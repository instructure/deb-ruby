--- a/lib/net/smtp.rb
+++ b/lib/net/smtp.rb
@@ -146,8 +146,8 @@
   # The SMTP server will judge whether it should send or reject
   # the SMTP session by inspecting the HELO domain.
   #
-  #     Net::SMTP.start('your.smtp.server', 25,
-  #                     'mail.from.domain') { |smtp| ... }
+  #     Net::SMTP.start('your.smtp.server', 25
+  #                     helo: 'mail.from.domain') { |smtp| ... }
   #
   # === SMTP Authentication
   #
@@ -157,17 +157,18 @@
   # SMTP.start/SMTP#start.
   #
   #     # PLAIN
-  #     Net::SMTP.start('your.smtp.server', 25, 'mail.from.domain',
-  #                     'Your Account', 'Your Password', :plain)
+  #     Net::SMTP.start('your.smtp.server', 25
+  #                     user: 'Your Account', secret: 'Your Password', authtype: :plain)
   #     # LOGIN
-  #     Net::SMTP.start('your.smtp.server', 25, 'mail.from.domain',
-  #                     'Your Account', 'Your Password', :login)
+  #     Net::SMTP.start('your.smtp.server', 25
+  #                     user: 'Your Account', secret: 'Your Password', authtype: :login)
   #
   #     # CRAM MD5
-  #     Net::SMTP.start('your.smtp.server', 25, 'mail.from.domain',
-  #                     'Your Account', 'Your Password', :cram_md5)
+  #     Net::SMTP.start('your.smtp.server', 25
+  #                     user: 'Your Account', secret: 'Your Password', authtype: :cram_md5)
   #
   class SMTP < Protocol
+    VERSION = "0.2.0"
 
     Revision = %q$Revision$.split[1]
 
@@ -190,8 +191,13 @@
       alias default_ssl_port default_tls_port
     end
 
-    def SMTP.default_ssl_context
-      OpenSSL::SSL::SSLContext.new
+    def SMTP.default_ssl_context(verify_peer=true)
+      context = OpenSSL::SSL::SSLContext.new
+      context.verify_mode = verify_peer ? OpenSSL::SSL::VERIFY_PEER : OpenSSL::SSL::VERIFY_NONE
+      store = OpenSSL::X509::Store.new
+      store.set_default_paths
+      context.cert_store = store
+      context
     end
 
     #
@@ -217,8 +223,9 @@
       @error_occurred = false
       @debug_output = nil
       @tls = false
-      @starttls = false
-      @ssl_context = nil
+      @starttls = :auto
+      @ssl_context_tls = nil
+      @ssl_context_starttls = nil
     end
 
     # Provide human-readable stringification of class state.
@@ -293,11 +300,11 @@
     # Enables SMTP/TLS (SMTPS: SMTP over direct TLS connection) for
     # this object.  Must be called before the connection is established
     # to have any effect.  +context+ is a OpenSSL::SSL::SSLContext object.
-    def enable_tls(context = SMTP.default_ssl_context)
+    def enable_tls(context = nil)
       raise 'openssl library not installed' unless defined?(OpenSSL)
-      raise ArgumentError, "SMTPS and STARTTLS is exclusive" if @starttls
+      raise ArgumentError, "SMTPS and STARTTLS is exclusive" if @starttls == :always
       @tls = true
-      @ssl_context = context
+      @ssl_context_tls = context
     end
 
     alias enable_ssl enable_tls
@@ -306,7 +313,7 @@
     # connection is established to have any effect.
     def disable_tls
       @tls = false
-      @ssl_context = nil
+      @ssl_context_tls = nil
     end
 
     alias disable_ssl disable_tls
@@ -330,27 +337,27 @@
 
     # Enables SMTP/TLS (STARTTLS) for this object.
     # +context+ is a OpenSSL::SSL::SSLContext object.
-    def enable_starttls(context = SMTP.default_ssl_context)
+    def enable_starttls(context = nil)
       raise 'openssl library not installed' unless defined?(OpenSSL)
       raise ArgumentError, "SMTPS and STARTTLS is exclusive" if @tls
       @starttls = :always
-      @ssl_context = context
+      @ssl_context_starttls = context
     end
 
     # Enables SMTP/TLS (STARTTLS) for this object if server accepts.
     # +context+ is a OpenSSL::SSL::SSLContext object.
-    def enable_starttls_auto(context = SMTP.default_ssl_context)
+    def enable_starttls_auto(context = nil)
       raise 'openssl library not installed' unless defined?(OpenSSL)
       raise ArgumentError, "SMTPS and STARTTLS is exclusive" if @tls
       @starttls = :auto
-      @ssl_context = context
+      @ssl_context_starttls = context
     end
 
     # Disables SMTP/TLS (STARTTLS) for this object.  Must be called
     # before the connection is established to have any effect.
     def disable_starttls
       @starttls = false
-      @ssl_context = nil
+      @ssl_context_starttls = nil
     end
 
     # The address of the SMTP server to connect to.
@@ -401,11 +408,15 @@
     #
 
     #
+    # :call-seq:
+    #  start(address, port = nil, helo: 'localhost', user: nil, secret: nil, authtype: nil, tls_verify: true, tls_hostname: nil) { |smtp| ... }
+    #  start(address, port = nil, helo = 'localhost', user = nil, secret = nil, authtype = nil) { |smtp| ... }
+    #
     # Creates a new Net::SMTP object and connects to the server.
     #
     # This method is equivalent to:
     #
-    #   Net::SMTP.new(address, port).start(helo_domain, account, password, authtype)
+    #   Net::SMTP.new(address, port).start(helo: helo_domain, user: account, secret: password, authtype: authtype, tls_verify: flag, tls_hostname: hostname)
     #
     # === Example
     #
@@ -435,6 +446,9 @@
     # or other authentication token; and +authtype+ is the authentication
     # type, one of :plain, :login, or :cram_md5.  See the discussion of
     # SMTP Authentication in the overview notes.
+    # If +tls_verify+ is true, verify the server's certificate. The default is true.
+    # If the hostname in the server certificate is different from +address+,
+    # it can be specified with +tls_hostname+.
     #
     # === Errors
     #
@@ -449,10 +463,16 @@
     # * Net::ReadTimeout
     # * IOError
     #
-    def SMTP.start(address, port = nil, helo = 'localhost',
-                   user = nil, secret = nil, authtype = nil,
-                   &block)   # :yield: smtp
-      new(address, port).start(helo, user, secret, authtype, &block)
+    def SMTP.start(address, port = nil, *args, helo: nil,
+                   user: nil, secret: nil, password: nil, authtype: nil,
+                   tls_verify: true, tls_hostname: nil,
+                   &block)
+      raise ArgumentError, "wrong number of arguments (given #{args.size + 2}, expected 1..6)" if args.size > 4
+      helo ||= args[0] || 'localhost'
+      user ||= args[1]
+      secret ||= password || args[2]
+      authtype ||= args[3]
+      new(address, port).start(helo: helo, user: user, secret: secret, authtype: authtype, tls_verify: tls_verify, tls_hostname: tls_hostname, &block)
     end
 
     # +true+ if the SMTP session has been started.
@@ -461,6 +481,10 @@
     end
 
     #
+    # :call-seq:
+    #  start(helo: 'localhost', user: nil, secret: nil, authtype: nil, tls_verify: true, tls_hostname: nil) { |smtp| ... }
+    #  start(helo = 'localhost', user = nil, secret = nil, authtype = nil) { |smtp| ... }
+    #
     # Opens a TCP connection and starts the SMTP session.
     #
     # === Parameters
@@ -473,6 +497,9 @@
     # the type of authentication to attempt; it must be one of
     # :login, :plain, and :cram_md5.  See the notes on SMTP Authentication
     # in the overview.
+    # If +tls_verify+ is true, verify the server's certificate. The default is true.
+    # If the hostname in the server certificate is different from +address+,
+    # it can be specified with +tls_hostname+.
     #
     # === Block Usage
     #
@@ -487,7 +514,7 @@
     #
     #     require 'net/smtp'
     #     smtp = Net::SMTP.new('smtp.mail.server', 25)
-    #     smtp.start(helo_domain, account, password, authtype) do |smtp|
+    #     smtp.start(helo: helo_domain, user: account, secret: password, authtype: authtype) do |smtp|
     #       smtp.send_message msgstr, 'from@example.com', ['dest@example.com']
     #     end
     #
@@ -511,8 +538,20 @@
     # * Net::ReadTimeout
     # * IOError
     #
-    def start(helo = 'localhost',
-              user = nil, secret = nil, authtype = nil)   # :yield: smtp
+    def start(*args, helo: nil,
+              user: nil, secret: nil, password: nil, authtype: nil, tls_verify: true, tls_hostname: nil)
+      raise ArgumentError, "wrong number of arguments (given #{args.size}, expected 0..4)" if args.size > 4
+      helo ||= args[0] || 'localhost'
+      user ||= args[1]
+      secret ||= password || args[2]
+      authtype ||= args[3]
+      if @tls && @ssl_context_tls.nil?
+        @ssl_context_tls = SMTP.default_ssl_context(tls_verify)
+      end
+      if @starttls && @ssl_context_starttls.nil?
+        @ssl_context_starttls = SMTP.default_ssl_context(tls_verify)
+      end
+      @tls_hostname = tls_hostname
       if block_given?
         begin
           do_start helo, user, secret, authtype
@@ -549,16 +588,16 @@
         tcp_socket(@address, @port)
       end
       logging "Connection opened: #{@address}:#{@port}"
-      @socket = new_internet_message_io(tls? ? tlsconnect(s) : s)
+      @socket = new_internet_message_io(tls? ? tlsconnect(s, @ssl_context_tls) : s)
       check_response critical { recv_response() }
       do_helo helo_domain
-      if starttls_always? or (capable_starttls? and starttls_auto?)
+      if ! tls? and (starttls_always? or (capable_starttls? and starttls_auto?))
         unless capable_starttls?
           raise SMTPUnsupportedCommand,
               "STARTTLS is not supported on this server"
         end
         starttls
-        @socket = new_internet_message_io(tlsconnect(s))
+        @socket = new_internet_message_io(tlsconnect(s, @ssl_context_starttls))
         # helo response may be different after STARTTLS
         do_helo helo_domain
       end
@@ -576,14 +615,15 @@
       OpenSSL::SSL::SSLSocket.new socket, context
     end
 
-    def tlsconnect(s)
+    def tlsconnect(s, context)
       verified = false
-      s = ssl_socket(s, @ssl_context)
+      s = ssl_socket(s, context)
       logging "TLS connection started"
       s.sync_close = true
+      s.hostname = @tls_hostname || @address if s.respond_to? :hostname=
       ssl_socket_connect(s, @open_timeout)
-      if @ssl_context.verify_mode != OpenSSL::SSL::VERIFY_NONE
-        s.post_connection_check(@address)
+      if context.verify_mode && context.verify_mode != OpenSSL::SSL::VERIFY_NONE
+        s.post_connection_check(@tls_hostname || @address)
       end
       verified = true
       s
@@ -1042,7 +1082,7 @@
         return {} unless @string[3, 1] == '-'
         h = {}
         @string.lines.drop(1).each do |line|
-          k, *v = line[4..-1].chomp.split
+          k, *v = line[4..-1].split(' ')
           h[k] = v
         end
         h
--- a/lib/net/smtp/net-smtp.gemspec
+++ b/lib/net/smtp/net-smtp.gemspec
@@ -1,12 +1,15 @@
-begin
-  require_relative "lib/net/smtp/version"
-rescue LoadError # Fallback to load version file in ruby core repository
-  require_relative "version"
+# frozen_string_literal: true
+
+name = File.basename(__FILE__, ".gemspec")
+version = ["lib", Array.new(name.count("-")+1, "..").join("/")].find do |dir|
+  break File.foreach(File.join(__dir__, dir, "#{name.tr('-', '/')}.rb")) do |line|
+    /^\s*VERSION\s*=\s*"(.*)"/ =~ line and break $1
+  end rescue nil
 end
 
 Gem::Specification.new do |spec|
-  spec.name          = "net-smtp"
-  spec.version       = Net::SMTP::VERSION
+  spec.name          = name
+  spec.version       = version
   spec.authors       = ["Yukihiro Matsumoto"]
   spec.email         = ["matz@ruby-lang.org"]
 
@@ -14,6 +17,7 @@
   spec.description   = %q{Simple Mail Transfer Protocol client library for Ruby.}
   spec.homepage      = "https://github.com/ruby/net-smtp"
   spec.license       = "BSD-2-Clause"
+  spec.required_ruby_version = ">= 2.5.0"
 
   spec.metadata["homepage_uri"] = spec.homepage
   spec.metadata["source_code_uri"] = spec.homepage
--- a/test/net/smtp/test_smtp.rb
+++ b/test/net/smtp/test_smtp.rb
@@ -129,7 +129,7 @@
         smtp = Net::SMTP.new("localhost", servers[0].local_address.ip_port)
         smtp.enable_tls
         smtp.open_timeout = 1
-        smtp.start do
+        smtp.start(tls_verify: false) do
         end
       ensure
         sock.close if sock
@@ -184,17 +184,99 @@
       end
     end
 
+    def test_start
+      port = fake_server_start
+      smtp = Net::SMTP.start('localhost', port)
+      smtp.quit
+    end
+
+    def test_start_with_position_argument
+      port = fake_server_start(helo: 'myname', user: 'account', password: 'password')
+      smtp = Net::SMTP.start('localhost', port, 'myname', 'account', 'password', :plain)
+      smtp.quit
+    end
+
+    def test_start_with_keyword_argument
+      port = fake_server_start(helo: 'myname', user: 'account', password: 'password')
+      smtp = Net::SMTP.start('localhost', port, helo: 'myname', user: 'account', secret: 'password', authtype: :plain)
+      smtp.quit
+    end
+
+    def test_start_password_is_secret
+      port = fake_server_start(helo: 'myname', user: 'account', password: 'password')
+      smtp = Net::SMTP.start('localhost', port, helo: 'myname', user: 'account', password: 'password', authtype: :plain)
+      smtp.quit
+    end
+
+    def test_start_invalid_number_of_arguments
+      err = assert_raise ArgumentError do
+        Net::SMTP.start('localhost', 25, 'myname', 'account', 'password', :plain, :invalid_arg)
+      end
+      assert_equal('wrong number of arguments (given 7, expected 1..6)', err.message)
+    end
+
+    def test_start_instance
+      port = fake_server_start
+      smtp = Net::SMTP.new('localhost', port)
+      smtp.start
+      smtp.quit
+    end
+
+    def test_start_instance_with_position_argument
+      port = fake_server_start(helo: 'myname', user: 'account', password: 'password')
+      smtp = Net::SMTP.new('localhost', port)
+      smtp.start('myname', 'account', 'password', :plain)
+      smtp.quit
+    end
+
+    def test_start_instance_with_keyword_argument
+      port = fake_server_start(helo: 'myname', user: 'account', password: 'password')
+      smtp = Net::SMTP.new('localhost', port)
+      smtp.start(helo: 'myname', user: 'account', secret: 'password', authtype: :plain)
+      smtp.quit
+    end
+
+    def test_start_instance_password_is_secret
+      port = fake_server_start(helo: 'myname', user: 'account', password: 'password')
+      smtp = Net::SMTP.new('localhost', port)
+      smtp.start(helo: 'myname', user: 'account', password: 'password', authtype: :plain)
+      smtp.quit
+    end
+
+    def test_start_instance_invalid_number_of_arguments
+      smtp = Net::SMTP.new('localhost')
+      err = assert_raise ArgumentError do
+        smtp.start('myname', 'account', 'password', :plain, :invalid_arg)
+      end
+      assert_equal('wrong number of arguments (given 5, expected 0..4)', err.message)
+    end
+
     private
 
     def accept(servers)
-      loop do
-        readable, = IO.select(servers.map(&:to_io))
-        readable.each do |r|
-          sock, = r.accept_nonblock(exception: false)
-          next if sock == :wait_readable
-          return sock
-        end
+      Socket.accept_loop(servers) { |s, _| break s }
+    end
+
+    def fake_server_start(helo: 'localhost', user: nil, password: nil)
+      servers = Socket.tcp_server_sockets('localhost', 0)
+      Thread.start do
+        Thread.current.abort_on_exception = true
+        sock = accept(servers)
+        sock.puts "220 ready\r\n"
+        assert_equal("EHLO #{helo}\r\n", sock.gets)
+        sock.puts "220-servername\r\n220 AUTH PLAIN\r\n"
+        if user
+          credential = ["\0#{user}\0#{password}"].pack('m0')
+          assert_equal("AUTH PLAIN #{credential}\r\n", sock.gets)
+          sock.puts "235 2.7.0 Authentication successful\r\n"
+        end
+        assert_equal("QUIT\r\n", sock.gets)
+        sock.puts "221 2.0.0 Bye\r\n"
+        sock.close
+        servers.each(&:close)
       end
+      port = servers[0].local_address.ip_port
+      return port
     end
   end
 end
--- a/test/net/smtp/test_ssl_socket.rb
+++ b/test/net/smtp/test_ssl_socket.rb
@@ -53,8 +53,10 @@
         end
       }
 
+      ssl_context = OpenSSL::SSL::SSLContext.new
+      ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER
       connection = MySMTP.new('localhost', 25)
-      connection.enable_starttls_auto
+      connection.enable_starttls_auto(ssl_context)
       connection.fake_tcp = tcp_socket
       connection.fake_ssl = ssl_socket
 
--- /dev/null
+++ b/test/net/smtp/test_sslcontext.rb
@@ -0,0 +1,128 @@
+require 'net/smtp'
+require 'test/unit'
+
+module Net
+  class TestSSLContext < Test::Unit::TestCase
+    class MySMTP < SMTP
+      attr_reader :__ssl_context, :__tls_hostname
+
+      def initialize(socket)
+        @fake_socket = socket
+        super("smtp.example.com")
+      end
+
+      def tcp_socket(*)
+        @fake_socket
+      end
+
+      def ssl_socket_connect(*)
+      end
+
+      def tlsconnect(*)
+        super
+        @fake_socket
+      end
+
+      def ssl_socket(socket, context)
+        @__ssl_context = context
+        s = super
+        hostname = @__tls_hostname = ''
+        s.define_singleton_method(:post_connection_check){ |name| hostname.replace(name) }
+        s
+      end
+    end
+
+    def teardown
+      @server_thread&.exit
+      @server_socket&.close
+      @client_socket&.close
+    end
+
+    def start_smtpd(starttls)
+      @server_socket, @client_socket = UNIXSocket.pair
+      @starttls_executed = false
+      @server_thread = Thread.new(@server_socket) do |s|
+        s.puts "220 fakeserver\r\n"
+        while cmd = s.gets&.chomp
+          case cmd
+          when /\AEHLO /
+            s.puts "250-fakeserver\r\n"
+            s.puts "250-STARTTLS\r\n" if starttls
+            s.puts "250 8BITMIME\r\n"
+          when /\ASTARTTLS/
+            @starttls_executed = true
+            s.puts "220 2.0.0 Ready to start TLS\r\n"
+          else
+            raise "unsupported command: #{cmd}"
+          end
+        end
+      end
+      @client_socket
+    end
+
+    def test_default
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.start
+      assert_equal(OpenSSL::SSL::VERIFY_PEER, smtp.__ssl_context.verify_mode)
+    end
+
+    def test_enable_tls
+      smtp = MySMTP.new(start_smtpd(true))
+      context = OpenSSL::SSL::SSLContext.new
+      smtp.enable_tls(context)
+      smtp.start
+      assert_equal(context, smtp.__ssl_context)
+    end
+
+    def test_enable_tls_before_disable_starttls
+      smtp = MySMTP.new(start_smtpd(true))
+      context = OpenSSL::SSL::SSLContext.new
+      smtp.enable_tls(context)
+      smtp.disable_starttls
+      smtp.start
+      assert_equal(context, smtp.__ssl_context)
+    end
+
+    def test_enable_starttls
+      smtp = MySMTP.new(start_smtpd(true))
+      context = OpenSSL::SSL::SSLContext.new
+      smtp.enable_starttls(context)
+      smtp.start
+      assert_equal(context, smtp.__ssl_context)
+    end
+
+    def test_enable_starttls_before_disable_tls
+      smtp = MySMTP.new(start_smtpd(true))
+      context = OpenSSL::SSL::SSLContext.new
+      smtp.enable_starttls(context)
+      smtp.disable_tls
+      smtp.start
+      assert_equal(context, smtp.__ssl_context)
+    end
+
+    def test_start_with_tls_verify_true
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.start(tls_verify: true)
+      assert_equal(OpenSSL::SSL::VERIFY_PEER, smtp.__ssl_context.verify_mode)
+    end
+
+    def test_start_with_tls_verify_false
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.start(tls_verify: false)
+      assert_equal(OpenSSL::SSL::VERIFY_NONE, smtp.__ssl_context.verify_mode)
+    end
+
+    def test_start_with_tls_hostname
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.start(tls_hostname: "localhost")
+      assert_equal("localhost", smtp.__tls_hostname)
+    end
+
+    def test_start_without_tls_hostname
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.start
+      assert_equal("smtp.example.com", smtp.__tls_hostname)
+    end
+
+  end
+end
--- /dev/null
+++ b/test/net/smtp/test_starttls.rb
@@ -0,0 +1,121 @@
+require 'net/smtp'
+require 'test/unit'
+
+module Net
+  class TestStarttls < Test::Unit::TestCase
+    class MySMTP < SMTP
+      def initialize(socket)
+        @fake_socket = socket
+        super("smtp.example.com")
+      end
+
+      def tcp_socket(*)
+        @fake_socket
+      end
+
+      def tlsconnect(*)
+        @fake_socket
+      end
+    end
+
+    def teardown
+      @server_thread&.exit
+      @server_socket&.close
+      @client_socket&.close
+    end
+
+    def start_smtpd(starttls)
+      @server_socket, @client_socket = UNIXSocket.pair
+      @starttls_executed = false
+      @server_thread = Thread.new(@server_socket) do |s|
+        s.puts "220 fakeserver\r\n"
+        while cmd = s.gets&.chomp
+          case cmd
+          when /\AEHLO /
+            s.puts "250-fakeserver\r\n"
+            s.puts "250-STARTTLS\r\n" if starttls
+            s.puts "250 8BITMIME\r\n"
+          when /\ASTARTTLS/
+            @starttls_executed = true
+            s.puts "220 2.0.0 Ready to start TLS\r\n"
+          else
+            raise "unsupported command: #{cmd}"
+          end
+        end
+      end
+      @client_socket
+    end
+
+    def test_default_with_starttls_capable
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.start
+      assert(@starttls_executed)
+    end
+
+    def test_default_without_starttls_capable
+      smtp = MySMTP.new(start_smtpd(false))
+      smtp.start
+      assert(!@starttls_executed)
+    end
+
+    def test_enable_starttls_with_starttls_capable
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.enable_starttls
+      smtp.start
+      assert(@starttls_executed)
+    end
+
+    def test_enable_starttls_without_starttls_capable
+      smtp = MySMTP.new(start_smtpd(false))
+      smtp.enable_starttls
+      err = assert_raise(Net::SMTPUnsupportedCommand) { smtp.start }
+      assert_equal("STARTTLS is not supported on this server", err.message)
+    end
+
+    def test_enable_starttls_auto_with_starttls_capable
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.enable_starttls_auto
+      smtp.start
+      assert(@starttls_executed)
+    end
+
+    def test_tls_with_starttls_capable
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.enable_tls
+      smtp.start
+      assert(!@starttls_executed)
+    end
+
+    def test_tls_without_starttls_capable
+      smtp = MySMTP.new(start_smtpd(false))
+      smtp.enable_tls
+    end
+
+    def test_disable_starttls
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.disable_starttls
+      smtp.start
+      assert(!@starttls_executed)
+    end
+
+    def test_enable_tls_and_enable_starttls
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.enable_tls
+      err = assert_raise(ArgumentError) { smtp.enable_starttls }
+      assert_equal("SMTPS and STARTTLS is exclusive", err.message)
+    end
+
+    def test_enable_tls_and_enable_starttls_auto
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.enable_tls
+      err = assert_raise(ArgumentError) { smtp.enable_starttls_auto }
+      assert_equal("SMTPS and STARTTLS is exclusive", err.message)
+    end
+
+    def test_enable_starttls_and_enable_starttls_auto
+      smtp = MySMTP.new(start_smtpd(true))
+      smtp.enable_starttls
+      assert_nothing_raised { smtp.enable_starttls_auto }
+    end
+  end
+end
