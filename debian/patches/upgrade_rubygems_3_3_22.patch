--- ruby2.7-2.7.6.orig/lib/rubygems.rb
+++ ruby2.7-2.7.6/lib/rubygems.rb
@@ -1,23 +1,22 @@
 # frozen_string_literal: true
-# -*- ruby -*-
 #--
 # Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.
 # All rights reserved.
 # See LICENSE.txt for permissions.
 #++
 
-require 'rbconfig'
+require "rbconfig"
 
 module Gem
-  VERSION = "3.1.6".freeze
+  VERSION = "3.3.22".freeze
 end
 
 # Must be first since it unloads the prelude from 1.9.2
-require 'rubygems/compatibility'
+require_relative "rubygems/compatibility"
 
-require 'rubygems/defaults'
-require 'rubygems/deprecate'
-require 'rubygems/errors'
+require_relative "rubygems/defaults"
+require_relative "rubygems/deprecate"
+require_relative "rubygems/errors"
 
 ##
 # RubyGems is the Ruby standard for publishing and managing third party
@@ -43,13 +42,13 @@ require 'rubygems/errors'
 #
 # == RubyGems Plugins
 #
-# As of RubyGems 1.3.2, RubyGems will load plugins installed in gems or
+# RubyGems will load plugins in the latest version of each installed gem or
 # $LOAD_PATH.  Plugins must be named 'rubygems_plugin' (.rb, .so, etc) and
-# placed at the root of your gem's #require_path.  Plugins are discovered via
-# Gem::find_files and then loaded.
+# placed at the root of your gem's #require_path.  Plugins are installed at a
+# special location and loaded on boot.
 #
 # For an example plugin, see the {Graph gem}[https://github.com/seattlerb/graph]
-# which adds a `gem graph` command.
+# which adds a <tt>gem graph</tt> command.
 #
 # == RubyGems Defaults, Packaging
 #
@@ -113,12 +112,16 @@ require 'rubygems/errors'
 # -The RubyGems Team
 
 module Gem
-  RUBYGEMS_DIR = File.dirname File.expand_path(__FILE__)
+  RUBYGEMS_DIR = __dir__
 
   # Taint support is deprecated in Ruby 2.7.
   # This allows switching ".untaint" to ".tap(&Gem::UNTAINT)",
   # to avoid deprecation warnings in Ruby 2.7.
-  UNTAINT = RUBY_VERSION < '2.7' ? :untaint.to_sym : proc{}
+  UNTAINT = RUBY_VERSION < "2.7" ? :untaint.to_sym : proc {}
+
+  # When https://bugs.ruby-lang.org/issues/17259 is available, there is no need to override Kernel#warn
+  KERNEL_WARN_IGNORES_INTERNAL_ENTRIES = RUBY_ENGINE == "truffleruby" ||
+                                         (RUBY_ENGINE == "ruby" && RUBY_VERSION >= "3.0")
 
   ##
   # An Array of Regexps that match windows Ruby platforms.
@@ -148,6 +151,7 @@ module Gem
     doc
     extensions
     gems
+    plugins
     specifications
   ].freeze
 
@@ -159,22 +163,12 @@ module Gem
     specifications/default
   ].freeze
 
-  ##
-  # Exception classes used in a Gem.read_binary +rescue+ statement
-
-  READ_BINARY_ERRORS = [Errno::EACCES, Errno::EROFS, Errno::ENOSYS, Errno::ENOTSUP].freeze
-
-  ##
-  # Exception classes used in Gem.write_binary +rescue+ statement
-
-  WRITE_BINARY_ERRORS = [Errno::ENOSYS, Errno::ENOTSUP].freeze
-
   @@win_platform = nil
 
   @configuration = nil
   @gemdeps = nil
   @loaded_specs = {}
-  LOADED_SPECS_MUTEX = Mutex.new
+  LOADED_SPECS_MUTEX = Thread::Mutex.new
   @path_to_default_spec_map = {}
   @platforms = []
   @ruby = nil
@@ -245,9 +239,6 @@ module Gem
   # you to specify specific gem versions.
 
   def self.bin_path(name, exec_name = nil, *requirements)
-    # TODO: fails test_self_bin_path_bin_file_gone_in_latest
-    # Gem::Specification.find_by_name(name, *requirements).bin_file exec_name
-
     requirements = Gem::Requirement.default if
       requirements.empty?
 
@@ -271,9 +262,6 @@ module Gem
 
     unless spec = specs.first
       msg = "can't find gem #{dep} with executable #{exec_name}"
-      if name == "bundler" && bundler_message = Gem::BundlerVersionFinder.missing_version_message
-        msg = bundler_message
-      end
       raise Gem::GemNotFoundException, msg
     end
 
@@ -305,19 +293,26 @@ module Gem
   # The mode needed to read a file as straight binary.
 
   def self.binary_mode
-    'rb'
+    "rb"
   end
 
   ##
   # The path where gem executables are to be installed.
 
   def self.bindir(install_dir=Gem.dir)
-    return File.join install_dir, 'bin' unless
+    return File.join install_dir, "bin" unless
       install_dir.to_s == Gem.default_dir.to_s
     Gem.default_bindir
   end
 
   ##
+  # The path were rubygems plugins are to be installed.
+
+  def self.plugindir(install_dir=Gem.dir)
+    File.join install_dir, "plugins"
+  end
+
+  ##
   # Reset the +dir+ and +path+ values.  The next time +dir+ or +path+
   # is requested, the values will be calculated from scratch.  This is
   # mainly used by the unit tests to provide test isolation.
@@ -330,13 +325,6 @@ module Gem
   end
 
   ##
-  # The path to standard location of the user's .gemrc file.
-
-  def self.config_file
-    @config_file ||= File.join Gem.user_home, '.gemrc'
-  end
-
-  ##
   # The standard configuration object for gems.
 
   def self.configuration
@@ -365,7 +353,7 @@ module Gem
   # A Zlib::Deflate.deflate wrapper
 
   def self.deflate(data)
-    require 'zlib'
+    require "zlib"
     Zlib::Deflate.deflate data
   end
 
@@ -387,17 +375,17 @@ module Gem
     target = {}
     env.each_pair do |k,v|
       case k
-      when 'GEM_HOME', 'GEM_PATH', 'GEM_SPEC_CACHE'
+      when "GEM_HOME", "GEM_PATH", "GEM_SPEC_CACHE"
         case v
         when nil, String
           target[k] = v
         when Array
           unless Gem::Deprecate.skip
-            warn <<-eowarn
+            warn <<-EOWARN
 Array values in the parameter to `Gem.paths=` are deprecated.
 Please use a String or nil.
 An Array (#{env.inspect}) was passed in from #{caller[3]}
-            eowarn
+            EOWARN
           end
           target[k] = v.join File::PATH_SEPARATOR
         end
@@ -411,8 +399,6 @@ An Array (#{env.inspect}) was passed in 
 
   ##
   # The path where gems are to be installed.
-  #--
-  # FIXME deprecate these once everything else has been done -ebh
 
   def self.dir
     paths.home
@@ -456,8 +442,6 @@ An Array (#{env.inspect}) was passed in 
     old_umask = File.umask
     File.umask old_umask | 002
 
-    require 'fileutils'
-
     options = {}
 
     options[:mode] = mode if mode
@@ -465,7 +449,13 @@ An Array (#{env.inspect}) was passed in 
     subdirs.each do |name|
       subdir = File.join dir, name
       next if File.exist? subdir
-      FileUtils.mkdir_p subdir, **options rescue nil
+
+      require "fileutils"
+
+      begin
+        FileUtils.mkdir_p subdir, **options
+      rescue SystemCallError
+      end
     end
   ensure
     File.umask old_umask
@@ -476,7 +466,7 @@ An Array (#{env.inspect}) was passed in 
   # distinction as extensions cannot be shared between the two.
 
   def self.extension_api_version # :nodoc:
-    if 'no' == RbConfig::CONFIG['ENABLE_SHARED']
+    if "no" == RbConfig::CONFIG["ENABLE_SHARED"]
       "#{ruby_api_version}-static"
     else
       ruby_api_version
@@ -502,7 +492,7 @@ An Array (#{env.inspect}) was passed in 
 
     gem_specifications = @gemdeps ? Gem.loaded_specs.values : Gem::Specification.stubs
 
-    files.concat gem_specifications.map { |spec|
+    files.concat gem_specifications.map {|spec|
       spec.matches_for_glob("#{glob}#{Gem.suffix_pattern}")
     }.flatten
 
@@ -517,7 +507,7 @@ An Array (#{env.inspect}) was passed in 
     glob_with_suffixes = "#{glob}#{Gem.suffix_pattern}"
     $LOAD_PATH.map do |load_path|
       Gem::Util.glob_files_in_dir(glob_with_suffixes, load_path)
-    end.flatten.select { |file| File.file? file.tap(&Gem::UNTAINT) }
+    end.flatten.select {|file| File.file? file.tap(&Gem::UNTAINT) }
   end
 
   ##
@@ -537,7 +527,7 @@ An Array (#{env.inspect}) was passed in 
 
     files = find_files_from_load_path glob if check_load_path
 
-    files.concat Gem::Specification.latest_specs(true).map { |spec|
+    files.concat Gem::Specification.latest_specs(true).map {|spec|
       spec.matches_for_glob("#{glob}#{Gem.suffix_pattern}")
     }.flatten
 
@@ -549,86 +539,15 @@ An Array (#{env.inspect}) was passed in 
   end
 
   ##
-  # Finds the user's home directory.
-  #--
-  # Some comments from the ruby-talk list regarding finding the home
-  # directory:
-  #
-  #   I have HOME, USERPROFILE and HOMEDRIVE + HOMEPATH. Ruby seems
-  #   to be depending on HOME in those code samples. I propose that
-  #   it should fallback to USERPROFILE and HOMEDRIVE + HOMEPATH (at
-  #   least on Win32).
-  #++
-  #--
-  #
-  #++
-
-  def self.find_home
-    Dir.home.dup
-  rescue
-    if Gem.win_platform?
-      File.expand_path File.join(ENV['HOMEDRIVE'] || ENV['SystemDrive'], '/')
-    else
-      File.expand_path "/"
-    end
-  end
-
-  private_class_method :find_home
-
-  # TODO:  remove in RubyGems 4.0
-
-  ##
-  # Zlib::GzipReader wrapper that unzips +data+.
-
-  def self.gunzip(data)
-    Gem::Util.gunzip data
-  end
-
-  class << self
-
-    extend Gem::Deprecate
-    deprecate :gunzip, "Gem::Util.gunzip", 2018, 12
-
-  end
-
-  ##
-  # Zlib::GzipWriter wrapper that zips +data+.
-
-  def self.gzip(data)
-    Gem::Util.gzip data
-  end
-
-  class << self
-
-    extend Gem::Deprecate
-    deprecate :gzip, "Gem::Util.gzip", 2018, 12
-
-  end
-
-  ##
-  # A Zlib::Inflate#inflate wrapper
-
-  def self.inflate(data)
-    Gem::Util.inflate data
-  end
-
-  class << self
-
-    extend Gem::Deprecate
-    deprecate :inflate, "Gem::Util.inflate", 2018, 12
-
-  end
-
-  ##
   # Top level install helper method. Allows you to install gems interactively:
   #
   #   % irb
   #   >> Gem.install "minitest"
-  #   Fetching: minitest-3.0.1.gem (100%)
+  #   Fetching: minitest-5.14.0.gem (100%)
   #   => [#<Gem::Specification:0x1013b4528 @name="minitest", ...>]
 
   def self.install(name, version = Gem::Requirement.default, *options)
-    require "rubygems/dependency_installer"
+    require_relative "rubygems/dependency_installer"
     inst = Gem::DependencyInstaller.new(*options)
     inst.install name, version
     inst.installed_gems
@@ -657,14 +576,14 @@ An Array (#{env.inspect}) was passed in 
       return i if path.instance_variable_defined?(:@gem_prelude_index)
     end
 
-    index = $LOAD_PATH.index RbConfig::CONFIG['sitelibdir']
+    index = $LOAD_PATH.index RbConfig::CONFIG["sitelibdir"]
 
     index || 0
   end
 
   ##
-  # The number of paths in the `$LOAD_PATH` from activated gems. Used to
-  # prioritize `-I` and `ENV['RUBYLIB`]` entries during `require`.
+  # The number of paths in the +$LOAD_PATH+ from activated gems. Used to
+  # prioritize +-I+ and +ENV['RUBYLIB']+ entries during +require+.
 
   def self.activated_gem_paths
     @activated_gem_paths ||= 0
@@ -687,37 +606,11 @@ An Array (#{env.inspect}) was passed in 
 
   def self.load_yaml
     return if @yaml_loaded
-    return unless defined?(gem)
-
-    begin
-      gem 'psych', '>= 2.0.0'
-    rescue Gem::LoadError
-      # It's OK if the user does not have the psych gem installed.  We will
-      # attempt to require the stdlib version
-    end
-
-    begin
-      # Try requiring the gem version *or* stdlib version of psych.
-      require 'psych'
-    rescue ::LoadError
-      # If we can't load psych, thats fine, go on.
-    else
-      # If 'yaml' has already been required, then we have to
-      # be sure to switch it over to the newly loaded psych.
-      if defined?(YAML::ENGINE) && YAML::ENGINE.yamler != "psych"
-        YAML::ENGINE.yamler = "psych"
-      end
-
-      require 'rubygems/psych_additions'
-      require 'rubygems/psych_tree'
-    end
 
-    require 'yaml'
-    require 'rubygems/safe_yaml'
+    require "psych"
+    require_relative "rubygems/psych_tree"
 
-    # Now that we're sure some kind of yaml library is loaded, pull
-    # in our hack to deal with Syck's DefaultKey ugliness.
-    require 'rubygems/syck_hack'
+    require_relative "rubygems/safe_yaml"
 
     @yaml_loaded = true
   end
@@ -848,9 +741,9 @@ An Array (#{env.inspect}) was passed in 
   def self.prefix
     prefix = File.dirname RUBYGEMS_DIR
 
-    if prefix != File.expand_path(RbConfig::CONFIG['sitelibdir']) and
-       prefix != File.expand_path(RbConfig::CONFIG['libdir']) and
-       'lib' == File.basename(RUBYGEMS_DIR)
+    if prefix != File.expand_path(RbConfig::CONFIG["sitelibdir"]) &&
+       prefix != File.expand_path(RbConfig::CONFIG["libdir"]) &&
+       "lib" == File.basename(RUBYGEMS_DIR)
       prefix
     end
   end
@@ -866,40 +759,42 @@ An Array (#{env.inspect}) was passed in 
   # Safely read a file in binary mode on all platforms.
 
   def self.read_binary(path)
-    File.open path, 'rb+' do |f|
-      f.flock(File::LOCK_EX)
-      f.read
-    end
-  rescue *READ_BINARY_ERRORS
-    File.open path, 'rb' do |f|
-      f.read
+    open_file(path, "rb+") do |io|
+      io.read
     end
-  rescue Errno::ENOLCK # NFS
-    if Thread.main != Thread.current
-      raise
-    else
-      File.open path, 'rb' do |f|
-        f.read
-      end
+  rescue Errno::EACCES, Errno::EROFS
+    open_file(path, "rb") do |io|
+      io.read
     end
   end
 
   ##
   # Safely write a file in binary mode on all platforms.
   def self.write_binary(path, data)
-    open(path, 'wb') do |io|
-      begin
-        io.flock(File::LOCK_EX)
-      rescue *WRITE_BINARY_ERRORS
-      end
+    open_file(path, "wb") do |io|
       io.write data
     end
+  end
+
+  ##
+  # Open a file with given flags, and on Windows protect access with flock
+
+  def self.open_file(path, flags, &block)
+    File.open(path, flags) do |io|
+      if !java_platform? && win_platform?
+        begin
+          io.flock(File::LOCK_EX)
+        rescue Errno::ENOSYS, Errno::ENOTSUP
+        end
+      end
+      yield io
+    end
   rescue Errno::ENOLCK # NFS
     if Thread.main != Thread.current
       raise
     else
-      open(path, 'wb') do |io|
-        io.write data
+      File.open(path, flags) do |io|
+        yield io
       end
     end
   end
@@ -909,8 +804,7 @@ An Array (#{env.inspect}) was passed in 
 
   def self.ruby
     if @ruby.nil?
-      @ruby = File.join(RbConfig::CONFIG['bindir'],
-                        "#{RbConfig::CONFIG['ruby_install_name']}#{RbConfig::CONFIG['EXEEXT']}")
+      @ruby = RbConfig.ruby
 
       @ruby = "\"#{@ruby}\"" if @ruby =~ /\s/
     end
@@ -922,13 +816,13 @@ An Array (#{env.inspect}) was passed in 
   # Returns a String containing the API compatibility version of Ruby
 
   def self.ruby_api_version
-    @ruby_api_version ||= RbConfig::CONFIG['ruby_version'].dup
+    @ruby_api_version ||= RbConfig::CONFIG["ruby_version"].dup
   end
 
   def self.env_requirement(gem_name)
     @env_requirements_by_name ||= {}
     @env_requirements_by_name[gem_name] ||= begin
-      req = ENV["GEM_REQUIREMENT_#{gem_name.upcase}"] || '>= 0'.freeze
+      req = ENV["GEM_REQUIREMENT_#{gem_name.upcase}"] || ">= 0".freeze
       Gem::Requirement.create(req)
     end
   end
@@ -942,7 +836,7 @@ An Array (#{env.inspect}) was passed in 
     fetcher      = Gem::SpecFetcher.fetcher
     spec_tuples, = fetcher.spec_for_dependency dependency
 
-    spec, = spec_tuples.first
+    spec, = spec_tuples.last
 
     spec
   end
@@ -951,8 +845,8 @@ An Array (#{env.inspect}) was passed in 
   # Returns the latest release version of RubyGems.
 
   def self.latest_rubygems_version
-    latest_version_for('rubygems-update') or
-      raise "Can't find 'rubygems-update' in any repo. Check `gem source list`."
+    latest_version_for("rubygems-update") ||
+      raise("Can't find 'rubygems-update' in any repo. Check `gem source list`.")
   end
 
   ##
@@ -960,7 +854,7 @@ An Array (#{env.inspect}) was passed in 
 
   def self.latest_version_for(name)
     spec = latest_spec_for name
-    spec and spec.version
+    spec && spec.version
   end
 
   ##
@@ -970,9 +864,7 @@ An Array (#{env.inspect}) was passed in 
     return @ruby_version if defined? @ruby_version
     version = RUBY_VERSION.dup
 
-    if defined?(RUBY_PATCHLEVEL) && RUBY_PATCHLEVEL != -1
-      version << ".#{RUBY_PATCHLEVEL}"
-    elsif defined?(RUBY_DESCRIPTION)
+    unless defined?(RUBY_PATCHLEVEL) && RUBY_PATCHLEVEL != -1
       if RUBY_ENGINE == "ruby"
         desc = RUBY_DESCRIPTION[/\Aruby #{Regexp.quote(RUBY_VERSION)}([^ ]+) /, 1]
       else
@@ -1023,21 +915,38 @@ An Array (#{env.inspect}) was passed in 
     @suffix_pattern ||= "{#{suffixes.join(',')}}"
   end
 
+  ##
+  # Regexp for require-able path suffixes.
+
   def self.suffix_regexp
     @suffix_regexp ||= /#{Regexp.union(suffixes)}\z/
   end
 
   ##
+  # Glob pattern for require-able plugin suffixes.
+
+  def self.plugin_suffix_pattern
+    @plugin_suffix_pattern ||= "_plugin#{suffix_pattern}"
+  end
+
+  ##
+  # Regexp for require-able plugin suffixes.
+
+  def self.plugin_suffix_regexp
+    @plugin_suffix_regexp ||= /_plugin#{suffix_regexp}\z/
+  end
+
+  ##
   # Suffixes for require-able paths.
 
   def self.suffixes
-    @suffixes ||= ['',
-                   '.rb',
-                   *%w(DLEXT DLEXT2).map do |key|
+    @suffixes ||= ["",
+                   ".rb",
+                   *%w[DLEXT DLEXT2].map do |key|
                      val = RbConfig::CONFIG[key]
-                     next unless val and not val.empty?
+                     next unless val && !val.empty?
                      ".#{val}"
-                   end
+                   end,
                   ].compact.uniq
   end
 
@@ -1061,7 +970,7 @@ An Array (#{env.inspect}) was passed in 
   # Lazily loads DefaultUserInteraction and returns the default UI.
 
   def self.ui
-    require 'rubygems/user_interaction'
+    require_relative "rubygems/user_interaction"
 
     Gem::DefaultUserInteraction.ui
   end
@@ -1074,24 +983,17 @@ An Array (#{env.inspect}) was passed in 
     paths.flatten!
     paths.compact!
     hash = { "GEM_HOME" => home, "GEM_PATH" => paths.empty? ? home : paths.join(File::PATH_SEPARATOR) }
-    hash.delete_if { |_, v| v.nil? }
+    hash.delete_if {|_, v| v.nil? }
     self.paths = hash
   end
 
   ##
-  # The home directory for the user.
-
-  def self.user_home
-    @user_home ||= find_home.tap(&Gem::UNTAINT)
-  end
-
-  ##
   # Is this a windows platform?
 
   def self.win_platform?
     if @@win_platform.nil?
-      ruby_platform = RbConfig::CONFIG['host_os']
-      @@win_platform = !!WIN_PATTERNS.find { |r| ruby_platform =~ r }
+      ruby_platform = RbConfig::CONFIG["host_os"]
+      @@win_platform = !!WIN_PATTERNS.find {|r| ruby_platform =~ r }
     end
 
     @@win_platform
@@ -1105,11 +1007,17 @@ An Array (#{env.inspect}) was passed in 
   end
 
   ##
+  # Is this platform Solaris?
+
+  def self.solaris_platform?
+    RUBY_PLATFORM =~ /solaris/
+  end
+
+  ##
   # Load +plugins+ as Ruby files
 
   def self.load_plugin_files(plugins) # :nodoc:
     plugins.each do |plugin|
-
       # Skip older versions of the GemCutter plugin: Its commands are in
       # RubyGems proper now.
 
@@ -1125,15 +1033,11 @@ An Array (#{env.inspect}) was passed in 
   end
 
   ##
-  # Find the 'rubygems_plugin' files in the latest installed gems and load
-  # them
+  # Find rubygems plugin files in the standard location and load them
 
   def self.load_plugins
-    # Remove this env var by at least 3.0
-    if ENV['RUBYGEMS_LOAD_ALL_PLUGINS']
-      load_plugin_files find_files('rubygems_plugin', false)
-    else
-      load_plugin_files find_latest_files('rubygems_plugin', false)
+    Gem.path.each do |gem_path|
+      load_plugin_files Gem::Util.glob_files_in_dir("*#{Gem.plugin_suffix_pattern}", plugindir(gem_path))
     end
   end
 
@@ -1141,19 +1045,7 @@ An Array (#{env.inspect}) was passed in 
   # Find all 'rubygems_plugin' files in $LOAD_PATH and load them
 
   def self.load_env_plugins
-    path = "rubygems_plugin"
-
-    files = []
-    glob = "#{path}#{Gem.suffix_pattern}"
-    $LOAD_PATH.each do |load_path|
-      globbed = Gem::Util.glob_files_in_dir(glob, load_path)
-
-      globbed.each do |load_path_file|
-        files << load_path_file if File.file?(load_path_file.tap(&Gem::UNTAINT))
-      end
-    end
-
-    load_plugin_files files
+    load_plugin_files find_files_from_load_path("rubygems_plugin")
   end
 
   ##
@@ -1179,14 +1071,14 @@ An Array (#{env.inspect}) was passed in 
   def self.use_gemdeps(path = nil)
     raise_exception = path
 
-    path ||= ENV['RUBYGEMS_GEMDEPS']
+    path ||= ENV["RUBYGEMS_GEMDEPS"]
     return unless path
 
     path = path.dup
 
     if path == "-"
       Gem::Util.traverse_parents Dir.pwd do |directory|
-        dep_file = GEM_DEP_FILES.find { |f| File.file?(f) }
+        dep_file = GEM_DEP_FILES.find {|f| File.file?(f) }
 
         next unless dep_file
 
@@ -1204,45 +1096,28 @@ An Array (#{env.inspect}) was passed in 
     end
 
     ENV["BUNDLE_GEMFILE"] ||= File.expand_path(path)
-    require 'rubygems/user_interaction'
-    Gem::DefaultUserInteraction.use_ui(ui) do
-      require "bundler"
-      begin
-        Bundler.ui.silence do
-          @gemdeps = Bundler.setup
+    require_relative "rubygems/user_interaction"
+    require "bundler"
+    begin
+      Gem::DefaultUserInteraction.use_ui(ui) do
+        begin
+          Bundler.ui.silence do
+            @gemdeps = Bundler.setup
+          end
+        ensure
+          Gem::DefaultUserInteraction.ui.close
         end
-      ensure
-        Gem::DefaultUserInteraction.ui.close
       end
-      @gemdeps.requested_specs.map(&:to_spec).sort_by(&:name)
-    end
-
-  rescue => e
-    case e
-    when Gem::LoadError, Gem::UnsatisfiableDependencyError, (defined?(Bundler::GemNotFound) ? Bundler::GemNotFound : Gem::LoadError)
+    rescue Bundler::BundlerError => e
       warn e.message
-      warn "You may need to `gem install -g` to install missing gems"
+      warn "You may need to `bundle install` to install missing gems"
       warn ""
-    else
-      raise
     end
   end
 
-  class << self
-
-    ##
-    # TODO remove with RubyGems 4.0
-
-    alias detect_gemdeps use_gemdeps # :nodoc:
-
-    extend Gem::Deprecate
-    deprecate :detect_gemdeps, "Gem.use_gemdeps", 2018, 12
-
-  end
-
   ##
   # If the SOURCE_DATE_EPOCH environment variable is set, returns it's value.
-  # Otherwise, returns the time that `Gem.source_date_epoch_string` was
+  # Otherwise, returns the time that +Gem.source_date_epoch_string+ was
   # first called in the same format as SOURCE_DATE_EPOCH.
   #
   # NOTE(@duckinator): The implementation is a tad weird because we want to:
@@ -1284,6 +1159,11 @@ An Array (#{env.inspect}) was passed in 
   # methods, and then we switch over to `class << self` here. Pick one or the
   # other.
   class << self
+    ##
+    # RubyGems distributors (like operating system package managers) can
+    # disable RubyGems update by setting this to error message printed to
+    # end-users on gem update --system instead of actual update.
+    attr_accessor :disable_system_update_message
 
     ##
     # Hash of loaded Gem::Specification keyed by name
@@ -1309,7 +1189,7 @@ An Array (#{env.inspect}) was passed in 
     #
 
     def register_default_spec(spec)
-      extended_require_paths = spec.require_paths.map {|f| f + "/"}
+      extended_require_paths = spec.require_paths.map {|f| f + "/" }
       new_format = extended_require_paths.any? {|path| spec.files.any? {|f| f.start_with? path } }
 
       if new_format
@@ -1323,6 +1203,8 @@ An Array (#{env.inspect}) was passed in 
           next unless $~
         end
 
+        spec.activate if already_loaded?(file)
+
         @path_to_default_spec_map[file] = spec
         @path_to_default_spec_map[file.sub(suffix_regexp, "")] = spec
       end
@@ -1388,6 +1270,22 @@ An Array (#{env.inspect}) was passed in 
 
     attr_reader :pre_uninstall_hooks
 
+    private
+
+    def already_loaded?(file)
+      $LOADED_FEATURES.any? do |feature_path|
+        feature_path.end_with?(file) && default_gem_load_paths.any? {|load_path_entry| feature_path == "#{load_path_entry}/#{file}" }
+      end
+    end
+
+    def default_gem_load_paths
+      @default_gem_load_paths ||= $LOAD_PATH[load_path_insert_index..-1].map do |lp|
+        expanded = File.expand_path(lp)
+        next expanded unless File.exist?(expanded)
+
+        File.realpath(expanded)
+      end
+    end
   end
 
   ##
@@ -1395,37 +1293,44 @@ An Array (#{env.inspect}) was passed in 
 
   MARSHAL_SPEC_DIR = "quick/Marshal.#{Gem.marshal_version}/".freeze
 
-  autoload :BundlerVersionFinder, File.expand_path('rubygems/bundler_version_finder', __dir__)
-  autoload :ConfigFile,         File.expand_path('rubygems/config_file', __dir__)
-  autoload :Dependency,         File.expand_path('rubygems/dependency', __dir__)
-  autoload :DependencyList,     File.expand_path('rubygems/dependency_list', __dir__)
-  autoload :Installer,          File.expand_path('rubygems/installer', __dir__)
-  autoload :Licenses,           File.expand_path('rubygems/util/licenses', __dir__)
-  autoload :NameTuple,          File.expand_path('rubygems/name_tuple', __dir__)
-  autoload :PathSupport,        File.expand_path('rubygems/path_support', __dir__)
-  autoload :Platform,           File.expand_path('rubygems/platform', __dir__)
-  autoload :RequestSet,         File.expand_path('rubygems/request_set', __dir__)
-  autoload :Requirement,        File.expand_path('rubygems/requirement', __dir__)
-  autoload :Resolver,           File.expand_path('rubygems/resolver', __dir__)
-  autoload :Source,             File.expand_path('rubygems/source', __dir__)
-  autoload :SourceList,         File.expand_path('rubygems/source_list', __dir__)
-  autoload :SpecFetcher,        File.expand_path('rubygems/spec_fetcher', __dir__)
-  autoload :Specification,      File.expand_path('rubygems/specification', __dir__)
-  autoload :Util,               File.expand_path('rubygems/util', __dir__)
-  autoload :Version,            File.expand_path('rubygems/version', __dir__)
-
-  require "rubygems/specification"
+  autoload :BundlerVersionFinder, File.expand_path("rubygems/bundler_version_finder", __dir__)
+  autoload :ConfigFile,         File.expand_path("rubygems/config_file", __dir__)
+  autoload :Dependency,         File.expand_path("rubygems/dependency", __dir__)
+  autoload :DependencyList,     File.expand_path("rubygems/dependency_list", __dir__)
+  autoload :Installer,          File.expand_path("rubygems/installer", __dir__)
+  autoload :Licenses,           File.expand_path("rubygems/util/licenses", __dir__)
+  autoload :NameTuple,          File.expand_path("rubygems/name_tuple", __dir__)
+  autoload :PathSupport,        File.expand_path("rubygems/path_support", __dir__)
+  autoload :RequestSet,         File.expand_path("rubygems/request_set", __dir__)
+  autoload :Requirement,        File.expand_path("rubygems/requirement", __dir__)
+  autoload :Resolver,           File.expand_path("rubygems/resolver", __dir__)
+  autoload :Source,             File.expand_path("rubygems/source", __dir__)
+  autoload :SourceList,         File.expand_path("rubygems/source_list", __dir__)
+  autoload :SpecFetcher,        File.expand_path("rubygems/spec_fetcher", __dir__)
+  autoload :SpecificationPolicy, File.expand_path("rubygems/specification_policy", __dir__)
+  autoload :Util,               File.expand_path("rubygems/util", __dir__)
+  autoload :Version,            File.expand_path("rubygems/version", __dir__)
 end
 
-require 'rubygems/exceptions'
+require_relative "rubygems/exceptions"
+require_relative "rubygems/specification"
 
 # REFACTOR: This should be pulled out into some kind of hacks file.
 begin
   ##
   # Defaults the operating system (or packager) wants to provide for RubyGems.
 
-  require 'rubygems/defaults/operating_system'
+  require "rubygems/defaults/operating_system"
 rescue LoadError
+  # Ignored
+rescue StandardError => e
+  path = e.backtrace_locations.reverse.find {|l| l.path.end_with?("rubygems/defaults/operating_system.rb") }.path
+  msg = "#{e.message}\n" \
+    "Loading the #{path} file caused an error. " \
+    "This file is owned by your OS, not by rubygems upstream. " \
+    "Please find out which OS package this file belongs to and follow the guidelines from your OS to report " \
+    "the problem and ask for help."
+  raise e.class, msg
 end
 
 begin
@@ -1440,8 +1345,6 @@ end
 # Loads the default specs.
 Gem::Specification.load_defaults
 
-require 'rubygems/core_ext/kernel_gem'
-require 'rubygems/core_ext/kernel_require'
-require 'rubygems/core_ext/kernel_warn'
-
-Gem.use_gemdeps
+require_relative "rubygems/core_ext/kernel_gem"
+require_relative "rubygems/core_ext/kernel_require"
+require_relative "rubygems/core_ext/kernel_warn"
--- ruby2.7-2.7.6.orig/lib/rubygems/available_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/available_set.rb
@@ -1,6 +1,5 @@
 # frozen_string_literal: true
 class Gem::AvailableSet
-
   include Enumerable
 
   Tuple = Struct.new(:spec, :source)
@@ -27,7 +26,7 @@ class Gem::AvailableSet
       s = o.set
     when Array
       s = o.map do |sp,so|
-        if !sp.kind_of?(Gem::Specification) or !so.kind_of?(Gem::Source)
+        if !sp.kind_of?(Gem::Specification) || !so.kind_of?(Gem::Source)
           raise TypeError, "Array must be in [[spec, source], ...] form"
         end
 
@@ -70,11 +69,11 @@ class Gem::AvailableSet
   end
 
   def all_specs
-    @set.map { |t| t.spec }
+    @set.map {|t| t.spec }
   end
 
   def match_platform!
-    @set.reject! { |t| !Gem::Platform.match(t.spec.platform) }
+    @set.reject! {|t| !Gem::Platform.match_spec?(t.spec) }
     @sorted = nil
     self
   end
@@ -91,7 +90,7 @@ class Gem::AvailableSet
   end
 
   def source_for(spec)
-    f = @set.find { |t| t.spec == spec }
+    f = @set.find {|t| t.spec == spec }
     f.source
   end
 
@@ -150,8 +149,8 @@ class Gem::AvailableSet
     @set.reject! do |t|
       # already locally installed
       Gem::Specification.any? do |installed_spec|
-        dep.name == installed_spec.name and
-          dep.requirement.satisfied_by? installed_spec.version
+        dep.name == installed_spec.name &&
+          dep.requirement.satisfied_by?(installed_spec.version)
       end
     end
 
@@ -160,7 +159,6 @@ class Gem::AvailableSet
   end
 
   def inject_into_list(dep_list)
-    @set.each { |t| dep_list.add t.spec }
+    @set.each {|t| dep_list.add t.spec }
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/basic_specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/basic_specification.rb
@@ -4,7 +4,6 @@
 # used by both Specification and StubSpecification.
 
 class Gem::BasicSpecification
-
   ##
   # Allows installation of extensions for git: gems.
 
@@ -39,10 +38,8 @@ class Gem::BasicSpecification
   end
 
   class << self
-
     extend Gem::Deprecate
-    deprecate :default_specifications_dir, "Gem.default_specifications_dir", 2020, 02
-
+    rubygems_deprecate :default_specifications_dir, "Gem.default_specifications_dir"
   end
 
   ##
@@ -50,7 +47,7 @@ class Gem::BasicSpecification
   # directory.
 
   def gem_build_complete_path # :nodoc:
-    File.join extension_dir, 'gem.build_complete'
+    File.join extension_dir, "gem.build_complete"
   end
 
   ##
@@ -80,7 +77,7 @@ class Gem::BasicSpecification
 
       if Gem::Platform::RUBY == platform || Gem::Platform.local === platform
         warn "Ignoring #{full_name} because its extensions are not built. " +
-          "Try: gem pristine #{name} --version #{version}"
+             "Try: gem pristine #{name} --version #{version}"
       end
 
       return false
@@ -106,7 +103,7 @@ class Gem::BasicSpecification
 
   def extensions_dir
     Gem.default_ext_dir_for(base_dir) ||
-      File.join(base_dir, 'extensions', Gem::Platform.local.to_s,
+      File.join(base_dir, "extensions", Gem::Platform.local.to_s,
                 Gem.extension_api_version)
   end
 
@@ -134,7 +131,7 @@ class Gem::BasicSpecification
   # default Ruby platform.
 
   def full_name
-    if platform == Gem::Platform::RUBY or platform.nil?
+    if platform == Gem::Platform::RUBY || platform.nil?
       "#{name}-#{version}".dup.tap(&Gem::UNTAINT)
     else
       "#{name}-#{version}-#{platform}".dup.tap(&Gem::UNTAINT)
@@ -274,10 +271,16 @@ class Gem::BasicSpecification
   # Return all files in this gem that match for +glob+.
 
   def matches_for_glob(glob) # TODO: rename?
-    # TODO: do we need these?? Kill it
     glob = File.join(self.lib_dirs_glob, glob)
 
-    Dir[glob].map { |f| f.tap(&Gem::UNTAINT) } # FIX our tests are broken, run w/ SAFE=1
+    Dir[glob].map {|f| f.tap(&Gem::UNTAINT) } # FIX our tests are broken, run w/ SAFE=1
+  end
+
+  ##
+  # Returns the list of plugins in this spec.
+
+  def plugins
+    matches_for_glob("rubygems#{Gem.plugin_suffix_pattern}")
   end
 
   ##
@@ -286,14 +289,14 @@ class Gem::BasicSpecification
 
   def lib_dirs_glob
     dirs = if self.raw_require_paths
-             if self.raw_require_paths.size > 1
-               "{#{self.raw_require_paths.join(',')}}"
-             else
-               self.raw_require_paths.first
-             end
-           else
-             "lib" # default value for require_paths for bundler/inline
-           end
+      if self.raw_require_paths.size > 1
+        "{#{self.raw_require_paths.join(',')}}"
+      else
+        self.raw_require_paths.first
+      end
+    else
+      "lib" # default value for require_paths for bundler/inline
+    end
 
     "#{self.full_gem_path}/#{dirs}".dup.tap(&Gem::UNTAINT)
   end
@@ -329,15 +332,14 @@ class Gem::BasicSpecification
   def have_file?(file, suffixes)
     return true if raw_require_paths.any? do |path|
       base = File.join(gems_dir, full_name, path.tap(&Gem::UNTAINT), file).tap(&Gem::UNTAINT)
-      suffixes.any? { |suf| File.file? base + suf }
+      suffixes.any? {|suf| File.file? base + suf }
     end
 
     if have_extensions?
       base = File.join extension_dir, file
-      suffixes.any? { |suf| File.file? base + suf }
+      suffixes.any? {|suf| File.file? base + suf }
     else
       false
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/bundler_version_finder.rb
+++ ruby2.7-2.7.6/lib/rubygems/bundler_version_finder.rb
@@ -1,52 +1,20 @@
 # frozen_string_literal: true
 
-require "rubygems/util"
-
 module Gem::BundlerVersionFinder
   def self.bundler_version
-    version, _ = bundler_version_with_reason
-
-    return unless version
-
-    Gem::Version.new(version)
-  end
-
-  def self.bundler_version_with_reason
-    if v = ENV["BUNDLER_VERSION"]
-      return [v, "`$BUNDLER_VERSION`"]
-    end
-    if v = bundle_update_bundler_version
-      return if v == true
-      return [v, "`bundle update --bundler`"]
-    end
-    v, lockfile = lockfile_version
-    if v
-      return [v, "your #{lockfile}"]
-    end
-  end
+    v = ENV["BUNDLER_VERSION"]
 
-  def self.missing_version_message
-    return unless vr = bundler_version_with_reason
-    <<-EOS
-Could not find 'bundler' (#{vr.first}) required by #{vr.last}.
-To update to the latest version installed on your system, run `bundle update --bundler`.
-To install the missing version, run `gem install bundler:#{vr.first}`
-    EOS
-  end
+    v ||= bundle_update_bundler_version
+    return if v == true
 
-  def self.compatible?(spec)
-    return true unless spec.name == "bundler".freeze
-    return true unless bundler_version = self.bundler_version
+    v ||= lockfile_version
+    return unless v
 
-    spec.version.segments.first == bundler_version.segments.first
+    Gem::Version.new(v)
   end
 
-  def self.filter!(specs)
-    return unless bundler_version = self.bundler_version
-
-    specs.reject! { |spec| spec.version.segments.first != bundler_version.segments.first }
-
-    exact_match_index = specs.find_index { |spec| spec.version == bundler_version }
+  def self.prioritize!(specs)
+    exact_match_index = specs.find_index {|spec| spec.version == bundler_version }
     return unless exact_match_index
 
     specs.unshift(specs.delete_at(exact_match_index))
@@ -70,12 +38,10 @@ To install the missing version, run `gem
   private_class_method :bundle_update_bundler_version
 
   def self.lockfile_version
-    return unless lockfile = lockfile_contents
-    lockfile, contents = lockfile
-    lockfile ||= "lockfile"
+    return unless contents = lockfile_contents
     regexp = /\n\nBUNDLED WITH\n\s{2,}(#{Gem::Version::VERSION_PATTERN})\n/
     return unless contents =~ regexp
-    [$1, lockfile]
+    $1
   end
   private_class_method :lockfile_version
 
@@ -86,7 +52,7 @@ To install the missing version, run `gem
     unless gemfile
       begin
         Gem::Util.traverse_parents(Dir.pwd) do |directory|
-          next unless gemfile = Gem::GEM_DEP_FILES.find { |f| File.file?(f.tap(&Gem::UNTAINT)) }
+          next unless gemfile = Gem::GEM_DEP_FILES.find {|f| File.file?(f.tap(&Gem::UNTAINT)) }
 
           gemfile = File.join directory, gemfile
           break
@@ -99,13 +65,13 @@ To install the missing version, run `gem
     return unless gemfile
 
     lockfile = case gemfile
-               when "gems.rb" then "gems.locked"
-               else "#{gemfile}.lock"
-               end.dup.tap(&Gem::UNTAINT)
+    when "gems.rb" then "gems.locked"
+    else "#{gemfile}.lock"
+    end.dup.tap(&Gem::UNTAINT)
 
     return unless File.file?(lockfile)
 
-    [lockfile, File.read(lockfile)]
+    File.read(lockfile)
   end
   private_class_method :lockfile_contents
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/command.rb
+++ ruby2.7-2.7.6/lib/rubygems/command.rb
@@ -5,9 +5,9 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'optparse'
-require 'rubygems/requirement'
-require 'rubygems/user_interaction'
+require_relative "optparse"
+require_relative "requirement"
+require_relative "user_interaction"
 
 ##
 # Base class for all Gem commands.  When creating a new gem command, define
@@ -17,10 +17,9 @@ require 'rubygems/user_interaction'
 # A very good example to look at is Gem::Commands::ContentsCommand
 
 class Gem::Command
-
   include Gem::UserInteraction
 
-  OptionParser.accept Symbol do |value|
+  Gem::OptionParser.accept Symbol do |value|
     value.to_sym
   end
 
@@ -77,7 +76,7 @@ class Gem::Command
     when Array
       @extra_args = value
     when String
-      @extra_args = value.split
+      @extra_args = value.split(" ")
     end
   end
 
@@ -125,7 +124,7 @@ class Gem::Command
     @program_name = "gem #{command}"
     @defaults = defaults
     @options = defaults.dup
-    @option_groups = Hash.new { |h,k| h[k] = [] }
+    @option_groups = Hash.new {|h,k| h[k] = [] }
     @deprecated_options = { command => {} }
     @parser = nil
     @when_invoked = nil
@@ -160,11 +159,11 @@ class Gem::Command
     gem = "'#{gem_name}' (#{version})"
     msg = String.new "Could not find a valid gem #{gem}"
 
-    if errors and !errors.empty?
+    if errors && !errors.empty?
       msg << ", here is why:\n"
-      errors.each { |x| msg << "          #{x.wordy}\n" }
+      errors.each {|x| msg << "          #{x.wordy}\n" }
     else
-      if required_by and gem != required_by
+      if required_by && gem != required_by
         msg << " (required by #{required_by}) in any repository"
       else
         msg << " in any repository"
@@ -174,8 +173,7 @@ class Gem::Command
     alert_error msg
 
     unless suppress_suggestions
-      suggestions = Gem::SpecFetcher.fetcher.suggest_gems_from_name gem_name
-
+      suggestions = Gem::SpecFetcher.fetcher.suggest_gems_from_name(gem_name, :latest, 10)
       unless suggestions.empty?
         alert_error "Possible alternatives: #{suggestions.join(", ")}"
       end
@@ -188,12 +186,12 @@ class Gem::Command
   def get_all_gem_names
     args = options[:args]
 
-    if args.nil? or args.empty?
+    if args.nil? || args.empty?
       raise Gem::CommandLineError,
             "Please specify at least one gem name (e.g. gem build GEMNAME)"
     end
 
-    args.select { |arg| arg !~ /^-/ }
+    args.select {|arg| arg !~ /^-/ }
   end
 
   ##
@@ -218,7 +216,7 @@ class Gem::Command
   def get_one_gem_name
     args = options[:args]
 
-    if args.nil? or args.empty?
+    if args.nil? || args.empty?
       raise Gem::CommandLineError,
             "Please specify a gem name on the command line (e.g. gem build GEMNAME)"
     end
@@ -346,7 +344,7 @@ class Gem::Command
   ##
   # Add a command-line option and handler to the command.
   #
-  # See OptionParser#make_switch for an explanation of +opts+.
+  # See Gem::OptionParser#make_switch for an explanation of +opts+.
   #
   # +handler+ will be called with two values, the value of the argument and
   # the options hash.
@@ -357,6 +355,8 @@ class Gem::Command
   def add_option(*opts, &handler) # :yields: value, options
     group_name = Symbol === opts.first ? opts.shift : :options
 
+    raise "Do not pass an empty string in opts" if opts.include?("")
+
     @option_groups[group_name] << [opts, handler]
   end
 
@@ -365,7 +365,7 @@ class Gem::Command
 
   def remove_option(name)
     @option_groups.each do |_, option_list|
-      option_list.reject! { |args, _| args.any? { |x| x.is_a?(String) && x =~ /^#{name}/ } }
+      option_list.reject! {|args, _| args.any? {|x| x.is_a?(String) && x =~ /^#{name}/ } }
     end
   end
 
@@ -398,10 +398,10 @@ class Gem::Command
         version_to_expire = deprecation["rg_version_to_expire"]
 
         deprecate_option_msg = if version_to_expire
-                                 "The \"#{option}\" option has been deprecated and will be removed in Rubygems #{version_to_expire}."
-                               else
-                                 "The \"#{option}\" option has been deprecated and will be removed in future versions of Rubygems."
-                               end
+          "The \"#{option}\" option has been deprecated and will be removed in Rubygems #{version_to_expire}."
+        else
+          "The \"#{option}\" option has been deprecated and will be removed in future versions of Rubygems."
+        end
 
         extra_msg = deprecation["extra_msg"]
 
@@ -418,7 +418,7 @@ class Gem::Command
 
   def merge_options(new_options)
     @options = @defaults.clone
-    new_options.each { |k,v| @options[k] = v }
+    new_options.each {|k,v| @options[k] = v }
   end
 
   ##
@@ -457,7 +457,7 @@ class Gem::Command
     until extra.empty? do
       ex = []
       ex << extra.shift
-      ex << extra.shift if extra.first.to_s =~ /^[^-]/
+      ex << extra.shift if extra.first.to_s =~ /^[^-]/ # rubocop:disable Performance/StartWith
       result << ex if handles?(ex)
     end
 
@@ -466,6 +466,10 @@ class Gem::Command
     result
   end
 
+  def deprecated?
+    false
+  end
+
   private
 
   def option_is_deprecated?(option)
@@ -493,7 +497,7 @@ class Gem::Command
 
     configure_options "", regular_options
 
-    @option_groups.sort_by { |n,_| n.to_s }.each do |group_name, option_list|
+    @option_groups.sort_by {|n,_| n.to_s }.each do |group_name, option_list|
       @parser.separator nil
       configure_options group_name, option_list
     end
@@ -536,7 +540,7 @@ class Gem::Command
   # command.
 
   def create_option_parser
-    @parser = OptionParser.new
+    @parser = Gem::OptionParser.new
 
     add_parser_options
 
@@ -550,9 +554,9 @@ class Gem::Command
   end
 
   def configure_options(header, option_list)
-    return if option_list.nil? or option_list.empty?
+    return if option_list.nil? || option_list.empty?
 
-    header = header.to_s.empty? ? '' : "#{header} "
+    header = header.to_s.empty? ? "" : "#{header} "
     @parser.separator "  #{header}Options:"
 
     option_list.each do |args, handler|
@@ -561,7 +565,7 @@ class Gem::Command
       end
     end
 
-    @parser.separator ''
+    @parser.separator ""
   end
 
   ##
@@ -574,22 +578,22 @@ class Gem::Command
   # ----------------------------------------------------------------
   # Add the options common to all commands.
 
-  add_common_option('-h', '--help',
-                    'Get help on this command') do |value, options|
+  add_common_option("-h", "--help",
+                    "Get help on this command") do |value, options|
     options[:help] = true
   end
 
-  add_common_option('-V', '--[no-]verbose',
-                    'Set the verbose level of output') do |value, options|
+  add_common_option("-V", "--[no-]verbose",
+                    "Set the verbose level of output") do |value, options|
     # Set us to "really verbose" so the progress meter works
-    if Gem.configuration.verbose and value
+    if Gem.configuration.verbose && value
       Gem.configuration.verbose = 1
     else
       Gem.configuration.verbose = value
     end
   end
 
-  add_common_option('-q', '--quiet', 'Silence command progress meter') do |value, options|
+  add_common_option("-q", "--quiet", "Silence command progress meter") do |value, options|
     Gem.configuration.verbose = false
   end
 
@@ -602,27 +606,26 @@ class Gem::Command
   # commands.  Both options are actually handled before the other
   # options get parsed.
 
-  add_common_option('--config-file FILE',
-                    'Use this config file instead of default') do
+  add_common_option("--config-file FILE",
+                    "Use this config file instead of default") do
   end
 
-  add_common_option('--backtrace',
-                    'Show stack backtrace on errors') do
+  add_common_option("--backtrace",
+                    "Show stack backtrace on errors") do
   end
 
-  add_common_option('--debug',
-                    'Turn on Ruby debugging') do
+  add_common_option("--debug",
+                    "Turn on Ruby debugging") do
   end
 
-  add_common_option('--norc',
-                    'Avoid loading any .gemrc file') do
+  add_common_option("--norc",
+                    "Avoid loading any .gemrc file") do
   end
 
   # :stopdoc:
 
   HELP = <<-HELP.freeze
-RubyGems is a sophisticated package manager for Ruby.  This is a
-basic help message containing pointers to more information.
+RubyGems is a package manager for Ruby.
 
   Usage:
     gem -h/--help
@@ -633,6 +636,7 @@ basic help message containing pointers t
     gem install rake
     gem list --local
     gem build package.gemspec
+    gem push package-0.0.1.gem
     gem help install
 
   Further help:
@@ -650,7 +654,6 @@ basic help message containing pointers t
   HELP
 
   # :startdoc:
-
 end
 
 ##
--- ruby2.7-2.7.6.orig/lib/rubygems/command_manager.rb
+++ ruby2.7-2.7.6/lib/rubygems/command_manager.rb
@@ -5,9 +5,9 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/command'
-require 'rubygems/user_interaction'
-require 'rubygems/text'
+require_relative "command"
+require_relative "user_interaction"
+require_relative "text"
 
 ##
 # The command manager registers and installs all the individual sub-commands
@@ -32,7 +32,6 @@ require 'rubygems/text'
 # See Gem::Command for instructions on writing gem commands.
 
 class Gem::CommandManager
-
   include Gem::Text
   include Gem::UserInteraction
 
@@ -74,7 +73,9 @@ class Gem::CommandManager
   ].freeze
 
   ALIAS_COMMANDS = {
-    'i' => 'install'
+    "i"      => "install",
+    "login"  => "signin",
+    "logout" => "signout",
   }.freeze
 
   ##
@@ -103,7 +104,7 @@ class Gem::CommandManager
   # Register all the subcommands supported by the gem command.
 
   def initialize
-    require 'timeout'
+    require "timeout"
     @commands = {}
 
     BUILTIN_COMMANDS.each do |name|
@@ -138,7 +139,7 @@ class Gem::CommandManager
   # Return a sorted list of all command names as strings.
 
   def command_names
-    @commands.keys.collect {|key| key.to_s}.sort
+    @commands.keys.collect {|key| key.to_s }.sort
   end
 
   ##
@@ -147,7 +148,12 @@ class Gem::CommandManager
   def run(args, build_args=nil)
     process_args(args, build_args)
   rescue StandardError, Timeout::Error => ex
-    alert_error clean_text("While executing gem ... (#{ex.class})\n    #{ex}")
+    if ex.respond_to?(:detailed_message)
+      msg = ex.detailed_message(highlight: false).sub(/\A(.*?)(?: \(.+?\))/) { $1 }
+    else
+      msg = ex.message
+    end
+    alert_error clean_text("While executing gem ... (#{ex.class})\n    #{msg}")
     ui.backtrace ex
 
     terminate_interaction(1)
@@ -163,10 +169,10 @@ class Gem::CommandManager
     end
 
     case args.first
-    when '-h', '--help' then
+    when "-h", "--help" then
       say Gem::Command::HELP
       terminate_interaction 0
-    when '-v', '--version' then
+    when "-v", "--version" then
       say Gem::VERSION
       terminate_interaction 0
     when /^-/ then
@@ -175,6 +181,7 @@ class Gem::CommandManager
     else
       cmd_name = args.shift.downcase
       cmd = find_command cmd_name
+      cmd.deprecation_warning if cmd.deprecated?
       cmd.invoke_with_build_args args, build_args
     end
   end
@@ -188,7 +195,7 @@ class Gem::CommandManager
       raise Gem::CommandLineError,
             "Ambiguous command #{cmd_name} matches [#{possibilities.join(', ')}]"
     elsif possibilities.empty?
-      raise Gem::CommandLineError, "Unknown command #{cmd_name}"
+      raise Gem::UnknownCommandError.new(cmd_name)
     end
 
     self[possibilities.first]
@@ -202,9 +209,9 @@ class Gem::CommandManager
   def find_command_possibilities(cmd_name)
     len = cmd_name.length
 
-    found = command_names.select { |name| cmd_name == name[0, len] }
+    found = command_names.select {|name| cmd_name == name[0, len] }
 
-    exact = found.find { |name| name == cmd_name }
+    exact = found.find {|name| name == cmd_name }
 
     exact ? [exact] : found
   end
@@ -230,5 +237,4 @@ class Gem::CommandManager
       ui.backtrace e
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/build_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/build_command.rb
@@ -1,25 +1,29 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/package'
+require_relative "../command"
+require_relative "../package"
+require_relative "../version_option"
 
 class Gem::Commands::BuildCommand < Gem::Command
+  include Gem::VersionOption
 
   def initialize
-    super 'build', 'Build a gem from a gemspec'
+    super "build", "Build a gem from a gemspec"
 
-    add_option '--force', 'skip validation of the spec' do |value, options|
+    add_platform_option
+
+    add_option "--force", "skip validation of the spec" do |value, options|
       options[:force] = true
     end
 
-    add_option '--strict', 'consider warnings as errors when validating the spec' do |value, options|
+    add_option "--strict", "consider warnings as errors when validating the spec" do |value, options|
       options[:strict] = true
     end
 
-    add_option '-o', '--output FILE', 'output gem with the given filename' do |value, options|
+    add_option "-o", "--output FILE", "output gem with the given filename" do |value, options|
       options[:output] = value
     end
 
-    add_option '-C PATH', '', 'Run as if gem build was started in <PATH> instead of the current working directory.' do |value, options|
+    add_option "-C PATH", "Run as if gem build was started in <PATH> instead of the current working directory." do |value, options|
       options[:build_path] = value
     end
   end
@@ -57,14 +61,18 @@ Gems can be saved to a specified filenam
   end
 
   def execute
-    gem_name = get_one_optional_argument || find_gemspec
-    build_gem(gem_name)
+    if build_path = options[:build_path]
+      Dir.chdir(build_path) { build_gem }
+      return
+    end
+
+    build_gem
   end
 
   private
 
-  def find_gemspec
-    gemspecs = Dir.glob("*.gemspec").sort
+  def find_gemspec(glob = "*.gemspec")
+    gemspecs = Dir.glob(glob).sort
 
     if gemspecs.size > 1
       alert_error "Multiple gemspecs found: #{gemspecs}, please specify one"
@@ -74,28 +82,19 @@ Gems can be saved to a specified filenam
     gemspecs.first
   end
 
-  def build_gem(gem_name)
-    gemspec = File.exist?(gem_name) ? gem_name : "#{gem_name}.gemspec"
-
-    if File.exist?(gemspec)
-      spec = Gem::Specification.load(gemspec)
-
-      if options[:build_path]
-        Dir.chdir(File.dirname(gemspec)) do
-          spec = Gem::Specification.load(File.basename(gemspec))
-          build_package(spec)
-        end
-      else
-        build_package(spec)
-      end
+  def build_gem
+    gemspec = resolve_gem_name
 
+    if gemspec
+      build_package(gemspec)
     else
-      alert_error "Gemspec file not found: #{gemspec}"
+      alert_error error_message
       terminate_interaction(1)
     end
   end
 
-  def build_package(spec)
+  def build_package(gemspec)
+    spec = Gem::Specification.load(gemspec)
     if spec
       Gem::Package.build(
         spec,
@@ -109,4 +108,25 @@ Gems can be saved to a specified filenam
     end
   end
 
+  def resolve_gem_name
+    return find_gemspec unless gem_name
+
+    if File.exist?(gem_name)
+      gem_name
+    else
+      find_gemspec("#{gem_name}.gemspec") || find_gemspec(gem_name)
+    end
+  end
+
+  def error_message
+    if gem_name
+      "Couldn't find a gemspec file matching '#{gem_name}' in #{Dir.pwd}"
+    else
+      "Couldn't find a gemspec file in #{Dir.pwd}"
+    end
+  end
+
+  def gem_name
+    get_one_optional_argument
+  end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/cert_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/cert_command.rb
@@ -1,99 +1,69 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/security'
-begin
-  require 'openssl'
-rescue LoadError => e
-  raise unless (e.respond_to?(:path) && e.path == 'openssl') ||
-               e.message =~ / -- openssl$/
-end
+require_relative "../command"
+require_relative "../security"
 
 class Gem::Commands::CertCommand < Gem::Command
-
   def initialize
-    super 'cert', 'Manage RubyGems certificates and signing settings',
+    super "cert", "Manage RubyGems certificates and signing settings",
           :add => [], :remove => [], :list => [], :build => [], :sign => []
 
-    OptionParser.accept OpenSSL::X509::Certificate do |certificate_file|
-      begin
-        certificate = OpenSSL::X509::Certificate.new File.read certificate_file
-      rescue Errno::ENOENT
-        raise OptionParser::InvalidArgument, "#{certificate_file}: does not exist"
-      rescue OpenSSL::X509::CertificateError
-        raise OptionParser::InvalidArgument,
-          "#{certificate_file}: invalid X509 certificate"
-      end
-      [certificate, certificate_file]
-    end
-
-    OptionParser.accept OpenSSL::PKey::RSA do |key_file|
-      begin
-        passphrase = ENV['GEM_PRIVATE_KEY_PASSPHRASE']
-        key = OpenSSL::PKey::RSA.new File.read(key_file), passphrase
-      rescue Errno::ENOENT
-        raise OptionParser::InvalidArgument, "#{key_file}: does not exist"
-      rescue OpenSSL::PKey::RSAError
-        raise OptionParser::InvalidArgument, "#{key_file}: invalid RSA key"
-      end
-
-      raise OptionParser::InvalidArgument,
-            "#{key_file}: private key not found" unless key.private?
-
-      key
-    end
-
-    add_option('-a', '--add CERT', OpenSSL::X509::Certificate,
-               'Add a trusted certificate.') do |(cert, _), options|
-      options[:add] << cert
-    end
-
-    add_option('-l', '--list [FILTER]',
-               'List trusted certificates where the',
-               'subject contains FILTER') do |filter, options|
-      filter ||= ''
+    add_option("-a", "--add CERT",
+               "Add a trusted certificate.") do |cert_file, options|
+      options[:add] << open_cert(cert_file)
+    end
+
+    add_option("-l", "--list [FILTER]",
+               "List trusted certificates where the",
+               "subject contains FILTER") do |filter, options|
+      filter ||= ""
 
       options[:list] << filter
     end
 
-    add_option('-r', '--remove FILTER',
-               'Remove trusted certificates where the',
-               'subject contains FILTER') do |filter, options|
+    add_option("-r", "--remove FILTER",
+               "Remove trusted certificates where the",
+               "subject contains FILTER") do |filter, options|
       options[:remove] << filter
     end
 
-    add_option('-b', '--build EMAIL_ADDR',
-               'Build private key and self-signed',
-               'certificate for EMAIL_ADDR') do |email_address, options|
+    add_option("-b", "--build EMAIL_ADDR",
+               "Build private key and self-signed",
+               "certificate for EMAIL_ADDR") do |email_address, options|
       options[:build] << email_address
     end
 
-    add_option('-C', '--certificate CERT', OpenSSL::X509::Certificate,
-               'Signing certificate for --sign') do |(cert, cert_file), options|
-      options[:issuer_cert] = cert
+    add_option("-C", "--certificate CERT",
+               "Signing certificate for --sign") do |cert_file, options|
+      options[:issuer_cert] = open_cert(cert_file)
       options[:issuer_cert_file] = cert_file
     end
 
-    add_option('-K', '--private-key KEY', OpenSSL::PKey::RSA,
-               'Key for --sign or --build') do |key, options|
-      options[:key] = key
+    add_option("-K", "--private-key KEY",
+               "Key for --sign or --build") do |key_file, options|
+      options[:key] = open_private_key(key_file)
+    end
+
+    add_option("-A", "--key-algorithm ALGORITHM",
+               "Select which key algorithm to use for --build") do |algorithm, options|
+      options[:key_algorithm] = algorithm
     end
 
-    add_option('-s', '--sign CERT',
-               'Signs CERT with the key from -K',
-               'and the certificate from -C') do |cert_file, options|
-      raise OptionParser::InvalidArgument, "#{cert_file}: does not exist" unless
+    add_option("-s", "--sign CERT",
+               "Signs CERT with the key from -K",
+               "and the certificate from -C") do |cert_file, options|
+      raise Gem::OptionParser::InvalidArgument, "#{cert_file}: does not exist" unless
         File.file? cert_file
 
       options[:sign] << cert_file
     end
 
-    add_option('-d', '--days NUMBER_OF_DAYS',
-               'Days before the certificate expires') do |days, options|
+    add_option("-d", "--days NUMBER_OF_DAYS",
+               "Days before the certificate expires") do |days, options|
       options[:expiration_length_days] = days.to_i
     end
 
-    add_option('-R', '--re-sign',
-               'Re-signs the certificate from -C with the key from -K') do |resign, options|
+    add_option("-R", "--re-sign",
+               "Re-signs the certificate from -C with the key from -K") do |resign, options|
       options[:resign] = resign
     end
   end
@@ -104,7 +74,39 @@ class Gem::Commands::CertCommand < Gem::
     say "Added '#{certificate.subject}'"
   end
 
+  def check_openssl
+    return if Gem::HAVE_OPENSSL
+
+    alert_error "OpenSSL library is required for the cert command"
+    terminate_interaction 1
+  end
+
+  def open_cert(certificate_file)
+    check_openssl
+    OpenSSL::X509::Certificate.new File.read certificate_file
+  rescue Errno::ENOENT
+    raise Gem::OptionParser::InvalidArgument, "#{certificate_file}: does not exist"
+  rescue OpenSSL::X509::CertificateError
+    raise Gem::OptionParser::InvalidArgument,
+      "#{certificate_file}: invalid X509 certificate"
+  end
+
+  def open_private_key(key_file)
+    check_openssl
+    passphrase = ENV["GEM_PRIVATE_KEY_PASSPHRASE"]
+    key = OpenSSL::PKey.read File.read(key_file), passphrase
+    raise Gem::OptionParser::InvalidArgument,
+      "#{key_file}: private key not found" unless key.private?
+    key
+  rescue Errno::ENOENT
+    raise Gem::OptionParser::InvalidArgument, "#{key_file}: does not exist"
+  rescue OpenSSL::PKey::PKeyError, ArgumentError
+    raise Gem::OptionParser::InvalidArgument, "#{key_file}: invalid RSA, DSA, or EC key"
+  end
+
   def execute
+    check_openssl
+
     options[:add].each do |certificate|
       add_certificate certificate
     end
@@ -150,7 +152,7 @@ class Gem::Commands::CertCommand < Gem::
 
   def build_cert(email, key) # :nodoc:
     expiration_length_days = options[:expiration_length_days] ||
-      Gem.configuration.cert_expiration_length_days
+                             Gem.configuration.cert_expiration_length_days
 
     cert = Gem::Security.create_cert_email(
       email,
@@ -164,16 +166,17 @@ class Gem::Commands::CertCommand < Gem::
   def build_key # :nodoc:
     return options[:key] if options[:key]
 
-    passphrase = ask_for_password 'Passphrase for your Private Key:'
+    passphrase = ask_for_password "Passphrase for your Private Key:"
     say "\n"
 
-    passphrase_confirmation = ask_for_password 'Please repeat the passphrase for your Private Key:'
+    passphrase_confirmation = ask_for_password "Please repeat the passphrase for your Private Key:"
     say "\n"
 
     raise Gem::CommandLineError,
           "Passphrase and passphrase confirmation don't match" unless passphrase == passphrase_confirmation
 
-    key      = Gem::Security.create_key
+    algorithm = options[:key_algorithm] || Gem::Security::DEFAULT_KEY_ALGORITHM
+    key = Gem::Security.create_key(algorithm)
     key_path = Gem::Security.write key, "gem-private_key.pem", 0600, passphrase
 
     return key, key_path
@@ -186,7 +189,7 @@ class Gem::Commands::CertCommand < Gem::
       subject = certificate.subject.to_s
       subject.downcase.index filter
     end.sort_by do |certificate, _|
-      certificate.subject.to_a.map { |name, data,| [name, data] }
+      certificate.subject.to_a.map {|name, data,| [name, data] }
     end.each do |certificate, path|
       yield certificate, path
     end
@@ -257,14 +260,15 @@ For further reading on signing gems see 
   def load_default_key
     key_file = File.join Gem.default_key_path
     key = File.read key_file
-    passphrase = ENV['GEM_PRIVATE_KEY_PASSPHRASE']
-    options[:key] = OpenSSL::PKey::RSA.new key, passphrase
+    passphrase = ENV["GEM_PRIVATE_KEY_PASSPHRASE"]
+    options[:key] = OpenSSL::PKey.read key, passphrase
+
   rescue Errno::ENOENT
     alert_error \
       "--private-key not specified and ~/.gem/gem-private_key.pem does not exist"
 
     terminate_interaction 1
-  rescue OpenSSL::PKey::RSAError
+  rescue OpenSSL::PKey::PKeyError
     alert_error \
       "--private-key not specified and ~/.gem/gem-private_key.pem is not valid"
 
@@ -318,5 +322,4 @@ For further reading on signing gems see 
     # It's simple, but is all we need
     email =~ /\A.+@.+\z/
   end
-
-end if defined?(OpenSSL::SSL)
+end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/check_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/check_command.rb
@@ -1,45 +1,44 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/version_option'
-require 'rubygems/validator'
-require 'rubygems/doctor'
+require_relative "../command"
+require_relative "../version_option"
+require_relative "../validator"
+require_relative "../doctor"
 
 class Gem::Commands::CheckCommand < Gem::Command
-
   include Gem::VersionOption
 
   def initialize
-    super 'check', 'Check a gem repository for added or missing files',
+    super "check", "Check a gem repository for added or missing files",
           :alien => true, :doctor => false, :dry_run => false, :gems => true
 
-    add_option('-a', '--[no-]alien',
+    add_option("-a", "--[no-]alien",
                'Report "unmanaged" or rogue files in the',
-               'gem repository') do |value, options|
+               "gem repository") do |value, options|
       options[:alien] = value
     end
 
-    add_option('--[no-]doctor',
-               'Clean up uninstalled gems and broken',
-               'specifications') do |value, options|
+    add_option("--[no-]doctor",
+               "Clean up uninstalled gems and broken",
+               "specifications") do |value, options|
       options[:doctor] = value
     end
 
-    add_option('--[no-]dry-run',
-               'Do not remove files, only report what',
-               'would be removed') do |value, options|
+    add_option("--[no-]dry-run",
+               "Do not remove files, only report what",
+               "would be removed") do |value, options|
       options[:dry_run] = value
     end
 
-    add_option('--[no-]gems',
-               'Check installed gems for problems') do |value, options|
+    add_option("--[no-]gems",
+               "Check installed gems for problems") do |value, options|
       options[:gems] = value
     end
 
-    add_version_option 'check'
+    add_version_option "check"
   end
 
   def check_gems
-    say 'Checking gems...'
+    say "Checking gems..."
     say
     gems = get_all_gem_names rescue []
 
@@ -58,7 +57,7 @@ class Gem::Commands::CheckCommand < Gem:
   end
 
   def doctor
-    say 'Checking for files from uninstalled gems...'
+    say "Checking for files from uninstalled gems..."
     say
 
     Gem.path.each do |gem_repo|
@@ -73,11 +72,11 @@ class Gem::Commands::CheckCommand < Gem:
   end
 
   def arguments # :nodoc:
-    'GEMNAME       name of gem to check'
+    "GEMNAME       name of gem to check"
   end
 
   def defaults_str # :nodoc:
-    '--gems --alien'
+    "--gems --alien"
   end
 
   def description # :nodoc:
@@ -90,5 +89,4 @@ specifications and will clean up gems th
   def usage # :nodoc:
     "#{program_name} [OPTIONS] [GEMNAME ...]"
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/cleanup_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/cleanup_command.rb
@@ -1,30 +1,35 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/dependency_list'
-require 'rubygems/uninstaller'
+require_relative "../command"
+require_relative "../dependency_list"
+require_relative "../uninstaller"
 
 class Gem::Commands::CleanupCommand < Gem::Command
-
   def initialize
-    super 'cleanup',
-          'Clean up old versions of installed gems',
+    super "cleanup",
+          "Clean up old versions of installed gems",
           :force => false, :install_dir => Gem.dir,
           :check_dev => true
 
-    add_option('-n', '-d', '--dryrun',
-               'Do not uninstall gems') do |value, options|
+    add_option("-n", "-d", "--dry-run",
+               "Do not uninstall gems") do |value, options|
+      options[:dryrun] = true
+    end
+
+    add_option(:Deprecated, "--dryrun",
+               "Do not uninstall gems") do |value, options|
       options[:dryrun] = true
     end
+    deprecate_option("--dryrun", extra_msg: "Use --dry-run instead")
 
-    add_option('-D', '--[no-]check-development',
-               'Check development dependencies while uninstalling',
-               '(default: true)') do |value, options|
+    add_option("-D", "--[no-]check-development",
+               "Check development dependencies while uninstalling",
+               "(default: true)") do |value, options|
       options[:check_dev] = value
     end
 
-    add_option('--[no-]user-install',
-               'Cleanup in user\'s home directory instead',
-               'of GEM_HOME.') do |value, options|
+    add_option("--[no-]user-install",
+               "Cleanup in user's home directory instead",
+               "of GEM_HOME.") do |value, options|
       options[:user_install] = value
     end
 
@@ -42,7 +47,7 @@ class Gem::Commands::CleanupCommand < Ge
   end
 
   def defaults_str # :nodoc:
-    "--no-dryrun"
+    "--no-dry-run"
   end
 
   def description # :nodoc:
@@ -69,7 +74,7 @@ If no gems are named all gems in GEM_HOM
       until done do
         clean_gems
 
-        this_set = @gems_to_cleanup.map { |spec| spec.full_name }.sort
+        this_set = @gems_to_cleanup.map {|spec| spec.full_name }.sort
 
         done = this_set.empty? || last_set == this_set
 
@@ -82,7 +87,7 @@ If no gems are named all gems in GEM_HOM
     say "Clean up complete"
 
     verbose do
-      skipped = @default_gems.map { |spec| spec.full_name }
+      skipped = @default_gems.map {|spec| spec.full_name }
 
       "Skipped default gems: #{skipped.join ', '}"
     end
@@ -99,7 +104,7 @@ If no gems are named all gems in GEM_HOM
     @full = Gem::DependencyList.from_specs
 
     deplist = Gem::DependencyList.new
-    @gems_to_cleanup.each { |spec| deplist.add spec }
+    @gems_to_cleanup.each {|spec| deplist.add spec }
 
     deps = deplist.strongly_connected_components.flatten
 
@@ -112,12 +117,12 @@ If no gems are named all gems in GEM_HOM
 
   def get_candidate_gems
     @candidate_gems = unless options[:args].empty?
-                        options[:args].map do |gem_name|
-                          Gem::Specification.find_all_by_name gem_name
-                        end.flatten
-                      else
-                        Gem::Specification.to_a
-                      end
+      options[:args].map do |gem_name|
+        Gem::Specification.find_all_by_name gem_name
+      end.flatten
+    else
+      Gem::Specification.to_a
+    end
   end
 
   def get_gems_to_cleanup
@@ -144,7 +149,7 @@ If no gems are named all gems in GEM_HOM
     @primary_gems = {}
 
     Gem::Specification.each do |spec|
-      if @primary_gems[spec.name].nil? or
+      if @primary_gems[spec.name].nil? ||
          @primary_gems[spec.name].version < spec.version
         @primary_gems[spec.name] = spec
       end
@@ -181,5 +186,4 @@ If no gems are named all gems in GEM_HOM
     # Restore path Gem::Uninstaller may have changed
     Gem.use_paths @original_home, *@original_path
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/contents_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/contents_command.rb
@@ -1,41 +1,39 @@
 # frozen_string_literal: true
-require 'English'
-require 'rubygems/command'
-require 'rubygems/version_option'
+require_relative "../command"
+require_relative "../version_option"
 
 class Gem::Commands::ContentsCommand < Gem::Command
-
   include Gem::VersionOption
 
   def initialize
-    super 'contents', 'Display the contents of the installed gems',
+    super "contents", "Display the contents of the installed gems",
           :specdirs => [], :lib_only => false, :prefix => true,
           :show_install_dir => false
 
     add_version_option
 
-    add_option('--all',
+    add_option("--all",
                "Contents for all gems") do |all, options|
       options[:all] = all
     end
 
-    add_option('-s', '--spec-dir a,b,c', Array,
+    add_option("-s", "--spec-dir a,b,c", Array,
                "Search for gems under specific paths") do |spec_dirs, options|
       options[:specdirs] = spec_dirs
     end
 
-    add_option('-l', '--[no-]lib-only',
+    add_option("-l", "--[no-]lib-only",
                "Only return files in the Gem's lib_dirs") do |lib_only, options|
       options[:lib_only] = lib_only
     end
 
-    add_option('--[no-]prefix',
+    add_option("--[no-]prefix",
                "Don't include installed path prefix") do |prefix, options|
       options[:prefix] = prefix
     end
 
-    add_option('--[no-]show-install-dir',
-               'Show only the gem install dir') do |show, options|
+    add_option("--[no-]show-install-dir",
+               "Show only the gem install dir") do |show, options|
       options[:show_install_dir] = show
     end
 
@@ -79,7 +77,7 @@ prefix or only the files that are requir
           gem_contents name
         end
 
-      terminate_interaction 1 unless found or names.length > 1
+      terminate_interaction 1 unless found || names.length > 1
     end
   end
 
@@ -106,11 +104,12 @@ prefix or only the files that are requir
     spec.files.map do |file|
       case file
       when /\A#{spec.bindir}\//
-        [RbConfig::CONFIG['bindir'], $POSTMATCH]
+        # $' is POSTMATCH
+        [RbConfig::CONFIG["bindir"], $']
       when /\.so\z/
-        [RbConfig::CONFIG['archdir'], file]
+        [RbConfig::CONFIG["archdir"], file]
       else
-        [RbConfig::CONFIG['rubylibdir'], file]
+        [RbConfig::CONFIG["rubylibdir"], file]
       end
     end
   end
@@ -167,7 +166,7 @@ prefix or only the files that are requir
   end
 
   def spec_for(name)
-    spec = Gem::Specification.find_all_by_name(name, @version).last
+    spec = Gem::Specification.find_all_by_name(name, @version).first
 
     return spec if spec
 
@@ -175,7 +174,7 @@ prefix or only the files that are requir
 
     if Gem.configuration.verbose
       say "\nDirectories searched:"
-      @spec_dirs.sort.each { |dir| say dir }
+      @spec_dirs.sort.each {|dir| say dir }
     end
 
     return nil
@@ -186,5 +185,4 @@ prefix or only the files that are requir
       [i, File.join(i, "specifications")]
     end.flatten
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/dependency_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/dependency_command.rb
@@ -1,29 +1,28 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/version_option'
+require_relative "../command"
+require_relative "../local_remote_options"
+require_relative "../version_option"
 
 class Gem::Commands::DependencyCommand < Gem::Command
-
   include Gem::LocalRemoteOptions
   include Gem::VersionOption
 
   def initialize
-    super 'dependency',
-          'Show the dependencies of an installed gem',
+    super "dependency",
+          "Show the dependencies of an installed gem",
           :version => Gem::Requirement.default, :domain => :local
 
     add_version_option
     add_platform_option
     add_prerelease_option
 
-    add_option('-R', '--[no-]reverse-dependencies',
-               'Include reverse dependencies in the output') do
+    add_option("-R", "--[no-]reverse-dependencies",
+               "Include reverse dependencies in the output") do
       |value, options|
       options[:reverse_dependencies] = value
     end
 
-    add_option('-p', '--pipe',
+    add_option("-p", "--pipe",
                "Pipe Format (name --version ver)") do |value, options|
       options[:pipe_format] = value
     end
@@ -54,45 +53,45 @@ use with other commands.
     "#{program_name} REGEXP"
   end
 
-  def fetch_remote_specs(dependency) # :nodoc:
+  def fetch_remote_specs(name, requirement, prerelease) # :nodoc:
     fetcher = Gem::SpecFetcher.fetcher
 
-    ss, = fetcher.spec_for_dependency dependency
+    specs_type = prerelease ? :complete : :released
+
+    ss = if name.nil?
+      fetcher.detect(specs_type) { true }
+    else
+      fetcher.detect(specs_type) do |name_tuple|
+        name === name_tuple.name && requirement.satisfied_by?(name_tuple.version)
+      end
+    end
 
-    ss.map { |spec, _| spec }
+    ss.map {|tuple, source| source.fetch_spec(tuple) }
   end
 
-  def fetch_specs(name_pattern, dependency) # :nodoc:
+  def fetch_specs(name_pattern, requirement, prerelease) # :nodoc:
     specs = []
 
     if local?
-      specs.concat Gem::Specification.stubs.find_all { |spec|
-        name_pattern =~ spec.name and
-          dependency.requirement.satisfied_by? spec.version
+      specs.concat Gem::Specification.stubs.find_all {|spec|
+        name_matches = name_pattern ? name_pattern =~ spec.name : true
+        version_matches = requirement.satisfied_by?(spec.version)
+
+        name_matches && version_matches
       }.map(&:to_spec)
     end
 
-    specs.concat fetch_remote_specs dependency if remote?
+    specs.concat fetch_remote_specs name_pattern, requirement, prerelease if remote?
 
     ensure_specs specs
 
     specs.uniq.sort
   end
 
-  def gem_dependency(pattern, version, prerelease) # :nodoc:
-    dependency = Gem::Deprecate.skip_during do
-      Gem::Dependency.new pattern, version
-    end
-
-    dependency.prerelease = prerelease
-
-    dependency
-  end
-
   def display_pipe(specs) # :nodoc:
     specs.each do |spec|
       unless spec.dependencies.empty?
-        spec.dependencies.sort_by { |dep| dep.name }.each do |dep|
+        spec.dependencies.sort_by {|dep| dep.name }.each do |dep|
           say "#{dep.name} --version '#{dep.requirement}'"
         end
       end
@@ -120,11 +119,9 @@ use with other commands.
     ensure_local_only_reverse_dependencies
 
     pattern = name_pattern options[:args]
+    requirement = Gem::Requirement.new options[:version]
 
-    dependency =
-      gem_dependency pattern, options[:version], options[:prerelease]
-
-    specs = fetch_specs pattern, dependency
+    specs = fetch_specs pattern, requirement, options[:prerelease]
 
     reverse = reverse_dependencies specs
 
@@ -136,8 +133,8 @@ use with other commands.
   end
 
   def ensure_local_only_reverse_dependencies # :nodoc:
-    if options[:reverse_dependencies] and remote? and not local?
-      alert_error 'Only reverse dependencies for local gems are supported.'
+    if options[:reverse_dependencies] && remote? && !local?
+      alert_error "Only reverse dependencies for local gems are supported."
       terminate_interaction 1
     end
   end
@@ -145,7 +142,7 @@ use with other commands.
   def ensure_specs(specs) # :nodoc:
     return unless specs.empty?
 
-    patterns = options[:args].join ','
+    patterns = options[:args].join ","
     say "No gems found matching #{patterns} (#{options[:version]})" if
       Gem.configuration.verbose
 
@@ -154,25 +151,17 @@ use with other commands.
 
   def print_dependencies(spec, level = 0) # :nodoc:
     response = String.new
-    response << '  ' * level + "Gem #{spec.full_name}\n"
+    response << "  " * level + "Gem #{spec.full_name}\n"
     unless spec.dependencies.empty?
-      spec.dependencies.sort_by { |dep| dep.name }.each do |dep|
-        response << '  ' * level + "  #{dep}\n"
+      spec.dependencies.sort_by {|dep| dep.name }.each do |dep|
+        response << "  " * level + "  #{dep}\n"
       end
     end
     response
   end
 
-  def remote_specs(dependency) # :nodoc:
-    fetcher = Gem::SpecFetcher.fetcher
-
-    ss, _ = fetcher.spec_for_dependency dependency
-
-    ss.map { |s,o| s }
-  end
-
   def reverse_dependencies(specs) # :nodoc:
-    reverse = Hash.new { |h, k| h[k] = [] }
+    reverse = Hash.new {|h, k| h[k] = [] }
 
     return reverse unless options[:reverse_dependencies]
 
@@ -193,7 +182,7 @@ use with other commands.
       sp.dependencies.each do |dep|
         dep = Gem::Dependency.new(*dep) unless Gem::Dependency === dep
 
-        if spec.name == dep.name and
+        if spec.name == dep.name &&
            dep.requirement.satisfied_by?(spec.version)
           result << [sp.full_name, dep]
         end
@@ -206,14 +195,13 @@ use with other commands.
   private
 
   def name_pattern(args)
-    args << '' if args.empty?
+    return if args.empty?
 
-    if args.length == 1 and args.first =~ /\A(.*)(i)?\z/m
+    if args.length == 1 && args.first =~ /\A(.*)(i)?\z/m
       flags = $2 ? Regexp::IGNORECASE : nil
       Regexp.new $1, flags
     else
       /\A#{Regexp.union(*args)}/
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/environment_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/environment_command.rb
@@ -1,22 +1,22 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative "../command"
 
 class Gem::Commands::EnvironmentCommand < Gem::Command
-
   def initialize
-    super 'environment', 'Display information about the RubyGems environment'
+    super "environment", "Display information about the RubyGems environment"
   end
 
   def arguments # :nodoc:
     args = <<-EOF
-          gemdir          display the path where gems are installed
-          gempath         display path used to search for gems
+          home            display the path where gems are installed. Aliases: gemhome, gemdir, GEM_HOME
+          path            display path used to search for gems. Aliases: gempath, GEM_PATH
+          user_gemhome    display the path where gems are installed when `--user-install` is given. Aliases: user_gemdir
           version         display the gem format version
           remotesources   display the remote gem servers
           platform        display the supported gem platforms
           <omitted>       display everything
     EOF
-    return args.gsub(/^\s+/, '')
+    return args.gsub(/^\s+/, "")
   end
 
   def description # :nodoc:
@@ -81,6 +81,8 @@ lib/rubygems/defaults/operating_system.r
         Gem.dir
       when /^gempath/, /^path/, /^GEM_PATH/ then
         Gem.path.join(File::PATH_SEPARATOR)
+      when /^user_gemdir/, /^user_gemhome/ then
+        Gem.user_dir
       when /^remotesources/ then
         Gem.sources.to_a.join("\n")
       when /^platform/ then
@@ -127,7 +129,7 @@ lib/rubygems/defaults/operating_system.r
 
     out << "  - RUBYGEMS PLATFORMS:\n"
     Gem.platforms.each do |platform|
-      out << "    - #{platform}\n"
+      out << "     - #{platform}\n"
     end
 
     out << "  - GEM PATHS:\n"
@@ -139,7 +141,7 @@ lib/rubygems/defaults/operating_system.r
 
     out << "  - GEM CONFIGURATION:\n"
     Gem.configuration.each do |name, value|
-      value = value.gsub(/./, '*') if name == 'gemcutter_key'
+      value = value.gsub(/./, "*") if name == "gemcutter_key"
       out << "     - #{name.inspect} => #{value.inspect}\n"
     end
 
@@ -150,7 +152,7 @@ lib/rubygems/defaults/operating_system.r
 
     out << "  - SHELL PATH:\n"
 
-    shell_path = ENV['PATH'].split(File::PATH_SEPARATOR)
+    shell_path = ENV["PATH"].split(File::PATH_SEPARATOR)
     add_path out, shell_path
 
     out
@@ -172,5 +174,4 @@ lib/rubygems/defaults/operating_system.r
 
     return nil
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/fetch_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/fetch_command.rb
@@ -1,15 +1,19 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/version_option'
+require_relative "../command"
+require_relative "../local_remote_options"
+require_relative "../version_option"
 
 class Gem::Commands::FetchCommand < Gem::Command
-
   include Gem::LocalRemoteOptions
   include Gem::VersionOption
 
   def initialize
-    super 'fetch', 'Download a gem and place it in the current directory'
+    defaults = {
+      :suggest_alternate => true,
+      :version           => Gem::Requirement.default,
+    }
+
+    super "fetch", "Download a gem and place it in the current directory", defaults
 
     add_bulk_threshold_option
     add_proxy_option
@@ -19,10 +23,14 @@ class Gem::Commands::FetchCommand < Gem:
     add_version_option
     add_platform_option
     add_prerelease_option
+
+    add_option "--[no-]suggestions", "Suggest alternates when gems are not found" do |value, options|
+      options[:suggest_alternate] = value
+    end
   end
 
   def arguments # :nodoc:
-    'GEMNAME       name of gem to download'
+    "GEMNAME       name of gem to download"
   end
 
   def defaults_str # :nodoc:
@@ -43,35 +51,44 @@ then repackaging it.
     "#{program_name} GEMNAME [GEMNAME ...]"
   end
 
+  def check_version # :nodoc:
+    if options[:version] != Gem::Requirement.default &&
+       get_all_gem_names.size > 1
+      alert_error "Can't use --version with multiple gems. You can specify multiple gems with" \
+                  " version requirements using `gem fetch 'my_gem:1.0.0' 'my_other_gem:~>2.0.0'`"
+      terminate_interaction 1
+    end
+  end
+
   def execute
-    version = options[:version] || Gem::Requirement.default
+    check_version
+    version = options[:version]
 
     platform  = Gem.platforms.last
-    gem_names = get_all_gem_names
+    gem_names = get_all_gem_names_and_versions
 
-    gem_names.each do |gem_name|
-      dep = Gem::Dependency.new gem_name, version
+    gem_names.each do |gem_name, gem_version|
+      gem_version ||= version
+      dep = Gem::Dependency.new gem_name, gem_version
       dep.prerelease = options[:prerelease]
+      suppress_suggestions = !options[:suggest_alternate]
 
       specs_and_sources, errors =
         Gem::SpecFetcher.fetcher.spec_for_dependency dep
 
       if platform
-        filtered = specs_and_sources.select { |s,| s.platform == platform }
+        filtered = specs_and_sources.select {|s,| s.platform == platform }
         specs_and_sources = filtered unless filtered.empty?
       end
 
-      spec, source = specs_and_sources.max_by { |s,| s.version }
+      spec, source = specs_and_sources.max_by {|s,| s }
 
       if spec.nil?
-        show_lookup_failure gem_name, version, errors, options[:domain]
+        show_lookup_failure gem_name, gem_version, errors, suppress_suggestions, options[:domain]
         next
       end
-
       source.download spec
-
       say "Downloaded #{spec.full_name}"
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/generate_index_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/generate_index_command.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/indexer'
+require_relative "../command"
+require_relative "../indexer"
 
 ##
 # Generates a index files for use as a gem server.
@@ -8,29 +8,28 @@ require 'rubygems/indexer'
 # See `gem help generate_index`
 
 class Gem::Commands::GenerateIndexCommand < Gem::Command
-
   def initialize
-    super 'generate_index',
-          'Generates the index files for a gem server directory',
-          :directory => '.', :build_modern => true
+    super "generate_index",
+          "Generates the index files for a gem server directory",
+          :directory => ".", :build_modern => true
 
-    add_option '-d', '--directory=DIRNAME',
-               'repository base dir containing gems subdir' do |dir, options|
+    add_option "-d", "--directory=DIRNAME",
+               "repository base dir containing gems subdir" do |dir, options|
       options[:directory] = File.expand_path dir
     end
 
-    add_option '--[no-]modern',
-               'Generate indexes for RubyGems',
-               '(always true)' do |value, options|
+    add_option "--[no-]modern",
+               "Generate indexes for RubyGems",
+               "(always true)" do |value, options|
       options[:build_modern] = value
     end
 
-    deprecate_option('--modern', version: '4.0', extra_msg: 'Modern indexes (specs, latest_specs, and prerelease_specs) are always generated, so this option is not needed.')
-    deprecate_option('--no-modern', version: '4.0', extra_msg: 'The `--no-modern` option is currently ignored. Modern indexes (specs, latest_specs, and prerelease_specs) are always generated.')
+    deprecate_option("--modern", version: "4.0", extra_msg: "Modern indexes (specs, latest_specs, and prerelease_specs) are always generated, so this option is not needed.")
+    deprecate_option("--no-modern", version: "4.0", extra_msg: "The `--no-modern` option is currently ignored. Modern indexes (specs, latest_specs, and prerelease_specs) are always generated.")
 
-    add_option '--update',
-               'Update modern indexes with gems added',
-               'since the last update' do |value, options|
+    add_option "--update",
+               "Update modern indexes with gems added",
+               "since the last update" do |value, options|
       options[:update] = value
     end
   end
@@ -69,8 +68,8 @@ Marshal::MINOR_VERSION constants.  It is
     # This is always true because it's the only way now.
     options[:build_modern] = true
 
-    if not File.exist?(options[:directory]) or
-       not File.directory?(options[:directory])
+    if !File.exist?(options[:directory]) ||
+       !File.directory?(options[:directory])
       alert_error "unknown directory name #{options[:directory]}."
       terminate_interaction 1
     else
@@ -83,5 +82,4 @@ Marshal::MINOR_VERSION constants.  It is
       end
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/help_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/help_command.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative "../command"
 
 class Gem::Commands::HelpCommand < Gem::Command
-
   # :stopdoc:
   EXAMPLES = <<-EOF.freeze
 Some examples of 'gem' usage.
@@ -281,7 +280,7 @@ platform.
   # :startdoc:
 
   def initialize
-    super 'help', "Provide help on the 'gem' command"
+    super "help", "Provide help on the 'gem' command"
 
     @command_manager = Gem::CommandManager.instance
   end
@@ -324,15 +323,17 @@ platform.
 
     margin_width = 4
 
-    desc_width = @command_manager.command_names.map { |n| n.size }.max + 4
+    desc_width = @command_manager.command_names.map {|n| n.size }.max + 4
 
     summary_width = 80 - margin_width - desc_width
-    wrap_indent = ' ' * (margin_width + desc_width)
+    wrap_indent = " " * (margin_width + desc_width)
     format = "#{' ' * margin_width}%-#{desc_width}s%s"
 
     @command_manager.command_names.each do |cmd_name|
       command = @command_manager[cmd_name]
 
+      next if command.deprecated?
+
       summary =
         if command
           command.summary
@@ -370,5 +371,4 @@ platform.
       alert_warning "Unknown command #{command_name}. Try: gem help commands"
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/info_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/info_command.rb
@@ -1,15 +1,19 @@
 # frozen_string_literal: true
 
-require 'rubygems/command'
-require 'rubygems/commands/query_command'
+require_relative "../command"
+require_relative "../query_utils"
 
-class Gem::Commands::InfoCommand < Gem::Commands::QueryCommand
+class Gem::Commands::InfoCommand < Gem::Command
+  include Gem::QueryUtils
 
   def initialize
-    super "info", "Show information for the given gem"
+    super "info", "Show information for the given gem",
+         :name => //, :domain => :local, :details => false, :versions => true,
+         :installed => nil, :version => Gem::Requirement.default
 
-    remove_option('--name-matches')
-    remove_option('-d')
+    add_query_options
+
+    remove_option("-d")
 
     defaults[:details] = true
     defaults[:exact] = true
@@ -31,5 +35,4 @@ class Gem::Commands::InfoCommand < Gem::
   def defaults_str
     "--local"
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/install_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/install_command.rb
@@ -1,10 +1,10 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/install_update_options'
-require 'rubygems/dependency_installer'
-require 'rubygems/local_remote_options'
-require 'rubygems/validator'
-require 'rubygems/version_option'
+require_relative "../command"
+require_relative "../install_update_options"
+require_relative "../dependency_installer"
+require_relative "../local_remote_options"
+require_relative "../validator"
+require_relative "../version_option"
 
 ##
 # Gem installer command line tool
@@ -12,7 +12,6 @@ require 'rubygems/version_option'
 # See `gem help install`
 
 class Gem::Commands::InstallCommand < Gem::Command
-
   attr_reader :installed_specs # :nodoc:
 
   include Gem::VersionOption
@@ -28,7 +27,9 @@ class Gem::Commands::InstallCommand < Ge
       :without_groups    => [],
     })
 
-    super 'install', 'Install a gem into the local repository', defaults
+    defaults.merge!(install_update_options)
+
+    super "install", "Install a gem into the local repository", defaults
 
     add_install_update_options
     add_local_remote_options
@@ -44,8 +45,9 @@ class Gem::Commands::InstallCommand < Ge
   end
 
   def defaults_str # :nodoc:
-    "--both --version '#{Gem::Requirement.default}' --document --no-force\n" +
-    "--install-dir #{Gem.dir} --lock"
+    "--both --version '#{Gem::Requirement.default}' --no-force\n" +
+      "--install-dir #{Gem.dir} --lock\n" +
+      install_update_defaults_str
   end
 
   def description # :nodoc:
@@ -128,19 +130,19 @@ You can use `i` command instead of `inst
   end
 
   def usage # :nodoc:
-    "#{program_name} GEMNAME [GEMNAME ...] [options] -- --build-flags"
+    "#{program_name} [options] GEMNAME [GEMNAME ...] -- --build-flags"
   end
 
   def check_install_dir # :nodoc:
-    if options[:install_dir] and options[:user_install]
+    if options[:install_dir] && options[:user_install]
       alert_error "Use --install-dir or --user-install but not both"
       terminate_interaction 1
     end
   end
 
   def check_version # :nodoc:
-    if options[:version] != Gem::Requirement.default and
-         get_all_gem_names.size > 1
+    if options[:version] != Gem::Requirement.default &&
+       get_all_gem_names.size > 1
       alert_error "Can't use --version with multiple gems. You can specify multiple gems with" \
                   " version requirements using `gem install 'my_gem:1.0.0' 'my_other_gem:~>2.0.0'`"
       terminate_interaction 1
@@ -155,7 +157,7 @@ You can use `i` command instead of `inst
 
     @installed_specs = []
 
-    ENV.delete 'GEM_PATH' if options[:install_dir].nil?
+    ENV.delete "GEM_PATH" if options[:install_dir].nil?
 
     check_install_dir
     check_version
@@ -170,7 +172,7 @@ You can use `i` command instead of `inst
   end
 
   def install_from_gemdeps # :nodoc:
-    require 'rubygems/request_set'
+    require_relative "../request_set"
     rs = Gem::RequestSet.new
 
     specs = rs.install_from_gemdeps options do |req, inst|
@@ -189,8 +191,8 @@ You can use `i` command instead of `inst
   end
 
   def install_gem(name, version) # :nodoc:
-    return if options[:conservative] and
-      not Gem::Dependency.new(name, version).matching_specs.empty?
+    return if options[:conservative] &&
+              !Gem::Dependency.new(name, version).matching_specs.empty?
 
     req = Gem::Requirement.create(version)
 
@@ -218,7 +220,7 @@ You can use `i` command instead of `inst
       gem_version ||= options[:version]
       domain = options[:domain]
       domain = :local unless options[:suggest_alternate]
-      supress_suggestions = (domain == :local)
+      suppress_suggestions = (domain == :local)
 
       begin
         install_gem gem_name, gem_version
@@ -226,11 +228,11 @@ You can use `i` command instead of `inst
         alert_error "Error installing #{gem_name}:\n\t#{e.message}"
         exit_code |= 1
       rescue Gem::GemNotFoundException => e
-        show_lookup_failure e.name, e.version, e.errors, supress_suggestions
+        show_lookup_failure e.name, e.version, e.errors, suppress_suggestions
 
         exit_code |= 2
       rescue Gem::UnsatisfiableDependencyError => e
-        show_lookup_failure e.name, e.version, e.errors, supress_suggestions,
+        show_lookup_failure e.name, e.version, e.errors, suppress_suggestions,
                             "'#{gem_name}' (#{gem_version})"
 
         exit_code |= 2
@@ -245,11 +247,11 @@ You can use `i` command instead of `inst
 
   def load_hooks # :nodoc:
     if options[:install_as_default]
-      require 'rubygems/install_default_message'
+      require_relative "../install_default_message"
     else
-      require 'rubygems/install_message'
+      require_relative "../install_message"
     end
-    require 'rubygems/rdoc'
+    require_relative "../rdoc"
   end
 
   def show_install_errors(errors) # :nodoc:
@@ -258,7 +260,8 @@ You can use `i` command instead of `inst
     errors.each do |x|
       return unless Gem::SourceFetchProblem === x
 
-      msg = "Unable to pull data from '#{x.source.uri}': #{x.error.message}"
+      require_relative "../uri"
+      msg = "Unable to pull data from '#{Gem::Uri.redact(x.source.uri)}': #{x.error.message}"
 
       alert_warning msg
     end
@@ -267,8 +270,7 @@ You can use `i` command instead of `inst
   def show_installed # :nodoc:
     return if @installed_specs.empty?
 
-    gems = @installed_specs.length == 1 ? 'gem' : 'gems'
+    gems = @installed_specs.length == 1 ? "gem" : "gems"
     say "#{@installed_specs.length} #{gems} installed"
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/list_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/list_command.rb
@@ -1,17 +1,19 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/commands/query_command'
+require_relative "../command"
+require_relative "../query_utils"
 
 ##
-# An alternate to Gem::Commands::QueryCommand that searches for gems starting
-# with the supplied argument.
+# Searches for gems starting with the supplied argument.
 
-class Gem::Commands::ListCommand < Gem::Commands::QueryCommand
+class Gem::Commands::ListCommand < Gem::Command
+  include Gem::QueryUtils
 
   def initialize
-    super 'list', 'Display local gems whose name matches REGEXP'
+    super "list", "Display local gems whose name matches REGEXP",
+         :domain => :local, :details => false, :versions => true,
+         :installed => nil, :version => Gem::Requirement.default
 
-    remove_option('--name-matches')
+    add_query_options
   end
 
   def arguments # :nodoc:
@@ -36,5 +38,4 @@ To search for remote gems use the search
   def usage # :nodoc:
     "#{program_name} [REGEXP ...]"
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/lock_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/lock_command.rb
@@ -1,14 +1,13 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative "../command"
 
 class Gem::Commands::LockCommand < Gem::Command
-
   def initialize
-    super 'lock', 'Generate a lockdown list of gems',
+    super "lock", "Generate a lockdown list of gems",
           :strict => false
 
-    add_option '-s', '--[no-]strict',
-               'fail if unable to satisfy a dependency' do |strict, options|
+    add_option "-s", "--[no-]strict",
+               "fail if unable to satisfy a dependency" do |strict, options|
       options[:strict] = strict
     end
   end
@@ -104,7 +103,6 @@ lock it down to the exact version.
       File.join path, "specifications", "#{gem_full_name}.gemspec"
     end
 
-    gemspecs.find { |path| File.exist? path }
+    gemspecs.find {|path| File.exist? path }
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/mirror_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/mirror_command.rb
@@ -1,13 +1,12 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative "../command"
 
 unless defined? Gem::Commands::MirrorCommand
   class Gem::Commands::MirrorCommand < Gem::Command
-
     def initialize
-      super('mirror', 'Mirror all gem files (requires rubygems-mirror)')
+      super("mirror", "Mirror all gem files (requires rubygems-mirror)")
       begin
-        Gem::Specification.find_by_name('rubygems-mirror').activate
+        Gem::Specification.find_by_name("rubygems-mirror").activate
       rescue Gem::LoadError
         # no-op
       end
@@ -22,6 +21,5 @@ The mirror command has been moved to the
     def execute
       alert_error "Install the rubygems-mirror gem for the mirror command"
     end
-
   end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/open_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/open_command.rb
@@ -1,21 +1,18 @@
 # frozen_string_literal: true
-require 'English'
-require 'rubygems/command'
-require 'rubygems/version_option'
-require 'rubygems/util'
+require_relative "../command"
+require_relative "../version_option"
 
 class Gem::Commands::OpenCommand < Gem::Command
-
   include Gem::VersionOption
 
   def initialize
-    super 'open', 'Open gem sources in editor'
+    super "open", "Open gem sources in editor"
 
-    add_option('-e', '--editor COMMAND', String,
+    add_option("-e", "--editor COMMAND", String,
                "Prepends COMMAND to gem path. Could be used to specify editor.") do |command, options|
       options[:editor] = command || get_env_editor
     end
-    add_option('-v', '--version VERSION', String,
+    add_option("-v", "--version VERSION", String,
                "Opens specific gem version") do |version|
       options[:version] = version
     end
@@ -39,14 +36,14 @@ class Gem::Commands::OpenCommand < Gem::
   end
 
   def usage # :nodoc:
-    "#{program_name} GEMNAME [-e COMMAND]"
+    "#{program_name} [-e COMMAND] GEMNAME"
   end
 
   def get_env_editor
-    ENV['GEM_EDITOR'] ||
-      ENV['VISUAL'] ||
-      ENV['EDITOR'] ||
-      'vi'
+    ENV["GEM_EDITOR"] ||
+      ENV["VISUAL"] ||
+      ENV["EDITOR"] ||
+      "vi"
   end
 
   def execute
@@ -84,5 +81,4 @@ class Gem::Commands::OpenCommand < Gem::
 
     say "Unable to find gem '#{name}'"
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/outdated_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/outdated_command.rb
@@ -1,16 +1,15 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/spec_fetcher'
-require 'rubygems/version_option'
+require_relative "../command"
+require_relative "../local_remote_options"
+require_relative "../spec_fetcher"
+require_relative "../version_option"
 
 class Gem::Commands::OutdatedCommand < Gem::Command
-
   include Gem::LocalRemoteOptions
   include Gem::VersionOption
 
   def initialize
-    super 'outdated', 'Display all gems that need updates'
+    super "outdated", "Display all gems that need updates"
 
     add_local_remote_options
     add_platform_option
@@ -30,5 +29,4 @@ update the gems with the update or insta
       say "#{spec.name} (#{spec.version} < #{remote_version})"
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/owner_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/owner_command.rb
@@ -1,11 +1,10 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/gemcutter_utilities'
-require 'rubygems/text'
+require_relative "../command"
+require_relative "../local_remote_options"
+require_relative "../gemcutter_utilities"
+require_relative "../text"
 
 class Gem::Commands::OwnerCommand < Gem::Command
-
   include Gem::Text
   include Gem::LocalRemoteOptions
   include Gem::GemcutterUtilities
@@ -13,7 +12,12 @@ class Gem::Commands::OwnerCommand < Gem:
   def description # :nodoc:
     <<-EOF
 The owner command lets you add and remove owners of a gem on a push
-server (the default is https://rubygems.org).
+server (the default is https://rubygems.org). Multiple owners can be
+added or removed at the same time, if the flag is given multiple times.
+
+The supported user identifiers are dependant on the push server.
+For rubygems.org, both e-mail and handle are supported, even though the
+user identifier field is called "email".
 
 The owner of a gem has the permission to push new versions, yank existing
 versions or edit the HTML page of the gem.  Be careful of who you give push
@@ -30,23 +34,23 @@ permission to.
   end
 
   def initialize
-    super 'owner', 'Manage gem owners of a gem on the push server'
+    super "owner", "Manage gem owners of a gem on the push server"
     add_proxy_option
     add_key_option
     add_otp_option
     defaults.merge! :add => [], :remove => []
 
-    add_option '-a', '--add EMAIL', 'Add an owner' do |value, options|
+    add_option "-a", "--add NEW_OWNER", "Add an owner by user identifier" do |value, options|
       options[:add] << value
     end
 
-    add_option '-r', '--remove EMAIL', 'Remove an owner' do |value, options|
+    add_option "-r", "--remove OLD_OWNER", "Remove an owner by user identifier" do |value, options|
       options[:remove] << value
     end
 
-    add_option '-h', '--host HOST',
-               'Use another gemcutter-compatible host',
-               '  (e.g. https://rubygems.org)' do |value, options|
+    add_option "-h", "--host HOST",
+               "Use another gemcutter-compatible host",
+               "  (e.g. https://rubygems.org)" do |value, options|
       options[:host] = value
     end
   end
@@ -54,7 +58,7 @@ permission to.
   def execute
     @host = options[:host]
 
-    sign_in
+    sign_in(scope: get_owner_scope)
     name = get_one_gem_name
 
     add_owners    name, options[:add]
@@ -103,11 +107,17 @@ permission to.
   private
 
   def send_owner_request(method, name, owner)
-    rubygems_api_request method, "api/v1/gems/#{name}/owners" do |request|
-      request.set_form_data 'email' => owner
+    rubygems_api_request method, "api/v1/gems/#{name}/owners", scope: get_owner_scope(method: method) do |request|
+      request.set_form_data "email" => owner
       request.add_field "Authorization", api_key
-      request.add_field "OTP", options[:otp] if options[:otp]
     end
   end
 
+  def get_owner_scope(method: nil)
+    if method == :post || options.any? && options[:add].any?
+      :add_owner
+    elsif method == :delete || options.any? && options[:remove].any?
+      :remove_owner
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/pristine_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/pristine_command.rb
@@ -1,58 +1,67 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/package'
-require 'rubygems/installer'
-require 'rubygems/version_option'
+require_relative "../command"
+require_relative "../package"
+require_relative "../installer"
+require_relative "../version_option"
 
 class Gem::Commands::PristineCommand < Gem::Command
-
   include Gem::VersionOption
 
   def initialize
-    super 'pristine',
-          'Restores installed gems to pristine condition from files located in the gem cache',
+    super "pristine",
+          "Restores installed gems to pristine condition from files located in the gem cache",
           :version => Gem::Requirement.default,
           :extensions => true,
           :extensions_set => false,
           :all => false
 
-    add_option('--all',
-               'Restore all installed gems to pristine',
-               'condition') do |value, options|
+    add_option("--all",
+               "Restore all installed gems to pristine",
+               "condition") do |value, options|
       options[:all] = value
     end
 
-    add_option('--skip=gem_name',
-               'used on --all, skip if name == gem_name') do |value, options|
+    add_option("--skip=gem_name",
+               "used on --all, skip if name == gem_name") do |value, options|
       options[:skip] ||= []
       options[:skip] << value
     end
 
-    add_option('--[no-]extensions',
-               'Restore gems with extensions',
-               'in addition to regular gems') do |value, options|
+    add_option("--[no-]extensions",
+               "Restore gems with extensions",
+               "in addition to regular gems") do |value, options|
       options[:extensions_set] = true
       options[:extensions]     = value
     end
 
-    add_option('--only-executables',
-               'Only restore executables') do |value, options|
+    add_option("--only-executables",
+               "Only restore executables") do |value, options|
       options[:only_executables] = value
     end
 
-    add_option('-E', '--[no-]env-shebang',
-               'Rewrite executables with a shebang',
-               'of /usr/bin/env') do |value, options|
+    add_option("--only-plugins",
+               "Only restore plugins") do |value, options|
+      options[:only_plugins] = value
+    end
+
+    add_option("-E", "--[no-]env-shebang",
+               "Rewrite executables with a shebang",
+               "of /usr/bin/env") do |value, options|
       options[:env_shebang] = value
     end
 
-    add_option('-n', '--bindir DIR',
-               'Directory where executables are',
-               'located') do |value, options|
+    add_option("-i", "--install-dir DIR",
+               "Gem repository to get binstubs and plugins installed") do |value, options|
+      options[:install_dir] = File.expand_path(value)
+    end
+
+    add_option("-n", "--bindir DIR",
+               "Directory where executables are",
+               "located") do |value, options|
       options[:bin_dir] = File.expand_path(value)
     end
 
-    add_version_option('restore to', 'pristine condition')
+    add_version_option("restore to", "pristine condition")
   end
 
   def arguments # :nodoc:
@@ -60,7 +69,7 @@ class Gem::Commands::PristineCommand < G
   end
 
   def defaults_str # :nodoc:
-    '--extensions'
+    "--extensions"
   end
 
   def description # :nodoc:
@@ -89,22 +98,22 @@ extensions will be restored.
 
   def execute
     specs = if options[:all]
-              Gem::Specification.map
+      Gem::Specification.map
 
-            # `--extensions` must be explicitly given to pristine only gems
-            # with extensions.
-            elsif options[:extensions_set] and
-                  options[:extensions] and options[:args].empty?
-              Gem::Specification.select do |spec|
-                spec.extensions and not spec.extensions.empty?
-              end
-            else
-              get_all_gem_names.sort.map do |gem_name|
-                Gem::Specification.find_all_by_name(gem_name, options[:version]).reverse
-              end.flatten
-            end
+    # `--extensions` must be explicitly given to pristine only gems
+    # with extensions.
+    elsif options[:extensions_set] &&
+          options[:extensions] && options[:args].empty?
+      Gem::Specification.select do |spec|
+        spec.extensions && !spec.extensions.empty?
+      end
+    else
+      get_all_gem_names.sort.map do |gem_name|
+        Gem::Specification.find_all_by_name(gem_name, options[:version]).reverse
+      end.flatten
+    end
 
-    specs = specs.select{|spec| RUBY_ENGINE == spec.platform || Gem::Platform.local === spec.platform || spec.platform == Gem::Platform::RUBY }
+    specs = specs.select {|spec| RUBY_ENGINE == spec.platform || Gem::Platform.local === spec.platform || spec.platform == Gem::Platform::RUBY }
 
     if specs.to_a.empty?
       raise Gem::Exception,
@@ -126,15 +135,15 @@ extensions will be restored.
         end
       end
 
-      unless spec.extensions.empty? or options[:extensions] or options[:only_executables]
+      unless spec.extensions.empty? || options[:extensions] || options[:only_executables] || options[:only_plugins]
         say "Skipped #{spec.full_name}, it needs to compile an extension"
         next
       end
 
       gem = spec.cache_file
 
-      unless File.exist? gem or options[:only_executables]
-        require 'rubygems/remote_fetcher'
+      unless File.exist?(gem) || options[:only_executables] || options[:only_plugins]
+        require_relative "../remote_fetcher"
 
         say "Cached gem for #{spec.full_name} not found, attempting to fetch..."
 
@@ -154,24 +163,28 @@ extensions will be restored.
         if options.include? :env_shebang
           options[:env_shebang]
         else
-          install_defaults = Gem::ConfigFile::PLATFORM_DEFAULTS['install']
-          install_defaults.to_s['--env-shebang']
+          install_defaults = Gem::ConfigFile::PLATFORM_DEFAULTS["install"]
+          install_defaults.to_s["--env-shebang"]
         end
 
       bin_dir = options[:bin_dir] if options[:bin_dir]
+      install_dir = options[:install_dir] if options[:install_dir]
 
       installer_options = {
         :wrappers => true,
         :force => true,
-        :install_dir => spec.base_dir,
+        :install_dir => install_dir || spec.base_dir,
         :env_shebang => env_shebang,
         :build_args => spec.build_args,
-        :bin_dir => bin_dir
+        :bin_dir => bin_dir,
       }
 
       if options[:only_executables]
         installer = Gem::Installer.for_spec(spec, installer_options)
         installer.generate_bin
+      elsif options[:only_plugins]
+        installer = Gem::Installer.for_spec(spec, installer_options)
+        installer.generate_plugins
       else
         installer = Gem::Installer.at(gem, installer_options)
         installer.install
@@ -180,5 +193,4 @@ extensions will be restored.
       say "Restored #{spec.full_name}"
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/push_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/push_command.rb
@@ -1,11 +1,10 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/gemcutter_utilities'
-require 'rubygems/package'
+require_relative "../command"
+require_relative "../local_remote_options"
+require_relative "../gemcutter_utilities"
+require_relative "../package"
 
 class Gem::Commands::PushCommand < Gem::Command
-
   include Gem::LocalRemoteOptions
   include Gem::GemcutterUtilities
 
@@ -30,7 +29,7 @@ The push command will use ~/.gem/credent
   end
 
   def initialize
-    super 'push', 'Push a gem up to the gem server', :host => self.host
+    super "push", "Push a gem up to the gem server", :host => self.host
 
     @user_defined_host = false
 
@@ -38,9 +37,9 @@ The push command will use ~/.gem/credent
     add_key_option
     add_otp_option
 
-    add_option('--host HOST',
-               'Push to another gemcutter-compatible host',
-               '  (e.g. https://rubygems.org)') do |value, options|
+    add_option("--host HOST",
+               "Push to another gemcutter-compatible host",
+               "  (e.g. https://rubygems.org)") do |value, options|
       options[:host] = value
       @user_defined_host = true
     end
@@ -52,26 +51,17 @@ The push command will use ~/.gem/credent
     gem_name = get_one_gem_name
     default_gem_server, push_host = get_hosts_for(gem_name)
 
-    default_host = nil
-    user_defined_host = nil
-
-    if @user_defined_host
-      user_defined_host = options[:host]
+    @host = if @user_defined_host
+      options[:host]
+    elsif default_gem_server
+      default_gem_server
+    elsif push_host
+      push_host
     else
-      default_host = options[:host]
+      options[:host]
     end
 
-    @host = if user_defined_host
-              user_defined_host
-            elsif default_gem_server
-              default_gem_server
-            elsif push_host
-              push_host
-            else
-              default_host
-            end
-
-    sign_in @host
+    sign_in @host, scope: get_push_scope
 
     send_gem(gem_name)
   end
@@ -79,36 +69,7 @@ The push command will use ~/.gem/credent
   def send_gem(name)
     args = [:post, "api/v1/gems"]
 
-    latest_rubygems_version = Gem.latest_rubygems_version
-
-    if latest_rubygems_version < Gem.rubygems_version and
-         Gem.rubygems_version.prerelease? and
-         Gem::Version.new('2.0.0.rc.2') != Gem.rubygems_version
-      alert_error <<-ERROR
-You are using a beta release of RubyGems (#{Gem::VERSION}) which is not
-allowed to push gems.  Please downgrade or upgrade to a release version.
-
-The latest released RubyGems version is #{latest_rubygems_version}
-
-You can upgrade or downgrade to the latest release version with:
-
-  gem update --system=#{latest_rubygems_version}
-
-      ERROR
-      terminate_interaction 1
-    end
-
-    gem_data = Gem::Package.new(name)
-
-    unless @host
-      @host = gem_data.spec.metadata['default_gem_server']
-    end
-
-    push_host = nil
-
-    if gem_data.spec.metadata.has_key?('allowed_push_host')
-      push_host = gem_data.spec.metadata['allowed_push_host']
-    end
+    _, push_host = get_hosts_for(name)
 
     @host ||= push_host
 
@@ -125,12 +86,11 @@ You can upgrade or downgrade to the late
   private
 
   def send_push_request(name, args)
-    rubygems_api_request(*args) do |request|
+    rubygems_api_request(*args, scope: get_push_scope) do |request|
       request.body = Gem.read_binary name
       request.add_field "Content-Length", request.body.size
       request.add_field "Content-Type",   "application/octet-stream"
       request.add_field "Authorization",  api_key
-      request.add_field "OTP", options[:otp] if options[:otp]
     end
   end
 
@@ -139,8 +99,11 @@ You can upgrade or downgrade to the late
 
     [
       gem_metadata["default_gem_server"],
-      gem_metadata["allowed_push_host"]
+      gem_metadata["allowed_push_host"],
     ]
   end
 
+  def get_push_scope
+    :push_rubygem
+  end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/query_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/query_command.rb
@@ -1,71 +1,35 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/spec_fetcher'
-require 'rubygems/version_option'
-require 'rubygems/text'
+require_relative "../command"
+require_relative "../query_utils"
+require_relative "../deprecate"
 
 class Gem::Commands::QueryCommand < Gem::Command
+  extend Gem::Deprecate
+  rubygems_deprecate_command
 
-  include Gem::Text
-  include Gem::LocalRemoteOptions
-  include Gem::VersionOption
+  include Gem::QueryUtils
 
-  def initialize(name = 'query',
-                 summary = 'Query gem information in local or remote repositories')
-    super name, summary,
-         :name => //, :domain => :local, :details => false, :versions => true,
-         :installed => nil, :version => Gem::Requirement.default
-
-    add_option('-i', '--[no-]installed',
-               'Check for installed gem') do |value, options|
-      options[:installed] = value
-    end
+  alias warning_without_suggested_alternatives deprecation_warning
+  def deprecation_warning
+    warning_without_suggested_alternatives
 
-    add_option('-I', 'Equivalent to --no-installed') do |value, options|
-      options[:installed] = false
-    end
+    message = "It is recommended that you use `gem search` or `gem list` instead.\n"
+    alert_warning message unless Gem::Deprecate.skip
+  end
 
-    add_version_option command, "for use with --installed"
+  def initialize(name = "query",
+                 summary = "Query gem information in local or remote repositories")
+    super name, summary,
+         :domain => :local, :details => false, :versions => true,
+         :installed => nil, :version => Gem::Requirement.default
 
-    add_option('-n', '--name-matches REGEXP',
-               'Name of gem(s) to query on matches the',
-               'provided REGEXP') do |value, options|
+    add_option("-n", "--name-matches REGEXP",
+               "Name of gem(s) to query on matches the",
+               "provided REGEXP") do |value, options|
       options[:name] = /#{value}/i
     end
 
-    add_option('-d', '--[no-]details',
-               'Display detailed information of gem(s)') do |value, options|
-      options[:details] = value
-    end
-
-    add_option('--[no-]versions',
-               'Display only gem names') do |value, options|
-      options[:versions] = value
-      options[:details] = false unless value
-    end
-
-    add_option('-a', '--all',
-               'Display all gem versions') do |value, options|
-      options[:all] = value
-    end
-
-    add_option('-e', '--exact',
-               'Name of gem(s) to query on matches the',
-               'provided STRING') do |value, options|
-      options[:exact] = value
-    end
-
-    add_option('--[no-]prerelease',
-               'Display prerelease versions') do |value, options|
-      options[:prerelease] = value
-    end
-
-    add_local_remote_options
-  end
-
-  def defaults_str # :nodoc:
-    "--local --name-matches // --no-details --versions --no-installed"
+    add_query_options
   end
 
   def description # :nodoc:
@@ -76,298 +40,4 @@ You should really use the list and searc
 is too hard to use.
     EOF
   end
-
-  def execute
-    gem_names = Array(options[:name])
-
-    if !args.empty?
-      gem_names = options[:exact] ? args.map{|arg| /\A#{Regexp.escape(arg)}\Z/ } : args.map{|arg| /#{arg}/i }
-    end
-
-    terminate_interaction(check_installed_gems(gem_names)) if check_installed_gems?
-
-    gem_names.each { |n| show_gems(n) }
-  end
-
-  private
-
-  def check_installed_gems(gem_names)
-    exit_code = 0
-
-    if args.empty? && !gem_name?
-      alert_error "You must specify a gem name"
-      exit_code = 4
-    elsif gem_names.count > 1
-      alert_error "You must specify only ONE gem!"
-      exit_code = 4
-    else
-      installed = installed?(gem_names.first, options[:version])
-      installed = !installed unless options[:installed]
-
-      say(installed)
-      exit_code = 1 if !installed
-    end
-
-    exit_code
-  end
-
-  def check_installed_gems?
-    !options[:installed].nil?
-  end
-
-  def gem_name?
-    !options[:name].source.empty?
-  end
-
-  def prerelease
-    options[:prerelease]
-  end
-
-  def show_prereleases?
-    prerelease.nil? || prerelease
-  end
-
-  def args
-    options[:args].to_a
-  end
-
-  def display_header(type)
-    if (ui.outs.tty? and Gem.configuration.verbose) or both?
-      say
-      say "*** #{type} GEMS ***"
-      say
-    end
-  end
-
-  #Guts of original execute
-  def show_gems(name)
-    show_local_gems(name)  if local?
-    show_remote_gems(name) if remote?
-  end
-
-  def show_local_gems(name, req = Gem::Requirement.default)
-    display_header("LOCAL")
-
-    specs = Gem::Specification.find_all do |s|
-      s.name =~ name and req =~ s.version
-    end
-
-    dep = Gem::Deprecate.skip_during { Gem::Dependency.new name, req }
-    specs.select! do |s|
-      dep.match?(s.name, s.version, show_prereleases?)
-    end
-
-    spec_tuples = specs.map do |spec|
-      [spec.name_tuple, spec]
-    end
-
-    output_query_results(spec_tuples)
-  end
-
-  def show_remote_gems(name)
-    display_header("REMOTE")
-
-    fetcher = Gem::SpecFetcher.fetcher
-
-    spec_tuples = if name.respond_to?(:source) && name.source.empty?
-                    fetcher.detect(specs_type) { true }
-                  else
-                    fetcher.detect(specs_type) do |name_tuple|
-                      name === name_tuple.name
-                    end
-                  end
-
-    output_query_results(spec_tuples)
-  end
-
-  def specs_type
-    if options[:all]
-      if options[:prerelease]
-        :complete
-      else
-        :released
-      end
-    elsif options[:prerelease]
-      :prerelease
-    else
-      :latest
-    end
-  end
-
-  ##
-  # Check if gem +name+ version +version+ is installed.
-
-  def installed?(name, req = Gem::Requirement.default)
-    Gem::Specification.any? { |s| s.name =~ name and req =~ s.version }
-  end
-
-  def output_query_results(spec_tuples)
-    output = []
-    versions = Hash.new { |h,name| h[name] = [] }
-
-    spec_tuples.each do |spec_tuple, source|
-      versions[spec_tuple.name] << [spec_tuple, source]
-    end
-
-    versions = versions.sort_by do |(n,_),_|
-      n.downcase
-    end
-
-    output_versions output, versions
-
-    say output.join(options[:details] ? "\n\n" : "\n")
-  end
-
-  def output_versions(output, versions)
-    versions.each do |gem_name, matching_tuples|
-      matching_tuples = matching_tuples.sort_by { |n,_| n.version }.reverse
-
-      platforms = Hash.new { |h,version| h[version] = [] }
-
-      matching_tuples.each do |n, _|
-        platforms[n.version] << n.platform if n.platform
-      end
-
-      seen = {}
-
-      matching_tuples.delete_if do |n,_|
-        if seen[n.version]
-          true
-        else
-          seen[n.version] = true
-          false
-        end
-      end
-
-      output << clean_text(make_entry(matching_tuples, platforms))
-    end
-  end
-
-  def entry_details(entry, detail_tuple, specs, platforms)
-    return unless options[:details]
-
-    name_tuple, spec = detail_tuple
-
-    spec = spec.fetch_spec(name_tuple)if spec.respond_to?(:fetch_spec)
-
-    entry << "\n"
-
-    spec_platforms   entry, platforms
-    spec_authors     entry, spec
-    spec_homepage    entry, spec
-    spec_license     entry, spec
-    spec_loaded_from entry, spec, specs
-    spec_summary     entry, spec
-  end
-
-  def entry_versions(entry, name_tuples, platforms, specs)
-    return unless options[:versions]
-
-    list =
-      if platforms.empty? or options[:details]
-        name_tuples.map { |n| n.version }.uniq
-      else
-        platforms.sort.reverse.map do |version, pls|
-          out = version.to_s
-
-          if options[:domain] == :local
-            default = specs.any? do |s|
-              !s.is_a?(Gem::Source) && s.version == version && s.default_gem?
-            end
-            out = "default: #{out}" if default
-          end
-
-          if pls != [Gem::Platform::RUBY]
-            platform_list = [pls.delete(Gem::Platform::RUBY), *pls.sort].compact
-            out = platform_list.unshift(out).join(' ')
-          end
-
-          out
-        end
-      end
-
-    entry << " (#{list.join ', '})"
-  end
-
-  def make_entry(entry_tuples, platforms)
-    detail_tuple = entry_tuples.first
-
-    name_tuples, specs = entry_tuples.flatten.partition do |item|
-      Gem::NameTuple === item
-    end
-
-    entry = [name_tuples.first.name]
-
-    entry_versions(entry, name_tuples, platforms, specs)
-    entry_details(entry, detail_tuple, specs, platforms)
-
-    entry.join
-  end
-
-  def spec_authors(entry, spec)
-    authors = "Author#{spec.authors.length > 1 ? 's' : ''}: ".dup
-    authors << spec.authors.join(', ')
-    entry << format_text(authors, 68, 4)
-  end
-
-  def spec_homepage(entry, spec)
-    return if spec.homepage.nil? or spec.homepage.empty?
-
-    entry << "\n" << format_text("Homepage: #{spec.homepage}", 68, 4)
-  end
-
-  def spec_license(entry, spec)
-    return if spec.license.nil? or spec.license.empty?
-
-    licenses = "License#{spec.licenses.length > 1 ? 's' : ''}: ".dup
-    licenses << spec.licenses.join(', ')
-    entry << "\n" << format_text(licenses, 68, 4)
-  end
-
-  def spec_loaded_from(entry, spec, specs)
-    return unless spec.loaded_from
-
-    if specs.length == 1
-      default = spec.default_gem? ? ' (default)' : nil
-      entry << "\n" << "    Installed at#{default}: #{spec.base_dir}"
-    else
-      label = 'Installed at'
-      specs.each do |s|
-        version = s.version.to_s
-        version << ', default' if s.default_gem?
-        entry << "\n" << "    #{label} (#{version}): #{s.base_dir}"
-        label = ' ' * label.length
-      end
-    end
-  end
-
-  def spec_platforms(entry, platforms)
-    non_ruby = platforms.any? do |_, pls|
-      pls.any? { |pl| pl != Gem::Platform::RUBY }
-    end
-
-    return unless non_ruby
-
-    if platforms.length == 1
-      title = platforms.values.length == 1 ? 'Platform' : 'Platforms'
-      entry << "    #{title}: #{platforms.values.sort.join(', ')}\n"
-    else
-      entry << "    Platforms:\n"
-
-      sorted_platforms = platforms.sort_by { |version,| version }
-
-      sorted_platforms.each do |version, pls|
-        label = "        #{version}: "
-        data = format_text pls.sort.join(', '), 68, label.length
-        data[0, label.length] = label
-        entry << data << "\n"
-      end
-    end
-  end
-
-  def spec_summary(entry, spec)
-    summary = truncate_text(spec.summary, "the summary for #{spec.full_name}")
-    entry << "\n\n" << format_text(summary, 68, 4)
-  end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/rdoc_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/rdoc_command.rb
@@ -1,36 +1,35 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/version_option'
-require 'rubygems/rdoc'
-require 'fileutils'
+require_relative "../command"
+require_relative "../version_option"
+require_relative "../rdoc"
+require "fileutils"
 
 class Gem::Commands::RdocCommand < Gem::Command
-
   include Gem::VersionOption
 
   def initialize
-    super 'rdoc', 'Generates RDoc for pre-installed gems',
+    super "rdoc", "Generates RDoc for pre-installed gems",
           :version => Gem::Requirement.default,
           :include_rdoc => false, :include_ri => true, :overwrite => false
 
-    add_option('--all',
-               'Generate RDoc/RI documentation for all',
-               'installed gems') do |value, options|
+    add_option("--all",
+               "Generate RDoc/RI documentation for all",
+               "installed gems") do |value, options|
       options[:all] = value
     end
 
-    add_option('--[no-]rdoc',
-               'Generate RDoc HTML') do |value, options|
+    add_option("--[no-]rdoc",
+               "Generate RDoc HTML") do |value, options|
       options[:include_rdoc] = value
     end
 
-    add_option('--[no-]ri',
-               'Generate RI data') do |value, options|
+    add_option("--[no-]ri",
+               "Generate RI data") do |value, options|
       options[:include_ri] = value
     end
 
-    add_option('--[no-]overwrite',
-               'Overwrite installed documents') do |value, options|
+    add_option("--[no-]overwrite",
+               "Overwrite installed documents") do |value, options|
       options[:overwrite] = value
     end
 
@@ -62,15 +61,15 @@ Use --overwrite to force rebuilding of d
 
   def execute
     specs = if options[:all]
-              Gem::Specification.to_a
-            else
-              get_all_gem_names.map do |name|
-                Gem::Specification.find_by_name name, options[:version]
-              end.flatten.uniq
-            end
+      Gem::Specification.to_a
+    else
+      get_all_gem_names.map do |name|
+        Gem::Specification.find_by_name name, options[:version]
+      end.flatten.uniq
+    end
 
     if specs.empty?
-      alert_error 'No matching gems found'
+      alert_error "No matching gems found"
       terminate_interaction 1
     end
 
@@ -80,8 +79,8 @@ Use --overwrite to force rebuilding of d
       doc.force = options[:overwrite]
 
       if options[:overwrite]
-        FileUtils.rm_rf File.join(spec.doc_dir, 'ri')
-        FileUtils.rm_rf File.join(spec.doc_dir, 'rdoc')
+        FileUtils.rm_rf File.join(spec.doc_dir, "ri")
+        FileUtils.rm_rf File.join(spec.doc_dir, "rdoc")
       end
 
       begin
@@ -93,5 +92,4 @@ Use --overwrite to force rebuilding of d
       end
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/search_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/search_command.rb
@@ -1,15 +1,16 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/commands/query_command'
+require_relative "../command"
+require_relative "../query_utils"
 
-class Gem::Commands::SearchCommand < Gem::Commands::QueryCommand
+class Gem::Commands::SearchCommand < Gem::Command
+  include Gem::QueryUtils
 
   def initialize
-    super 'search', 'Display remote gems whose name matches REGEXP'
+    super "search", "Display remote gems whose name matches REGEXP",
+         :domain => :remote, :details => false, :versions => true,
+         :installed => nil, :version => Gem::Requirement.default
 
-    remove_option '--name-matches'
-
-    defaults[:domain] = :remote
+    add_query_options
   end
 
   def arguments # :nodoc:
@@ -36,5 +37,4 @@ To list local gems use the list command.
   def usage # :nodoc:
     "#{program_name} [REGEXP]"
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/server_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/server_command.rb
@@ -1,86 +1,25 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/server'
+require_relative "../command"
 
-class Gem::Commands::ServerCommand < Gem::Command
-
-  def initialize
-    super 'server', 'Documentation and gem repository HTTP server',
-          :port => 8808, :gemdir => [], :daemon => false
-
-    OptionParser.accept :Port do |port|
-      if port =~ /\A\d+\z/
-        port = Integer port
-        raise OptionParser::InvalidArgument, "#{port}: not a port number" if
-          port > 65535
-
-        port
-      else
-        begin
-          Socket.getservbyname port
-        rescue SocketError
-          raise OptionParser::InvalidArgument, "#{port}: no such named service"
-        end
+unless defined? Gem::Commands::ServerCommand
+  class Gem::Commands::ServerCommand < Gem::Command
+    def initialize
+      super("server", "Starts up a web server that hosts the RDoc (requires rubygems-server)")
+      begin
+        Gem::Specification.find_by_name("rubygems-server").activate
+      rescue Gem::LoadError
+        # no-op
       end
     end
 
-    add_option '-p', '--port=PORT', :Port,
-               'port to listen on' do |port, options|
-      options[:port] = port
+    def description # :nodoc:
+      <<-EOF
+The server command has been moved to the rubygems-server gem.
+      EOF
     end
 
-    add_option '-d', '--dir=GEMDIR',
-               'directories from which to serve gems',
-               'multiple directories may be provided' do |gemdir, options|
-      options[:gemdir] << File.expand_path(gemdir)
+    def execute
+      alert_error "Install the rubygems-server gem for the server command"
     end
-
-    add_option '--[no-]daemon', 'run as a daemon' do |daemon, options|
-      options[:daemon] = daemon
-    end
-
-    add_option '-b', '--bind=HOST,HOST',
-               'addresses to bind', Array do |address, options|
-      options[:addresses] ||= []
-      options[:addresses].push(*address)
-    end
-
-    add_option '-l', '--launch[=COMMAND]',
-               'launches a browser window',
-               "COMMAND defaults to 'start' on Windows",
-               "and 'open' on all other platforms" do |launch, options|
-      launch ||= Gem.win_platform? ? 'start' : 'open'
-      options[:launch] = launch
-    end
-  end
-
-  def defaults_str # :nodoc:
-    "--port 8808 --dir #{Gem.dir} --no-daemon"
   end
-
-  def description # :nodoc:
-    <<-EOF
-The server command starts up a web server that hosts the RDoc for your
-installed gems and can operate as a server for installation of gems on other
-machines.
-
-The cache files for installed gems must exist to use the server as a source
-for gem installation.
-
-To install gems from a running server, use `gem install GEMNAME --source
-http://gem_server_host:8808`
-
-You can set up a shortcut to gem server documentation using the URL:
-
-  http://localhost:8808/rdoc?q=%s - Firefox
-  http://localhost:8808/rdoc?q=* - LaunchBar
-
-    EOF
-  end
-
-  def execute
-    options[:gemdir] = Gem.path if options[:gemdir].empty?
-    Gem::Server.run options
-  end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/setup_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/setup_command.rb
@@ -1,102 +1,105 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative "../command"
 
 ##
 # Installs RubyGems itself.  This command is ordinarily only available from a
 # RubyGems checkout or tarball.
 
 class Gem::Commands::SetupCommand < Gem::Command
-
-  HISTORY_HEADER = /^===\s*[\d.a-zA-Z]+\s*\/\s*\d{4}-\d{2}-\d{2}\s*$/.freeze
-  VERSION_MATCHER = /^===\s*([\d.a-zA-Z]+)\s*\/\s*\d{4}-\d{2}-\d{2}\s*$/.freeze
+  HISTORY_HEADER = /^#\s*[\d.a-zA-Z]+\s*\/\s*\d{4}-\d{2}-\d{2}\s*$/.freeze
+  VERSION_MATCHER = /^#\s*([\d.a-zA-Z]+)\s*\/\s*\d{4}-\d{2}-\d{2}\s*$/.freeze
 
   ENV_PATHS = %w[/usr/bin/env /bin/env].freeze
 
   def initialize
-    require 'tmpdir'
-
-    super 'setup', 'Install RubyGems',
-          :format_executable => true, :document => %w[ri],
+    super "setup", "Install RubyGems",
+          :format_executable => false, :document => %w[ri],
           :force => true,
-          :site_or_vendor => 'sitelibdir',
-          :destdir => '', :prefix => '', :previous_version => '',
-          :regenerate_binstubs => true
-
-    add_option '--previous-version=VERSION',
-               'Previous version of RubyGems',
-               'Used for changelog processing' do |version, options|
+          :site_or_vendor => "sitelibdir",
+          :destdir => "", :prefix => "", :previous_version => "",
+          :regenerate_binstubs => true,
+          :regenerate_plugins => true
+
+    add_option "--previous-version=VERSION",
+               "Previous version of RubyGems",
+               "Used for changelog processing" do |version, options|
       options[:previous_version] = version
     end
 
-    add_option '--prefix=PREFIX',
-               'Prefix path for installing RubyGems',
-               'Will not affect gem repository location' do |prefix, options|
+    add_option "--prefix=PREFIX",
+               "Prefix path for installing RubyGems",
+               "Will not affect gem repository location" do |prefix, options|
       options[:prefix] = File.expand_path prefix
     end
 
-    add_option '--destdir=DESTDIR',
-               'Root directory to install RubyGems into',
-               'Mainly used for packaging RubyGems' do |destdir, options|
+    add_option "--destdir=DESTDIR",
+               "Root directory to install RubyGems into",
+               "Mainly used for packaging RubyGems" do |destdir, options|
       options[:destdir] = File.expand_path destdir
     end
 
-    add_option '--[no-]vendor',
-               'Install into vendorlibdir not sitelibdir' do |vendor, options|
-      options[:site_or_vendor] = vendor ? 'vendorlibdir' : 'sitelibdir'
+    add_option "--[no-]vendor",
+               "Install into vendorlibdir not sitelibdir" do |vendor, options|
+      options[:site_or_vendor] = vendor ? "vendorlibdir" : "sitelibdir"
     end
 
-    add_option '--[no-]format-executable',
-               'Makes `gem` match ruby',
-               'If Ruby is ruby18, gem will be gem18' do |value, options|
+    add_option "--[no-]format-executable",
+               "Makes `gem` match ruby",
+               "If Ruby is ruby18, gem will be gem18" do |value, options|
       options[:format_executable] = value
     end
 
-    add_option '--[no-]document [TYPES]', Array,
-               'Generate documentation for RubyGems',
-               'List the documentation types you wish to',
-               'generate.  For example: rdoc,ri' do |value, options|
+    add_option "--[no-]document [TYPES]", Array,
+               "Generate documentation for RubyGems",
+               "List the documentation types you wish to",
+               "generate.  For example: rdoc,ri" do |value, options|
       options[:document] = case value
-                           when nil   then %w[rdoc ri]
-                           when false then []
-                           else            value
-                           end
+      when nil   then %w[rdoc ri]
+      when false then []
+      else            value
+      end
     end
 
-    add_option '--[no-]rdoc',
-               'Generate RDoc documentation for RubyGems' do |value, options|
+    add_option "--[no-]rdoc",
+               "Generate RDoc documentation for RubyGems" do |value, options|
       if value
-        options[:document] << 'rdoc'
+        options[:document] << "rdoc"
       else
-        options[:document].delete 'rdoc'
+        options[:document].delete "rdoc"
       end
 
       options[:document].uniq!
     end
 
-    add_option '--[no-]ri',
-               'Generate RI documentation for RubyGems' do |value, options|
+    add_option "--[no-]ri",
+               "Generate RI documentation for RubyGems" do |value, options|
       if value
-        options[:document] << 'ri'
+        options[:document] << "ri"
       else
-        options[:document].delete 'ri'
+        options[:document].delete "ri"
       end
 
       options[:document].uniq!
     end
 
-    add_option '--[no-]regenerate-binstubs',
-               'Regenerate gem binstubs' do |value, options|
+    add_option "--[no-]regenerate-binstubs",
+               "Regenerate gem binstubs" do |value, options|
       options[:regenerate_binstubs] = value
     end
 
-    add_option '-f', '--[no-]force',
-               'Forcefully overwrite binstubs' do |value, options|
+    add_option "--[no-]regenerate-plugins",
+               "Regenerate gem plugins" do |value, options|
+      options[:regenerate_plugins] = value
+    end
+
+    add_option "-f", "--[no-]force",
+               "Forcefully overwrite binstubs" do |value, options|
       options[:force] = value
     end
 
-    add_option('-E', '--[no-]env-shebang',
-               'Rewrite executables with a shebang',
-               'of /usr/bin/env') do |value, options|
+    add_option("-E", "--[no-]env-shebang",
+               "Rewrite executables with a shebang",
+               "of /usr/bin/env") do |value, options|
       options[:env_shebang] = value
     end
 
@@ -104,7 +107,7 @@ class Gem::Commands::SetupCommand < Gem:
   end
 
   def check_ruby_version
-    required_version = Gem::Requirement.new '>= 2.3.0'
+    required_version = Gem::Requirement.new ">= 2.3.0"
 
     unless required_version.satisfied_by? Gem.ruby_version
       alert_error "Expected Ruby version #{required_version}, is #{Gem.ruby_version}"
@@ -144,16 +147,9 @@ By default, this RubyGems will install g
   def execute
     @verbose = Gem.configuration.really_verbose
 
-    install_destdir = options[:destdir]
-
-    unless install_destdir.empty?
-      ENV['GEM_HOME'] ||= File.join(install_destdir,
-                                    Gem.default_dir.gsub(/^[a-zA-Z]:/, ''))
-    end
-
     check_ruby_version
 
-    require 'fileutils'
+    require "fileutils"
     if Gem.configuration.really_verbose
       extend FileUtils::Verbose
     else
@@ -161,7 +157,8 @@ By default, this RubyGems will install g
     end
     extend MakeDirs
 
-    lib_dir, bin_dir = make_destination_dirs install_destdir
+    lib_dir, bin_dir = make_destination_dirs
+    man_dir = generate_default_man_dir
 
     install_lib lib_dir
 
@@ -171,6 +168,9 @@ By default, this RubyGems will install g
 
     remove_old_lib_files lib_dir
 
+    # Can be removed one we drop support for bundler 2.2.3 (the last version installing man files to man_dir)
+    remove_old_man_files man_dir if man_dir && File.exist?(man_dir)
+
     install_default_bundler_gem bin_dir
 
     if mode = options[:dir_mode]
@@ -180,7 +180,8 @@ By default, this RubyGems will install g
 
     say "RubyGems #{Gem::VERSION} installed"
 
-    regenerate_binstubs if options[:regenerate_binstubs]
+    regenerate_binstubs(bin_dir) if options[:regenerate_binstubs]
+    regenerate_plugins(bin_dir) if options[:regenerate_plugins]
 
     uninstall_old_gemcutter
 
@@ -193,7 +194,7 @@ By default, this RubyGems will install g
     end
 
     if options[:previous_version].empty?
-      options[:previous_version] = Gem::VERSION.sub(/[0-9]+$/, '0')
+      options[:previous_version] = Gem::VERSION.sub(/[0-9]+$/, "0")
     end
 
     options[:previous_version] = Gem::Version.new(options[:previous_version])
@@ -205,7 +206,7 @@ By default, this RubyGems will install g
     say
 
     say "RubyGems installed the following executables:"
-    say bin_file_names.map { |name| "\t#{name}\n" }
+    say bin_file_names.map {|name| "\t#{name}\n" }
     say
 
     unless bin_file_names.grep(/#{File::SEPARATOR}gem$/)
@@ -215,7 +216,7 @@ By default, this RubyGems will install g
     end
 
     if documentation_success
-      if options[:document].include? 'rdoc'
+      if options[:document].include? "rdoc"
         say "Rdoc documentation was installed. You may now invoke:"
         say "  gem server"
         say "and then peruse beautifully formatted documentation for your gems"
@@ -226,7 +227,7 @@ By default, this RubyGems will install g
         say
       end
 
-      if options[:document].include? 'ri'
+      if options[:document].include? "ri"
         say "Ruby Interactive (ri) documentation was installed. ri is kind of like man "
         say "pages for Ruby libraries. You may access it like this:"
         say "  ri Classname"
@@ -243,40 +244,39 @@ By default, this RubyGems will install g
   def install_executables(bin_dir)
     prog_mode = options[:prog_mode] || 0755
 
-    executables = { 'gem' => 'bin' }
+    executables = { "gem" => "bin" }
     executables.each do |tool, path|
       say "Installing #{tool} executable" if @verbose
 
       Dir.chdir path do
-        bin_files = Dir['*']
+        bin_file = "gem"
+
+        require "tmpdir"
 
-        bin_files -= %w[update_rubygems]
+        dest_file = target_bin_path(bin_dir, bin_file)
+        bin_tmp_file = File.join Dir.tmpdir, "#{bin_file}.#{$$}"
 
-        bin_files.each do |bin_file|
-          dest_file = target_bin_path(bin_dir, bin_file)
-          bin_tmp_file = File.join Dir.tmpdir, "#{bin_file}.#{$$}"
-
-          begin
-            bin = File.readlines bin_file
-            bin[0] = shebang
-
-            File.open bin_tmp_file, 'w' do |fp|
-              fp.puts bin.join
-            end
-
-            install bin_tmp_file, dest_file, :mode => prog_mode
-            bin_file_names << dest_file
-          ensure
-            rm bin_tmp_file
+        begin
+          bin = File.readlines bin_file
+          bin[0] = shebang
+
+          File.open bin_tmp_file, "w" do |fp|
+            fp.puts bin.join
           end
 
-          next unless Gem.win_platform?
+          install bin_tmp_file, dest_file, :mode => prog_mode
+          bin_file_names << dest_file
+        ensure
+          rm bin_tmp_file
+        end
+
+        next unless Gem.win_platform?
 
-          begin
-            bin_cmd_file = File.join Dir.tmpdir, "#{bin_file}.bat"
+        begin
+          bin_cmd_file = File.join Dir.tmpdir, "#{bin_file}.bat"
 
-            File.open bin_cmd_file, 'w' do |file|
-              file.puts <<-TEXT
+          File.open bin_cmd_file, "w" do |file|
+            file.puts <<-TEXT
   @ECHO OFF
   IF NOT "%~f0" == "~f0" GOTO :WinNT
   @"#{File.basename(Gem.ruby).chomp('"')}" "#{dest_file}" %1 %2 %3 %4 %5 %6 %7 %8 %9
@@ -284,12 +284,11 @@ By default, this RubyGems will install g
   :WinNT
   @"#{File.basename(Gem.ruby).chomp('"')}" "%~dpn0" %*
   TEXT
-            end
-
-            install bin_cmd_file, "#{dest_file}.bat", :mode => prog_mode
-          ensure
-            rm bin_cmd_file
           end
+
+          install bin_cmd_file, "#{dest_file}.bat", :mode => prog_mode
+        ensure
+          rm bin_cmd_file
         end
       end
     end
@@ -297,7 +296,7 @@ By default, this RubyGems will install g
 
   def shebang
     if options[:env_shebang]
-      ruby_name = RbConfig::CONFIG['ruby_install_name']
+      ruby_name = RbConfig::CONFIG["ruby_install_name"]
       @env_path ||= ENV_PATHS.find {|env_path| File.executable? env_path }
       "#!#{@env_path} #{ruby_name}\n"
     else
@@ -305,41 +304,22 @@ By default, this RubyGems will install g
     end
   end
 
-  def install_file(file, dest_dir)
-    dest_file = File.join dest_dir, file
-    dest_dir = File.dirname dest_file
-    unless File.directory? dest_dir
-      mkdir_p dest_dir, :mode => 0755
-    end
-
-    install file, dest_file, :mode => options[:data_mode] || 0644
-  end
-
   def install_lib(lib_dir)
-    libs = { 'RubyGems' => 'lib' }
-    libs['Bundler'] = 'bundler/lib'
+    libs = { "RubyGems" => "lib" }
+    libs["Bundler"] = "bundler/lib"
     libs.each do |tool, path|
       say "Installing #{tool}" if @verbose
 
-      lib_files = rb_files_in path
-      lib_files.concat(template_files) if tool == 'Bundler'
-
-      pem_files = pem_files_in path
+      lib_files = files_in path
 
       Dir.chdir path do
-        lib_files.each do |lib_file|
-          install_file lib_file, lib_dir
-        end
-
-        pem_files.each do |pem_file|
-          install_file pem_file, lib_dir
-        end
+        install_file_list(lib_files, lib_dir)
       end
     end
   end
 
   def install_rdoc
-    gem_doc_dir = File.join Gem.dir, 'doc'
+    gem_doc_dir = File.join Gem.dir, "doc"
     rubygems_name = "rubygems-#{Gem::VERSION}"
     rubygems_doc_dir = File.join gem_doc_dir, rubygems_name
 
@@ -349,23 +329,23 @@ By default, this RubyGems will install g
       # ignore
     end
 
-    if File.writable? gem_doc_dir and
-       (not File.exist? rubygems_doc_dir or
-        File.writable? rubygems_doc_dir)
+    if File.writable?(gem_doc_dir) &&
+       (!File.exist?(rubygems_doc_dir) ||
+        File.writable?(rubygems_doc_dir))
       say "Removing old RubyGems RDoc and ri" if @verbose
-      Dir[File.join(Gem.dir, 'doc', 'rubygems-[0-9]*')].each do |dir|
+      Dir[File.join(Gem.dir, "doc", "rubygems-[0-9]*")].each do |dir|
         rm_rf dir
       end
 
-      require 'rubygems/rdoc'
+      require_relative "../rdoc"
 
-      fake_spec = Gem::Specification.new 'rubygems', Gem::VERSION
+      fake_spec = Gem::Specification.new "rubygems", Gem::VERSION
       def fake_spec.full_gem_path
-        File.expand_path '../../../..', __FILE__
+        File.expand_path "../../..", __dir__
       end
 
-      generate_ri   = options[:document].include? 'ri'
-      generate_rdoc = options[:document].include? 'rdoc'
+      generate_ri   = options[:document].include? "ri"
+      generate_rdoc = options[:document].include? "rdoc"
 
       rdoc = Gem::RDoc.new fake_spec, generate_rdoc, generate_ri
       rdoc.generate
@@ -380,30 +360,26 @@ By default, this RubyGems will install g
   end
 
   def install_default_bundler_gem(bin_dir)
-    specs_dir = Gem.default_specifications_dir
-    specs_dir = File.join(options[:destdir], specs_dir) unless Gem.win_platform?
-    mkdir_p specs_dir, :mode => 0755
-
-    # Workaround for non-git environment.
-    gemspec = File.open('bundler/bundler.gemspec', 'rb'){|f| f.read.gsub(/`git ls-files -z`/, "''") }
-    File.open('bundler/bundler.gemspec', 'w'){|f| f.write gemspec }
-
-    bundler_spec = Gem::Specification.load("bundler/bundler.gemspec")
-    bundler_spec.files = Dir.chdir("bundler") { Dir["{*.md,{lib,exe,man}/**/*}"] }
-    bundler_spec.executables -= %w[bundler bundle_ruby]
-
-    # Remove bundler-*.gemspec in default specification directory.
-    Dir.entries(specs_dir).
-      select {|gs| gs.start_with?("bundler-") }.
-      each {|gs| File.delete(File.join(specs_dir, gs)) }
+    current_default_spec = Gem::Specification.default_stubs.find {|s| s.name == "bundler" }
+    specs_dir = if current_default_spec && default_dir == Gem.default_dir
+      Gem::Specification.remove_spec current_default_spec
+      loaded_from = current_default_spec.loaded_from
+      File.delete(loaded_from)
+      File.dirname(loaded_from)
+    else
+      target_specs_dir = File.join(default_dir, "specifications", "default")
+      mkdir_p target_specs_dir, :mode => 0755
+      target_specs_dir
+    end
 
+    bundler_spec = Dir.chdir("bundler") { Gem::Specification.load("bundler.gemspec") }
     default_spec_path = File.join(specs_dir, "#{bundler_spec.full_name}.gemspec")
     Gem.write_binary(default_spec_path, bundler_spec.to_ruby)
 
     bundler_spec = Gem::Specification.load(default_spec_path)
 
     # Remove gemspec that was same version of vendored bundler.
-    normal_gemspec = File.join(Gem.default_dir, "specifications", "bundler-#{bundler_spec.version}.gemspec")
+    normal_gemspec = File.join(default_dir, "specifications", "bundler-#{bundler_spec.version}.gemspec")
     if File.file? normal_gemspec
       File.delete normal_gemspec
     end
@@ -416,19 +392,26 @@ By default, this RubyGems will install g
     end
 
     bundler_bin_dir = bundler_spec.bin_dir
-    bundler_bin_dir = File.join(options[:destdir], bundler_bin_dir) unless Gem.win_platform?
     mkdir_p bundler_bin_dir, :mode => 0755
     bundler_spec.executables.each do |e|
       cp File.join("bundler", bundler_spec.bindir, e), File.join(bundler_bin_dir, e)
     end
 
-    require 'rubygems/installer'
+    require_relative "../installer"
 
     Dir.chdir("bundler") do
       built_gem = Gem::Package.build(bundler_spec)
       begin
-        installer = Gem::Installer.at(built_gem, env_shebang: options[:env_shebang], format_executable: options[:format_executable], force: options[:force], install_as_default: true, bin_dir: bin_dir, wrappers: true)
-        installer.install
+        Gem::Installer.at(
+          built_gem,
+          env_shebang: options[:env_shebang],
+          format_executable: options[:format_executable],
+          force: options[:force],
+          install_as_default: true,
+          bin_dir: bin_dir,
+          install_dir: default_dir,
+          wrappers: true
+        ).install
       ensure
         FileUtils.rm_f built_gem
       end
@@ -439,11 +422,11 @@ By default, this RubyGems will install g
     say "Bundler #{bundler_spec.version} installed"
   end
 
-  def make_destination_dirs(install_destdir)
+  def make_destination_dirs
     lib_dir, bin_dir = Gem.default_rubygems_dirs
 
     unless lib_dir
-      lib_dir, bin_dir = generate_default_dirs(install_destdir)
+      lib_dir, bin_dir = generate_default_dirs
     end
 
     mkdir_p lib_dir, :mode => 0755
@@ -452,74 +435,49 @@ By default, this RubyGems will install g
     return lib_dir, bin_dir
   end
 
-  def generate_default_dirs(install_destdir)
+  def generate_default_man_dir
     prefix = options[:prefix]
-    site_or_vendor = options[:site_or_vendor]
 
     if prefix.empty?
-      lib_dir = RbConfig::CONFIG[site_or_vendor]
-      bin_dir = RbConfig::CONFIG['bindir']
+      man_dir = RbConfig::CONFIG["mandir"]
+      return unless man_dir
     else
-      # Apple installed RubyGems into libdir, and RubyGems <= 1.1.0 gets
-      # confused about installation location, so switch back to
-      # sitelibdir/vendorlibdir.
-      if defined?(APPLE_GEM_HOME) and
-        # just in case Apple and RubyGems don't get this patched up proper.
-        (prefix == RbConfig::CONFIG['libdir'] or
-         # this one is important
-         prefix == File.join(RbConfig::CONFIG['libdir'], 'ruby'))
-        lib_dir = RbConfig::CONFIG[site_or_vendor]
-        bin_dir = RbConfig::CONFIG['bindir']
-      else
-        lib_dir = File.join prefix, 'lib'
-        bin_dir = File.join prefix, 'bin'
-      end
-    end
-
-    unless install_destdir.empty?
-      lib_dir = File.join install_destdir, lib_dir.gsub(/^[a-zA-Z]:/, '')
-      bin_dir = File.join install_destdir, bin_dir.gsub(/^[a-zA-Z]:/, '')
+      man_dir = File.join prefix, "man"
     end
 
-    [lib_dir, bin_dir]
+    prepend_destdir_if_present(man_dir)
   end
 
-  def pem_files_in(dir)
-    Dir.chdir dir do
-      Dir[File.join('**', '*pem')]
-    end
-  end
+  def generate_default_dirs
+    prefix = options[:prefix]
+    site_or_vendor = options[:site_or_vendor]
 
-  def rb_files_in(dir)
-    Dir.chdir dir do
-      Dir[File.join('**', '*rb')]
+    if prefix.empty?
+      lib_dir = RbConfig::CONFIG[site_or_vendor]
+      bin_dir = RbConfig::CONFIG["bindir"]
+    else
+      lib_dir = File.join prefix, "lib"
+      bin_dir = File.join prefix, "bin"
     end
-  end
 
-  # for installation of bundler as default gems
-  def template_files
-    Dir.chdir "bundler/lib" do
-      (Dir[File.join('bundler', 'templates', '**', '{*,.*}')]).
-        select{|f| !File.directory?(f)}
-    end
+    [prepend_destdir_if_present(lib_dir), prepend_destdir_if_present(bin_dir)]
   end
 
-  # for cleanup old bundler files
-  def template_files_in(dir)
+  def files_in(dir)
     Dir.chdir dir do
-      (Dir[File.join('templates', '**', '{*,.*}')]).
-        select{|f| !File.directory?(f)}
+      Dir.glob(File.join("**", "*"), File::FNM_DOTMATCH).
+        select {|f| !File.directory?(f) }
     end
   end
 
   def remove_old_bin_files(bin_dir)
     old_bin_files = {
-      'gem_mirror' => 'gem mirror',
-      'gem_server' => 'gem server',
-      'gemlock' => 'gem lock',
-      'gemri' => 'ri',
-      'gemwhich' => 'gem which',
-      'index_gem_repository.rb' => 'gem generate_index',
+      "gem_mirror" => "gem mirror",
+      "gem_server" => "gem server",
+      "gemlock" => "gem lock",
+      "gemri" => "ri",
+      "gemwhich" => "gem which",
+      "index_gem_repository.rb" => "gem generate_index",
     }
 
     old_bin_files.each do |old_bin_file, new_name|
@@ -528,7 +486,7 @@ By default, this RubyGems will install g
 
       deprecation_message = "`#{old_bin_file}` has been deprecated. Use `#{new_name}` instead."
 
-      File.open old_bin_path, 'w' do |fp|
+      File.open old_bin_path, "w" do |fp|
         fp.write <<-EOF
 #!#{Gem.ruby}
 
@@ -538,41 +496,53 @@ abort "#{deprecation_message}"
 
       next unless Gem.win_platform?
 
-      File.open "#{old_bin_path}.bat", 'w' do |fp|
-        fp.puts %{@ECHO.#{deprecation_message}}
+      File.open "#{old_bin_path}.bat", "w" do |fp|
+        fp.puts %(@ECHO.#{deprecation_message})
       end
     end
   end
 
   def remove_old_lib_files(lib_dir)
-    lib_dirs = { File.join(lib_dir, 'rubygems') => 'lib/rubygems' }
-    lib_dirs[File.join(lib_dir, 'bundler')] = 'bundler/lib/bundler'
+    lib_dirs = { File.join(lib_dir, "rubygems") => "lib/rubygems" }
+    lib_dirs[File.join(lib_dir, "bundler")] = "bundler/lib/bundler"
     lib_dirs.each do |old_lib_dir, new_lib_dir|
-      lib_files = rb_files_in(new_lib_dir)
-      lib_files.concat(template_files_in(new_lib_dir)) if new_lib_dir =~ /bundler/
+      lib_files = files_in(new_lib_dir)
 
-      old_lib_files = rb_files_in(old_lib_dir)
-      old_lib_files.concat(template_files_in(old_lib_dir)) if old_lib_dir =~ /bundler/
+      old_lib_files = files_in(old_lib_dir)
 
       to_remove = old_lib_files - lib_files
 
+      gauntlet_rubygems = File.join(lib_dir, "gauntlet_rubygems.rb")
+      to_remove << gauntlet_rubygems if File.exist? gauntlet_rubygems
+
       to_remove.delete_if do |file|
-        file.start_with? 'defaults'
+        file.start_with? "defaults"
       end
 
-      Dir.chdir old_lib_dir do
-        to_remove.each do |file|
-          FileUtils.rm_f file
+      remove_file_list(to_remove, old_lib_dir)
+    end
+  end
 
-          warn "unable to remove old file #{file} please remove it by hand" if
-            File.exist? file
-        end
-      end
+  def remove_old_man_files(old_man_dir)
+    old_man1_dir = "#{old_man_dir}/man1"
+
+    if File.exist?(old_man1_dir)
+      man1_to_remove = Dir.chdir(old_man1_dir) { Dir["bundle*.1{,.txt,.ronn}"] }
+
+      remove_file_list(man1_to_remove, old_man1_dir)
+    end
+
+    old_man5_dir = "#{old_man_dir}/man5"
+
+    if File.exist?(old_man5_dir)
+      man5_to_remove = Dir.chdir(old_man5_dir) { Dir["gemfile.5{,.txt,.ronn}"] }
+
+      remove_file_list(man5_to_remove, old_man5_dir)
     end
   end
 
   def show_release_notes
-    release_notes = File.join Dir.pwd, 'History.txt'
+    release_notes = File.join Dir.pwd, "CHANGELOG.md"
 
     release_notes =
       if File.exist? release_notes
@@ -580,8 +550,6 @@ abort "#{deprecation_message}"
 
         history.force_encoding Encoding::UTF_8
 
-        history = history.sub(/^# coding:.*?(?=^=)/m, '')
-
         text = history.split(HISTORY_HEADER)
         text.shift # correct an off-by-one generated by split
         version_lines = history.scan(HISTORY_HEADER)
@@ -591,7 +559,7 @@ abort "#{deprecation_message}"
 
         history_string = ""
 
-        until versions.length == 0 or
+        until versions.length == 0 ||
               versions.shift <= options[:previous_version] do
           history_string += version_lines.shift + text.shift
         end
@@ -605,19 +573,20 @@ abort "#{deprecation_message}"
   end
 
   def uninstall_old_gemcutter
-    require 'rubygems/uninstaller'
+    require_relative "../uninstaller"
 
-    ui = Gem::Uninstaller.new('gemcutter', :all => true, :ignore => true,
-                              :version => '< 0.4')
+    ui = Gem::Uninstaller.new("gemcutter", :all => true, :ignore => true,
+                              :version => "< 0.4")
     ui.uninstall
   rescue Gem::InstallError
   end
 
-  def regenerate_binstubs
-    require "rubygems/commands/pristine_command"
+  def regenerate_binstubs(bindir)
+    require_relative "pristine_command"
     say "Regenerating binstubs"
 
     args = %w[--all --only-executables --silent]
+    args << "--bindir=#{bindir}"
     if options[:env_shebang]
       args << "--env-shebang"
     end
@@ -626,19 +595,76 @@ abort "#{deprecation_message}"
     command.invoke(*args)
   end
 
+  def regenerate_plugins(bindir)
+    require_relative "pristine_command"
+    say "Regenerating plugins"
+
+    args = %w[--all --only-plugins --silent]
+    args << "--bindir=#{bindir}"
+    args << "--install-dir=#{default_dir}"
+
+    command = Gem::Commands::PristineCommand.new
+    command.invoke(*args)
+  end
+
   private
 
+  def default_dir
+    prefix = options[:prefix]
+
+    if prefix.empty?
+      dir = Gem.default_dir
+    else
+      dir = prefix
+    end
+
+    prepend_destdir_if_present(dir)
+  end
+
+  def prepend_destdir_if_present(path)
+    destdir = options[:destdir]
+    return path if destdir.empty?
+
+    File.join(options[:destdir], path.gsub(/^[a-zA-Z]:/, ""))
+  end
+
+  def install_file_list(files, dest_dir)
+    files.each do |file|
+      install_file file, dest_dir
+    end
+  end
+
+  def install_file(file, dest_dir)
+    dest_file = File.join dest_dir, file
+    dest_dir = File.dirname dest_file
+    unless File.directory? dest_dir
+      mkdir_p dest_dir, :mode => 0755
+    end
+
+    install file, dest_file, :mode => options[:data_mode] || 0644
+  end
+
+  def remove_file_list(files, dir)
+    Dir.chdir dir do
+      files.each do |file|
+        FileUtils.rm_f file
+
+        warn "unable to remove old file #{file} please remove it by hand" if
+          File.exist? file
+      end
+    end
+  end
+
   def target_bin_path(bin_dir, bin_file)
     bin_file_formatted = if options[:format_executable]
-                           Gem.default_exec_format % bin_file
-                         else
-                           bin_file
-                         end
+      Gem.default_exec_format % bin_file
+    else
+      bin_file
+    end
     File.join bin_dir, bin_file_formatted
   end
 
   def bin_file_names
     @bin_file_names ||= []
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/signin_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/signin_command.rb
@@ -1,16 +1,15 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/gemcutter_utilities'
+require_relative "../command"
+require_relative "../gemcutter_utilities"
 
 class Gem::Commands::SigninCommand < Gem::Command
-
   include Gem::GemcutterUtilities
 
   def initialize
-    super 'signin', 'Sign in to any gemcutter-compatible host. '\
-          'It defaults to https://rubygems.org'
+    super "signin", "Sign in to any gemcutter-compatible host. "\
+          "It defaults to https://rubygems.org"
 
-    add_option('--host HOST', 'Push to another gemcutter-compatible host') do |value, options|
+    add_option("--host HOST", "Push to another gemcutter-compatible host") do |value, options|
       options[:host] = value
     end
 
@@ -18,10 +17,10 @@ class Gem::Commands::SigninCommand < Gem
   end
 
   def description # :nodoc:
-    'The signin command executes host sign in for a push server (the default is'\
-    ' https://rubygems.org). The host can be provided with the host flag or can'\
-    ' be inferred from the provided gem. Host resolution matches the resolution'\
-    ' strategy for the push command.'
+    "The signin command executes host sign in for a push server (the default is"\
+    " https://rubygems.org). The host can be provided with the host flag or can"\
+    " be inferred from the provided gem. Host resolution matches the resolution"\
+    " strategy for the push command."
   end
 
   def usage # :nodoc:
@@ -31,5 +30,4 @@ class Gem::Commands::SigninCommand < Gem
   def execute
     sign_in options[:host]
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/signout_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/signout_command.rb
@@ -1,15 +1,14 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative "../command"
 
 class Gem::Commands::SignoutCommand < Gem::Command
-
   def initialize
-    super 'signout', 'Sign out from all the current sessions.'
+    super "signout", "Sign out from all the current sessions."
   end
 
   def description # :nodoc:
-    'The `signout` command is used to sign out from all current sessions,'\
-    ' allowing you to sign in using a different set of credentials.'
+    "The `signout` command is used to sign out from all current sessions,"\
+    " allowing you to sign in using a different set of credentials."
   end
 
   def usage # :nodoc:
@@ -20,14 +19,13 @@ class Gem::Commands::SignoutCommand < Ge
     credentials_path = Gem.configuration.credentials_path
 
     if !File.exist?(credentials_path)
-      alert_error 'You are not currently signed in.'
+      alert_error "You are not currently signed in."
     elsif !File.writable?(credentials_path)
       alert_error "File '#{Gem.configuration.credentials_path}' is read-only."\
-                  ' Please make sure it is writable.'
+                  " Please make sure it is writable."
     else
       Gem.configuration.unset_api_key!
-      say 'You have successfully signed out from all sessions.'
+      say "You have successfully signed out from all sessions."
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/sources_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/sources_command.rb
@@ -1,40 +1,43 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/remote_fetcher'
-require 'rubygems/spec_fetcher'
-require 'rubygems/local_remote_options'
+require_relative "../command"
+require_relative "../remote_fetcher"
+require_relative "../spec_fetcher"
+require_relative "../local_remote_options"
 
 class Gem::Commands::SourcesCommand < Gem::Command
-
   include Gem::LocalRemoteOptions
 
   def initialize
-    require 'fileutils'
+    require "fileutils"
 
-    super 'sources',
-          'Manage the sources and cache file RubyGems uses to search for gems'
+    super "sources",
+          "Manage the sources and cache file RubyGems uses to search for gems"
 
-    add_option '-a', '--add SOURCE_URI', 'Add source' do |value, options|
+    add_option "-a", "--add SOURCE_URI", "Add source" do |value, options|
       options[:add] = value
     end
 
-    add_option '-l', '--list', 'List sources' do |value, options|
+    add_option "-l", "--list", "List sources" do |value, options|
       options[:list] = value
     end
 
-    add_option '-r', '--remove SOURCE_URI', 'Remove source' do |value, options|
+    add_option "-r", "--remove SOURCE_URI", "Remove source" do |value, options|
       options[:remove] = value
     end
 
-    add_option '-c', '--clear-all',
-               'Remove all sources (clear the cache)' do |value, options|
+    add_option "-c", "--clear-all",
+               "Remove all sources (clear the cache)" do |value, options|
       options[:clear_all] = value
     end
 
-    add_option '-u', '--update', 'Update source cache' do |value, options|
+    add_option "-u", "--update", "Update source cache" do |value, options|
       options[:update] = value
     end
 
+    add_option "-f", "--[no-]force", "Do not show any confirmation prompts and behave as if 'yes' was always answered" do |value, options|
+      options[:force] = value
+    end
+
     add_proxy_option
   end
 
@@ -59,7 +62,7 @@ class Gem::Commands::SourcesCommand < Ge
       say "#{source_uri} is not a URI"
       terminate_interaction 1
     rescue Gem::RemoteFetcher::FetchError => e
-      say "Error fetching #{source_uri}:\n\t#{e.message}"
+      say "Error fetching #{Gem::Uri.redact(source.uri)}:\n\t#{e.message}"
       terminate_interaction 1
     end
   end
@@ -72,22 +75,22 @@ class Gem::Commands::SourcesCommand < Ge
 Do you want to add this source?
       QUESTION
 
-      terminate_interaction 1 unless ask_yes_no question
+      terminate_interaction 1 unless options[:force] || ask_yes_no(question)
     end
   end
 
   def check_rubygems_https(source_uri) # :nodoc:
     uri = URI source_uri
 
-    if uri.scheme and uri.scheme.downcase == 'http' and
-       uri.host.downcase == 'rubygems.org'
+    if uri.scheme && uri.scheme.downcase == "http" &&
+       uri.host.downcase == "rubygems.org"
       question = <<-QUESTION.chomp
 https://rubygems.org is recommended for security over #{uri}
 
 Do you want to add this insecure source?
       QUESTION
 
-      terminate_interaction 1 unless ask_yes_no question
+      terminate_interaction 1 unless options[:force] || ask_yes_no(question)
     end
   end
 
@@ -109,7 +112,7 @@ Do you want to add this insecure source?
   end
 
   def defaults_str # :nodoc:
-    '--list'
+    "--list"
   end
 
   def description # :nodoc:
@@ -135,8 +138,8 @@ do not recognize you should remove them.
 RubyGems has been configured to serve gems via the following URLs through
 its history:
 
-* http://gems.rubyforge.org (RubyGems 1.3.6 and earlier)
-* https://rubygems.org/       (RubyGems 1.3.7 through 1.8.25)
+* http://gems.rubyforge.org (RubyGems 1.3.5 and earlier)
+* http://rubygems.org       (RubyGems 1.3.6 through 1.8.30, and 2.0.0)
 * https://rubygems.org      (RubyGems 2.0.1 and newer)
 
 Since all of these sources point to the same set of gems you only need one
@@ -212,13 +215,12 @@ To remove a source use the --remove argu
   def remove_cache_file(desc, path) # :nodoc:
     FileUtils.rm_rf path
 
-    if not File.exist?(path)
+    if !File.exist?(path)
       say "*** Removed #{desc} source cache ***"
-    elsif not File.writable?(path)
+    elsif !File.writable?(path)
       say "*** Unable to remove #{desc} source cache (write protected) ***"
     else
       say "*** Unable to remove #{desc} source cache ***"
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/specification_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/specification_command.rb
@@ -1,39 +1,38 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/version_option'
-require 'rubygems/package'
+require_relative "../command"
+require_relative "../local_remote_options"
+require_relative "../version_option"
+require_relative "../package"
 
 class Gem::Commands::SpecificationCommand < Gem::Command
-
   include Gem::LocalRemoteOptions
   include Gem::VersionOption
 
   def initialize
     Gem.load_yaml
 
-    super 'specification', 'Display gem specification (in yaml)',
+    super "specification", "Display gem specification (in yaml)",
           :domain => :local, :version => Gem::Requirement.default,
           :format => :yaml
 
-    add_version_option('examine')
+    add_version_option("examine")
     add_platform_option
     add_prerelease_option
 
-    add_option('--all', 'Output specifications for all versions of',
-               'the gem') do |value, options|
+    add_option("--all", "Output specifications for all versions of",
+               "the gem") do |value, options|
       options[:all] = true
     end
 
-    add_option('--ruby', 'Output ruby format') do |value, options|
+    add_option("--ruby", "Output ruby format") do |value, options|
       options[:format] = :ruby
     end
 
-    add_option('--yaml', 'Output YAML format') do |value, options|
+    add_option("--yaml", "Output YAML format") do |value, options|
       options[:format] = :yaml
     end
 
-    add_option('--marshal', 'Output Marshal format') do |value, options|
+    add_option("--marshal", "Output Marshal format") do |value, options|
       options[:format] = :marshal
     end
 
@@ -89,7 +88,7 @@ Specific fields in the specification can
       raise Gem::CommandLineError, "Unsupported version type: '#{v}'"
     end
 
-    if !req.none? and options[:all]
+    if !req.none? && options[:all]
       alert_error "Specify --all or -v, not both"
       terminate_interaction 1
     end
@@ -103,7 +102,7 @@ Specific fields in the specification can
     field = get_one_optional_argument
 
     raise Gem::CommandLineError, "--ruby and FIELD are mutually exclusive" if
-      field and options[:format] == :ruby
+      field && options[:format] == :ruby
 
     if local?
       if File.exist? gem
@@ -119,7 +118,7 @@ Specific fields in the specification can
       dep.prerelease = options[:prerelease]
       found, _ = Gem::SpecFetcher.fetcher.spec_for_dependency dep
 
-      specs.push(*found.map { |spec,| spec })
+      specs.push(*found.map {|spec,| spec })
     end
 
     if specs.empty?
@@ -127,21 +126,26 @@ Specific fields in the specification can
       terminate_interaction 1
     end
 
+    platform = get_platform_from_requirements(options)
+
+    if platform
+      specs = specs.select {|s| s.platform.to_s == platform }
+    end
+
     unless options[:all]
-      specs = [specs.max_by { |s| s.version }]
+      specs = [specs.max_by {|s| s.version }]
     end
 
     specs.each do |s|
       s = s.send field if field
 
       say case options[:format]
-          when :ruby then s.to_ruby
-          when :marshal then Marshal.dump s
-          else s.to_yaml
-          end
+      when :ruby then s.to_ruby
+      when :marshal then Marshal.dump s
+      else s.to_yaml
+      end
 
       say "\n"
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/stale_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/stale_command.rb
@@ -1,10 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative "../command"
 
 class Gem::Commands::StaleCommand < Gem::Command
-
   def initialize
-    super('stale', 'List gems along with access times')
+    super("stale", "List gems along with access times")
   end
 
   def description # :nodoc:
@@ -33,9 +32,8 @@ longer using.
       end
     end
 
-    gem_to_atime.sort_by { |_, atime| atime }.each do |name, atime|
+    gem_to_atime.sort_by {|_, atime| atime }.each do |name, atime|
       say "#{name} at #{atime.strftime '%c'}"
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/uninstall_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/uninstall_command.rb
@@ -1,8 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/version_option'
-require 'rubygems/uninstaller'
-require 'fileutils'
+require_relative "../command"
+require_relative "../version_option"
+require_relative "../uninstaller"
+require "fileutils"
 
 ##
 # Gem uninstaller command line tool
@@ -10,82 +10,81 @@ require 'fileutils'
 # See `gem help uninstall`
 
 class Gem::Commands::UninstallCommand < Gem::Command
-
   include Gem::VersionOption
 
   def initialize
-    super 'uninstall', 'Uninstall gems from the local repository',
+    super "uninstall", "Uninstall gems from the local repository",
           :version => Gem::Requirement.default, :user_install => true,
           :check_dev => false, :vendor => false
 
-    add_option('-a', '--[no-]all',
-      'Uninstall all matching versions'
+    add_option("-a", "--[no-]all",
+      "Uninstall all matching versions"
     ) do |value, options|
       options[:all] = value
     end
 
-    add_option('-I', '--[no-]ignore-dependencies',
-               'Ignore dependency requirements while',
-               'uninstalling') do |value, options|
+    add_option("-I", "--[no-]ignore-dependencies",
+               "Ignore dependency requirements while",
+               "uninstalling") do |value, options|
       options[:ignore] = value
     end
 
-    add_option('-D', '--[no-]check-development',
-               'Check development dependencies while uninstalling',
-               '(default: false)') do |value, options|
+    add_option("-D", "--[no-]check-development",
+               "Check development dependencies while uninstalling",
+               "(default: false)") do |value, options|
       options[:check_dev] = value
     end
 
-    add_option('-x', '--[no-]executables',
-                 'Uninstall applicable executables without',
-                 'confirmation') do |value, options|
+    add_option("-x", "--[no-]executables",
+                 "Uninstall applicable executables without",
+                 "confirmation") do |value, options|
       options[:executables] = value
     end
 
-    add_option('-i', '--install-dir DIR',
-               'Directory to uninstall gem from') do |value, options|
+    add_option("-i", "--install-dir DIR",
+               "Directory to uninstall gem from") do |value, options|
       options[:install_dir] = File.expand_path(value)
     end
 
-    add_option('-n', '--bindir DIR',
-               'Directory to remove executables from') do |value, options|
+    add_option("-n", "--bindir DIR",
+               "Directory to remove executables from") do |value, options|
       options[:bin_dir] = File.expand_path(value)
     end
 
-    add_option('--[no-]user-install',
-               'Uninstall from user\'s home directory',
-               'in addition to GEM_HOME.') do |value, options|
+    add_option("--[no-]user-install",
+               "Uninstall from user's home directory",
+               "in addition to GEM_HOME.") do |value, options|
       options[:user_install] = value
     end
 
-    add_option('--[no-]format-executable',
-               'Assume executable names match Ruby\'s prefix and suffix.') do |value, options|
+    add_option("--[no-]format-executable",
+               "Assume executable names match Ruby's prefix and suffix.") do |value, options|
       options[:format_executable] = value
     end
 
-    add_option('--[no-]force',
-               'Uninstall all versions of the named gems',
-               'ignoring dependencies') do |value, options|
+    add_option("--[no-]force",
+               "Uninstall all versions of the named gems",
+               "ignoring dependencies") do |value, options|
       options[:force] = value
     end
 
-    add_option('--[no-]abort-on-dependent',
-               'Prevent uninstalling gems that are',
-               'depended on by other gems.') do |value, options|
+    add_option("--[no-]abort-on-dependent",
+               "Prevent uninstalling gems that are",
+               "depended on by other gems.") do |value, options|
       options[:abort_on_dependent] = value
     end
 
     add_version_option
     add_platform_option
 
-    add_option('--vendor',
-               'Uninstall gem from the vendor directory.',
-               'Only for use by gem repackagers.') do |value, options|
+    add_option("--vendor",
+               "Uninstall gem from the vendor directory.",
+               "Only for use by gem repackagers.") do |value, options|
       unless Gem.vendor_dir
-        raise OptionParser::InvalidOption.new 'your platform is not supported'
+        raise Gem::OptionParser::InvalidOption.new "your platform is not supported"
       end
 
-      alert_warning 'Use your OS package manager to uninstall vendor gems'
+      alert_warning "Use your OS package manager to uninstall vendor gems"
       options[:vendor] = true
       options[:install_dir] = Gem.vendor_dir
     end
@@ -97,7 +96,7 @@ class Gem::Commands::UninstallCommand < 
 
   def defaults_str # :nodoc:
     "--version '#{Gem::Requirement.default}' --no-force " +
-    "--user-install"
+      "--user-install"
   end
 
   def description # :nodoc:
@@ -115,8 +114,8 @@ that is a dependency of an existing gem.
   end
 
   def check_version # :nodoc:
-    if options[:version] != Gem::Requirement.default and
-         get_all_gem_names.size > 1
+    if options[:version] != Gem::Requirement.default &&
+       get_all_gem_names.size > 1
       alert_error "Can't use --version with multiple gems. You can specify multiple gems with" \
                   " version requirements using `gem uninstall 'my_gem:1.0.0' 'my_other_gem:~>2.0.0'`"
       terminate_interaction 1
@@ -126,7 +125,7 @@ that is a dependency of an existing gem.
   def execute
     check_version
 
-    if options[:all] and not options[:args].empty?
+    if options[:all] && !options[:args].empty?
       uninstall_specific
     elsif options[:all]
       uninstall_all
@@ -136,7 +135,7 @@ that is a dependency of an existing gem.
   end
 
   def uninstall_all
-    specs = Gem::Specification.reject { |spec| spec.default_gem? }
+    specs = Gem::Specification.reject {|spec| spec.default_gem? }
 
     specs.each do |spec|
       options[:version] = spec.version
@@ -195,5 +194,4 @@ that is a dependency of an existing gem.
   def uninstall(gem_name)
     Gem::Uninstaller.new(gem_name, options).uninstall
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/unpack_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/unpack_command.rb
@@ -1,9 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/version_option'
-require 'rubygems/security_option'
-require 'rubygems/remote_fetcher'
-require 'rubygems/package'
+require_relative "../command"
+require_relative "../version_option"
+require_relative "../security_option"
+require_relative "../remote_fetcher"
+require_relative "../package"
 
 # forward-declare
 
@@ -13,23 +13,22 @@ module Gem::Security # :nodoc:
 end
 
 class Gem::Commands::UnpackCommand < Gem::Command
-
   include Gem::VersionOption
   include Gem::SecurityOption
 
   def initialize
-    require 'fileutils'
+    require "fileutils"
 
-    super 'unpack', 'Unpack an installed gem to the current directory',
+    super "unpack", "Unpack an installed gem to the current directory",
           :version => Gem::Requirement.default,
           :target  => Dir.pwd
 
-    add_option('--target=DIR',
-               'target directory for unpacking') do |value, options|
+    add_option("--target=DIR",
+               "target directory for unpacking") do |value, options|
       options[:target] = value
     end
 
-    add_option('--spec', 'unpack the gem specification') do |value, options|
+    add_option("--spec", "unpack the gem specification") do |value, options|
       options[:spec] = true
     end
 
@@ -104,11 +103,11 @@ command help for an example.
           end
         end
 
-        File.open destination, 'w' do |io|
+        File.open destination, "w" do |io|
           io.write metadata
         end
       else
-        basename = File.basename path, '.gem'
+        basename = File.basename path, ".gem"
         target_dir = File.expand_path basename, options[:target]
 
         package = Gem::Package.new path, security_policy
@@ -157,7 +156,7 @@ command help for an example.
 
     specs = dependency.matching_specs
 
-    selected = specs.max_by { |s| s.version }
+    selected = specs.max_by {|s| s.version }
 
     return Gem::RemoteFetcher.fetcher.download_to_cache(dependency) unless
       selected
@@ -173,5 +172,4 @@ command help for an example.
 
     path
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/update_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/update_command.rb
@@ -1,16 +1,15 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/command_manager'
-require 'rubygems/dependency_installer'
-require 'rubygems/install_update_options'
-require 'rubygems/local_remote_options'
-require 'rubygems/spec_fetcher'
-require 'rubygems/version_option'
-require 'rubygems/install_message' # must come before rdoc for messaging
-require 'rubygems/rdoc'
+require_relative "../command"
+require_relative "../command_manager"
+require_relative "../dependency_installer"
+require_relative "../install_update_options"
+require_relative "../local_remote_options"
+require_relative "../spec_fetcher"
+require_relative "../version_option"
+require_relative "../install_message" # must come before rdoc for messaging
+require_relative "../rdoc"
 
 class Gem::Commands::UpdateCommand < Gem::Command
-
   include Gem::InstallUpdateOptions
   include Gem::LocalRemoteOptions
   include Gem::VersionOption
@@ -20,20 +19,24 @@ class Gem::Commands::UpdateCommand < Gem
   attr_reader :updated # :nodoc:
 
   def initialize
-    super 'update', 'Update installed gems to the latest version',
-      :document => %w[rdoc ri],
-      :force    => false
+    options = {
+      :force => false,
+    }
+
+    options.merge!(install_update_options)
+
+    super "update", "Update installed gems to the latest version", options
 
     add_install_update_options
 
-    OptionParser.accept Gem::Version do |value|
+    Gem::OptionParser.accept Gem::Version do |value|
       Gem::Version.new value
 
       value
     end
 
-    add_option('--system [VERSION]', Gem::Version,
-               'Update the RubyGems system software') do |value, options|
+    add_option("--system [VERSION]", Gem::Version,
+               "Update the RubyGems system software") do |value, options|
       value = true unless value
 
       options[:system] = value
@@ -52,7 +55,8 @@ class Gem::Commands::UpdateCommand < Gem
   end
 
   def defaults_str # :nodoc:
-    "--document --no-force --install-dir #{Gem.dir}"
+    "--no-force --install-dir #{Gem.dir}\n" +
+      install_update_defaults_str
   end
 
   def description # :nodoc:
@@ -73,8 +77,13 @@ command to remove old versions.
       say "Latest version already installed. Done."
       terminate_interaction
     end
+  end
 
-    options[:user_install] = false
+  def check_oldest_rubygems(version) # :nodoc:
+    if oldest_supported_version > version
+      alert_error "rubygems #{version} is not supported on #{RUBY_VERSION}. The oldest version supported by this ruby is #{oldest_supported_version}"
+      terminate_interaction 1
+    end
   end
 
   def check_update_arguments # :nodoc:
@@ -90,9 +99,10 @@ command to remove old versions.
       return
     end
 
-    hig = highest_installed_gems
-
-    gems_to_update = which_to_update hig, options[:args].uniq
+    gems_to_update = which_to_update(
+      highest_installed_gems,
+      options[:args].uniq
+    )
 
     if options[:explain]
       say "Gems to update:"
@@ -108,15 +118,19 @@ command to remove old versions.
 
     updated = update_gems gems_to_update
 
-    updated_names = updated.map { |spec| spec.name }
+    installed_names = highest_installed_gems.keys
+    updated_names = updated.map {|spec| spec.name }
     not_updated_names = options[:args].uniq - updated_names
+    not_installed_names = not_updated_names - installed_names
+    up_to_date_names = not_updated_names - not_installed_names
 
     if updated.empty?
       say "Nothing to update"
     else
       say "Gems updated: #{updated_names.join(' ')}"
-      say "Gems already up-to-date: #{not_updated_names.join(' ')}" unless not_updated_names.empty?
     end
+    say "Gems already up-to-date: #{up_to_date_names.join(' ')}" unless up_to_date_names.empty?
+    say "Gems not currently installed: #{not_installed_names.join(' ')}" unless not_installed_names.empty?
   end
 
   def fetch_remote_gems(spec) # :nodoc:
@@ -127,7 +141,7 @@ command to remove old versions.
 
     spec_tuples, errors = fetcher.search_for_dependency dependency
 
-    error = errors.find { |e| e.respond_to? :exception }
+    error = errors.find {|e| e.respond_to? :exception }
 
     raise error if error
 
@@ -137,8 +151,11 @@ command to remove old versions.
   def highest_installed_gems # :nodoc:
     hig = {} # highest installed gems
 
+    # Get only gem specifications installed as --user-install
+    Gem::Specification.dirs = Gem.user_dir if options[:user_install]
+
     Gem::Specification.each do |spec|
-      if hig[spec.name].nil? or hig[spec.name].version < spec.version
+      if hig[spec.name].nil? || hig[spec.name].version < spec.version
         hig[spec.name] = spec
       end
     end
@@ -149,27 +166,46 @@ command to remove old versions.
   def highest_remote_name_tuple(spec) # :nodoc:
     spec_tuples = fetch_remote_gems spec
 
-    matching_gems = spec_tuples.select do |g,_|
-      g.name == spec.name and g.match_platform?
-    end
-
-    highest_remote_gem = matching_gems.max
-
-    highest_remote_gem ||= [Gem::NameTuple.null]
+    highest_remote_gem = spec_tuples.max
+    return unless highest_remote_gem
 
     highest_remote_gem.first
   end
 
-  def install_rubygems(version) # :nodoc:
+  def install_rubygems(spec) # :nodoc:
     args = update_rubygems_arguments
+    version = spec.version
 
-    update_dir = File.join Gem.dir, 'gems', "rubygems-update-#{version}"
+    update_dir = File.join spec.base_dir, "gems", "rubygems-update-#{version}"
 
     Dir.chdir update_dir do
-      say "Installing RubyGems #{version}"
+      say "Installing RubyGems #{version}" unless options[:silent]
+
+      installed = preparing_gem_layout_for(version) do
+        system Gem.ruby, "--disable-gems", "setup.rb", *args
+      end
 
-      installed = system Gem.ruby, '--disable-gems', 'setup.rb', *args
-      say "RubyGems system software updated" if installed
+      say "RubyGems system software updated" if installed unless options[:silent]
+    end
+  end
+
+  def preparing_gem_layout_for(version)
+    if Gem::Version.new(version) >= Gem::Version.new("3.2.a")
+      yield
+    else
+      require "tmpdir"
+      tmpdir = Dir.mktmpdir
+      FileUtils.mv Gem.plugindir, tmpdir
+
+      status = yield
+
+      if status
+        FileUtils.rm_rf tmpdir
+      else
+        FileUtils.mv File.join(tmpdir, "plugins"), Gem.plugindir
+      end
+
+      status
     end
   end
 
@@ -177,43 +213,35 @@ command to remove old versions.
     version = options[:system]
     update_latest = version == true
 
-    if update_latest
-      version     = Gem::Version.new     Gem::VERSION
-      requirement = Gem::Requirement.new ">= #{Gem::VERSION}"
-    else
+    unless update_latest
       version     = Gem::Version.new     version
       requirement = Gem::Requirement.new version
+
+      return version, requirement
     end
 
+    version     = Gem::Version.new     Gem::VERSION
+    requirement = Gem::Requirement.new ">= #{Gem::VERSION}"
+
     rubygems_update         = Gem::Specification.new
-    rubygems_update.name    = 'rubygems-update'
+    rubygems_update.name    = "rubygems-update"
     rubygems_update.version = version
 
-    hig = {
-      'rubygems-update' => rubygems_update
-    }
-
-    gems_to_update = which_to_update hig, options[:args], :system
-    up_ver = gems_to_update.first.version
-
-    target = if update_latest
-               up_ver
-             else
-               version
-             end
+    highest_remote_tup = highest_remote_name_tuple(rubygems_update)
+    target = highest_remote_tup ? highest_remote_tup.version : version
 
     return target, requirement
   end
 
   def update_gem(name, version = Gem::Requirement.default)
-    return if @updated.any? { |spec| spec.name == name }
+    return if @updated.any? {|spec| spec.name == name }
 
     update_options = options.dup
     update_options[:prerelease] = version.prerelease?
 
     @installer = Gem::DependencyInstaller.new update_options
 
-    say "Updating #{name}"
+    say "Updating #{name}" unless options[:system] && options[:silent]
     begin
       @installer.install name, Gem::Requirement.new(version)
     rescue Gem::InstallError, Gem::DependencyError => e
@@ -237,48 +265,78 @@ command to remove old versions.
   # Update RubyGems software to the latest version.
 
   def update_rubygems
+    if Gem.disable_system_update_message
+      alert_error Gem.disable_system_update_message
+      terminate_interaction 1
+    end
+
     check_update_arguments
 
     version, requirement = rubygems_target_version
 
     check_latest_rubygems version
 
-    update_gem 'rubygems-update', version
+    check_oldest_rubygems version
 
-    installed_gems = Gem::Specification.find_all_by_name 'rubygems-update', requirement
-    version        = installed_gems.first.version
+    installed_gems = Gem::Specification.find_all_by_name "rubygems-update", requirement
+    installed_gems = update_gem("rubygems-update", version) if installed_gems.empty? || installed_gems.first.version != version
+    return if installed_gems.empty?
 
-    install_rubygems version
+    install_rubygems installed_gems.first
   end
 
   def update_rubygems_arguments # :nodoc:
     args = []
-    args << '--prefix' << Gem.prefix if Gem.prefix
-    args << '--no-document' unless options[:document].include?('rdoc') || options[:document].include?('ri')
-    args << '--no-format-executable' if options[:no_format_executable]
-    args << '--previous-version' << Gem::VERSION if
-      options[:system] == true or
-        Gem::Version.new(options[:system]) >= Gem::Version.new(2)
+    args << "--silent" if options[:silent]
+    args << "--prefix" << Gem.prefix if Gem.prefix
+    args << "--no-document" unless options[:document].include?("rdoc") || options[:document].include?("ri")
+    args << "--no-format-executable" if options[:no_format_executable]
+    args << "--previous-version" << Gem::VERSION if
+      options[:system] == true ||
+      Gem::Version.new(options[:system]) >= Gem::Version.new(2)
     args
   end
 
-  def which_to_update(highest_installed_gems, gem_names, system = false)
+  def which_to_update(highest_installed_gems, gem_names)
     result = []
 
     highest_installed_gems.each do |l_name, l_spec|
-      next if not gem_names.empty? and
-              gem_names.none? { |name| name == l_spec.name }
+      next if !gem_names.empty? &&
+              gem_names.none? {|name| name == l_spec.name }
 
       highest_remote_tup = highest_remote_name_tuple l_spec
-      highest_remote_ver = highest_remote_tup.version
-      highest_installed_ver = l_spec.version
+      next unless highest_remote_tup
 
-      if system or (highest_installed_ver < highest_remote_ver)
-        result << Gem::NameTuple.new(l_spec.name, [highest_installed_ver, highest_remote_ver].max, highest_remote_tup.platform)
-      end
+      result << highest_remote_tup
     end
 
     result
   end
 
+  private
+
+  #
+  # Oldest version we support downgrading to. This is the version that
+  # originally ships with the first patch version of each ruby, because we never
+  # test each ruby against older rubygems, so we can't really guarantee it
+  # works. Version list can be checked here: https://stdgems.org/rubygems
+  #
+  def oldest_supported_version
+    @oldest_supported_version ||=
+      if Gem.ruby_version > Gem::Version.new("3.1.a")
+        Gem::Version.new("3.3.3")
+      elsif Gem.ruby_version > Gem::Version.new("3.0.a")
+        Gem::Version.new("3.2.3")
+      elsif Gem.ruby_version > Gem::Version.new("2.7.a")
+        Gem::Version.new("3.1.2")
+      elsif Gem.ruby_version > Gem::Version.new("2.6.a")
+        Gem::Version.new("3.0.1")
+      elsif Gem.ruby_version > Gem::Version.new("2.5.a")
+        Gem::Version.new("2.7.3")
+      elsif Gem.ruby_version > Gem::Version.new("2.4.a")
+        Gem::Version.new("2.6.8")
+      else
+        Gem::Version.new("2.5.2")
+      end
+  end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/which_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/which_command.rb
@@ -1,18 +1,17 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative "../command"
 
 class Gem::Commands::WhichCommand < Gem::Command
-
   def initialize
-    super 'which', 'Find the location of a library file you can require',
+    super "which", "Find the location of a library file you can require",
           :search_gems_first => false, :show_all => false
 
-    add_option '-a', '--[no-]all', 'show all matching files' do |show_all, options|
+    add_option "-a", "--[no-]all", "show all matching files" do |show_all, options|
       options[:show_all] = show_all
     end
 
-    add_option '-g', '--[no-]gems-first',
-               'search gems before non-gems' do |gems_first, options|
+    add_option "-g", "--[no-]gems-first",
+               "search gems before non-gems" do |gems_first, options|
       options[:search_gems_first] = gems_first
     end
   end
@@ -40,7 +39,7 @@ requiring to see why it does not behave 
     found = true
 
     options[:args].each do |arg|
-      arg = arg.sub(/#{Regexp.union(*Gem.suffixes)}$/, '')
+      arg = arg.sub(/#{Regexp.union(*Gem.suffixes)}$/, "")
       dirs = $LOAD_PATH
 
       spec = Gem::Specification.find_by_path arg
@@ -72,7 +71,7 @@ requiring to see why it does not behave 
     dirs.each do |dir|
       Gem.suffixes.each do |ext|
         full_path = File.join dir, "#{package_name}#{ext}"
-        if File.exist? full_path and not File.directory? full_path
+        if File.exist?(full_path) && !File.directory?(full_path)
           result << full_path
           return result unless options[:show_all]
         end
@@ -85,5 +84,4 @@ requiring to see why it does not behave 
   def usage # :nodoc:
     "#{program_name} FILE [FILE ...]"
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/commands/yank_command.rb
+++ ruby2.7-2.7.6/lib/rubygems/commands/yank_command.rb
@@ -1,11 +1,10 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/version_option'
-require 'rubygems/gemcutter_utilities'
+require_relative "../command"
+require_relative "../local_remote_options"
+require_relative "../version_option"
+require_relative "../gemcutter_utilities"
 
 class Gem::Commands::YankCommand < Gem::Command
-
   include Gem::LocalRemoteOptions
   include Gem::VersionOption
   include Gem::GemcutterUtilities
@@ -25,19 +24,19 @@ data you will need to change them immedi
   end
 
   def usage # :nodoc:
-    "#{program_name} GEM -v VERSION [-p PLATFORM] [--key KEY_NAME] [--host HOST]"
+    "#{program_name} -v VERSION [-p PLATFORM] [--key KEY_NAME] [--host HOST] GEM"
   end
 
   def initialize
-    super 'yank', 'Remove a pushed gem from the index'
+    super "yank", "Remove a pushed gem from the index"
 
     add_version_option("remove")
     add_platform_option("remove")
     add_otp_option
 
-    add_option('--host HOST',
-               'Yank from another gemcutter-compatible host',
-               '  (e.g. https://rubygems.org)') do |value, options|
+    add_option("--host HOST",
+               "Yank from another gemcutter-compatible host",
+               "  (e.g. https://rubygems.org)") do |value, options|
       options[:host] = value
     end
 
@@ -48,7 +47,7 @@ data you will need to change them immedi
   def execute
     @host = options[:host]
 
-    sign_in @host
+    sign_in @host, scope: get_yank_scope
 
     version   = get_version_from_requirements(options[:version])
     platform  = get_platform_from_requirements(options)
@@ -73,15 +72,14 @@ data you will need to change them immedi
 
   def yank_api_request(method, version, platform, api)
     name = get_one_gem_name
-    response = rubygems_api_request(method, api, host) do |request|
+    response = rubygems_api_request(method, api, host, scope: get_yank_scope) do |request|
       request.add_field("Authorization", api_key)
-      request.add_field("OTP", options[:otp]) if options[:otp]
 
       data = {
-        'gem_name' => name,
-        'version' => version,
+        "gem_name" => name,
+        "version" => version,
       }
-      data['platform'] = platform if platform
+      data["platform"] = platform if platform
 
       request.set_form_data data
     end
@@ -94,8 +92,7 @@ data you will need to change them immedi
     nil
   end
 
-  def get_platform_from_requirements(requirements)
-    Gem.platforms[1].to_s if requirements.key? :added_platform
+  def get_yank_scope
+    :yank_rubygem
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/compatibility.rb
+++ ruby2.7-2.7.6/lib/rubygems/compatibility.rb
@@ -1,5 +1,4 @@
 # frozen_string_literal: true
-# :stopdoc:
 
 #--
 # This file contains all sorts of little compatibility hacks that we've
@@ -8,10 +7,13 @@
 #
 # Ruby 1.9.x has introduced some things that are awkward, and we need to
 # support them, so we define some constants to use later.
+#
+# TODO remove at RubyGems 4
 #++
 
-# TODO remove at RubyGems 4
 module Gem
+  # :stopdoc:
+
   RubyGemsVersion = VERSION
   deprecate_constant(:RubyGemsVersion)
 
--- ruby2.7-2.7.6.orig/lib/rubygems/config_file.rb
+++ ruby2.7-2.7.6/lib/rubygems/config_file.rb
@@ -5,8 +5,8 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/user_interaction'
-require 'rbconfig'
+require_relative "user_interaction"
+require "rbconfig"
 
 ##
 # Gem::ConfigFile RubyGems options and gem command options from gemrc.
@@ -37,15 +37,15 @@ require 'rbconfig'
 # - per environment (gemrc files listed in the GEMRC environment variable)
 
 class Gem::ConfigFile
-
   include Gem::UserInteraction
 
-  DEFAULT_BACKTRACE = false
+  DEFAULT_BACKTRACE = true
   DEFAULT_BULK_THRESHOLD = 1000
   DEFAULT_VERBOSITY = true
   DEFAULT_UPDATE_SOURCES = true
   DEFAULT_CONCURRENT_DOWNLOADS = 8
   DEFAULT_CERT_EXPIRATION_LENGTH_DAYS = 365
+  DEFAULT_IPV4_FALLBACK_ENABLED = false
 
   ##
   # For Ruby packagers to set configuration defaults.  Set in
@@ -71,7 +71,7 @@ class Gem::ConfigFile
 
   # :startdoc:
 
-  SYSTEM_WIDE_CONFIG_FILE = File.join SYSTEM_CONFIG_PATH, 'gemrc'
+  SYSTEM_WIDE_CONFIG_FILE = File.join SYSTEM_CONFIG_PATH, "gemrc"
 
   ##
   # List of arguments supplied to the config file object.
@@ -142,6 +142,12 @@ class Gem::ConfigFile
   attr_accessor :cert_expiration_length_days
 
   ##
+  # == Experimental ==
+  # Fallback to IPv4 when IPv6 is not reachable or slow (default: false)
+
+  attr_accessor :ipv4_fallback_enabled
+
+  ##
   # Path name of directory or file of openssl client certificate, used for remote https connection with client authentication
 
   attr_reader :ssl_client_cert
@@ -176,19 +182,20 @@ class Gem::ConfigFile
     @update_sources = DEFAULT_UPDATE_SOURCES
     @concurrent_downloads = DEFAULT_CONCURRENT_DOWNLOADS
     @cert_expiration_length_days = DEFAULT_CERT_EXPIRATION_LENGTH_DAYS
+    @ipv4_fallback_enabled = ENV["IPV4_FALLBACK_ENABLED"] == "true" || DEFAULT_IPV4_FALLBACK_ENABLED
 
     operating_system_config = Marshal.load Marshal.dump(OPERATING_SYSTEM_DEFAULTS)
     platform_config = Marshal.load Marshal.dump(PLATFORM_DEFAULTS)
     system_config = load_file SYSTEM_WIDE_CONFIG_FILE
     user_config = load_file config_file_name.dup.tap(&Gem::UNTAINT)
 
-    environment_config = (ENV['GEMRC'] || '')
+    environment_config = (ENV["GEMRC"] || "")
       .split(File::PATH_SEPARATOR).inject({}) do |result, file|
         result.merge load_file file
       end
 
     @hash = operating_system_config.merge platform_config
-    unless args.index '--norc'
+    unless args.index "--norc"
       @hash = @hash.merge system_config
       @hash = @hash.merge user_config
       @hash = @hash.merge environment_config
@@ -204,6 +211,7 @@ class Gem::ConfigFile
     @disable_default_gem_server  = @hash[:disable_default_gem_server]  if @hash.key? :disable_default_gem_server
     @sources                     = @hash[:sources]                     if @hash.key? :sources
     @cert_expiration_length_days = @hash[:cert_expiration_length_days] if @hash.key? :cert_expiration_length_days
+    @ipv4_fallback_enabled       = @hash[:ipv4_fallback_enabled]       if @hash.key? :ipv4_fallback_enabled
 
     @ssl_verify_mode  = @hash[:ssl_verify_mode]  if @hash.key? :ssl_verify_mode
     @ssl_ca_cert      = @hash[:ssl_ca_cert]      if @hash.key? :ssl_ca_cert
@@ -261,17 +269,22 @@ if you believe they were disclosed to a 
   # Location of RubyGems.org credentials
 
   def credentials_path
-    File.join Gem.user_home, '.gem', 'credentials'
+    credentials = File.join Gem.user_home, ".gem", "credentials"
+    if File.exist? credentials
+      credentials
+    else
+      File.join Gem.data_home, "gem", "credentials"
+    end
   end
 
   def load_api_keys
     check_credentials_permissions
 
     @api_keys = if File.exist? credentials_path
-                  load_file(credentials_path)
-                else
-                  @hash
-                end
+      load_file(credentials_path)
+    else
+      @hash
+    end
 
     if @api_keys.key? :rubygems_api_key
       @rubygems_api_key    = @api_keys[:rubygems_api_key]
@@ -307,12 +320,13 @@ if you believe they were disclosed to a 
     config = load_file(credentials_path).merge(host => api_key)
 
     dirname = File.dirname credentials_path
-    Dir.mkdir(dirname) unless File.exist? dirname
+    require "fileutils"
+    FileUtils.mkdir_p(dirname)
 
     Gem.load_yaml
 
     permissions = 0600 & (~File.umask)
-    File.open(credentials_path, 'w', permissions) do |f|
+    File.open(credentials_path, "w", permissions) do |f|
       f.write config.to_yaml
     end
 
@@ -354,7 +368,7 @@ if you believe they were disclosed to a 
 
   # True if the backtrace option has been specified, or debug is on.
   def backtrace
-    @backtrace or $DEBUG
+    @backtrace || $DEBUG
   end
 
   # The name of the configuration file.
@@ -375,7 +389,7 @@ if you believe they were disclosed to a 
     yield :backtrace, @backtrace
     yield :bulk_threshold, @bulk_threshold
 
-    yield 'config_file_name', @config_file_name if @config_file_name
+    yield "config_file_name", @config_file_name if @config_file_name
 
     hash.each(&block)
   end
@@ -391,7 +405,7 @@ if you believe they were disclosed to a 
       when /^--debug$/ then
         $DEBUG = true
 
-        warn 'NOTE:  Debugging mode prints all exceptions even when rescued'
+        warn "NOTE:  Debugging mode prints all exceptions even when rescued"
       else
         @args << arg
       end
@@ -429,8 +443,8 @@ if you believe they were disclosed to a 
     yaml_hash[:ssl_client_cert] =
       @hash[:ssl_client_cert] if @hash.key? :ssl_client_cert
 
-    keys = yaml_hash.keys.map { |key| key.to_s }
-    keys << 'debug'
+    keys = yaml_hash.keys.map {|key| key.to_s }
+    keys << "debug"
     re = Regexp.union(*keys)
 
     @hash.each do |key, value|
@@ -444,7 +458,10 @@ if you believe they were disclosed to a 
 
   # Writes out this config file, replacing its source.
   def write
-    File.open config_file_name, 'w' do |io|
+    require "fileutils"
+    FileUtils.mkdir_p File.dirname(config_file_name)
+
+    File.open config_file_name, "w" do |io|
       io.write to_yaml
     end
   end
@@ -460,11 +477,11 @@ if you believe they were disclosed to a 
   end
 
   def ==(other) # :nodoc:
-    self.class === other and
-      @backtrace == other.backtrace and
-      @bulk_threshold == other.bulk_threshold and
-      @verbose == other.verbose and
-      @update_sources == other.update_sources and
+    self.class === other &&
+      @backtrace == other.backtrace &&
+      @bulk_threshold == other.bulk_threshold &&
+      @verbose == other.verbose &&
+      @update_sources == other.update_sources &&
       @hash == other.hash
   end
 
@@ -488,5 +505,4 @@ if you believe they were disclosed to a 
       end
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/core_ext/kernel_gem.rb
+++ ruby2.7-2.7.6/lib/rubygems/core_ext/kernel_gem.rb
@@ -39,7 +39,7 @@ module Kernel
   #   GEM_SKIP=libA:libB ruby -I../libA -I../libB ./mycode.rb
 
   def gem(gem_name, *requirements) # :doc:
-    skip_list = (ENV['GEM_SKIP'] || "").split(/:/)
+    skip_list = (ENV["GEM_SKIP"] || "").split(/:/)
     raise Gem::LoadError, "skipping #{gem_name}" if skip_list.include? gem_name
 
     if gem_name.kind_of? Gem::Dependency
--- ruby2.7-2.7.6.orig/lib/rubygems/core_ext/kernel_require.rb
+++ ruby2.7-2.7.6/lib/rubygems/core_ext/kernel_require.rb
@@ -5,7 +5,7 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'monitor'
+require "monitor"
 
 module Kernel
 
@@ -17,6 +17,8 @@ module Kernel
     private :gem_original_require
   end
 
+  file = Gem::KERNEL_WARN_IGNORES_INTERNAL_ENTRIES ? "<internal:#{__FILE__}>" : __FILE__
+  module_eval <<'RUBY', file, __LINE__ + 1 # rubocop:disable Style/EvalWithLocation
   ##
   # When RubyGems is required, Kernel#require is replaced with our own which
   # is capable of loading gems on demand.
@@ -130,7 +132,7 @@ module Kernel
 
       # Ok, now find a gem that has no conflicts, starting
       # at the highest version.
-      valid = found_specs.find { |s| !s.has_conflicts? }
+      valid = found_specs.find {|s| !s.has_conflicts? }
 
       unless valid
         le = Gem::LoadError.new "unable to find a version of '#{names.first}' to activate"
@@ -148,7 +150,7 @@ module Kernel
     RUBYGEMS_ACTIVATION_MONITOR.enter
 
     begin
-      if load_error.message.end_with?(path) and Gem.try_activate(path)
+      if load_error.path == path and Gem.try_activate(path)
         require_again = true
       end
     ensure
@@ -166,6 +168,7 @@ module Kernel
       end
     end
   end
+RUBY
 
   private :require
 
--- ruby2.7-2.7.6.orig/lib/rubygems/core_ext/kernel_warn.rb
+++ ruby2.7-2.7.6/lib/rubygems/core_ext/kernel_warn.rb
@@ -1,27 +1,25 @@
 # frozen_string_literal: true
 
 # `uplevel` keyword argument of Kernel#warn is available since ruby 2.5.
-if RUBY_VERSION >= "2.5"
+if RUBY_VERSION >= "2.5" && !Gem::KERNEL_WARN_IGNORES_INTERNAL_ENTRIES
 
   module Kernel
-    path = "#{__dir__}/" # Frames to be skipped start with this path.
+    rubygems_path = "#{__dir__}/" # Frames to be skipped start with this path.
 
-    original_warn = method(:warn)
+    original_warn = instance_method(:warn)
 
     remove_method :warn
 
     class << self
-
       remove_method :warn
-
     end
 
     module_function define_method(:warn) {|*messages, **kw|
       unless uplevel = kw[:uplevel]
         if Gem.java_platform?
-          return original_warn.call(*messages)
+          return original_warn.bind(self).call(*messages)
         else
-          return original_warn.call(*messages, **kw)
+          return original_warn.bind(self).call(*messages, **kw)
         end
       end
 
@@ -40,16 +38,17 @@ if RUBY_VERSION >= "2.5"
 
           start += 1
 
-          unless loc.path.start_with?(path)
-            # Non-rubygems frames
-            uplevel -= 1
+          if path = loc.path
+            unless path.start_with?(rubygems_path) || path.start_with?("<internal:")
+              # Non-rubygems frames
+              uplevel -= 1
+            end
           end
         end
-        uplevel = start
+        kw[:uplevel] = start
       end
 
-      kw[:uplevel] = uplevel
-      original_warn.call(*messages, **kw)
+      original_warn.bind(self).call(*messages, **kw)
     }
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/core_ext/tcpsocket_init.rb
@@ -0,0 +1,52 @@
+require "socket"
+
+module CoreExtensions
+  module TCPSocketExt
+    def self.prepended(base)
+      base.prepend Initializer
+    end
+
+    module Initializer
+      CONNECTION_TIMEOUT = 5
+      IPV4_DELAY_SECONDS = 0.1
+
+      def initialize(host, serv, *rest)
+        mutex = Thread::Mutex.new
+        addrs = []
+        threads = []
+        cond_var = Thread::ConditionVariable.new
+
+        Addrinfo.foreach(host, serv, nil, :STREAM) do |addr|
+          Thread.report_on_exception = false if defined? Thread.report_on_exception = ()
+
+          threads << Thread.new(addr) do
+            # give head start to ipv6 addresses
+            sleep IPV4_DELAY_SECONDS if addr.ipv4?
+
+            # raises Errno::ECONNREFUSED when ip:port is unreachable
+            Socket.tcp(addr.ip_address, serv, connect_timeout: CONNECTION_TIMEOUT).close
+            mutex.synchronize do
+              addrs << addr.ip_address
+              cond_var.signal
+            end
+          end
+        end
+
+        mutex.synchronize do
+          timeout_time = CONNECTION_TIMEOUT + Time.now.to_f
+          while addrs.empty? && (remaining_time = timeout_time - Time.now.to_f) > 0
+            cond_var.wait(mutex, remaining_time)
+          end
+
+          host = addrs.shift unless addrs.empty?
+        end
+
+        threads.each {|t| t.kill.join if t.alive? }
+
+        super(host, serv, *rest)
+      end
+    end
+  end
+end
+
+TCPSocket.prepend CoreExtensions::TCPSocketExt
--- ruby2.7-2.7.6.orig/lib/rubygems/defaults.rb
+++ ruby2.7-2.7.6/lib/rubygems/defaults.rb
@@ -20,7 +20,13 @@ module Gem
   # specified in the environment
 
   def self.default_spec_cache_dir
-    File.join Gem.user_home, '.gem', 'specs'
+    default_spec_cache_dir = File.join Gem.user_home, ".gem", "specs"
+
+    unless File.exist?(default_spec_cache_dir)
+      default_spec_cache_dir = File.join Gem.data_home, "gem", "specs"
+    end
+
+    default_spec_cache_dir
   end
 
   ##
@@ -28,21 +34,7 @@ module Gem
   # specified in the environment
 
   def self.default_dir
-    path = if defined? RUBY_FRAMEWORK_VERSION
-             [
-               File.dirname(RbConfig::CONFIG['sitedir']),
-               'Gems',
-               RbConfig::CONFIG['ruby_version']
-             ]
-           else
-             [
-               RbConfig::CONFIG['rubylibprefix'],
-               'gems',
-               RbConfig::CONFIG['ruby_version']
-             ]
-           end
-
-    @default_dir ||= File.join(*path)
+    @default_dir ||= File.join(RbConfig::CONFIG["rubylibprefix"], "gems", RbConfig::CONFIG["ruby_version"])
   end
 
   ##
@@ -67,19 +59,95 @@ module Gem
   # Path to specification files of default gems.
 
   def self.default_specifications_dir
-    File.join(Gem.default_dir, "specifications", "default")
+    @default_specifications_dir ||= File.join(Gem.default_dir, "specifications", "default")
+  end
+
+  ##
+  # Finds the user's home directory.
+  #--
+  # Some comments from the ruby-talk list regarding finding the home
+  # directory:
+  #
+  #   I have HOME, USERPROFILE and HOMEDRIVE + HOMEPATH. Ruby seems
+  #   to be depending on HOME in those code samples. I propose that
+  #   it should fallback to USERPROFILE and HOMEDRIVE + HOMEPATH (at
+  #   least on Win32).
+  #++
+  #--
+  #
+  #++
+
+  def self.find_home
+    Dir.home.dup
+  rescue
+    if Gem.win_platform?
+      File.expand_path File.join(ENV["HOMEDRIVE"] || ENV["SystemDrive"], "/")
+    else
+      File.expand_path "/"
+    end
+  end
+
+  private_class_method :find_home
+
+  ##
+  # The home directory for the user.
+
+  def self.user_home
+    @user_home ||= find_home.tap(&Gem::UNTAINT)
   end
 
   ##
   # Path for gems in the user's home directory
 
   def self.user_dir
-    parts = [Gem.user_home, '.gem', ruby_engine]
-    parts << RbConfig::CONFIG['ruby_version'] unless RbConfig::CONFIG['ruby_version'].empty?
+    gem_dir = File.join(Gem.user_home, ".gem")
+    gem_dir = File.join(Gem.data_home, "gem") unless File.exist?(gem_dir)
+    parts = [gem_dir, ruby_engine]
+    parts << RbConfig::CONFIG["ruby_version"] unless RbConfig::CONFIG["ruby_version"].empty?
     File.join parts
   end
 
   ##
+  # The path to standard location of the user's configuration directory.
+
+  def self.config_home
+    @config_home ||= (ENV["XDG_CONFIG_HOME"] || File.join(Gem.user_home, ".config"))
+  end
+
+  ##
+  # Finds the user's config file
+
+  def self.find_config_file
+    gemrc = File.join Gem.user_home, ".gemrc"
+    if File.exist? gemrc
+      gemrc
+    else
+      File.join Gem.config_home, "gem", "gemrc"
+    end
+  end
+
+  ##
+  # The path to standard location of the user's .gemrc file.
+
+  def self.config_file
+    @config_file ||= find_config_file.tap(&Gem::UNTAINT)
+  end
+
+  ##
+  # The path to standard location of the user's cache directory.
+
+  def self.cache_home
+    @cache_home ||= (ENV["XDG_CACHE_HOME"] || File.join(Gem.user_home, ".cache"))
+  end
+
+  ##
+  # The path to standard location of the user's data directory.
+
+  def self.data_home
+    @data_home ||= (ENV["XDG_DATA_HOME"] || File.join(Gem.user_home, ".local", "share"))
+  end
+
+  ##
   # How String Gem paths should be split.  Overridable for esoteric platforms.
 
   def self.path_separator
@@ -93,7 +161,7 @@ module Gem
     path = []
     path << user_dir if user_home && File.exist?(user_home)
     path << default_dir
-    path << vendor_dir if vendor_dir and File.directory? vendor_dir
+    path << vendor_dir if vendor_dir && File.directory?(vendor_dir)
     path
   end
 
@@ -101,7 +169,7 @@ module Gem
   # Deduce Ruby's --program-prefix and --program-suffix from its install name
 
   def self.default_exec_format
-    exec_format = RbConfig::CONFIG['ruby_install_name'].sub('ruby', '%s') rescue '%s'
+    exec_format = RbConfig::CONFIG["ruby_install_name"].sub("ruby", "%s") rescue "%s"
 
     unless exec_format =~ /%s/
       raise Gem::Exception,
@@ -115,11 +183,7 @@ module Gem
   # The default directory for binaries
 
   def self.default_bindir
-    if defined? RUBY_FRAMEWORK_VERSION  # mac framework support
-      '/usr/bin'
-    else # generic install
-      RbConfig::CONFIG['bindir']
-    end
+    RbConfig::CONFIG["bindir"]
   end
 
   def self.ruby_engine
@@ -130,14 +194,26 @@ module Gem
   # The default signing key path
 
   def self.default_key_path
-    File.join Gem.user_home, ".gem", "gem-private_key.pem"
+    default_key_path = File.join Gem.user_home, ".gem", "gem-private_key.pem"
+
+    unless File.exist?(default_key_path)
+      default_key_path = File.join Gem.data_home, "gem", "gem-private_key.pem"
+    end
+
+    default_key_path
   end
 
   ##
   # The default signing certificate chain path
 
   def self.default_cert_path
-    File.join Gem.user_home, ".gem", "gem-public_cert.pem"
+    default_cert_path = File.join Gem.user_home, ".gem", "gem-public_cert.pem"
+
+    unless File.exist?(default_cert_path)
+      default_cert_path = File.join Gem.data_home, "gem", "gem-public_cert.pem"
+    end
+
+    default_cert_path
   end
 
   ##
@@ -151,14 +227,14 @@ module Gem
   # Directory where vendor gems are installed.
 
   def self.vendor_dir # :nodoc:
-    if vendor_dir = ENV['GEM_VENDOR']
+    if vendor_dir = ENV["GEM_VENDOR"]
       return vendor_dir.dup
     end
 
-    return nil unless RbConfig::CONFIG.key? 'vendordir'
+    return nil unless RbConfig::CONFIG.key? "vendordir"
 
-    File.join RbConfig::CONFIG['vendordir'], 'gems',
-              RbConfig::CONFIG['ruby_version']
+    File.join RbConfig::CONFIG["vendordir"], "gems",
+              RbConfig::CONFIG["ruby_version"]
   end
 
   ##
--- ruby2.7-2.7.6.orig/lib/rubygems/dependency.rb
+++ ruby2.7-2.7.6/lib/rubygems/dependency.rb
@@ -2,11 +2,7 @@
 ##
 # The Dependency class holds a Gem name and a Gem::Requirement.
 
-require "rubygems/bundler_version_finder"
-require "rubygems/requirement"
-
 class Gem::Dependency
-
   ##
   # Valid dependency types.
   #--
@@ -101,14 +97,14 @@ class Gem::Dependency
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 1, 'Gem::Dependency.new(', ')' do
+    q.group 1, "Gem::Dependency.new(", ")" do
       q.pp name
-      q.text ','
+      q.text ","
       q.breakable
 
       q.pp requirement
 
-      q.text ','
+      q.text ","
       q.breakable
 
       q.pp type
@@ -119,7 +115,7 @@ class Gem::Dependency
   # What does this dependency require?
 
   def requirement
-    return @requirement if defined?(@requirement) and @requirement
+    return @requirement if defined?(@requirement) && @requirement
 
     # @version_requirements and @version_requirement are legacy ivar
     # names, and supported here because older gems need to keep
@@ -201,7 +197,7 @@ class Gem::Dependency
     reqs = other.requirement.requirements
 
     return false unless reqs.length == 1
-    return false unless reqs.first.first == '='
+    return false unless reqs.first.first == "="
 
     version = reqs.first.last
 
@@ -234,10 +230,10 @@ class Gem::Dependency
 
     version = Gem::Version.new version
 
-    return true if requirement.none? and not version.prerelease?
-    return false if version.prerelease? and
-                    not allow_prerelease and
-                    not prerelease?
+    return true if requirement.none? && !version.prerelease?
+    return false if version.prerelease? &&
+                    !allow_prerelease &&
+                    !prerelease?
 
     requirement.satisfied_by? version
   end
@@ -281,11 +277,11 @@ class Gem::Dependency
       requirement.satisfied_by?(spec.version) && env_req.satisfied_by?(spec.version)
     end.map(&:to_spec)
 
-    Gem::BundlerVersionFinder.filter!(matches) if name == "bundler".freeze && !requirement.specific?
+    Gem::BundlerVersionFinder.prioritize!(matches) if prioritizes_bundler?
 
     if platform_only
       matches.reject! do |spec|
-        spec.nil? || !Gem::Platform.match(spec.platform)
+        spec.nil? || !Gem::Platform.match_spec?(spec)
       end
     end
 
@@ -299,6 +295,10 @@ class Gem::Dependency
     @requirement.specific?
   end
 
+  def prioritizes_bundler?
+    name == "bundler".freeze && !specific?
+  end
+
   def to_specs
     matches = matching_specs true
 
@@ -322,14 +322,14 @@ class Gem::Dependency
   def to_spec
     matches = self.to_specs.compact
 
-    active = matches.find { |spec| spec.activated? }
+    active = matches.find {|spec| spec.activated? }
     return active if active
 
-    return matches.first if prerelease?
-
-    # Move prereleases to the end of the list for >= 0 requirements
-    pre, matches = matches.partition { |spec| spec.version.prerelease? }
-    matches += pre if requirement == Gem::Requirement.default
+    unless prerelease?
+      # Move prereleases to the end of the list for >= 0 requirements
+      pre, matches = matches.partition {|spec| spec.version.prerelease? }
+      matches += pre if requirement == Gem::Requirement.default
+    end
 
     matches.first
   end
@@ -347,5 +347,4 @@ class Gem::Dependency
       :released
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/dependency_installer.rb
+++ ruby2.7-2.7.6/lib/rubygems/dependency_installer.rb
@@ -1,19 +1,17 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/dependency_list'
-require 'rubygems/package'
-require 'rubygems/installer'
-require 'rubygems/spec_fetcher'
-require 'rubygems/user_interaction'
-require 'rubygems/source'
-require 'rubygems/available_set'
-require 'rubygems/deprecate'
+require_relative "../rubygems"
+require_relative "dependency_list"
+require_relative "package"
+require_relative "installer"
+require_relative "spec_fetcher"
+require_relative "user_interaction"
+require_relative "available_set"
+require_relative "deprecate"
 
 ##
 # Installs a gem along with all its dependencies from local and remote gems.
 
 class Gem::DependencyInstaller
-
   include Gem::UserInteraction
   extend Gem::Deprecate
 
@@ -29,7 +27,7 @@ class Gem::DependencyInstaller
     :wrappers            => true,
     :build_args          => nil,
     :build_docs_in_background => false,
-    :install_as_default => false
+    :install_as_default => false,
   }.freeze
 
   ##
@@ -107,32 +105,11 @@ class Gem::DependencyInstaller
   end
 
   ##
-  # Creates an AvailableSet to install from based on +dep_or_name+ and
-  # +version+
-
-  def available_set_for(dep_or_name, version) # :nodoc:
-    if String === dep_or_name
-      Gem::Deprecate.skip_during do
-        find_spec_by_name_and_version dep_or_name, version, @prerelease
-      end
-    else
-      dep = dep_or_name.dup
-      dep.prerelease = @prerelease
-      @available = Gem::Deprecate.skip_during do
-        find_gems_with_sources dep
-      end
-    end
-
-    @available.pick_best!
-  end
-  deprecate :available_set_for, :none, 2019, 12
-
-  ##
   # Indicated, based on the requested domain, if local
   # gems should be considered.
 
   def consider_local?
-    @domain == :both or @domain == :local
+    @domain == :both || @domain == :local
   end
 
   ##
@@ -140,7 +117,7 @@ class Gem::DependencyInstaller
   # gems should be considered.
 
   def consider_remote?
-    @domain == :both or @domain == :remote
+    @domain == :both || @domain == :remote
   end
 
   ##
@@ -216,61 +193,11 @@ class Gem::DependencyInstaller
 
     set
   end
-  deprecate :find_gems_with_sources, :none, 2019, 12
-
-  ##
-  # Finds a spec and the source_uri it came from for gem +gem_name+ and
-  # +version+.  Returns an Array of specs and sources required for
-  # installation of the gem.
-
-  def find_spec_by_name_and_version(gem_name,
-                                    version = Gem::Requirement.default,
-                                    prerelease = false)
-    set = Gem::AvailableSet.new
-
-    if consider_local?
-      if gem_name =~ /\.gem$/ and File.file? gem_name
-        src = Gem::Source::SpecificFile.new(gem_name)
-        set.add src.spec, src
-      elsif gem_name =~ /\.gem$/
-        Dir[gem_name].each do |name|
-          begin
-            src = Gem::Source::SpecificFile.new name
-            set.add src.spec, src
-          rescue Gem::Package::FormatError
-          end
-        end
-      else
-        local = Gem::Source::Local.new
-
-        if s = local.find_gem(gem_name, version)
-          set.add s, local
-        end
-      end
-    end
-
-    if set.empty?
-      dep = Gem::Dependency.new gem_name, version
-      dep.prerelease = true if prerelease
-
-      set = Gem::Deprecate.skip_during do
-        find_gems_with_sources(dep, true)
-      end
-
-      set.match_platform!
-    end
-
-    if set.empty?
-      raise Gem::SpecificGemNotFoundException.new(gem_name, version, @errors)
-    end
-
-    @available = set
-  end
-  deprecate :find_spec_by_name_and_version, :none, 2019, 12
+  rubygems_deprecate :find_gems_with_sources
 
   def in_background(what) # :nodoc:
     fork_happened = false
-    if @build_docs_in_background and Process.respond_to?(:fork)
+    if @build_docs_in_background && Process.respond_to?(:fork)
       begin
         Process.fork do
           yield
@@ -341,7 +268,7 @@ class Gem::DependencyInstaller
   end
 
   def install_development_deps # :nodoc:
-    if @development and @dev_shallow
+    if @development && @dev_shallow
       :shallow
     elsif @development
       :all
@@ -356,13 +283,13 @@ class Gem::DependencyInstaller
     request_set.development_shallow = @dev_shallow
     request_set.soft_missing = @force
     request_set.prerelease = @prerelease
-    request_set.remote = false unless consider_remote?
 
     installer_set = Gem::Resolver::InstallerSet.new @domain
-    installer_set.ignore_installed = @only_install_dir
+    installer_set.ignore_installed = (@minimal_deps == false) || @only_install_dir
+    installer_set.force = @force
 
     if consider_local?
-      if dep_or_name =~ /\.gem$/ and File.file? dep_or_name
+      if dep_or_name =~ /\.gem$/ && File.file?(dep_or_name)
         src = Gem::Source::SpecificFile.new dep_or_name
         installer_set.add_local dep_or_name, src.spec, src
         version = src.spec.version if version == Gem::Requirement.default
@@ -380,6 +307,7 @@ class Gem::DependencyInstaller
 
     dependency =
       if spec = installer_set.local?(dep_or_name)
+        installer_set.remote = nil if spec.dependencies.none?
         Gem::Dependency.new spec.name, version
       elsif String === dep_or_name
         Gem::Dependency.new dep_or_name, version
@@ -394,6 +322,7 @@ class Gem::DependencyInstaller
     installer_set.add_always_install dependency
 
     request_set.always_install = installer_set.always_install
+    request_set.remote = installer_set.consider_remote?
 
     if @ignore_dependencies
       installer_set.ignore_dependencies = true
@@ -407,5 +336,4 @@ class Gem::DependencyInstaller
 
     request_set
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/dependency_list.rb
+++ ruby2.7-2.7.6/lib/rubygems/dependency_list.rb
@@ -5,8 +5,8 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'tsort'
-require 'rubygems/deprecate'
+require_relative "tsort"
+require_relative "deprecate"
 
 ##
 # Gem::DependencyList is used for installing and uninstalling gems in the
@@ -17,11 +17,10 @@ require 'rubygems/deprecate'
 # this class necessary anymore?  Especially #ok?, #why_not_ok?
 
 class Gem::DependencyList
-
   attr_reader :specs
 
   include Enumerable
-  include TSort
+  include Gem::TSort
 
   ##
   # Allows enabling/disabling use of development dependencies
@@ -101,11 +100,11 @@ class Gem::DependencyList
   end
 
   def find_name(full_name)
-    @specs.find { |spec| spec.full_name == full_name }
+    @specs.find {|spec| spec.full_name == full_name }
   end
 
   def inspect # :nodoc:
-    "%s %p>" % [super[0..-2], map { |s| s.full_name }]
+    "%s %p>" % [super[0..-2], map {|s| s.full_name }]
   end
 
   ##
@@ -116,15 +115,15 @@ class Gem::DependencyList
   end
 
   def why_not_ok?(quick = false)
-    unsatisfied = Hash.new { |h,k| h[k] = [] }
+    unsatisfied = Hash.new {|h,k| h[k] = [] }
     each do |spec|
       spec.runtime_dependencies.each do |dep|
         inst = Gem::Specification.any? do |installed_spec|
-          dep.name == installed_spec.name and
-            dep.requirement.satisfied_by? installed_spec.version
+          dep.name == installed_spec.name &&
+            dep.requirement.satisfied_by?(installed_spec.version)
         end
 
-        unless inst or @specs.find { |s| s.satisfies_requirement? dep }
+        unless inst || @specs.find {|s| s.satisfies_requirement? dep }
           unsatisfied[spec.name] << dep
           return unsatisfied if quick
         end
@@ -176,7 +175,7 @@ class Gem::DependencyList
   def remove_specs_unsatisfied_by(dependencies)
     specs.reject! do |spec|
       dep = dependencies[spec.name]
-      dep and not dep.requirement.satisfied_by? spec.version
+      dep && !dep.requirement.satisfied_by?(spec.version)
     end
   end
 
@@ -184,7 +183,7 @@ class Gem::DependencyList
   # Removes the gemspec matching +full_name+ from the dependency list
 
   def remove_by_name(full_name)
-    @specs.delete_if { |spec| spec.full_name == full_name }
+    @specs.delete_if {|spec| spec.full_name == full_name }
   end
 
   ##
@@ -192,7 +191,7 @@ class Gem::DependencyList
   # gemspecs that have a dependency satisfied by the named gemspec.
 
   def spec_predecessors
-    result = Hash.new { |h,k| h[k] = [] }
+    result = Hash.new {|h,k| h[k] = [] }
 
     specs = @specs.sort.reverse
 
@@ -238,7 +237,6 @@ class Gem::DependencyList
   # +ignored+.
 
   def active_count(specs, ignored)
-    specs.count { |spec| ignored[spec.full_name].nil? }
+    specs.count {|spec| ignored[spec.full_name].nil? }
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/deprecate.rb
+++ ruby2.7-2.7.6/lib/rubygems/deprecate.rb
@@ -1,23 +1,70 @@
 # frozen_string_literal: true
 ##
-# Provides a single method +deprecate+ to be used to declare when
-# something is going away.
+# Provides 3 methods for declaring when something is going away.
+#
+# +deprecate(name, repl, year, month)+:
+#     Indicate something may be removed on/after a certain date.
+#
+# +rubygems_deprecate(name, replacement=:none)+:
+#     Indicate something will be removed in the next major RubyGems version,
+#     and (optionally) a replacement for it.
+#
+# +rubygems_deprecate_command+:
+#     Indicate a RubyGems command (in +lib/rubygems/commands/*.rb+) will be
+#     removed in the next RubyGems version.
+#
+# Also provides +skip_during+ for temporarily turning off deprecation warnings.
+# This is intended to be used in the test suite, so deprecation warnings
+# don't cause test failures if you need to make sure stderr is otherwise empty.
+#
+#
+# Example usage of +deprecate+ and +rubygems_deprecate+:
 #
 #     class Legacy
-#       def self.klass_method
+#       def self.some_class_method
 #         # ...
 #       end
 #
-#       def instance_method
+#       def some_instance_method
+#         # ...
+#       end
+#
+#       def some_old_method
 #         # ...
 #       end
 #
 #       extend Gem::Deprecate
-#       deprecate :instance_method, "X.z", 2011, 4
+#       deprecate :some_instance_method, "X.z", 2011, 4
+#       rubygems_deprecate :some_old_method, "Modern#some_new_method"
 #
 #       class << self
 #         extend Gem::Deprecate
-#         deprecate :klass_method, :none, 2011, 4
+#         deprecate :some_class_method, :none, 2011, 4
+#       end
+#     end
+#
+#
+# Example usage of +rubygems_deprecate_command+:
+#
+#     class Gem::Commands::QueryCommand < Gem::Command
+#       extend Gem::Deprecate
+#       rubygems_deprecate_command
+#
+#       # ...
+#     end
+#
+#
+# Example usage of +skip_during+:
+#
+#     class TestSomething < Gem::Testcase
+#       def test_some_thing_with_deprecations
+#         Gem::Deprecate.skip_during do
+#           actual_stdout, actual_stderr = capture_output do
+#             Gem.something_deprecated
+#           end
+#           assert_empty actual_stdout
+#           assert_equal(expected, actual_stderr)
+#         end
 #       end
 #     end
 
@@ -41,6 +88,10 @@ module Gem::Deprecate
     Gem::Deprecate.skip = original
   end
 
+  def self.next_rubygems_major_version # :nodoc:
+    Gem::Version.new(Gem.rubygems_version.segments.first).bump
+  end
+
   ##
   # Simple deprecation method that deprecates +name+ by wrapping it up
   # in a dummy method. It warns on each call to the dummy method
@@ -56,15 +107,58 @@ module Gem::Deprecate
         target = klass ? "#{self}." : "#{self.class}#"
         msg = [ "NOTE: #{target}#{name} is deprecated",
                 repl == :none ? " with no replacement" : "; use #{repl} instead",
-                ". It will be removed on or after %4d-%02d-01." % [year, month],
+                ". It will be removed on or after %4d-%02d." % [year, month],
                 "\n#{target}#{name} called from #{Gem.location_of_caller.join(":")}",
         ]
         warn "#{msg.join}." unless Gem::Deprecate.skip
         send old, *args, &block
       end
+      ruby2_keywords name if respond_to?(:ruby2_keywords, true)
+    end
+  end
+
+  ##
+  # Simple deprecation method that deprecates +name+ by wrapping it up
+  # in a dummy method. It warns on each call to the dummy method
+  # telling the user of +repl+ (unless +repl+ is :none) and the
+  # Rubygems version that it is planned to go away.
+
+  def rubygems_deprecate(name, replacement=:none)
+    class_eval do
+      old = "_deprecated_#{name}"
+      alias_method old, name
+      define_method name do |*args, &block|
+        klass = self.kind_of? Module
+        target = klass ? "#{self}." : "#{self.class}#"
+        msg = [ "NOTE: #{target}#{name} is deprecated",
+                replacement == :none ? " with no replacement" : "; use #{replacement} instead",
+                ". It will be removed in Rubygems #{Gem::Deprecate.next_rubygems_major_version}",
+                "\n#{target}#{name} called from #{Gem.location_of_caller.join(":")}",
+        ]
+        warn "#{msg.join}." unless Gem::Deprecate.skip
+        send old, *args, &block
+      end
+      ruby2_keywords name if respond_to?(:ruby2_keywords, true)
+    end
+  end
+
+  # Deprecation method to deprecate Rubygems commands
+  def rubygems_deprecate_command
+    class_eval do
+      define_method "deprecated?" do
+        true
+      end
+
+      define_method "deprecation_warning" do
+        msg = [ "#{self.command} command is deprecated",
+                ". It will be removed in Rubygems #{Gem::Deprecate.next_rubygems_major_version}.\n",
+        ]
+
+        alert_warning "#{msg.join}" unless Gem::Deprecate.skip
+      end
     end
   end
 
-  module_function :deprecate, :skip_during
+  module_function :rubygems_deprecate, :rubygems_deprecate_command, :skip_during
 
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/doctor.rb
+++ ruby2.7-2.7.6/lib/rubygems/doctor.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/user_interaction'
+require_relative "../rubygems"
+require_relative "user_interaction"
 
 ##
 # Cleans up after a partially-failed uninstall or for an invalid
@@ -12,7 +12,6 @@ require 'rubygems/user_interaction'
 # removing the bogus specification.
 
 class Gem::Doctor
-
   include Gem::UserInteraction
 
   ##
@@ -20,17 +19,18 @@ class Gem::Doctor
   # subdirectory.
 
   REPOSITORY_EXTENSION_MAP = [ # :nodoc:
-    ['specifications', '.gemspec'],
-    ['build_info',     '.info'],
-    ['cache',          '.gem'],
-    ['doc',            ''],
-    ['extensions',     ''],
-    ['gems',           ''],
+    ["specifications", ".gemspec"],
+    ["build_info",     ".info"],
+    ["cache",          ".gem"],
+    ["doc",            ""],
+    ["extensions",     ""],
+    ["gems",           ""],
+    ["plugins",        ""],
   ].freeze
 
   missing =
     Gem::REPOSITORY_SUBDIRECTORIES.sort -
-      REPOSITORY_EXTENSION_MAP.map { |(k,_)| k }.sort
+    REPOSITORY_EXTENSION_MAP.map {|(k,_)| k }.sort
 
   raise "Update REPOSITORY_EXTENSION_MAP, missing: #{missing.join ', '}" unless
     missing.empty?
@@ -52,14 +52,14 @@ class Gem::Doctor
   # Specs installed in this gem repository
 
   def installed_specs # :nodoc:
-    @installed_specs ||= Gem::Specification.map { |s| s.full_name }
+    @installed_specs ||= Gem::Specification.map {|s| s.full_name }
   end
 
   ##
   # Are we doctoring a gem repository?
 
   def gem_repository?
-    not installed_specs.empty?
+    !installed_specs.empty?
   end
 
   ##
@@ -74,8 +74,8 @@ class Gem::Doctor
     Gem.use_paths @gem_repository.to_s
 
     unless gem_repository?
-      say 'This directory does not appear to be a RubyGems repository, ' +
-          'skipping'
+      say "This directory does not appear to be a RubyGems repository, " +
+          "skipping"
       say
       return
     end
@@ -111,21 +111,21 @@ class Gem::Doctor
       basename = File.basename(child, extension)
       next if installed_specs.include? basename
       next if /^rubygems-\d/ =~ basename
-      next if 'specifications' == sub_directory and 'default' == basename
+      next if "specifications" == sub_directory && "default" == basename
+      next if "plugins" == sub_directory && Gem.plugin_suffix_regexp =~ (basename)
 
-      type = File.directory?(child) ? 'directory' : 'file'
+      type = File.directory?(child) ? "directory" : "file"
 
       action = if @dry_run
-                 'Extra'
-               else
-                 FileUtils.rm_r(child)
-                 'Removed'
-               end
+        "Extra"
+      else
+        FileUtils.rm_r(child)
+        "Removed"
+      end
 
       say "#{action} #{type} #{sub_directory}/#{File.basename(child)}"
     end
   rescue Errno::ENOENT
     # ignore
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/errors.rb
+++ ruby2.7-2.7.6/lib/rubygems/errors.rb
@@ -13,13 +13,11 @@ module Gem
   # already activated gems or that RubyGems is otherwise unable to activate.
 
   class LoadError < ::LoadError
-
     # Name of gem
     attr_accessor :name
 
     # Version requirement of gem
     attr_accessor :requirement
-
   end
 
   ##
@@ -27,15 +25,15 @@ module Gem
   # system.  Instead of rescuing from this class, make sure to rescue from the
   # superclass Gem::LoadError to catch all types of load errors.
   class MissingSpecError < Gem::LoadError
-
-    def initialize(name, requirement)
+    def initialize(name, requirement, extra_message=nil)
       @name        = name
       @requirement = requirement
+      @extra_message = extra_message
     end
 
     def message # :nodoc:
       build_message +
-        "Checked in 'GEM_PATH=#{Gem.path.join(File::PATH_SEPARATOR)}', execute `gem env` for more information"
+        "Checked in 'GEM_PATH=#{Gem.path.join(File::PATH_SEPARATOR)}' #{@extra_message}, execute `gem env` for more information"
     end
 
     private
@@ -44,7 +42,6 @@ module Gem
       total = Gem::Specification.stubs.size
       "Could not find '#{name}' (#{requirement}) among #{total} total gem(s)\n"
     end
-
   end
 
   ##
@@ -52,7 +49,6 @@ module Gem
   # not the requested version. Instead of rescuing from this class, make sure to
   # rescue from the superclass Gem::LoadError to catch all types of load errors.
   class MissingSpecVersionError < MissingSpecError
-
     attr_reader :specs
 
     def initialize(name, requirement, specs)
@@ -63,19 +59,14 @@ module Gem
     private
 
     def build_message
-      if name == "bundler" && message = Gem::BundlerVersionFinder.missing_version_message
-        return message
-      end
       names = specs.map(&:full_name)
       "Could not find '#{name}' (#{requirement}) - did find: [#{names.join ','}]\n"
     end
-
   end
 
   # Raised when there are conflicting gem specs loaded
 
   class ConflictError < LoadError
-
     ##
     # A Hash mapping conflicting specifications to the dependencies that
     # caused the conflict
@@ -100,7 +91,6 @@ module Gem
 
       super("Unable to activate #{target.full_name}, because #{reason}")
     end
-
   end
 
   class ErrorReason; end
@@ -112,7 +102,6 @@ module Gem
   # in figuring out why a gem couldn't be installed.
   #
   class PlatformMismatch < ErrorReason
-
     ##
     # the name of the gem
     attr_reader :name
@@ -147,10 +136,9 @@ module Gem
       "Found %s (%s), but was for platform%s %s" %
         [@name,
          @version,
-         @platforms.size == 1 ? '' : 's',
-         @platforms.join(' ,')]
+         @platforms.size == 1 ? "" : "s",
+         @platforms.join(" ,")]
     end
-
   end
 
   ##
@@ -158,7 +146,6 @@ module Gem
   # data from a source
 
   class SourceFetchProblem < ErrorReason
-
     ##
     # Creates a new SourceFetchProblem for the given +source+ and +error+.
 
@@ -181,14 +168,12 @@ module Gem
     # An English description of the error.
 
     def wordy
-      @source.uri.password = 'REDACTED' unless @source.uri.password.nil?
-      "Unable to download data from #{@source.uri} - #{@error.message}"
+      "Unable to download data from #{Gem::Uri.redact(@source.uri)} - #{@error.message}"
     end
 
     ##
     # The "exception" alias allows you to call raise on a SourceFetchProblem.
 
     alias exception error
-
   end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/exceptions.rb
+++ ruby2.7-2.7.6/lib/rubygems/exceptions.rb
@@ -1,24 +1,42 @@
 # frozen_string_literal: true
 
-require 'rubygems/deprecate'
+require_relative "deprecate"
+require_relative "unknown_command_spell_checker"
 
 ##
 # Base exception class for RubyGems.  All exception raised by RubyGems are a
 # subclass of this one.
-class Gem::Exception < RuntimeError
+class Gem::Exception < RuntimeError; end
 
-  ##
-  #--
-  # TODO: remove in RubyGems 4, nobody sets this
+class Gem::CommandLineError < Gem::Exception; end
 
-  attr_accessor :source_exception # :nodoc:
+class Gem::UnknownCommandError < Gem::Exception
+  attr_reader :unknown_command
 
-  extend Gem::Deprecate
-  deprecate :source_exception, :none, 2018, 12
+  def initialize(unknown_command)
+    self.class.attach_correctable
 
-end
+    @unknown_command = unknown_command
+    super("Unknown command #{unknown_command}")
+  end
 
-class Gem::CommandLineError < Gem::Exception; end
+  def self.attach_correctable
+    return if defined?(@attached)
+
+    if defined?(DidYouMean::SPELL_CHECKERS) && defined?(DidYouMean::Correctable)
+      if DidYouMean.respond_to?(:correct_error)
+        DidYouMean.correct_error(Gem::UnknownCommandError, Gem::UnknownCommandSpellChecker)
+      else
+        DidYouMean::SPELL_CHECKERS["Gem::UnknownCommandError"] =
+          Gem::UnknownCommandSpellChecker
+
+        prepend DidYouMean::Correctable
+      end
+    end
+
+    @attached = true
+  end
+end
 
 class Gem::DependencyError < Gem::Exception; end
 
@@ -30,7 +48,6 @@ class Gem::DependencyRemovalException < 
 # and #conflicting_dependencies
 
 class Gem::DependencyResolutionError < Gem::DependencyError
-
   attr_reader :conflict
 
   def initialize(conflict)
@@ -43,25 +60,20 @@ class Gem::DependencyResolutionError < G
   def conflicting_dependencies
     @conflict.conflicting_dependencies
   end
-
 end
 
 ##
 # Raised when attempting to uninstall a gem that isn't in GEM_HOME.
 
 class Gem::GemNotInHomeException < Gem::Exception
-
   attr_accessor :spec
-
 end
 
 ###
 # Raised when removing a gem with the uninstall command fails
 
 class Gem::UninstallError < Gem::Exception
-
   attr_accessor :spec
-
 end
 
 class Gem::DocumentError < Gem::Exception; end
@@ -75,7 +87,6 @@ class Gem::EndOfYAMLException < Gem::Exc
 # operating on the given directory.
 
 class Gem::FilePermissionError < Gem::Exception
-
   attr_reader :directory
 
   def initialize(directory)
@@ -83,15 +94,12 @@ class Gem::FilePermissionError < Gem::Ex
 
     super "You don't have write permissions for the #{directory} directory."
   end
-
 end
 
 ##
 # Used to raise parsing and loading errors
 class Gem::FormatException < Gem::Exception
-
   attr_accessor :file_path
-
 end
 
 class Gem::GemNotFoundException < Gem::Exception; end
@@ -100,7 +108,6 @@ class Gem::GemNotFoundException < Gem::E
 # Raised by the DependencyInstaller when a specific gem cannot be found
 
 class Gem::SpecificGemNotFoundException < Gem::GemNotFoundException
-
   ##
   # Creates a new SpecificGemNotFoundException for a gem with the given +name+
   # and +version+.  Any +errors+ encountered when attempting to find the gem
@@ -128,7 +135,6 @@ class Gem::SpecificGemNotFoundException 
   # Errors encountered attempting to find the gem.
 
   attr_reader :errors
-
 end
 
 ##
@@ -136,7 +142,6 @@ end
 # inability to find a valid possible spec for a request.
 
 class Gem::ImpossibleDependenciesError < Gem::Exception
-
   attr_reader :conflicts
   attr_reader :request
 
@@ -149,7 +154,7 @@ class Gem::ImpossibleDependenciesError <
 
   def build_message # :nodoc:
     requester  = @request.requester
-    requester  = requester ? requester.spec.full_name : 'The user'
+    requester  = requester ? requester.spec.full_name : "The user"
     dependency = @request.dependency
 
     message = "#{requester} requires #{dependency} but it conflicted:\n".dup
@@ -164,17 +169,14 @@ class Gem::ImpossibleDependenciesError <
   def dependency
     @request.dependency
   end
-
 end
 
 class Gem::InstallError < Gem::Exception; end
 class Gem::RuntimeRequirementNotMetError < Gem::InstallError
-
   attr_accessor :suggestion
   def message
     [suggestion, super].compact.join("\n\t")
   end
-
 end
 
 ##
@@ -216,7 +218,6 @@ class Gem::VerificationError < Gem::Exce
 # exit_code
 
 class Gem::SystemExitException < SystemExit
-
   ##
   # The exit code for the process
 
@@ -228,9 +229,8 @@ class Gem::SystemExitException < SystemE
   def initialize(exit_code)
     @exit_code = exit_code
 
-    super "Exiting RubyGems with exit_code #{exit_code}"
+    super exit_code, "Exiting RubyGems with exit_code #{exit_code}"
   end
-
 end
 
 ##
@@ -238,7 +238,6 @@ end
 # there is no spec.
 
 class Gem::UnsatisfiableDependencyError < Gem::DependencyError
-
   ##
   # The unsatisfiable dependency.  This is a
   # Gem::Resolver::DependencyRequest, not a Gem::Dependency
@@ -255,8 +254,8 @@ class Gem::UnsatisfiableDependencyError 
   # Gem::Resolver::DependencyRequest +dep+
 
   def initialize(dep, platform_mismatch=nil)
-    if platform_mismatch and !platform_mismatch.empty?
-      plats = platform_mismatch.map { |x| x.platform.to_s }.sort.uniq
+    if platform_mismatch && !platform_mismatch.empty?
+      plats = platform_mismatch.map {|x| x.platform.to_s }.sort.uniq
       super "Unable to resolve dependency: No match for '#{dep}' on this platform. Found: #{plats.join(', ')}"
     else
       if dep.explicit?
@@ -283,10 +282,10 @@ class Gem::UnsatisfiableDependencyError 
   def version
     @dependency.requirement
   end
-
 end
 
 ##
 # Backwards compatible typo'd exception class for early RubyGems 2.0.x
 
 Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError # :nodoc:
+Gem.deprecate_constant :UnsatisfiableDepedencyError
--- ruby2.7-2.7.6.orig/lib/rubygems/ext.rb
+++ ruby2.7-2.7.6/lib/rubygems/ext.rb
@@ -10,9 +10,10 @@
 
 module Gem::Ext; end
 
-require 'rubygems/ext/build_error'
-require 'rubygems/ext/builder'
-require 'rubygems/ext/configure_builder'
-require 'rubygems/ext/ext_conf_builder'
-require 'rubygems/ext/rake_builder'
-require 'rubygems/ext/cmake_builder'
+require_relative "ext/build_error"
+require_relative "ext/builder"
+require_relative "ext/configure_builder"
+require_relative "ext/ext_conf_builder"
+require_relative "ext/rake_builder"
+require_relative "ext/cmake_builder"
+require_relative "ext/cargo_builder"
--- ruby2.7-2.7.6.orig/lib/rubygems/ext/build_error.rb
+++ ruby2.7-2.7.6/lib/rubygems/ext/build_error.rb
@@ -2,5 +2,7 @@
 ##
 # Raised when there is an error while building extensions.
 
+require_relative "../exceptions"
+
 class Gem::Ext::BuildError < Gem::InstallError
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/ext/builder.rb
+++ ruby2.7-2.7.6/lib/rubygems/ext/builder.rb
@@ -5,20 +5,11 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/user_interaction'
+require_relative "../user_interaction"
 
 class Gem::Ext::Builder
-
   include Gem::UserInteraction
 
-  ##
-  # The builder shells-out to run various commands after changing the
-  # directory.  This means multiple installations cannot be allowed to build
-  # extensions in parallel as they may change each other's directories leading
-  # to broken extensions or failed installations.
-
-  CHDIR_MUTEX = Mutex.new # :nodoc:
-
   attr_accessor :build_args # :nodoc:
 
   def self.class_name
@@ -26,60 +17,72 @@ class Gem::Ext::Builder
     $1.downcase
   end
 
-  def self.make(dest_path, results)
-    unless File.exist? 'Makefile'
-      raise Gem::InstallError, 'Makefile not found'
+  def self.make(dest_path, results, make_dir = Dir.pwd, sitedir = nil)
+    unless File.exist? File.join(make_dir, "Makefile")
+      raise Gem::InstallError, "Makefile not found"
     end
 
     # try to find make program from Ruby configure arguments first
-    RbConfig::CONFIG['configure_args'] =~ /with-make-prog\=(\w+)/
-    make_program = ENV['MAKE'] || ENV['make'] || $1
-    unless make_program
-      make_program = (/mswin/ =~ RUBY_PLATFORM) ? 'nmake' : 'make'
+    RbConfig::CONFIG["configure_args"] =~ /with-make-prog\=(\w+)/
+    make_program_name = ENV["MAKE"] || ENV["make"] || $1
+    unless make_program_name
+      make_program_name = (/mswin/ =~ RUBY_PLATFORM) ? "nmake" : "make"
     end
+    make_program = Shellwords.split(make_program_name)
+
+    # The installation of the bundled gems is failed when DESTDIR is empty in mswin platform.
+    destdir = (/\bnmake/i !~ make_program_name || ENV["DESTDIR"] && ENV["DESTDIR"] != "") ? "DESTDIR=%s" % ENV["DESTDIR"] : ""
 
-    destdir = '"DESTDIR=%s"' % ENV['DESTDIR']
+    env = [destdir]
 
-    ['clean', '', 'install'].each do |target|
+    if sitedir
+      env << "sitearchdir=%s" % sitedir
+      env << "sitelibdir=%s" % sitedir
+    end
+
+    ["clean", "", "install"].each do |target|
       # Pass DESTDIR via command line to override what's in MAKEFLAGS
       cmd = [
-        make_program,
-        destdir,
-        target
-      ].join(' ').rstrip
+        *make_program,
+        *env,
+        target,
+      ].reject(&:empty?)
       begin
-        run(cmd, results, "make #{target}".rstrip)
+        run(cmd, results, "make #{target}".rstrip, make_dir)
       rescue Gem::InstallError
-        raise unless target == 'clean' # ignore clean failure
+        raise unless target == "clean" # ignore clean failure
       end
     end
   end
 
-  def self.run(command, results, command_name = nil)
+  def self.run(command, results, command_name = nil, dir = Dir.pwd, env = {})
     verbose = Gem.configuration.really_verbose
 
     begin
-      rubygems_gemdeps, ENV['RUBYGEMS_GEMDEPS'] = ENV['RUBYGEMS_GEMDEPS'], nil
+      rubygems_gemdeps, ENV["RUBYGEMS_GEMDEPS"] = ENV["RUBYGEMS_GEMDEPS"], nil
       if verbose
-        puts("current directory: #{Dir.pwd}")
+        puts("current directory: #{dir}")
         p(command)
       end
-      results << "current directory: #{Dir.pwd}"
-      results << (command.respond_to?(:shelljoin) ? command.shelljoin : command)
+      results << "current directory: #{dir}"
+      require "shellwords"
+      results << command.shelljoin
 
       require "open3"
       # Set $SOURCE_DATE_EPOCH for the subprocess.
-      env = {'SOURCE_DATE_EPOCH' => Gem.source_date_epoch_string}
-      output, status = Open3.capture2e(env, *command)
+      build_env = { "SOURCE_DATE_EPOCH" => Gem.source_date_epoch_string }.merge(env)
+      output, status = begin
+                         Open3.capture2e(build_env, *command, :chdir => dir)
+                       rescue => error
+                         raise Gem::InstallError, "#{command_name || class_name} failed#{error.message}"
+                       end
       if verbose
         puts output
       else
         results << output
       end
-    rescue => error
-      raise Gem::InstallError, "#{command_name || class_name} failed#{error.message}"
     ensure
-      ENV['RUBYGEMS_GEMDEPS'] = rubygems_gemdeps
+      ENV["RUBYGEMS_GEMDEPS"] = rubygems_gemdeps
     end
 
     unless status.success?
@@ -127,6 +130,9 @@ class Gem::Ext::Builder
       Gem::Ext::RakeBuilder
     when /CMakeLists.txt/ then
       Gem::Ext::CmakeBuilder
+    when /Cargo.toml/ then
+      # We use the spec name here to ensure we invoke the correct init function later
+      Gem::Ext::CargoBuilder.new(@spec)
     else
       build_error("No builder for extension '#{extension}'")
     end
@@ -162,22 +168,10 @@ EOF
     begin
       FileUtils.mkdir_p dest_path
 
-      CHDIR_MUTEX.synchronize do
-        pwd = Dir.getwd
-        Dir.chdir extension_dir
-        begin
-          results = builder.build(extension, dest_path,
-                                  results, @build_args, lib_dir)
-
-          verbose { results.join("\n") }
-        ensure
-          begin
-            Dir.chdir pwd
-          rescue SystemCallError
-            Dir.chdir dest_path
-          end
-        end
-      end
+      results = builder.build(extension, dest_path,
+                              results, @build_args, lib_dir, extension_dir)
+
+      verbose { results.join("\n") }
 
       write_gem_make_out results.join "\n"
     rescue => e
@@ -202,6 +196,7 @@ EOF
 
     dest_path = @spec.extension_dir
 
+    require "fileutils"
     FileUtils.rm_f @spec.gem_build_complete_path
 
     @spec.extensions.each do |extension|
@@ -217,15 +212,14 @@ EOF
   # Writes +output+ to gem_make.out in the extension install directory.
 
   def write_gem_make_out(output) # :nodoc:
-    destination = File.join @spec.extension_dir, 'gem_make.out'
+    destination = File.join @spec.extension_dir, "gem_make.out"
 
     FileUtils.mkdir_p @spec.extension_dir
 
-    File.open destination, 'wb' do |io|
+    File.open destination, "wb" do |io|
       io.puts output
     end
 
     destination
   end
-
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/ext/cargo_builder.rb
@@ -0,0 +1,321 @@
+# frozen_string_literal: true
+
+# This class is used by rubygems to build Rust extensions. It is a thin-wrapper
+# over the `cargo rustc` command which takes care of building Rust code in a way
+# that Ruby can use.
+class Gem::Ext::CargoBuilder < Gem::Ext::Builder
+  attr_accessor :spec, :runner, :profile
+
+  def initialize(spec)
+    require_relative "../command"
+    require_relative "cargo_builder/link_flag_converter"
+
+    @spec = spec
+    @runner = self.class.method(:run)
+    @profile = :release
+  end
+
+  def build(_extension, dest_path, results, args = [], lib_dir = nil, cargo_dir = Dir.pwd)
+    require "fileutils"
+    require "shellwords"
+
+    build_crate(dest_path, results, args, cargo_dir)
+    validate_cargo_build!(dest_path)
+    rename_cdylib_for_ruby_compatibility(dest_path)
+    finalize_directory(dest_path, lib_dir, cargo_dir)
+    results
+  end
+
+  def build_crate(dest_path, results, args, cargo_dir)
+    env = build_env
+    cmd = cargo_command(cargo_dir, dest_path, args)
+    runner.call cmd, results, "cargo", cargo_dir, env
+
+    results
+  end
+
+  def build_env
+    build_env = rb_config_env
+    build_env["RUBY_STATIC"] = "true" if ruby_static? && ENV.key?("RUBY_STATIC")
+    build_env
+  end
+
+  def cargo_command(cargo_dir, dest_path, args = [])
+    manifest = File.join(cargo_dir, "Cargo.toml")
+    cargo = ENV.fetch("CARGO", "cargo")
+
+    cmd = []
+    cmd += [cargo, "rustc"]
+    cmd += ["--target", ENV["CARGO_BUILD_TARGET"]] if ENV["CARGO_BUILD_TARGET"]
+    cmd += ["--target-dir", dest_path]
+    cmd += ["--manifest-path", manifest]
+    cmd += ["--lib"]
+    cmd += ["--profile", profile.to_s]
+    cmd += ["--locked"] if profile == :release
+    cmd += Gem::Command.build_args
+    cmd += args
+    cmd += ["--"]
+    cmd += [*cargo_rustc_args(dest_path)]
+    cmd
+  end
+
+  private
+
+  def rb_config_env
+    result = {}
+    RbConfig::CONFIG.each {|k, v| result["RBCONFIG_#{k}"] = v }
+    result
+  end
+
+  def cargo_rustc_args(dest_dir)
+    [
+      *linker_args,
+      *mkmf_libpath,
+      *rustc_dynamic_linker_flags(dest_dir),
+      *rustc_lib_flags(dest_dir),
+      *platform_specific_rustc_args(dest_dir),
+      *debug_flags,
+    ]
+  end
+
+  def platform_specific_rustc_args(dest_dir, flags = [])
+    if mingw_target?
+      # On mingw platforms, mkmf adds libruby to the linker flags
+      flags += libruby_args(dest_dir)
+
+      # Make sure ALSR is used on mingw
+      # see https://github.com/rust-lang/rust/pull/75406/files
+      flags += ["-C", "link-arg=-Wl,--dynamicbase"]
+      flags += ["-C", "link-arg=-Wl,--disable-auto-image-base"]
+
+      # If the gem is installed on a host with build tools installed, but is
+      # run on one that isn't the missing libraries will cause the extension
+      # to fail on start.
+      flags += ["-C", "link-arg=-static-libgcc"]
+    end
+
+    flags
+  end
+
+  # We want to use the same linker that Ruby uses, so that the linker flags from
+  # mkmf work properly.
+  def linker_args
+    # Have to handle CC="cl /nologo" on mswin
+    cc_flag = Shellwords.split(makefile_config("CC"))
+    linker = cc_flag.shift
+    link_args = cc_flag.flat_map {|a| ["-C", "link-arg=#{a}"] }
+
+    ["-C", "linker=#{linker}", *link_args]
+  end
+
+  def libruby_args(dest_dir)
+    libs = makefile_config(ruby_static? ? "LIBRUBYARG_STATIC" : "LIBRUBYARG_SHARED")
+    raw_libs = Shellwords.split(libs)
+    raw_libs.flat_map {|l| ldflag_to_link_modifier(l) }
+  end
+
+  def ruby_static?
+    return true if %w[1 true].include?(ENV["RUBY_STATIC"])
+
+    makefile_config("ENABLE_SHARED") == "no"
+  end
+
+  # Ruby expects the dylib to follow a file name convention for loading
+  def rename_cdylib_for_ruby_compatibility(dest_path)
+    new_path = final_extension_path(dest_path)
+    FileUtils.cp(cargo_dylib_path(dest_path), new_path)
+    new_path
+  end
+
+  def validate_cargo_build!(dir)
+    dylib_path = cargo_dylib_path(dir)
+
+    raise DylibNotFoundError, dir unless File.exist?(dylib_path)
+
+    dylib_path
+  end
+
+  def final_extension_path(dest_path)
+    dylib_path = cargo_dylib_path(dest_path)
+    dlext_name = "#{spec.name}.#{makefile_config("DLEXT")}"
+    dylib_path.gsub(File.basename(dylib_path), dlext_name)
+  end
+
+  def cargo_dylib_path(dest_path)
+    prefix = so_ext == "dll" ? "" : "lib"
+    path_parts = [dest_path]
+    path_parts << ENV["CARGO_BUILD_TARGET"] if ENV["CARGO_BUILD_TARGET"]
+    path_parts += [profile_target_directory, "#{prefix}#{cargo_crate_name}.#{so_ext}"]
+    File.join(*path_parts)
+  end
+
+  def cargo_crate_name
+    spec.metadata.fetch("cargo_crate_name", spec.name).tr("-", "_")
+  end
+
+  def rustc_dynamic_linker_flags(dest_dir)
+    split_flags("DLDFLAGS")
+      .map {|arg| maybe_resolve_ldflag_variable(arg, dest_dir) }
+      .compact
+      .flat_map {|arg| ldflag_to_link_modifier(arg) }
+  end
+
+  def rustc_lib_flags(dest_dir)
+    split_flags("LIBS").flat_map {|arg| ldflag_to_link_modifier(arg) }
+  end
+
+  def split_flags(var)
+    Shellwords.split(RbConfig::CONFIG.fetch(var, ""))
+  end
+
+  def ldflag_to_link_modifier(arg)
+    LinkFlagConverter.convert(arg)
+  end
+
+  def msvc_target?
+    makefile_config("target_os").include?("msvc")
+  end
+
+  def darwin_target?
+    makefile_config("target_os").include?("darwin")
+  end
+
+  def mingw_target?
+    makefile_config("target_os").include?("mingw")
+  end
+
+  def win_target?
+    target_platform = RbConfig::CONFIG["target_os"]
+    !!Gem::WIN_PATTERNS.find {|r| target_platform =~ r }
+  end
+
+  # Interpolate substition vars in the arg (i.e. $(DEFFILE))
+  def maybe_resolve_ldflag_variable(input_arg, dest_dir)
+    var_matches = input_arg.match(/\$\((\w+)\)/)
+
+    return input_arg unless var_matches
+
+    var_name = var_matches[1]
+
+    return input_arg if var_name.nil? || var_name.chomp.empty?
+
+    case var_name
+    # On windows, it is assumed that mkmf has setup an exports file for the
+    # extension, so we have to to create one ourselves.
+    when "DEFFILE"
+      write_deffile(dest_dir)
+    else
+      RbConfig::CONFIG[var_name]
+    end
+  end
+
+  def write_deffile(dest_dir)
+    deffile_path = File.join(dest_dir, "#{spec.name}-#{RbConfig::CONFIG["arch"]}.def")
+    export_prefix = makefile_config("EXPORT_PREFIX") || ""
+
+    File.open(deffile_path, "w") do |f|
+      f.puts "EXPORTS"
+      f.puts "#{export_prefix.strip}Init_#{spec.name}"
+    end
+
+    deffile_path
+  end
+
+  # We have to basically reimplement RbConfig::CONFIG['SOEXT'] here to support
+  # Ruby < 2.5
+  #
+  # @see https://github.com/ruby/ruby/blob/c87c027f18c005460746a74c07cd80ee355b16e4/configure.ac#L3185
+  def so_ext
+    return RbConfig::CONFIG["SOEXT"] if RbConfig::CONFIG.key?("SOEXT")
+
+    if win_target?
+      "dll"
+    elsif darwin_target?
+      "dylib"
+    else
+      "so"
+    end
+  end
+
+  # Corresponds to $(LIBPATH) in mkmf
+  def mkmf_libpath
+    ["-L", "native=#{makefile_config("libdir")}"]
+  end
+
+  def makefile_config(var_name)
+    val = RbConfig::MAKEFILE_CONFIG[var_name]
+
+    return unless val
+
+    RbConfig.expand(val.dup)
+  end
+
+  # Good balance between binary size and debugability
+  def debug_flags
+    return [] if profile == :dev
+
+    ["-C", "debuginfo=1"]
+  end
+
+  # Copied from ExtConfBuilder
+  def finalize_directory(dest_path, lib_dir, extension_dir)
+    require "fileutils"
+    require "tempfile"
+
+    ext_path = final_extension_path(dest_path)
+
+    begin
+      tmp_dest = Dir.mktmpdir(".gem.", extension_dir)
+
+      # Some versions of `mktmpdir` return absolute paths, which will break make
+      # if the paths contain spaces.
+      #
+      # As such, we convert to a relative path.
+      tmp_dest_relative = get_relative_path(tmp_dest.clone, extension_dir)
+
+      full_tmp_dest = File.join(extension_dir, tmp_dest_relative)
+
+      # TODO: remove in RubyGems 4
+      if Gem.install_extension_in_lib && lib_dir
+        FileUtils.mkdir_p lib_dir
+        FileUtils.cp_r ext_path, lib_dir, remove_destination: true
+      end
+
+      FileUtils::Entry_.new(full_tmp_dest).traverse do |ent|
+        destent = ent.class.new(dest_path, ent.rel)
+        destent.exist? || FileUtils.mv(ent.path, destent.path)
+      end
+    ensure
+      FileUtils.rm_rf tmp_dest if tmp_dest
+    end
+  end
+
+  def get_relative_path(path, base)
+    path[0..base.length - 1] = "." if path.start_with?(base)
+    path
+  end
+
+  def profile_target_directory
+    case profile
+    when :release then "release"
+    when :dev     then "debug"
+    else          raise "unknown target directory for profile: #{profile}"
+    end
+  end
+
+  # Error raised when no cdylib artifact was created
+  class DylibNotFoundError < StandardError
+    def initialize(dir)
+      files = Dir.glob(File.join(dir, "**", "*")).map {|f| "- #{f}" }.join "\n"
+
+      super <<~MSG
+        Dynamic library not found for Rust extension (in #{dir})
+
+        Make sure you set "crate-type" in Cargo.toml to "cdylib"
+
+        Found files:
+        #{files}
+      MSG
+    end
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/ext/cargo_builder/link_flag_converter.rb
@@ -0,0 +1,23 @@
+# frozen_string_literal: true
+
+class Gem::Ext::CargoBuilder < Gem::Ext::Builder
+  # Converts Ruby link flags into something cargo understands
+  class LinkFlagConverter
+    def self.convert(arg)
+      case arg.chomp
+      when /^-L\s*(.+)$/
+        ["-L", "native=#{$1}"]
+      when /^--library=(\w+\S+)$/, /^-l\s*(\w+\S+)$/
+        ["-l", $1]
+      when /^-l\s*:lib(\S+).a$/
+        ["-l", "static=#{$1}"]
+      when /^-l\s*:lib(\S+).(so|dylib|dll)$/
+        ["-l", "dylib=#{$1}"]
+      when /^-F\s*(.*)$/
+        ["-l", "framework=#{$1}"]
+      else
+        ["-C", "link_arg=#{arg}"]
+      end
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/lib/rubygems/ext/cmake_builder.rb
+++ ruby2.7-2.7.6/lib/rubygems/ext/cmake_builder.rb
@@ -1,19 +1,16 @@
 # frozen_string_literal: true
-require 'rubygems/command'
 
 class Gem::Ext::CmakeBuilder < Gem::Ext::Builder
+  def self.build(extension, dest_path, results, args=[], lib_dir=nil, cmake_dir=Dir.pwd)
+    unless File.exist?(File.join(cmake_dir, "Makefile"))
+      require_relative "../command"
+      cmd = ["cmake", ".", "-DCMAKE_INSTALL_PREFIX=#{dest_path}", *Gem::Command.build_args]
 
-  def self.build(extension, dest_path, results, args=[], lib_dir=nil)
-    unless File.exist?('Makefile')
-      cmd = "cmake . -DCMAKE_INSTALL_PREFIX=#{dest_path}"
-      cmd << " #{Gem::Command.build_args.join ' '}" unless Gem::Command.build_args.empty?
-
-      run cmd, results
+      run cmd, results, class_name, cmake_dir
     end
 
-    make dest_path, results
+    make dest_path, results, cmake_dir
 
     results
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/ext/configure_builder.rb
+++ ruby2.7-2.7.6/lib/rubygems/ext/configure_builder.rb
@@ -6,18 +6,15 @@
 #++
 
 class Gem::Ext::ConfigureBuilder < Gem::Ext::Builder
+  def self.build(extension, dest_path, results, args=[], lib_dir=nil, configure_dir=Dir.pwd)
+    unless File.exist?(File.join(configure_dir, "Makefile"))
+      cmd = ["sh", "./configure", "--prefix=#{dest_path}", *args]
 
-  def self.build(extension, dest_path, results, args=[], lib_dir=nil)
-    unless File.exist?('Makefile')
-      cmd = "sh ./configure --prefix=#{dest_path}"
-      cmd << " #{args.join ' '}" unless args.empty?
-
-      run cmd, results
+      run cmd, results, class_name, configure_dir
     end
 
-    make dest_path, results
+    make dest_path, results, configure_dir
 
     results
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/ext/ext_conf_builder.rb
+++ ruby2.7-2.7.6/lib/rubygems/ext/ext_conf_builder.rb
@@ -5,81 +5,58 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'fileutils'
-require 'tempfile'
-require 'shellwords'
-
 class Gem::Ext::ExtConfBuilder < Gem::Ext::Builder
+  def self.build(extension, dest_path, results, args=[], lib_dir=nil, extension_dir=Dir.pwd)
+    require "fileutils"
+    require "tempfile"
 
-  FileEntry = FileUtils::Entry_ # :nodoc:
-
-  def self.build(extension, dest_path, results, args=[], lib_dir=nil)
-    tmp_dest = Dir.mktmpdir(".gem.", ".")
+    tmp_dest = Dir.mktmpdir(".gem.", extension_dir)
 
     # Some versions of `mktmpdir` return absolute paths, which will break make
-    # if the paths contain spaces. However, on Ruby 1.9.x on Windows, relative
-    # paths cause all C extension builds to fail.
+    # if the paths contain spaces.
     #
-    # As such, we convert to a relative path unless we are using Ruby 1.9.x on
-    # Windows. This means that when using Ruby 1.9.x on Windows, paths with
-    # spaces do not work.
-    #
-    # Details: https://github.com/rubygems/rubygems/issues/977#issuecomment-171544940
-    tmp_dest = get_relative_path(tmp_dest)
+    # As such, we convert to a relative path.
+    tmp_dest_relative = get_relative_path(tmp_dest.clone, extension_dir)
 
-    Tempfile.open %w"siteconf .rb", "." do |siteconf|
-      siteconf.puts "require 'rbconfig'"
-      siteconf.puts "dest_path = #{tmp_dest.dump}"
-      %w[sitearchdir sitelibdir].each do |dir|
-        siteconf.puts "RbConfig::MAKEFILE_CONFIG['#{dir}'] = dest_path"
-        siteconf.puts "RbConfig::CONFIG['#{dir}'] = dest_path"
-      end
+    destdir = ENV["DESTDIR"]
 
-      siteconf.close
-
-      destdir = ENV["DESTDIR"]
-
-      begin
-        cmd = Gem.ruby.shellsplit << "-I" << File.expand_path("../../..", __FILE__) <<
-              "-r" << get_relative_path(siteconf.path) << File.basename(extension)
-        cmd.push(*args)
-
-        begin
-          run(cmd, results) do |s, r|
-            if File.exist? 'mkmf.log'
-              unless s.success?
-                r << "To see why this extension failed to compile, please check" \
-                  " the mkmf.log which can be found here:\n"
-                r << "  " + File.join(dest_path, 'mkmf.log') + "\n"
-              end
-              FileUtils.mv 'mkmf.log', dest_path
-            end
+    begin
+      require "shellwords"
+      cmd = Gem.ruby.shellsplit << "-I" << File.expand_path("../..", __dir__) << File.basename(extension)
+      cmd.push(*args)
+
+      run(cmd, results, class_name, extension_dir) do |s, r|
+        mkmf_log = File.join(extension_dir, "mkmf.log")
+        if File.exist? mkmf_log
+          unless s.success?
+            r << "To see why this extension failed to compile, please check" \
+              " the mkmf.log which can be found here:\n"
+            r << "  " + File.join(dest_path, "mkmf.log") + "\n"
           end
-          siteconf.unlink
+          FileUtils.mv mkmf_log, dest_path
         end
+      end
 
-        ENV["DESTDIR"] = nil
+      ENV["DESTDIR"] = nil
 
-        make dest_path, results
+      make dest_path, results, extension_dir, tmp_dest_relative
 
-        if tmp_dest
-          # TODO remove in RubyGems 3
-          if Gem.install_extension_in_lib and lib_dir
-            FileUtils.mkdir_p lib_dir
-            entries = Dir.entries(tmp_dest) - %w[. ..]
-            entries = entries.map { |entry| File.join tmp_dest, entry }
-            FileUtils.cp_r entries, lib_dir, :remove_destination => true
-          end
+      full_tmp_dest = File.join(extension_dir, tmp_dest_relative)
 
-          FileEntry.new(tmp_dest).traverse do |ent|
-            destent = ent.class.new(dest_path, ent.rel)
-            destent.exist? or FileUtils.mv(ent.path, destent.path)
-          end
-        end
-      ensure
-        ENV["DESTDIR"] = destdir
-        siteconf.close!
+      # TODO remove in RubyGems 4
+      if Gem.install_extension_in_lib && lib_dir
+        FileUtils.mkdir_p lib_dir
+        entries = Dir.entries(full_tmp_dest) - %w[. ..]
+        entries = entries.map {|entry| File.join full_tmp_dest, entry }
+        FileUtils.cp_r entries, lib_dir, :remove_destination => true
       end
+
+      FileUtils::Entry_.new(full_tmp_dest).traverse do |ent|
+        destent = ent.class.new(dest_path, ent.rel)
+        destent.exist? || FileUtils.mv(ent.path, destent.path)
+      end
+    ensure
+      ENV["DESTDIR"] = destdir
     end
 
     results
@@ -89,9 +66,8 @@ class Gem::Ext::ExtConfBuilder < Gem::Ex
 
   private
 
-  def self.get_relative_path(path)
-    path[0..Dir.pwd.length - 1] = '.' if path.start_with?(Dir.pwd)
+  def self.get_relative_path(path, base)
+    path[0..base.length - 1] = "." if path.start_with?(base)
     path
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/ext/rake_builder.rb
+++ ruby2.7-2.7.6/lib/rubygems/ext/rake_builder.rb
@@ -5,31 +5,28 @@
 # See LICENSE.txt for permissions.
 #++
 
-require "shellwords"
-
 class Gem::Ext::RakeBuilder < Gem::Ext::Builder
-
-  def self.build(extension, dest_path, results, args=[], lib_dir=nil)
+  def self.build(extension, dest_path, results, args=[], lib_dir=nil, extension_dir=Dir.pwd)
     if File.basename(extension) =~ /mkrf_conf/i
-      run([Gem.ruby, File.basename(extension), *args], results)
+      run([Gem.ruby, File.basename(extension), *args], results, class_name, extension_dir)
     end
 
-    rake = ENV['rake']
+    rake = ENV["rake"]
 
     if rake
+      require "shellwords"
       rake = rake.shellsplit
     else
       begin
-        rake = [Gem.ruby, "-I#{File.expand_path("..", __dir__)}", "-rrubygems", Gem.bin_path('rake', 'rake')]
+        rake = [Gem.ruby, "-I#{File.expand_path("../..", __dir__)}", "-rrubygems", Gem.bin_path("rake", "rake")]
       rescue Gem::Exception
-        rake = [Gem.default_exec_format % 'rake']
+        rake = [Gem.default_exec_format % "rake"]
       end
     end
 
     rake_args = ["RUBYARCHDIR=#{dest_path}", "RUBYLIBDIR=#{dest_path}", *args]
-    run(rake + rake_args, results)
+    run(rake + rake_args, results, class_name, extension_dir)
 
     results
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/gem_runner.rb
+++ ruby2.7-2.7.6/lib/rubygems/gem_runner.rb
@@ -5,15 +5,9 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems'
-require 'rubygems/command_manager'
-require 'rubygems/config_file'
-require 'rubygems/deprecate'
-
-##
-# Load additional plugins from $LOAD_PATH
-
-Gem.load_env_plugins rescue nil
+require_relative "../rubygems"
+require_relative "command_manager"
+require_relative "deprecate"
 
 ##
 # Run an instance of the gem program.
@@ -25,14 +19,9 @@ Gem.load_env_plugins rescue nil
 # classes they call directly.
 
 class Gem::GemRunner
-
-  def initialize(options={})
-    if !options.empty? && !Gem::Deprecate.skip
-      Kernel.warn "NOTE: passing options to Gem::GemRunner.new is deprecated with no replacement. It will be removed on or after 2016-10-01."
-    end
-
-    @command_manager_class = options[:command_manager] || Gem::CommandManager
-    @config_file_class = options[:config_file] || Gem::ConfigFile
+  def initialize
+    @command_manager_class = Gem::CommandManager
+    @config_file_class = Gem::ConfigFile
   end
 
   ##
@@ -43,16 +32,19 @@ class Gem::GemRunner
 
     do_configuration args
 
+    Gem.load_env_plugins rescue nil
+    Gem.load_plugins
+
     cmd = @command_manager_class.instance
 
     cmd.command_names.each do |command_name|
       config_args = Gem.configuration[command_name]
       config_args = case config_args
-                    when String
-                      config_args.split ' '
-                    else
-                      Array(config_args)
-                    end
+      when String
+        config_args.split " "
+      else
+        Array(config_args)
+      end
       Gem::Command.add_specific_extra_args command_name, config_args
     end
 
@@ -64,7 +56,7 @@ class Gem::GemRunner
   # other arguments in the list.
 
   def extract_build_args(args) # :nodoc:
-    return [] unless offset = args.index('--')
+    return [] unless offset = args.index("--")
 
     build_args = args.slice!(offset...args.length)
 
@@ -80,7 +72,4 @@ class Gem::GemRunner
     Gem.use_paths Gem.configuration[:gemhome], Gem.configuration[:gempath]
     Gem::Command.extra_args = Gem.configuration[:gem]
   end
-
 end
-
-Gem.load_plugins
--- ruby2.7-2.7.6.orig/lib/rubygems/gemcutter_utilities.rb
+++ ruby2.7-2.7.6/lib/rubygems/gemcutter_utilities.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/remote_fetcher'
-require 'rubygems/text'
+require_relative "remote_fetcher"
+require_relative "text"
 
 ##
 # Utility methods for using the RubyGems API.
@@ -8,18 +8,20 @@ require 'rubygems/text'
 module Gem::GemcutterUtilities
 
   ERROR_CODE = 1
+  API_SCOPES = %i[index_rubygems push_rubygem yank_rubygem add_owner remove_owner access_webhooks show_dashboard].freeze
 
   include Gem::Text
 
   attr_writer :host
+  attr_writer :scope
 
   ##
   # Add the --key option
 
   def add_key_option
-    add_option('-k', '--key KEYNAME', Symbol,
-               'Use the given API key',
-               'from ~/.gem/credentials') do |value,options|
+    add_option("-k", "--key KEYNAME", Symbol,
+               "Use the given API key",
+               "from #{Gem.configuration.credentials_path}") do |value,options|
       options[:key] = value
     end
   end
@@ -28,8 +30,9 @@ module Gem::GemcutterUtilities
   # Add the --otp option
 
   def add_otp_option
-    add_option('--otp CODE',
-               'Digit code for multifactor authentication') do |value, options|
+    add_option("--otp CODE",
+               "Digit code for multifactor authentication",
+               "You can also use the environment variable GEM_HOST_OTP_CODE") do |value, options|
       options[:otp] = value
     end
   end
@@ -50,6 +53,13 @@ module Gem::GemcutterUtilities
   end
 
   ##
+  # The OTP code from the command options or from the user's configuration.
+
+  def otp
+    options[:otp] || ENV["GEM_HOST_OTP_CODE"]
+  end
+
+  ##
   # The host to connect to either from the RUBYGEMS_HOST environment variable
   # or from the user's configuration
 
@@ -59,9 +69,9 @@ module Gem::GemcutterUtilities
 
     @host ||=
       begin
-        env_rubygems_host = ENV['RUBYGEMS_HOST']
+        env_rubygems_host = ENV["RUBYGEMS_HOST"]
         env_rubygems_host = nil if
-          env_rubygems_host and env_rubygems_host.empty?
+          env_rubygems_host && env_rubygems_host.empty?
 
         env_rubygems_host || configured_host
       end
@@ -72,8 +82,8 @@ module Gem::GemcutterUtilities
   #
   # If +allowed_push_host+ metadata is present, then it will only allow that host.
 
-  def rubygems_api_request(method, path, host = nil, allowed_push_host = nil, &block)
-    require 'net/http'
+  def rubygems_api_request(method, path, host = nil, allowed_push_host = nil, scope: nil, &block)
+    require "net/http"
 
     self.host = host if host
     unless self.host
@@ -92,39 +102,56 @@ module Gem::GemcutterUtilities
     end
 
     uri = URI.parse "#{self.host}/#{path}"
+    response = request_with_otp(method, uri, &block)
 
-    request_method = Net::HTTP.const_get method.to_s.capitalize
-    response = Gem::RemoteFetcher.fetcher.request(uri, request_method, &block)
-    return response unless mfa_unauthorized?(response)
+    if mfa_unauthorized?(response)
+      ask_otp
+      response = request_with_otp(method, uri, &block)
+    end
 
-    Gem::RemoteFetcher.fetcher.request(uri, request_method) do |req|
-      req.add_field "OTP", get_otp
-      block.call(req)
+    if api_key_forbidden?(response)
+      update_scope(scope)
+      request_with_otp(method, uri, &block)
+    else
+      response
     end
   end
 
   def mfa_unauthorized?(response)
-    response.kind_of?(Net::HTTPUnauthorized) && response.body.start_with?('You have enabled multifactor authentication')
+    response.kind_of?(Net::HTTPUnauthorized) && response.body.start_with?("You have enabled multifactor authentication")
   end
 
-  def get_otp
-    say 'You have enabled multi-factor authentication. Please enter OTP code.'
-    ask 'Code: '
+  def update_scope(scope)
+    sign_in_host        = self.host
+    pretty_host         = pretty_host(sign_in_host)
+    update_scope_params = { scope => true }
+
+    say "The existing key doesn't have access of #{scope} on #{pretty_host}. Please sign in to update access."
+
+    email    = ask "   Email: "
+    password = ask_for_password "Password: "
+
+    response = rubygems_api_request(:put, "api/v1/api_key",
+                                    sign_in_host, scope: scope) do |request|
+      request.basic_auth email, password
+      request["OTP"] = otp if otp
+      request.body = URI.encode_www_form({ :api_key => api_key }.merge(update_scope_params))
+    end
+
+    with_response response do |resp|
+      say "Added #{scope} scope to the existing API key"
+    end
   end
 
   ##
   # Signs in with the RubyGems API at +sign_in_host+ and sets the rubygems API
   # key.
 
-  def sign_in(sign_in_host = nil)
+  def sign_in(sign_in_host = nil, scope: nil)
     sign_in_host ||= self.host
     return if api_key
 
-    pretty_host = if Gem::DEFAULT_HOST == sign_in_host
-                    'RubyGems.org'
-                  else
-                    sign_in_host
-                  end
+    pretty_host = pretty_host(sign_in_host)
 
     say "Enter your #{pretty_host} credentials."
     say "Don't have an account yet? " +
@@ -134,14 +161,24 @@ module Gem::GemcutterUtilities
     password = ask_for_password "Password: "
     say "\n"
 
-    response = rubygems_api_request(:get, "api/v1/api_key",
-                                    sign_in_host) do |request|
+    key_name     = get_key_name(scope)
+    scope_params = get_scope_params(scope)
+    profile      = get_user_profile(email, password)
+    mfa_params   = get_mfa_params(profile)
+    all_params   = scope_params.merge(mfa_params)
+    warning      = profile["warning"]
+
+    say "#{warning}\n" if warning
+
+    response = rubygems_api_request(:post, "api/v1/api_key",
+                                    sign_in_host, scope: scope) do |request|
       request.basic_auth email, password
-      request.add_field "OTP", options[:otp] if options[:otp]
+      request["OTP"] = otp if otp
+      request.body = URI.encode_www_form({ name: key_name }.merge(all_params))
     end
 
     with_response response do |resp|
-      say "Signed in."
+      say "Signed in with API key: #{key_name}."
       set_api_key host, resp.body
     end
   end
@@ -188,11 +225,95 @@ module Gem::GemcutterUtilities
   # +response+ text and no otp provided by options.
 
   def set_api_key(host, key)
-    if host == Gem::DEFAULT_HOST
+    if default_host?
       Gem.configuration.rubygems_api_key = key
     else
       Gem.configuration.set_api_key host, key
     end
   end
 
+  private
+
+  def request_with_otp(method, uri, &block)
+    request_method = Net::HTTP.const_get method.to_s.capitalize
+
+    Gem::RemoteFetcher.fetcher.request(uri, request_method) do |req|
+      req["OTP"] = otp if otp
+      block.call(req)
+    end
+  end
+
+  def ask_otp
+    say "You have enabled multi-factor authentication. Please enter OTP code."
+    options[:otp] = ask "Code: "
+  end
+
+  def pretty_host(host)
+    if default_host?
+      "RubyGems.org"
+    else
+      host
+    end
+  end
+
+  def get_scope_params(scope)
+    scope_params = {}
+
+    if scope
+      scope_params = { scope => true }
+    else
+      say "Please select scopes you want to enable for the API key (y/n)"
+      API_SCOPES.each do |scope|
+        selected = ask_yes_no("#{scope}", false)
+        scope_params[scope] = true if selected
+      end
+      say "\n"
+    end
+
+    scope_params
+  end
+
+  def default_host?
+    self.host == Gem::DEFAULT_HOST
+  end
+
+  def get_user_profile(email, password)
+    return {} unless default_host?
+
+    response = rubygems_api_request(:get, "api/v1/profile/me.yaml") do |request|
+      request.basic_auth email, password
+    end
+
+    with_response response do |resp|
+      Gem::SafeYAML.load clean_text(resp.body)
+    end
+  end
+
+  def get_mfa_params(profile)
+    mfa_level = profile["mfa"]
+    params = {}
+    if mfa_level == "ui_only" || mfa_level == "ui_and_gem_signin"
+      selected = ask_yes_no("Would you like to enable MFA for this key? (strongly recommended)")
+      params["mfa"] = true if selected
+    end
+    params
+  end
+
+  def get_key_name(scope)
+    hostname = Socket.gethostname || "unknown-host"
+    user = ENV["USER"] || ENV["USERNAME"] || "unknown-user"
+    ts = Time.now.strftime("%Y%m%d%H%M%S")
+    default_key_name = "#{hostname}-#{user}-#{ts}"
+
+    key_name = ask "API Key name [#{default_key_name}]: " unless scope
+    if key_name.nil? || key_name.empty?
+      default_key_name
+    else
+      key_name
+    end
+  end
+
+  def api_key_forbidden?(response)
+    response.kind_of?(Net::HTTPForbidden) && response.body.start_with?("The API key doesn't have access")
+  end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/indexer.rb
+++ ruby2.7-2.7.6/lib/rubygems/indexer.rb
@@ -1,27 +1,12 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/package'
-require 'time'
-require 'tmpdir'
-
-rescue_exceptions = [LoadError]
-begin
-  require 'bundler/errors'
-rescue LoadError # this rubygems + old ruby
-else # this rubygems + ruby trunk with bundler
-  rescue_exceptions << Bundler::GemfileNotFound
-end
-begin
-  gem 'builder'
-  require 'builder/xchar'
-rescue *rescue_exceptions
-end
+require_relative "../rubygems"
+require_relative "package"
+require "tmpdir"
 
 ##
 # Top level class for building the gem repository index.
 
 class Gem::Indexer
-
   include Gem::UserInteraction
 
   ##
@@ -58,33 +43,28 @@ class Gem::Indexer
   # Create an indexer that will index the gems in +directory+.
 
   def initialize(directory, options = {})
-    require 'fileutils'
-    require 'tmpdir'
-    require 'zlib'
-
-    unless defined?(Builder::XChar)
-      raise "Gem::Indexer requires that the XML Builder library be installed:" +
-            "\n\tgem install builder"
-    end
+    require "fileutils"
+    require "tmpdir"
+    require "zlib"
 
     options = { :build_modern => true }.merge options
 
     @build_modern = options[:build_modern]
 
     @dest_directory = directory
-    @directory = Dir.mktmpdir 'gem_generate_index'
+    @directory = Dir.mktmpdir "gem_generate_index"
 
     marshal_name = "Marshal.#{Gem.marshal_version}"
 
-    @master_index = File.join @directory, 'yaml'
+    @master_index = File.join @directory, "yaml"
     @marshal_index = File.join @directory, marshal_name
 
-    @quick_dir = File.join @directory, 'quick'
+    @quick_dir = File.join @directory, "quick"
     @quick_marshal_dir = File.join @quick_dir, marshal_name
     @quick_marshal_dir_base = File.join "quick", marshal_name # FIX: UGH
 
-    @quick_index = File.join @quick_dir, 'index'
-    @latest_index = File.join @quick_dir, 'latest_index'
+    @quick_index = File.join @quick_dir, "index"
+    @latest_index = File.join @quick_dir, "latest_index"
 
     @specs_index = File.join @directory, "specs.#{Gem.marshal_version}"
     @latest_specs_index =
@@ -124,7 +104,7 @@ class Gem::Indexer
 
     files = []
 
-    Gem.time 'Generated Marshal quick index gemspecs' do
+    Gem.time "Generated Marshal quick index gemspecs" do
       specs.each do |spec|
         next if spec.default_gem?
         spec_file_name = "#{spec.original_name}.gemspec.rz"
@@ -132,7 +112,7 @@ class Gem::Indexer
 
         marshal_zipped = Gem.deflate Marshal.dump(spec)
 
-        File.open marshal_name, 'wb' do |io|
+        File.open marshal_name, "wb" do |io|
           io.write marshal_zipped
         end
 
@@ -156,7 +136,7 @@ class Gem::Indexer
     say "Generating #{name} index"
 
     Gem.time "Generated #{name} index" do
-      open(file, 'wb') do |io|
+      File.open(file, "wb") do |io|
         specs = index.map do |*spec|
           # We have to splat here because latest_specs is an array, while the
           # others are hashes.
@@ -169,7 +149,7 @@ class Gem::Indexer
             next
           end
 
-          platform = Gem::Platform::RUBY if platform.nil? or platform.empty?
+          platform = Gem::Platform::RUBY if platform.nil? || platform.empty?
           [spec.name, spec.version, platform]
         end
 
@@ -189,10 +169,10 @@ class Gem::Indexer
     latest_specs =
       Gem::Specification._latest_specs specs
 
-    build_modern_index(released.sort, @specs_index, 'specs')
-    build_modern_index(latest_specs.sort, @latest_specs_index, 'latest specs')
+    build_modern_index(released.sort, @specs_index, "specs")
+    build_modern_index(latest_specs.sort, @latest_specs_index, "latest specs")
     build_modern_index(prerelease.sort, @prerelease_specs_index,
-                       'prerelease specs')
+                       "prerelease specs")
 
     @files += [@specs_index,
                "#{@specs_index}.gz",
@@ -237,7 +217,7 @@ class Gem::Indexer
   def compress_indices
     say "Compressing indices"
 
-    Gem.time 'Compressed indices' do
+    Gem.time "Compressed indices" do
       if @build_modern
         gzip @specs_index
         gzip @latest_specs_index
@@ -272,7 +252,7 @@ class Gem::Indexer
 
     zipped = Gem.deflate data
 
-    File.open "#{filename}.#{extension}", 'wb' do |io|
+    File.open "#{filename}.#{extension}", "wb" do |io|
       io.write zipped
     end
   end
@@ -316,7 +296,7 @@ class Gem::Indexer
     files = @files
     files.delete @quick_marshal_dir if files.include? @quick_dir
 
-    if files.include? @quick_marshal_dir and not files.include? @quick_dir
+    if files.include?(@quick_marshal_dir) && !files.include?(@quick_dir)
       files.delete @quick_marshal_dir
 
       dst_name = File.join(@dest_directory, @quick_marshal_dir_base)
@@ -328,7 +308,7 @@ class Gem::Indexer
     end
 
     files = files.map do |path|
-      path.sub(/^#{Regexp.escape @directory}\/?/, '') # HACK?
+      path.sub(/^#{Regexp.escape @directory}\/?/, "") # HACK?
     end
 
     files.each do |file|
@@ -378,16 +358,16 @@ class Gem::Indexer
     end
 
     if updated_gems.empty?
-      say 'No new gems'
+      say "No new gems"
       terminate_interaction 0
     end
 
     specs = map_gems_to_specs updated_gems
-    prerelease, released = specs.partition { |s| s.version.prerelease? }
+    prerelease, released = specs.partition {|s| s.version.prerelease? }
 
     files = build_marshal_gemspecs specs
 
-    Gem.time 'Updated indexes' do
+    Gem.time "Updated indexes" do
       update_specs_index released, @dest_specs_index, @specs_index
       update_specs_index released, @dest_latest_specs_index, @latest_specs_index
       update_specs_index(prerelease,
@@ -409,7 +389,7 @@ class Gem::Indexer
     files << "#{@prerelease_specs_index}.gz"
 
     files = files.map do |path|
-      path.sub(/^#{Regexp.escape @directory}\/?/, '') # HACK?
+      path.sub(/^#{Regexp.escape @directory}\/?/, "") # HACK?
     end
 
     files.each do |file|
@@ -421,6 +401,8 @@ class Gem::Indexer
 
       File.utime newest_mtime, newest_mtime, dst_name
     end
+  ensure
+    FileUtils.rm_rf @directory
   end
 
   ##
@@ -432,15 +414,14 @@ class Gem::Indexer
 
     index.each do |spec|
       platform = spec.original_platform
-      platform = Gem::Platform::RUBY if platform.nil? or platform.empty?
+      platform = Gem::Platform::RUBY if platform.nil? || platform.empty?
       specs_index << [spec.name, spec.version, platform]
     end
 
     specs_index = compact_specs specs_index.uniq.sort
 
-    File.open dest, 'wb' do |io|
+    File.open dest, "wb" do |io|
       Marshal.dump specs_index, io
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/install_default_message.rb
+++ ruby2.7-2.7.6/lib/rubygems/install_default_message.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/user_interaction'
+require_relative "../rubygems"
+require_relative "user_interaction"
 
 ##
 # A post-install hook that displays "Successfully installed
--- ruby2.7-2.7.6.orig/lib/rubygems/install_message.rb
+++ ruby2.7-2.7.6/lib/rubygems/install_message.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/user_interaction'
+require_relative "../rubygems"
+require_relative "user_interaction"
 
 ##
 # A default post-install hook that displays "Successfully installed
--- ruby2.7-2.7.6.orig/lib/rubygems/install_update_options.rb
+++ ruby2.7-2.7.6/lib/rubygems/install_update_options.rb
@@ -5,8 +5,8 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems'
-require 'rubygems/security_option'
+require_relative "../rubygems"
+require_relative "security_option"
 
 ##
 # Mixin methods for install and update options for Gem::Commands
@@ -18,86 +18,86 @@ module Gem::InstallUpdateOptions
   # Add the install/update options to the option parser.
 
   def add_install_update_options
-    add_option(:"Install/Update", '-i', '--install-dir DIR',
-               'Gem repository directory to get installed',
-               'gems') do |value, options|
+    add_option(:"Install/Update", "-i", "--install-dir DIR",
+               "Gem repository directory to get installed",
+               "gems") do |value, options|
       options[:install_dir] = File.expand_path(value)
     end
 
-    add_option(:"Install/Update", '-n', '--bindir DIR',
-               'Directory where executables are',
-               'located') do |value, options|
+    add_option(:"Install/Update", "-n", "--bindir DIR",
+               "Directory where executables will be",
+               "placed when the gem is installed") do |value, options|
       options[:bin_dir] = File.expand_path(value)
     end
 
-    add_option(:"Install/Update",       '--document [TYPES]', Array,
-               'Generate documentation for installed gems',
-               'List the documentation types you wish to',
-               'generate.  For example: rdoc,ri') do |value, options|
+    add_option(:"Install/Update", "--document [TYPES]", Array,
+               "Generate documentation for installed gems",
+               "List the documentation types you wish to",
+               "generate.  For example: rdoc,ri") do |value, options|
       options[:document] = case value
-                           when nil   then %w[ri]
-                           when false then []
-                           else            value
-                           end
+      when nil   then %w[ri]
+      when false then []
+      else            value
+      end
     end
 
-    add_option(:"Install/Update", '--build-root DIR',
-               'Temporary installation root. Useful for building',
-               'packages. Do not use this when installing remote gems.') do |value, options|
+    add_option(:"Install/Update", "--build-root DIR",
+               "Temporary installation root. Useful for building",
+               "packages. Do not use this when installing remote gems.") do |value, options|
       options[:build_root] = File.expand_path(value)
     end
 
-    add_option(:"Install/Update", '--vendor',
-               'Install gem into the vendor directory.',
-               'Only for use by gem repackagers.') do |value, options|
+    add_option(:"Install/Update", "--vendor",
+               "Install gem into the vendor directory.",
+               "Only for use by gem repackagers.") do |value, options|
       unless Gem.vendor_dir
-        raise OptionParser::InvalidOption.new 'your platform is not supported'
+        raise Gem::OptionParser::InvalidOption.new "your platform is not supported"
       end
 
       options[:vendor] = true
       options[:install_dir] = Gem.vendor_dir
     end
 
-    add_option(:"Install/Update", '-N', '--no-document',
-               'Disable documentation generation') do |value, options|
+    add_option(:"Install/Update", "-N", "--no-document",
+               "Disable documentation generation") do |value, options|
       options[:document] = []
     end
 
-    add_option(:"Install/Update", '-E', '--[no-]env-shebang',
+    add_option(:"Install/Update", "-E", "--[no-]env-shebang",
                "Rewrite the shebang line on installed",
                "scripts to use /usr/bin/env") do |value, options|
       options[:env_shebang] = value
     end
 
-    add_option(:"Install/Update", '-f', '--[no-]force',
-               'Force gem to install, bypassing dependency',
-               'checks') do |value, options|
+    add_option(:"Install/Update", "-f", "--[no-]force",
+               "Force gem to install, bypassing dependency",
+               "checks") do |value, options|
       options[:force] = value
     end
 
-    add_option(:"Install/Update", '-w', '--[no-]wrappers',
-               'Use bin wrappers for executables',
-               'Not available on dosish platforms') do |value, options|
+    add_option(:"Install/Update", "-w", "--[no-]wrappers",
+               "Use bin wrappers for executables",
+               "Not available on dosish platforms") do |value, options|
       options[:wrappers] = value
     end
 
     add_security_option
 
-    add_option(:"Install/Update", '--ignore-dependencies',
-               'Do not install any required dependent gems') do |value, options|
+    add_option(:"Install/Update", "--ignore-dependencies",
+               "Do not install any required dependent gems") do |value, options|
       options[:ignore_dependencies] = value
     end
 
-    add_option(:"Install/Update",       '--[no-]format-executable',
-               'Make installed executable names match Ruby.',
-               'If Ruby is ruby18, foo_exec will be',
-               'foo_exec18') do |value, options|
+    add_option(:"Install/Update", "--[no-]format-executable",
+               "Make installed executable names match Ruby.",
+               "If Ruby is ruby18, foo_exec will be",
+               "foo_exec18") do |value, options|
       options[:format_executable] = value
     end
 
-    add_option(:"Install/Update",       '--[no-]user-install',
-               'Install in user\'s home directory instead',
-               'of GEM_HOME.') do |value, options|
+    add_option(:"Install/Update", "--[no-]user-install",
+               "Install in user's home directory instead",
+               "of GEM_HOME.") do |value, options|
       options[:user_install] = value
     end
 
@@ -122,10 +122,10 @@ module Gem::InstallUpdateOptions
       options[:minimal_deps] = true
     end
 
-    add_option(:"Install/Update", "--minimal-deps",
+    add_option(:"Install/Update", "--[no-]minimal-deps",
                 "Don't upgrade any dependencies that already",
                 "meet version requirements") do |value, options|
-      options[:minimal_deps] = true
+      options[:minimal_deps] = value
     end
 
     add_option(:"Install/Update", "--[no-]post-install-message",
@@ -133,9 +133,9 @@ module Gem::InstallUpdateOptions
       options[:post_install_message] = value
     end
 
-    add_option(:"Install/Update", '-g', '--file [FILE]',
-               'Read from a gem dependencies API file and',
-               'install the listed gems') do |v,o|
+    add_option(:"Install/Update", "-g", "--file [FILE]",
+               "Read from a gem dependencies API file and",
+               "install the listed gems") do |v,o|
       v = Gem::GEM_DEP_FILES.find do |file|
         File.exist? file
       end unless v
@@ -143,48 +143,57 @@ module Gem::InstallUpdateOptions
       unless v
         message = v ? v : "(tried #{Gem::GEM_DEP_FILES.join ', '})"
 
-        raise OptionParser::InvalidArgument,
+        raise Gem::OptionParser::InvalidArgument,
                 "cannot find gem dependencies file #{message}"
       end
 
       options[:gemdeps] = v
     end
 
-    add_option(:"Install/Update", '--without GROUPS', Array,
-               'Omit the named groups (comma separated)',
-               'when installing from a gem dependencies',
-               'file') do |v,o|
-      options[:without_groups].concat v.map { |without| without.intern }
+    add_option(:"Install/Update", "--without GROUPS", Array,
+               "Omit the named groups (comma separated)",
+               "when installing from a gem dependencies",
+               "file") do |v,o|
+      options[:without_groups].concat v.map {|without| without.intern }
     end
 
-    add_option(:"Install/Update", '--default',
-               'Add the gem\'s full specification to',
-               'specifications/default and extract only its bin') do |v,o|
+    add_option(:"Install/Update", "--default",
+               "Add the gem's full specification to",
+               "specifications/default and extract only its bin") do |v,o|
       options[:install_as_default] = v
     end
 
-    add_option(:"Install/Update", '--explain',
-               'Rather than install the gems, indicate which would',
-               'be installed') do |v,o|
+    add_option(:"Install/Update", "--explain",
+               "Rather than install the gems, indicate which would",
+               "be installed") do |v,o|
       options[:explain] = v
     end
 
-    add_option(:"Install/Update", '--[no-]lock',
-               'Create a lock file (when used with -g/--file)') do |v,o|
+    add_option(:"Install/Update", "--[no-]lock",
+               "Create a lock file (when used with -g/--file)") do |v,o|
       options[:lock] = v
     end
 
-    add_option(:"Install/Update", '--[no-]suggestions',
-               'Suggest alternates when gems are not found') do |v,o|
+    add_option(:"Install/Update", "--[no-]suggestions",
+               "Suggest alternates when gems are not found") do |v,o|
       options[:suggest_alternate] = v
     end
   end
 
   ##
-  # Default options for the gem install command.
+  # Default options for the gem install and update commands.
+
+  def install_update_options
+    {
+      :document => %w[ri],
+    }
+  end
+
+  ##
+  # Default description for the gem install and update commands.
 
   def install_update_defaults_str
-    '--document=rdoc,ri --wrappers'
+    "--document=ri"
   end
 
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/installer.rb
+++ ruby2.7-2.7.6/lib/rubygems/installer.rb
@@ -5,13 +5,12 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/command'
-require 'rubygems/exceptions'
-require 'rubygems/deprecate'
-require 'rubygems/package'
-require 'rubygems/ext'
-require 'rubygems/user_interaction'
-require 'fileutils'
+require_relative "installer_uninstaller_utils"
+require_relative "exceptions"
+require_relative "deprecate"
+require_relative "package"
+require_relative "ext"
+require_relative "user_interaction"
 
 ##
 # The installer installs the files contained in the .gem into the Gem.home.
@@ -27,7 +26,6 @@ require 'fileutils'
 # file.  See Gem.pre_install and Gem.post_install for details.
 
 class Gem::Installer
-
   extend Gem::Deprecate
 
   ##
@@ -43,10 +41,7 @@ class Gem::Installer
 
   include Gem::UserInteraction
 
-  ##
-  # Filename of the gem being installed.
-
-  attr_reader :gem
+  include Gem::InstallerUninstallerUtils
 
   ##
   # The directory a gem's executables will be installed into
@@ -72,20 +67,28 @@ class Gem::Installer
 
   @path_warning = false
 
-  @install_lock = Mutex.new
-
   class << self
+    #
+    # Changes in rubygems to lazily loading `rubygems/command` (in order to
+    # lazily load `optparse` as a side effect) affect bundler's custom installer
+    # which uses `Gem::Command` without requiring it (up until bundler 2.2.29).
+    # This hook is to compensate for that missing require.
+    #
+    # TODO: Remove when rubygems no longer supports running on bundler older
+    # than 2.2.29.
 
-    ##
-    # True if we've warned about PATH not including Gem.bindir
+    def inherited(klass)
+      if klass.name == "Bundler::RubyGemsGemInstaller"
+        require "rubygems/command"
+      end
 
-    attr_accessor :path_warning
+      super(klass)
+    end
 
     ##
-    # Certain aspects of the install process are not thread-safe. This lock is
-    # used to allow multiple threads to install Gems at the same time.
+    # True if we've warned about PATH not including Gem.bindir
 
-    attr_reader :install_lock
+    attr_accessor :path_warning
 
     ##
     # Overrides the executable format.
@@ -100,7 +103,6 @@ class Gem::Installer
     def exec_format
       @exec_format ||= Gem.default_exec_format
     end
-
   end
 
   ##
@@ -113,7 +115,6 @@ class Gem::Installer
   end
 
   class FakePackage
-
     attr_accessor :spec
 
     attr_accessor :dir_mode
@@ -124,14 +125,14 @@ class Gem::Installer
       @spec = spec
     end
 
-    def extract_files(destination_dir, pattern = '*')
+    def extract_files(destination_dir, pattern = "*")
       FileUtils.mkdir_p destination_dir
 
       spec.files.each do |file|
         file = File.join destination_dir, file
         next if File.exist? file
         FileUtils.mkdir_p File.dirname(file)
-        File.open file, 'w' do |fp|
+        File.open file, "w" do |fp|
           fp.puts "# #{file}"
         end
       end
@@ -139,7 +140,6 @@ class Gem::Installer
 
     def copy_to(path)
     end
-
   end
 
   ##
@@ -177,18 +177,10 @@ class Gem::Installer
   # :post_install_message:: Print gem post install message if true
 
   def initialize(package, options={})
-    require 'fileutils'
+    require "fileutils"
 
     @options = options
-    if package.is_a? String
-      security_policy = options[:security_policy]
-      @package = Gem::Package.new package, security_policy
-      if $VERBOSE
-        warn "constructing an Installer object with a string is deprecated. Please use Gem::Installer.at (called from: #{caller.first})"
-      end
-    else
-      @package = package
-    end
+    @package = package
 
     process_options
 
@@ -199,6 +191,7 @@ class Gem::Installer
     if options[:user_install]
       @gem_home = Gem.user_dir
       @bin_dir = Gem.bindir gem_home unless options[:bin_dir]
+      @plugins_dir = Gem.plugindir(gem_home)
       check_that_user_bin_dir_is_in_path
     end
   end
@@ -208,8 +201,8 @@ class Gem::Installer
   #
   # If +@force+ is set +filename+ is overwritten.
   #
-  # If +filename+ exists and is a RubyGems wrapper for different gem the user
-  # is consulted.
+  # If +filename+ exists and it is a RubyGems wrapper for a different gem, then
+  # the user is consulted.
   #
   # If +filename+ exists and +@bin_dir+ is Gem.default_bindir (/usr/local) the
   # user is consulted.
@@ -226,8 +219,18 @@ class Gem::Installer
     ruby_executable = false
     existing = nil
 
-    File.open generated_bin, 'rb' do |io|
-      next unless io.gets =~ /^#!/ # shebang
+    File.open generated_bin, "rb" do |io|
+      line = io.gets
+      shebang = /^#!.*ruby/
+
+      if load_relative_enabled?
+        until line.nil? || line =~ shebang do
+          line = io.gets
+        end
+      end
+
+      next unless line =~ shebang
+
       io.gets # blankline
 
       # TODO detect a specially formatted comment instead of trying
@@ -248,12 +251,12 @@ class Gem::Installer
     return if spec.name == existing
 
     # somebody has written to RubyGems' directory, overwrite, too bad
-    return if Gem.default_bindir != @bin_dir and not ruby_executable
+    return if Gem.default_bindir != @bin_dir && !ruby_executable
 
     question = "#{spec.name}'s executable \"#{filename}\" conflicts with ".dup
 
     if ruby_executable
-      question << (existing || 'an unknown executable')
+      question << (existing || "an unknown executable")
 
       return if ask_yes_no "#{question}\nOverwrite the executable?", false
 
@@ -282,8 +285,6 @@ class Gem::Installer
 
   def spec
     @package.spec
-  rescue Gem::Package::Error => e
-    raise Gem::InstallError, "invalid gem: #{e.message}"
   end
 
   ##
@@ -300,8 +301,6 @@ class Gem::Installer
   def install
     pre_install_checks
 
-    FileUtils.rm_f File.join gem_home, 'specifications', spec.spec_name
-
     run_pre_install_hooks
 
     # Set loaded_from to ensure extension_dir is correct
@@ -330,6 +329,7 @@ class Gem::Installer
     end
 
     generate_bin
+    generate_plugins
 
     unless @options[:install_as_default]
       write_spec
@@ -340,7 +340,7 @@ class Gem::Installer
 
     say spec.post_install_message if options[:post_install_message] && !spec.post_install_message.nil?
 
-    Gem::Installer.install_lock.synchronize { Gem::Specification.reset }
+    Gem::Specification.add_spec(spec)
 
     run_post_install_hooks
 
@@ -418,10 +418,10 @@ class Gem::Installer
   # True if the gems in the system satisfy +dependency+.
 
   def installation_satisfies_dependency?(dependency)
-    return true if @options[:development] and dependency.type == :development
-    return true if installed_specs.detect { |s| dependency.matches_spec? s }
+    return true if @options[:development] && dependency.type == :development
+    return true if installed_specs.detect {|s| dependency.matches_spec? s }
     return false if @only_install_dir
-    not dependency.matching_specs.empty?
+    !dependency.matching_specs.empty?
   end
 
   ##
@@ -431,7 +431,7 @@ class Gem::Installer
     @gem_dir = directory
     extract_files
   end
-  deprecate :unpack, :none, 2020, 04
+  rubygems_deprecate :unpack
 
   ##
   # The location of the spec file that is installed.
@@ -446,7 +446,7 @@ class Gem::Installer
   #
 
   def default_spec_file
-    File.join Gem.default_specifications_dir, "#{spec.full_name}.gemspec"
+    File.join gem_home, "specifications", "default", "#{spec.full_name}.gemspec"
   end
 
   ##
@@ -454,13 +454,9 @@ class Gem::Installer
   # specifications directory.
 
   def write_spec
-    File.open spec_file, 'w' do |file|
-      spec.installed_by_version = Gem.rubygems_version
+    spec.installed_by_version = Gem.rubygems_version
 
-      file.puts spec.to_ruby_for_cache
-
-      file.fsync rescue nil # for filesystems without fsync(2)
-    end
+    Gem.write_binary(spec_file, spec.to_ruby_for_cache)
   end
 
   ##
@@ -468,9 +464,7 @@ class Gem::Installer
   # specifications/default directory.
 
   def write_default_spec
-    File.open(default_spec_file, "w") do |file|
-      file.puts spec.to_ruby
-    end
+    Gem.write_binary(default_spec_file, spec.to_ruby)
   end
 
   ##
@@ -480,7 +474,7 @@ class Gem::Installer
     if Gem.win_platform?
       script_name = formatted_program_filename(filename) + ".bat"
       script_path = File.join bindir, File.basename(script_name)
-      File.open script_path, 'w' do |file|
+      File.open script_path, "w" do |file|
         file.puts windows_stub_script(bindir, filename)
       end
 
@@ -489,29 +483,22 @@ class Gem::Installer
   end
 
   def generate_bin # :nodoc:
-    return if spec.executables.nil? or spec.executables.empty?
-
-    begin
-      Dir.mkdir @bin_dir, *[options[:dir_mode] && 0755].compact
-    rescue SystemCallError
-      raise unless File.directory? @bin_dir
-    end
+    return if spec.executables.nil? || spec.executables.empty?
 
-    raise Gem::FilePermissionError.new(@bin_dir) unless File.writable? @bin_dir
+    ensure_writable_dir @bin_dir
 
     spec.executables.each do |filename|
       filename.tap(&Gem::UNTAINT)
       bin_path = File.join gem_dir, spec.bindir, filename
-
-      unless File.exist? bin_path
-        # TODO change this to a more useful warning
-        warn "`#{bin_path}` does not exist, maybe `gem pristine #{spec.name}` will fix it?"
-        next
-      end
+      next unless File.exist? bin_path
 
       mode = File.stat(bin_path).mode
       dir_mode = options[:prog_mode] || (mode | 0111)
-      FileUtils.chmod dir_mode, bin_path unless dir_mode == mode
+
+      unless dir_mode == mode
+        require "fileutils"
+        FileUtils.chmod dir_mode, bin_path
+      end
 
       check_executable_overwrite filename
 
@@ -520,7 +507,19 @@ class Gem::Installer
       else
         generate_bin_symlink filename, @bin_dir
       end
+    end
+  end
+
+  def generate_plugins # :nodoc:
+    latest = Gem::Specification.latest_spec_for(spec.name)
+    return if latest && latest.version > spec.version
+
+    ensure_writable_dir @plugins_dir
 
+    if spec.plugins.empty?
+      remove_plugins_for(spec, @plugins_dir)
+    else
+      regenerate_plugins_for(spec, @plugins_dir)
     end
   end
 
@@ -534,9 +533,10 @@ class Gem::Installer
   def generate_bin_script(filename, bindir)
     bin_script_path = File.join bindir, formatted_program_filename(filename)
 
+    require "fileutils"
     FileUtils.rm_f bin_script_path # prior install may have been --no-wrappers
 
-    File.open bin_script_path, 'wb', 0755 do |file|
+    File.open bin_script_path, "wb", 0755 do |file|
       file.print app_script_text(filename)
       file.chmod(options[:prog_mode] || 0755)
     end
@@ -557,7 +557,7 @@ class Gem::Installer
     if File.exist? dst
       if File.symlink? dst
         link = File.readlink(dst).split File::SEPARATOR
-        cur_version = Gem::Version.create(link[-3].sub(/^.*-/, ''))
+        cur_version = Gem::Version.create(link[-3].sub(/^.*-/, ""))
         return if spec.version < cur_version
       end
       File.unlink dst
@@ -585,11 +585,10 @@ class Gem::Installer
   #
 
   def shebang(bin_file_name)
-    ruby_name = RbConfig::CONFIG['ruby_install_name'] if @env_shebang
     path = File.join gem_dir, spec.bindir, bin_file_name
-    first_line = File.open(path, "rb") {|file| file.gets}
+    first_line = File.open(path, "rb") {|file| file.gets } || ""
 
-    if /\A#!/ =~ first_line
+    if first_line.start_with?("#!")
       # Preserve extra words on shebang line, like "-w".  Thanks RPA.
       shebang = first_line.sub(/\A\#!.*?ruby\S*((\s+\S+)+)/, "#!#{Gem.ruby}")
       opts = $1
@@ -598,7 +597,7 @@ class Gem::Installer
 
     if which = Gem.configuration[:custom_shebang]
       # replace bin_file_name with "ruby" to avoid endless loops
-      which = which.gsub(/ #{bin_file_name}$/," #{RbConfig::CONFIG['ruby_install_name']}")
+      which = which.gsub(/ #{bin_file_name}$/," #{ruby_install_name}")
 
       which = which.gsub(/\$(\w+)/) do
         case $1
@@ -614,14 +613,12 @@ class Gem::Installer
       end
 
       "#!#{which}"
-    elsif not ruby_name
-      "#!#{Gem.ruby}#{opts}"
-    elsif opts
-      "#!/bin/sh\n'exec' #{ruby_name.dump} '-x' \"$0\" \"$@\"\n#{shebang}"
-    else
+    elsif @env_shebang
       # Create a plain shebang line.
       @env_path ||= ENV_PATHS.find {|env_path| File.executable? env_path }
-      "#!#{@env_path} #{ruby_name}"
+      "#!#{@env_path} #{ruby_install_name}"
+    else
+      "#{bash_prolog_script}#!#{Gem.ruby}#{opts}"
     end
   end
 
@@ -641,27 +638,6 @@ class Gem::Installer
     end
   end
 
-  def ensure_required_ruby_version_met # :nodoc:
-    if rrv = spec.required_ruby_version
-      ruby_version = Gem.ruby_version
-      unless rrv.satisfied_by? ruby_version
-        raise Gem::RuntimeRequirementNotMetError,
-          "#{spec.name} requires Ruby version #{rrv}. The current ruby version is #{ruby_version}."
-      end
-    end
-  end
-
-  def ensure_required_rubygems_version_met # :nodoc:
-    if rrgv = spec.required_rubygems_version
-      unless rrgv.satisfied_by? Gem.rubygems_version
-        rg_version = Gem::VERSION
-        raise Gem::RuntimeRequirementNotMetError,
-          "#{spec.name} requires RubyGems version #{rrgv}. The current RubyGems version is #{rg_version}. " +
-          "Try 'gem update --system' to update RubyGems itself."
-      end
-    end
-  end
-
   def ensure_dependencies_met # :nodoc:
     deps = spec.runtime_dependencies
     deps |= spec.development_dependencies if @development
@@ -677,13 +653,14 @@ class Gem::Installer
       :env_shebang  => false,
       :force        => false,
       :only_install_dir => false,
-      :post_install_message => true
+      :post_install_message => true,
     }.merge options
 
     @env_shebang         = options[:env_shebang]
     @force               = options[:force]
     @install_dir         = options[:install_dir]
     @gem_home            = options[:install_dir] || Gem.dir
+    @plugins_dir         = Gem.plugindir(@gem_home)
     @ignore_dependencies = options[:ignore_dependencies]
     @format_executable   = options[:format_executable]
     @wrappers            = options[:wrappers]
@@ -696,23 +673,25 @@ class Gem::Installer
     @development         = options[:development]
     @build_root          = options[:build_root]
 
-    @build_args = options[:build_args] || Gem::Command.build_args
+    @build_args = options[:build_args]
 
     unless @build_root.nil?
-      require 'pathname'
-      @build_root = Pathname.new(@build_root).expand_path
-      @bin_dir = File.join(@build_root, options[:bin_dir] || Gem.bindir(@gem_home))
-      @gem_home = File.join(@build_root, @gem_home)
-      alert_warning "You build with buildroot.\n  Build root: #{@build_root}\n  Bin dir: #{@bin_dir}\n  Gem home: #{@gem_home}"
+      @bin_dir = File.join(@build_root, @bin_dir.gsub(/^[a-zA-Z]:/, ""))
+      @gem_home = File.join(@build_root, @gem_home.gsub(/^[a-zA-Z]:/, ""))
+      @plugins_dir = File.join(@build_root, @plugins_dir.gsub(/^[a-zA-Z]:/, ""))
+      alert_warning "You build with buildroot.\n  Build root: #{@build_root}\n  Bin dir: #{@bin_dir}\n  Gem home: #{@gem_home}\n  Plugins dir: #{@plugins_dir}"
     end
   end
 
   def check_that_user_bin_dir_is_in_path # :nodoc:
+    return if self.class.path_warning
+
     user_bin_dir = @bin_dir || Gem.bindir(gem_home)
-    user_bin_dir = user_bin_dir.gsub(File::SEPARATOR, File::ALT_SEPARATOR) if
-      File::ALT_SEPARATOR
+    user_bin_dir = user_bin_dir.tr(File::ALT_SEPARATOR, File::SEPARATOR) if File::ALT_SEPARATOR
+
+    path = ENV["PATH"]
+    path = path.tr(File::ALT_SEPARATOR, File::SEPARATOR) if File::ALT_SEPARATOR
 
-    path = ENV['PATH']
     if Gem.win_platform?
       path = path.downcase
       user_bin_dir = user_bin_dir.downcase
@@ -721,11 +700,9 @@ class Gem::Installer
     path = path.split(File::PATH_SEPARATOR)
 
     unless path.include? user_bin_dir
-      unless !Gem.win_platform? && (path.include? user_bin_dir.sub(ENV['HOME'], '~'))
-        unless self.class.path_warning
-          alert_warning "You don't have #{user_bin_dir} in your PATH,\n\t  gem executables will not run."
-          self.class.path_warning = true
-        end
+      unless !Gem.win_platform? && (path.include? user_bin_dir.sub(ENV["HOME"], "~"))
+        alert_warning "You don't have #{user_bin_dir} in your PATH,\n\t  gem executables will not run."
+        self.class.path_warning = true
       end
     end
   end
@@ -740,14 +717,18 @@ class Gem::Installer
       raise Gem::InstallError, "#{spec} has an invalid name"
     end
 
-    if spec.raw_require_paths.any?{|path| path =~ /\R/ }
+    if spec.raw_require_paths.any? {|path| path =~ /\R/ }
       raise Gem::InstallError, "#{spec} has an invalid require_paths"
     end
 
-    if spec.extensions.any?{|ext| ext =~ /\R/ }
+    if spec.extensions.any? {|ext| ext =~ /\R/ }
       raise Gem::InstallError, "#{spec} has an invalid extensions"
     end
 
+    if spec.platform.to_s =~ /\R/
+      raise Gem::InstallError, "#{spec.platform} is an invalid platform"
+    end
+
     unless spec.specification_version.to_s =~ /\A\d+\z/
       raise Gem::InstallError, "#{spec} has an invalid specification_version"
     end
@@ -777,14 +758,14 @@ class Gem::Installer
 #
 
 require 'rubygems'
-
+#{gemdeps_load(spec.name)}
 version = "#{Gem::Requirement.default_prerelease}"
 
 str = ARGV.first
 if str
   str = str.b[/\\A_(.*)_\\z/, 1]
   if str and Gem::Version.correct?(str)
-    version = str
+    #{explicit_version_requirement(spec.name)}
     ARGV.shift
   end
 end
@@ -798,11 +779,29 @@ end
 TEXT
   end
 
+  def gemdeps_load(name)
+    return "" if name == "bundler"
+
+    <<-TEXT
+
+Gem.use_gemdeps
+TEXT
+  end
+
+  def explicit_version_requirement(name)
+    code = "version = str"
+    return code unless name == "bundler"
+
+    code += <<-TEXT
+
+    ENV['BUNDLER_VERSION'] = str
+TEXT
+  end
+
   ##
   # return the stub script text used to launch the true Ruby script
 
   def windows_stub_script(bindir, bin_file_name)
-    rb_config = RbConfig::CONFIG
     rb_topdir = RbConfig::TOPDIR || File.dirname(rb_config["bindir"])
 
     # get ruby executable file name from RbConfig
@@ -810,14 +809,14 @@ TEXT
     ruby_exe = "ruby.exe" if ruby_exe.empty?
 
     if File.exist?(File.join bindir, ruby_exe)
-      # stub & ruby.exe withing same folder.  Portable
+      # stub & ruby.exe within same folder.  Portable
       <<-TEXT
 @ECHO OFF
 @"%~dp0#{ruby_exe}" "%~dpn0" %*
       TEXT
     elsif bindir.downcase.start_with? rb_topdir.downcase
       # stub within ruby folder, but not standard bin.  Portable
-      require 'pathname'
+      require "pathname"
       from = Pathname.new bindir
       to   = Pathname.new "#{rb_topdir}/bin"
       rel  = to.relative_path_from from
@@ -839,24 +838,12 @@ TEXT
   # configure scripts and rakefiles or mkrf_conf files.
 
   def build_extensions
-    builder = Gem::Ext::Builder.new spec, @build_args
+    builder = Gem::Ext::Builder.new spec, build_args
 
     builder.build_extensions
   end
 
   ##
-  # Logs the build +output+ in +build_dir+, then raises Gem::Ext::BuildError.
-  #
-  # TODO:  Delete this for RubyGems 4.  It remains for API compatibility
-
-  def extension_build_error(build_dir, output, backtrace = nil) # :nodoc:
-    builder = Gem::Ext::Builder.new spec, @build_args
-
-    builder.build_error build_dir, output, backtrace
-  end
-  deprecate :extension_build_error, :none, 2018, 12
-
-  ##
   # Reads the file index and extracts each file into the gem directory.
   #
   # Ensures that files can't be installed outside the gem directory.
@@ -896,6 +883,13 @@ TEXT
   end
 
   ##
+  # Filename of the gem being installed.
+
+  def gem
+    @package.gem.path
+  end
+
+  ##
   # Performs various checks before installing the gem such as the install
   # repository is writable and its directories exist, required Ruby and
   # rubygems versions are met and that dependencies are installed.
@@ -921,8 +915,6 @@ TEXT
 
     return true if @force
 
-    ensure_required_ruby_version_met
-    ensure_required_rubygems_version_met
     ensure_dependencies_met unless @ignore_dependencies
 
     true
@@ -933,17 +925,17 @@ TEXT
   # extensions.
 
   def write_build_info_file
-    return if @build_args.empty?
+    return if build_args.empty?
 
-    build_info_dir = File.join gem_home, 'build_info'
+    build_info_dir = File.join gem_home, "build_info"
 
     dir_mode = options[:dir_mode]
     FileUtils.mkdir_p build_info_dir, :mode => dir_mode && 0755
 
     build_info_file = File.join build_info_dir, "#{spec.full_name}.info"
 
-    File.open build_info_file, 'w' do |io|
-      @build_args.each do |arg|
+    File.open build_info_file, "w" do |io|
+      build_args.each do |arg|
         io.puts arg
       end
     end
@@ -955,8 +947,59 @@ TEXT
   # Writes the .gem file to the cache directory
 
   def write_cache_file
-    cache_file = File.join gem_home, 'cache', spec.file_name
+    cache_file = File.join gem_home, "cache", spec.file_name
     @package.copy_to cache_file
   end
 
+  def ensure_writable_dir(dir) # :nodoc:
+    begin
+      Dir.mkdir dir, *[options[:dir_mode] && 0755].compact
+    rescue SystemCallError
+      raise unless File.directory? dir
+    end
+
+    raise Gem::FilePermissionError.new(dir) unless File.writable? dir
+  end
+
+  private
+
+  def build_args
+    @build_args ||= begin
+                      require_relative "command"
+                      Gem::Command.build_args
+                    end
+  end
+
+  def rb_config
+    RbConfig::CONFIG
+  end
+
+  def ruby_install_name
+    rb_config["ruby_install_name"]
+  end
+
+  def load_relative_enabled?
+    rb_config["LIBRUBY_RELATIVE"] == "yes"
+  end
+
+  def bash_prolog_script
+    if load_relative_enabled?
+      script = +<<~EOS
+        bindir="${0%/*}"
+      EOS
+
+      script << %Q(exec "$bindir/#{ruby_install_name}" "-x" "$0" "$@"\n)
+
+      <<~EOS
+        #!/bin/sh
+        # -*- ruby -*-
+        _=_\\
+        =begin
+        #{script.chomp}
+        =end
+      EOS
+    else
+      ""
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/installer_test_case.rb
+++ /dev/null
@@ -1,233 +0,0 @@
-# frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/installer'
-
-class Gem::Installer
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :bin_dir
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :build_args
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :gem_dir
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :force
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :format
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :gem_home
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :env_shebang
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :ignore_dependencies
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :format_executable
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :security_policy
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :wrappers
-
-end
-
-##
-# A test case for Gem::Installer.
-
-class Gem::InstallerTestCase < Gem::TestCase
-
-  def setup
-    super
-
-    Gem::Installer.path_warning = false
-  end
-
-  ##
-  # The path where installed executables live
-
-  def util_inst_bindir
-    File.join @gemhome, "bin"
-  end
-
-  ##
-  # Adds an executable named "executable" to +spec+ with the given +shebang+.
-  #
-  # The executable is also written to the bin dir in @tmpdir and the installed
-  # gem directory for +spec+.
-
-  def util_make_exec(spec = @spec, shebang = "#!/usr/bin/ruby", bindir = "bin")
-    spec.executables = %w[executable]
-    spec.bindir = bindir
-
-    exec_path = spec.bin_file "executable"
-    write_file exec_path do |io|
-      io.puts shebang
-    end
-
-    bin_path = File.join @tempdir, "bin", "executable"
-    write_file bin_path do |io|
-      io.puts shebang
-    end
-  end
-
-  ##
-  # Creates the following instance variables:
-  #
-  # @spec::
-  #   a spec named 'a', intended for regular installs
-  #
-  # @gem::
-  #   the path to a built gem from @spec
-  #
-  # And returns a Gem::Installer for the @spec that installs into @gemhome
-
-  def setup_base_installer
-    @gem = setup_base_gem
-    util_installer @spec, @gemhome
-  end
-
-  ##
-  # Creates the following instance variables:
-  #
-  # @spec::
-  #   a spec named 'a', intended for regular installs
-  #
-  # And returns a gem built for the @spec
-
-  def setup_base_gem
-    @spec = setup_base_spec
-    util_build_gem @spec
-    @spec.cache_file
-  end
-
-  ##
-  # Sets up a generic specification for testing the rubygems installer
-  #
-  # And returns it
-
-  def setup_base_spec
-    quick_gem 'a' do |spec|
-      util_make_exec spec
-    end
-  end
-
-  ##
-  # Creates the following instance variables:
-  #
-  # @spec::
-  #   a spec named 'a', intended for regular installs
-  # @user_spec::
-  #   a spec named 'b', intended for user installs
-  #
-  # @gem::
-  #   the path to a built gem from @spec
-  # @user_gem::
-  #   the path to a built gem from @user_spec
-  #
-  # And returns a Gem::Installer for the @user_spec that installs into Gem.user_dir
-
-  def setup_base_user_installer
-    @user_spec = quick_gem 'b' do |spec|
-      util_make_exec spec
-    end
-
-    util_build_gem @user_spec
-
-    @user_gem = @user_spec.cache_file
-
-    util_installer @user_spec, Gem.user_dir, :user
-  end
-
-  ##
-  # Sets up the base @gem, builds it and returns an installer for it.
-  #
-  def util_setup_installer
-    @gem = setup_base_gem
-
-    util_setup_gem
-  end
-
-  ##
-  # Builds the @spec gem and returns an installer for it.  The built gem
-  # includes:
-  #
-  #   bin/executable
-  #   lib/code.rb
-  #   ext/a/mkrf_conf.rb
-
-  def util_setup_gem(ui = @ui)
-    @spec.files << File.join('lib', 'code.rb')
-    @spec.extensions << File.join('ext', 'a', 'mkrf_conf.rb')
-
-    Dir.chdir @tempdir do
-      FileUtils.mkdir_p 'bin'
-      FileUtils.mkdir_p 'lib'
-      FileUtils.mkdir_p File.join('ext', 'a')
-
-      File.open File.join('bin', 'executable'), 'w' do |f|
-        f.puts "raise 'ran executable'"
-      end
-
-      File.open File.join('lib', 'code.rb'), 'w' do |f|
-        f.puts '1'
-      end
-
-      File.open File.join('ext', 'a', 'mkrf_conf.rb'), 'w' do |f|
-        f << <<-EOF
-          File.open 'Rakefile', 'w' do |rf| rf.puts "task :default" end
-        EOF
-      end
-
-      yield @spec if block_given?
-
-      use_ui ui do
-        FileUtils.rm_f @gem
-
-        @gem = Gem::Package.build @spec
-      end
-    end
-
-    Gem::Installer.at @gem
-  end
-
-  ##
-  # Creates an installer for +spec+ that will install into +gem_home+.  If
-  # +user+ is true a user-install will be performed.
-
-  def util_installer(spec, gem_home, user=false)
-    Gem::Installer.at(spec.cache_file,
-                       :install_dir => gem_home,
-                       :user_install => user)
-  end
-
-end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/installer_uninstaller_utils.rb
@@ -0,0 +1,29 @@
+# frozen_string_literal: true
+
+##
+# Helper methods for both Gem::Installer and Gem::Uninstaller
+
+module Gem::InstallerUninstallerUtils
+
+  def regenerate_plugins_for(spec, plugins_dir)
+    plugins = spec.plugins
+    return if plugins.empty?
+
+    require "pathname"
+
+    spec.plugins.each do |plugin|
+      plugin_script_path = File.join plugins_dir, "#{spec.name}_plugin#{File.extname(plugin)}"
+
+      File.open plugin_script_path, "wb" do |file|
+        file.puts "require_relative '#{Pathname.new(plugin).relative_path_from(Pathname.new(plugins_dir))}'"
+      end
+
+      verbose plugin_script_path
+    end
+  end
+
+  def remove_plugins_for(spec, plugins_dir)
+    FileUtils.rm_f Gem::Util.glob_files_in_dir("#{spec.name}#{Gem.plugin_suffix_pattern}", plugins_dir)
+  end
+
+end
--- ruby2.7-2.7.6.orig/lib/rubygems/local_remote_options.rb
+++ ruby2.7-2.7.6/lib/rubygems/local_remote_options.rb
@@ -5,8 +5,8 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'uri'
-require 'rubygems'
+require "uri"
+require_relative "../rubygems"
 
 ##
 # Mixin methods for local and remote Gem::Command options.
@@ -14,19 +14,19 @@ require 'rubygems'
 module Gem::LocalRemoteOptions
 
   ##
-  # Allows OptionParser to handle HTTP URIs.
+  # Allows Gem::OptionParser to handle HTTP URIs.
 
   def accept_uri_http
-    OptionParser.accept URI::HTTP do |value|
+    Gem::OptionParser.accept URI::HTTP do |value|
       begin
         uri = URI.parse value
       rescue URI::InvalidURIError
-        raise OptionParser::InvalidArgument, value
+        raise Gem::OptionParser::InvalidArgument, value
       end
 
       valid_uri_schemes = ["http", "https", "file", "s3"]
       unless valid_uri_schemes.include?(uri.scheme)
-        msg = "Invalid uri scheme for #{value}\nPreface URLs with one of #{valid_uri_schemes.map{|s| "#{s}://"}}"
+        msg = "Invalid uri scheme for #{value}\nPreface URLs with one of #{valid_uri_schemes.map {|s| "#{s}://" }}"
         raise ArgumentError, msg
       end
 
@@ -38,18 +38,18 @@ module Gem::LocalRemoteOptions
   # Add local/remote options to the command line parser.
 
   def add_local_remote_options
-    add_option(:"Local/Remote", '-l', '--local',
-               'Restrict operations to the LOCAL domain') do |value, options|
+    add_option(:"Local/Remote", "-l", "--local",
+               "Restrict operations to the LOCAL domain") do |value, options|
       options[:domain] = :local
     end
 
-    add_option(:"Local/Remote", '-r', '--remote',
-      'Restrict operations to the REMOTE domain') do |value, options|
+    add_option(:"Local/Remote", "-r", "--remote",
+      "Restrict operations to the REMOTE domain") do |value, options|
       options[:domain] = :remote
     end
 
-    add_option(:"Local/Remote", '-b', '--both',
-               'Allow LOCAL and REMOTE operations') do |value, options|
+    add_option(:"Local/Remote", "-b", "--both",
+               "Allow LOCAL and REMOTE operations") do |value, options|
       options[:domain] = :both
     end
 
@@ -64,7 +64,7 @@ module Gem::LocalRemoteOptions
   # Add the --bulk-threshold option
 
   def add_bulk_threshold_option
-    add_option(:"Local/Remote", '-B', '--bulk-threshold COUNT',
+    add_option(:"Local/Remote", "-B", "--bulk-threshold COUNT",
                "Threshold for switching to bulk",
                "synchronization (default #{Gem.configuration.bulk_threshold})") do
       |value, options|
@@ -76,9 +76,8 @@ module Gem::LocalRemoteOptions
   # Add the --clear-sources option
 
   def add_clear_sources_option
-    add_option(:"Local/Remote", '--clear-sources',
-               'Clear the gem sources') do |value, options|
-
+    add_option(:"Local/Remote", "--clear-sources",
+               "Clear the gem sources") do |value, options|
       Gem.sources = nil
       options[:sources_cleared] = true
     end
@@ -90,8 +89,8 @@ module Gem::LocalRemoteOptions
   def add_proxy_option
     accept_uri_http
 
-    add_option(:"Local/Remote", '-p', '--[no-]http-proxy [URL]', URI::HTTP,
-               'Use HTTP proxy for remote operations') do |value, options|
+    add_option(:"Local/Remote", "-p", "--[no-]http-proxy [URL]", URI::HTTP,
+               "Use HTTP proxy for remote operations") do |value, options|
       options[:http_proxy] = (value == false) ? :no_proxy : value
       Gem.configuration[:http_proxy] = options[:http_proxy]
     end
@@ -103,10 +102,9 @@ module Gem::LocalRemoteOptions
   def add_source_option
     accept_uri_http
 
-    add_option(:"Local/Remote", '-s', '--source URL', URI::HTTP,
-               'Append URL to list of remote gem sources') do |source, options|
-
-      source << '/' if source !~ /\/\z/
+    add_option(:"Local/Remote", "-s", "--source URL", URI::HTTP,
+               "Append URL to list of remote gem sources") do |source, options|
+      source << "/" if source !~ /\/\z/
 
       if options.delete :sources_cleared
         Gem.sources = [source]
@@ -120,8 +118,8 @@ module Gem::LocalRemoteOptions
   # Add the --update-sources option
 
   def add_update_sources_option
-    add_option(:Deprecated, '-u', '--[no-]update-sources',
-               'Update local source cache') do |value, options|
+    add_option(:Deprecated, "-u", "--[no-]update-sources",
+               "Update local source cache") do |value, options|
       Gem.configuration.update_sources = value
     end
   end
--- ruby2.7-2.7.6.orig/lib/rubygems/mock_gem_ui.rb
+++ ruby2.7-2.7.6/lib/rubygems/mock_gem_ui.rb
@@ -1,32 +1,27 @@
 # frozen_string_literal: true
-require 'rubygems/user_interaction'
+require_relative "user_interaction"
 
 ##
 # This Gem::StreamUI subclass records input and output to StringIO for
 # retrieval during tests.
 
 class Gem::MockGemUi < Gem::StreamUI
-
   ##
   # Raised when you haven't provided enough input to your MockGemUi
 
   class InputEOFError < RuntimeError
-
     def initialize(question)
       super "Out of input for MockGemUi on #{question.inspect}"
     end
-
   end
 
   class TermError < RuntimeError
-
     attr_reader :exit_code
 
     def initialize(exit_code)
       super
       @exit_code = exit_code
     end
-
   end
   class SystemExitException < RuntimeError; end
 
@@ -45,7 +40,7 @@ class Gem::MockGemUi < Gem::StreamUI
   end
 
   def initialize(input = "")
-    require 'stringio'
+    require "stringio"
     ins = StringIO.new input
     outs = StringIO.new
     errs = StringIO.new
@@ -87,5 +82,4 @@ class Gem::MockGemUi < Gem::StreamUI
     raise TermError, status if status != 0
     raise SystemExitException
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/name_tuple.rb
+++ ruby2.7-2.7.6/lib/rubygems/name_tuple.rb
@@ -4,16 +4,13 @@
 # Represents a gem of name +name+ at +version+ of +platform+. These
 # wrap the data returned from the indexes.
 
-require 'rubygems/platform'
-
 class Gem::NameTuple
-
   def initialize(name, version, platform="ruby")
     @name = name
     @version = version
 
     unless platform.kind_of? Gem::Platform
-      platform = "ruby" if !platform or platform.empty?
+      platform = "ruby" if !platform || platform.empty?
     end
 
     @platform = platform
@@ -26,7 +23,7 @@ class Gem::NameTuple
   # NameTuple objects.
 
   def self.from_list(list)
-    list.map { |t| new(*t) }
+    list.map {|t| new(*t) }
   end
 
   ##
@@ -34,7 +31,7 @@ class Gem::NameTuple
   # [name, version, platform] tuples.
 
   def self.to_basic(list)
-    list.map { |t| t.to_a }
+    list.map {|t| t.to_a }
   end
 
   ##
@@ -51,7 +48,7 @@ class Gem::NameTuple
 
   def full_name
     case @platform
-    when nil, 'ruby', ''
+    when nil, "ruby", ""
       "#{@name}-#{@version}"
     else
       "#{@name}-#{@version}-#{@platform}"
@@ -62,7 +59,7 @@ class Gem::NameTuple
   # Indicate if this NameTuple matches the current platform.
 
   def match_platform?
-    Gem::Platform.match @platform
+    Gem::Platform.match_gem? @platform, @name
   end
 
   ##
@@ -92,9 +89,8 @@ class Gem::NameTuple
   alias to_s inspect # :nodoc:
 
   def <=>(other)
-    [@name, @version, @platform == Gem::Platform::RUBY ? -1 : 1] <=>
-      [other.name, other.version,
-       other.platform == Gem::Platform::RUBY ? -1 : 1]
+    [@name, @version, Gem::Platform.sort_priority(@platform)] <=>
+      [other.name, other.version, Gem::Platform.sort_priority(other.platform)]
   end
 
   include Comparable
@@ -106,8 +102,8 @@ class Gem::NameTuple
   def ==(other)
     case other
     when self.class
-      @name == other.name and
-        @version == other.version and
+      @name == other.name &&
+        @version == other.version &&
         @platform == other.platform
     when Array
       to_a == other
@@ -121,5 +117,4 @@ class Gem::NameTuple
   def hash
     to_a.hash
   end
-
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/openssl.rb
@@ -0,0 +1,7 @@
+# frozen_string_literal: true
+
+autoload :OpenSSL, "openssl"
+
+module Gem
+  HAVE_OPENSSL = defined? OpenSSL::SSL # :nodoc:
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse.rb
@@ -0,0 +1,3 @@
+# frozen_string_literal: true
+
+require_relative "optparse/lib/optparse"
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse/.document
@@ -0,0 +1 @@
+# Vendored files do not need to be documented
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse/COPYING
@@ -0,0 +1,56 @@
+Ruby is copyrighted free software by Yukihiro Matsumoto <matz@netlab.jp>.
+You can redistribute it and/or modify it under either the terms of the
+2-clause BSDL (see the file BSDL), or the conditions below:
+
+1. You may make and give away verbatim copies of the source form of the
+   software without restriction, provided that you duplicate all of the
+   original copyright notices and associated disclaimers.
+
+2. You may modify your copy of the software in any way, provided that
+   you do at least ONE of the following:
+
+   a. place your modifications in the Public Domain or otherwise
+      make them Freely Available, such as by posting said
+      modifications to Usenet or an equivalent medium, or by allowing
+      the author to include your modifications in the software.
+
+   b. use the modified software only within your corporation or
+      organization.
+
+   c. give non-standard binaries non-standard names, with
+      instructions on where to get the original software distribution.
+
+   d. make other distribution arrangements with the author.
+
+3. You may distribute the software in object code or binary form,
+   provided that you do at least ONE of the following:
+
+   a. distribute the binaries and library files of the software,
+      together with instructions (in the manual page or equivalent)
+      on where to get the original distribution.
+
+   b. accompany the distribution with the machine-readable source of
+      the software.
+
+   c. give non-standard binaries non-standard names, with
+      instructions on where to get the original software distribution.
+
+   d. make other distribution arrangements with the author.
+
+4. You may modify and include the part of the software into any other
+   software (possibly commercial).  But some files in the distribution
+   are not written by the author, so that they are not under these terms.
+
+   For the list of those files and their copying conditions, see the
+   file LEGAL.
+
+5. The scripts and library files supplied as input to or produced as
+   output from the software do not automatically fall under the
+   copyright of the software, but belong to whomever generated them,
+   and may be sold commercially, and may be aggregated with this
+   software.
+
+6. THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+   PURPOSE.
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse/lib/optionparser.rb
@@ -0,0 +1,2 @@
+# frozen_string_literal: false
+require_relative 'optparse'
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse/lib/optparse.rb
@@ -0,0 +1,2303 @@
+# frozen_string_literal: true
+#
+# optparse.rb - command-line option analysis with the Gem::OptionParser class.
+#
+# Author:: Nobu Nakada
+# Documentation:: Nobu Nakada and Gavin Sinclair.
+#
+# See Gem::OptionParser for documentation.
+#
+
+
+#--
+# == Developer Documentation (not for RDoc output)
+#
+# === Class tree
+#
+# - Gem::OptionParser:: front end
+# - Gem::OptionParser::Switch:: each switches
+# - Gem::OptionParser::List:: options list
+# - Gem::OptionParser::ParseError:: errors on parsing
+#   - Gem::OptionParser::AmbiguousOption
+#   - Gem::OptionParser::NeedlessArgument
+#   - Gem::OptionParser::MissingArgument
+#   - Gem::OptionParser::InvalidOption
+#   - Gem::OptionParser::InvalidArgument
+#     - Gem::OptionParser::AmbiguousArgument
+#
+# === Object relationship diagram
+#
+#   +--------------+
+#   | Gem::OptionParser |<>-----+
+#   +--------------+       |                      +--------+
+#                          |                    ,-| Switch |
+#        on_head -------->+---------------+    /  +--------+
+#        accept/reject -->| List          |<|>-
+#                         |               |<|>-  +----------+
+#        on ------------->+---------------+    `-| argument |
+#                           :           :        |  class   |
+#                         +---------------+      |==========|
+#        on_tail -------->|               |      |pattern   |
+#                         +---------------+      |----------|
+#   Gem::OptionParser.accept ->| DefaultList   |      |converter |
+#                reject   |(shared between|      +----------+
+#                         | all instances)|
+#                         +---------------+
+#
+#++
+#
+# == Gem::OptionParser
+#
+# === New to \Gem::OptionParser?
+#
+# See the {Tutorial}[optparse/tutorial.rdoc].
+#
+# === Introduction
+#
+# Gem::OptionParser is a class for command-line option analysis.  It is much more
+# advanced, yet also easier to use, than GetoptLong, and is a more Ruby-oriented
+# solution.
+#
+# === Features
+#
+# 1. The argument specification and the code to handle it are written in the
+#    same place.
+# 2. It can output an option summary; you don't need to maintain this string
+#    separately.
+# 3. Optional and mandatory arguments are specified very gracefully.
+# 4. Arguments can be automatically converted to a specified class.
+# 5. Arguments can be restricted to a certain set.
+#
+# All of these features are demonstrated in the examples below.  See
+# #make_switch for full documentation.
+#
+# === Minimal example
+#
+#   require 'rubygems/optparse/lib/optparse'
+#
+#   options = {}
+#   Gem::OptionParser.new do |parser|
+#     parser.banner = "Usage: example.rb [options]"
+#
+#     parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
+#       options[:verbose] = v
+#     end
+#   end.parse!
+#
+#   p options
+#   p ARGV
+#
+# === Generating Help
+#
+# Gem::OptionParser can be used to automatically generate help for the commands you
+# write:
+#
+#   require 'rubygems/optparse/lib/optparse'
+#
+#   Options = Struct.new(:name)
+#
+#   class Parser
+#     def self.parse(options)
+#       args = Options.new("world")
+#
+#       opt_parser = Gem::OptionParser.new do |parser|
+#         parser.banner = "Usage: example.rb [options]"
+#
+#         parser.on("-nNAME", "--name=NAME", "Name to say hello to") do |n|
+#           args.name = n
+#         end
+#
+#         parser.on("-h", "--help", "Prints this help") do
+#           puts parser
+#           exit
+#         end
+#       end
+#
+#       opt_parser.parse!(options)
+#       return args
+#     end
+#   end
+#   options = Parser.parse %w[--help]
+#
+#   #=>
+#      # Usage: example.rb [options]
+#      #     -n, --name=NAME                  Name to say hello to
+#      #     -h, --help                       Prints this help
+#
+# === Required Arguments
+#
+# For options that require an argument, option specification strings may include an
+# option name in all caps. If an option is used without the required argument,
+# an exception will be raised.
+#
+#   require 'rubygems/optparse/lib/optparse'
+#
+#   options = {}
+#   Gem::OptionParser.new do |parser|
+#     parser.on("-r", "--require LIBRARY",
+#               "Require the LIBRARY before executing your script") do |lib|
+#       puts "You required #{lib}!"
+#     end
+#   end.parse!
+#
+# Used:
+#
+#   $ ruby optparse-test.rb -r
+#   optparse-test.rb:9:in `<main>': missing argument: -r (Gem::OptionParser::MissingArgument)
+#   $ ruby optparse-test.rb -r my-library
+#   You required my-library!
+#
+# === Type Coercion
+#
+# Gem::OptionParser supports the ability to coerce command line arguments
+# into objects for us.
+#
+# Gem::OptionParser comes with a few ready-to-use kinds of  type
+# coercion. They are:
+#
+# - Date  -- Anything accepted by +Date.parse+
+# - DateTime -- Anything accepted by +DateTime.parse+
+# - Time -- Anything accepted by +Time.httpdate+ or +Time.parse+
+# - URI  -- Anything accepted by +URI.parse+
+# - Shellwords -- Anything accepted by +Shellwords.shellwords+
+# - String -- Any non-empty string
+# - Integer -- Any integer. Will convert octal. (e.g. 124, -3, 040)
+# - Float -- Any float. (e.g. 10, 3.14, -100E+13)
+# - Numeric -- Any integer, float, or rational (1, 3.4, 1/3)
+# - DecimalInteger -- Like +Integer+, but no octal format.
+# - OctalInteger -- Like +Integer+, but no decimal format.
+# - DecimalNumeric -- Decimal integer or float.
+# - TrueClass --  Accepts '+, yes, true, -, no, false' and
+#   defaults as +true+
+# - FalseClass -- Same as +TrueClass+, but defaults to +false+
+# - Array -- Strings separated by ',' (e.g. 1,2,3)
+# - Regexp -- Regular expressions. Also includes options.
+#
+# We can also add our own coercions, which we will cover below.
+#
+# ==== Using Built-in Conversions
+#
+# As an example, the built-in +Time+ conversion is used. The other built-in
+# conversions behave in the same way.
+# Gem::OptionParser will attempt to parse the argument
+# as a +Time+. If it succeeds, that time will be passed to the
+# handler block. Otherwise, an exception will be raised.
+#
+#   require 'rubygems/optparse/lib/optparse'
+#   require 'rubygems/optparse/lib/optparse/time'
+#   Gem::OptionParser.new do |parser|
+#     parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
+#       p time
+#     end
+#   end.parse!
+#
+# Used:
+#
+#   $ ruby optparse-test.rb  -t nonsense
+#   ... invalid argument: -t nonsense (Gem::OptionParser::InvalidArgument)
+#   $ ruby optparse-test.rb  -t 10-11-12
+#   2010-11-12 00:00:00 -0500
+#   $ ruby optparse-test.rb  -t 9:30
+#   2014-08-13 09:30:00 -0400
+#
+# ==== Creating Custom Conversions
+#
+# The +accept+ method on Gem::OptionParser may be used to create converters.
+# It specifies which conversion block to call whenever a class is specified.
+# The example below uses it to fetch a +User+ object before the +on+ handler receives it.
+#
+#   require 'rubygems/optparse/lib/optparse'
+#
+#   User = Struct.new(:id, :name)
+#
+#   def find_user id
+#     not_found = ->{ raise "No User Found for id #{id}" }
+#     [ User.new(1, "Sam"),
+#       User.new(2, "Gandalf") ].find(not_found) do |u|
+#       u.id == id
+#     end
+#   end
+#
+#   op = Gem::OptionParser.new
+#   op.accept(User) do |user_id|
+#     find_user user_id.to_i
+#   end
+#
+#   op.on("--user ID", User) do |user|
+#     puts user
+#   end
+#
+#   op.parse!
+#
+# Used:
+#
+#   $ ruby optparse-test.rb --user 1
+#   #<struct User id=1, name="Sam">
+#   $ ruby optparse-test.rb --user 2
+#   #<struct User id=2, name="Gandalf">
+#   $ ruby optparse-test.rb --user 3
+#   optparse-test.rb:15:in `block in find_user': No User Found for id 3 (RuntimeError)
+#
+# === Store options to a Hash
+#
+# The +into+ option of +order+, +parse+ and so on methods stores command line options into a Hash.
+#
+#   require 'rubygems/optparse/lib/optparse'
+#
+#   options = {}
+#   Gem::OptionParser.new do |parser|
+#     parser.on('-a')
+#     parser.on('-b NUM', Integer)
+#     parser.on('-v', '--verbose')
+#   end.parse!(into: options)
+#
+#   p options
+#
+# Used:
+#
+#   $ ruby optparse-test.rb -a
+#   {:a=>true}
+#   $ ruby optparse-test.rb -a -v
+#   {:a=>true, :verbose=>true}
+#   $ ruby optparse-test.rb -a -b 100
+#   {:a=>true, :b=>100}
+#
+# === Complete example
+#
+# The following example is a complete Ruby program.  You can run it and see the
+# effect of specifying various options.  This is probably the best way to learn
+# the features of +optparse+.
+#
+#   require 'rubygems/optparse/lib/optparse'
+#   require 'rubygems/optparse/lib/optparse/time'
+#   require 'ostruct'
+#   require 'pp'
+#
+#   class OptparseExample
+#     Version = '1.0.0'
+#
+#     CODES = %w[iso-2022-jp shift_jis euc-jp utf8 binary]
+#     CODE_ALIASES = { "jis" => "iso-2022-jp", "sjis" => "shift_jis" }
+#
+#     class ScriptOptions
+#       attr_accessor :library, :inplace, :encoding, :transfer_type,
+#                     :verbose, :extension, :delay, :time, :record_separator,
+#                     :list
+#
+#       def initialize
+#         self.library = []
+#         self.inplace = false
+#         self.encoding = "utf8"
+#         self.transfer_type = :auto
+#         self.verbose = false
+#       end
+#
+#       def define_options(parser)
+#         parser.banner = "Usage: example.rb [options]"
+#         parser.separator ""
+#         parser.separator "Specific options:"
+#
+#         # add additional options
+#         perform_inplace_option(parser)
+#         delay_execution_option(parser)
+#         execute_at_time_option(parser)
+#         specify_record_separator_option(parser)
+#         list_example_option(parser)
+#         specify_encoding_option(parser)
+#         optional_option_argument_with_keyword_completion_option(parser)
+#         boolean_verbose_option(parser)
+#
+#         parser.separator ""
+#         parser.separator "Common options:"
+#         # No argument, shows at tail.  This will print an options summary.
+#         # Try it and see!
+#         parser.on_tail("-h", "--help", "Show this message") do
+#           puts parser
+#           exit
+#         end
+#         # Another typical switch to print the version.
+#         parser.on_tail("--version", "Show version") do
+#           puts Version
+#           exit
+#         end
+#       end
+#
+#       def perform_inplace_option(parser)
+#         # Specifies an optional option argument
+#         parser.on("-i", "--inplace [EXTENSION]",
+#                   "Edit ARGV files in place",
+#                   "(make backup if EXTENSION supplied)") do |ext|
+#           self.inplace = true
+#           self.extension = ext || ''
+#           self.extension.sub!(/\A\.?(?=.)/, ".")  # Ensure extension begins with dot.
+#         end
+#       end
+#
+#       def delay_execution_option(parser)
+#         # Cast 'delay' argument to a Float.
+#         parser.on("--delay N", Float, "Delay N seconds before executing") do |n|
+#           self.delay = n
+#         end
+#       end
+#
+#       def execute_at_time_option(parser)
+#         # Cast 'time' argument to a Time object.
+#         parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
+#           self.time = time
+#         end
+#       end
+#
+#       def specify_record_separator_option(parser)
+#         # Cast to octal integer.
+#         parser.on("-F", "--irs [OCTAL]", Gem::OptionParser::OctalInteger,
+#                   "Specify record separator (default \\0)") do |rs|
+#           self.record_separator = rs
+#         end
+#       end
+#
+#       def list_example_option(parser)
+#         # List of arguments.
+#         parser.on("--list x,y,z", Array, "Example 'list' of arguments") do |list|
+#           self.list = list
+#         end
+#       end
+#
+#       def specify_encoding_option(parser)
+#         # Keyword completion.  We are specifying a specific set of arguments (CODES
+#         # and CODE_ALIASES - notice the latter is a Hash), and the user may provide
+#         # the shortest unambiguous text.
+#         code_list = (CODE_ALIASES.keys + CODES).join(', ')
+#         parser.on("--code CODE", CODES, CODE_ALIASES, "Select encoding",
+#                   "(#{code_list})") do |encoding|
+#           self.encoding = encoding
+#         end
+#       end
+#
+#       def optional_option_argument_with_keyword_completion_option(parser)
+#         # Optional '--type' option argument with keyword completion.
+#         parser.on("--type [TYPE]", [:text, :binary, :auto],
+#                   "Select transfer type (text, binary, auto)") do |t|
+#           self.transfer_type = t
+#         end
+#       end
+#
+#       def boolean_verbose_option(parser)
+#         # Boolean switch.
+#         parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
+#           self.verbose = v
+#         end
+#       end
+#     end
+#
+#     #
+#     # Return a structure describing the options.
+#     #
+#     def parse(args)
+#       # The options specified on the command line will be collected in
+#       # *options*.
+#
+#       @options = ScriptOptions.new
+#       @args = Gem::OptionParser.new do |parser|
+#         @options.define_options(parser)
+#         parser.parse!(args)
+#       end
+#       @options
+#     end
+#
+#     attr_reader :parser, :options
+#   end  # class OptparseExample
+#
+#   example = OptparseExample.new
+#   options = example.parse(ARGV)
+#   pp options # example.options
+#   pp ARGV
+#
+# === Shell Completion
+#
+# For modern shells (e.g. bash, zsh, etc.), you can use shell
+# completion for command line options.
+#
+# === Further documentation
+#
+# The above examples, along with the accompanying
+# {Tutorial}[optparse/tutorial.rdoc],
+# should be enough to learn how to use this class.
+# If you have any questions, file a ticket at http://bugs.ruby-lang.org.
+#
+class Gem::OptionParser
+  Gem::OptionParser::Version = "0.2.0"
+
+  # :stopdoc:
+  NoArgument = [NO_ARGUMENT = :NONE, nil].freeze
+  RequiredArgument = [REQUIRED_ARGUMENT = :REQUIRED, true].freeze
+  OptionalArgument = [OPTIONAL_ARGUMENT = :OPTIONAL, false].freeze
+  # :startdoc:
+
+  #
+  # Keyword completion module.  This allows partial arguments to be specified
+  # and resolved against a list of acceptable values.
+  #
+  module Completion
+    def self.regexp(key, icase)
+      Regexp.new('\A' + Regexp.quote(key).gsub(/\w+\b/, '\&\w*'), icase)
+    end
+
+    def self.candidate(key, icase = false, pat = nil, &block)
+      pat ||= Completion.regexp(key, icase)
+      candidates = []
+      block.call do |k, *v|
+        (if Regexp === k
+           kn = ""
+           k === key
+         else
+           kn = defined?(k.id2name) ? k.id2name : k
+           pat === kn
+         end) or next
+        v << k if v.empty?
+        candidates << [k, v, kn]
+      end
+      candidates
+    end
+
+    def candidate(key, icase = false, pat = nil)
+      Completion.candidate(key, icase, pat, &method(:each))
+    end
+
+    public
+    def complete(key, icase = false, pat = nil)
+      candidates = candidate(key, icase, pat, &method(:each)).sort_by {|k, v, kn| kn.size}
+      if candidates.size == 1
+        canon, sw, * = candidates[0]
+      elsif candidates.size > 1
+        canon, sw, cn = candidates.shift
+        candidates.each do |k, v, kn|
+          next if sw == v
+          if String === cn and String === kn
+            if cn.rindex(kn, 0)
+              canon, sw, cn = k, v, kn
+              next
+            elsif kn.rindex(cn, 0)
+              next
+            end
+          end
+          throw :ambiguous, key
+        end
+      end
+      if canon
+        block_given? or return key, *sw
+        yield(key, *sw)
+      end
+    end
+
+    def convert(opt = nil, val = nil, *)
+      val
+    end
+  end
+
+
+  #
+  # Map from option/keyword string to object with completion.
+  #
+  class OptionMap < Hash
+    include Completion
+  end
+
+
+  #
+  # Individual switch class.  Not important to the user.
+  #
+  # Defined within Switch are several Switch-derived classes: NoArgument,
+  # RequiredArgument, etc.
+  #
+  class Switch
+    attr_reader :pattern, :conv, :short, :long, :arg, :desc, :block
+
+    #
+    # Guesses argument style from +arg+.  Returns corresponding
+    # Gem::OptionParser::Switch class (OptionalArgument, etc.).
+    #
+    def self.guess(arg)
+      case arg
+      when ""
+        t = self
+      when /\A=?\[/
+        t = Switch::OptionalArgument
+      when /\A\s+\[/
+        t = Switch::PlacedArgument
+      else
+        t = Switch::RequiredArgument
+      end
+      self >= t or incompatible_argument_styles(arg, t)
+      t
+    end
+
+    def self.incompatible_argument_styles(arg, t)
+      raise(ArgumentError, "#{arg}: incompatible argument styles\n  #{self}, #{t}",
+            ParseError.filter_backtrace(caller(2)))
+    end
+
+    def self.pattern
+      NilClass
+    end
+
+    def initialize(pattern = nil, conv = nil,
+                   short = nil, long = nil, arg = nil,
+                   desc = ([] if short or long), block = nil, &_block)
+      raise if Array === pattern
+      block ||= _block
+      @pattern, @conv, @short, @long, @arg, @desc, @block =
+        pattern, conv, short, long, arg, desc, block
+    end
+
+    #
+    # Parses +arg+ and returns rest of +arg+ and matched portion to the
+    # argument pattern. Yields when the pattern doesn't match substring.
+    #
+    def parse_arg(arg) # :nodoc:
+      pattern or return nil, [arg]
+      unless m = pattern.match(arg)
+        yield(InvalidArgument, arg)
+        return arg, []
+      end
+      if String === m
+        m = [s = m]
+      else
+        m = m.to_a
+        s = m[0]
+        return nil, m unless String === s
+      end
+      raise InvalidArgument, arg unless arg.rindex(s, 0)
+      return nil, m if s.length == arg.length
+      yield(InvalidArgument, arg) # didn't match whole arg
+      return arg[s.length..-1], m
+    end
+    private :parse_arg
+
+    #
+    # Parses argument, converts and returns +arg+, +block+ and result of
+    # conversion. Yields at semi-error condition instead of raising an
+    # exception.
+    #
+    def conv_arg(arg, val = []) # :nodoc:
+      if conv
+        val = conv.call(*val)
+      else
+        val = proc {|v| v}.call(*val)
+      end
+      return arg, block, val
+    end
+    private :conv_arg
+
+    #
+    # Produces the summary text. Each line of the summary is yielded to the
+    # block (without newline).
+    #
+    # +sdone+::  Already summarized short style options keyed hash.
+    # +ldone+::  Already summarized long style options keyed hash.
+    # +width+::  Width of left side (option part). In other words, the right
+    #            side (description part) starts after +width+ columns.
+    # +max+::    Maximum width of left side -> the options are filled within
+    #            +max+ columns.
+    # +indent+:: Prefix string indents all summarized lines.
+    #
+    def summarize(sdone = {}, ldone = {}, width = 1, max = width - 1, indent = "")
+      sopts, lopts = [], [], nil
+      @short.each {|s| sdone.fetch(s) {sopts << s}; sdone[s] = true} if @short
+      @long.each {|s| ldone.fetch(s) {lopts << s}; ldone[s] = true} if @long
+      return if sopts.empty? and lopts.empty? # completely hidden
+
+      left = [sopts.join(', ')]
+      right = desc.dup
+
+      while s = lopts.shift
+        l = left[-1].length + s.length
+        l += arg.length if left.size == 1 && arg
+        l < max or sopts.empty? or left << +''
+        left[-1] << (left[-1].empty? ? ' ' * 4 : ', ') << s
+      end
+
+      if arg
+        left[0] << (left[1] ? arg.sub(/\A(\[?)=/, '\1') + ',' : arg)
+      end
+      mlen = left.collect {|ss| ss.length}.max.to_i
+      while mlen > width and l = left.shift
+        mlen = left.collect {|ss| ss.length}.max.to_i if l.length == mlen
+        if l.length < width and (r = right[0]) and !r.empty?
+          l = l.to_s.ljust(width) + ' ' + r
+          right.shift
+        end
+        yield(indent + l)
+      end
+
+      while begin l = left.shift; r = right.shift; l or r end
+        l = l.to_s.ljust(width) + ' ' + r if r and !r.empty?
+        yield(indent + l)
+      end
+
+      self
+    end
+
+    def add_banner(to)  # :nodoc:
+      unless @short or @long
+        s = desc.join
+        to << " [" + s + "]..." unless s.empty?
+      end
+      to
+    end
+
+    def match_nonswitch?(str)  # :nodoc:
+      @pattern =~ str unless @short or @long
+    end
+
+    #
+    # Main name of the switch.
+    #
+    def switch_name
+      (long.first || short.first).sub(/\A-+(?:\[no-\])?/, '')
+    end
+
+    def compsys(sdone, ldone)   # :nodoc:
+      sopts, lopts = [], []
+      @short.each {|s| sdone.fetch(s) {sopts << s}; sdone[s] = true} if @short
+      @long.each {|s| ldone.fetch(s) {lopts << s}; ldone[s] = true} if @long
+      return if sopts.empty? and lopts.empty? # completely hidden
+
+      (sopts+lopts).each do |opt|
+        # "(-x -c -r)-l[left justify]"
+        if /^--\[no-\](.+)$/ =~ opt
+          o = $1
+          yield("--#{o}", desc.join(""))
+          yield("--no-#{o}", desc.join(""))
+        else
+          yield("#{opt}", desc.join(""))
+        end
+      end
+    end
+
+    def pretty_print_contents(q) # :nodoc:
+      if @block
+        q.text ":" + @block.source_location.join(":") + ":"
+        first = false
+      else
+        first = true
+      end
+      [@short, @long].each do |list|
+        list.each do |opt|
+          if first
+            q.text ":"
+            first = false
+          end
+          q.breakable
+          q.text opt
+        end
+      end
+    end
+
+    def pretty_print(q)         # :nodoc:
+      q.object_group(self) {pretty_print_contents(q)}
+    end
+
+    #
+    # Switch that takes no arguments.
+    #
+    class NoArgument < self
+
+      #
+      # Raises an exception if any arguments given.
+      #
+      def parse(arg, argv)
+        yield(NeedlessArgument, arg) if arg
+        conv_arg(arg)
+      end
+
+      def self.incompatible_argument_styles(*)
+      end
+
+      def self.pattern
+        Object
+      end
+
+      def pretty_head           # :nodoc:
+        "NoArgument"
+      end
+    end
+
+    #
+    # Switch that takes an argument.
+    #
+    class RequiredArgument < self
+
+      #
+      # Raises an exception if argument is not present.
+      #
+      def parse(arg, argv)
+        unless arg
+          raise MissingArgument if argv.empty?
+          arg = argv.shift
+        end
+        conv_arg(*parse_arg(arg, &method(:raise)))
+      end
+
+      def pretty_head           # :nodoc:
+        "Required"
+      end
+    end
+
+    #
+    # Switch that can omit argument.
+    #
+    class OptionalArgument < self
+
+      #
+      # Parses argument if given, or uses default value.
+      #
+      def parse(arg, argv, &error)
+        if arg
+          conv_arg(*parse_arg(arg, &error))
+        else
+          conv_arg(arg)
+        end
+      end
+
+      def pretty_head           # :nodoc:
+        "Optional"
+      end
+    end
+
+    #
+    # Switch that takes an argument, which does not begin with '-'.
+    #
+    class PlacedArgument < self
+
+      #
+      # Returns nil if argument is not present or begins with '-'.
+      #
+      def parse(arg, argv, &error)
+        if !(val = arg) and (argv.empty? or /\A-/ =~ (val = argv[0]))
+          return nil, block, nil
+        end
+        opt = (val = parse_arg(val, &error))[1]
+        val = conv_arg(*val)
+        if opt and !arg
+          argv.shift
+        else
+          val[0] = nil
+        end
+        val
+      end
+
+      def pretty_head           # :nodoc:
+        "Placed"
+      end
+    end
+  end
+
+  #
+  # Simple option list providing mapping from short and/or long option
+  # string to Gem::OptionParser::Switch and mapping from acceptable argument to
+  # matching pattern and converter pair. Also provides summary feature.
+  #
+  class List
+    # Map from acceptable argument types to pattern and converter pairs.
+    attr_reader :atype
+
+    # Map from short style option switches to actual switch objects.
+    attr_reader :short
+
+    # Map from long style option switches to actual switch objects.
+    attr_reader :long
+
+    # List of all switches and summary string.
+    attr_reader :list
+
+    #
+    # Just initializes all instance variables.
+    #
+    def initialize
+      @atype = {}
+      @short = OptionMap.new
+      @long = OptionMap.new
+      @list = []
+    end
+
+    def pretty_print(q)         # :nodoc:
+      q.group(1, "(", ")") do
+        @list.each do |sw|
+          next unless Switch === sw
+          q.group(1, "(" + sw.pretty_head, ")") do
+            sw.pretty_print_contents(q)
+          end
+        end
+      end
+    end
+
+    #
+    # See Gem::OptionParser.accept.
+    #
+    def accept(t, pat = /.*/m, &block)
+      if pat
+        pat.respond_to?(:match) or
+          raise TypeError, "has no `match'", ParseError.filter_backtrace(caller(2))
+      else
+        pat = t if t.respond_to?(:match)
+      end
+      unless block
+        block = pat.method(:convert).to_proc if pat.respond_to?(:convert)
+      end
+      @atype[t] = [pat, block]
+    end
+
+    #
+    # See Gem::OptionParser.reject.
+    #
+    def reject(t)
+      @atype.delete(t)
+    end
+
+    #
+    # Adds +sw+ according to +sopts+, +lopts+ and +nlopts+.
+    #
+    # +sw+::     Gem::OptionParser::Switch instance to be added.
+    # +sopts+::  Short style option list.
+    # +lopts+::  Long style option list.
+    # +nlopts+:: Negated long style options list.
+    #
+    def update(sw, sopts, lopts, nsw = nil, nlopts = nil) # :nodoc:
+      sopts.each {|o| @short[o] = sw} if sopts
+      lopts.each {|o| @long[o] = sw} if lopts
+      nlopts.each {|o| @long[o] = nsw} if nsw and nlopts
+      used = @short.invert.update(@long.invert)
+      @list.delete_if {|o| Switch === o and !used[o]}
+    end
+    private :update
+
+    #
+    # Inserts +switch+ at the head of the list, and associates short, long
+    # and negated long options. Arguments are:
+    #
+    # +switch+::      Gem::OptionParser::Switch instance to be inserted.
+    # +short_opts+::  List of short style options.
+    # +long_opts+::   List of long style options.
+    # +nolong_opts+:: List of long style options with "no-" prefix.
+    #
+    #   prepend(switch, short_opts, long_opts, nolong_opts)
+    #
+    def prepend(*args)
+      update(*args)
+      @list.unshift(args[0])
+    end
+
+    #
+    # Appends +switch+ at the tail of the list, and associates short, long
+    # and negated long options. Arguments are:
+    #
+    # +switch+::      Gem::OptionParser::Switch instance to be inserted.
+    # +short_opts+::  List of short style options.
+    # +long_opts+::   List of long style options.
+    # +nolong_opts+:: List of long style options with "no-" prefix.
+    #
+    #   append(switch, short_opts, long_opts, nolong_opts)
+    #
+    def append(*args)
+      update(*args)
+      @list.push(args[0])
+    end
+
+    #
+    # Searches +key+ in +id+ list. The result is returned or yielded if a
+    # block is given. If it isn't found, nil is returned.
+    #
+    def search(id, key)
+      if list = __send__(id)
+        val = list.fetch(key) {return nil}
+        block_given? ? yield(val) : val
+      end
+    end
+
+    #
+    # Searches list +id+ for +opt+ and the optional patterns for completion
+    # +pat+. If +icase+ is true, the search is case insensitive. The result
+    # is returned or yielded if a block is given. If it isn't found, nil is
+    # returned.
+    #
+    def complete(id, opt, icase = false, *pat, &block)
+      __send__(id).complete(opt, icase, *pat, &block)
+    end
+
+    def get_candidates(id)
+      yield __send__(id).keys
+    end
+
+    #
+    # Iterates over each option, passing the option to the +block+.
+    #
+    def each_option(&block)
+      list.each(&block)
+    end
+
+    #
+    # Creates the summary table, passing each line to the +block+ (without
+    # newline). The arguments +args+ are passed along to the summarize
+    # method which is called on every option.
+    #
+    def summarize(*args, &block)
+      sum = []
+      list.reverse_each do |opt|
+        if opt.respond_to?(:summarize) # perhaps Gem::OptionParser::Switch
+          s = []
+          opt.summarize(*args) {|l| s << l}
+          sum.concat(s.reverse)
+        elsif !opt or opt.empty?
+          sum << ""
+        elsif opt.respond_to?(:each_line)
+          sum.concat([*opt.each_line].reverse)
+        else
+          sum.concat([*opt.each].reverse)
+        end
+      end
+      sum.reverse_each(&block)
+    end
+
+    def add_banner(to)  # :nodoc:
+      list.each do |opt|
+        if opt.respond_to?(:add_banner)
+          opt.add_banner(to)
+        end
+      end
+      to
+    end
+
+    def compsys(*args, &block)  # :nodoc:
+      list.each do |opt|
+        if opt.respond_to?(:compsys)
+          opt.compsys(*args, &block)
+        end
+      end
+    end
+  end
+
+  #
+  # Hash with completion search feature. See Gem::OptionParser::Completion.
+  #
+  class CompletingHash < Hash
+    include Completion
+
+    #
+    # Completion for hash key.
+    #
+    def match(key)
+      *values = fetch(key) {
+        raise AmbiguousArgument, catch(:ambiguous) {return complete(key)}
+      }
+      return key, *values
+    end
+  end
+
+  # :stopdoc:
+
+  #
+  # Enumeration of acceptable argument styles. Possible values are:
+  #
+  # NO_ARGUMENT::       The switch takes no arguments. (:NONE)
+  # REQUIRED_ARGUMENT:: The switch requires an argument. (:REQUIRED)
+  # OPTIONAL_ARGUMENT:: The switch requires an optional argument. (:OPTIONAL)
+  #
+  # Use like --switch=argument (long style) or -Xargument (short style). For
+  # short style, only portion matched to argument pattern is treated as
+  # argument.
+  #
+  ArgumentStyle = {}
+  NoArgument.each {|el| ArgumentStyle[el] = Switch::NoArgument}
+  RequiredArgument.each {|el| ArgumentStyle[el] = Switch::RequiredArgument}
+  OptionalArgument.each {|el| ArgumentStyle[el] = Switch::OptionalArgument}
+  ArgumentStyle.freeze
+
+  #
+  # Switches common used such as '--', and also provides default
+  # argument classes
+  #
+  DefaultList = List.new
+  DefaultList.short['-'] = Switch::NoArgument.new {}
+  DefaultList.long[''] = Switch::NoArgument.new {throw :terminate}
+
+
+  COMPSYS_HEADER = <<'XXX'      # :nodoc:
+
+typeset -A opt_args
+local context state line
+
+_arguments -s -S \
+XXX
+
+  def compsys(to, name = File.basename($0)) # :nodoc:
+    to << "#compdef #{name}\n"
+    to << COMPSYS_HEADER
+    visit(:compsys, {}, {}) {|o, d|
+      to << %Q[  "#{o}[#{d.gsub(/[\"\[\]]/, '\\\\\&')}]" \\\n]
+    }
+    to << "  '*:file:_files' && return 0\n"
+  end
+
+  #
+  # Default options for ARGV, which never appear in option summary.
+  #
+  Officious = {}
+
+  #
+  # --help
+  # Shows option summary.
+  #
+  Officious['help'] = proc do |parser|
+    Switch::NoArgument.new do |arg|
+      puts parser.help
+      exit
+    end
+  end
+
+  #
+  # --*-completion-bash=WORD
+  # Shows candidates for command line completion.
+  #
+  Officious['*-completion-bash'] = proc do |parser|
+    Switch::RequiredArgument.new do |arg|
+      puts parser.candidate(arg)
+      exit
+    end
+  end
+
+  #
+  # --*-completion-zsh[=NAME:FILE]
+  # Creates zsh completion file.
+  #
+  Officious['*-completion-zsh'] = proc do |parser|
+    Switch::OptionalArgument.new do |arg|
+      parser.compsys(STDOUT, arg)
+      exit
+    end
+  end
+
+  #
+  # --version
+  # Shows version string if Version is defined.
+  #
+  Officious['version'] = proc do |parser|
+    Switch::OptionalArgument.new do |pkg|
+      if pkg
+        begin
+          require 'rubygems/optparse/lib/optparse/version'
+        rescue LoadError
+        else
+          show_version(*pkg.split(/,/)) or
+            abort("#{parser.program_name}: no version found in package #{pkg}")
+          exit
+        end
+      end
+      v = parser.ver or abort("#{parser.program_name}: version unknown")
+      puts v
+      exit
+    end
+  end
+
+  # :startdoc:
+
+  #
+  # Class methods
+  #
+
+  #
+  # Initializes a new instance and evaluates the optional block in context
+  # of the instance. Arguments +args+ are passed to #new, see there for
+  # description of parameters.
+  #
+  # This method is *deprecated*, its behavior corresponds to the older #new
+  # method.
+  #
+  def self.with(*args, &block)
+    opts = new(*args)
+    opts.instance_eval(&block)
+    opts
+  end
+
+  #
+  # Returns an incremented value of +default+ according to +arg+.
+  #
+  def self.inc(arg, default = nil)
+    case arg
+    when Integer
+      arg.nonzero?
+    when nil
+      default.to_i + 1
+    end
+  end
+  def inc(*args)
+    self.class.inc(*args)
+  end
+
+  #
+  # Initializes the instance and yields itself if called with a block.
+  #
+  # +banner+:: Banner message.
+  # +width+::  Summary width.
+  # +indent+:: Summary indent.
+  #
+  def initialize(banner = nil, width = 32, indent = ' ' * 4)
+    @stack = [DefaultList, List.new, List.new]
+    @program_name = nil
+    @banner = banner
+    @summary_width = width
+    @summary_indent = indent
+    @default_argv = ARGV
+    @require_exact = false
+    add_officious
+    yield self if block_given?
+  end
+
+  def add_officious  # :nodoc:
+    list = base()
+    Officious.each do |opt, block|
+      list.long[opt] ||= block.call(self)
+    end
+  end
+
+  #
+  # Terminates option parsing. Optional parameter +arg+ is a string pushed
+  # back to be the first non-option argument.
+  #
+  def terminate(arg = nil)
+    self.class.terminate(arg)
+  end
+  def self.terminate(arg = nil)
+    throw :terminate, arg
+  end
+
+  @stack = [DefaultList]
+  def self.top() DefaultList end
+
+  #
+  # Directs to accept specified class +t+. The argument string is passed to
+  # the block in which it should be converted to the desired class.
+  #
+  # +t+::   Argument class specifier, any object including Class.
+  # +pat+:: Pattern for argument, defaults to +t+ if it responds to match.
+  #
+  #   accept(t, pat, &block)
+  #
+  def accept(*args, &blk) top.accept(*args, &blk) end
+  #
+  # See #accept.
+  #
+  def self.accept(*args, &blk) top.accept(*args, &blk) end
+
+  #
+  # Directs to reject specified class argument.
+  #
+  # +t+:: Argument class specifier, any object including Class.
+  #
+  #   reject(t)
+  #
+  def reject(*args, &blk) top.reject(*args, &blk) end
+  #
+  # See #reject.
+  #
+  def self.reject(*args, &blk) top.reject(*args, &blk) end
+
+  #
+  # Instance methods
+  #
+
+  # Heading banner preceding summary.
+  attr_writer :banner
+
+  # Program name to be emitted in error message and default banner,
+  # defaults to $0.
+  attr_writer :program_name
+
+  # Width for option list portion of summary. Must be Numeric.
+  attr_accessor :summary_width
+
+  # Indentation for summary. Must be String (or have + String method).
+  attr_accessor :summary_indent
+
+  # Strings to be parsed in default.
+  attr_accessor :default_argv
+
+  # Whether to require that options match exactly (disallows providing
+  # abbreviated long option as short option).
+  attr_accessor :require_exact
+
+  #
+  # Heading banner preceding summary.
+  #
+  def banner
+    unless @banner
+      @banner = +"Usage: #{program_name} [options]"
+      visit(:add_banner, @banner)
+    end
+    @banner
+  end
+
+  #
+  # Program name to be emitted in error message and default banner, defaults
+  # to $0.
+  #
+  def program_name
+    @program_name || File.basename($0, '.*')
+  end
+
+  # for experimental cascading :-)
+  alias set_banner banner=
+  alias set_program_name program_name=
+  alias set_summary_width summary_width=
+  alias set_summary_indent summary_indent=
+
+  # Version
+  attr_writer :version
+  # Release code
+  attr_writer :release
+
+  #
+  # Version
+  #
+  def version
+    (defined?(@version) && @version) || (defined?(::Version) && ::Version)
+  end
+
+  #
+  # Release code
+  #
+  def release
+    (defined?(@release) && @release) || (defined?(::Release) && ::Release) || (defined?(::RELEASE) && ::RELEASE)
+  end
+
+  #
+  # Returns version string from program_name, version and release.
+  #
+  def ver
+    if v = version
+      str = +"#{program_name} #{[v].join('.')}"
+      str << " (#{v})" if v = release
+      str
+    end
+  end
+
+  def warn(mesg = $!)
+    super("#{program_name}: #{mesg}")
+  end
+
+  def abort(mesg = $!)
+    super("#{program_name}: #{mesg}")
+  end
+
+  #
+  # Subject of #on / #on_head, #accept / #reject
+  #
+  def top
+    @stack[-1]
+  end
+
+  #
+  # Subject of #on_tail.
+  #
+  def base
+    @stack[1]
+  end
+
+  #
+  # Pushes a new List.
+  #
+  def new
+    @stack.push(List.new)
+    if block_given?
+      yield self
+    else
+      self
+    end
+  end
+
+  #
+  # Removes the last List.
+  #
+  def remove
+    @stack.pop
+  end
+
+  #
+  # Puts option summary into +to+ and returns +to+. Yields each line if
+  # a block is given.
+  #
+  # +to+:: Output destination, which must have method <<. Defaults to [].
+  # +width+:: Width of left side, defaults to @summary_width.
+  # +max+:: Maximum length allowed for left side, defaults to +width+ - 1.
+  # +indent+:: Indentation, defaults to @summary_indent.
+  #
+  def summarize(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &blk)
+    nl = "\n"
+    blk ||= proc {|l| to << (l.index(nl, -1) ? l : l + nl)}
+    visit(:summarize, {}, {}, width, max, indent, &blk)
+    to
+  end
+
+  #
+  # Returns option summary string.
+  #
+  def help; summarize("#{banner}".sub(/\n?\z/, "\n")) end
+  alias to_s help
+
+  def pretty_print(q)           # :nodoc:
+    q.object_group(self) do
+      first = true
+      if @stack.size > 2
+        @stack.each_with_index do |s, i|
+          next if i < 2
+          next if s.list.empty?
+          if first
+            first = false
+            q.text ":"
+          end
+          q.breakable
+          s.pretty_print(q)
+        end
+      end
+    end
+  end
+
+  def inspect                   # :nodoc:
+    require 'pp'
+    pretty_print_inspect
+  end
+
+  #
+  # Returns option summary list.
+  #
+  def to_a; summarize("#{banner}".split(/^/)) end
+
+  #
+  # Checks if an argument is given twice, in which case an ArgumentError is
+  # raised. Called from Gem::OptionParser#switch only.
+  #
+  # +obj+:: New argument.
+  # +prv+:: Previously specified argument.
+  # +msg+:: Exception message.
+  #
+  def notwice(obj, prv, msg) # :nodoc:
+    unless !prv or prv == obj
+      raise(ArgumentError, "argument #{msg} given twice: #{obj}",
+            ParseError.filter_backtrace(caller(2)))
+    end
+    obj
+  end
+  private :notwice
+
+  SPLAT_PROC = proc {|*a| a.length <= 1 ? a.first : a} # :nodoc:
+
+  # :call-seq:
+  #   make_switch(params, block = nil)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  def make_switch(opts, block = nil)
+    short, long, nolong, style, pattern, conv, not_pattern, not_conv, not_style = [], [], []
+    ldesc, sdesc, desc, arg = [], [], []
+    default_style = Switch::NoArgument
+    default_pattern = nil
+    klass = nil
+    q, a = nil
+    has_arg = false
+
+    opts.each do |o|
+      # argument class
+      next if search(:atype, o) do |pat, c|
+        klass = notwice(o, klass, 'type')
+        if not_style and not_style != Switch::NoArgument
+          not_pattern, not_conv = pat, c
+        else
+          default_pattern, conv = pat, c
+        end
+      end
+
+      # directly specified pattern(any object possible to match)
+      if (!(String === o || Symbol === o)) and o.respond_to?(:match)
+        pattern = notwice(o, pattern, 'pattern')
+        if pattern.respond_to?(:convert)
+          conv = pattern.method(:convert).to_proc
+        else
+          conv = SPLAT_PROC
+        end
+        next
+      end
+
+      # anything others
+      case o
+      when Proc, Method
+        block = notwice(o, block, 'block')
+      when Array, Hash
+        case pattern
+        when CompletingHash
+        when nil
+          pattern = CompletingHash.new
+          conv = pattern.method(:convert).to_proc if pattern.respond_to?(:convert)
+        else
+          raise ArgumentError, "argument pattern given twice"
+        end
+        o.each {|pat, *v| pattern[pat] = v.fetch(0) {pat}}
+      when Module
+        raise ArgumentError, "unsupported argument type: #{o}", ParseError.filter_backtrace(caller(4))
+      when *ArgumentStyle.keys
+        style = notwice(ArgumentStyle[o], style, 'style')
+      when /^--no-([^\[\]=\s]*)(.+)?/
+        q, a = $1, $2
+        o = notwice(a ? Object : TrueClass, klass, 'type')
+        not_pattern, not_conv = search(:atype, o) unless not_style
+        not_style = (not_style || default_style).guess(arg = a) if a
+        default_style = Switch::NoArgument
+        default_pattern, conv = search(:atype, FalseClass) unless default_pattern
+        ldesc << "--no-#{q}"
+        (q = q.downcase).tr!('_', '-')
+        long << "no-#{q}"
+        nolong << q
+      when /^--\[no-\]([^\[\]=\s]*)(.+)?/
+        q, a = $1, $2
+        o = notwice(a ? Object : TrueClass, klass, 'type')
+        if a
+          default_style = default_style.guess(arg = a)
+          default_pattern, conv = search(:atype, o) unless default_pattern
+        end
+        ldesc << "--[no-]#{q}"
+        (o = q.downcase).tr!('_', '-')
+        long << o
+        not_pattern, not_conv = search(:atype, FalseClass) unless not_style
+        not_style = Switch::NoArgument
+        nolong << "no-#{o}"
+      when /^--([^\[\]=\s]*)(.+)?/
+        q, a = $1, $2
+        if a
+          o = notwice(NilClass, klass, 'type')
+          default_style = default_style.guess(arg = a)
+          default_pattern, conv = search(:atype, o) unless default_pattern
+        end
+        ldesc << "--#{q}"
+        (o = q.downcase).tr!('_', '-')
+        long << o
+      when /^-(\[\^?\]?(?:[^\\\]]|\\.)*\])(.+)?/
+        q, a = $1, $2
+        o = notwice(Object, klass, 'type')
+        if a
+          default_style = default_style.guess(arg = a)
+          default_pattern, conv = search(:atype, o) unless default_pattern
+        else
+          has_arg = true
+        end
+        sdesc << "-#{q}"
+        short << Regexp.new(q)
+      when /^-(.)(.+)?/
+        q, a = $1, $2
+        if a
+          o = notwice(NilClass, klass, 'type')
+          default_style = default_style.guess(arg = a)
+          default_pattern, conv = search(:atype, o) unless default_pattern
+        end
+        sdesc << "-#{q}"
+        short << q
+      when /^=/
+        style = notwice(default_style.guess(arg = o), style, 'style')
+        default_pattern, conv = search(:atype, Object) unless default_pattern
+      else
+        desc.push(o)
+      end
+    end
+
+    default_pattern, conv = search(:atype, default_style.pattern) unless default_pattern
+    if !(short.empty? and long.empty?)
+      if has_arg and default_style == Switch::NoArgument
+        default_style = Switch::RequiredArgument
+      end
+      s = (style || default_style).new(pattern || default_pattern,
+                                       conv, sdesc, ldesc, arg, desc, block)
+    elsif !block
+      if style or pattern
+        raise ArgumentError, "no switch given", ParseError.filter_backtrace(caller)
+      end
+      s = desc
+    else
+      short << pattern
+      s = (style || default_style).new(pattern,
+                                       conv, nil, nil, arg, desc, block)
+    end
+    return s, short, long,
+      (not_style.new(not_pattern, not_conv, sdesc, ldesc, nil, desc, block) if not_style),
+      nolong
+  end
+
+  # :call-seq:
+  #   define(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  def define(*opts, &block)
+    top.append(*(sw = make_switch(opts, block)))
+    sw[0]
+  end
+
+  # :call-seq:
+  #   on(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  def on(*opts, &block)
+    define(*opts, &block)
+    self
+  end
+  alias def_option define
+
+  # :call-seq:
+  #   define_head(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  def define_head(*opts, &block)
+    top.prepend(*(sw = make_switch(opts, block)))
+    sw[0]
+  end
+
+  # :call-seq:
+  #   on_head(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  # The new option is added at the head of the summary.
+  #
+  def on_head(*opts, &block)
+    define_head(*opts, &block)
+    self
+  end
+  alias def_head_option define_head
+
+  # :call-seq:
+  #   define_tail(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  def define_tail(*opts, &block)
+    base.append(*(sw = make_switch(opts, block)))
+    sw[0]
+  end
+
+  #
+  # :call-seq:
+  #   on_tail(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  # The new option is added at the tail of the summary.
+  #
+  def on_tail(*opts, &block)
+    define_tail(*opts, &block)
+    self
+  end
+  alias def_tail_option define_tail
+
+  #
+  # Add separator in summary.
+  #
+  def separator(string)
+    top.append(string, nil, nil)
+  end
+
+  #
+  # Parses command line arguments +argv+ in order. When a block is given,
+  # each non-option argument is yielded. When optional +into+ keyword
+  # argument is provided, the parsed option values are stored there via
+  # <code>[]=</code> method (so it can be Hash, or OpenStruct, or other
+  # similar object).
+  #
+  # Returns the rest of +argv+ left unparsed.
+  #
+  def order(*argv, into: nil, &nonopt)
+    argv = argv[0].dup if argv.size == 1 and Array === argv[0]
+    order!(argv, into: into, &nonopt)
+  end
+
+  #
+  # Same as #order, but removes switches destructively.
+  # Non-option arguments remain in +argv+.
+  #
+  def order!(argv = default_argv, into: nil, &nonopt)
+    setter = ->(name, val) {into[name.to_sym] = val} if into
+    parse_in_order(argv, setter, &nonopt)
+  end
+
+  def parse_in_order(argv = default_argv, setter = nil, &nonopt)  # :nodoc:
+    opt, arg, val, rest = nil
+    nonopt ||= proc {|a| throw :terminate, a}
+    argv.unshift(arg) if arg = catch(:terminate) {
+      while arg = argv.shift
+        case arg
+        # long option
+        when /\A--([^=]*)(?:=(.*))?/m
+          opt, rest = $1, $2
+          opt.tr!('_', '-')
+          begin
+            sw, = complete(:long, opt, true)
+            if require_exact && !sw.long.include?(arg)
+              raise InvalidOption, arg
+            end
+          rescue ParseError
+            raise $!.set_option(arg, true)
+          end
+          begin
+            opt, cb, val = sw.parse(rest, argv) {|*exc| raise(*exc)}
+            val = cb.call(val) if cb
+            setter.call(sw.switch_name, val) if setter
+          rescue ParseError
+            raise $!.set_option(arg, rest)
+          end
+
+        # short option
+        when /\A-(.)((=).*|.+)?/m
+          eq, rest, opt = $3, $2, $1
+          has_arg, val = eq, rest
+          begin
+            sw, = search(:short, opt)
+            unless sw
+              begin
+                sw, = complete(:short, opt)
+                # short option matched.
+                val = arg.delete_prefix('-')
+                has_arg = true
+              rescue InvalidOption
+                raise if require_exact
+                # if no short options match, try completion with long
+                # options.
+                sw, = complete(:long, opt)
+                eq ||= !rest
+              end
+            end
+          rescue ParseError
+            raise $!.set_option(arg, true)
+          end
+          begin
+            opt, cb, val = sw.parse(val, argv) {|*exc| raise(*exc) if eq}
+          rescue ParseError
+            raise $!.set_option(arg, arg.length > 2)
+          else
+            raise InvalidOption, arg if has_arg and !eq and arg == "-#{opt}"
+          end
+          begin
+            argv.unshift(opt) if opt and (!rest or (opt = opt.sub(/\A-*/, '-')) != '-')
+            val = cb.call(val) if cb
+            setter.call(sw.switch_name, val) if setter
+          rescue ParseError
+            raise $!.set_option(arg, arg.length > 2)
+          end
+
+        # non-option argument
+        else
+          catch(:prune) do
+            visit(:each_option) do |sw0|
+              sw = sw0
+              sw.block.call(arg) if Switch === sw and sw.match_nonswitch?(arg)
+            end
+            nonopt.call(arg)
+          end
+        end
+      end
+
+      nil
+    }
+
+    visit(:search, :short, nil) {|sw| sw.block.call(*argv) if !sw.pattern}
+
+    argv
+  end
+  private :parse_in_order
+
+  #
+  # Parses command line arguments +argv+ in permutation mode and returns
+  # list of non-option arguments. When optional +into+ keyword
+  # argument is provided, the parsed option values are stored there via
+  # <code>[]=</code> method (so it can be Hash, or OpenStruct, or other
+  # similar object).
+  #
+  def permute(*argv, into: nil)
+    argv = argv[0].dup if argv.size == 1 and Array === argv[0]
+    permute!(argv, into: into)
+  end
+
+  #
+  # Same as #permute, but removes switches destructively.
+  # Non-option arguments remain in +argv+.
+  #
+  def permute!(argv = default_argv, into: nil)
+    nonopts = []
+    order!(argv, into: into, &nonopts.method(:<<))
+    argv[0, 0] = nonopts
+    argv
+  end
+
+  #
+  # Parses command line arguments +argv+ in order when environment variable
+  # POSIXLY_CORRECT is set, and in permutation mode otherwise.
+  # When optional +into+ keyword argument is provided, the parsed option
+  # values are stored there via <code>[]=</code> method (so it can be Hash,
+  # or OpenStruct, or other similar object).
+  #
+  def parse(*argv, into: nil)
+    argv = argv[0].dup if argv.size == 1 and Array === argv[0]
+    parse!(argv, into: into)
+  end
+
+  #
+  # Same as #parse, but removes switches destructively.
+  # Non-option arguments remain in +argv+.
+  #
+  def parse!(argv = default_argv, into: nil)
+    if ENV.include?('POSIXLY_CORRECT')
+      order!(argv, into: into)
+    else
+      permute!(argv, into: into)
+    end
+  end
+
+  #
+  # Wrapper method for getopts.rb.
+  #
+  #   params = ARGV.getopts("ab:", "foo", "bar:", "zot:Z;zot option")
+  #   # params["a"] = true   # -a
+  #   # params["b"] = "1"    # -b1
+  #   # params["foo"] = "1"  # --foo
+  #   # params["bar"] = "x"  # --bar x
+  #   # params["zot"] = "z"  # --zot Z
+  #
+  def getopts(*args)
+    argv = Array === args.first ? args.shift : default_argv
+    single_options, *long_options = *args
+
+    result = {}
+
+    single_options.scan(/(.)(:)?/) do |opt, val|
+      if val
+        result[opt] = nil
+        define("-#{opt} VAL")
+      else
+        result[opt] = false
+        define("-#{opt}")
+      end
+    end if single_options
+
+    long_options.each do |arg|
+      arg, desc = arg.split(';', 2)
+      opt, val = arg.split(':', 2)
+      if val
+        result[opt] = val.empty? ? nil : val
+        define("--#{opt}=#{result[opt] || "VAL"}", *[desc].compact)
+      else
+        result[opt] = false
+        define("--#{opt}", *[desc].compact)
+      end
+    end
+
+    parse_in_order(argv, result.method(:[]=))
+    result
+  end
+
+  #
+  # See #getopts.
+  #
+  def self.getopts(*args)
+    new.getopts(*args)
+  end
+
+  #
+  # Traverses @stack, sending each element method +id+ with +args+ and
+  # +block+.
+  #
+  def visit(id, *args, &block) # :nodoc:
+    @stack.reverse_each do |el|
+      el.__send__(id, *args, &block)
+    end
+    nil
+  end
+  private :visit
+
+  #
+  # Searches +key+ in @stack for +id+ hash and returns or yields the result.
+  #
+  def search(id, key) # :nodoc:
+    block_given = block_given?
+    visit(:search, id, key) do |k|
+      return block_given ? yield(k) : k
+    end
+  end
+  private :search
+
+  #
+  # Completes shortened long style option switch and returns pair of
+  # canonical switch and switch descriptor Gem::OptionParser::Switch.
+  #
+  # +typ+::   Searching table.
+  # +opt+::   Searching key.
+  # +icase+:: Search case insensitive if true.
+  # +pat+::   Optional pattern for completion.
+  #
+  def complete(typ, opt, icase = false, *pat) # :nodoc:
+    if pat.empty?
+      search(typ, opt) {|sw| return [sw, opt]} # exact match or...
+    end
+    ambiguous = catch(:ambiguous) {
+      visit(:complete, typ, opt, icase, *pat) {|o, *sw| return sw}
+    }
+    exc = ambiguous ? AmbiguousOption : InvalidOption
+    raise exc.new(opt, additional: self.method(:additional_message).curry[typ])
+  end
+  private :complete
+
+  #
+  # Returns additional info.
+  #
+  def additional_message(typ, opt)
+    return unless typ and opt and defined?(DidYouMean::SpellChecker)
+    all_candidates = []
+    visit(:get_candidates, typ) do |candidates|
+      all_candidates.concat(candidates)
+    end
+    all_candidates.select! {|cand| cand.is_a?(String) }
+    checker = DidYouMean::SpellChecker.new(dictionary: all_candidates)
+    suggestions = all_candidates & checker.correct(opt)
+    if DidYouMean.respond_to?(:formatter)
+      DidYouMean.formatter.message_for(suggestions)
+    else
+       "\nDid you mean?  #{suggestions.join("\n               ")}"
+    end
+  end
+
+  def candidate(word)
+    list = []
+    case word
+    when '-'
+      long = short = true
+    when /\A--/
+      word, arg = word.split(/=/, 2)
+      argpat = Completion.regexp(arg, false) if arg and !arg.empty?
+      long = true
+    when /\A-/
+      short = true
+    end
+    pat = Completion.regexp(word, long)
+    visit(:each_option) do |opt|
+      next unless Switch === opt
+      opts = (long ? opt.long : []) + (short ? opt.short : [])
+      opts = Completion.candidate(word, true, pat, &opts.method(:each)).map(&:first) if pat
+      if /\A=/ =~ opt.arg
+        opts.map! {|sw| sw + "="}
+        if arg and CompletingHash === opt.pattern
+          if opts = opt.pattern.candidate(arg, false, argpat)
+            opts.map!(&:last)
+          end
+        end
+      end
+      list.concat(opts)
+    end
+    list
+  end
+
+  #
+  # Loads options from file names as +filename+. Does nothing when the file
+  # is not present. Returns whether successfully loaded.
+  #
+  # +filename+ defaults to basename of the program without suffix in a
+  # directory ~/.options, then the basename with '.options' suffix
+  # under XDG and Haiku standard places.
+  #
+  def load(filename = nil)
+    unless filename
+      basename = File.basename($0, '.*')
+      return true if load(File.expand_path(basename, '~/.options')) rescue nil
+      basename << ".options"
+      return [
+        # XDG
+        ENV['XDG_CONFIG_HOME'],
+        '~/.config',
+        *ENV['XDG_CONFIG_DIRS']&.split(File::PATH_SEPARATOR),
+
+        # Haiku
+        '~/config/settings',
+      ].any? {|dir|
+        next if !dir or dir.empty?
+        load(File.expand_path(basename, dir)) rescue nil
+      }
+    end
+    begin
+      parse(*IO.readlines(filename).each {|s| s.chomp!})
+      true
+    rescue Errno::ENOENT, Errno::ENOTDIR
+      false
+    end
+  end
+
+  #
+  # Parses environment variable +env+ or its uppercase with splitting like a
+  # shell.
+  #
+  # +env+ defaults to the basename of the program.
+  #
+  def environment(env = File.basename($0, '.*'))
+    env = ENV[env] || ENV[env.upcase] or return
+    require 'shellwords'
+    parse(*Shellwords.shellwords(env))
+  end
+
+  #
+  # Acceptable argument classes
+  #
+
+  #
+  # Any string and no conversion. This is fall-back.
+  #
+  accept(Object) {|s,|s or s.nil?}
+
+  accept(NilClass) {|s,|s}
+
+  #
+  # Any non-empty string, and no conversion.
+  #
+  accept(String, /.+/m) {|s,*|s}
+
+  #
+  # Ruby/C-like integer, octal for 0-7 sequence, binary for 0b, hexadecimal
+  # for 0x, and decimal for others; with optional sign prefix. Converts to
+  # Integer.
+  #
+  decimal = '\d+(?:_\d+)*'
+  binary = 'b[01]+(?:_[01]+)*'
+  hex = 'x[\da-f]+(?:_[\da-f]+)*'
+  octal = "0(?:[0-7]+(?:_[0-7]+)*|#{binary}|#{hex})?"
+  integer = "#{octal}|#{decimal}"
+
+  accept(Integer, %r"\A[-+]?(?:#{integer})\z"io) {|s,|
+    begin
+      Integer(s)
+    rescue ArgumentError
+      raise Gem::OptionParser::InvalidArgument, s
+    end if s
+  }
+
+  #
+  # Float number format, and converts to Float.
+  #
+  float = "(?:#{decimal}(?=(.)?)(?:\\.(?:#{decimal})?)?|\\.#{decimal})(?:E[-+]?#{decimal})?"
+  floatpat = %r"\A[-+]?#{float}\z"io
+  accept(Float, floatpat) {|s,| s.to_f if s}
+
+  #
+  # Generic numeric format, converts to Integer for integer format, Float
+  # for float format, and Rational for rational format.
+  #
+  real = "[-+]?(?:#{octal}|#{float})"
+  accept(Numeric, /\A(#{real})(?:\/(#{real}))?\z/io) {|s, d, f, n,|
+    if n
+      Rational(d, n)
+    elsif f
+      Float(s)
+    else
+      Integer(s)
+    end
+  }
+
+  #
+  # Decimal integer format, to be converted to Integer.
+  #
+  DecimalInteger = /\A[-+]?#{decimal}\z/io
+  accept(DecimalInteger, DecimalInteger) {|s,|
+    begin
+      Integer(s, 10)
+    rescue ArgumentError
+      raise Gem::OptionParser::InvalidArgument, s
+    end if s
+  }
+
+  #
+  # Ruby/C like octal/hexadecimal/binary integer format, to be converted to
+  # Integer.
+  #
+  OctalInteger = /\A[-+]?(?:[0-7]+(?:_[0-7]+)*|0(?:#{binary}|#{hex}))\z/io
+  accept(OctalInteger, OctalInteger) {|s,|
+    begin
+      Integer(s, 8)
+    rescue ArgumentError
+      raise Gem::OptionParser::InvalidArgument, s
+    end if s
+  }
+
+  #
+  # Decimal integer/float number format, to be converted to Integer for
+  # integer format, Float for float format.
+  #
+  DecimalNumeric = floatpat     # decimal integer is allowed as float also.
+  accept(DecimalNumeric, floatpat) {|s, f|
+    begin
+      if f
+        Float(s)
+      else
+        Integer(s)
+      end
+    rescue ArgumentError
+      raise Gem::OptionParser::InvalidArgument, s
+    end if s
+  }
+
+  #
+  # Boolean switch, which means whether it is present or not, whether it is
+  # absent or not with prefix no-, or it takes an argument
+  # yes/no/true/false/+/-.
+  #
+  yesno = CompletingHash.new
+  %w[- no false].each {|el| yesno[el] = false}
+  %w[+ yes true].each {|el| yesno[el] = true}
+  yesno['nil'] = false          # should be nil?
+  accept(TrueClass, yesno) {|arg, val| val == nil or val}
+  #
+  # Similar to TrueClass, but defaults to false.
+  #
+  accept(FalseClass, yesno) {|arg, val| val != nil and val}
+
+  #
+  # List of strings separated by ",".
+  #
+  accept(Array) do |s, |
+    if s
+      s = s.split(',').collect {|ss| ss unless ss.empty?}
+    end
+    s
+  end
+
+  #
+  # Regular expression with options.
+  #
+  accept(Regexp, %r"\A/((?:\\.|[^\\])*)/([[:alpha:]]+)?\z|.*") do |all, s, o|
+    f = 0
+    if o
+      f |= Regexp::IGNORECASE if /i/ =~ o
+      f |= Regexp::MULTILINE if /m/ =~ o
+      f |= Regexp::EXTENDED if /x/ =~ o
+      k = o.delete("imx")
+      k = nil if k.empty?
+    end
+    Regexp.new(s || all, f, k)
+  end
+
+  #
+  # Exceptions
+  #
+
+  #
+  # Base class of exceptions from Gem::OptionParser.
+  #
+  class ParseError < RuntimeError
+    # Reason which caused the error.
+    Reason = 'parse error'
+
+    def initialize(*args, additional: nil)
+      @additional = additional
+      @arg0, = args
+      @args = args
+      @reason = nil
+    end
+
+    attr_reader :args
+    attr_writer :reason
+    attr_accessor :additional
+
+    #
+    # Pushes back erred argument(s) to +argv+.
+    #
+    def recover(argv)
+      argv[0, 0] = @args
+      argv
+    end
+
+    def self.filter_backtrace(array)
+      unless $DEBUG
+        array.delete_if(&%r"\A#{Regexp.quote(__FILE__)}:"o.method(:=~))
+      end
+      array
+    end
+
+    def set_backtrace(array)
+      super(self.class.filter_backtrace(array))
+    end
+
+    def set_option(opt, eq)
+      if eq
+        @args[0] = opt
+      else
+        @args.unshift(opt)
+      end
+      self
+    end
+
+    #
+    # Returns error reason. Override this for I18N.
+    #
+    def reason
+      @reason || self.class::Reason
+    end
+
+    def inspect
+      "#<#{self.class}: #{args.join(' ')}>"
+    end
+
+    #
+    # Default stringizing method to emit standard error message.
+    #
+    def message
+      "#{reason}: #{args.join(' ')}#{additional[@arg0] if additional}"
+    end
+
+    alias to_s message
+  end
+
+  #
+  # Raises when ambiguously completable string is encountered.
+  #
+  class AmbiguousOption < ParseError
+    const_set(:Reason, 'ambiguous option')
+  end
+
+  #
+  # Raises when there is an argument for a switch which takes no argument.
+  #
+  class NeedlessArgument < ParseError
+    const_set(:Reason, 'needless argument')
+  end
+
+  #
+  # Raises when a switch with mandatory argument has no argument.
+  #
+  class MissingArgument < ParseError
+    const_set(:Reason, 'missing argument')
+  end
+
+  #
+  # Raises when switch is undefined.
+  #
+  class InvalidOption < ParseError
+    const_set(:Reason, 'invalid option')
+  end
+
+  #
+  # Raises when the given argument does not match required format.
+  #
+  class InvalidArgument < ParseError
+    const_set(:Reason, 'invalid argument')
+  end
+
+  #
+  # Raises when the given argument word can't be completed uniquely.
+  #
+  class AmbiguousArgument < InvalidArgument
+    const_set(:Reason, 'ambiguous argument')
+  end
+
+  #
+  # Miscellaneous
+  #
+
+  #
+  # Extends command line arguments array (ARGV) to parse itself.
+  #
+  module Arguable
+
+    #
+    # Sets Gem::OptionParser object, when +opt+ is +false+ or +nil+, methods
+    # Gem::OptionParser::Arguable#options and Gem::OptionParser::Arguable#options= are
+    # undefined. Thus, there is no ways to access the Gem::OptionParser object
+    # via the receiver object.
+    #
+    def options=(opt)
+      unless @optparse = opt
+        class << self
+          undef_method(:options)
+          undef_method(:options=)
+        end
+      end
+    end
+
+    #
+    # Actual Gem::OptionParser object, automatically created if nonexistent.
+    #
+    # If called with a block, yields the Gem::OptionParser object and returns the
+    # result of the block. If an Gem::OptionParser::ParseError exception occurs
+    # in the block, it is rescued, a error message printed to STDERR and
+    # +nil+ returned.
+    #
+    def options
+      @optparse ||= Gem::OptionParser.new
+      @optparse.default_argv = self
+      block_given? or return @optparse
+      begin
+        yield @optparse
+      rescue ParseError
+        @optparse.warn $!
+        nil
+      end
+    end
+
+    #
+    # Parses +self+ destructively in order and returns +self+ containing the
+    # rest arguments left unparsed.
+    #
+    def order!(&blk) options.order!(self, &blk) end
+
+    #
+    # Parses +self+ destructively in permutation mode and returns +self+
+    # containing the rest arguments left unparsed.
+    #
+    def permute!() options.permute!(self) end
+
+    #
+    # Parses +self+ destructively and returns +self+ containing the
+    # rest arguments left unparsed.
+    #
+    def parse!() options.parse!(self) end
+
+    #
+    # Substitution of getopts is possible as follows. Also see
+    # Gem::OptionParser#getopts.
+    #
+    #   def getopts(*args)
+    #     ($OPT = ARGV.getopts(*args)).each do |opt, val|
+    #       eval "$OPT_#{opt.gsub(/[^A-Za-z0-9_]/, '_')} = val"
+    #     end
+    #   rescue Gem::OptionParser::ParseError
+    #   end
+    #
+    def getopts(*args)
+      options.getopts(self, *args)
+    end
+
+    #
+    # Initializes instance variable.
+    #
+    def self.extend_object(obj)
+      super
+      obj.instance_eval {@optparse = nil}
+    end
+    def initialize(*args)
+      super
+      @optparse = nil
+    end
+  end
+
+  #
+  # Acceptable argument classes. Now contains DecimalInteger, OctalInteger
+  # and DecimalNumeric. See Acceptable argument classes (in source code).
+  #
+  module Acceptables
+    const_set(:DecimalInteger, Gem::OptionParser::DecimalInteger)
+    const_set(:OctalInteger, Gem::OptionParser::OctalInteger)
+    const_set(:DecimalNumeric, Gem::OptionParser::DecimalNumeric)
+  end
+end
+
+# ARGV is arguable by Gem::OptionParser
+ARGV.extend(Gem::OptionParser::Arguable)
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse/lib/optparse/ac.rb
@@ -0,0 +1,54 @@
+# frozen_string_literal: false
+require_relative '../optparse'
+
+class Gem::OptionParser::AC < Gem::OptionParser
+  private
+
+  def _check_ac_args(name, block)
+    unless /\A\w[-\w]*\z/ =~ name
+      raise ArgumentError, name
+    end
+    unless block
+      raise ArgumentError, "no block given", ParseError.filter_backtrace(caller)
+    end
+  end
+
+  ARG_CONV = proc {|val| val.nil? ? true : val}
+
+  def _ac_arg_enable(prefix, name, help_string, block)
+    _check_ac_args(name, block)
+
+    sdesc = []
+    ldesc = ["--#{prefix}-#{name}"]
+    desc = [help_string]
+    q = name.downcase
+    ac_block = proc {|val| block.call(ARG_CONV.call(val))}
+    enable = Switch::PlacedArgument.new(nil, ARG_CONV, sdesc, ldesc, nil, desc, ac_block)
+    disable = Switch::NoArgument.new(nil, proc {false}, sdesc, ldesc, nil, desc, ac_block)
+    top.append(enable, [], ["enable-" + q], disable, ['disable-' + q])
+    enable
+  end
+
+  public
+
+  def ac_arg_enable(name, help_string, &block)
+    _ac_arg_enable("enable", name, help_string, block)
+  end
+
+  def ac_arg_disable(name, help_string, &block)
+    _ac_arg_enable("disable", name, help_string, block)
+  end
+
+  def ac_arg_with(name, help_string, &block)
+    _check_ac_args(name, block)
+
+    sdesc = []
+    ldesc = ["--with-#{name}"]
+    desc = [help_string]
+    q = name.downcase
+    with = Switch::PlacedArgument.new(*search(:atype, String), sdesc, ldesc, nil, desc, block)
+    without = Switch::NoArgument.new(nil, proc {}, sdesc, ldesc, nil, desc, block)
+    top.append(with, [], ["with-" + q], without, ['without-' + q])
+    with
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse/lib/optparse/date.rb
@@ -0,0 +1,18 @@
+# frozen_string_literal: false
+require_relative '../optparse'
+require 'date'
+
+Gem::OptionParser.accept(DateTime) do |s,|
+  begin
+    DateTime.parse(s) if s
+  rescue ArgumentError
+    raise Gem::OptionParser::InvalidArgument, s
+  end
+end
+Gem::OptionParser.accept(Date) do |s,|
+  begin
+    Date.parse(s) if s
+  rescue ArgumentError
+    raise Gem::OptionParser::InvalidArgument, s
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse/lib/optparse/kwargs.rb
@@ -0,0 +1,22 @@
+# frozen_string_literal: true
+require_relative '../optparse'
+
+class Gem::OptionParser
+  # :call-seq:
+  #   define_by_keywords(options, method, **params)
+  #
+  # :include: ../../doc/optparse/creates_option.rdoc
+  #
+  def define_by_keywords(options, meth, **opts)
+    meth.parameters.each do |type, name|
+      case type
+      when :key, :keyreq
+        op, cl = *(type == :key ? %w"[ ]" : ["", ""])
+        define("--#{name}=#{op}#{name.upcase}#{cl}", *opts[name]) do |o|
+          options[name] = o
+        end
+      end
+    end
+    options
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse/lib/optparse/shellwords.rb
@@ -0,0 +1,7 @@
+# frozen_string_literal: false
+# -*- ruby -*-
+
+require 'shellwords'
+require_relative '../optparse'
+
+Gem::OptionParser.accept(Shellwords) {|s,| Shellwords.shellwords(s)}
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse/lib/optparse/time.rb
@@ -0,0 +1,11 @@
+# frozen_string_literal: false
+require_relative '../optparse'
+require 'time'
+
+Gem::OptionParser.accept(Time) do |s,|
+  begin
+    (Time.httpdate(s) rescue Time.parse(s)) if s
+  rescue
+    raise Gem::OptionParser::InvalidArgument, s
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse/lib/optparse/uri.rb
@@ -0,0 +1,7 @@
+# frozen_string_literal: false
+# -*- ruby -*-
+
+require_relative '../optparse'
+require 'uri'
+
+Gem::OptionParser.accept(URI) {|s,| URI.parse(s) if s}
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/optparse/lib/optparse/version.rb
@@ -0,0 +1,71 @@
+# frozen_string_literal: false
+# Gem::OptionParser internal utility
+
+class << Gem::OptionParser
+  def show_version(*pkgs)
+    progname = ARGV.options.program_name
+    result = false
+    show = proc do |klass, cname, version|
+      str = "#{progname}"
+      unless klass == ::Object and cname == :VERSION
+        version = version.join(".") if Array === version
+        str << ": #{klass}" unless klass == Object
+        str << " version #{version}"
+      end
+      [:Release, :RELEASE].find do |rel|
+        if klass.const_defined?(rel)
+          str << " (#{klass.const_get(rel)})"
+        end
+      end
+      puts str
+      result = true
+    end
+    if pkgs.size == 1 and pkgs[0] == "all"
+      self.search_const(::Object, /\AV(?:ERSION|ersion)\z/) do |klass, cname, version|
+        unless cname[1] == ?e and klass.const_defined?(:Version)
+          show.call(klass, cname.intern, version)
+        end
+      end
+    else
+      pkgs.each do |pkg|
+        begin
+          pkg = pkg.split(/::|\//).inject(::Object) {|m, c| m.const_get(c)}
+          v = case
+              when pkg.const_defined?(:Version)
+                pkg.const_get(n = :Version)
+              when pkg.const_defined?(:VERSION)
+                pkg.const_get(n = :VERSION)
+              else
+                n = nil
+                "unknown"
+              end
+          show.call(pkg, n, v)
+        rescue NameError
+        end
+      end
+    end
+    result
+  end
+
+  def each_const(path, base = ::Object)
+    path.split(/::|\//).inject(base) do |klass, name|
+      raise NameError, path unless Module === klass
+      klass.constants.grep(/#{name}/i) do |c|
+        klass.const_defined?(c) or next
+        klass.const_get(c)
+      end
+    end
+  end
+
+  def search_const(klass, name)
+    klasses = [klass]
+    while klass = klasses.shift
+      klass.constants.each do |cname|
+        klass.const_defined?(cname) or next
+        const = klass.const_get(cname)
+        yield klass, cname, const if name === cname
+        klasses << const if Module === const and const != ::Object
+      end
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/lib/rubygems/package.rb
+++ ruby2.7-2.7.6/lib/rubygems/package.rb
@@ -1,14 +1,19 @@
-# -*- coding: utf-8 -*-
 # frozen_string_literal: true
 #--
 # Copyright (C) 2004 Mauricio Julio Fernndez Pradier
 # See LICENSE.txt for additional licensing information.
 #++
-#
+
+require_relative "../rubygems"
+require_relative "security"
+require_relative "user_interaction"
+
+##
 # Example using a Gem::Package
 #
 # Builds a .gem file given a Gem::Specification. A .gem file is a tarball
-# which contains a data.tar.gz and metadata.gz, and possibly signatures.
+# which contains a data.tar.gz, metadata.gz, checksums.yaml.gz and possibly
+# signatures.
 #
 #   require 'rubygems'
 #   require 'rubygems/package'
@@ -41,19 +46,12 @@
 # #files are the files in the .gem tar file, not the Ruby files in the gem
 # #extract_files and #contents automatically call #verify
 
-require 'rubygems/security'
-require 'rubygems/specification'
-require 'rubygems/user_interaction'
-require 'zlib'
-
 class Gem::Package
-
   include Gem::UserInteraction
 
   class Error < Gem::Exception; end
 
   class FormatError < Error
-
     attr_reader :path
 
     def initialize(message, source = nil)
@@ -65,16 +63,20 @@ class Gem::Package
 
       super message
     end
-
   end
 
   class PathError < Error
-
     def initialize(destination, destination_dir)
       super "installing into parent path %s of %s is not allowed" %
-              [destination, destination_dir]
+        [destination, destination_dir]
     end
+  end
 
+  class SymlinkError < Error
+    def initialize(name, destination, destination_dir)
+      super "installing symlink '%s' pointing to parent path %s of %s is not allowed" %
+        [name, destination, destination_dir]
+    end
   end
 
   class NonSeekableIO < Error; end
@@ -145,18 +147,18 @@ class Gem::Package
 
   def self.new(gem, security_policy = nil)
     gem = if gem.is_a?(Gem::Package::Source)
-            gem
-          elsif gem.respond_to? :read
-            Gem::Package::IOSource.new gem
-          else
-            Gem::Package::FileSource.new gem
-          end
+      gem
+    elsif gem.respond_to? :read
+      Gem::Package::IOSource.new gem
+    else
+      Gem::Package::FileSource.new gem
+    end
 
     return super unless Gem::Package == self
     return super unless gem.present?
 
     return super unless gem.start
-    return super unless gem.start.include? 'MD5SUM ='
+    return super unless gem.start.include? "MD5SUM ="
 
     Gem::Package::Old.new gem
   end
@@ -176,9 +178,9 @@ class Gem::Package
       tar = Gem::Package::TarReader.new io
       tar.each_entry do |entry|
         case entry.full_name
-        when 'metadata' then
+        when "metadata" then
           metadata = entry.read
-        when 'metadata.gz' then
+        when "metadata.gz" then
           metadata = Gem::Util.gunzip entry.read
         end
       end
@@ -191,12 +193,14 @@ class Gem::Package
   # Creates a new package that will read or write to the file +gem+.
 
   def initialize(gem, security_policy) # :notnew:
+    require "zlib"
+
     @gem = gem
 
     @build_time      = Gem.source_date_epoch
     @checksums       = {}
     @contents        = nil
-    @digests         = Hash.new { |h, algorithm| h[algorithm] = {} }
+    @digests         = Hash.new {|h, algorithm| h[algorithm] = {} }
     @files           = nil
     @security_policy = security_policy
     @signatures      = {}
@@ -217,7 +221,7 @@ class Gem::Package
   def add_checksums(tar)
     Gem.load_yaml
 
-    checksums_by_algorithm = Hash.new { |h, algorithm| h[algorithm] = {} }
+    checksums_by_algorithm = Hash.new {|h, algorithm| h[algorithm] = {} }
 
     @checksums.each do |name, digests|
       digests.each do |algorithm, digest|
@@ -225,9 +229,9 @@ class Gem::Package
       end
     end
 
-    tar.add_file_signed 'checksums.yaml.gz', 0444, @signer do |io|
+    tar.add_file_signed "checksums.yaml.gz", 0444, @signer do |io|
       gzip_to io do |gz_io|
-        YAML.dump checksums_by_algorithm, gz_io
+        Psych.dump checksums_by_algorithm, gz_io
       end
     end
   end
@@ -237,7 +241,7 @@ class Gem::Package
   # and adds this file to the +tar+.
 
   def add_contents(tar) # :nodoc:
-    digests = tar.add_file_signed 'data.tar.gz', 0444, @signer do |io|
+    digests = tar.add_file_signed "data.tar.gz", 0444, @signer do |io|
       gzip_to io do |gz_io|
         Gem::Package::TarWriter.new gz_io do |data_tar|
           add_files data_tar
@@ -245,7 +249,7 @@ class Gem::Package
       end
     end
 
-    @checksums['data.tar.gz'] = digests
+    @checksums["data.tar.gz"] = digests
   end
 
   ##
@@ -256,20 +260,13 @@ class Gem::Package
       stat = File.lstat file
 
       if stat.symlink?
-        target_path = File.readlink(file)
-
-        unless target_path.start_with? '.'
-          relative_dir = File.dirname(file).sub("#{Dir.pwd}/", '')
-          target_path = File.join(relative_dir, target_path)
-        end
-
-        tar.add_symlink file, target_path, stat.mode
+        tar.add_symlink file, File.readlink(file), stat.mode
       end
 
       next unless stat.file?
 
       tar.add_file_simple file, stat.mode, stat.size do |dst_io|
-        File.open file, 'rb' do |src_io|
+        File.open file, "rb" do |src_io|
           dst_io.write src_io.read 16384 until src_io.eof?
         end
       end
@@ -280,13 +277,13 @@ class Gem::Package
   # Adds the package's Gem::Specification to the +tar+ file
 
   def add_metadata(tar) # :nodoc:
-    digests = tar.add_file_signed 'metadata.gz', 0444, @signer do |io|
+    digests = tar.add_file_signed "metadata.gz", 0444, @signer do |io|
       gzip_to io do |gz_io|
         gz_io.write @spec.to_yaml
       end
     end
 
-    @checksums['metadata.gz'] = digests
+    @checksums["metadata.gz"] = digests
   end
 
   ##
@@ -302,7 +299,7 @@ class Gem::Package
 
     setup_signer(
       signer_options: {
-        expiration_length_days: Gem.configuration.cert_expiration_length_days
+        expiration_length_days: Gem.configuration.cert_expiration_length_days,
       }
     )
 
@@ -338,7 +335,7 @@ EOM
       gem_tar = Gem::Package::TarReader.new io
 
       gem_tar.each do |entry|
-        next unless entry.full_name == 'data.tar.gz'
+        next unless entry.full_name == "data.tar.gz"
 
         open_tar_gz entry do |pkg_tar|
           pkg_tar.each do |contents_entry|
@@ -357,18 +354,13 @@ EOM
 
   def digest(entry) # :nodoc:
     algorithms = if @checksums
-                   @checksums.keys
-                 else
-                   [Gem::Security::DIGEST_NAME].compact
-                 end
+      @checksums.keys
+    else
+      [Gem::Security::DIGEST_NAME].compact
+    end
 
     algorithms.each do |algorithm|
-      digester =
-        if defined?(OpenSSL::Digest)
-          OpenSSL::Digest.new algorithm
-        else
-          Digest.const_get(algorithm).new
-        end
+      digester = Gem::Security.create_digest(algorithm)
 
       digester << entry.read(16384) until entry.eof?
 
@@ -395,7 +387,7 @@ EOM
       reader = Gem::Package::TarReader.new io
 
       reader.each do |entry|
-        next unless entry.full_name == 'data.tar.gz'
+        next unless entry.full_name == "data.tar.gz"
 
         extract_tar_gz entry, destination_dir, pattern
 
@@ -416,12 +408,25 @@ EOM
   # extracted.
 
   def extract_tar_gz(io, destination_dir, pattern = "*") # :nodoc:
-    directories = [] if dir_mode
+    directories = []
+    symlinks = []
+
     open_tar_gz io do |tar|
       tar.each do |entry|
-        next unless File.fnmatch pattern, entry.full_name, File::FNM_DOTMATCH
+        full_name = entry.full_name
+        next unless File.fnmatch pattern, full_name, File::FNM_DOTMATCH
+
+        destination = install_location full_name, destination_dir
+
+        if entry.symlink?
+          link_target = entry.header.linkname
+          real_destination = link_target.start_with?("/") ? link_target : File.expand_path(link_target, File.dirname(destination))
 
-        destination = install_location entry.full_name, destination_dir
+          raise Gem::Package::SymlinkError.new(full_name, real_destination, destination_dir) unless
+            normalize_path(real_destination).start_with? normalize_path(destination_dir + "/")
+
+          symlinks << [full_name, link_target, destination, real_destination]
+        end
 
         FileUtils.rm_rf destination
 
@@ -433,23 +438,30 @@ EOM
           else
             File.dirname destination
           end
-        directories << mkdir if directories
 
-        mkdir_p_safe mkdir, mkdir_options, destination_dir, entry.full_name
+        unless directories.include?(mkdir)
+          FileUtils.mkdir_p mkdir, **mkdir_options
+          directories << mkdir
+        end
 
-        File.open destination, 'wb' do |out|
+        File.open destination, "wb" do |out|
           out.write entry.read
           FileUtils.chmod file_mode(entry.header.mode), destination
         end if entry.file?
 
-        File.symlink(entry.header.linkname, destination) if entry.symlink?
-
         verbose destination
       end
     end
 
-    if directories
-      directories.uniq!
+    symlinks.each do |name, target, destination, real_destination|
+      if File.exist?(real_destination)
+        File.symlink(target, destination)
+      else
+        alert_warning "#{@spec.full_name} ships with a dangling symlink named #{name} pointing to missing #{target} file. Ignoring"
+      end
+    end
+
+    if dir_mode
       File.chmod(dir_mode, *directories)
     end
   end
@@ -480,23 +492,13 @@ EOM
 
   def install_location(filename, destination_dir) # :nodoc:
     raise Gem::Package::PathError.new(filename, destination_dir) if
-      filename.start_with? '/'
+      filename.start_with? "/"
 
-    destination_dir = File.expand_path(File.realpath(destination_dir))
-    destination = File.expand_path(File.join(destination_dir, filename))
+    destination_dir = File.realpath(destination_dir)
+    destination = File.expand_path(filename, destination_dir)
 
     raise Gem::Package::PathError.new(destination, destination_dir) unless
-      destination.start_with? destination_dir + '/'
-
-    begin
-      real_destination = File.expand_path(File.realpath(destination))
-    rescue
-      # it's fine if the destination doesn't exist, because rm -rf'ing it can't cause any damage
-      nil
-    else
-      raise Gem::Package::PathError.new(real_destination, destination_dir) unless
-        real_destination.start_with? destination_dir + '/'
-    end
+      normalize_path(destination).start_with? normalize_path(destination_dir + "/")
 
     destination.tap(&Gem::UNTAINT)
     destination
@@ -510,30 +512,14 @@ EOM
     end
   end
 
-  def mkdir_p_safe(mkdir, mkdir_options, destination_dir, file_name)
-    destination_dir = File.realpath(File.expand_path(destination_dir))
-    parts = mkdir.split(File::SEPARATOR)
-    parts.reduce do |path, basename|
-      path = File.realpath(path) unless path == ""
-      path = File.expand_path(path + File::SEPARATOR + basename)
-      lstat = File.lstat path rescue nil
-      if !lstat || !lstat.directory?
-        unless normalize_path(path).start_with? normalize_path(destination_dir) and (FileUtils.mkdir path, **mkdir_options rescue false)
-          raise Gem::Package::PathError.new(file_name, destination_dir)
-        end
-      end
-      path
-    end
-  end
-
   ##
   # Loads a Gem::Specification from the TarEntry +entry+
 
   def load_spec(entry) # :nodoc:
     case entry.full_name
-    when 'metadata' then
+    when "metadata" then
       @spec = Gem::Specification.from_yaml entry.read
-    when 'metadata.gz' then
+    when "metadata.gz" then
       Zlib::GzipReader.wrap(entry, external_encoding: Encoding::UTF_8) do |gzio|
         @spec = Gem::Specification.from_yaml gzio.read
       end
@@ -557,7 +543,7 @@ EOM
   def read_checksums(gem)
     Gem.load_yaml
 
-    @checksums = gem.seek 'checksums.yaml.gz' do |entry|
+    @checksums = gem.seek "checksums.yaml.gz" do |entry|
       Zlib::GzipReader.wrap entry do |gz_io|
         Gem::SafeYAML.safe_load gz_io.read
       end
@@ -569,7 +555,7 @@ EOM
   # certificate and key are not present only checksum generation is set up.
 
   def setup_signer(signer_options: {})
-    passphrase = ENV['GEM_PRIVATE_KEY_PASSPHRASE']
+    passphrase = ENV["GEM_PRIVATE_KEY_PASSPHRASE"]
     if @spec.signing_key
       @signer =
         Gem::Security::Signer.new(
@@ -580,10 +566,10 @@ EOM
         )
 
       @spec.signing_key = nil
-      @spec.cert_chain = @signer.cert_chain.map { |cert| cert.to_s }
+      @spec.cert_chain = @signer.cert_chain.map {|cert| cert.to_s }
     else
       @signer = Gem::Security::Signer.new nil, nil, passphrase
-      @spec.cert_chain = @signer.cert_chain.map { |cert| cert.to_pem } if
+      @spec.cert_chain = @signer.cert_chain.map {|cert| cert.to_pem } if
         @signer.cert_chain
     end
   end
@@ -676,13 +662,12 @@ EOM
     case file_name
     when "metadata", "metadata.gz" then
       load_spec entry
-    when 'data.tar.gz' then
+    when "data.tar.gz" then
       verify_gz entry
     end
-  rescue => e
-    message = "package is corrupt, exception while verifying: " +
-              "#{e.message} (#{e.class})"
-    raise Gem::Package::FormatError.new message, @gem
+  rescue
+    warn "Exception while verifying #{@gem.path}"
+    raise
   end
 
   ##
@@ -694,15 +679,15 @@ EOM
     end
 
     unless @spec
-      raise Gem::Package::FormatError.new 'package metadata is missing', @gem
+      raise Gem::Package::FormatError.new "package metadata is missing", @gem
     end
 
-    unless @files.include? 'data.tar.gz'
+    unless @files.include? "data.tar.gz"
       raise Gem::Package::FormatError.new \
-              'package content (data.tar.gz) is missing', @gem
+              "package content (data.tar.gz) is missing", @gem
     end
 
-    if duplicates = @files.group_by {|f| f }.select {|k,v| v.size > 1 }.map(&:first) and duplicates.any?
+    if (duplicates = @files.group_by {|f| f }.select {|k,v| v.size > 1 }.map(&:first)) && duplicates.any?
       raise Gem::Security::Exception, "duplicate files in the package: (#{duplicates.map(&:inspect).join(', ')})"
     end
   end
@@ -717,15 +702,14 @@ EOM
   rescue Zlib::GzipFile::Error => e
     raise Gem::Package::FormatError.new(e.message, entry.full_name)
   end
-
 end
 
-require 'rubygems/package/digest_io'
-require 'rubygems/package/source'
-require 'rubygems/package/file_source'
-require 'rubygems/package/io_source'
-require 'rubygems/package/old'
-require 'rubygems/package/tar_header'
-require 'rubygems/package/tar_reader'
-require 'rubygems/package/tar_reader/entry'
-require 'rubygems/package/tar_writer'
+require_relative "package/digest_io"
+require_relative "package/source"
+require_relative "package/file_source"
+require_relative "package/io_source"
+require_relative "package/old"
+require_relative "package/tar_header"
+require_relative "package/tar_reader"
+require_relative "package/tar_reader/entry"
+require_relative "package/tar_writer"
--- ruby2.7-2.7.6.orig/lib/rubygems/package/digest_io.rb
+++ ruby2.7-2.7.6/lib/rubygems/package/digest_io.rb
@@ -3,7 +3,6 @@
 # IO wrapper that creates digests of contents written to the IO it wraps.
 
 class Gem::Package::DigestIO
-
   ##
   # Collected digests for wrapped writes.
   #
@@ -60,5 +59,4 @@ class Gem::Package::DigestIO
 
     result
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/package/file_source.rb
+++ ruby2.7-2.7.6/lib/rubygems/package/file_source.rb
@@ -7,7 +7,6 @@
 # object to `Gem::Package.new`.
 
 class Gem::Package::FileSource < Gem::Package::Source # :nodoc: all
-
   attr_reader :path
 
   def initialize(path)
@@ -23,11 +22,10 @@ class Gem::Package::FileSource < Gem::Pa
   end
 
   def with_write_io(&block)
-    File.open path, 'wb', &block
+    File.open path, "wb", &block
   end
 
   def with_read_io(&block)
-    File.open path, 'rb', &block
+    File.open path, "rb", &block
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/package/io_source.rb
+++ ruby2.7-2.7.6/lib/rubygems/package/io_source.rb
@@ -8,7 +8,6 @@
 # object to `Gem::Package.new`.
 
 class Gem::Package::IOSource < Gem::Package::Source # :nodoc: all
-
   attr_reader :io
 
   def initialize(io)
@@ -33,13 +32,16 @@ class Gem::Package::IOSource < Gem::Pack
 
   def with_read_io
     yield io
+  ensure
+    io.rewind
   end
 
   def with_write_io
     yield io
+  ensure
+    io.rewind
   end
 
   def path
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/package/old.rb
+++ ruby2.7-2.7.6/lib/rubygems/package/old.rb
@@ -12,7 +12,6 @@
 # Please pretend this doesn't exist.
 
 class Gem::Package::Old < Gem::Package
-
   undef_method :spec=
 
   ##
@@ -20,8 +19,8 @@ class Gem::Package::Old < Gem::Package
   # cannot be written.
 
   def initialize(gem, security_policy)
-    require 'fileutils'
-    require 'zlib'
+    require "fileutils"
+    require "zlib"
     Gem.load_yaml
 
     @contents        = nil
@@ -42,7 +41,7 @@ class Gem::Package::Old < Gem::Package
       read_until_dashes io # spec
       header = file_list io
 
-      @contents = header.map { |file| file['path'] }
+      @contents = header.map {|file| file["path"] }
     end
   end
 
@@ -60,7 +59,7 @@ class Gem::Package::Old < Gem::Package
       raise Gem::Exception, errstr unless header
 
       header.each do |entry|
-        full_name = entry['path']
+        full_name = entry["path"]
 
         destination = install_location full_name, destination_dir
 
@@ -74,13 +73,13 @@ class Gem::Package::Old < Gem::Package
         file_data = Zlib::Inflate.inflate file_data
 
         raise Gem::Package::FormatError, "#{full_name} in #{@gem} is corrupt" if
-          file_data.length != entry['size'].to_i
+          file_data.length != entry["size"].to_i
 
         FileUtils.rm_rf destination
 
         FileUtils.mkdir_p File.dirname(destination), :mode => dir_mode && 0755
 
-        File.open destination, 'wb', file_mode(entry['mode']) do |out|
+        File.open destination, "wb", file_mode(entry["mode"]) do |out|
           out.write file_data
         end
 
@@ -120,7 +119,7 @@ class Gem::Package::Old < Gem::Package
     loop do
       line = io.gets
 
-      return if line.chomp == '__END__'
+      return if line.chomp == "__END__"
       break unless line
     end
 
@@ -146,7 +145,7 @@ class Gem::Package::Old < Gem::Package
 
     begin
       @spec = Gem::Specification.from_yaml yaml
-    rescue YAML::SyntaxError
+    rescue Psych::SyntaxError
       raise Gem::Exception, "Failed to parse gem specification out of gem file"
     end
   rescue ArgumentError
@@ -161,10 +160,9 @@ class Gem::Package::Old < Gem::Package
     return true unless @security_policy
 
     raise Gem::Security::Exception,
-          'old format gems do not contain signatures and cannot be verified' if
+          "old format gems do not contain signatures and cannot be verified" if
       @security_policy.verify_data
 
     true
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/package/tar_header.rb
+++ ruby2.7-2.7.6/lib/rubygems/package/tar_header.rb
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 # frozen_string_literal: true
 #--
 # Copyright (C) 2004 Mauricio Julio Fernndez Pradier
@@ -29,7 +28,6 @@
 # A header for a tar file
 
 class Gem::Package::TarHeader
-
   ##
   # Fields in the tar header
 
@@ -55,42 +53,42 @@ class Gem::Package::TarHeader
   ##
   # Pack format for a tar header
 
-  PACK_FORMAT = 'a100' + # name
-                'a8'   + # mode
-                'a8'   + # uid
-                'a8'   + # gid
-                'a12'  + # size
-                'a12'  + # mtime
-                'a7a'  + # chksum
-                'a'    + # typeflag
-                'a100' + # linkname
-                'a6'   + # magic
-                'a2'   + # version
-                'a32'  + # uname
-                'a32'  + # gname
-                'a8'   + # devmajor
-                'a8'   + # devminor
-                'a155'   # prefix
+  PACK_FORMAT = "a100" + # name
+                "a8"   + # mode
+                "a8"   + # uid
+                "a8"   + # gid
+                "a12"  + # size
+                "a12"  + # mtime
+                "a7a"  + # chksum
+                "a"    + # typeflag
+                "a100" + # linkname
+                "a6"   + # magic
+                "a2"   + # version
+                "a32"  + # uname
+                "a32"  + # gname
+                "a8"   + # devmajor
+                "a8"   + # devminor
+                "a155"   # prefix
 
   ##
   # Unpack format for a tar header
 
-  UNPACK_FORMAT = 'A100' + # name
-                  'A8'   + # mode
-                  'A8'   + # uid
-                  'A8'   + # gid
-                  'A12'  + # size
-                  'A12'  + # mtime
-                  'A8'   + # checksum
-                  'A'    + # typeflag
-                  'A100' + # linkname
-                  'A6'   + # magic
-                  'A2'   + # version
-                  'A32'  + # uname
-                  'A32'  + # gname
-                  'A8'   + # devmajor
-                  'A8'   + # devminor
-                  'A155'   # prefix
+  UNPACK_FORMAT = "A100" + # name
+                  "A8"   + # mode
+                  "A8"   + # uid
+                  "A8"   + # gid
+                  "A12"  + # size
+                  "A12"  + # mtime
+                  "A8"   + # checksum
+                  "A"    + # typeflag
+                  "A100" + # linkname
+                  "A6"   + # magic
+                  "A2"   + # version
+                  "A32"  + # uname
+                  "A32"  + # gname
+                  "A8"   + # devmajor
+                  "A8"   + # devminor
+                  "A155"   # prefix
 
   attr_reader(*FIELDS)
 
@@ -126,7 +124,8 @@ class Gem::Package::TarHeader
   end
 
   def self.strict_oct(str)
-    return str.oct if str =~ /\A[0-7]*\z/
+    return str.strip.oct if str.strip =~ /\A[0-7]*\z/
+
     raise ArgumentError, "#{str.inspect} is not an octal string"
   end
 
@@ -135,7 +134,7 @@ class Gem::Package::TarHeader
     # \ff flags a negative 256-based number
     # In case we have a match, parse it as a signed binary value
     # in big-endian order, except that the high-order bit is ignored.
-    return str.unpack('N2').last if str =~ /\A[\x80\xff]/n
+    return str.unpack("N2").last if str =~ /\A[\x80\xff]/n
     strict_oct(str)
   end
 
@@ -174,23 +173,23 @@ class Gem::Package::TarHeader
   end
 
   def ==(other) # :nodoc:
-    self.class === other and
-    @checksum == other.checksum and
-    @devmajor == other.devmajor and
-    @devminor == other.devminor and
-    @gid      == other.gid      and
-    @gname    == other.gname    and
-    @linkname == other.linkname and
-    @magic    == other.magic    and
-    @mode     == other.mode     and
-    @mtime    == other.mtime    and
-    @name     == other.name     and
-    @prefix   == other.prefix   and
-    @size     == other.size     and
-    @typeflag == other.typeflag and
-    @uid      == other.uid      and
-    @uname    == other.uname    and
-    @version  == other.version
+    self.class === other &&
+      @checksum == other.checksum &&
+      @devmajor == other.devmajor &&
+      @devminor == other.devminor &&
+      @gid      == other.gid      &&
+      @gname    == other.gname    &&
+      @linkname == other.linkname &&
+      @magic    == other.magic    &&
+      @mode     == other.mode     &&
+      @mtime    == other.mtime    &&
+      @name     == other.name     &&
+      @prefix   == other.prefix   &&
+      @size     == other.size     &&
+      @typeflag == other.typeflag &&
+      @uid      == other.uid      &&
+      @uname    == other.uname    &&
+      @version  == other.version
   end
 
   def to_s # :nodoc:
@@ -209,7 +208,7 @@ class Gem::Package::TarHeader
   private
 
   def calculate_checksum(header)
-    header.unpack("C*").inject { |a, b| a + b }
+    header.unpack("C*").inject {|a, b| a + b }
   end
 
   def header(checksum = @checksum)
@@ -230,7 +229,7 @@ class Gem::Package::TarHeader
       gname,
       oct(devmajor, 7),
       oct(devminor, 7),
-      prefix
+      prefix,
     ]
 
     header = header.pack PACK_FORMAT
@@ -241,5 +240,4 @@ class Gem::Package::TarHeader
   def oct(num, len)
     "%0#{len}o" % num
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/package/tar_reader.rb
+++ ruby2.7-2.7.6/lib/rubygems/package/tar_reader.rb
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 # frozen_string_literal: true
 #--
 # Copyright (C) 2004 Mauricio Julio Fernndez Pradier
@@ -9,7 +8,6 @@
 # TarReader reads tar files and allows iteration over their items
 
 class Gem::Package::TarReader
-
   include Enumerable
 
   ##
@@ -121,7 +119,6 @@ class Gem::Package::TarReader
   ensure
     rewind
   end
-
 end
 
-require 'rubygems/package/tar_reader/entry'
+require_relative "tar_reader/entry"
--- ruby2.7-2.7.6.orig/lib/rubygems/package/tar_reader/entry.rb
+++ ruby2.7-2.7.6/lib/rubygems/package/tar_reader/entry.rb
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 # frozen_string_literal: true
 #++
 # Copyright (C) 2004 Mauricio Julio Fernndez Pradier
@@ -9,7 +8,6 @@
 # Class for reading entries out of a tar file
 
 class Gem::Package::TarReader::Entry
-
   ##
   # Header for this tar entry
 
@@ -70,9 +68,9 @@ class Gem::Package::TarReader::Entry
       @header.name
     end
   rescue ArgumentError => e
-    raise unless e.message == 'string contains null byte'
+    raise unless e.message == "string contains null byte"
     raise Gem::Package::TarInvalidError,
-          'tar is corrupt, name contains null byte'
+          "tar is corrupt, name contains null byte"
   end
 
   ##
@@ -166,5 +164,4 @@ class Gem::Package::TarReader::Entry
     @io.pos = @orig_pos
     @read = 0
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/package/tar_test_case.rb
+++ /dev/null
@@ -1,141 +0,0 @@
-# frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/package'
-
-##
-# A test case for Gem::Package::Tar* classes
-
-class Gem::Package::TarTestCase < Gem::TestCase
-
-  def ASCIIZ(str, length)
-    str + "\0" * (length - str.length)
-  end
-
-  def SP(s)
-    s + " "
-  end
-
-  def SP_Z(s)
-    s + " \0"
-  end
-
-  def Z(s)
-    s + "\0"
-  end
-
-  def assert_headers_equal(expected, actual)
-    expected = expected.to_s unless String === expected
-    actual = actual.to_s unless String === actual
-
-    fields = %w[
-      name 100
-      mode 8
-      uid 8
-      gid 8
-      size 12
-      mtime 12
-      checksum 8
-      typeflag 1
-      linkname 100
-      magic 6
-      version 2
-      uname 32
-      gname 32
-      devmajor 8
-      devminor 8
-      prefix 155
-    ]
-
-    offset = 0
-
-    until fields.empty? do
-      name = fields.shift
-      length = fields.shift.to_i
-
-      if name == "checksum"
-        chksum_off = offset
-        offset += length
-        next
-      end
-
-      assert_equal expected[offset, length], actual[offset, length],
-                   "Field #{name} of the tar header differs."
-
-      offset += length
-    end
-
-    assert_equal expected[chksum_off, 8], actual[chksum_off, 8]
-  end
-
-  def calc_checksum(header)
-    sum = header.unpack("C*").inject{|s,a| s + a}
-    SP(Z(to_oct(sum, 6)))
-  end
-
-  def header(type, fname, dname, length, mode, mtime, checksum = nil, linkname = "")
-    checksum ||= " " * 8
-
-    arr = [                  # struct tarfile_entry_posix
-      ASCIIZ(fname, 100),    # char name[100];     ASCII + (Z unless filled)
-      Z(to_oct(mode, 7)),    # char mode[8];       0 padded, octal null
-      Z(to_oct(0, 7)),       # char uid[8];        ditto
-      Z(to_oct(0, 7)),       # char gid[8];        ditto
-      Z(to_oct(length, 11)), # char size[12];      0 padded, octal, null
-      Z(to_oct(mtime, 11)),  # char mtime[12];     0 padded, octal, null
-      checksum,              # char checksum[8];   0 padded, octal, null, space
-      type,                  # char typeflag[1];   file: "0"  dir: "5"
-      ASCIIZ(linkname, 100), # char linkname[100]; ASCII + (Z unless filled)
-      "ustar\0",             # char magic[6];      "ustar\0"
-      "00",                  # char version[2];    "00"
-      ASCIIZ("wheel", 32),   # char uname[32];     ASCIIZ
-      ASCIIZ("wheel", 32),   # char gname[32];     ASCIIZ
-      Z(to_oct(0, 7)),       # char devmajor[8];   0 padded, octal, null
-      Z(to_oct(0, 7)),       # char devminor[8];   0 padded, octal, null
-      ASCIIZ(dname, 155)     # char prefix[155];   ASCII + (Z unless filled)
-    ]
-
-    h = arr.join
-    ret = h + "\0" * (512 - h.size)
-    assert_equal(512, ret.size)
-    ret
-  end
-
-  def tar_dir_header(name, prefix, mode, mtime)
-    h = header("5", name, prefix, 0, mode, mtime)
-    checksum = calc_checksum(h)
-    header("5", name, prefix, 0, mode, mtime, checksum)
-  end
-
-  def tar_file_header(fname, dname, mode, length, mtime)
-    h = header("0", fname, dname, length, mode, mtime)
-    checksum = calc_checksum(h)
-    header("0", fname, dname, length, mode, mtime, checksum)
-  end
-
-  def tar_symlink_header(fname, prefix, mode, mtime, linkname)
-    h = header("2", fname, prefix, 0, mode, mtime, nil, linkname)
-    checksum = calc_checksum(h)
-    header("2", fname, prefix, 0, mode, mtime, checksum, linkname)
-  end
-
-  def to_oct(n, pad_size)
-    "%0#{pad_size}o" % n
-  end
-
-  def util_entry(tar)
-    io = TempIO.new tar
-
-    header = Gem::Package::TarHeader.from io
-
-    Gem::Package::TarReader::Entry.new header, io
-  end
-
-  def util_dir_entry
-    util_entry tar_dir_header("foo", "bar", 0, Time.now)
-  end
-
-  def util_symlink_entry
-    util_entry tar_symlink_header("foo", "bar", 0, Time.now, "link")
-  end
-
-end
--- ruby2.7-2.7.6.orig/lib/rubygems/package/tar_writer.rb
+++ ruby2.7-2.7.6/lib/rubygems/package/tar_writer.rb
@@ -1,24 +1,19 @@
-# -*- coding: utf-8 -*-
 # frozen_string_literal: true
 #--
 # Copyright (C) 2004 Mauricio Julio Fernndez Pradier
 # See LICENSE.txt for additional licensing information.
 #++
 
-require 'digest'
-
 ##
 # Allows writing of tar files
 
 class Gem::Package::TarWriter
-
   class FileOverflow < StandardError; end
 
   ##
   # IO wrapper that allows writing a limited amount of data
 
   class BoundedStream
-
     ##
     # Maximum number of bytes that can be written
 
@@ -50,14 +45,12 @@ class Gem::Package::TarWriter
       @written += data.bytesize
       data.bytesize
     end
-
   end
 
   ##
   # IO wrapper that provides only #write
 
   class RestrictedStream
-
     ##
     # Creates a new RestrictedStream wrapping +io+
 
@@ -71,7 +64,6 @@ class Gem::Package::TarWriter
     def write(data)
       @io.write data
     end
-
   end
 
   ##
@@ -146,8 +138,7 @@ class Gem::Package::TarWriter
         if digest.respond_to? :name
           digest.name
         else
-          /::([^:]+)$/ =~ digest_algorithm.name
-          $1
+          digest_algorithm.class.name[/::([^:]+)\z/, 1]
         end
 
       [digest_name, digest]
@@ -175,7 +166,7 @@ class Gem::Package::TarWriter
   def add_file_signed(name, mode, signer)
     digest_algorithms = [
       signer.digest_algorithm,
-      Digest::SHA512,
+      Gem::Security.create_digest("SHA512"),
     ].compact.uniq
 
     digests = add_file_digest name, mode, digest_algorithms do |io|
@@ -313,17 +304,17 @@ class Gem::Package::TarWriter
       raise Gem::Package::TooLongFileName.new("File \"#{name}\" has a too long path (should be 256 or less)")
     end
 
-    prefix = ''
+    prefix = ""
     if name.bytesize > 100
-      parts = name.split('/', -1) # parts are never empty here
+      parts = name.split("/", -1) # parts are never empty here
       name = parts.pop            # initially empty for names with a trailing slash ("foo/.../bar/")
-      prefix = parts.join('/')    # if empty, then it's impossible to split (parts is empty too)
+      prefix = parts.join("/")    # if empty, then it's impossible to split (parts is empty too)
       while !parts.empty? && (prefix.bytesize > 155 || name.empty?)
-        name = parts.pop + '/' + name
-        prefix = parts.join('/')
+        name = parts.pop + "/" + name
+        prefix = parts.join("/")
       end
 
-      if name.bytesize > 100 or prefix.empty?
+      if name.bytesize > 100 || prefix.empty?
         raise Gem::Package::TooLongFileName.new("File \"#{prefix}/#{name}\" has a too long name (should be 100 or less)")
       end
 
@@ -334,5 +325,4 @@ class Gem::Package::TarWriter
 
     return name, prefix
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/package_task.rb
+++ ruby2.7-2.7.6/lib/rubygems/package_task.rb
@@ -20,14 +20,9 @@
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
-require 'rubygems'
-require 'rubygems/package'
-begin
-  gem 'rake'
-rescue Gem::LoadError
-end
-
-require 'rake/packagetask'
+require_relative "../rubygems"
+require_relative "package"
+require "rake/packagetask"
 
 ##
 # Create a package based upon a Gem::Specification.  Gem packages, as well as
@@ -62,7 +57,6 @@ require 'rake/packagetask'
 #   end
 
 class Gem::PackageTask < Rake::PackageTask
-
   ##
   # Ruby Gem::Specification containing the metadata for this package.  The
   # name, version and package_files are automatically determined from the
@@ -88,6 +82,7 @@ class Gem::PackageTask < Rake::PackageTa
     super gem.full_name, :noversion
     @gem_spec = gem
     @package_files += gem_spec.files if gem_spec.files
+    @fileutils_output = $stdout
   end
 
   ##
@@ -118,11 +113,10 @@ class Gem::PackageTask < Rake::PackageTa
           Gem::Package.build gem_spec
 
           verbose trace do
-            mv gem_file, '..'
+            mv gem_file, ".."
           end
         end
       end
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/path_support.rb
+++ ruby2.7-2.7.6/lib/rubygems/path_support.rb
@@ -5,7 +5,6 @@
 # to the rest of RubyGems.
 #
 class Gem::PathSupport
-
   ##
   # The default system path for managing Gems.
   attr_reader :home
@@ -68,17 +67,12 @@ class Gem::PathSupport
       gem_path = default_path
     end
 
-    gem_path.map { |path| expand(path) }.uniq
+    gem_path.map {|path| expand(path) }.uniq
   end
 
   # Return the default Gem path
   def default_path
-    gem_path = Gem.default_path + [@home]
-
-    if defined?(APPLE_GEM_HOME)
-      gem_path << APPLE_GEM_HOME
-    end
-    gem_path
+    Gem.default_path + [@home]
   end
 
   def expand(path)
@@ -88,5 +82,4 @@ class Gem::PathSupport
       path
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/platform.rb
+++ ruby2.7-2.7.6/lib/rubygems/platform.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require "rubygems/deprecate"
+require_relative "deprecate"
 
 ##
 # Available list of platforms for targeting Gem installations.
@@ -7,34 +7,48 @@ require "rubygems/deprecate"
 # See `gem help platform` for information on platform matching.
 
 class Gem::Platform
-
   @local = nil
 
-  attr_accessor :cpu
-
-  attr_accessor :os
-
-  attr_accessor :version
+  attr_accessor :cpu, :os, :version
 
   def self.local
-    arch = RbConfig::CONFIG['arch']
+    arch = RbConfig::CONFIG["arch"]
     arch = "#{arch}_60" if arch =~ /mswin(?:32|64)$/
     @local ||= new(arch)
   end
 
   def self.match(platform)
-    Gem.platforms.any? do |local_platform|
-      platform.nil? or
-        local_platform == platform or
-        (local_platform != Gem::Platform::RUBY and local_platform =~ platform)
+    match_platforms?(platform, Gem.platforms)
+  end
+
+  def self.match_platforms?(platform, platforms)
+    platforms.any? do |local_platform|
+      platform.nil? ||
+        local_platform == platform ||
+        (local_platform != Gem::Platform::RUBY && platform =~ local_platform)
     end
   end
+  private_class_method :match_platforms?
+
+  def self.match_spec?(spec)
+    match_gem?(spec.platform, spec.name)
+  end
+
+  def self.match_gem?(platform, gem_name)
+    # Note: this method might be redefined by Ruby implementations to
+    # customize behavior per RUBY_ENGINE, gem_name or other criteria.
+    match_platforms?(platform, Gem.platforms)
+  end
+
+  def self.sort_priority(platform)
+    platform == Gem::Platform::RUBY ? -1 : 1
+  end
 
   def self.installable?(spec)
     if spec.respond_to? :installable_platform?
       spec.installable_platform?
     else
-      match spec.platform
+      match_spec? spec
     end
   end
 
@@ -42,7 +56,7 @@ class Gem::Platform
     case arch
     when Gem::Platform::CURRENT then
       Gem::Platform.local
-    when Gem::Platform::RUBY, nil, '' then
+    when Gem::Platform::RUBY, nil, "" then
       Gem::Platform::RUBY
     else
       super
@@ -54,9 +68,9 @@ class Gem::Platform
     when Array then
       @cpu, @os, @version = arch
     when String then
-      arch = arch.split '-'
+      arch = arch.split "-"
 
-      if arch.length > 2 and arch.last !~ /\d/  # reassemble x86-linux-gnu
+      if arch.length > 2 && arch.last !~ /\d+(\.\d+)?$/ # reassemble x86-linux-{libc}
         extra = arch.pop
         arch.last << "-#{extra}"
       end
@@ -64,11 +78,11 @@ class Gem::Platform
       cpu = arch.shift
 
       @cpu = case cpu
-             when /i\d86/ then 'x86'
-             else cpu
-             end
+      when /i\d86/ then "x86"
+      else cpu
+      end
 
-      if arch.length == 2 and arch.last =~ /^\d+(\.\d+)?$/  # for command-line
+      if arch.length == 2 && arch.last =~ /^\d+(\.\d+)?$/ # for command-line
         @os, @version = arch
         return
       end
@@ -77,31 +91,32 @@ class Gem::Platform
       @cpu, os = nil, cpu if os.nil? # legacy jruby
 
       @os, @version = case os
-                      when /aix(\d+)?/ then             [ 'aix',       $1  ]
-                      when /cygwin/ then                [ 'cygwin',    nil ]
-                      when /darwin(\d+)?/ then          [ 'darwin',    $1  ]
-                      when /^macruby$/ then             [ 'macruby',   nil ]
-                      when /freebsd(\d+)?/ then         [ 'freebsd',   $1  ]
-                      when /hpux(\d+)?/ then            [ 'hpux',      $1  ]
-                      when /^java$/, /^jruby$/ then     [ 'java',      nil ]
-                      when /^java([\d.]*)/ then         [ 'java',      $1  ]
-                      when /^dalvik(\d+)?$/ then        [ 'dalvik',    $1  ]
-                      when /^dotnet$/ then              [ 'dotnet',    nil ]
-                      when /^dotnet([\d.]*)/ then       [ 'dotnet',    $1  ]
-                      when /linux-?((?!gnu)\w+)?/ then  [ 'linux',     $1  ]
-                      when /mingw32/ then               [ 'mingw32',   nil ]
-                      when /(mswin\d+)(\_(\d+))?/ then
-                        os, version = $1, $3
-                        @cpu = 'x86' if @cpu.nil? and os =~ /32$/
-                        [os, version]
-                      when /netbsdelf/ then             [ 'netbsdelf', nil ]
-                      when /openbsd(\d+\.\d+)?/ then    [ 'openbsd',   $1  ]
-                      when /bitrig(\d+\.\d+)?/ then     [ 'bitrig',    $1  ]
-                      when /solaris(\d+\.\d+)?/ then    [ 'solaris',   $1  ]
-                      # test
-                      when /^(\w+_platform)(\d+)?/ then [ $1,          $2  ]
-                      else                              [ 'unknown',   nil ]
-                      end
+      when /aix(\d+)?/ then             [ "aix",       $1  ]
+      when /cygwin/ then                [ "cygwin",    nil ]
+      when /darwin(\d+)?/ then          [ "darwin",    $1  ]
+      when /^macruby$/ then             [ "macruby",   nil ]
+      when /freebsd(\d+)?/ then         [ "freebsd",   $1  ]
+      when /hpux(\d+)?/ then            [ "hpux",      $1  ]
+      when /^java$/, /^jruby$/ then     [ "java",      nil ]
+      when /^java([\d.]*)/ then         [ "java",      $1  ]
+      when /^dalvik(\d+)?$/ then        [ "dalvik",    $1  ]
+      when /^dotnet$/ then              [ "dotnet",    nil ]
+      when /^dotnet([\d.]*)/ then       [ "dotnet",    $1  ]
+      when /linux-?(\w+)?/ then         [ "linux",     $1  ]
+      when /mingw32/ then               [ "mingw32",   nil ]
+      when /mingw-?(\w+)?/ then         [ "mingw",     $1  ]
+      when /(mswin\d+)(\_(\d+))?/ then
+        os, version = $1, $3
+        @cpu = "x86" if @cpu.nil? && os =~ /32$/
+        [os, version]
+      when /netbsdelf/ then             [ "netbsdelf", nil ]
+      when /openbsd(\d+\.\d+)?/ then    [ "openbsd",   $1  ]
+      when /bitrig(\d+\.\d+)?/ then     [ "bitrig",    $1  ]
+      when /solaris(\d+\.\d+)?/ then    [ "solaris",   $1  ]
+      # test
+      when /^(\w+_platform)(\d+)?/ then [ $1,          $2  ]
+      else                              [ "unknown",   nil ]
+      end
     when Gem::Platform then
       @cpu = arch.cpu
       @os = arch.os
@@ -111,16 +126,12 @@ class Gem::Platform
     end
   end
 
-  def inspect
-    "%s @cpu=%p, @os=%p, @version=%p>" % [super[0..-2], *to_a]
-  end
-
   def to_a
     [@cpu, @os, @version]
   end
 
   def to_s
-    to_a.compact.join '-'
+    to_a.compact.join "-"
   end
 
   ##
@@ -128,7 +139,7 @@ class Gem::Platform
   # the same CPU, OS and version.
 
   def ==(other)
-    self.class === other and to_a == other.to_a
+    self.class === other && to_a == other.to_a
   end
 
   alias :eql? :==
@@ -140,23 +151,38 @@ class Gem::Platform
   ##
   # Does +other+ match this platform?  Two platforms match if they have the
   # same CPU, or either has a CPU of 'universal', they have the same OS, and
-  # they have the same version, or either has no version.
+  # they have the same version, or either one has no version
   #
   # Additionally, the platform will match if the local CPU is 'arm' and the
   # other CPU starts with "arm" (for generic ARM family support).
+  #
+  # Of note, this method is not commutative. Indeed the OS 'linux' has a
+  # special case: the version is the libc name, yet while "no version" stands
+  # as a wildcard for a binary gem platform (as for other OSes), for the
+  # runtime platform "no version" stands for 'gnu'. To be able to disinguish
+  # these, the method receiver is the gem platform, while the argument is
+  # the runtime platform.
 
   def ===(other)
     return nil unless Gem::Platform === other
 
+    # universal-mingw32 matches x64-mingw-ucrt
+    return true if (@cpu == "universal" || other.cpu == "universal") &&
+                   @os.start_with?("mingw") && other.os.start_with?("mingw")
+
     # cpu
-    ([nil,'universal'].include?(@cpu) or [nil, 'universal'].include?(other.cpu) or @cpu == other.cpu or
-    (@cpu == 'arm' and other.cpu =~ /\Aarm/)) and
+    ([nil,"universal"].include?(@cpu) || [nil, "universal"].include?(other.cpu) || @cpu == other.cpu ||
+    (@cpu == "arm" && other.cpu.start_with?("arm"))) &&
 
-    # os
-    @os == other.os and
+      # os
+      @os == other.os &&
 
-    # version
-    (@version.nil? or other.version.nil? or @version == other.version)
+      # version
+      (
+        (@os != "linux" && (@version.nil? || other.version.nil?)) ||
+        (@os == "linux" && (other.version == "gnu#{@version}" || other.version == "musl#{@version}" || @version == "gnu#{other.version}")) ||
+        @version == other.version
+      )
   end
 
   ##
@@ -169,19 +195,19 @@ class Gem::Platform
     when String then
       # This data is from http://gems.rubyforge.org/gems/yaml on 19 Aug 2007
       other = case other
-              when /^i686-darwin(\d)/     then ['x86',       'darwin',  $1    ]
-              when /^i\d86-linux/         then ['x86',       'linux',   nil   ]
-              when 'java', 'jruby'        then [nil,         'java',    nil   ]
-              when /^dalvik(\d+)?$/       then [nil,         'dalvik',  $1    ]
-              when /dotnet(\-(\d+\.\d+))?/ then ['universal','dotnet',  $2    ]
-              when /mswin32(\_(\d+))?/    then ['x86',       'mswin32', $2    ]
-              when /mswin64(\_(\d+))?/    then ['x64',       'mswin64', $2    ]
-              when 'powerpc-darwin'       then ['powerpc',   'darwin',  nil   ]
-              when /powerpc-darwin(\d)/   then ['powerpc',   'darwin',  $1    ]
-              when /sparc-solaris2.8/     then ['sparc',     'solaris', '2.8' ]
-              when /universal-darwin(\d)/ then ['universal', 'darwin',  $1    ]
-              else                             other
-              end
+      when /^i686-darwin(\d)/     then ["x86",       "darwin",  $1    ]
+      when /^i\d86-linux/         then ["x86",       "linux",   nil   ]
+      when "java", "jruby"        then [nil,         "java",    nil   ]
+      when /^dalvik(\d+)?$/       then [nil,         "dalvik",  $1    ]
+      when /dotnet(\-(\d+\.\d+))?/ then ["universal","dotnet",  $2    ]
+      when /mswin32(\_(\d+))?/    then ["x86",       "mswin32", $2    ]
+      when /mswin64(\_(\d+))?/    then ["x64",       "mswin64", $2    ]
+      when "powerpc-darwin"       then ["powerpc",   "darwin",  nil   ]
+      when /powerpc-darwin(\d)/   then ["powerpc",   "darwin",  $1    ]
+      when /sparc-solaris2.8/     then ["sparc",     "solaris", "2.8" ]
+      when /universal-darwin(\d)/ then ["universal", "darwin",  $1    ]
+      else                             other
+      end
 
       other = Gem::Platform.new other
     else
@@ -195,12 +221,11 @@ class Gem::Platform
   # A pure-Ruby gem that may use Gem::Specification#extensions to build
   # binary files.
 
-  RUBY = 'ruby'.freeze
+  RUBY = "ruby".freeze
 
   ##
   # A platform-specific gem that is built for the packaging Ruby's platform.
   # This will be replaced with Gem::Platform::local.
 
-  CURRENT = 'current'.freeze
-
+  CURRENT = "current".freeze
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/psych_additions.rb
+++ /dev/null
@@ -1,10 +0,0 @@
-# frozen_string_literal: true
-# This exists just to satisfy bugs in marshal'd gemspecs that
-# contain a reference to YAML::PrivateType. We prune these out
-# in Specification._load, but if we don't have the constant, Marshal
-# blows up.
-
-module Psych # :nodoc:
-  class PrivateType # :nodoc:
-  end
-end
--- ruby2.7-2.7.6.orig/lib/rubygems/psych_tree.rb
+++ ruby2.7-2.7.6/lib/rubygems/psych_tree.rb
@@ -2,13 +2,12 @@
 module Gem
   if defined? ::Psych::Visitors
     class NoAliasYAMLTree < Psych::Visitors::YAMLTree
-
       def self.create
         new({})
       end unless respond_to? :create
 
       def visit_String(str)
-        return super unless str == '=' # or whatever you want
+        return super unless str == "=" # or whatever you want
 
         quote = Psych::Nodes::Scalar::SINGLE_QUOTED
         @emitter.scalar str, nil, nil, false, true, quote
@@ -28,7 +27,6 @@ module Gem
       end
 
       private :format_time
-
     end
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/query_utils.rb
@@ -0,0 +1,351 @@
+# frozen_string_literal: true
+
+require_relative "local_remote_options"
+require_relative "spec_fetcher"
+require_relative "version_option"
+require_relative "text"
+
+module Gem::QueryUtils
+
+  include Gem::Text
+  include Gem::LocalRemoteOptions
+  include Gem::VersionOption
+
+  def add_query_options
+    add_option("-i", "--[no-]installed",
+               "Check for installed gem") do |value, options|
+      options[:installed] = value
+    end
+
+    add_option("-I", "Equivalent to --no-installed") do |value, options|
+      options[:installed] = false
+    end
+
+    add_version_option command, "for use with --installed"
+
+    add_option("-d", "--[no-]details",
+               "Display detailed information of gem(s)") do |value, options|
+      options[:details] = value
+    end
+
+    add_option("--[no-]versions",
+               "Display only gem names") do |value, options|
+      options[:versions] = value
+      options[:details] = false unless value
+    end
+
+    add_option("-a", "--all",
+               "Display all gem versions") do |value, options|
+      options[:all] = value
+    end
+
+    add_option("-e", "--exact",
+               "Name of gem(s) to query on matches the",
+               "provided STRING") do |value, options|
+      options[:exact] = value
+    end
+
+    add_option("--[no-]prerelease",
+               "Display prerelease versions") do |value, options|
+      options[:prerelease] = value
+    end
+
+    add_local_remote_options
+  end
+
+  def defaults_str # :nodoc:
+    "--local --no-details --versions --no-installed"
+  end
+
+  def execute
+    gem_names = if args.empty?
+      [options[:name]]
+    else
+      options[:exact] ? args.map {|arg| /\A#{Regexp.escape(arg)}\Z/ } : args.map {|arg| /#{arg}/i }
+    end
+
+    terminate_interaction(check_installed_gems(gem_names)) if check_installed_gems?
+
+    gem_names.each {|n| show_gems(n) }
+  end
+
+  private
+
+  def check_installed_gems(gem_names)
+    exit_code = 0
+
+    if args.empty? && !gem_name?
+      alert_error "You must specify a gem name"
+      exit_code = 4
+    elsif gem_names.count > 1
+      alert_error "You must specify only ONE gem!"
+      exit_code = 4
+    else
+      installed = installed?(gem_names.first, options[:version])
+      installed = !installed unless options[:installed]
+
+      say(installed)
+      exit_code = 1 if !installed
+    end
+
+    exit_code
+  end
+
+  def check_installed_gems?
+    !options[:installed].nil?
+  end
+
+  def gem_name?
+    !options[:name].nil?
+  end
+
+  def prerelease
+    options[:prerelease]
+  end
+
+  def show_prereleases?
+    prerelease.nil? || prerelease
+  end
+
+  def args
+    options[:args].to_a
+  end
+
+  def display_header(type)
+    if (ui.outs.tty? && Gem.configuration.verbose) || both?
+      say
+      say "*** #{type} GEMS ***"
+      say
+    end
+  end
+
+  #Guts of original execute
+  def show_gems(name)
+    show_local_gems(name)  if local?
+    show_remote_gems(name) if remote?
+  end
+
+  def show_local_gems(name, req = Gem::Requirement.default)
+    display_header("LOCAL")
+
+    specs = Gem::Specification.find_all do |s|
+      name_matches = name ? s.name =~ name : true
+      version_matches = show_prereleases? || !s.version.prerelease?
+
+      name_matches && version_matches
+    end
+
+    spec_tuples = specs.map do |spec|
+      [spec.name_tuple, spec]
+    end
+
+    output_query_results(spec_tuples)
+  end
+
+  def show_remote_gems(name)
+    display_header("REMOTE")
+
+    fetcher = Gem::SpecFetcher.fetcher
+
+    spec_tuples = if name.nil?
+      fetcher.detect(specs_type) { true }
+    else
+      fetcher.detect(specs_type) do |name_tuple|
+        name === name_tuple.name && options[:version].satisfied_by?(name_tuple.version)
+      end
+    end
+
+    output_query_results(spec_tuples)
+  end
+
+  def specs_type
+    if options[:all] || options[:version].specific?
+      if options[:prerelease]
+        :complete
+      else
+        :released
+      end
+    elsif options[:prerelease]
+      :prerelease
+    else
+      :latest
+    end
+  end
+
+  ##
+  # Check if gem +name+ version +version+ is installed.
+
+  def installed?(name, req = Gem::Requirement.default)
+    Gem::Specification.any? {|s| s.name =~ name && req =~ s.version }
+  end
+
+  def output_query_results(spec_tuples)
+    output = []
+    versions = Hash.new {|h,name| h[name] = [] }
+
+    spec_tuples.each do |spec_tuple, source|
+      versions[spec_tuple.name] << [spec_tuple, source]
+    end
+
+    versions = versions.sort_by do |(n,_),_|
+      n.downcase
+    end
+
+    output_versions output, versions
+
+    say output.join(options[:details] ? "\n\n" : "\n")
+  end
+
+  def output_versions(output, versions)
+    versions.each do |gem_name, matching_tuples|
+      matching_tuples = matching_tuples.sort_by {|n,_| n.version }.reverse
+
+      platforms = Hash.new {|h,version| h[version] = [] }
+
+      matching_tuples.each do |n, _|
+        platforms[n.version] << n.platform if n.platform
+      end
+
+      seen = {}
+
+      matching_tuples.delete_if do |n,_|
+        if seen[n.version]
+          true
+        else
+          seen[n.version] = true
+          false
+        end
+      end
+
+      output << clean_text(make_entry(matching_tuples, platforms))
+    end
+  end
+
+  def entry_details(entry, detail_tuple, specs, platforms)
+    return unless options[:details]
+
+    name_tuple, spec = detail_tuple
+
+    spec = spec.fetch_spec(name_tuple)if spec.respond_to?(:fetch_spec)
+
+    entry << "\n"
+
+    spec_platforms   entry, platforms
+    spec_authors     entry, spec
+    spec_homepage    entry, spec
+    spec_license     entry, spec
+    spec_loaded_from entry, spec, specs
+    spec_summary     entry, spec
+  end
+
+  def entry_versions(entry, name_tuples, platforms, specs)
+    return unless options[:versions]
+
+    list =
+      if platforms.empty? || options[:details]
+        name_tuples.map {|n| n.version }.uniq
+      else
+        platforms.sort.reverse.map do |version, pls|
+          out = version.to_s
+
+          if options[:domain] == :local
+            default = specs.any? do |s|
+              !s.is_a?(Gem::Source) && s.version == version && s.default_gem?
+            end
+            out = "default: #{out}" if default
+          end
+
+          if pls != [Gem::Platform::RUBY]
+            platform_list = [pls.delete(Gem::Platform::RUBY), *pls.sort].compact
+            out = platform_list.unshift(out).join(" ")
+          end
+
+          out
+        end
+      end
+
+    entry << " (#{list.join ', '})"
+  end
+
+  def make_entry(entry_tuples, platforms)
+    detail_tuple = entry_tuples.first
+
+    name_tuples, specs = entry_tuples.flatten.partition do |item|
+      Gem::NameTuple === item
+    end
+
+    entry = [name_tuples.first.name]
+
+    entry_versions(entry, name_tuples, platforms, specs)
+    entry_details(entry, detail_tuple, specs, platforms)
+
+    entry.join
+  end
+
+  def spec_authors(entry, spec)
+    authors = "Author#{spec.authors.length > 1 ? 's' : ''}: ".dup
+    authors << spec.authors.join(", ")
+    entry << format_text(authors, 68, 4)
+  end
+
+  def spec_homepage(entry, spec)
+    return if spec.homepage.nil? || spec.homepage.empty?
+
+    entry << "\n" << format_text("Homepage: #{spec.homepage}", 68, 4)
+  end
+
+  def spec_license(entry, spec)
+    return if spec.license.nil? || spec.license.empty?
+
+    licenses = "License#{spec.licenses.length > 1 ? 's' : ''}: ".dup
+    licenses << spec.licenses.join(", ")
+    entry << "\n" << format_text(licenses, 68, 4)
+  end
+
+  def spec_loaded_from(entry, spec, specs)
+    return unless spec.loaded_from
+
+    if specs.length == 1
+      default = spec.default_gem? ? " (default)" : nil
+      entry << "\n" << "    Installed at#{default}: #{spec.base_dir}"
+    else
+      label = "Installed at"
+      specs.each do |s|
+        version = s.version.to_s
+        version << ", default" if s.default_gem?
+        entry << "\n" << "    #{label} (#{version}): #{s.base_dir}"
+        label = " " * label.length
+      end
+    end
+  end
+
+  def spec_platforms(entry, platforms)
+    non_ruby = platforms.any? do |_, pls|
+      pls.any? {|pl| pl != Gem::Platform::RUBY }
+    end
+
+    return unless non_ruby
+
+    if platforms.length == 1
+      title = platforms.values.length == 1 ? "Platform" : "Platforms"
+      entry << "    #{title}: #{platforms.values.sort.join(', ')}\n"
+    else
+      entry << "    Platforms:\n"
+
+      sorted_platforms = platforms.sort_by {|version,| version }
+
+      sorted_platforms.each do |version, pls|
+        label = "        #{version}: "
+        data = format_text pls.sort.join(", "), 68, label.length
+        data[0, label.length] = label
+        entry << data << "\n"
+      end
+    end
+  end
+
+  def spec_summary(entry, spec)
+    summary = truncate_text(spec.summary, "the summary for #{spec.full_name}")
+    entry << "\n\n" << format_text(summary, 68, 4)
+  end
+
+end
--- ruby2.7-2.7.6.orig/lib/rubygems/rdoc.rb
+++ ruby2.7-2.7.6/lib/rubygems/rdoc.rb
@@ -1,20 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems'
+require_relative "../rubygems"
 
 begin
-  gem 'rdoc'
-rescue Gem::LoadError
-  # swallow
-else
-  # This will force any deps that 'rdoc' might have
-  # (such as json) that are ambiguous to be activated, which
-  # is important because we end up using Specification.reset
-  # and we don't want the warning it pops out.
-  Gem.finish_resolve
-end
-
-begin
-  require 'rdoc/rubygems_hook'
+  require "rdoc/rubygems_hook"
   module Gem
     RDoc = ::RDoc::RubygemsHook
   end
--- ruby2.7-2.7.6.orig/lib/rubygems/remote_fetcher.rb
+++ ruby2.7-2.7.6/lib/rubygems/remote_fetcher.rb
@@ -1,52 +1,41 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/request'
-require 'rubygems/request/connection_pools'
-require 'rubygems/s3_uri_signer'
-require 'rubygems/uri_formatter'
-require 'rubygems/uri_parsing'
-require 'rubygems/user_interaction'
-require 'resolv'
-require 'rubygems/deprecate'
+require_relative "../rubygems"
+require_relative "request"
+require_relative "request/connection_pools"
+require_relative "s3_uri_signer"
+require_relative "uri_formatter"
+require_relative "uri"
+require_relative "user_interaction"
 
 ##
 # RemoteFetcher handles the details of fetching gems and gem information from
 # a remote source.
 
 class Gem::RemoteFetcher
-
   include Gem::UserInteraction
-  extend Gem::Deprecate
-
-  include Gem::UriParsing
 
   ##
   # A FetchError exception wraps up the various possible IO and HTTP failures
   # that could happen while downloading from the internet.
 
   class FetchError < Gem::Exception
-
-    include Gem::UriParsing
-
     ##
     # The URI which was being accessed when the exception happened.
 
-    attr_accessor :uri
+    attr_accessor :uri, :original_uri
 
     def initialize(message, uri)
-      super message
-
-      uri = parse_uri(uri)
+      uri = Gem::Uri.new(uri)
 
-      uri.password = 'REDACTED' if uri.respond_to?(:password) && uri.password
+      super uri.redact_credentials_from(message)
 
-      @uri = uri.to_s
+      @original_uri = uri.to_s
+      @uri = uri.redacted.to_s
     end
 
     def to_s # :nodoc:
       "#{super} (#{uri})"
     end
-
   end
 
   ##
@@ -55,6 +44,7 @@ class Gem::RemoteFetcher
 
   class UnknownHostError < FetchError
   end
+  deprecate_constant(:UnknownHostError)
 
   @fetcher = nil
 
@@ -82,16 +72,16 @@ class Gem::RemoteFetcher
   #            fetching the gem.
 
   def initialize(proxy=nil, dns=nil, headers={})
-    require 'net/http'
-    require 'stringio'
-    require 'time'
-    require 'uri'
+    require_relative "core_ext/tcpsocket_init" if Gem.configuration.ipv4_fallback_enabled
+    require "net/http"
+    require "stringio"
+    require "uri"
 
     Socket.do_not_reverse_lookup = true
 
     @proxy = proxy
     @pools = {}
-    @pool_lock = Mutex.new
+    @pool_lock = Thread::Mutex.new
     @cert_files = Gem::Request.get_cert_files
 
     @headers = headers
@@ -109,7 +99,7 @@ class Gem::RemoteFetcher
 
     return if found.empty?
 
-    spec, source = found.max_by { |(s,_)| s.version }
+    spec, source = found.max_by {|(s,_)| s.version }
 
     download spec, source.uri
   end
@@ -120,11 +110,12 @@ class Gem::RemoteFetcher
   # always replaced.
 
   def download(spec, source_uri, install_dir = Gem.dir)
+    install_cache_dir = File.join install_dir, "cache"
     cache_dir =
-      if Dir.pwd == install_dir  # see fetch_command
+      if Dir.pwd == install_dir # see fetch_command
         install_dir
-      elsif File.writable? install_dir
-        File.join install_dir, "cache"
+      elsif File.writable?(install_cache_dir) || (File.writable?(install_dir) && (!File.exist?(install_cache_dir)))
+        install_cache_dir
       else
         File.join Gem.user_dir, "cache"
       end
@@ -132,9 +123,10 @@ class Gem::RemoteFetcher
     gem_file_name = File.basename spec.cache_file
     local_gem_path = File.join cache_dir, gem_file_name
 
+    require "fileutils"
     FileUtils.mkdir_p cache_dir rescue nil unless File.exist? cache_dir
 
-    source_uri = parse_uri(source_uri)
+    source_uri = Gem::Uri.new(source_uri)
 
     scheme = source_uri.scheme
 
@@ -144,7 +136,7 @@ class Gem::RemoteFetcher
     # REFACTOR: split this up and dispatch on scheme (eg download_http)
     # REFACTOR: be sure to clean up fake fetcher when you do this... cleaner
     case scheme
-    when 'http', 'https', 's3' then
+    when "http", "https", "s3" then
       unless File.exist? local_gem_path
         begin
           verbose "Downloading gem #{gem_file_name}"
@@ -164,12 +156,12 @@ class Gem::RemoteFetcher
           self.cache_update_path remote_gem_path, local_gem_path
         end
       end
-    when 'file' then
+    when "file" then
       begin
         path = source_uri.path
-        path = File.dirname(path) if File.extname(path) == '.gem'
+        path = File.dirname(path) if File.extname(path) == ".gem"
 
-        remote_gem_path = Gem::Util.correct_for_windows_path(File.join(path, 'gems', gem_file_name))
+        remote_gem_path = Gem::Util.correct_for_windows_path(File.join(path, "gems", gem_file_name))
 
         FileUtils.cp(remote_gem_path, local_gem_path)
       rescue Errno::EACCES
@@ -179,11 +171,11 @@ class Gem::RemoteFetcher
       verbose "Using local gem #{local_gem_path}"
     when nil then # TODO test for local overriding cache
       source_path = if Gem.win_platform? && source_uri.scheme &&
-                       !source_uri.path.include?(':')
-                      "#{source_uri.scheme}:#{source_uri.path}"
-                    else
-                      source_uri.path
-                    end
+                       !source_uri.path.include?(":")
+        "#{source_uri.scheme}:#{source_uri.path}"
+      else
+        source_uri.path
+      end
 
       source_path = Gem::UriFormatter.new(source_path).unescape
 
@@ -215,21 +207,21 @@ class Gem::RemoteFetcher
   def fetch_http(uri, last_modified = nil, head = false, depth = 0)
     fetch_type = head ? Net::HTTP::Head : Net::HTTP::Get
     response   = request uri, fetch_type, last_modified do |req|
-      headers.each { |k,v| req.add_field(k,v) }
+      headers.each {|k,v| req.add_field(k,v) }
     end
 
     case response
     when Net::HTTPOK, Net::HTTPNotModified then
-      response.uri = uri if response.respond_to? :uri
+      response.uri = uri
       head ? response : response.body
     when Net::HTTPMovedPermanently, Net::HTTPFound, Net::HTTPSeeOther,
          Net::HTTPTemporaryRedirect then
-      raise FetchError.new('too many redirects', uri) if depth > 10
+      raise FetchError.new("too many redirects", uri) if depth > 10
 
-      unless location = response['Location']
+      unless location = response["Location"]
         raise FetchError.new("redirecting but no redirect location was given", uri)
       end
-      location = parse_uri location
+      location = Gem::Uri.new location
 
       if https?(uri) && !https?(location)
         raise FetchError.new("redirecting to non-https resource: #{location}", uri)
@@ -247,7 +239,7 @@ class Gem::RemoteFetcher
   # Downloads +uri+ and returns it as a String.
 
   def fetch_path(uri, mtime = nil, head = false)
-    uri = parse_uri uri
+    uri = Gem::Uri.new uri
 
     unless uri.scheme
       raise ArgumentError, "uri scheme is invalid: #{uri.scheme.inspect}"
@@ -255,7 +247,7 @@ class Gem::RemoteFetcher
 
     data = send "fetch_#{uri.scheme}", uri, mtime, head
 
-    if data and !head and uri.to_s =~ /\.gz$/
+    if data && !head && uri.to_s.end_with?(".gz")
       begin
         data = Gem::Util.gunzip data
       rescue Zlib::GzipFile::Error
@@ -264,15 +256,9 @@ class Gem::RemoteFetcher
     end
 
     data
-  rescue Timeout::Error
-    raise UnknownHostError.new('timed out', uri)
-  rescue IOError, SocketError, SystemCallError,
-         *(OpenSSL::SSL::SSLError if defined?(OpenSSL)) => e
-    if e.message =~ /getaddrinfo/
-      raise UnknownHostError.new('no such name', uri)
-    else
-      raise FetchError.new("#{e.class}: #{e}", uri)
-    end
+  rescue Timeout::Error, IOError, SocketError, SystemCallError,
+         *(OpenSSL::SSL::SSLError if Gem::HAVE_OPENSSL) => e
+    raise FetchError.new("#{e.class}: #{e}", uri)
   end
 
   def fetch_s3(uri, mtime = nil, head = false)
@@ -298,11 +284,11 @@ class Gem::RemoteFetcher
 
     data = fetch_path(uri, mtime)
 
-    if data == nil # indicates the server returned 304 Not Modified
+    if data.nil? # indicates the server returned 304 Not Modified
       return Gem.read_binary(path)
     end
 
-    if update and path
+    if update && path
       Gem.write_binary(path, data)
     end
 
@@ -310,17 +296,6 @@ class Gem::RemoteFetcher
   end
 
   ##
-  # Returns the size of +uri+ in bytes.
-
-  def fetch_size(uri)
-    response = fetch_path(uri, nil, true)
-
-    response['content-length'].to_i
-  end
-
-  deprecate :fetch_size, :none, 2019, 12
-
-  ##
   # Performs a Net::HTTP request of type +request_class+ on +uri+ returning
   # a Net::HTTP response object.  request maintains a table of persistent
   # connections to reduce connect overhead.
@@ -337,11 +312,11 @@ class Gem::RemoteFetcher
   end
 
   def https?(uri)
-    uri.scheme.downcase == 'https'
+    uri.scheme.downcase == "https"
   end
 
   def close_all
-    @pools.each_value {|pool| pool.close_all}
+    @pools.each_value {|pool| pool.close_all }
   end
 
   private
@@ -355,5 +330,4 @@ class Gem::RemoteFetcher
       @pools[proxy] ||= Gem::Request::ConnectionPools.new proxy, @cert_files
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/request.rb
+++ ruby2.7-2.7.6/lib/rubygems/request.rb
@@ -1,10 +1,8 @@
 # frozen_string_literal: true
-require 'net/http'
-require 'time'
-require 'rubygems/user_interaction'
+require "net/http"
+require_relative "user_interaction"
 
 class Gem::Request
-
   extend Gem::UserInteraction
   include Gem::UserInteraction
 
@@ -41,12 +39,13 @@ class Gem::Request
   def cert_files; @connection_pool.cert_files; end
 
   def self.get_cert_files
-    pattern = File.expand_path("./ssl_certs/*/*.pem", File.dirname(__FILE__))
+    pattern = File.expand_path("./ssl_certs/*/*.pem", __dir__)
     Dir.glob(pattern)
   end
 
   def self.configure_connection_for_https(connection, cert_files)
-    require 'net/https'
+    raise Gem::Exception.new("OpenSSL is not available. Install OpenSSL and rebuild Ruby (preferred) or use non-HTTPS sources") unless Gem::HAVE_OPENSSL
+
     connection.use_ssl = true
     connection.verify_mode =
       Gem.configuration.ssl_verify_mode || OpenSSL::SSL::VERIFY_PEER
@@ -78,12 +77,6 @@ class Gem::Request
     end
 
     connection
-  rescue LoadError => e
-    raise unless (e.respond_to?(:path) && e.path == 'openssl') ||
-                 e.message =~ / -- openssl$/
-
-    raise Gem::Exception.new(
-            'Unable to require openssl, install OpenSSL and rebuild Ruby (preferred) or use non-HTTPS sources')
   end
 
   def self.verify_certificate(store_context)
@@ -103,8 +96,10 @@ class Gem::Request
     return unless cert
     case error_number
     when OpenSSL::X509::V_ERR_CERT_HAS_EXPIRED then
+      require "time"
       "Certificate #{cert.subject} expired at #{cert.not_after.iso8601}"
     when OpenSSL::X509::V_ERR_CERT_NOT_YET_VALID then
+      require "time"
       "Certificate #{cert.subject} not valid until #{cert.not_before.iso8601}"
     when OpenSSL::X509::V_ERR_CERT_REJECTED then
       "Certificate #{cert.subject} is rejected"
@@ -132,7 +127,7 @@ class Gem::Request
 
   def connection_for(uri)
     @connection_pool.checkout
-  rescue defined?(OpenSSL::SSL) ? OpenSSL::SSL::SSLError : Errno::EHOSTDOWN,
+  rescue Gem::HAVE_OPENSSL ? OpenSSL::SSL::SSLError : Errno::EHOSTDOWN,
          Errno::EHOSTDOWN => e
     raise Gem::RemoteFetcher::FetchError.new(e.message, uri)
   end
@@ -145,12 +140,13 @@ class Gem::Request
                          Gem::UriFormatter.new(@uri.password).unescape
     end
 
-    request.add_field 'User-Agent', @user_agent
-    request.add_field 'Connection', 'keep-alive'
-    request.add_field 'Keep-Alive', '30'
+    request.add_field "User-Agent", @user_agent
+    request.add_field "Connection", "keep-alive"
+    request.add_field "Keep-Alive", "30"
 
     if @last_modified
-      request.add_field 'If-Modified-Since', @last_modified.httpdate
+      require "time"
+      request.add_field "If-Modified-Since", @last_modified.httpdate
     end
 
     yield request if block_given?
@@ -162,7 +158,7 @@ class Gem::Request
   # Returns a proxy URI for the given +scheme+ if one is set in the
   # environment variables.
 
-  def self.get_proxy_from_env(scheme = 'http')
+  def self.get_proxy_from_env(scheme = "http")
     _scheme = scheme.downcase
     _SCHEME = scheme.upcase
     env_proxy = ENV["#{_scheme}_proxy"] || ENV["#{_SCHEME}_PROXY"]
@@ -170,14 +166,14 @@ class Gem::Request
     no_env_proxy = env_proxy.nil? || env_proxy.empty?
 
     if no_env_proxy
-      return (_scheme == 'https' || _scheme == 'http') ?
-        :no_proxy : get_proxy_from_env('http')
+      return (_scheme == "https" || _scheme == "http") ?
+        :no_proxy : get_proxy_from_env("http")
     end
 
     require "uri"
     uri = URI(Gem::UriFormatter.new(env_proxy).normalize)
 
-    if uri and uri.user.nil? and uri.password.nil?
+    if uri && uri.user.nil? && uri.password.nil?
       user     = ENV["#{_scheme}_proxy_user"] || ENV["#{_SCHEME}_PROXY_USER"]
       password = ENV["#{_scheme}_proxy_pass"] || ENV["#{_SCHEME}_PROXY_PASS"]
 
@@ -197,7 +193,7 @@ class Gem::Request
     begin
       @requests[connection.object_id] += 1
 
-      verbose "#{request.method} #{@uri}"
+      verbose "#{request.method} #{Gem::Uri.redact(@uri)}"
 
       file_name = File.basename(@uri.path)
       # perform download progress reporter only for gems
@@ -233,14 +229,14 @@ class Gem::Request
 
       reset connection
 
-      raise Gem::RemoteFetcher::FetchError.new('too many bad responses', @uri) if bad_response
+      raise Gem::RemoteFetcher::FetchError.new("too many bad responses", @uri) if bad_response
 
       bad_response = true
       retry
     rescue Net::HTTPFatalError
       verbose "fatal error"
 
-      raise Gem::RemoteFetcher::FetchError.new('fatal error', @uri)
+      raise Gem::RemoteFetcher::FetchError.new("fatal error", @uri)
     # HACK work around EOFError bug in Net::HTTP
     # NOTE Errno::ECONNABORTED raised a lot on Windows, and make impossible
     # to install gems.
@@ -250,7 +246,7 @@ class Gem::Request
       requests = @requests[connection.object_id]
       verbose "connection reset after #{requests} requests, retrying"
 
-      raise Gem::RemoteFetcher::FetchError.new('too many connection resets', @uri) if retried
+      raise Gem::RemoteFetcher::FetchError.new("too many connection resets", @uri) if retried
 
       reset connection
 
@@ -277,7 +273,7 @@ class Gem::Request
     ua = "RubyGems/#{Gem::VERSION} #{Gem::Platform.local}".dup
 
     ruby_version = RUBY_VERSION
-    ruby_version += 'dev' if RUBY_PATCHLEVEL == -1
+    ruby_version += "dev" if RUBY_PATCHLEVEL == -1
 
     ua << " Ruby/#{ruby_version} (#{RUBY_RELEASE_DATE}"
     if RUBY_PATCHLEVEL >= 0
@@ -287,13 +283,12 @@ class Gem::Request
     end
     ua << ")"
 
-    ua << " #{RUBY_ENGINE}" if RUBY_ENGINE != 'ruby'
+    ua << " #{RUBY_ENGINE}" if RUBY_ENGINE != "ruby"
 
     ua
   end
-
 end
 
-require 'rubygems/request/http_pool'
-require 'rubygems/request/https_pool'
-require 'rubygems/request/connection_pools'
+require_relative "request/http_pool"
+require_relative "request/https_pool"
+require_relative "request/connection_pools"
--- ruby2.7-2.7.6.orig/lib/rubygems/request/connection_pools.rb
+++ ruby2.7-2.7.6/lib/rubygems/request/connection_pools.rb
@@ -1,20 +1,17 @@
 # frozen_string_literal: true
 
 class Gem::Request::ConnectionPools # :nodoc:
-
   @client = Net::HTTP
 
   class << self
-
     attr_accessor :client
-
   end
 
   def initialize(proxy_uri, cert_files)
     @proxy_uri  = proxy_uri
     @cert_files = cert_files
     @pools      = {}
-    @pool_mutex = Mutex.new
+    @pool_mutex = Thread::Mutex.new
   end
 
   def pool_for(uri)
@@ -31,7 +28,7 @@ class Gem::Request::ConnectionPools # :n
   end
 
   def close_all
-    @pools.each_value {|pool| pool.close_all}
+    @pools.each_value {|pool| pool.close_all }
   end
 
   private
@@ -40,15 +37,15 @@ class Gem::Request::ConnectionPools # :n
   # Returns list of no_proxy entries (if any) from the environment
 
   def get_no_proxy_from_env
-    env_no_proxy = ENV['no_proxy'] || ENV['NO_PROXY']
+    env_no_proxy = ENV["no_proxy"] || ENV["NO_PROXY"]
 
-    return [] if env_no_proxy.nil? or env_no_proxy.empty?
+    return [] if env_no_proxy.nil? || env_no_proxy.empty?
 
     env_no_proxy.split(/\s*,\s*/)
   end
 
   def https?(uri)
-    uri.scheme.downcase == 'https'
+    uri.scheme.downcase == "https"
   end
 
   def no_proxy?(host, env_no_proxy)
@@ -81,7 +78,7 @@ class Gem::Request::ConnectionPools # :n
 
     no_proxy = get_no_proxy_from_env
 
-    if proxy_uri and not no_proxy?(hostname, no_proxy)
+    if proxy_uri && !no_proxy?(hostname, no_proxy)
       proxy_hostname = proxy_uri.respond_to?(:hostname) ? proxy_uri.hostname : proxy_uri.host
       net_http_args + [
         proxy_hostname,
@@ -95,5 +92,4 @@ class Gem::Request::ConnectionPools # :n
       net_http_args
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/request/http_pool.rb
+++ ruby2.7-2.7.6/lib/rubygems/request/http_pool.rb
@@ -6,14 +6,13 @@
 # use it.
 
 class Gem::Request::HTTPPool # :nodoc:
-
   attr_reader :cert_files, :proxy_uri
 
   def initialize(http_args, cert_files, proxy_uri)
     @http_args  = http_args
     @cert_files = cert_files
     @proxy_uri  = proxy_uri
-    @queue      = SizedQueue.new 1
+    @queue      = Thread::SizedQueue.new 1
     @queue << nil
   end
 
@@ -27,7 +26,7 @@ class Gem::Request::HTTPPool # :nodoc:
 
   def close_all
     until @queue.empty?
-      if connection = @queue.pop(true) and connection.started?
+      if (connection = @queue.pop(true)) && connection.started?
         connection.finish
       end
     end
@@ -44,5 +43,4 @@ class Gem::Request::HTTPPool # :nodoc:
     connection.start
     connection
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/request/https_pool.rb
+++ ruby2.7-2.7.6/lib/rubygems/request/https_pool.rb
@@ -1,11 +1,9 @@
 # frozen_string_literal: true
 class Gem::Request::HTTPSPool < Gem::Request::HTTPPool # :nodoc:
-
   private
 
   def setup_connection(connection)
     Gem::Request.configure_connection_for_https(connection, @cert_files)
     super
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/request_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/request_set.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'tsort'
+require_relative "tsort"
 
 ##
 # A RequestSet groups a request to activate a set of dependencies.
@@ -15,8 +15,7 @@ require 'tsort'
 #   #=> ["nokogiri-1.6.0", "mini_portile-0.5.1", "pg-0.17.0"]
 
 class Gem::RequestSet
-
-  include TSort
+  include Gem::TSort
 
   ##
   # Array of gems to install even if already installed
@@ -152,7 +151,7 @@ class Gem::RequestSet
     @prerelease = options[:prerelease]
 
     requests = []
-    download_queue = Queue.new
+    download_queue = Thread::Queue.new
 
     # Create a thread-safe list of gems to download
     sorted_requests.each do |req|
@@ -184,7 +183,7 @@ class Gem::RequestSet
       if req.installed?
         req.spec.spec.build_extensions
 
-        if @always_install.none? { |spec| spec == req.spec.spec }
+        if @always_install.none? {|spec| spec == req.spec.spec }
           yield req, nil if block_given?
           next
         end
@@ -196,19 +195,8 @@ class Gem::RequestSet
             yield req, installer if block_given?
           end
         rescue Gem::RuntimeRequirementNotMetError => e
-          recent_match = req.spec.set.find_all(req.request).sort_by(&:version).reverse_each.find do |s|
-            s = s.spec
-            s.required_ruby_version.satisfied_by?(Gem.ruby_version) &&
-              s.required_rubygems_version.satisfied_by?(Gem.rubygems_version) &&
-              Gem::Platform.installable?(s)
-          end
-          if recent_match
-            suggestion = "The last version of #{req.request} to support your Ruby & RubyGems was #{recent_match.version}. Try installing it with `gem install #{recent_match.name} -v #{recent_match.version}`"
-            suggestion += " and then running the current command again" unless @always_install.include?(req.spec.spec)
-          else
-            suggestion = "There are no versions of #{req.request} compatible with your Ruby & RubyGems"
-            suggestion += ". Maybe try installing an older version of the gem you're looking for?" unless @always_install.include?(req.spec.spec)
-          end
+          suggestion = "There are no versions of #{req.request} compatible with your Ruby & RubyGems"
+          suggestion += ". Maybe try installing an older version of the gem you're looking for?" unless @always_install.include?(req.spec.spec)
           e.suggestion = suggestion
           raise
         end
@@ -266,10 +254,10 @@ class Gem::RequestSet
   end
 
   def install_into(dir, force = true, options = {})
-    gem_home, ENV['GEM_HOME'] = ENV['GEM_HOME'], dir
+    gem_home, ENV["GEM_HOME"] = ENV["GEM_HOME"], dir
 
     existing = force ? [] : specs_in(dir)
-    existing.delete_if { |s| @always_install.include? s }
+    existing.delete_if {|s| @always_install.include? s }
 
     dir = File.expand_path dir
 
@@ -283,7 +271,7 @@ class Gem::RequestSet
     sorted_requests.each do |request|
       spec = request.spec
 
-      if existing.find { |s| s.full_name == spec.full_name }
+      if existing.find {|s| s.full_name == spec.full_name }
         yield request, nil if block_given?
         next
       end
@@ -299,7 +287,7 @@ class Gem::RequestSet
 
     installed
   ensure
-    ENV['GEM_HOME'] = gem_home
+    ENV["GEM_HOME"] = gem_home
   end
 
   ##
@@ -315,7 +303,7 @@ class Gem::RequestSet
       end
     end
 
-    require "rubygems/dependency_installer"
+    require_relative "dependency_installer"
     inst = Gem::DependencyInstaller.new options
     inst.installed_gems.replace specs
 
@@ -349,32 +337,32 @@ class Gem::RequestSet
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[RequestSet:', ']' do
+    q.group 2, "[RequestSet:", "]" do
       q.breakable
 
       if @remote
-        q.text 'remote'
+        q.text "remote"
         q.breakable
       end
 
       if @prerelease
-        q.text 'prerelease'
+        q.text "prerelease"
         q.breakable
       end
 
       if @development_shallow
-        q.text 'shallow development'
+        q.text "shallow development"
         q.breakable
       elsif @development
-        q.text 'development'
+        q.text "development"
         q.breakable
       end
 
       if @soft_missing
-        q.text 'soft missing'
+        q.text "soft missing"
       end
 
-      q.group 2, '[dependencies:', ']' do
+      q.group 2, "[dependencies:", "]" do
         q.breakable
         @dependencies.map do |dep|
           q.text dep.to_s
@@ -383,10 +371,10 @@ class Gem::RequestSet
       end
 
       q.breakable
-      q.text 'sets:'
+      q.text "sets:"
 
       q.breakable
-      q.pp @sets.map { |set| set.class }
+      q.pp @sets.map {|set| set.class }
     end
   end
 
@@ -440,7 +428,7 @@ class Gem::RequestSet
   end
 
   def specs
-    @specs ||= @requests.map { |r| r.full_spec }
+    @specs ||= @requests.map {|r| r.full_spec }
   end
 
   def specs_in(dir)
@@ -455,14 +443,14 @@ class Gem::RequestSet
 
   def tsort_each_child(node) # :nodoc:
     node.spec.dependencies.each do |dep|
-      next if dep.type == :development and not @development
+      next if dep.type == :development && !@development
 
       match = @requests.find do |r|
-        dep.match? r.spec.name, r.spec.version, @prerelease
+        dep.match? r.spec.name, r.spec.version, r.spec.is_a?(Gem::Resolver::InstalledSpecification) || @prerelease
       end
 
       unless match
-        next if dep.type == :development and @development_shallow
+        next if dep.type == :development && @development_shallow
         next if @soft_missing
         raise Gem::DependencyError,
               "Unresolved dependency found during sorting - #{dep} (requested by #{node.spec.full_name})"
@@ -471,9 +459,8 @@ class Gem::RequestSet
       yield match
     end
   end
-
 end
 
-require 'rubygems/request_set/gem_dependency_api'
-require 'rubygems/request_set/lockfile'
-require 'rubygems/request_set/lockfile/tokenizer'
+require_relative "request_set/gem_dependency_api"
+require_relative "request_set/lockfile"
+require_relative "request_set/lockfile/tokenizer"
--- ruby2.7-2.7.6.orig/lib/rubygems/request_set/gem_dependency_api.rb
+++ ruby2.7-2.7.6/lib/rubygems/request_set/gem_dependency_api.rb
@@ -31,7 +31,6 @@
 # See `gem help install` and `gem help gem_dependencies` for further details.
 
 class Gem::RequestSet::GemDependencyAPI
-
   ENGINE_MAP = { # :nodoc:
     :jruby        => %w[jruby],
     :jruby_18     => %w[jruby],
@@ -51,10 +50,10 @@ class Gem::RequestSet::GemDependencyAPI
     :ruby_21      => %w[ruby rbx maglev truffleruby],
   }.freeze
 
-  mswin     = Gem::Platform.new 'x86-mswin32'
-  mswin64   = Gem::Platform.new 'x64-mswin64'
-  x86_mingw = Gem::Platform.new 'x86-mingw32'
-  x64_mingw = Gem::Platform.new 'x64-mingw32'
+  mswin     = Gem::Platform.new "x86-mswin32"
+  mswin64   = Gem::Platform.new "x64-mswin64"
+  x86_mingw = Gem::Platform.new "x86-mingw32"
+  x64_mingw = Gem::Platform.new "x64-mingw32"
 
   PLATFORM_MAP = { # :nodoc:
     :jruby        => Gem::Platform::RUBY,
@@ -89,14 +88,14 @@ class Gem::RequestSet::GemDependencyAPI
     :truffleruby  => Gem::Platform::RUBY,
     :x64_mingw    => x64_mingw,
     :x64_mingw_20 => x64_mingw,
-    :x64_mingw_21 => x64_mingw
+    :x64_mingw_21 => x64_mingw,
   }.freeze
 
-  gt_eq_0        = Gem::Requirement.new '>= 0'
-  tilde_gt_1_8_0 = Gem::Requirement.new '~> 1.8.0'
-  tilde_gt_1_9_0 = Gem::Requirement.new '~> 1.9.0'
-  tilde_gt_2_0_0 = Gem::Requirement.new '~> 2.0.0'
-  tilde_gt_2_1_0 = Gem::Requirement.new '~> 2.1.0'
+  gt_eq_0        = Gem::Requirement.new ">= 0"
+  tilde_gt_1_8_0 = Gem::Requirement.new "~> 1.8.0"
+  tilde_gt_1_9_0 = Gem::Requirement.new "~> 1.9.0"
+  tilde_gt_2_0_0 = Gem::Requirement.new "~> 2.0.0"
+  tilde_gt_2_1_0 = Gem::Requirement.new "~> 2.1.0"
 
   VERSION_MAP = { # :nodoc:
     :jruby        => gt_eq_0,
@@ -206,7 +205,7 @@ class Gem::RequestSet::GemDependencyAPI
     @git_set            = @set.git_set
     @git_sources        = {}
     @installing         = false
-    @requires           = Hash.new { |h, name| h[name] = [] }
+    @requires           = Hash.new {|h, name| h[name] = [] }
     @vendor_set         = @set.vendor_set
     @source_set         = @set.source_set
     @gem_sources        = {}
@@ -372,7 +371,7 @@ class Gem::RequestSet::GemDependencyAPI
     duplicate = @dependencies.include? name
 
     @dependencies[name] =
-      if requirements.empty? and not source_set
+      if requirements.empty? && !source_set
         Gem::Requirement.default
       elsif source_set
         Gem::Requirement.source_set
@@ -380,7 +379,7 @@ class Gem::RequestSet::GemDependencyAPI
         Gem::Requirement.create requirements
       end
 
-    return unless gem_platforms options
+    return unless gem_platforms name, options
 
     groups = gem_group name, options
 
@@ -436,7 +435,7 @@ Gem dependencies file #{@path} requires 
     reference ||= ref
     reference ||= branch
     reference ||= tag
-    reference ||= 'master'
+    reference ||= "master"
 
     if ref && branch
       warn <<-WARNING
@@ -533,7 +532,7 @@ Gem dependencies file #{@path} includes 
   # Handles the platforms: option from +options+.  Returns true if the
   # platform matches the current platform.
 
-  def gem_platforms(options) # :nodoc:
+  def gem_platforms(name, options) # :nodoc:
     platform_names = Array(options.delete :platform)
     platform_names.concat Array(options.delete :platforms)
     platform_names.concat @current_platforms if @current_platforms
@@ -544,7 +543,7 @@ Gem dependencies file #{@path} includes 
       raise ArgumentError, "unknown platform #{platform_name.inspect}" unless
         platform = PLATFORM_MAP[platform_name]
 
-      next false unless Gem::Platform.match platform
+      next false unless Gem::Platform.match_gem? platform, name
 
       if engines = ENGINE_MAP[platform_name]
         next false unless engines.include? Gem.ruby_engine
@@ -638,8 +637,8 @@ Gem dependencies file #{@path} includes 
   #   :development.  Only one group may be specified.
 
   def gemspec(options = {})
-    name              = options.delete(:name) || '{,*}'
-    path              = options.delete(:path) || '.'
+    name              = options.delete(:name) || "{,*}"
+    path              = options.delete(:path) || "."
     development_group = options.delete(:development_group) || :development
 
     spec = find_gemspec name, path
@@ -698,11 +697,11 @@ Gem dependencies file #{@path} includes 
   def pin_gem_source(name, type = :default, source = nil)
     source_description =
       case type
-      when :default then '(default)'
+      when :default then "(default)"
       when :path    then "path: #{source}"
       when :git     then "git: #{source}"
       when :source  then "source: #{source}"
-      else               '(unknown)'
+      else               "(unknown)"
       end
 
     raise ArgumentError,
@@ -789,8 +788,8 @@ Gem dependencies file #{@path} includes 
     engine_version = options[:engine_version]
 
     raise ArgumentError,
-          'You must specify engine_version along with the Ruby engine' if
-            engine and not engine_version
+          "You must specify engine_version along with the Ruby engine" if
+            engine && !engine_version
 
     return true if @installing
 
@@ -801,7 +800,7 @@ Gem dependencies file #{@path} includes 
       raise Gem::RubyVersionMismatch, message
     end
 
-    if engine and engine != Gem.ruby_engine
+    if engine && engine != Gem.ruby_engine
       message = "Your Ruby engine is #{Gem.ruby_engine}, " +
                 "but your #{gem_deps_file} requires #{engine}"
 
@@ -842,5 +841,4 @@ Gem dependencies file #{@path} includes 
 
     Gem.sources << url
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/request_set/lockfile.rb
+++ ruby2.7-2.7.6/lib/rubygems/request_set/lockfile.rb
@@ -5,12 +5,10 @@
 # constructed.
 
 class Gem::RequestSet::Lockfile
-
   ##
   # Raised when a lockfile cannot be parsed
 
   class ParseError < Gem::Exception
-
     ##
     # The column where the error was encountered
 
@@ -36,7 +34,6 @@ class Gem::RequestSet::Lockfile
       @path   = path
       super "#{message} (at line #{line} column #{column})"
     end
-
   end
 
   ##
@@ -59,10 +56,10 @@ class Gem::RequestSet::Lockfile
 
       deps[name] = if [Gem::Resolver::VendorSpecification,
                        Gem::Resolver::GitSpecification].include? spec.class
-                     Gem::Requirement.source_set
-                   else
-                     requirement
-                   end
+        Gem::Requirement.source_set
+      else
+        requirement
+      end
     end
 
     deps
@@ -79,7 +76,7 @@ class Gem::RequestSet::Lockfile
     @gem_deps_file = File.expand_path(gem_deps_file)
     @gem_deps_dir  = File.dirname(@gem_deps_file)
 
-    if RUBY_VERSION < '2.7'
+    if RUBY_VERSION < "2.7"
       @gem_deps_file.untaint unless gem_deps_file.tainted?
     end
 
@@ -89,7 +86,7 @@ class Gem::RequestSet::Lockfile
   def add_DEPENDENCIES(out) # :nodoc:
     out << "DEPENDENCIES"
 
-    out.concat @dependencies.sort_by { |name,| name }.map { |name, requirement|
+    out.concat @dependencies.sort_by {|name,| name }.map {|name, requirement|
       "  #{name}#{requirement.for_lockfile}"
     }
 
@@ -103,13 +100,13 @@ class Gem::RequestSet::Lockfile
       request.spec.source.uri
     end
 
-    source_groups.sort_by { |group,| group.to_s }.map do |group, requests|
+    source_groups.sort_by {|group,| group.to_s }.map do |group, requests|
       out << "GEM"
       out << "  remote: #{group}"
       out << "  specs:"
 
-      requests.sort_by { |request| request.name }.each do |request|
-        next if request.spec.name == 'bundler'
+      requests.sort_by {|request| request.name }.each do |request|
+        next if request.spec.name == "bundler"
         platform = "-#{request.spec.platform}" unless
           Gem::Platform::RUBY == request.spec.platform
 
@@ -140,10 +137,10 @@ class Gem::RequestSet::Lockfile
       out << "  revision: #{revision}"
       out << "  specs:"
 
-      requests.sort_by { |request| request.name }.each do |request|
+      requests.sort_by {|request| request.name }.each do |request|
         out << "    #{request.name} (#{request.version})"
 
-        dependencies = request.spec.dependencies.sort_by { |dep| dep.name }
+        dependencies = request.spec.dependencies.sort_by {|dep| dep.name }
         dependencies.each do |dep|
           out << "      #{dep.name}#{dep.requirement.for_lockfile}"
         end
@@ -159,7 +156,7 @@ class Gem::RequestSet::Lockfile
     if dest.index(base) == 0
       offset = dest[base.size + 1..-1]
 
-      return '.' unless offset
+      return "." unless offset
 
       offset
     else
@@ -185,9 +182,9 @@ class Gem::RequestSet::Lockfile
   def add_PLATFORMS(out) # :nodoc:
     out << "PLATFORMS"
 
-    platforms = requests.map { |request| request.spec.platform }.uniq
+    platforms = requests.map {|request| request.spec.platform }.uniq
 
-    platforms = platforms.sort_by { |platform| platform.to_s }
+    platforms = platforms.sort_by {|platform| platform.to_s }
 
     platforms.each do |platform|
       out << "  #{platform}"
@@ -197,7 +194,7 @@ class Gem::RequestSet::Lockfile
   end
 
   def spec_groups
-    requests.group_by { |request| request.spec.class }
+    requests.group_by {|request| request.spec.class }
   end
 
   ##
@@ -227,7 +224,7 @@ class Gem::RequestSet::Lockfile
   def write
     content = to_s
 
-    File.open "#{@gem_deps_file}.lock", 'w' do |io|
+    File.open "#{@gem_deps_file}.lock", "w" do |io|
       io.write content
     end
   end
@@ -237,7 +234,6 @@ class Gem::RequestSet::Lockfile
   def requests
     @set.sorted_requests
   end
-
 end
 
-require 'rubygems/request_set/lockfile/tokenizer'
+require_relative "lockfile/tokenizer"
--- ruby2.7-2.7.6.orig/lib/rubygems/request_set/lockfile/parser.rb
+++ ruby2.7-2.7.6/lib/rubygems/request_set/lockfile/parser.rb
@@ -1,6 +1,5 @@
 # frozen_string_literal: true
 class Gem::RequestSet::Lockfile::Parser
-
   ###
   # Parses lockfiles
 
@@ -20,18 +19,18 @@ class Gem::RequestSet::Lockfile::Parser
         @tokens.skip :newline
 
         case token.value
-        when 'DEPENDENCIES' then
+        when "DEPENDENCIES" then
           parse_DEPENDENCIES
-        when 'GIT' then
+        when "GIT" then
           parse_GIT
-        when 'GEM' then
+        when "GEM" then
           parse_GEM
-        when 'PATH' then
+        when "PATH" then
           parse_PATH
-        when 'PLATFORMS' then
+        when "PLATFORMS" then
           parse_PLATFORMS
         else
-          token = get until @tokens.empty? or peek.first == :section
+          token = get until @tokens.empty? || peek.first == :section
         end
       else
         raise "BUG: unhandled token #{token.type} (#{token.value.inspect}) at line #{token.line} column #{token.column}"
@@ -45,7 +44,7 @@ class Gem::RequestSet::Lockfile::Parser
   def get(expected_types = nil, expected_value = nil) # :nodoc:
     token = @tokens.shift
 
-    if expected_types and not Array(expected_types).include? token.type
+    if expected_types && !Array(expected_types).include?(token.type)
       unget token
 
       message = "unexpected token [#{token.type.inspect}, #{token.value.inspect}], " +
@@ -54,7 +53,7 @@ class Gem::RequestSet::Lockfile::Parser
       raise Gem::RequestSet::Lockfile::ParseError.new message, token.column, token.line, @filename
     end
 
-    if expected_value and expected_value != token.value
+    if expected_value && expected_value != token.value
       unget token
 
       message = "unexpected token [#{token.type.inspect}, #{token.value.inspect}], " +
@@ -68,7 +67,7 @@ class Gem::RequestSet::Lockfile::Parser
   end
 
   def parse_DEPENDENCIES # :nodoc:
-    while not @tokens.empty? and :text == peek.type do
+    while !@tokens.empty? && :text == peek.type do
       token = get :text
 
       requirements = []
@@ -111,8 +110,8 @@ class Gem::RequestSet::Lockfile::Parser
   def parse_GEM # :nodoc:
     sources = []
 
-    while [:entry, 'remote'] == peek.first(2) do
-      get :entry, 'remote'
+    while [:entry, "remote"] == peek.first(2) do
+      get :entry, "remote"
       data = get(:text).value
       skip :newline
 
@@ -121,14 +120,14 @@ class Gem::RequestSet::Lockfile::Parser
 
     sources << Gem::Source.new(Gem::DEFAULT_HOST) if sources.empty?
 
-    get :entry, 'specs'
+    get :entry, "specs"
 
     skip :newline
 
     set = Gem::Resolver::LockSet.new sources
     last_specs = nil
 
-    while not @tokens.empty? and :text == peek.type do
+    while !@tokens.empty? && :text == peek.type do
       token = get :text
       name = token.value
       column = token.column
@@ -145,8 +144,8 @@ class Gem::RequestSet::Lockfile::Parser
         type = token.type
         data = token.value
 
-        if type == :text and column == 4
-          version, platform = data.split '-', 2
+        if type == :text && column == 4
+          version, platform = data.split "-", 2
 
           platform =
             platform ? Gem::Platform.new(platform) : Gem::Platform::RUBY
@@ -172,26 +171,26 @@ class Gem::RequestSet::Lockfile::Parser
   end
 
   def parse_GIT # :nodoc:
-    get :entry, 'remote'
+    get :entry, "remote"
     repository = get(:text).value
 
     skip :newline
 
-    get :entry, 'revision'
+    get :entry, "revision"
     revision = get(:text).value
 
     skip :newline
 
     type = peek.type
     value = peek.value
-    if type == :entry and %w[branch ref tag].include? value
+    if type == :entry && %w[branch ref tag].include?(value)
       get
       get :text
 
       skip :newline
     end
 
-    get :entry, 'specs'
+    get :entry, "specs"
 
     skip :newline
 
@@ -200,7 +199,7 @@ class Gem::RequestSet::Lockfile::Parser
 
     last_spec = nil
 
-    while not @tokens.empty? and :text == peek.type do
+    while !@tokens.empty? && :text == peek.type do
       token = get :text
       name = token.value
       column = token.column
@@ -215,7 +214,7 @@ class Gem::RequestSet::Lockfile::Parser
         type = token.type
         data = token.value
 
-        if type == :text and column == 4
+        if type == :text && column == 4
           last_spec = set.add_git_spec name, data, repository, revision, true
         else
           dependency = parse_dependency name, data
@@ -235,19 +234,19 @@ class Gem::RequestSet::Lockfile::Parser
   end
 
   def parse_PATH # :nodoc:
-    get :entry, 'remote'
+    get :entry, "remote"
     directory = get(:text).value
 
     skip :newline
 
-    get :entry, 'specs'
+    get :entry, "specs"
 
     skip :newline
 
     set = Gem::Resolver::VendorSet.new
     last_spec = nil
 
-    while not @tokens.empty? and :text == peek.first do
+    while !@tokens.empty? && :text == peek.first do
       token = get :text
       name = token.value
       column = token.column
@@ -262,7 +261,7 @@ class Gem::RequestSet::Lockfile::Parser
         type = token.type
         data = token.value
 
-        if type == :text and column == 4
+        if type == :text && column == 4
           last_spec = set.add_vendor_gem name, directory
         else
           dependency = parse_dependency name, data
@@ -282,7 +281,7 @@ class Gem::RequestSet::Lockfile::Parser
   end
 
   def parse_PLATFORMS # :nodoc:
-    while not @tokens.empty? and :text == peek.first do
+    while !@tokens.empty? && :text == peek.first do
       name = get(:text).value
 
       @platforms << name
@@ -341,5 +340,4 @@ class Gem::RequestSet::Lockfile::Parser
   def unget(token) # :nodoc:
     @tokens.unshift token
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/request_set/lockfile/tokenizer.rb
+++ ruby2.7-2.7.6/lib/rubygems/request_set/lockfile/tokenizer.rb
@@ -1,8 +1,7 @@
-# frozen_string_literal: true
-require 'rubygems/request_set/lockfile/parser'
+#) frozen_string_literal: true
+require_relative "parser"
 
 class Gem::RequestSet::Lockfile::Tokenizer
-
   Token = Struct.new :type, :value, :column, :line
   EOF   = Token.new :EOF
 
@@ -23,11 +22,11 @@ class Gem::RequestSet::Lockfile::Tokeniz
   end
 
   def to_a
-    @tokens.map { |token| [token.type, token.value, token.column, token.line] }
+    @tokens.map {|token| [token.type, token.value, token.column, token.line] }
   end
 
   def skip(type)
-    @tokens.shift while not @tokens.empty? and peek.type == type
+    @tokens.shift while !@tokens.empty? && peek.type == type
   end
 
   ##
@@ -58,7 +57,7 @@ class Gem::RequestSet::Lockfile::Tokeniz
   private
 
   def tokenize(input)
-    require 'strscan'
+    require "strscan"
     s = StringScanner.new input
 
     until s.eos? do
@@ -110,5 +109,4 @@ class Gem::RequestSet::Lockfile::Tokeniz
 
     @tokens
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/requirement.rb
+++ ruby2.7-2.7.6/lib/rubygems/requirement.rb
@@ -1,6 +1,5 @@
 # frozen_string_literal: true
-require "rubygems/version"
-require "rubygems/deprecate"
+require_relative "version"
 
 ##
 # A Requirement is a set of one or more version restrictions. It supports a
@@ -10,20 +9,19 @@ require "rubygems/deprecate"
 # together in RubyGems.
 
 class Gem::Requirement
-
   OPS = { #:nodoc:
-    "="  =>  lambda { |v, r| v == r },
-    "!=" =>  lambda { |v, r| v != r },
-    ">"  =>  lambda { |v, r| v >  r },
-    "<"  =>  lambda { |v, r| v <  r },
-    ">=" =>  lambda { |v, r| v >= r },
-    "<=" =>  lambda { |v, r| v <= r },
-    "~>" =>  lambda { |v, r| v >= r && v.release < r.bump }
+    "="  =>  lambda {|v, r| v == r },
+    "!=" =>  lambda {|v, r| v != r },
+    ">"  =>  lambda {|v, r| v >  r },
+    "<"  =>  lambda {|v, r| v <  r },
+    ">=" =>  lambda {|v, r| v >= r },
+    "<=" =>  lambda {|v, r| v <= r },
+    "~>" =>  lambda {|v, r| v >= r && v.release < r.bump },
   }.freeze
 
   SOURCE_SET_REQUIREMENT = Struct.new(:for_lockfile).new "!" # :nodoc:
 
-  quoted = OPS.keys.map { |k| Regexp.quote k }.join "|"
+  quoted = OPS.keys.map {|k| Regexp.quote k }.join "|"
   PATTERN_RAW = "\\s*(#{quoted})?\\s*(#{Gem::Version::VERSION_PATTERN})\\s*".freeze # :nodoc:
 
   ##
@@ -63,7 +61,7 @@ class Gem::Requirement
       input
     when Gem::Version, Array then
       new input
-    when '!' then
+    when "!" then
       source_set
     else
       if input.respond_to? :to_str
@@ -75,11 +73,11 @@ class Gem::Requirement
   end
 
   def self.default
-    new '>= 0'
+    new ">= 0"
   end
 
   def self.default_prerelease
-    new '>= 0.a'
+    new ">= 0.a"
   end
 
   ###
@@ -113,7 +111,7 @@ class Gem::Requirement
     elsif $1 == ">=" && $2 == "0.a"
       DefaultPrereleaseRequirement
     else
-      [$1 || "=", Gem::Version.new($2)]
+      [-($1 || "="), Gem::Version.new($2)]
     end
   end
 
@@ -137,7 +135,7 @@ class Gem::Requirement
     if requirements.empty?
       @requirements = [DefaultRequirement]
     else
-      @requirements = requirements.map! { |r| self.class.parse r }
+      @requirements = requirements.map! {|r| self.class.parse r }
     end
   end
 
@@ -148,7 +146,7 @@ class Gem::Requirement
     new = new.flatten
     new.compact!
     new.uniq!
-    new = new.map { |r| self.class.parse r }
+    new = new.map {|r| self.class.parse r }
 
     @requirements.concat new
   end
@@ -188,32 +186,27 @@ class Gem::Requirement
   end
 
   def as_list # :nodoc:
-    requirements.map { |op, version| "#{op} #{version}" }
+    requirements.map {|op, version| "#{op} #{version}" }
   end
 
   def hash # :nodoc:
-    requirements.sort.hash
+    requirements.map {|r| r.first == "~>" ? [r[0], r[1].to_s] : r }.sort.hash
   end
 
   def marshal_dump # :nodoc:
-    fix_syck_default_key_in_requirements
-
     [@requirements]
   end
 
   def marshal_load(array) # :nodoc:
     @requirements = array[0]
 
-    fix_syck_default_key_in_requirements
+    raise TypeError, "wrong @requirements" unless Array === @requirements
   end
 
   def yaml_initialize(tag, vals) # :nodoc:
     vals.each do |ivar, val|
       instance_variable_set "@#{ivar}", val
     end
-
-    Gem.load_yaml
-    fix_syck_default_key_in_requirements
   end
 
   def init_with(coder) # :nodoc:
@@ -225,7 +218,7 @@ class Gem::Requirement
   end
 
   def encode_with(coder) # :nodoc:
-    coder.add 'requirements', @requirements
+    coder.add "requirements", @requirements
   end
 
   ##
@@ -233,11 +226,11 @@ class Gem::Requirement
   # are prereleases
 
   def prerelease?
-    requirements.any? { |r| r.last.prerelease? }
+    requirements.any? {|r| r.last.prerelease? }
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 1, 'Gem::Requirement.new(', ')' do
+    q.group 1, "Gem::Requirement.new(", ")" do
       q.pp as_list
     end
   end
@@ -248,8 +241,7 @@ class Gem::Requirement
   def satisfied_by?(version)
     raise ArgumentError, "Need a Gem::Version: #{version.inspect}" unless
       Gem::Version === version
-    # #28965: syck has a bug with unquoted '=' YAML.loading as YAML::DefaultKey
-    requirements.all? { |op, rv| (OPS[op] || OPS["="]).call version, rv }
+    requirements.all? {|op, rv| OPS[op].call version, rv }
   end
 
   alias :=== :satisfied_by?
@@ -261,7 +253,7 @@ class Gem::Requirement
   def specific?
     return true if @requirements.length > 1 # GIGO, > 1, > 2 is silly
 
-    not %w[> >=].include? @requirements.first.first # grab the operator
+    !%w[> >=].include? @requirements.first.first # grab the operator
   end
 
   def to_s # :nodoc:
@@ -272,7 +264,7 @@ class Gem::Requirement
     return unless Gem::Requirement === other
 
     # An == check is always necessary
-    return false unless requirements == other.requirements
+    return false unless _sorted_requirements == other._sorted_requirements
 
     # An == check is sufficient unless any requirements use ~>
     return true unless _tilde_requirements.any?
@@ -284,30 +276,18 @@ class Gem::Requirement
 
   protected
 
-  def _tilde_requirements
-    requirements.select { |r| r.first == "~>" }
+  def _sorted_requirements
+    @_sorted_requirements ||= requirements.sort_by(&:to_s)
   end
 
-  private
-
-  def fix_syck_default_key_in_requirements # :nodoc:
-    Gem.load_yaml
-
-    # Fixup the Syck DefaultKey bug
-    @requirements.each do |r|
-      if r[0].kind_of? Gem::SyckDefaultKey
-        r[0] = "="
-      end
-    end
+  def _tilde_requirements
+    @_tilde_requirements ||= _sorted_requirements.select {|r| r.first == "~>" }
   end
-
 end
 
 class Gem::Version
-
   # This is needed for compatibility with older yaml
   # gemspecs.
 
   Requirement = Gem::Requirement # :nodoc:
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/dependency'
-require 'rubygems/exceptions'
-require 'rubygems/util'
-require 'rubygems/util/list'
+require_relative "dependency"
+require_relative "exceptions"
+require_relative "util/list"
 
 ##
 # Given a set of Gem::Dependency objects as +needed+ and a way to query the
@@ -11,15 +10,14 @@ require 'rubygems/util/list'
 # all the requirements.
 
 class Gem::Resolver
-
-  require 'rubygems/resolver/molinillo'
+  require_relative "resolver/molinillo"
 
   ##
   # If the DEBUG_RESOLVER environment variable is set then debugging mode is
   # enabled for the resolver.  This will display information about the state
   # of the resolver while a set of dependencies is being resolved.
 
-  DEBUG_RESOLVER = !ENV['DEBUG_RESOLVER'].nil?
+  DEBUG_RESOLVER = !ENV["DEBUG_RESOLVER"].nil?
 
   ##
   # Set to true if all development dependencies should be considered.
@@ -76,7 +74,7 @@ class Gem::Resolver
 
     case sets.length
     when 0 then
-      raise ArgumentError, 'one set in the composition must be non-nil'
+      raise ArgumentError, "one set in the composition must be non-nil"
     when 1 then
       sets.first
     else
@@ -116,7 +114,7 @@ class Gem::Resolver
   def explain(stage, *data) # :nodoc:
     return unless DEBUG_RESOLVER
 
-    d = data.map { |x| x.pretty_inspect }.join(", ")
+    d = data.map {|x| x.pretty_inspect }.join(", ")
     $stderr.printf "%10s %s\n", stage.to_s.upcase, d
   end
 
@@ -126,7 +124,7 @@ class Gem::Resolver
     data = yield
     $stderr.printf "%10s (%d entries)\n", stage.to_s.upcase, data.size
     unless data.empty?
-      require 'pp'
+      require "pp"
       PP.pp data, $stderr
     end
   end
@@ -155,10 +153,10 @@ class Gem::Resolver
     s.fetch_development_dependencies if @development
 
     s.dependencies.reverse_each do |d|
-      next if d.type == :development and not @development
-      next if d.type == :development and @development_shallow and
+      next if d.type == :development && !@development
+      next if d.type == :development && @development_shallow &&
               act.development?
-      next if d.type == :development and @development_shallow and
+      next if d.type == :development && @development_shallow &&
               act.parent
 
       reqs << Gem::Resolver::DependencyRequest.new(d, act)
@@ -175,7 +173,7 @@ class Gem::Resolver
   include Molinillo::UI
 
   def output
-    @output ||= debug? ? $stdout : File.open(IO::NULL, 'w')
+    @output ||= debug? ? $stdout : File.open(IO::NULL, "w")
   end
 
   def debug?
@@ -189,12 +187,12 @@ class Gem::Resolver
 
   def resolve
     locking_dg = Molinillo::DependencyGraph.new
-    Molinillo::Resolver.new(self, self).resolve(@needed.map { |d| DependencyRequest.new d, nil }, locking_dg).tsort.map(&:payload).compact
+    Molinillo::Resolver.new(self, self).resolve(@needed.map {|d| DependencyRequest.new d, nil }, locking_dg).tsort.map(&:payload).compact
   rescue Molinillo::VersionConflict => e
     conflict = e.conflicts.values.first
     raise Gem::DependencyResolutionError, Conflict.new(conflict.requirement_trees.first.first, conflict.existing, conflict.requirement)
   ensure
-    @output.close if defined?(@output) and !debug?
+    @output.close if defined?(@output) && !debug?
   end
 
   ##
@@ -206,7 +204,7 @@ class Gem::Resolver
 
     if (skip_dep_gems = skip_gems[dependency.name]) && !skip_dep_gems.empty?
       matching = all.select do |api_spec|
-        skip_dep_gems.any? { |s| api_spec.version == s.version }
+        skip_dep_gems.any? {|s| api_spec.version == s.version }
       end
 
       all = matching unless matching.empty?
@@ -235,7 +233,7 @@ class Gem::Resolver
       raise exc
     end
 
-    groups = Hash.new { |hash, key| hash[key] = [] }
+    groups = Hash.new {|hash, key| hash[key] = [] }
 
     # create groups & sources in the same loop
     sources = possibles.map do |spec|
@@ -248,9 +246,9 @@ class Gem::Resolver
 
     sources.each do |source|
       groups[source].
-        sort_by { |spec| [spec.version, Gem::Platform.local =~ spec.platform ? 1 : 0] }.
-        map { |spec| ActivationRequest.new spec, dependency }.
-        each { |activation_request| activation_requests << activation_request }
+        sort_by {|spec| [spec.version, Gem::Platform.local =~ spec.platform ? 1 : 0] }.
+        map {|spec| ActivationRequest.new spec, dependency }.
+        each {|activation_request| activation_requests << activation_request }
     end
 
     activation_requests
@@ -263,7 +261,12 @@ class Gem::Resolver
   end
 
   def requirement_satisfied_by?(requirement, activated, spec)
-    requirement.matches_spec? spec
+    matches_spec = requirement.matches_spec? spec
+    return matches_spec if @soft_missing
+
+    matches_spec &&
+      spec.spec.required_ruby_version.satisfied_by?(Gem.ruby_version) &&
+      spec.spec.required_rubygems_version.satisfied_by?(Gem.rubygems_version)
   end
 
   def name_for(dependency)
@@ -283,7 +286,7 @@ class Gem::Resolver
         amount_constrained(dependency),
         conflicts[name] ? 0 : 1,
         activated.vertex_named(name).payload ? 0 : search_for(dependency).count,
-        i # for stable sort
+        i, # for stable sort
       ]
     end
   end
@@ -313,33 +316,32 @@ class Gem::Resolver
     end
   end
   private :amount_constrained
-
 end
 
-require 'rubygems/resolver/activation_request'
-require 'rubygems/resolver/conflict'
-require 'rubygems/resolver/dependency_request'
-require 'rubygems/resolver/requirement_list'
-require 'rubygems/resolver/stats'
-
-require 'rubygems/resolver/set'
-require 'rubygems/resolver/api_set'
-require 'rubygems/resolver/composed_set'
-require 'rubygems/resolver/best_set'
-require 'rubygems/resolver/current_set'
-require 'rubygems/resolver/git_set'
-require 'rubygems/resolver/index_set'
-require 'rubygems/resolver/installer_set'
-require 'rubygems/resolver/lock_set'
-require 'rubygems/resolver/vendor_set'
-require 'rubygems/resolver/source_set'
-
-require 'rubygems/resolver/specification'
-require 'rubygems/resolver/spec_specification'
-require 'rubygems/resolver/api_specification'
-require 'rubygems/resolver/git_specification'
-require 'rubygems/resolver/index_specification'
-require 'rubygems/resolver/installed_specification'
-require 'rubygems/resolver/local_specification'
-require 'rubygems/resolver/lock_specification'
-require 'rubygems/resolver/vendor_specification'
+require_relative "resolver/activation_request"
+require_relative "resolver/conflict"
+require_relative "resolver/dependency_request"
+require_relative "resolver/requirement_list"
+require_relative "resolver/stats"
+
+require_relative "resolver/set"
+require_relative "resolver/api_set"
+require_relative "resolver/composed_set"
+require_relative "resolver/best_set"
+require_relative "resolver/current_set"
+require_relative "resolver/git_set"
+require_relative "resolver/index_set"
+require_relative "resolver/installer_set"
+require_relative "resolver/lock_set"
+require_relative "resolver/vendor_set"
+require_relative "resolver/source_set"
+
+require_relative "resolver/specification"
+require_relative "resolver/spec_specification"
+require_relative "resolver/api_specification"
+require_relative "resolver/git_specification"
+require_relative "resolver/index_specification"
+require_relative "resolver/installed_specification"
+require_relative "resolver/local_specification"
+require_relative "resolver/lock_specification"
+require_relative "resolver/vendor_specification"
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/activation_request.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/activation_request.rb
@@ -4,7 +4,6 @@
 # dependency that was used to introduce this activation.
 
 class Gem::Resolver::ActivationRequest
-
   ##
   # The parent request for this activation request.
 
@@ -29,12 +28,20 @@ class Gem::Resolver::ActivationRequest
     when Gem::Specification
       @spec == other
     when Gem::Resolver::ActivationRequest
-      @spec == other.spec && @request == other.request
+      @spec == other.spec
     else
       false
     end
   end
 
+  def eql?(other)
+    self == other
+  end
+
+  def hash
+    @spec.hash
+  end
+
   ##
   # Is this activation request for a development dependency?
 
@@ -86,7 +93,7 @@ class Gem::Resolver::ActivationRequest
   end
 
   def inspect # :nodoc:
-    '#<%s for %p from %s>' % [
+    "#<%s for %p from %s>" % [
       self.class, @spec, @request
     ]
   end
@@ -123,12 +130,12 @@ class Gem::Resolver::ActivationRequest
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[Activation request', ']' do
+    q.group 2, "[Activation request", "]" do
       q.breakable
       q.pp @spec
 
       q.breakable
-      q.text ' for '
+      q.text " for "
       q.pp @request
     end
   end
@@ -152,5 +159,4 @@ class Gem::Resolver::ActivationRequest
   def name_tuple
     @name_tuple ||= Gem::NameTuple.new(name, version, platform)
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/api_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/api_set.rb
@@ -4,6 +4,7 @@
 # Returns instances of APISpecification.
 
 class Gem::Resolver::APISet < Gem::Resolver::Set
+  autoload :GemParser, File.expand_path("api_set/gem_parser", __dir__)
 
   ##
   # The URI for the dependency API this APISet uses.
@@ -25,15 +26,15 @@ class Gem::Resolver::APISet < Gem::Resol
   # API URL +dep_uri+ which is described at
   # https://guides.rubygems.org/rubygems-org-api
 
-  def initialize(dep_uri = 'https://rubygems.org/api/v1/dependencies')
+  def initialize(dep_uri = "https://index.rubygems.org/info/")
     super()
 
-    dep_uri = URI dep_uri unless URI === dep_uri # for ruby 1.8
+    dep_uri = URI dep_uri unless URI === dep_uri
 
     @dep_uri = dep_uri
-    @uri     = dep_uri + '../..'
+    @uri     = dep_uri + ".."
 
-    @data   = Hash.new { |h,k| h[k] = [] }
+    @data   = Hash.new {|h,k| h[k] = [] }
     @source = Gem::Source.new @uri
 
     @to_fetch = []
@@ -53,7 +54,7 @@ class Gem::Resolver::APISet < Gem::Resol
     end
 
     versions(req.name).each do |ver|
-      if req.dependency.match? req.name, ver[:number]
+      if req.dependency.match? req.name, ver[:number], @prerelease
         res << Gem::Resolver::APISpecification.new(self, ver)
       end
     end
@@ -67,7 +68,7 @@ class Gem::Resolver::APISet < Gem::Resol
 
   def prefetch(reqs)
     return unless @remote
-    names = reqs.map { |r| r.dependency.name }
+    names = reqs.map {|r| r.dependency.name }
     needed = names - @data.keys - @to_fetch
 
     @to_fetch += needed
@@ -76,30 +77,18 @@ class Gem::Resolver::APISet < Gem::Resol
   def prefetch_now # :nodoc:
     needed, @to_fetch = @to_fetch, []
 
-    uri = @dep_uri + "?gems=#{needed.sort.join ','}"
-    str = Gem::RemoteFetcher.fetcher.fetch_path uri
-
-    loaded = []
-
-    Marshal.load(str).each do |ver|
-      name = ver[:name]
-
-      @data[name] << ver
-      loaded << name
-    end
-
-    (needed - loaded).each do |missing|
-      @data[missing] = []
+    needed.sort.each do |name|
+      versions(name)
     end
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[APISet', ']' do
+    q.group 2, "[APISet", "]" do
       q.breakable
       q.text "URI: #{@dep_uri}"
 
       q.breakable
-      q.text 'gem names:'
+      q.text "gem names:"
       q.pp @data.keys
     end
   end
@@ -112,14 +101,32 @@ class Gem::Resolver::APISet < Gem::Resol
       return @data[name]
     end
 
-    uri = @dep_uri + "?gems=#{name}"
+    uri = @dep_uri + name
     str = Gem::RemoteFetcher.fetcher.fetch_path uri
 
-    Marshal.load(str).each do |ver|
-      @data[ver[:name]] << ver
+    lines(str).each do |ver|
+      number, platform, dependencies, requirements = parse_gem(ver)
+
+      platform ||= "ruby"
+      dependencies = dependencies.map {|dep_name, reqs| [dep_name, reqs.join(", ")] }
+      requirements = requirements.map {|req_name, reqs| [req_name.to_sym, reqs] }.to_h
+
+      @data[name] << { name: name, number: number, platform: platform, dependencies: dependencies, requirements: requirements }
     end
 
     @data[name]
   end
 
+  private
+
+  def lines(str)
+    lines = str.split("\n")
+    header = lines.index("---")
+    header ? lines[header + 1..-1] : lines
+  end
+
+  def parse_gem(string)
+    @gem_parser ||= GemParser.new
+    @gem_parser.parse(string)
+  end
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/resolver/api_set/gem_parser.rb
@@ -0,0 +1,20 @@
+# frozen_string_literal: true
+
+class Gem::Resolver::APISet::GemParser
+  def parse(line)
+    version_and_platform, rest = line.split(" ", 2)
+    version, platform = version_and_platform.split("-", 2)
+    dependencies, requirements = rest.split("|", 2).map {|s| s.split(",") } if rest
+    dependencies = dependencies ? dependencies.map {|d| parse_dependency(d) } : []
+    requirements = requirements ? requirements.map {|d| parse_dependency(d) } : []
+    [version, platform, dependencies, requirements]
+  end
+
+  private
+
+  def parse_dependency(string)
+    dependency = string.split(":")
+    dependency[-1] = dependency[-1].split("&") if dependency.size > 1
+    dependency
+  end
+end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/api_specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/api_specification.rb
@@ -6,6 +6,16 @@
 # is the name, version, and dependencies.
 
 class Gem::Resolver::APISpecification < Gem::Resolver::Specification
+  ##
+  # We assume that all instances of this class are immutable;
+  # so avoid duplicated generation for performance.
+  @@cache = {}
+  def self.new(set, api_data)
+    cache_key = [set, api_data]
+    cache = @@cache[cache_key]
+    return cache if cache
+    @@cache[cache_key] = super
+  end
 
   ##
   # Creates an APISpecification for the given +set+ from the rubygems.org
@@ -19,21 +29,26 @@ class Gem::Resolver::APISpecification < 
 
     @set = set
     @name = api_data[:name]
-    @version = Gem::Version.new api_data[:number]
-    @platform = Gem::Platform.new api_data[:platform]
-    @original_platform = api_data[:platform]
+    @version = Gem::Version.new(api_data[:number]).freeze
+    @platform = Gem::Platform.new(api_data[:platform]).freeze
+    @original_platform = api_data[:platform].freeze
     @dependencies = api_data[:dependencies].map do |name, ver|
-      Gem::Dependency.new name, ver.split(/\s*,\s*/)
-    end
+      Gem::Dependency.new(name, ver.split(/\s*,\s*/)).freeze
+    end.freeze
+    @required_ruby_version = Gem::Requirement.new(api_data.dig(:requirements, :ruby)).freeze
+    @required_rubygems_version = Gem::Requirement.new(api_data.dig(:requirements, :rubygems)).freeze
   end
 
   def ==(other) # :nodoc:
-    self.class === other and
-      @set          == other.set and
-      @name         == other.name and
-      @version      == other.version and
-      @platform     == other.platform and
-      @dependencies == other.dependencies
+    self.class === other &&
+      @set          == other.set &&
+      @name         == other.name &&
+      @version      == other.version &&
+      @platform     == other.platform
+  end
+
+  def hash
+    @set.hash ^ @name.hash ^ @version.hash ^ @platform.hash
   end
 
   def fetch_development_dependencies # :nodoc:
@@ -43,11 +58,11 @@ class Gem::Resolver::APISpecification < 
   end
 
   def installable_platform? # :nodoc:
-    Gem::Platform.match @platform
+    Gem::Platform.match_gem? @platform, @name
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[APISpecification', ']' do
+    q.group 2, "[APISpecification", "]" do
       q.breakable
       q.text "name: #{name}"
 
@@ -58,7 +73,7 @@ class Gem::Resolver::APISpecification < 
       q.text "platform: #{platform}"
 
       q.breakable
-      q.text 'dependencies:'
+      q.text "dependencies:"
       q.breakable
       q.pp @dependencies
 
@@ -86,5 +101,4 @@ class Gem::Resolver::APISpecification < 
   def source # :nodoc:
     @set.source
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/best_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/best_set.rb
@@ -5,7 +5,6 @@
 # It combines IndexSet and APISet
 
 class Gem::Resolver::BestSet < Gem::Resolver::ComposedSet
-
   ##
   # Creates a BestSet for the given +sources+ or Gem::sources if none are
   # specified.  +sources+ must be a Gem::SourceList.
@@ -26,7 +25,7 @@ class Gem::Resolver::BestSet < Gem::Reso
   end
 
   def find_all(req) # :nodoc:
-    pick_sets if @remote and @sets.empty?
+    pick_sets if @remote && @sets.empty?
 
     super
   rescue Gem::RemoteFetcher::FetchError => e
@@ -36,15 +35,15 @@ class Gem::Resolver::BestSet < Gem::Reso
   end
 
   def prefetch(reqs) # :nodoc:
-    pick_sets if @remote and @sets.empty?
+    pick_sets if @remote && @sets.empty?
 
     super
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[BestSet', ']' do
+    q.group 2, "[BestSet", "]" do
       q.breakable
-      q.text 'sets:'
+      q.text "sets:"
 
       q.breakable
       q.pp @sets
@@ -59,12 +58,12 @@ class Gem::Resolver::BestSet < Gem::Reso
   # The calling method must retry the exception to repeat the lookup.
 
   def replace_failed_api_set(error) # :nodoc:
-    uri = error.uri
+    uri = error.original_uri
     uri = URI uri unless URI === uri
-    uri.query = nil
+    uri = uri + "."
 
     raise error unless api_set = @sets.find do |set|
-      Gem::Resolver::APISet === set and set.dep_uri == uri
+      Gem::Resolver::APISet === set && set.dep_uri == uri
     end
 
     index_set = Gem::Resolver::IndexSet.new api_set.source
@@ -74,5 +73,4 @@ class Gem::Resolver::BestSet < Gem::Reso
       index_set
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/composed_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/composed_set.rb
@@ -9,7 +9,6 @@
 # This method will eliminate nesting of composed sets.
 
 class Gem::Resolver::ComposedSet < Gem::Resolver::Set
-
   attr_reader :sets # :nodoc:
 
   ##
@@ -40,11 +39,11 @@ class Gem::Resolver::ComposedSet < Gem::
   def remote=(remote)
     super
 
-    @sets.each { |set| set.remote = remote }
+    @sets.each {|set| set.remote = remote }
   end
 
   def errors
-    @errors + @sets.map { |set| set.errors }.flatten
+    @errors + @sets.map {|set| set.errors }.flatten
   end
 
   ##
@@ -60,7 +59,6 @@ class Gem::Resolver::ComposedSet < Gem::
   # Prefetches +reqs+ in all sets.
 
   def prefetch(reqs)
-    @sets.each { |s| s.prefetch(reqs) }
+    @sets.each {|s| s.prefetch(reqs) }
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/conflict.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/conflict.rb
@@ -4,7 +4,6 @@
 # with a spec that would be activated.
 
 class Gem::Resolver::Conflict
-
   ##
   # The specification that was activated prior to the conflict
 
@@ -28,9 +27,9 @@ class Gem::Resolver::Conflict
   end
 
   def ==(other) # :nodoc:
-    self.class === other and
-      @dependency == other.dependency and
-      @activated  == other.activated  and
+    self.class === other &&
+      @dependency == other.dependency &&
+      @activated  == other.activated  &&
       @failed_dep == other.failed_dep
   end
 
@@ -55,7 +54,7 @@ class Gem::Resolver::Conflict
     activated   = @activated.spec.full_name
     dependency  = @failed_dep.dependency
     requirement = dependency.requirement
-    alternates  = dependency.matching_specs.map { |spec| spec.full_name }
+    alternates  = dependency.matching_specs.map {|spec| spec.full_name }
 
     unless alternates.empty?
       matching = <<-MATCHING.chomp
@@ -66,7 +65,7 @@ class Gem::Resolver::Conflict
 
       matching = matching % [
         dependency,
-        alternates.join(', '),
+        alternates.join(", "),
       ]
     end
 
@@ -86,7 +85,7 @@ class Gem::Resolver::Conflict
       activated, requirement,
       request_path(@activated).reverse.join(", depends on\n    "),
       request_path(@failed_dep).reverse.join(", depends on\n    "),
-      matching,
+      matching
     ]
   end
 
@@ -98,21 +97,21 @@ class Gem::Resolver::Conflict
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[Dependency conflict: ', ']' do
+    q.group 2, "[Dependency conflict: ", "]" do
       q.breakable
 
-      q.text 'activated '
+      q.text "activated "
       q.pp @activated
 
       q.breakable
-      q.text ' dependency '
+      q.text " dependency "
       q.pp @dependency
 
       q.breakable
       if @dependency == @failed_dep
-        q.text ' failed'
+        q.text " failed"
       else
-        q.text ' failed dependency '
+        q.text " failed dependency "
         q.pp @failed_dep
       end
     end
@@ -140,7 +139,7 @@ class Gem::Resolver::Conflict
       end
     end
 
-    path = ['user request (gem command or Gemfile)'] if path.empty?
+    path = ["user request (gem command or Gemfile)"] if path.empty?
 
     path
   end
@@ -151,5 +150,4 @@ class Gem::Resolver::Conflict
   def requester
     @failed_dep.requester
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/current_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/current_set.rb
@@ -5,9 +5,7 @@
 # for installed gems.
 
 class Gem::Resolver::CurrentSet < Gem::Resolver::Set
-
   def find_all(req)
     req.dependency.matching_specs
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/dependency_request.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/dependency_request.rb
@@ -4,7 +4,6 @@
 # contained the Dependency.
 
 class Gem::Resolver::DependencyRequest
-
   ##
   # The wrapped Gem::Dependency
 
@@ -29,7 +28,7 @@ class Gem::Resolver::DependencyRequest
     when Gem::Dependency
       @dependency == other
     when Gem::Resolver::DependencyRequest
-      @dependency == other.dependency && @requester == other.requester
+      @dependency == other.dependency
     else
       false
     end
@@ -96,12 +95,12 @@ class Gem::Resolver::DependencyRequest
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[Dependency request ', ']' do
+    q.group 2, "[Dependency request ", "]" do
       q.breakable
       q.text @dependency.to_s
 
       q.breakable
-      q.text ' requested by '
+      q.text " requested by "
       q.pp @requester
     end
   end
@@ -116,5 +115,4 @@ class Gem::Resolver::DependencyRequest
   def to_s # :nodoc:
     @dependency.to_s
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/git_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/git_set.rb
@@ -10,7 +10,6 @@
 #   set.add_git_gem 'rake', 'git://example/rake.git', tag: 'rake-10.1.0'
 
 class Gem::Resolver::GitSet < Gem::Resolver::Set
-
   ##
   # The root directory for git gems in this set.  This is usually Gem.dir, the
   # installation directory for regular gems.
@@ -36,7 +35,7 @@ class Gem::Resolver::GitSet < Gem::Resol
   def initialize # :nodoc:
     super()
 
-    @git             = ENV['git'] || 'git'
+    @git             = ENV["git"] || "git"
     @need_submodules = {}
     @repositories    = {}
     @root_dir        = Gem.dir
@@ -105,7 +104,7 @@ class Gem::Resolver::GitSet < Gem::Resol
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[GitSet', ']' do
+    q.group 2, "[GitSet", "]" do
       next if @repositories.empty?
       q.breakable
 
@@ -118,5 +117,4 @@ class Gem::Resolver::GitSet < Gem::Resol
       end
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/git_specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/git_specification.rb
@@ -5,11 +5,10 @@
 # option.
 
 class Gem::Resolver::GitSpecification < Gem::Resolver::SpecSpecification
-
   def ==(other) # :nodoc:
-    self.class === other and
-      @set  == other.set and
-      @spec == other.spec and
+    self.class === other &&
+      @set  == other.set &&
+      @spec == other.spec &&
       @source == other.source
   end
 
@@ -22,7 +21,7 @@ class Gem::Resolver::GitSpecification < 
   # the executables.
 
   def install(options = {})
-    require 'rubygems/installer'
+    require_relative "../installer"
 
     installer = Gem::Installer.for_spec spec, options
 
@@ -36,7 +35,7 @@ class Gem::Resolver::GitSpecification < 
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[GitSpecification', ']' do
+    q.group 2, "[GitSpecification", "]" do
       q.breakable
       q.text "name: #{name}"
 
@@ -44,7 +43,7 @@ class Gem::Resolver::GitSpecification < 
       q.text "version: #{version}"
 
       q.breakable
-      q.text 'dependencies:'
+      q.text "dependencies:"
       q.breakable
       q.pp dependencies
 
@@ -54,5 +53,4 @@ class Gem::Resolver::GitSpecification < 
       q.pp @source
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/index_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/index_set.rb
@@ -4,7 +4,6 @@
 # source index.
 
 class Gem::Resolver::IndexSet < Gem::Resolver::Set
-
   def initialize(source = nil) # :nodoc:
     super()
 
@@ -17,7 +16,7 @@ class Gem::Resolver::IndexSet < Gem::Res
         Gem::SpecFetcher.fetcher
       end
 
-    @all = Hash.new { |h,k| h[k] = [] }
+    @all = Hash.new {|h,k| h[k] = [] }
 
     list, errors = @f.available_specs :complete
 
@@ -54,14 +53,14 @@ class Gem::Resolver::IndexSet < Gem::Res
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[IndexSet', ']' do
+    q.group 2, "[IndexSet", "]" do
       q.breakable
-      q.text 'sources:'
+      q.text "sources:"
       q.breakable
       q.pp @f.sources
 
       q.breakable
-      q.text 'specs:'
+      q.text "specs:"
 
       q.breakable
 
@@ -76,5 +75,4 @@ class Gem::Resolver::IndexSet < Gem::Res
       end
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/index_specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/index_specification.rb
@@ -5,7 +5,6 @@
 # and +version+ are needed.
 
 class Gem::Resolver::IndexSpecification < Gem::Resolver::Specification
-
   ##
   # An IndexSpecification is created from the index format described in `gem
   # help generate_index`.
@@ -22,7 +21,8 @@ class Gem::Resolver::IndexSpecification 
     @name = name
     @version = version
     @source = source
-    @platform = platform.to_s
+    @platform = Gem::Platform.new(platform.to_s)
+    @original_platform = platform.to_s
 
     @spec = nil
   end
@@ -34,12 +34,44 @@ class Gem::Resolver::IndexSpecification 
     spec.dependencies
   end
 
+  ##
+  # The required_ruby_version constraint for this specification
+  #
+  # A fallback is included because when generated, some marshalled specs have it
+  # set to +nil+.
+
+  def required_ruby_version
+    spec.required_ruby_version || Gem::Requirement.default
+  end
+
+  ##
+  # The required_rubygems_version constraint for this specification
+  #
+  # A fallback is included because the original version of the specification
+  # API didn't include that field, so some marshalled specs in the index have it
+  # set to +nil+.
+
+  def required_rubygems_version
+    spec.required_rubygems_version || Gem::Requirement.default
+  end
+
+  def ==(other)
+    self.class === other &&
+      @name == other.name &&
+      @version == other.version &&
+      @platform == other.platform
+  end
+
+  def hash
+    @name.hash ^ @version.hash ^ @platform.hash
+  end
+
   def inspect # :nodoc:
-    '#<%s %s source %s>' % [self.class, full_name, @source]
+    "#<%s %s source %s>" % [self.class, full_name, @source]
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[Index specification', ']' do
+    q.group 2, "[Index specification", "]" do
       q.breakable
       q.text full_name
 
@@ -49,7 +81,7 @@ class Gem::Resolver::IndexSpecification 
       end
 
       q.breakable
-      q.text 'source '
+      q.text "source "
       q.pp @source
     end
   end
@@ -60,10 +92,9 @@ class Gem::Resolver::IndexSpecification 
   def spec # :nodoc:
     @spec ||=
       begin
-        tuple = Gem::NameTuple.new @name, @version, @platform
+        tuple = Gem::NameTuple.new @name, @version, @original_platform
 
         @source.fetch_spec tuple
       end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/installed_specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/installed_specification.rb
@@ -4,10 +4,9 @@
 # locally.
 
 class Gem::Resolver::InstalledSpecification < Gem::Resolver::SpecSpecification
-
   def ==(other) # :nodoc:
-    self.class === other and
-      @set  == other.set and
+    self.class === other &&
+      @set  == other.set &&
       @spec == other.spec
   end
 
@@ -31,7 +30,7 @@ class Gem::Resolver::InstalledSpecificat
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[InstalledSpecification', ']' do
+    q.group 2, "[InstalledSpecification", "]" do
       q.breakable
       q.text "name: #{name}"
 
@@ -42,7 +41,7 @@ class Gem::Resolver::InstalledSpecificat
       q.text "platform: #{platform}"
 
       q.breakable
-      q.text 'dependencies:'
+      q.text "dependencies:"
       q.breakable
       q.pp spec.dependencies
     end
@@ -54,5 +53,4 @@ class Gem::Resolver::InstalledSpecificat
   def source
     @source ||= Gem::Source::Installed.new
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/installer_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/installer_set.rb
@@ -4,7 +4,6 @@
 # files
 
 class Gem::Resolver::InstallerSet < Gem::Resolver::Set
-
   ##
   # List of Gem::Specification objects that must always be installed.
 
@@ -27,13 +26,18 @@ class Gem::Resolver::InstallerSet < Gem:
   attr_reader :remote_set # :nodoc:
 
   ##
+  # Ignore ruby & rubygems specification constraints.
+  #
+
+  attr_accessor :force # :nodoc:
+
+  ##
   # Creates a new InstallerSet that will look for gems in +domain+.
 
   def initialize(domain)
     super()
 
     @domain = domain
-    @remote = consider_remote?
 
     @f = Gem::SpecFetcher.fetcher
 
@@ -43,6 +47,7 @@ class Gem::Resolver::InstallerSet < Gem:
     @local               = {}
     @local_source        = Gem::Source::Local.new
     @remote_set          = Gem::Resolver::BestSet.new
+    @force               = false
     @specs               = {}
   end
 
@@ -56,24 +61,38 @@ class Gem::Resolver::InstallerSet < Gem:
     found = find_all request
 
     found.delete_if do |s|
-      s.version.prerelease? and not s.local?
+      s.version.prerelease? && !s.local?
     end unless dependency.prerelease?
 
     found = found.select do |s|
-      Gem::Source::SpecificFile === s.source or
-        Gem::Platform::RUBY == s.platform or
-        Gem::Platform.local === s.platform
+      Gem::Source::SpecificFile === s.source ||
+        Gem::Platform.match(s.platform)
+    end
+
+    found = found.sort_by do |s|
+      [s.version, Gem::Platform.sort_priority(s.platform)]
     end
 
-    if found.empty?
+    newest = found.last
+
+    unless newest
       exc = Gem::UnsatisfiableDependencyError.new request
       exc.errors = errors
 
       raise exc
     end
 
-    newest = found.max_by do |s|
-      [s.version, s.platform == Gem::Platform::RUBY ? -1 : 1]
+    unless @force
+      found_matching_metadata = found.reverse.find do |spec|
+        metadata_satisfied?(spec)
+      end
+
+      if found_matching_metadata.nil?
+        ensure_required_ruby_version_met(newest.spec)
+        ensure_required_rubygems_version_met(newest.spec)
+      else
+        newest = found_matching_metadata
+      end
     end
 
     @always_install << newest.spec
@@ -91,14 +110,14 @@ class Gem::Resolver::InstallerSet < Gem:
   # Should local gems should be considered?
 
   def consider_local? # :nodoc:
-    @domain == :both or @domain == :local
+    @domain == :both || @domain == :local
   end
 
   ##
   # Should remote gems should be considered?
 
   def consider_remote? # :nodoc:
-    @domain == :both or @domain == :remote
+    @domain == :both || @domain == :remote
   end
 
   ##
@@ -117,13 +136,13 @@ class Gem::Resolver::InstallerSet < Gem:
 
     dep = req.dependency
 
-    return res if @ignore_dependencies and
-              @always_install.none? { |spec| dep.match? spec }
+    return res if @ignore_dependencies &&
+                  @always_install.none? {|spec| dep.match? spec }
 
     name = dep.name
 
     dep.matching_specs.each do |gemspec|
-      next if @always_install.any? { |spec| spec.name == gemspec.name }
+      next if @always_install.any? {|spec| spec.name == gemspec.name }
 
       res << Gem::Resolver::InstalledSpecification.new(self, gemspec)
     end unless @ignore_installed
@@ -148,10 +167,6 @@ class Gem::Resolver::InstallerSet < Gem:
       end
     end
 
-    res.delete_if do |spec|
-      spec.version.prerelease? and not dep.prerelease?
-    end
-
     res.concat @remote_set.find_all req if consider_remote?
 
     res
@@ -168,10 +183,10 @@ class Gem::Resolver::InstallerSet < Gem:
   end
 
   def inspect # :nodoc:
-    always_install = @always_install.map { |s| s.full_name }
+    always_install = @always_install.map {|s| s.full_name }
 
-    '#<%s domain: %s specs: %p always install: %p>' % [
-      self.class, @domain, @specs.keys, always_install,
+    "#<%s domain: %s specs: %p always install: %p>" % [
+      self.class, @domain, @specs.keys, always_install
     ]
   end
 
@@ -199,16 +214,16 @@ class Gem::Resolver::InstallerSet < Gem:
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[InstallerSet', ']' do
+    q.group 2, "[InstallerSet", "]" do
       q.breakable
       q.text "domain: #{@domain}"
 
       q.breakable
-      q.text 'specs: '
+      q.text "specs: "
       q.pp @specs.keys
 
       q.breakable
-      q.text 'always install: '
+      q.text "always install: "
       q.pp @always_install
     end
   end
@@ -224,4 +239,31 @@ class Gem::Resolver::InstallerSet < Gem:
     end
   end
 
+  private
+
+  def metadata_satisfied?(spec)
+    spec.required_ruby_version.satisfied_by?(Gem.ruby_version) &&
+      spec.required_rubygems_version.satisfied_by?(Gem.rubygems_version)
+  end
+
+  def ensure_required_ruby_version_met(spec) # :nodoc:
+    if rrv = spec.required_ruby_version
+      ruby_version = Gem.ruby_version
+      unless rrv.satisfied_by? ruby_version
+        raise Gem::RuntimeRequirementNotMetError,
+          "#{spec.full_name} requires Ruby version #{rrv}. The current ruby version is #{ruby_version}."
+      end
+    end
+  end
+
+  def ensure_required_rubygems_version_met(spec) # :nodoc:
+    if rrgv = spec.required_rubygems_version
+      unless rrgv.satisfied_by? Gem.rubygems_version
+        rg_version = Gem::VERSION
+        raise Gem::RuntimeRequirementNotMetError,
+          "#{spec.full_name} requires RubyGems version #{rrgv}. The current RubyGems version is #{rg_version}. " +
+          "Try 'gem update --system' to update RubyGems itself."
+      end
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/local_specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/local_specification.rb
@@ -3,7 +3,6 @@
 # A LocalSpecification comes from a .gem file on the local filesystem.
 
 class Gem::Resolver::LocalSpecification < Gem::Resolver::SpecSpecification
-
   ##
   # Returns +true+ if this gem is installable for the current platform.
 
@@ -18,7 +17,7 @@ class Gem::Resolver::LocalSpecification 
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[LocalSpecification', ']' do
+    q.group 2, "[LocalSpecification", "]" do
       q.breakable
       q.text "name: #{name}"
 
@@ -29,7 +28,7 @@ class Gem::Resolver::LocalSpecification 
       q.text "platform: #{platform}"
 
       q.breakable
-      q.text 'dependencies:'
+      q.text "dependencies:"
       q.breakable
       q.pp dependencies
 
@@ -37,5 +36,4 @@ class Gem::Resolver::LocalSpecification 
       q.text "source: #{@source.path}"
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/lock_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/lock_set.rb
@@ -3,7 +3,6 @@
 # A set of gems from a gem dependencies lockfile.
 
 class Gem::Resolver::LockSet < Gem::Resolver::Set
-
   attr_reader :specs # :nodoc:
 
   ##
@@ -29,7 +28,7 @@ class Gem::Resolver::LockSet < Gem::Reso
   def add(name, version, platform) # :nodoc:
     version = Gem::Version.new version
     specs = [
-      Gem::Resolver::LockSpecification.new(self, name, version, @sources, platform)
+      Gem::Resolver::LockSpecification.new(self, name, version, @sources, platform),
     ]
 
     @specs.concat specs
@@ -55,7 +54,7 @@ class Gem::Resolver::LockSet < Gem::Reso
     dep = Gem::Dependency.new name, version
 
     found = @specs.find do |spec|
-      dep.matches_spec? spec and spec.platform == platform
+      dep.matches_spec?(spec) && spec.platform == platform
     end
 
     tuple = Gem::NameTuple.new found.name, found.version, found.platform
@@ -64,19 +63,18 @@ class Gem::Resolver::LockSet < Gem::Reso
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[LockSet', ']' do
+    q.group 2, "[LockSet", "]" do
       q.breakable
-      q.text 'source:'
+      q.text "source:"
 
       q.breakable
       q.pp @source
 
       q.breakable
-      q.text 'specs:'
+      q.text "specs:"
 
       q.breakable
-      q.pp @specs.map { |spec| spec.full_name }
+      q.pp @specs.map {|spec| spec.full_name }
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/lock_specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/lock_specification.rb
@@ -6,7 +6,6 @@
 # lockfile.
 
 class Gem::Resolver::LockSpecification < Gem::Resolver::Specification
-
   attr_reader :sources
 
   def initialize(set, name, version, sources, platform)
@@ -30,7 +29,7 @@ class Gem::Resolver::LockSpecification <
   def install(options = {})
     destination = options[:install_dir] || Gem.dir
 
-    if File.exist? File.join(destination, 'specifications', spec.spec_name)
+    if File.exist? File.join(destination, "specifications", spec.spec_name)
       yield nil
       return
     end
@@ -46,7 +45,7 @@ class Gem::Resolver::LockSpecification <
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[LockSpecification', ']' do
+    q.group 2, "[LockSpecification", "]" do
       q.breakable
       q.text "name: #{@name}"
 
@@ -60,7 +59,7 @@ class Gem::Resolver::LockSpecification <
 
       unless @dependencies.empty?
         q.breakable
-        q.text 'dependencies:'
+        q.text "dependencies:"
         q.breakable
         q.pp @dependencies
       end
@@ -72,7 +71,7 @@ class Gem::Resolver::LockSpecification <
 
   def spec
     @spec ||= Gem::Specification.find do |spec|
-      spec.name == @name and spec.version == @version
+      spec.name == @name && spec.version == @version
     end
 
     @spec ||= Gem::Specification.new do |s|
@@ -83,5 +82,4 @@ class Gem::Resolver::LockSpecification <
       s.dependencies.concat @dependencies
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo.rb
@@ -1,2 +1,2 @@
 # frozen_string_literal: true
-require 'rubygems/resolver/molinillo/lib/molinillo'
+require_relative "molinillo/lib/molinillo"
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/LICENSE
@@ -0,0 +1,9 @@
+This project is licensed under the MIT license.
+
+Copyright (c) 2014 Samuel E. Giddins segiddins@segiddins.me
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo.rb
@@ -1,9 +1,10 @@
 # frozen_string_literal: true
-require 'rubygems/resolver/molinillo/lib/molinillo/gem_metadata'
-require 'rubygems/resolver/molinillo/lib/molinillo/errors'
-require 'rubygems/resolver/molinillo/lib/molinillo/resolver'
-require 'rubygems/resolver/molinillo/lib/molinillo/modules/ui'
-require 'rubygems/resolver/molinillo/lib/molinillo/modules/specification_provider'
+
+require_relative 'molinillo/gem_metadata'
+require_relative 'molinillo/errors'
+require_relative 'molinillo/resolver'
+require_relative 'molinillo/modules/ui'
+require_relative 'molinillo/modules/specification_provider'
 
 # Gem::Resolver::Molinillo is a generic dependency resolution algorithm.
 module Gem::Resolver::Molinillo
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/delegates/resolution_state.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/delegates/resolution_state.rb
@@ -1,4 +1,5 @@
 # frozen_string_literal: true
+
 module Gem::Resolver::Molinillo
   # @!visibility private
   module Delegates
@@ -45,6 +46,12 @@ module Gem::Resolver::Molinillo
         current_state = state || Gem::Resolver::Molinillo::ResolutionState.empty
         current_state.conflicts
       end
+
+      # (see Gem::Resolver::Molinillo::ResolutionState#unused_unwind_options)
+      def unused_unwind_options
+        current_state = state || Gem::Resolver::Molinillo::ResolutionState.empty
+        current_state.unused_unwind_options
+      end
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/delegates/specification_provider.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/delegates/specification_provider.rb
@@ -1,4 +1,5 @@
 # frozen_string_literal: true
+
 module Gem::Resolver::Molinillo
   module Delegates
     # Delegates all {Gem::Resolver::Molinillo::SpecificationProvider} methods to a
@@ -25,6 +26,13 @@ module Gem::Resolver::Molinillo
         end
       end
 
+      # (see Gem::Resolver::Molinillo::SpecificationProvider#dependencies_equal?)
+      def dependencies_equal?(dependencies, other_dependencies)
+        with_no_such_dependency_error_handling do
+          specification_provider.dependencies_equal?(dependencies, other_dependencies)
+        end
+      end
+
       # (see Gem::Resolver::Molinillo::SpecificationProvider#name_for)
       def name_for(dependency)
         with_no_such_dependency_error_handling do
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph.rb
@@ -1,9 +1,9 @@
 # frozen_string_literal: true
-require 'set'
-require 'tsort'
 
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/log'
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/vertex'
+require_relative '../../../../tsort'
+
+require_relative 'dependency_graph/log'
+require_relative 'dependency_graph/vertex'
 
 module Gem::Resolver::Molinillo
   # A directed acyclic graph that is tuned to hold named dependencies
@@ -17,7 +17,7 @@ module Gem::Resolver::Molinillo
       vertices.values.each { |v| yield v }
     end
 
-    include TSort
+    include Gem::TSort
 
     # @!visibility private
     alias tsort_each_node each
@@ -123,6 +123,7 @@ module Gem::Resolver::Molinillo
       dot.join("\n")
     end
 
+    # @param [DependencyGraph] other
     # @return [Boolean] whether the two dependency graphs are equal, determined
     #   by a recursive traversal of each {#root_vertices} and its
     #   {Vertex#successors}
@@ -147,8 +148,8 @@ module Gem::Resolver::Molinillo
       vertex = add_vertex(name, payload, root)
       vertex.explicit_requirements << requirement if root
       parent_names.each do |parent_name|
-        parent_node = vertex_named(parent_name)
-        add_edge(parent_node, vertex, requirement)
+        parent_vertex = vertex_named(parent_name)
+        add_edge(parent_vertex, vertex, requirement)
       end
       vertex
     end
@@ -189,7 +190,7 @@ module Gem::Resolver::Molinillo
     # @return [Edge] the added edge
     def add_edge(origin, destination, requirement)
       if destination.path_to?(origin)
-        raise CircularDependencyError.new([origin, destination])
+        raise CircularDependencyError.new(path(destination, origin))
       end
       add_edge_no_circular(origin, destination, requirement)
     end
@@ -218,5 +219,37 @@ module Gem::Resolver::Molinillo
     def add_edge_no_circular(origin, destination, requirement)
       log.add_edge_no_circular(self, origin.name, destination.name, requirement)
     end
+
+    # Returns the path between two vertices
+    # @raise [ArgumentError] if there is no path between the vertices
+    # @param [Vertex] from
+    # @param [Vertex] to
+    # @return [Array<Vertex>] the shortest path from `from` to `to`
+    def path(from, to)
+      distances = Hash.new(vertices.size + 1)
+      distances[from.name] = 0
+      predecessors = {}
+      each do |vertex|
+        vertex.successors.each do |successor|
+          if distances[successor.name] > distances[vertex.name] + 1
+            distances[successor.name] = distances[vertex.name] + 1
+            predecessors[successor] = vertex
+          end
+        end
+      end
+
+      path = [to]
+      while before = predecessors[to]
+        path << before
+        to = before
+        break if to == from
+      end
+
+      unless path.last.equal?(from)
+        raise ArgumentError, "There is no path from #{from.name} to #{to.name}"
+      end
+
+      path.reverse
+    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/action.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/action.rb
@@ -1,4 +1,5 @@
 # frozen_string_literal: true
+
 module Gem::Resolver::Molinillo
   class DependencyGraph
     # An action that modifies a {DependencyGraph} that is reversible.
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/add_edge_no_circular.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/add_edge_no_circular.rb
@@ -1,5 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/action'
+
+require_relative 'action'
 module Gem::Resolver::Molinillo
   class DependencyGraph
     # @!visibility private
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/add_vertex.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/add_vertex.rb
@@ -1,5 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/action'
+
+require_relative 'action'
 module Gem::Resolver::Molinillo
   class DependencyGraph
     # @!visibility private
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/delete_edge.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/delete_edge.rb
@@ -1,5 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/action'
+
+require_relative 'action'
 module Gem::Resolver::Molinillo
   class DependencyGraph
     # @!visibility private
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/detach_vertex_named.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/detach_vertex_named.rb
@@ -1,5 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/action'
+
+require_relative 'action'
 module Gem::Resolver::Molinillo
   class DependencyGraph
     # @!visibility private
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/log.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/log.rb
@@ -1,10 +1,11 @@
 # frozen_string_literal: true
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/add_edge_no_circular'
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/add_vertex'
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/delete_edge'
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/detach_vertex_named'
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/set_payload'
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/tag'
+
+require_relative 'add_edge_no_circular'
+require_relative 'add_vertex'
+require_relative 'delete_edge'
+require_relative 'detach_vertex_named'
+require_relative 'set_payload'
+require_relative 'tag'
 
 module Gem::Resolver::Molinillo
   class DependencyGraph
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/set_payload.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/set_payload.rb
@@ -1,5 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/action'
+
+require_relative 'action'
 module Gem::Resolver::Molinillo
   class DependencyGraph
     # @!visibility private
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/tag.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/tag.rb
@@ -1,5 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph/action'
+
+require_relative 'action'
 module Gem::Resolver::Molinillo
   class DependencyGraph
     # @!visibility private
@@ -13,11 +14,11 @@ module Gem::Resolver::Molinillo
       end
 
       # (see Action#up)
-      def up(_graph)
+      def up(graph)
       end
 
       # (see Action#down)
-      def down(_graph)
+      def down(graph)
       end
 
       # @!group Tag
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/vertex.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph/vertex.rb
@@ -1,4 +1,5 @@
 # frozen_string_literal: true
+
 module Gem::Resolver::Molinillo
   class DependencyGraph
     # A vertex in a {DependencyGraph} that encapsulates a {#name} and a
@@ -32,7 +33,7 @@ module Gem::Resolver::Molinillo
       # @return [Array<Object>] all of the requirements that required
       #   this vertex
       def requirements
-        incoming_edges.map(&:requirement) + explicit_requirements
+        (incoming_edges.map(&:requirement) + explicit_requirements).uniq
       end
 
       # @return [Array<Edge>] the edges of {#graph} that have `self` as their
@@ -49,14 +50,25 @@ module Gem::Resolver::Molinillo
         incoming_edges.map(&:origin)
       end
 
-      # @return [Array<Vertex>] the vertices of {#graph} where `self` is a
+      # @return [Set<Vertex>] the vertices of {#graph} where `self` is a
       #   {#descendent?}
       def recursive_predecessors
-        vertices = predecessors
-        vertices += vertices.map(&:recursive_predecessors).flatten(1)
-        vertices.uniq!
+        _recursive_predecessors
+      end
+
+      # @param [Set<Vertex>] vertices the set to add the predecessors to
+      # @return [Set<Vertex>] the vertices of {#graph} where `self` is a
+      #   {#descendent?}
+      def _recursive_predecessors(vertices = new_vertex_set)
+        incoming_edges.each do |edge|
+          vertex = edge.origin
+          next unless vertices.add?(vertex)
+          vertex._recursive_predecessors(vertices)
+        end
+
         vertices
       end
+      protected :_recursive_predecessors
 
       # @return [Array<Vertex>] the vertices of {#graph} that have an edge with
       #   `self` as their {Edge#origin}
@@ -64,14 +76,25 @@ module Gem::Resolver::Molinillo
         outgoing_edges.map(&:destination)
       end
 
-      # @return [Array<Vertex>] the vertices of {#graph} where `self` is an
+      # @return [Set<Vertex>] the vertices of {#graph} where `self` is an
       #   {#ancestor?}
       def recursive_successors
-        vertices = successors
-        vertices += vertices.map(&:recursive_successors).flatten(1)
-        vertices.uniq!
+        _recursive_successors
+      end
+
+      # @param [Set<Vertex>] vertices the set to add the successors to
+      # @return [Set<Vertex>] the vertices of {#graph} where `self` is an
+      #   {#ancestor?}
+      def _recursive_successors(vertices = new_vertex_set)
+        outgoing_edges.each do |edge|
+          vertex = edge.destination
+          next unless vertices.add?(vertex)
+          vertex._recursive_successors(vertices)
+        end
+
         vertices
       end
+      protected :_recursive_successors
 
       # @return [String] a string suitable for debugging
       def inspect
@@ -105,21 +128,37 @@ module Gem::Resolver::Molinillo
 
       # Is there a path from `self` to `other` following edges in the
       # dependency graph?
-      # @return true iff there is a path following edges within this {#graph}
+      # @return whether there is a path following edges within this {#graph}
       def path_to?(other)
-        equal?(other) || successors.any? { |v| v.path_to?(other) }
+        _path_to?(other)
       end
 
       alias descendent? path_to?
 
+      # @param [Vertex] other the vertex to check if there's a path to
+      # @param [Set<Vertex>] visited the vertices of {#graph} that have been visited
+      # @return [Boolean] whether there is a path to `other` from `self`
+      def _path_to?(other, visited = new_vertex_set)
+        return false unless visited.add?(self)
+        return true if equal?(other)
+        successors.any? { |v| v._path_to?(other, visited) }
+      end
+      protected :_path_to?
+
       # Is there a path from `other` to `self` following edges in the
       # dependency graph?
-      # @return true iff there is a path following edges within this {#graph}
+      # @return whether there is a path following edges within this {#graph}
       def ancestor?(other)
         other.path_to?(self)
       end
 
       alias is_reachable_from? ancestor?
+
+      def new_vertex_set
+        require 'set'
+        Set.new
+      end
+      private :new_vertex_set
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/errors.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/errors.rb
@@ -1,4 +1,5 @@
 # frozen_string_literal: true
+
 module Gem::Resolver::Molinillo
   # An error that occurred during the resolution process
   class ResolverError < StandardError; end
@@ -17,7 +18,7 @@ module Gem::Resolver::Molinillo
     # @param [Array<Object>] required_by @see {#required_by}
     def initialize(dependency, required_by = [])
       @dependency = dependency
-      @required_by = required_by
+      @required_by = required_by.uniq
       super()
     end
 
@@ -33,7 +34,7 @@ module Gem::Resolver::Molinillo
 
   # An error caused by attempting to fulfil a dependency that was circular
   #
-  # @note This exception will be thrown iff a {Vertex} is added to a
+  # @note This exception will be thrown if and only if a {Vertex} is added to a
   #   {DependencyGraph} that has a {DependencyGraph::Vertex#path_to?} an
   #   existing {DependencyGraph::Vertex}
   class CircularDependencyError < ResolverError
@@ -41,11 +42,11 @@ module Gem::Resolver::Molinillo
     attr_reader :dependencies
 
     # Initializes a new error with the given circular vertices.
-    # @param [Array<DependencyGraph::Vertex>] nodes the nodes in the dependency
+    # @param [Array<DependencyGraph::Vertex>] vertices the vertices in the dependency
     #   that caused the error
-    def initialize(nodes)
-      super "There is a circular dependency between #{nodes.map(&:name).join(' and ')}"
-      @dependencies = nodes.map(&:payload).to_set
+    def initialize(vertices)
+      super "There is a circular dependency between #{vertices.map(&:name).join(' and ')}"
+      @dependencies = vertices.map { |vertex| vertex.payload.possibilities.last }.to_set
     end
   end
 
@@ -55,11 +56,16 @@ module Gem::Resolver::Molinillo
     #   resolution to fail
     attr_reader :conflicts
 
+    # @return [SpecificationProvider] the specification provider used during
+    #   resolution
+    attr_reader :specification_provider
+
     # Initializes a new error with the given version conflicts.
     # @param [{String => Resolution::Conflict}] conflicts see {#conflicts}
-    def initialize(conflicts)
+    # @param [SpecificationProvider] specification_provider see {#specification_provider}
+    def initialize(conflicts, specification_provider)
       pairs = []
-      conflicts.values.flatten.map(&:requirements).flatten.each do |conflicting|
+      conflicts.values.flat_map(&:requirements).each do |conflicting|
         conflicting.each do |source, conflict_requirements|
           conflict_requirements.each do |c|
             pairs << [c, source]
@@ -69,7 +75,69 @@ module Gem::Resolver::Molinillo
 
       super "Unable to satisfy the following requirements:\n\n" \
         "#{pairs.map { |r, d| "- `#{r}` required by `#{d}`" }.join("\n")}"
+
       @conflicts = conflicts
+      @specification_provider = specification_provider
+    end
+
+    require_relative 'delegates/specification_provider'
+    include Delegates::SpecificationProvider
+
+    # @return [String] An error message that includes requirement trees,
+    #   which is much more detailed & customizable than the default message
+    # @param [Hash] opts the options to create a message with.
+    # @option opts [String] :solver_name The user-facing name of the solver
+    # @option opts [String] :possibility_type The generic name of a possibility
+    # @option opts [Proc] :reduce_trees A proc that reduced the list of requirement trees
+    # @option opts [Proc] :printable_requirement A proc that pretty-prints requirements
+    # @option opts [Proc] :additional_message_for_conflict A proc that appends additional
+    #   messages for each conflict
+    # @option opts [Proc] :version_for_spec A proc that returns the version number for a
+    #   possibility
+    def message_with_trees(opts = {})
+      solver_name = opts.delete(:solver_name) { self.class.name.split('::').first }
+      possibility_type = opts.delete(:possibility_type) { 'possibility named' }
+      reduce_trees = opts.delete(:reduce_trees) { proc { |trees| trees.uniq.sort_by(&:to_s) } }
+      printable_requirement = opts.delete(:printable_requirement) { proc { |req| req.to_s } }
+      additional_message_for_conflict = opts.delete(:additional_message_for_conflict) { proc {} }
+      version_for_spec = opts.delete(:version_for_spec) { proc(&:to_s) }
+      incompatible_version_message_for_conflict = opts.delete(:incompatible_version_message_for_conflict) do
+        proc do |name, _conflict|
+          %(#{solver_name} could not find compatible versions for #{possibility_type} "#{name}":)
+        end
+      end
+
+      conflicts.sort.reduce(''.dup) do |o, (name, conflict)|
+        o << "\n" << incompatible_version_message_for_conflict.call(name, conflict) << "\n"
+        if conflict.locked_requirement
+          o << %(  In snapshot (#{name_for_locking_dependency_source}):\n)
+          o << %(    #{printable_requirement.call(conflict.locked_requirement)}\n)
+          o << %(\n)
+        end
+        o << %(  In #{name_for_explicit_dependency_source}:\n)
+        trees = reduce_trees.call(conflict.requirement_trees)
+
+        o << trees.map do |tree|
+          t = ''.dup
+          depth = 2
+          tree.each do |req|
+            t << '  ' * depth << printable_requirement.call(req)
+            unless tree.last == req
+              if spec = conflict.activated_by_name[name_for(req)]
+                t << %( was resolved to #{version_for_spec.call(spec)}, which)
+              end
+              t << %( depends on)
+            end
+            t << %(\n)
+            depth += 1
+          end
+          t
+        end.join("\n")
+
+        additional_message_for_conflict.call(o, name, conflict)
+
+        o
+      end.strip
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/gem_metadata.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/gem_metadata.rb
@@ -1,5 +1,6 @@
 # frozen_string_literal: true
+
 module Gem::Resolver::Molinillo
   # The version of Gem::Resolver::Molinillo.
-  VERSION = '0.5.7'.freeze
+  VERSION = '0.7.0'.freeze
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/modules/specification_provider.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/modules/specification_provider.rb
@@ -1,6 +1,7 @@
 # frozen_string_literal: true
+
 module Gem::Resolver::Molinillo
-  # Provides information about specifcations and dependencies to the resolver,
+  # Provides information about specifications and dependencies to the resolver,
   # allowing the {Resolver} class to remain generic while still providing power
   # and flexibility.
   #
@@ -44,6 +45,17 @@ module Gem::Resolver::Molinillo
       true
     end
 
+    # Determines whether two arrays of dependencies are equal, and thus can be
+    # grouped.
+    #
+    # @param [Array<Object>] dependencies
+    # @param [Array<Object>] other_dependencies
+    # @return [Boolean] whether `dependencies` and `other_dependencies` should
+    #   be considered equal.
+    def dependencies_equal?(dependencies, other_dependencies)
+      dependencies == other_dependencies
+    end
+
     # Returns the name for the given `dependency`.
     # @note This method should be 'pure', i.e. the return value should depend
     #   only on the `dependency` parameter.
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/modules/ui.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/modules/ui.rb
@@ -1,4 +1,5 @@
 # frozen_string_literal: true
+
 module Gem::Resolver::Molinillo
   # Conveys information about the resolution process to a user.
   module UI
@@ -48,7 +49,8 @@ module Gem::Resolver::Molinillo
       if debug?
         debug_info = yield
         debug_info = debug_info.inspect unless debug_info.is_a?(String)
-        output.puts debug_info.split("\n").map { |s| ' ' * depth + s }
+        debug_info = debug_info.split("\n").map { |s| ":#{depth.to_s.rjust 4}: #{s}" }
+        output.puts debug_info
       end
     end
 
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/resolution.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/resolution.rb
@@ -1,4 +1,5 @@
 # frozen_string_literal: true
+
 module Gem::Resolver::Molinillo
   class Resolver
     # A specific resolution from a given {Resolver}
@@ -8,22 +9,125 @@ module Gem::Resolver::Molinillo
       # @attr [{String,Nil=>[Object]}] requirements the requirements that caused the conflict
       # @attr [Object, nil] existing the existing spec that was in conflict with
       #   the {#possibility}
-      # @attr [Object] possibility the spec that was unable to be activated due
-      #   to a conflict
+      # @attr [Object] possibility_set the set of specs that was unable to be
+      #   activated due to a conflict.
       # @attr [Object] locked_requirement the relevant locking requirement.
       # @attr [Array<Array<Object>>] requirement_trees the different requirement
       #   trees that led to every requirement for the conflicting name.
       # @attr [{String=>Object}] activated_by_name the already-activated specs.
+      # @attr [Object] underlying_error an error that has occurred during resolution, and
+      #    will be raised at the end of it if no resolution is found.
       Conflict = Struct.new(
         :requirement,
         :requirements,
         :existing,
-        :possibility,
+        :possibility_set,
         :locked_requirement,
         :requirement_trees,
-        :activated_by_name
+        :activated_by_name,
+        :underlying_error
       )
 
+      class Conflict
+        # @return [Object] a spec that was unable to be activated due to a conflict
+        def possibility
+          possibility_set && possibility_set.latest_version
+        end
+      end
+
+      # A collection of possibility states that share the same dependencies
+      # @attr [Array] dependencies the dependencies for this set of possibilities
+      # @attr [Array] possibilities the possibilities
+      PossibilitySet = Struct.new(:dependencies, :possibilities)
+
+      class PossibilitySet
+        # String representation of the possibility set, for debugging
+        def to_s
+          "[#{possibilities.join(', ')}]"
+        end
+
+        # @return [Object] most up-to-date dependency in the possibility set
+        def latest_version
+          possibilities.last
+        end
+      end
+
+      # Details of the state to unwind to when a conflict occurs, and the cause of the unwind
+      # @attr [Integer] state_index the index of the state to unwind to
+      # @attr [Object] state_requirement the requirement of the state we're unwinding to
+      # @attr [Array] requirement_tree for the requirement we're relaxing
+      # @attr [Array] conflicting_requirements the requirements that combined to cause the conflict
+      # @attr [Array] requirement_trees for the conflict
+      # @attr [Array] requirements_unwound_to_instead array of unwind requirements that were chosen over this unwind
+      UnwindDetails = Struct.new(
+        :state_index,
+        :state_requirement,
+        :requirement_tree,
+        :conflicting_requirements,
+        :requirement_trees,
+        :requirements_unwound_to_instead
+      )
+
+      class UnwindDetails
+        include Comparable
+
+        # We compare UnwindDetails when choosing which state to unwind to. If
+        # two options have the same state_index we prefer the one most
+        # removed from a requirement that caused the conflict. Both options
+        # would unwind to the same state, but a `grandparent` option will
+        # filter out fewer of its possibilities after doing so - where a state
+        # is both a `parent` and a `grandparent` to requirements that have
+        # caused a conflict this is the correct behaviour.
+        # @param [UnwindDetail] other UnwindDetail to be compared
+        # @return [Integer] integer specifying ordering
+        def <=>(other)
+          if state_index > other.state_index
+            1
+          elsif state_index == other.state_index
+            reversed_requirement_tree_index <=> other.reversed_requirement_tree_index
+          else
+            -1
+          end
+        end
+
+        # @return [Integer] index of state requirement in reversed requirement tree
+        #    (the conflicting requirement itself will be at position 0)
+        def reversed_requirement_tree_index
+          @reversed_requirement_tree_index ||=
+            if state_requirement
+              requirement_tree.reverse.index(state_requirement)
+            else
+              999_999
+            end
+        end
+
+        # @return [Boolean] where the requirement of the state we're unwinding
+        #    to directly caused the conflict. Note: in this case, it is
+        #    impossible for the state we're unwinding to to be a parent of
+        #    any of the other conflicting requirements (or we would have
+        #    circularity)
+        def unwinding_to_primary_requirement?
+          requirement_tree.last == state_requirement
+        end
+
+        # @return [Array] array of sub-dependencies to avoid when choosing a
+        #    new possibility for the state we've unwound to. Only relevant for
+        #    non-primary unwinds
+        def sub_dependencies_to_avoid
+          @requirements_to_avoid ||=
+            requirement_trees.map do |tree|
+              index = tree.index(state_requirement)
+              tree[index + 1] if index
+            end.compact
+        end
+
+        # @return [Array] array of all the requirements that led to the need for
+        #    this unwind
+        def all_requirements
+          @all_requirements ||= requirement_trees.flatten(1)
+        end
+      end
+
       # @return [SpecificationProvider] the provider that knows about
       #   dependencies, requirements, specifications, versions, etc.
       attr_reader :specification_provider
@@ -64,7 +168,7 @@ module Gem::Resolver::Molinillo
         start_resolution
 
         while state
-          break unless state.requirements.any? || state.requirement
+          break if !state.requirement && state.requirements.empty?
           indicate_progress
           if state.respond_to?(:pop_possibility_state) # DependencyState
             debug(depth) { "Creating possibility state for #{requirement} (#{possibilities.count} remaining)" }
@@ -78,7 +182,7 @@ module Gem::Resolver::Molinillo
           process_topmost_state
         end
 
-        activated.freeze
+        resolve_activated_specs
       ensure
         end_resolution
       end
@@ -103,12 +207,25 @@ module Gem::Resolver::Molinillo
       def start_resolution
         @started_at = Time.now
 
-        handle_missing_or_push_dependency_state(initial_state)
+        push_initial_state
 
         debug { "Starting resolution (#{@started_at})\nUser-requested dependencies: #{original_requested}" }
         resolver_ui.before_resolution
       end
 
+      def resolve_activated_specs
+        activated.vertices.each do |_, vertex|
+          next unless vertex.payload
+
+          latest_version = vertex.payload.possibilities.reverse_each.find do |possibility|
+            vertex.requirements.all? { |req| requirement_satisfied_by?(req, activated, possibility) }
+          end
+
+          activated.set_payload(vertex.name, latest_version)
+        end
+        activated.freeze
+      end
+
       # Ends the resolution process
       # @return [void]
       def end_resolution
@@ -121,11 +238,11 @@ module Gem::Resolver::Molinillo
         debug { 'Activated: ' + Hash[activated.vertices.select { |_n, v| v.payload }].keys.join(', ') } if state
       end
 
-      require 'rubygems/resolver/molinillo/lib/molinillo/state'
-      require 'rubygems/resolver/molinillo/lib/molinillo/modules/specification_provider'
+      require_relative 'state'
+      require_relative 'modules/specification_provider'
 
-      require 'rubygems/resolver/molinillo/lib/molinillo/delegates/resolution_state'
-      require 'rubygems/resolver/molinillo/lib/molinillo/delegates/specification_provider'
+      require_relative 'delegates/resolution_state'
+      require_relative 'delegates/specification_provider'
 
       include Gem::Resolver::Molinillo::Delegates::ResolutionState
       include Gem::Resolver::Molinillo::Delegates::SpecificationProvider
@@ -136,9 +253,12 @@ module Gem::Resolver::Molinillo
         if possibility
           attempt_to_activate
         else
-          create_conflict if state.is_a? PossibilityState
-          unwind_for_conflict until possibility && state.is_a?(DependencyState)
+          create_conflict
+          unwind_for_conflict
         end
+      rescue CircularDependencyError => underlying_error
+        create_conflict(underlying_error)
+        unwind_for_conflict
       end
 
       # @return [Object] the current possibility that the resolution is trying
@@ -153,63 +273,296 @@ module Gem::Resolver::Molinillo
         states.last
       end
 
-      # Creates the initial state for the resolution, based upon the
+      # Creates and pushes the initial state for the resolution, based upon the
       # {#requested} dependencies
-      # @return [DependencyState] the initial state for the resolution
-      def initial_state
+      # @return [void]
+      def push_initial_state
         graph = DependencyGraph.new.tap do |dg|
-          original_requested.each { |r| dg.add_vertex(name_for(r), nil, true).tap { |v| v.explicit_requirements << r } }
+          original_requested.each do |requested|
+            vertex = dg.add_vertex(name_for(requested), nil, true)
+            vertex.explicit_requirements << requested
+          end
           dg.tag(:initial_state)
         end
 
-        requirements = sort_dependencies(original_requested, graph, {})
-        initial_requirement = requirements.shift
-        DependencyState.new(
-          initial_requirement && name_for(initial_requirement),
-          requirements,
-          graph,
-          initial_requirement,
-          initial_requirement && search_for(initial_requirement),
-          0,
-          {}
-        )
+        push_state_for_requirements(original_requested, true, graph)
       end
 
       # Unwinds the states stack because a conflict has been encountered
       # @return [void]
       def unwind_for_conflict
-        debug(depth) { "Unwinding for conflict: #{requirement} to #{state_index_for_unwind / 2}" }
+        details_for_unwind = build_details_for_unwind
+        unwind_options = unused_unwind_options
+        debug(depth) { "Unwinding for conflict: #{requirement} to #{details_for_unwind.state_index / 2}" }
         conflicts.tap do |c|
-          sliced_states = states.slice!((state_index_for_unwind + 1)..-1)
-          raise VersionConflict.new(c) unless state
+          sliced_states = states.slice!((details_for_unwind.state_index + 1)..-1)
+          raise_error_unless_state(c)
           activated.rewind_to(sliced_states.first || :initial_state) if sliced_states
           state.conflicts = c
+          state.unused_unwind_options = unwind_options
+          filter_possibilities_after_unwind(details_for_unwind)
           index = states.size - 1
           @parents_of.each { |_, a| a.reject! { |i| i >= index } }
+          state.unused_unwind_options.reject! { |uw| uw.state_index >= index }
+        end
+      end
+
+      # Raises a VersionConflict error, or any underlying error, if there is no
+      # current state
+      # @return [void]
+      def raise_error_unless_state(conflicts)
+        return if state
+
+        error = conflicts.values.map(&:underlying_error).compact.first
+        raise error || VersionConflict.new(conflicts, specification_provider)
+      end
+
+      # @return [UnwindDetails] Details of the nearest index to which we could unwind
+      def build_details_for_unwind
+        # Get the possible unwinds for the current conflict
+        current_conflict = conflicts[name]
+        binding_requirements = binding_requirements_for_conflict(current_conflict)
+        unwind_details = unwind_options_for_requirements(binding_requirements)
+
+        last_detail_for_current_unwind = unwind_details.sort.last
+        current_detail = last_detail_for_current_unwind
+
+        # Look for past conflicts that could be unwound to affect the
+        # requirement tree for the current conflict
+        all_reqs = last_detail_for_current_unwind.all_requirements
+        all_reqs_size = all_reqs.size
+        relevant_unused_unwinds = unused_unwind_options.select do |alternative|
+          diff_reqs = all_reqs - alternative.requirements_unwound_to_instead
+          next if diff_reqs.size == all_reqs_size
+          # Find the highest index unwind whilst looping through
+          current_detail = alternative if alternative > current_detail
+          alternative
+        end
+
+        # Add the current unwind options to the `unused_unwind_options` array.
+        # The "used" option will be filtered out during `unwind_for_conflict`.
+        state.unused_unwind_options += unwind_details.reject { |detail| detail.state_index == -1 }
+
+        # Update the requirements_unwound_to_instead on any relevant unused unwinds
+        relevant_unused_unwinds.each do |d|
+          (d.requirements_unwound_to_instead << current_detail.state_requirement).uniq!
+        end
+        unwind_details.each do |d|
+          (d.requirements_unwound_to_instead << current_detail.state_requirement).uniq!
+        end
+
+        current_detail
+      end
+
+      # @param [Array<Object>] binding_requirements array of requirements that combine to create a conflict
+      # @return [Array<UnwindDetails>] array of UnwindDetails that have a chance
+      #    of resolving the passed requirements
+      def unwind_options_for_requirements(binding_requirements)
+        unwind_details = []
+
+        trees = []
+        binding_requirements.reverse_each do |r|
+          partial_tree = [r]
+          trees << partial_tree
+          unwind_details << UnwindDetails.new(-1, nil, partial_tree, binding_requirements, trees, [])
+
+          # If this requirement has alternative possibilities, check if any would
+          # satisfy the other requirements that created this conflict
+          requirement_state = find_state_for(r)
+          if conflict_fixing_possibilities?(requirement_state, binding_requirements)
+            unwind_details << UnwindDetails.new(
+              states.index(requirement_state),
+              r,
+              partial_tree,
+              binding_requirements,
+              trees,
+              []
+            )
+          end
+
+          # Next, look at the parent of this requirement, and check if the requirement
+          # could have been avoided if an alternative PossibilitySet had been chosen
+          parent_r = parent_of(r)
+          next if parent_r.nil?
+          partial_tree.unshift(parent_r)
+          requirement_state = find_state_for(parent_r)
+          if requirement_state.possibilities.any? { |set| !set.dependencies.include?(r) }
+            unwind_details << UnwindDetails.new(
+              states.index(requirement_state),
+              parent_r,
+              partial_tree,
+              binding_requirements,
+              trees,
+              []
+            )
+          end
+
+          # Finally, look at the grandparent and up of this requirement, looking
+          # for any possibilities that wouldn't create their parent requirement
+          grandparent_r = parent_of(parent_r)
+          until grandparent_r.nil?
+            partial_tree.unshift(grandparent_r)
+            requirement_state = find_state_for(grandparent_r)
+            if requirement_state.possibilities.any? { |set| !set.dependencies.include?(parent_r) }
+              unwind_details << UnwindDetails.new(
+                states.index(requirement_state),
+                grandparent_r,
+                partial_tree,
+                binding_requirements,
+                trees,
+                []
+              )
+            end
+            parent_r = grandparent_r
+            grandparent_r = parent_of(parent_r)
+          end
+        end
+
+        unwind_details
+      end
+
+      # @param [DependencyState] state
+      # @param [Array] binding_requirements array of requirements
+      # @return [Boolean] whether or not the given state has any possibilities
+      #    that could satisfy the given requirements
+      def conflict_fixing_possibilities?(state, binding_requirements)
+        return false unless state
+
+        state.possibilities.any? do |possibility_set|
+          possibility_set.possibilities.any? do |poss|
+            possibility_satisfies_requirements?(poss, binding_requirements)
+          end
+        end
+      end
+
+      # Filter's a state's possibilities to remove any that would not fix the
+      # conflict we've just rewound from
+      # @param [UnwindDetails] unwind_details details of the conflict just
+      #   unwound from
+      # @return [void]
+      def filter_possibilities_after_unwind(unwind_details)
+        return unless state && !state.possibilities.empty?
+
+        if unwind_details.unwinding_to_primary_requirement?
+          filter_possibilities_for_primary_unwind(unwind_details)
+        else
+          filter_possibilities_for_parent_unwind(unwind_details)
         end
       end
 
-      # @return [Integer] The index to which the resolution should unwind in the
-      #   case of conflict.
-      def state_index_for_unwind
-        current_requirement = requirement
-        existing_requirement = requirement_for_existing_name(name)
-        index = -1
-        [current_requirement, existing_requirement].each do |r|
-          until r.nil?
-            current_state = find_state_for(r)
-            if state_any?(current_state)
-              current_index = states.index(current_state)
-              index = current_index if current_index > index
-              break
+      # Filter's a state's possibilities to remove any that would not satisfy
+      # the requirements in the conflict we've just rewound from
+      # @param [UnwindDetails] unwind_details details of the conflict just unwound from
+      # @return [void]
+      def filter_possibilities_for_primary_unwind(unwind_details)
+        unwinds_to_state = unused_unwind_options.select { |uw| uw.state_index == unwind_details.state_index }
+        unwinds_to_state << unwind_details
+        unwind_requirement_sets = unwinds_to_state.map(&:conflicting_requirements)
+
+        state.possibilities.reject! do |possibility_set|
+          possibility_set.possibilities.none? do |poss|
+            unwind_requirement_sets.any? do |requirements|
+              possibility_satisfies_requirements?(poss, requirements)
+            end
+          end
+        end
+      end
+
+      # @param [Object] possibility a single possibility
+      # @param [Array] requirements an array of requirements
+      # @return [Boolean] whether the possibility satisfies all of the
+      #    given requirements
+      def possibility_satisfies_requirements?(possibility, requirements)
+        name = name_for(possibility)
+
+        activated.tag(:swap)
+        activated.set_payload(name, possibility) if activated.vertex_named(name)
+        satisfied = requirements.all? { |r| requirement_satisfied_by?(r, activated, possibility) }
+        activated.rewind_to(:swap)
+
+        satisfied
+      end
+
+      # Filter's a state's possibilities to remove any that would (eventually)
+      # create a requirement in the conflict we've just rewound from
+      # @param [UnwindDetails] unwind_details details of the conflict just unwound from
+      # @return [void]
+      def filter_possibilities_for_parent_unwind(unwind_details)
+        unwinds_to_state = unused_unwind_options.select { |uw| uw.state_index == unwind_details.state_index }
+        unwinds_to_state << unwind_details
+
+        primary_unwinds = unwinds_to_state.select(&:unwinding_to_primary_requirement?).uniq
+        parent_unwinds = unwinds_to_state.uniq - primary_unwinds
+
+        allowed_possibility_sets = primary_unwinds.flat_map do |unwind|
+          states[unwind.state_index].possibilities.select do |possibility_set|
+            possibility_set.possibilities.any? do |poss|
+              possibility_satisfies_requirements?(poss, unwind.conflicting_requirements)
             end
-            r = parent_of(r)
           end
         end
 
-        index
+        requirements_to_avoid = parent_unwinds.flat_map(&:sub_dependencies_to_avoid)
+
+        state.possibilities.reject! do |possibility_set|
+          !allowed_possibility_sets.include?(possibility_set) &&
+            (requirements_to_avoid - possibility_set.dependencies).empty?
+        end
+      end
+
+      # @param [Conflict] conflict
+      # @return [Array] minimal array of requirements that would cause the passed
+      #    conflict to occur.
+      def binding_requirements_for_conflict(conflict)
+        return [conflict.requirement] if conflict.possibility.nil?
+
+        possible_binding_requirements = conflict.requirements.values.flatten(1).uniq
+
+        # When there's a `CircularDependency` error the conflicting requirement
+        # (the one causing the circular) won't be `conflict.requirement`
+        # (which won't be for the right state, because we won't have created it,
+        # because it's circular).
+        # We need to make sure we have that requirement in the conflict's list,
+        # otherwise we won't be able to unwind properly, so we just return all
+        # the requirements for the conflict.
+        return possible_binding_requirements if conflict.underlying_error
+
+        possibilities = search_for(conflict.requirement)
+
+        # If all the requirements together don't filter out all possibilities,
+        # then the only two requirements we need to consider are the initial one
+        # (where the dependency's version was first chosen) and the last
+        if binding_requirement_in_set?(nil, possible_binding_requirements, possibilities)
+          return [conflict.requirement, requirement_for_existing_name(name_for(conflict.requirement))].compact
+        end
+
+        # Loop through the possible binding requirements, removing each one
+        # that doesn't bind. Use a `reverse_each` as we want the earliest set of
+        # binding requirements, and don't use `reject!` as we wish to refine the
+        # array *on each iteration*.
+        binding_requirements = possible_binding_requirements.dup
+        possible_binding_requirements.reverse_each do |req|
+          next if req == conflict.requirement
+          unless binding_requirement_in_set?(req, binding_requirements, possibilities)
+            binding_requirements -= [req]
+          end
+        end
+
+        binding_requirements
       end
 
+      # @param [Object] requirement we wish to check
+      # @param [Array] possible_binding_requirements array of requirements
+      # @param [Array] possibilities array of possibilities the requirements will be used to filter
+      # @return [Boolean] whether or not the given requirement is required to filter
+      #    out all elements of the array of possibilities.
+      def binding_requirement_in_set?(requirement, possible_binding_requirements, possibilities)
+        possibilities.any? do |poss|
+          possibility_satisfies_requirements?(poss, possible_binding_requirements - [requirement])
+        end
+      end
+
+      # @param [Object] requirement
       # @return [Object] the requirement that led to `requirement` being added
       #   to the list of requirements.
       def parent_of(requirement)
@@ -219,29 +572,27 @@ module Gem::Resolver::Molinillo
         parent_state.requirement
       end
 
+      # @param [String] name
       # @return [Object] the requirement that led to a version of a possibility
       #   with the given name being activated.
       def requirement_for_existing_name(name)
-        return nil unless activated.vertex_named(name).payload
+        return nil unless vertex = activated.vertex_named(name)
+        return nil unless vertex.payload
         states.find { |s| s.name == name }.requirement
       end
 
+      # @param [Object] requirement
       # @return [ResolutionState] the state whose `requirement` is the given
       #   `requirement`.
       def find_state_for(requirement)
         return nil unless requirement
-        states.reverse_each.find { |i| requirement == i.requirement && i.is_a?(DependencyState) }
-      end
-
-      # @return [Boolean] whether or not the given state has any possibilities
-      #   left.
-      def state_any?(state)
-        state && state.possibilities.any?
+        states.find { |i| requirement == i.requirement }
       end
 
+      # @param [Object] underlying_error
       # @return [Conflict] a {Conflict} that reflects the failure to activate
       #   the {#possibility} in conjunction with the current {#state}
-      def create_conflict
+      def create_conflict(underlying_error = nil)
         vertex = activated.vertex_named(name)
         locked_requirement = locked_requirement_named(name)
 
@@ -250,18 +601,21 @@ module Gem::Resolver::Molinillo
           requirements[name_for_explicit_dependency_source] = vertex.explicit_requirements
         end
         requirements[name_for_locking_dependency_source] = [locked_requirement] if locked_requirement
-        vertex.incoming_edges.each { |edge| (requirements[edge.origin.payload] ||= []).unshift(edge.requirement) }
+        vertex.incoming_edges.each do |edge|
+          (requirements[edge.origin.payload.latest_version] ||= []).unshift(edge.requirement)
+        end
 
         activated_by_name = {}
-        activated.each { |v| activated_by_name[v.name] = v.payload if v.payload }
+        activated.each { |v| activated_by_name[v.name] = v.payload.latest_version if v.payload }
         conflicts[name] = Conflict.new(
           requirement,
           requirements,
-          vertex.payload,
+          vertex.payload && vertex.payload.latest_version,
           possibility,
           locked_requirement,
           requirement_trees,
-          activated_by_name
+          activated_by_name,
+          underlying_error
         )
       end
 
@@ -272,6 +626,7 @@ module Gem::Resolver::Molinillo
         vertex.requirements.map { |r| requirement_tree_for(r) }
       end
 
+      # @param [Object] requirement
       # @return [Array<Object>] the list of requirements that led to
       #   `requirement` being required.
       def requirement_tree_for(requirement)
@@ -311,116 +666,47 @@ module Gem::Resolver::Molinillo
       # @return [void]
       def attempt_to_activate
         debug(depth) { 'Attempting to activate ' + possibility.to_s }
-        existing_node = activated.vertex_named(name)
-        if existing_node.payload
-          debug(depth) { "Found existing spec (#{existing_node.payload})" }
-          attempt_to_activate_existing_spec(existing_node)
+        existing_vertex = activated.vertex_named(name)
+        if existing_vertex.payload
+          debug(depth) { "Found existing spec (#{existing_vertex.payload})" }
+          attempt_to_filter_existing_spec(existing_vertex)
         else
-          attempt_to_activate_new_spec
+          latest = possibility.latest_version
+          possibility.possibilities.select! do |possibility|
+            requirement_satisfied_by?(requirement, activated, possibility)
+          end
+          if possibility.latest_version.nil?
+            # ensure there's a possibility for better error messages
+            possibility.possibilities << latest if latest
+            create_conflict
+            unwind_for_conflict
+          else
+            activate_new_spec
+          end
         end
       end
 
-      # Attempts to activate the current {#possibility} (given that it has
-      # already been activated)
+      # Attempts to update the existing vertex's `PossibilitySet` with a filtered version
       # @return [void]
-      def attempt_to_activate_existing_spec(existing_node)
-        existing_spec = existing_node.payload
-        if requirement_satisfied_by?(requirement, activated, existing_spec)
+      def attempt_to_filter_existing_spec(vertex)
+        filtered_set = filtered_possibility_set(vertex)
+        if !filtered_set.possibilities.empty?
+          activated.set_payload(name, filtered_set)
           new_requirements = requirements.dup
           push_state_for_requirements(new_requirements, false)
         else
-          return if attempt_to_swap_possibility
-          create_conflict
-          debug(depth) { "Unsatisfied by existing spec (#{existing_node.payload})" }
-          unwind_for_conflict
-        end
-      end
-
-      # Attempts to swp the current {#possibility} with the already-activated
-      # spec with the given name
-      # @return [Boolean] Whether the possibility was swapped into {#activated}
-      def attempt_to_swap_possibility
-        activated.tag(:swap)
-        vertex = activated.vertex_named(name)
-        activated.set_payload(name, possibility)
-        if !vertex.requirements.
-           all? { |r| requirement_satisfied_by?(r, activated, possibility) } ||
-            !new_spec_satisfied?
-          activated.rewind_to(:swap)
-          return
-        end
-        fixup_swapped_children(vertex)
-        activate_spec
-      end
-
-      # Ensures there are no orphaned successors to the given {vertex}.
-      # @param [DependencyGraph::Vertex] vertex the vertex to fix up.
-      # @return [void]
-      def fixup_swapped_children(vertex) # rubocop:disable Metrics/CyclomaticComplexity
-        payload = vertex.payload
-        deps = dependencies_for(payload).group_by(&method(:name_for))
-        vertex.outgoing_edges.each do |outgoing_edge|
-          requirement = outgoing_edge.requirement
-          parent_index = @parents_of[requirement].last
-          succ = outgoing_edge.destination
-          matching_deps = Array(deps[succ.name])
-          dep_matched = matching_deps.include?(requirement)
-
-          # only push the current index when it was originally required by the
-          # same named spec
-          if parent_index && states[parent_index].name == name
-            @parents_of[requirement].push(states.size - 1)
-          end
-
-          if matching_deps.empty? && !succ.root? && succ.predecessors.to_a == [vertex]
-            debug(depth) { "Removing orphaned spec #{succ.name} after swapping #{name}" }
-            succ.requirements.each { |r| @parents_of.delete(r) }
-
-            removed_names = activated.detach_vertex_named(succ.name).map(&:name)
-            requirements.delete_if do |r|
-              # the only removed vertices are those with no other requirements,
-              # so it's safe to delete only based upon name here
-              removed_names.include?(name_for(r))
-            end
-          elsif !dep_matched
-            debug(depth) { "Removing orphaned dependency #{requirement} after swapping #{name}" }
-            # also reset if we're removing the edge, but only if its parent has
-            # already been fixed up
-            @parents_of[requirement].push(states.size - 1) if @parents_of[requirement].empty?
-
-            activated.delete_edge(outgoing_edge)
-            requirements.delete(requirement)
-          end
-        end
-      end
-
-      # Attempts to activate the current {#possibility} (given that it hasn't
-      # already been activated)
-      # @return [void]
-      def attempt_to_activate_new_spec
-        if new_spec_satisfied?
-          activate_spec
-        else
           create_conflict
+          debug(depth) { "Unsatisfied by existing spec (#{vertex.payload})" }
           unwind_for_conflict
         end
       end
 
-      # @return [Boolean] whether the current spec is satisfied as a new
-      # possibility.
-      def new_spec_satisfied?
-        unless requirement_satisfied_by?(requirement, activated, possibility)
-          debug(depth) { 'Unsatisfied by requested spec' }
-          return false
-        end
-
-        locked_requirement = locked_requirement_named(name)
-
-        locked_spec_satisfied = !locked_requirement ||
-          requirement_satisfied_by?(locked_requirement, activated, possibility)
-        debug(depth) { 'Unsatisfied by locked spec' } unless locked_spec_satisfied
-
-        locked_spec_satisfied
+      # Generates a filtered version of the existing vertex's `PossibilitySet` using the
+      # current state's `requirement`
+      # @param [Object] vertex existing vertex
+      # @return [PossibilitySet] filtered possibility set
+      def filtered_possibility_set(vertex)
+        PossibilitySet.new(vertex.payload.dependencies, vertex.payload.possibilities & possibility.possibilities)
       end
 
       # @param [String] requirement_name the spec name to search for
@@ -434,7 +720,7 @@ module Gem::Resolver::Molinillo
       # Add the current {#possibility} to the dependency graph of the current
       # {#state}
       # @return [void]
-      def activate_spec
+      def activate_new_spec
         conflicts.delete(name)
         debug(depth) { "Activated #{name} at #{possibility}" }
         activated.set_payload(name, possibility)
@@ -442,14 +728,14 @@ module Gem::Resolver::Molinillo
       end
 
       # Requires the dependencies that the recently activated spec has
-      # @param [Object] activated_spec the specification that has just been
+      # @param [Object] possibility_set the PossibilitySet that has just been
       #   activated
       # @return [void]
-      def require_nested_dependencies_for(activated_spec)
-        nested_dependencies = dependencies_for(activated_spec)
+      def require_nested_dependencies_for(possibility_set)
+        nested_dependencies = dependencies_for(possibility_set.latest_version)
         debug(depth) { "Requiring nested dependencies (#{nested_dependencies.join(', ')})" }
         nested_dependencies.each do |d|
-          activated.add_child_vertex(name_for(d), nil, [name_for(activated_spec)], d)
+          activated.add_child_vertex(name_for(d), nil, [name_for(possibility_set.latest_version)], d)
           parent_index = states.size - 1
           parents = @parents_of[d]
           parents << parent_index if parents.empty?
@@ -461,23 +747,82 @@ module Gem::Resolver::Molinillo
       # Pushes a new {DependencyState} that encapsulates both existing and new
       # requirements
       # @param [Array] new_requirements
+      # @param [Boolean] requires_sort
+      # @param [Object] new_activated
       # @return [void]
       def push_state_for_requirements(new_requirements, requires_sort = true, new_activated = activated)
         new_requirements = sort_dependencies(new_requirements.uniq, new_activated, conflicts) if requires_sort
-        new_requirement = new_requirements.shift
+        new_requirement = nil
+        loop do
+          new_requirement = new_requirements.shift
+          break if new_requirement.nil? || states.none? { |s| s.requirement == new_requirement }
+        end
         new_name = new_requirement ? name_for(new_requirement) : ''.freeze
-        possibilities = new_requirement ? search_for(new_requirement) : []
+        possibilities = possibilities_for_requirement(new_requirement)
         handle_missing_or_push_dependency_state DependencyState.new(
           new_name, new_requirements, new_activated,
-          new_requirement, possibilities, depth, conflicts.dup
+          new_requirement, possibilities, depth, conflicts.dup, unused_unwind_options.dup
         )
       end
 
+      # Checks a proposed requirement with any existing locked requirement
+      # before generating an array of possibilities for it.
+      # @param [Object] requirement the proposed requirement
+      # @param [Object] activated
+      # @return [Array] possibilities
+      def possibilities_for_requirement(requirement, activated = self.activated)
+        return [] unless requirement
+        if locked_requirement_named(name_for(requirement))
+          return locked_requirement_possibility_set(requirement, activated)
+        end
+
+        group_possibilities(search_for(requirement))
+      end
+
+      # @param [Object] requirement the proposed requirement
+      # @param [Object] activated
+      # @return [Array] possibility set containing only the locked requirement, if any
+      def locked_requirement_possibility_set(requirement, activated = self.activated)
+        all_possibilities = search_for(requirement)
+        locked_requirement = locked_requirement_named(name_for(requirement))
+
+        # Longwinded way to build a possibilities array with either the locked
+        # requirement or nothing in it. Required, since the API for
+        # locked_requirement isn't guaranteed.
+        locked_possibilities = all_possibilities.select do |possibility|
+          requirement_satisfied_by?(locked_requirement, activated, possibility)
+        end
+
+        group_possibilities(locked_possibilities)
+      end
+
+      # Build an array of PossibilitySets, with each element representing a group of
+      # dependency versions that all have the same sub-dependency version constraints
+      # and are contiguous.
+      # @param [Array] possibilities an array of possibilities
+      # @return [Array<PossibilitySet>] an array of possibility sets
+      def group_possibilities(possibilities)
+        possibility_sets = []
+        current_possibility_set = nil
+
+        possibilities.reverse_each do |possibility|
+          dependencies = dependencies_for(possibility)
+          if current_possibility_set && dependencies_equal?(current_possibility_set.dependencies, dependencies)
+            current_possibility_set.possibilities.unshift(possibility)
+          else
+            possibility_sets.unshift(PossibilitySet.new(dependencies, [possibility]))
+            current_possibility_set = possibility_sets.first
+          end
+        end
+
+        possibility_sets
+      end
+
       # Pushes a new {DependencyState}.
       # If the {#specification_provider} says to
       # {SpecificationProvider#allow_missing?} that particular requirement, and
       # there are no possibilities for that requirement, then `state` is not
-      # pushed, and the node in {#activated} is removed, and we continue
+      # pushed, and the vertex in {#activated} is removed, and we continue
       # resolving the remaining requirements.
       # @param [DependencyState] state
       # @return [void]
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/resolver.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/resolver.rb
@@ -1,5 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/resolver/molinillo/lib/molinillo/dependency_graph'
+
+require_relative 'dependency_graph'
 
 module Gem::Resolver::Molinillo
   # This class encapsulates a dependency resolver.
@@ -8,7 +9,7 @@ module Gem::Resolver::Molinillo
   #
   #
   class Resolver
-    require 'rubygems/resolver/molinillo/lib/molinillo/resolution'
+    require_relative 'resolution'
 
     # @return [SpecificationProvider] the specification provider used
     #   in the resolution process
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/molinillo/lib/molinillo/state.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/molinillo/lib/molinillo/state.rb
@@ -1,4 +1,5 @@
 # frozen_string_literal: true
+
 module Gem::Resolver::Molinillo
   # A state that a {Resolution} can be in
   # @attr [String] name the name of the current requirement
@@ -7,7 +8,8 @@ module Gem::Resolver::Molinillo
   # @attr [Object] requirement the current requirement
   # @attr [Object] possibilities the possibilities to satisfy the current requirement
   # @attr [Integer] depth the depth of the resolution
-  # @attr [Set<Object>] conflicts unresolved conflicts
+  # @attr [Hash] conflicts unresolved conflicts, indexed by dependency name
+  # @attr [Array<UnwindDetails>] unused_unwind_options unwinds for previous conflicts that weren't explored
   ResolutionState = Struct.new(
     :name,
     :requirements,
@@ -15,14 +17,15 @@ module Gem::Resolver::Molinillo
     :requirement,
     :possibilities,
     :depth,
-    :conflicts
+    :conflicts,
+    :unused_unwind_options
   )
 
   class ResolutionState
     # Returns an empty resolution state
     # @return [ResolutionState] an empty state
     def self.empty
-      new(nil, [], DependencyGraph.new, nil, nil, 0, Set.new)
+      new(nil, [], DependencyGraph.new, nil, nil, 0, {}, [])
     end
   end
 
@@ -40,7 +43,8 @@ module Gem::Resolver::Molinillo
         requirement,
         [possibilities.pop],
         depth + 1,
-        conflicts.dup
+        conflicts.dup,
+        unused_unwind_options.dup
       ).tap do |state|
         state.activated.tag(state)
       end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/requirement_list.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/requirement_list.rb
@@ -7,7 +7,6 @@
 # first.
 
 class Gem::Resolver::RequirementList
-
   include Enumerable
 
   ##
@@ -79,5 +78,4 @@ class Gem::Resolver::RequirementList
     x = @exact[0,5]
     x + @list[0,5 - x.size]
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/set.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/set.rb
@@ -4,7 +4,6 @@
 # dependencies) used in resolution.  This set is abstract.
 
 class Gem::Resolver::Set
-
   ##
   # Set to true to disable network access for this set
 
@@ -21,7 +20,6 @@ class Gem::Resolver::Set
   attr_accessor :prerelease
 
   def initialize # :nodoc:
-    require 'uri'
     @prerelease = false
     @remote     = true
     @errors     = []
@@ -53,5 +51,4 @@ class Gem::Resolver::Set
   def remote? # :nodoc:
     @remote
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/source_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/source_set.rb
@@ -4,7 +4,6 @@
 # Kind off like BestSet but filters the sources for gems
 
 class Gem::Resolver::SourceSet < Gem::Resolver::Set
-
   ##
   # Creates a SourceSet for the given +sources+ or Gem::sources if none are
   # specified.  +sources+ must be a Gem::SourceList.
@@ -43,5 +42,4 @@ class Gem::Resolver::SourceSet < Gem::Re
     link = @links[name]
     @sets[link] ||= Gem::Source.new(link).dependency_resolver_set if link
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/spec_specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/spec_specification.rb
@@ -4,7 +4,6 @@
 # Resolver specifications that are backed by a Gem::Specification.
 
 class Gem::Resolver::SpecSpecification < Gem::Resolver::Specification
-
   ##
   # A SpecSpecification is created for a +set+ for a Gem::Specification in
   # +spec+.  The +source+ is either where the +spec+ came from, or should be
@@ -24,6 +23,20 @@ class Gem::Resolver::SpecSpecification <
   end
 
   ##
+  # The required_ruby_version constraint for this specification
+
+  def required_ruby_version
+    spec.required_ruby_version
+  end
+
+  ##
+  # The required_rubygems_version constraint for this specification
+
+  def required_rubygems_version
+    spec.required_rubygems_version
+  end
+
+  ##
   # The name and version of the specification.
   #
   # Unlike Gem::Specification#full_name, the platform is not included.
@@ -52,5 +65,4 @@ class Gem::Resolver::SpecSpecification <
   def version
     spec.version
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/specification.rb
@@ -5,7 +5,6 @@
 # dependency resolution in the resolver is included.
 
 class Gem::Resolver::Specification
-
   ##
   # The dependencies of the gem for this specification
 
@@ -45,6 +44,16 @@ class Gem::Resolver::Specification
   attr_reader :version
 
   ##
+  # The required_ruby_version constraint for this specification.
+
+  attr_reader :required_ruby_version
+
+  ##
+  # The required_ruby_version constraint for this specification.
+
+  attr_reader :required_rubygems_version
+
+  ##
   # Sets default instance variables for the specification.
 
   def initialize
@@ -54,6 +63,8 @@ class Gem::Resolver::Specification
     @set          = nil
     @source       = nil
     @version      = nil
+    @required_ruby_version = Gem::Requirement.default
+    @required_rubygems_version = Gem::Requirement.default
   end
 
   ##
@@ -82,7 +93,7 @@ class Gem::Resolver::Specification
   # specification.
 
   def install(options = {})
-    require 'rubygems/installer'
+    require_relative "../installer"
 
     gem = download options
 
@@ -105,11 +116,10 @@ class Gem::Resolver::Specification
   # Returns true if this specification is installable on this platform.
 
   def installable_platform?
-    Gem::Platform.match spec.platform
+    Gem::Platform.match_spec? spec
   end
 
   def local? # :nodoc:
     false
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/stats.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/stats.rb
@@ -1,6 +1,5 @@
 # frozen_string_literal: true
 class Gem::Resolver::Stats
-
   def initialize
     @max_depth = 0
     @max_requirements = 0
@@ -43,5 +42,4 @@ class Gem::Resolver::Stats
     $stdout.printf PATTERN, "Backtracking #", @backtracking
     $stdout.printf PATTERN, "Iteration #", @iterations
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/vendor_set.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/vendor_set.rb
@@ -15,7 +15,6 @@
 # rake.gemspec (watching the given name).
 
 class Gem::Resolver::VendorSet < Gem::Resolver::Set
-
   ##
   # The specifications for this set.
 
@@ -70,7 +69,7 @@ class Gem::Resolver::VendorSet < Gem::Re
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[VendorSet', ']' do
+    q.group 2, "[VendorSet", "]" do
       next if @directories.empty?
       q.breakable
 
@@ -83,5 +82,4 @@ class Gem::Resolver::VendorSet < Gem::Re
       end
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/resolver/vendor_specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/resolver/vendor_specification.rb
@@ -5,11 +5,10 @@
 # option.
 
 class Gem::Resolver::VendorSpecification < Gem::Resolver::SpecSpecification
-
   def ==(other) # :nodoc:
-    self.class === other and
-      @set  == other.set and
-      @spec == other.spec and
+    self.class === other &&
+      @set  == other.set &&
+      @spec == other.spec &&
       @source == other.source
   end
 
@@ -20,5 +19,4 @@ class Gem::Resolver::VendorSpecification
   def install(options = {})
     yield nil
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/s3_uri_signer.rb
+++ ruby2.7-2.7.6/lib/rubygems/s3_uri_signer.rb
@@ -1,14 +1,10 @@
-require 'base64'
-require 'digest'
-require 'openssl'
+require_relative "openssl"
 
 ##
 # S3URISigner implements AWS SigV4 for S3 Source to avoid a dependency on the aws-sdk-* gems
 # More on AWS SigV4: https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html
 class Gem::S3URISigner
-
   class ConfigurationError < Gem::Exception
-
     def initialize(message)
       super message
     end
@@ -16,11 +12,9 @@ class Gem::S3URISigner
     def to_s # :nodoc:
       "#{super}"
     end
-
   end
 
   class InstanceProfileError < Gem::Exception
-
     def initialize(message)
       super message
     end
@@ -28,7 +22,6 @@ class Gem::S3URISigner
     def to_s # :nodoc:
       "#{super}"
     end
-
   end
 
   attr_accessor :uri
@@ -93,7 +86,7 @@ class Gem::S3URISigner
       "AWS4-HMAC-SHA256",
       date_time,
       credential_info,
-      Digest::SHA256.hexdigest(canonical_request)
+      OpenSSL::Digest::SHA256.hexdigest(canonical_request),
     ].join("\n")
   end
 
@@ -145,14 +138,14 @@ class Gem::S3URISigner
   end
 
   def ec2_metadata_credentials_json
-    require 'net/http'
-    require 'rubygems/request'
-    require 'rubygems/request/connection_pools'
-    require 'json'
+    require "net/http"
+    require_relative "request"
+    require_relative "request/connection_pools"
+    require "json"
 
     iam_info = ec2_metadata_request(EC2_IAM_INFO)
     # Expected format: arn:aws:iam::<id>:instance-profile/<role_name>
-    role_name = iam_info['InstanceProfileArn'].split('/').last
+    role_name = iam_info["InstanceProfileArn"].split("/").last
     ec2_metadata_request(EC2_IAM_SECURITY_CREDENTIALS + role_name)
   end
 
@@ -179,5 +172,4 @@ class Gem::S3URISigner
   BASE64_URI_TRANSLATE = { "+" => "%2B", "/" => "%2F", "=" => "%3D", "\n" => "" }.freeze
   EC2_IAM_INFO = "http://169.254.169.254/latest/meta-data/iam/info".freeze
   EC2_IAM_SECURITY_CREDENTIALS = "http://169.254.169.254/latest/meta-data/iam/security-credentials/".freeze
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/safe_yaml.rb
+++ ruby2.7-2.7.6/lib/rubygems/safe_yaml.rb
@@ -7,7 +7,7 @@ module Gem
   # Psych.safe_load
 
   module SafeYAML
-    PERMITTED_CLASSES = %w(
+    PERMITTED_CLASSES = %w[
       Symbol
       Time
       Date
@@ -17,42 +17,40 @@ module Gem
       Gem::Specification
       Gem::Version
       Gem::Version::Requirement
-      YAML::Syck::DefaultKey
-      Syck::DefaultKey
-    ).freeze
+    ].freeze
 
-    PERMITTED_SYMBOLS = %w(
+    PERMITTED_SYMBOLS = %w[
       development
       runtime
-    ).freeze
+    ].freeze
 
-    if ::YAML.respond_to? :safe_load
+    if ::Psych.respond_to? :safe_load
       def self.safe_load(input)
-        if Gem::Version.new(Psych::VERSION) >= Gem::Version.new('3.1.0.pre1')
-          ::YAML.safe_load(input, permitted_classes: PERMITTED_CLASSES, permitted_symbols: PERMITTED_SYMBOLS, aliases: true)
+        if Gem::Version.new(Psych::VERSION) >= Gem::Version.new("3.1.0.pre1")
+          ::Psych.safe_load(input, permitted_classes: PERMITTED_CLASSES, permitted_symbols: PERMITTED_SYMBOLS, aliases: true)
         else
-          ::YAML.safe_load(input, PERMITTED_CLASSES, PERMITTED_SYMBOLS, true)
+          ::Psych.safe_load(input, PERMITTED_CLASSES, PERMITTED_SYMBOLS, true)
         end
       end
 
       def self.load(input)
-        if Gem::Version.new(Psych::VERSION) >= Gem::Version.new('3.1.0.pre1')
-          ::YAML.safe_load(input, permitted_classes: [::Symbol])
+        if Gem::Version.new(Psych::VERSION) >= Gem::Version.new("3.1.0.pre1")
+          ::Psych.safe_load(input, permitted_classes: [::Symbol])
         else
-          ::YAML.safe_load(input, [::Symbol])
+          ::Psych.safe_load(input, [::Symbol])
         end
       end
     else
       unless Gem::Deprecate.skip
-        warn "YAML safe loading is not available. Please upgrade psych to a version that supports safe loading (>= 2.0)."
+        warn "Psych safe loading is not available. Please upgrade psych to a version that supports safe loading (>= 2.0)."
       end
 
       def self.safe_load(input, *args)
-        ::YAML.load input
+        ::Psych.load input
       end
 
       def self.load(input)
-        ::YAML.load input
+        ::Psych.load input
       end
     end
   end
--- ruby2.7-2.7.6.orig/lib/rubygems/security.rb
+++ ruby2.7-2.7.6/lib/rubygems/security.rb
@@ -5,15 +5,8 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/exceptions'
-require 'fileutils'
-
-begin
-  require 'openssl'
-rescue LoadError => e
-  raise unless (e.respond_to?(:path) && e.path == 'openssl') ||
-               e.message =~ / -- openssl$/
-end
+require_relative "exceptions"
+require_relative "openssl"
 
 ##
 # = Signing gems
@@ -62,11 +55,11 @@ end
 #
 #   $ tar tf your-gem-1.0.gem
 #   metadata.gz
-#   metadata.gz.sum
 #   metadata.gz.sig # metadata signature
 #   data.tar.gz
-#   data.tar.gz.sum
 #   data.tar.gz.sig # data signature
+#   checksums.yaml.gz
+#   checksums.yaml.gz.sig # checksums signature
 #
 # === Manually signing gems
 #
@@ -159,8 +152,11 @@ end
 #                                      certificate for EMAIL_ADDR
 #     -C, --certificate CERT           Signing certificate for --sign
 #     -K, --private-key KEY            Key for --sign or --build
+#     -A, --key-algorithm ALGORITHM    Select key algorithm for --build from RSA, DSA, or EC. Defaults to RSA.
 #     -s, --sign CERT                  Signs CERT with the key from -K
 #                                      and the certificate from -C
+#     -d, --days NUMBER_OF_DAYS        Days before the certificate expires
+#     -R, --re-sign                    Re-signs the certificate from -C with the key from -K
 #
 # We've already covered the <code>--build</code> option, and the
 # <code>--add</code>, <code>--list</code>, and <code>--remove</code> commands
@@ -265,7 +261,7 @@ end
 # 2. Grab the public key from the gemspec
 #
 #      gem spec some_signed_gem-1.0.gem cert_chain | \
-#        ruby -ryaml -e 'puts YAML.load_documents($stdin)' > public_key.crt
+#        ruby -rpsych -e 'puts Psych.load($stdin)' > public_key.crt
 #
 # 3. Generate a SHA1 hash of the data.tar.gz
 #
@@ -322,7 +318,6 @@ end
 # * Honor extension restrictions
 # * Might be better to store the certificate chain as a PKCS#7 or PKCS#12
 #   file, instead of an array embedded in the metadata.
-# * Flexible signature and key algorithms, not hard-coded to RSA and SHA1.
 #
 # == Original author
 #
@@ -337,46 +332,30 @@ module Gem::Security
   class Exception < Gem::Exception; end
 
   ##
-  # Digest algorithm used to sign gems
+  # Used internally to select the signing digest from all computed digests
 
-  DIGEST_ALGORITHM =
-    if defined?(OpenSSL::Digest::SHA256)
-      OpenSSL::Digest::SHA256
-    elsif defined?(OpenSSL::Digest::SHA1)
-      OpenSSL::Digest::SHA1
-    else
-      require 'digest'
-      Digest::SHA512
-    end
+  DIGEST_NAME = "SHA256" # :nodoc:
 
   ##
-  # Used internally to select the signing digest from all computed digests
+  # Length of keys created by RSA and DSA keys
 
-  DIGEST_NAME = # :nodoc:
-    if DIGEST_ALGORITHM.method_defined? :name
-      DIGEST_ALGORITHM.new.name
-    else
-      DIGEST_ALGORITHM.name[/::([^:]+)\z/, 1]
-    end
+  RSA_DSA_KEY_LENGTH = 3072
 
   ##
-  # Algorithm for creating the key pair used to sign gems
+  # Default algorithm to use when building a key pair
 
-  KEY_ALGORITHM =
-    if defined?(OpenSSL::PKey::RSA)
-      OpenSSL::PKey::RSA
-    end
+  DEFAULT_KEY_ALGORITHM = "RSA"
 
   ##
-  # Length of keys created by KEY_ALGORITHM
+  # Named curve used for Elliptic Curve
 
-  KEY_LENGTH = 3072
+  EC_NAME = "secp384r1"
 
   ##
   # Cipher used to encrypt the key pair used to sign gems.
   # Must be in the list returned by OpenSSL::Cipher.ciphers
 
-  KEY_CIPHER = OpenSSL::Cipher.new('AES-256-CBC') if defined?(OpenSSL::Cipher)
+  KEY_CIPHER = OpenSSL::Cipher.new("AES-256-CBC") if defined?(OpenSSL::Cipher)
 
   ##
   # One day in seconds
@@ -397,10 +376,10 @@ module Gem::Security
   # * The certificate contains a subject key identifier
 
   EXTENSIONS = {
-    'basicConstraints'     => 'CA:FALSE',
-    'keyUsage'             =>
-      'keyEncipherment,dataEncipherment,digitalSignature',
-    'subjectKeyIdentifier' => 'hash',
+    "basicConstraints"     => "CA:FALSE",
+    "keyUsage"             =>
+      "keyEncipherment,dataEncipherment,digitalSignature",
+    "subjectKeyIdentifier" => "hash",
   }.freeze
 
   def self.alt_name_or_x509_entry(certificate, x509_entry)
@@ -423,7 +402,7 @@ module Gem::Security
                        serial = 1)
     cert = OpenSSL::X509::Certificate.new
 
-    cert.public_key = key.public_key
+    cert.public_key = get_public_key(key)
     cert.version    = 2
     cert.serial     = serial
 
@@ -442,6 +421,26 @@ module Gem::Security
   end
 
   ##
+  # Gets the right public key from a PKey instance
+
+  def self.get_public_key(key)
+    # Ruby 3.0 (Ruby/OpenSSL 2.2) or later
+    return OpenSSL::PKey.read(key.public_to_der) if key.respond_to?(:public_to_der)
+    return key.public_key unless key.is_a?(OpenSSL::PKey::EC)
+
+    ec_key = OpenSSL::PKey::EC.new(key.group.curve_name)
+    ec_key.public_key = key.public_key
+    ec_key
+  end
+
+  ##
+  # In Ruby 2.3 EC doesn't implement the private_key? but not the private? method
+
+  if defined?(OpenSSL::PKey::EC) && Gem::Version.new(String.new(RUBY_VERSION)) < Gem::Version.new("2.4.0")
+    OpenSSL::PKey::EC.send(:alias_method, :private?, :private_key?)
+  end
+
+  ##
   # Creates a self-signed certificate with an issuer and subject from +email+,
   # a subject alternative name of +email+ and the given +extensions+ for the
   # +key+.
@@ -466,26 +465,61 @@ module Gem::Security
   end
 
   ##
-  # Creates a new key pair of the specified +length+ and +algorithm+.  The
-  # default is a 3072 bit RSA key.
+  # Creates a new digest instance using the specified +algorithm+. The default
+  # is SHA256.
+
+  if defined?(OpenSSL::Digest)
+    def self.create_digest(algorithm = DIGEST_NAME)
+      OpenSSL::Digest.new(algorithm)
+    end
+  else
+    require "digest"
 
-  def self.create_key(length = KEY_LENGTH, algorithm = KEY_ALGORITHM)
-    algorithm.new length
+    def self.create_digest(algorithm = DIGEST_NAME)
+      Digest.const_get(algorithm).new
+    end
+  end
+
+  ##
+  # Creates a new key pair of the specified +algorithm+. RSA, DSA, and EC
+  # are supported.
+
+  def self.create_key(algorithm)
+    if defined?(OpenSSL::PKey)
+      case algorithm.downcase
+      when "dsa"
+        OpenSSL::PKey::DSA.new(RSA_DSA_KEY_LENGTH)
+      when "rsa"
+        OpenSSL::PKey::RSA.new(RSA_DSA_KEY_LENGTH)
+      when "ec"
+        if RUBY_VERSION >= "2.4.0"
+          OpenSSL::PKey::EC.generate(EC_NAME)
+        else
+          domain_key = OpenSSL::PKey::EC.new(EC_NAME)
+          domain_key.generate_key
+          domain_key
+        end
+      else
+        raise Gem::Security::Exception,
+        "#{algorithm} algorithm not found. RSA, DSA, and EC algorithms are supported."
+      end
+    end
   end
 
   ##
   # Turns +email_address+ into an OpenSSL::X509::Name
 
   def self.email_to_name(email_address)
-    email_address = email_address.gsub(/[^\w@.-]+/i, '_')
-
-    cn, dcs = email_address.split '@'
+    email_address = email_address.gsub(/[^\w@.-]+/i, "_")
 
-    dcs = dcs.split '.'
+    cn, dcs = email_address.split "@"
 
-    name = "CN=#{cn}/#{dcs.map { |dc| "DC=#{dc}" }.join '/'}"
+    dcs = dcs.split "."
 
-    OpenSSL::X509::Name.parse name
+    OpenSSL::X509::Name.new([
+      ["CN", cn],
+      *dcs.map {|dc| ["DC", dc] },
+    ])
   end
 
   ##
@@ -499,7 +533,7 @@ module Gem::Security
     raise Gem::Security::Exception,
           "incorrect signing key for re-signing " +
           "#{expired_certificate.subject}" unless
-      expired_certificate.public_key.to_pem == private_key.public_key.to_pem
+      expired_certificate.check_private_key(private_key)
 
     unless expired_certificate.subject.to_s ==
            expired_certificate.issuer.to_s
@@ -526,7 +560,7 @@ module Gem::Security
 
   ##
   # Sign the public key from +certificate+ with the +signing_key+ and
-  # +signing_cert+, using the Gem::Security::DIGEST_ALGORITHM.  Uses the
+  # +signing_cert+, using the Gem::Security::DIGEST_NAME.  Uses the
   # default certificate validity range and extensions.
   #
   # Returns the newly signed certificate.
@@ -537,23 +571,23 @@ module Gem::Security
     signee_key     = certificate.public_key
 
     alt_name = certificate.extensions.find do |extension|
-      extension.oid == 'subjectAltName'
+      extension.oid == "subjectAltName"
     end
 
-    extensions = extensions.merge 'subjectAltName' => alt_name.value if
+    extensions = extensions.merge "subjectAltName" => alt_name.value if
       alt_name
 
     issuer_alt_name = signing_cert.extensions.find do |extension|
-      extension.oid == 'subjectAltName'
+      extension.oid == "subjectAltName"
     end
 
-    extensions = extensions.merge 'issuerAltName' => issuer_alt_name.value if
+    extensions = extensions.merge "issuerAltName" => issuer_alt_name.value if
       issuer_alt_name
 
     signed = create_cert signee_subject, signee_key, age, extensions, serial
     signed.issuer = signing_cert.subject
 
-    signed.sign signing_key, Gem::Security::DIGEST_ALGORITHM.new
+    signed.sign signing_key, Gem::Security::DIGEST_NAME
   end
 
   ##
@@ -563,7 +597,7 @@ module Gem::Security
   def self.trust_dir
     return @trust_dir if @trust_dir
 
-    dir = File.join Gem.user_home, '.gem', 'trust'
+    dir = File.join Gem.user_home, ".gem", "trust"
 
     @trust_dir ||= Gem::Security::TrustDir.new dir
   end
@@ -583,8 +617,8 @@ module Gem::Security
   def self.write(pemmable, path, permissions = 0600, passphrase = nil, cipher = KEY_CIPHER)
     path = File.expand_path path
 
-    File.open path, 'wb', permissions do |io|
-      if passphrase and cipher
+    File.open path, "wb", permissions do |io|
+      if passphrase && cipher
         io.write pemmable.to_pem cipher, passphrase
       else
         io.write pemmable.to_pem
@@ -598,10 +632,10 @@ module Gem::Security
 
 end
 
-if defined?(OpenSSL::SSL)
-  require 'rubygems/security/policy'
-  require 'rubygems/security/policies'
-  require 'rubygems/security/trust_dir'
+if Gem::HAVE_OPENSSL
+  require_relative "security/policy"
+  require_relative "security/policies"
+  require_relative "security/trust_dir"
 end
 
-require 'rubygems/security/signer'
+require_relative "security/signer"
--- ruby2.7-2.7.6.orig/lib/rubygems/security/policies.rb
+++ ruby2.7-2.7.6/lib/rubygems/security/policies.rb
@@ -5,7 +5,7 @@ module Gem::Security
   # No security policy: all package signature checks are disabled.
 
   NoSecurity = Policy.new(
-    'No Security',
+    "No Security",
     :verify_data      => false,
     :verify_signer    => false,
     :verify_chain     => false,
@@ -23,7 +23,7 @@ module Gem::Security
   # easily spoofed, and is not recommended.
 
   AlmostNoSecurity = Policy.new(
-    'Almost No Security',
+    "Almost No Security",
     :verify_data      => true,
     :verify_signer    => false,
     :verify_chain     => false,
@@ -40,7 +40,7 @@ module Gem::Security
   # is not recommended.
 
   LowSecurity = Policy.new(
-    'Low Security',
+    "Low Security",
     :verify_data      => true,
     :verify_signer    => true,
     :verify_chain     => false,
@@ -59,7 +59,7 @@ module Gem::Security
   # gem off as unsigned.
 
   MediumSecurity = Policy.new(
-    'Medium Security',
+    "Medium Security",
     :verify_data      => true,
     :verify_signer    => true,
     :verify_chain     => true,
@@ -78,7 +78,7 @@ module Gem::Security
   # a reasonable guarantee that the contents of the gem have not been altered.
 
   HighSecurity = Policy.new(
-    'High Security',
+    "High Security",
     :verify_data      => true,
     :verify_signer    => true,
     :verify_chain     => true,
@@ -91,7 +91,7 @@ module Gem::Security
   # Policy used to verify a certificate and key when signing a gem
 
   SigningPolicy = Policy.new(
-    'Signing Policy',
+    "Signing Policy",
     :verify_data      => false,
     :verify_signer    => true,
     :verify_chain     => true,
@@ -104,11 +104,11 @@ module Gem::Security
   # Hash of configured security policies
 
   Policies = {
-    'NoSecurity'       => NoSecurity,
-    'AlmostNoSecurity' => AlmostNoSecurity,
-    'LowSecurity'      => LowSecurity,
-    'MediumSecurity'   => MediumSecurity,
-    'HighSecurity'     => HighSecurity,
+    "NoSecurity"       => NoSecurity,
+    "AlmostNoSecurity" => AlmostNoSecurity,
+    "LowSecurity"      => LowSecurity,
+    "MediumSecurity"   => MediumSecurity,
+    "HighSecurity"     => HighSecurity,
     # SigningPolicy is not intended for use by `gem -P` so do not list it
   }.freeze
 
--- ruby2.7-2.7.6.orig/lib/rubygems/security/policy.rb
+++ ruby2.7-2.7.6/lib/rubygems/security/policy.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/user_interaction'
+require_relative "../user_interaction"
 
 ##
 # A Gem::Security::Policy object encapsulates the settings for verifying
@@ -8,7 +8,6 @@ require 'rubygems/user_interaction'
 # Gem::Security::Policies.
 
 class Gem::Security::Policy
-
   include Gem::UserInteraction
 
   attr_reader :name
@@ -25,8 +24,6 @@ class Gem::Security::Policy
   # options.
 
   def initialize(name, policy = {}, opt = {})
-    require 'openssl'
-
     @name = name
 
     @opt = opt
@@ -56,8 +53,8 @@ class Gem::Security::Policy
   # and is valid for the given +time+.
 
   def check_chain(chain, time)
-    raise Gem::Security::Exception, 'missing signing chain' unless chain
-    raise Gem::Security::Exception, 'empty signing chain' if chain.empty?
+    raise Gem::Security::Exception, "missing signing chain" unless chain
+    raise Gem::Security::Exception, "empty signing chain" if chain.empty?
 
     begin
       chain.each_cons 2 do |issuer, cert|
@@ -76,7 +73,7 @@ class Gem::Security::Policy
 
   def check_data(public_key, digest, signature, data)
     raise Gem::Security::Exception, "invalid signature" unless
-      public_key.verify digest.new, signature, data.digest
+      public_key.verify digest, signature, data.digest
 
     true
   end
@@ -86,21 +83,21 @@ class Gem::Security::Policy
   # If the +issuer+ is +nil+ no verification is performed.
 
   def check_cert(signer, issuer, time)
-    raise Gem::Security::Exception, 'missing signing certificate' unless
+    raise Gem::Security::Exception, "missing signing certificate" unless
       signer
 
     message = "certificate #{signer.subject}"
 
-    if not_before = signer.not_before and not_before > time
+    if (not_before = signer.not_before) && not_before > time
       raise Gem::Security::Exception,
             "#{message} not valid before #{not_before}"
     end
 
-    if not_after = signer.not_after and not_after < time
+    if (not_after = signer.not_after) && not_after < time
       raise Gem::Security::Exception, "#{message} not valid after #{not_after}"
     end
 
-    if issuer and not signer.verify issuer.public_key
+    if issuer && !signer.verify(issuer.public_key)
       raise Gem::Security::Exception,
             "#{message} was not issued by #{issuer.subject}"
     end
@@ -112,15 +109,15 @@ class Gem::Security::Policy
   # Ensures the public key of +key+ matches the public key in +signer+
 
   def check_key(signer, key)
-    unless signer and key
+    unless signer && key
       return true unless @only_signed
 
-      raise Gem::Security::Exception, 'missing key or signature'
+      raise Gem::Security::Exception, "missing key or signature"
     end
 
     raise Gem::Security::Exception,
       "certificate #{signer.subject} does not match the signing key" unless
-        signer.public_key.to_pem == key.public_key.to_pem
+        signer.check_private_key(key)
 
     true
   end
@@ -130,16 +127,16 @@ class Gem::Security::Policy
   # +time+.
 
   def check_root(chain, time)
-    raise Gem::Security::Exception, 'missing signing chain' unless chain
+    raise Gem::Security::Exception, "missing signing chain" unless chain
 
     root = chain.first
 
-    raise Gem::Security::Exception, 'missing root certificate' unless root
+    raise Gem::Security::Exception, "missing root certificate" unless root
 
     raise Gem::Security::Exception,
           "root certificate #{root.subject} is not self-signed " +
           "(issuer #{root.issuer})" if
-      root.issuer.to_s != root.subject.to_s # HACK to_s is for ruby 1.8
+      root.issuer != root.subject
 
     check_cert root, root, time
   end
@@ -149,11 +146,11 @@ class Gem::Security::Policy
   # the digests of the two certificates match according to +digester+
 
   def check_trust(chain, digester, trust_dir)
-    raise Gem::Security::Exception, 'missing signing chain' unless chain
+    raise Gem::Security::Exception, "missing signing chain" unless chain
 
     root = chain.first
 
-    raise Gem::Security::Exception, 'missing root certificate' unless root
+    raise Gem::Security::Exception, "missing root certificate" unless root
 
     path = Gem::Security.trust_dir.cert_path root
 
@@ -167,9 +164,9 @@ class Gem::Security::Policy
     end
 
     save_cert = OpenSSL::X509::Certificate.new File.read path
-    save_dgst = digester.digest save_cert.public_key.to_s
+    save_dgst = digester.digest save_cert.public_key.to_pem
 
-    pkey_str = root.public_key.to_s
+    pkey_str = root.public_key.to_pem
     cert_dgst = digester.digest pkey_str
 
     raise Gem::Security::Exception,
@@ -185,7 +182,7 @@ class Gem::Security::Policy
 
   def subject(certificate) # :nodoc:
     certificate.extensions.each do |extension|
-      next unless extension.oid == 'subjectAltName'
+      next unless extension.oid == "subjectAltName"
 
       return extension.value
     end
@@ -197,7 +194,7 @@ class Gem::Security::Policy
     ("[Policy: %s - data: %p signer: %p chain: %p root: %p " +
      "signed-only: %p trusted-only: %p]") % [
        @name, @verify_chain, @verify_data, @verify_root, @verify_signer,
-       @only_signed, @only_trusted,
+       @only_signed, @only_trusted
      ]
   end
 
@@ -209,7 +206,7 @@ class Gem::Security::Policy
   # If +key+ is given it is used to validate the signing certificate.
 
   def verify(chain, key = nil, digests = {}, signatures = {},
-             full_name = '(unknown)')
+             full_name = "(unknown)")
     if signatures.empty?
       if @only_signed
         raise Gem::Security::Exception,
@@ -224,7 +221,7 @@ class Gem::Security::Policy
     end
 
     opt       = @opt
-    digester  = Gem::Security::DIGEST_ALGORITHM
+    digester  = Gem::Security.create_digest
     trust_dir = opt[:trust_dir]
     time      = Time.now
 
@@ -233,8 +230,8 @@ class Gem::Security::Policy
     end
 
     if @verify_data
-      raise Gem::Security::Exception, 'no digests provided (probable bug)' if
-        signer_digests.nil? or signer_digests.empty?
+      raise Gem::Security::Exception, "no digests provided (probable bug)" if
+        signer_digests.nil? || signer_digests.empty?
     else
       signer_digests = {}
     end
@@ -251,7 +248,7 @@ class Gem::Security::Policy
 
     if @only_trusted
       check_trust chain, digester, trust_dir
-    elsif signatures.empty? and digests.empty?
+    elsif signatures.empty? && digests.empty?
       # trust is irrelevant if there's no signatures to verify
     else
       alert_warning "#{subject signer} is not trusted for #{full_name}"
@@ -291,5 +288,4 @@ class Gem::Security::Policy
   end
 
   alias to_s name # :nodoc:
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/security/signer.rb
+++ ruby2.7-2.7.6/lib/rubygems/security/signer.rb
@@ -2,10 +2,9 @@
 ##
 # Basic OpenSSL-based package signing class.
 
-require "rubygems/user_interaction"
+require_relative "../user_interaction"
 
 class Gem::Security::Signer
-
   include Gem::UserInteraction
 
   ##
@@ -35,15 +34,15 @@ class Gem::Security::Signer
   attr_reader :options
 
   DEFAULT_OPTIONS = {
-    expiration_length_days: 365
+    expiration_length_days: 365,
   }.freeze
 
   ##
-  # Attemps to re-sign an expired cert with a given private key
+  # Attempts to re-sign an expired cert with a given private key
   def self.re_sign_cert(expired_cert, expired_cert_path, private_key)
     return unless expired_cert.not_after < Time.now
 
-    expiry = expired_cert.not_after.strftime('%Y%m%d%H%M%S')
+    expiry = expired_cert.not_after.strftime("%Y%m%d%H%M%S")
     expired_cert_file = "#{File.basename(expired_cert_path)}.expired.#{expiry}"
     new_expired_cert_path = File.join(Gem.user_home, ".gem", expired_cert_file)
 
@@ -81,11 +80,11 @@ class Gem::Security::Signer
       @cert_chain = [default_cert] if File.exist? default_cert
     end
 
-    @digest_algorithm = Gem::Security::DIGEST_ALGORITHM
     @digest_name      = Gem::Security::DIGEST_NAME
+    @digest_algorithm = Gem::Security.create_digest(@digest_name)
 
-    if @key && !@key.is_a?(OpenSSL::PKey::RSA)
-      @key = OpenSSL::PKey::RSA.new(File.read(@key), @passphrase)
+    if @key && !@key.is_a?(OpenSSL::PKey::PKey)
+      @key = OpenSSL::PKey.read(File.read(@key), @passphrase)
     end
 
     if @cert_chain
@@ -106,10 +105,10 @@ class Gem::Security::Signer
   # this value is preferred, otherwise the subject is used.
 
   def extract_name(cert) # :nodoc:
-    subject_alt_name = cert.extensions.find { |e| 'subjectAltName' == e.oid }
+    subject_alt_name = cert.extensions.find {|e| "subjectAltName" == e.oid }
 
     if subject_alt_name
-      /\Aemail:/ =~ subject_alt_name.value
+      /\Aemail:/ =~ subject_alt_name.value # rubocop:disable Performance/StartWith
 
       $' || subject_alt_name.value
     else
@@ -140,9 +139,9 @@ class Gem::Security::Signer
   def sign(data)
     return unless @key
 
-    raise Gem::Security::Exception, 'no certs provided' if @cert_chain.empty?
+    raise Gem::Security::Exception, "no certs provided" if @cert_chain.empty?
 
-    if @cert_chain.length == 1 and @cert_chain.last.not_after < Time.now
+    if @cert_chain.length == 1 && @cert_chain.last.not_after < Time.now
       alert("Your certificate has expired, trying to re-sign it...")
 
       re_sign_key(
@@ -178,13 +177,12 @@ class Gem::Security::Signer
     disk_cert = File.read(disk_cert_path) rescue nil
 
     disk_key_path = File.join(Gem.default_key_path)
-    disk_key =
-      OpenSSL::PKey::RSA.new(File.read(disk_key_path), @passphrase) rescue nil
+    disk_key = OpenSSL::PKey.read(File.read(disk_key_path), @passphrase) rescue nil
 
     return unless disk_key
 
     if disk_key.to_pem == @key.to_pem && disk_cert == old_cert.to_pem
-      expiry = old_cert.not_after.strftime('%Y%m%d%H%M%S')
+      expiry = old_cert.not_after.strftime("%Y%m%d%H%M%S")
       old_cert_file = "gem-public_cert.pem.expired.#{expiry}"
       old_cert_path = File.join(Gem.user_home, ".gem", old_cert_file)
 
@@ -202,5 +200,4 @@ class Gem::Security::Signer
       end
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/security/trust_dir.rb
+++ ruby2.7-2.7.6/lib/rubygems/security/trust_dir.rb
@@ -4,7 +4,6 @@
 # verification.
 
 class Gem::Security::TrustDir
-
   ##
   # Default permissions for the trust directory and its contents
 
@@ -26,7 +25,7 @@ class Gem::Security::TrustDir
     @dir = dir
     @permissions = permissions
 
-    @digester = Gem::Security::DIGEST_ALGORITHM
+    @digester = Gem::Security.create_digest
   end
 
   ##
@@ -42,7 +41,7 @@ class Gem::Security::TrustDir
   def each_certificate
     return enum_for __method__ unless block_given?
 
-    glob = File.join @dir, '*.pem'
+    glob = File.join @dir, "*.pem"
 
     Dir[glob].each do |certificate_file|
       begin
@@ -93,7 +92,7 @@ class Gem::Security::TrustDir
 
     destination = cert_path certificate
 
-    File.open destination, 'wb', 0600 do |io|
+    File.open destination, "wb", 0600 do |io|
       io.write certificate.to_pem
       io.chmod(@permissions[:trusted_cert])
     end
@@ -105,6 +104,7 @@ class Gem::Security::TrustDir
   # permissions.
 
   def verify
+    require "fileutils"
     if File.exist? @dir
       raise Gem::Security::Exception,
         "trust directory #{@dir} is not a directory" unless
@@ -115,5 +115,4 @@ class Gem::Security::TrustDir
       FileUtils.mkdir_p @dir, :mode => @permissions[:trust_dir]
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/security_option.rb
+++ ruby2.7-2.7.6/lib/rubygems/security_option.rb
@@ -5,7 +5,7 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems'
+require_relative "../rubygems"
 
 # forward-declare
 
@@ -19,23 +19,23 @@ end
 
 module Gem::SecurityOption
   def add_security_option
-    OptionParser.accept Gem::Security::Policy do |value|
-      require 'rubygems/security'
+    Gem::OptionParser.accept Gem::Security::Policy do |value|
+      require_relative "security"
 
-      raise OptionParser::InvalidArgument, 'OpenSSL not installed' unless
+      raise Gem::OptionParser::InvalidArgument, "OpenSSL not installed" unless
         defined?(Gem::Security::HighSecurity)
 
       policy = Gem::Security::Policies[value]
       unless policy
         valid = Gem::Security::Policies.keys.sort
-        raise OptionParser::InvalidArgument, "#{value} (#{valid.join ', '} are valid)"
+        raise Gem::OptionParser::InvalidArgument, "#{value} (#{valid.join ', '} are valid)"
       end
       policy
     end
 
-    add_option(:"Install/Update", '-P', '--trust-policy POLICY',
+    add_option(:"Install/Update", "-P", "--trust-policy POLICY",
                Gem::Security::Policy,
-               'Specify gem trust policy') do |value, options|
+               "Specify gem trust policy") do |value, options|
       options[:security_policy] = value
     end
   end
--- ruby2.7-2.7.6.orig/lib/rubygems/server.rb
+++ /dev/null
@@ -1,879 +0,0 @@
-# frozen_string_literal: true
-require 'webrick'
-require 'zlib'
-require 'erb'
-require 'uri'
-
-require 'rubygems'
-require 'rubygems/rdoc'
-
-##
-# Gem::Server and allows users to serve gems for consumption by
-# `gem --remote-install`.
-#
-# gem_server starts an HTTP server on the given port and serves the following:
-# * "/" - Browsing of gem spec files for installed gems
-# * "/specs.#{Gem.marshal_version}.gz" - specs name/version/platform index
-# * "/latest_specs.#{Gem.marshal_version}.gz" - latest specs
-#   name/version/platform index
-# * "/quick/" - Individual gemspecs
-# * "/gems" - Direct access to download the installable gems
-# * "/rdoc?q=" - Search for installed rdoc documentation
-#
-# == Usage
-#
-#   gem_server = Gem::Server.new Gem.dir, 8089, false
-#   gem_server.run
-#
-#--
-# TODO Refactor into a real WEBrick servlet to remove code duplication.
-
-class Gem::Server
-
-  attr_reader :spec_dirs
-
-  include ERB::Util
-  include Gem::UserInteraction
-
-  SEARCH = <<-ERB.freeze
-      <form class="headerSearch" name="headerSearchForm" method="get" action="/rdoc">
-        <div id="search" style="float:right">
-          <label for="q">Filter/Search</label>
-          <input id="q" type="text" style="width:10em" name="q">
-          <button type="submit" style="display:none"></button>
-        </div>
-      </form>
-  ERB
-
-  DOC_TEMPLATE = <<-'ERB'.freeze
-  <?xml version="1.0" encoding="iso-8859-1"?>
-  <!DOCTYPE html
-       PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
-       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-
-  <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
-  <head>
-    <title>RubyGems Documentation Index</title>
-    <link rel="stylesheet" href="gem-server-rdoc-style.css" type="text/css" media="screen" />
-  </head>
-  <body>
-    <div id="fileHeader">
-<%= SEARCH %>
-      <h1>RubyGems Documentation Index</h1>
-    </div>
-    <!-- banner header -->
-
-  <div id="bodyContent">
-    <div id="contextContent">
-      <div id="description">
-        <h1>Summary</h1>
-  <p>There are <%=values["gem_count"]%> gems installed:</p>
-  <p>
-  <%= values["specs"].map { |v| "<a href=\"##{u v["name"]}\">#{h v["name"]}</a>" }.join ', ' %>.
-  <h1>Gems</h1>
-
-  <dl>
-  <% values["specs"].each do |spec| %>
-    <dt>
-    <% if spec["first_name_entry"] then %>
-      <a name="<%=h spec["name"]%>"></a>
-    <% end %>
-
-    <b><%=h spec["name"]%> <%=h spec["version"]%></b>
-
-    <% if spec["ri_installed"] || spec["rdoc_installed"] then %>
-      <a href="<%=spec["doc_path"]%>">[rdoc]</a>
-    <% else %>
-      <span title="rdoc not installed">[rdoc]</span>
-    <% end %>
-
-    <% if spec["homepage"] then %>
-      <a href="<%=uri_encode spec["homepage"]%>" title="<%=h spec["homepage"]%>">[www]</a>
-    <% else %>
-      <span title="no homepage available">[www]</span>
-    <% end %>
-
-    <% if spec["has_deps"] then %>
-     - depends on
-      <%= spec["dependencies"].map { |v| "<a href=\"##{u v["name"]}\">#{h v["name"]}</a>" }.join ', ' %>.
-    <% end %>
-    </dt>
-    <dd>
-    <%=spec["summary"]%>
-    <% if spec["executables"] then %>
-      <br/>
-
-      <% if spec["only_one_executable"] then %>
-          Executable is
-      <% else %>
-          Executables are
-      <%end%>
-
-      <%= spec["executables"].map { |v| "<span class=\"context-item-name\">#{h v["executable"]}</span>"}.join ', ' %>.
-
-    <%end%>
-    <br/>
-    <br/>
-    </dd>
-  <% end %>
-  </dl>
-
-      </div>
-     </div>
-    </div>
-  <div id="validator-badges">
-    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
-  </div>
-  </body>
-  </html>
-  ERB
-
-  # CSS is copy & paste from rdoc-style.css, RDoc V1.0.1 - 20041108
-  RDOC_CSS = <<-CSS.freeze
-body {
-    font-family: Verdana,Arial,Helvetica,sans-serif;
-    font-size:   90%;
-    margin: 0;
-    margin-left: 40px;
-    padding: 0;
-    background: white;
-}
-
-h1,h2,h3,h4 { margin: 0; color: #efefef; background: transparent; }
-h1 { font-size: 150%; }
-h2,h3,h4 { margin-top: 1em; }
-
-a { background: #eef; color: #039; text-decoration: none; }
-a:hover { background: #039; color: #eef; }
-
-/* Override the base stylesheets Anchor inside a table cell */
-td > a {
-  background: transparent;
-  color: #039;
-  text-decoration: none;
-}
-
-/* and inside a section title */
-.section-title > a {
-  background: transparent;
-  color: #eee;
-  text-decoration: none;
-}
-
-/* === Structural elements =================================== */
-
-div#index {
-    margin: 0;
-    margin-left: -40px;
-    padding: 0;
-    font-size: 90%;
-}
-
-
-div#index a {
-    margin-left: 0.7em;
-}
-
-div#index .section-bar {
-   margin-left: 0px;
-   padding-left: 0.7em;
-   background: #ccc;
-   font-size: small;
-}
-
-
-div#classHeader, div#fileHeader {
-    width: auto;
-    color: white;
-    padding: 0.5em 1.5em 0.5em 1.5em;
-    margin: 0;
-    margin-left: -40px;
-    border-bottom: 3px solid #006;
-}
-
-div#classHeader a, div#fileHeader a {
-    background: inherit;
-    color: white;
-}
-
-div#classHeader td, div#fileHeader td {
-    background: inherit;
-    color: white;
-}
-
-
-div#fileHeader {
-    background: #057;
-}
-
-div#classHeader {
-    background: #048;
-}
-
-
-.class-name-in-header {
-  font-size:  180%;
-  font-weight: bold;
-}
-
-
-div#bodyContent {
-    padding: 0 1.5em 0 1.5em;
-}
-
-div#description {
-    padding: 0.5em 1.5em;
-    background: #efefef;
-    border: 1px dotted #999;
-}
-
-div#description h1,h2,h3,h4,h5,h6 {
-    color: #125;;
-    background: transparent;
-}
-
-div#validator-badges {
-    text-align: center;
-}
-div#validator-badges img { border: 0; }
-
-div#copyright {
-    color: #333;
-    background: #efefef;
-    font: 0.75em sans-serif;
-    margin-top: 5em;
-    margin-bottom: 0;
-    padding: 0.5em 2em;
-}
-
-
-/* === Classes =================================== */
-
-table.header-table {
-    color: white;
-    font-size: small;
-}
-
-.type-note {
-    font-size: small;
-    color: #DEDEDE;
-}
-
-.xxsection-bar {
-    background: #eee;
-    color: #333;
-    padding: 3px;
-}
-
-.section-bar {
-   color: #333;
-   border-bottom: 1px solid #999;
-    margin-left: -20px;
-}
-
-
-.section-title {
-    background: #79a;
-    color: #eee;
-    padding: 3px;
-    margin-top: 2em;
-    margin-left: -30px;
-    border: 1px solid #999;
-}
-
-.top-aligned-row {  vertical-align: top }
-.bottom-aligned-row { vertical-align: bottom }
-
-/* --- Context section classes ----------------------- */
-
-.context-row { }
-.context-item-name { font-family: monospace; font-weight: bold; color: black; }
-.context-item-value { font-size: small; color: #448; }
-.context-item-desc { color: #333; padding-left: 2em; }
-
-/* --- Method classes -------------------------- */
-.method-detail {
-    background: #efefef;
-    padding: 0;
-    margin-top: 0.5em;
-    margin-bottom: 1em;
-    border: 1px dotted #ccc;
-}
-.method-heading {
-  color: black;
-  background: #ccc;
-  border-bottom: 1px solid #666;
-  padding: 0.2em 0.5em 0 0.5em;
-}
-.method-signature { color: black; background: inherit; }
-.method-name { font-weight: bold; }
-.method-args { font-style: italic; }
-.method-description { padding: 0 0.5em 0 0.5em; }
-
-/* --- Source code sections -------------------- */
-
-a.source-toggle { font-size: 90%; }
-div.method-source-code {
-    background: #262626;
-    color: #ffdead;
-    margin: 1em;
-    padding: 0.5em;
-    border: 1px dashed #999;
-    overflow: hidden;
-}
-
-div.method-source-code pre { color: #ffdead; overflow: hidden; }
-
-/* --- Ruby keyword styles --------------------- */
-
-.standalone-code { background: #221111; color: #ffdead; overflow: hidden; }
-
-.ruby-constant  { color: #7fffd4; background: transparent; }
-.ruby-keyword { color: #00ffff; background: transparent; }
-.ruby-ivar    { color: #eedd82; background: transparent; }
-.ruby-operator  { color: #00ffee; background: transparent; }
-.ruby-identifier { color: #ffdead; background: transparent; }
-.ruby-node    { color: #ffa07a; background: transparent; }
-.ruby-comment { color: #b22222; font-weight: bold; background: transparent; }
-.ruby-regexp  { color: #ffa07a; background: transparent; }
-.ruby-value   { color: #7fffd4; background: transparent; }
-  CSS
-
-  RDOC_NO_DOCUMENTATION = <<-'ERB'.freeze
-<?xml version="1.0" encoding="iso-8859-1"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
-          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
-  <head>
-    <title>Found documentation</title>
-    <link rel="stylesheet" href="gem-server-rdoc-style.css" type="text/css" media="screen" />
-  </head>
-  <body>
-    <div id="fileHeader">
-<%= SEARCH %>
-      <h1>No documentation found</h1>
-    </div>
-
-    <div id="bodyContent">
-      <div id="contextContent">
-        <div id="description">
-          <p>No gems matched <%= h query.inspect %></p>
-
-          <p>
-            Back to <a href="/">complete gem index</a>
-          </p>
-
-        </div>
-      </div>
-    </div>
-    <div id="validator-badges">
-      <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
-    </div>
-  </body>
-</html>
-  ERB
-
-  RDOC_SEARCH_TEMPLATE = <<-'ERB'.freeze
-<?xml version="1.0" encoding="iso-8859-1"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
-          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
-  <head>
-    <title>Found documentation</title>
-    <link rel="stylesheet" href="gem-server-rdoc-style.css" type="text/css" media="screen" />
-  </head>
-  <body>
-    <div id="fileHeader">
-<%= SEARCH %>
-      <h1>Found documentation</h1>
-    </div>
-    <!-- banner header -->
-
-    <div id="bodyContent">
-      <div id="contextContent">
-        <div id="description">
-          <h1>Summary</h1>
-          <p><%=doc_items.length%> documentation topics found.</p>
-          <h1>Topics</h1>
-
-          <dl>
-          <% doc_items.each do |doc_item| %>
-            <dt>
-              <b><%=doc_item[:name]%></b>
-              <a href="<%=u doc_item[:url]%>">[rdoc]</a>
-            </dt>
-            <dd>
-              <%=h doc_item[:summary]%>
-              <br/>
-              <br/>
-            </dd>
-          <% end %>
-          </dl>
-
-          <p>
-            Back to <a href="/">complete gem index</a>
-          </p>
-
-        </div>
-      </div>
-    </div>
-    <div id="validator-badges">
-      <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
-    </div>
-  </body>
-</html>
-  ERB
-
-  def self.run(options)
-    new(options[:gemdir], options[:port], options[:daemon],
-        options[:launch], options[:addresses]).run
-  end
-
-  def initialize(gem_dirs, port, daemon, launch = nil, addresses = nil)
-    Gem::RDoc.load_rdoc
-    Socket.do_not_reverse_lookup = true
-
-    @gem_dirs  = Array gem_dirs
-    @port      = port
-    @daemon    = daemon
-    @launch    = launch
-    @addresses = addresses
-
-    logger  = WEBrick::Log.new nil, WEBrick::BasicLog::FATAL
-    @server = WEBrick::HTTPServer.new :DoNotListen => true, :Logger => logger
-
-    @spec_dirs = @gem_dirs.map { |gem_dir| File.join gem_dir, 'specifications' }
-    @spec_dirs.reject! { |spec_dir| !File.directory? spec_dir }
-
-    reset_gems
-
-    @have_rdoc_4_plus = nil
-  end
-
-  def add_date(res)
-    res['date'] = @spec_dirs.map do |spec_dir|
-      File.stat(spec_dir).mtime
-    end.max
-  end
-
-  def uri_encode(str)
-    str.gsub(URI::UNSAFE) do |match|
-      match.each_byte.map { |c| sprintf('%%%02X', c.ord) }.join
-    end
-  end
-
-  def doc_root(gem_name)
-    if have_rdoc_4_plus?
-      "/doc_root/#{u gem_name}/"
-    else
-      "/doc_root/#{u gem_name}/rdoc/index.html"
-    end
-  end
-
-  def have_rdoc_4_plus?
-    @have_rdoc_4_plus ||=
-      Gem::Requirement.new('>= 4.0.0.preview2').satisfied_by? Gem::RDoc.rdoc_version
-  end
-
-  def latest_specs(req, res)
-    reset_gems
-
-    res['content-type'] = 'application/x-gzip'
-
-    add_date res
-
-    latest_specs = Gem::Specification.latest_specs
-
-    specs = latest_specs.sort.map do |spec|
-      platform = spec.original_platform || Gem::Platform::RUBY
-      [spec.name, spec.version, platform]
-    end
-
-    specs = Marshal.dump specs
-
-    if req.path =~ /\.gz$/
-      specs = Gem::Util.gzip specs
-      res['content-type'] = 'application/x-gzip'
-    else
-      res['content-type'] = 'application/octet-stream'
-    end
-
-    if req.request_method == 'HEAD'
-      res['content-length'] = specs.length
-    else
-      res.body << specs
-    end
-  end
-
-  ##
-  # Creates server sockets based on the addresses option.  If no addresses
-  # were given a server socket for all interfaces is created.
-
-  def listen(addresses = @addresses)
-    addresses = [nil] unless addresses
-
-    listeners = 0
-
-    addresses.each do |address|
-      begin
-        @server.listen address, @port
-        @server.listeners[listeners..-1].each do |listener|
-          host, port = listener.addr.values_at 2, 1
-          host = "[#{host}]" if host =~ /:/ # we don't reverse lookup
-          say "Server started at http://#{host}:#{port}"
-        end
-
-        listeners = @server.listeners.length
-      rescue SystemCallError
-        next
-      end
-    end
-
-    if @server.listeners.empty?
-      say "Unable to start a server."
-      say "Check for running servers or your --bind and --port arguments"
-      terminate_interaction 1
-    end
-  end
-
-  def prerelease_specs(req, res)
-    reset_gems
-
-    res['content-type'] = 'application/x-gzip'
-
-    add_date res
-
-    specs = Gem::Specification.select do |spec|
-      spec.version.prerelease?
-    end.sort.map do |spec|
-      platform = spec.original_platform || Gem::Platform::RUBY
-      [spec.name, spec.version, platform]
-    end
-
-    specs = Marshal.dump specs
-
-    if req.path =~ /\.gz$/
-      specs = Gem::Util.gzip specs
-      res['content-type'] = 'application/x-gzip'
-    else
-      res['content-type'] = 'application/octet-stream'
-    end
-
-    if req.request_method == 'HEAD'
-      res['content-length'] = specs.length
-    else
-      res.body << specs
-    end
-  end
-
-  def quick(req, res)
-    reset_gems
-
-    res['content-type'] = 'text/plain'
-    add_date res
-
-    case req.request_uri.path
-    when %r|^/quick/(Marshal.#{Regexp.escape Gem.marshal_version}/)?(.*?)\.gemspec\.rz$| then
-      marshal_format, full_name = $1, $2
-      specs = Gem::Specification.find_all_by_full_name(full_name)
-
-      selector = full_name.inspect
-
-      if specs.empty?
-        res.status = 404
-        res.body = "No gems found matching #{selector}"
-      elsif specs.length > 1
-        res.status = 500
-        res.body = "Multiple gems found matching #{selector}"
-      elsif marshal_format
-        res['content-type'] = 'application/x-deflate'
-        res.body << Gem.deflate(Marshal.dump(specs.first))
-      end
-    else
-      raise WEBrick::HTTPStatus::NotFound, "`#{req.path}' not found."
-    end
-  end
-
-  def root(req, res)
-    reset_gems
-
-    add_date res
-
-    raise WEBrick::HTTPStatus::NotFound, "`#{req.path}' not found." unless
-      req.path == '/'
-
-    specs = []
-    total_file_count = 0
-
-    Gem::Specification.each do |spec|
-      total_file_count += spec.files.size
-      deps = spec.dependencies.map do |dep|
-        {
-          "name"    => dep.name,
-          "type"    => dep.type,
-          "version" => dep.requirement.to_s,
-        }
-      end
-
-      deps = deps.sort_by { |dep| [dep["name"].downcase, dep["version"]] }
-      deps.last["is_last"] = true unless deps.empty?
-
-      # executables
-      executables = spec.executables.sort.collect { |exec| {"executable" => exec} }
-      executables = nil if executables.empty?
-      executables.last["is_last"] = true if executables
-
-      # Pre-process spec homepage for safety reasons
-      begin
-        homepage_uri = URI.parse(spec.homepage)
-        if [URI::HTTP, URI::HTTPS].member? homepage_uri.class
-          homepage_uri = spec.homepage
-        else
-          homepage_uri = "."
-        end
-      rescue URI::InvalidURIError
-        homepage_uri = "."
-      end
-
-      specs << {
-        "authors"             => spec.authors.sort.join(", "),
-        "date"                => spec.date.to_s,
-        "dependencies"        => deps,
-        "doc_path"            => doc_root(spec.full_name),
-        "executables"         => executables,
-        "only_one_executable" => (executables && executables.size == 1),
-        "full_name"           => spec.full_name,
-        "has_deps"            => !deps.empty?,
-        "homepage"            => homepage_uri,
-        "name"                => spec.name,
-        "rdoc_installed"      => Gem::RDoc.new(spec).rdoc_installed?,
-        "ri_installed"        => Gem::RDoc.new(spec).ri_installed?,
-        "summary"             => spec.summary,
-        "version"             => spec.version.to_s,
-      }
-    end
-
-    specs << {
-      "authors" => "Chad Fowler, Rich Kilmer, Jim Weirich, Eric Hodel and others",
-      "dependencies" => [],
-      "doc_path" => doc_root("rubygems-#{Gem::VERSION}"),
-      "executables" => [{"executable" => 'gem', "is_last" => true}],
-      "only_one_executable" => true,
-      "full_name" => "rubygems-#{Gem::VERSION}",
-      "has_deps" => false,
-      "homepage" => "https://guides.rubygems.org/",
-      "name" => 'rubygems',
-      "ri_installed" => true,
-      "summary" => "RubyGems itself",
-      "version" => Gem::VERSION,
-    }
-
-    specs = specs.sort_by { |spec| [spec["name"].downcase, spec["version"]] }
-    specs.last["is_last"] = true
-
-    # tag all specs with first_name_entry
-    last_spec = nil
-    specs.each do |spec|
-      is_first = last_spec.nil? || (last_spec["name"].downcase != spec["name"].downcase)
-      spec["first_name_entry"] = is_first
-      last_spec = spec
-    end
-
-    # create page from template
-    template = ERB.new(DOC_TEMPLATE)
-    res['content-type'] = 'text/html'
-
-    values = { "gem_count" => specs.size.to_s, "specs" => specs,
-               "total_file_count" => total_file_count.to_s }
-
-    # suppress 1.9.3dev warning about unused variable
-    values = values
-
-    result = template.result binding
-    res.body = result
-  end
-
-  ##
-  # Can be used for quick navigation to the rdoc documentation.  You can then
-  # define a search shortcut for your browser.  E.g. in Firefox connect
-  # 'shortcut:rdoc' to http://localhost:8808/rdoc?q=%s template. Then you can
-  # directly open the ActionPack documentation by typing 'rdoc actionp'. If
-  # there are multiple hits for the search term, they are presented as a list
-  # with links.
-  #
-  # Search algorithm aims for an intuitive search:
-  # 1. first try to find the gems and documentation folders which name
-  #    starts with the search term
-  # 2. search for entries, that *contain* the search term
-  # 3. show all the gems
-  #
-  # If there is only one search hit, user is immediately redirected to the
-  # documentation for the particular gem, otherwise a list with results is
-  # shown.
-  #
-  # === Additional trick - install documentation for Ruby core
-  #
-  # Note: please adjust paths accordingly use for example 'locate yaml.rb' and
-  # 'gem environment' to identify directories, that are specific for your
-  # local installation
-  #
-  # 1. install Ruby sources
-  #      cd /usr/src
-  #      sudo apt-get source ruby
-  #
-  # 2. generate documentation
-  #      rdoc -o /usr/lib/ruby/gems/1.8/doc/core/rdoc \
-  #        /usr/lib/ruby/1.8 ruby1.8-1.8.7.72
-  #
-  # By typing 'rdoc core' you can now access the core documentation
-
-  def rdoc(req, res)
-    query = req.query['q']
-    show_rdoc_for_pattern("#{query}*", res) && return
-    show_rdoc_for_pattern("*#{query}*", res) && return
-
-    template = ERB.new RDOC_NO_DOCUMENTATION
-
-    res['content-type'] = 'text/html'
-    res.body = template.result binding
-  end
-
-  ##
-  # Updates the server to use the latest installed gems.
-
-  def reset_gems # :nodoc:
-    Gem::Specification.dirs = @gem_dirs
-  end
-
-  ##
-  # Returns true and prepares http response, if rdoc for the requested gem
-  # name pattern was found.
-  #
-  # The search is based on the file system content, not on the gems metadata.
-  # This allows additional documentation folders like 'core' for the Ruby core
-  # documentation - just put it underneath the main doc folder.
-
-  def show_rdoc_for_pattern(pattern, res)
-    found_gems = Dir.glob("{#{@gem_dirs.join ','}}/doc/#{pattern}").select do |path|
-      File.exist? File.join(path, 'rdoc/index.html')
-    end
-    case found_gems.length
-    when 0
-      return false
-    when 1
-      new_path = File.basename(found_gems[0])
-      res.status = 302
-      res['Location'] = doc_root new_path
-      return true
-    else
-      doc_items = []
-      found_gems.each do |file_name|
-        base_name = File.basename(file_name)
-        doc_items << {
-          :name    => base_name,
-          :url     => doc_root(new_path),
-          :summary => ''
-        }
-      end
-
-      template = ERB.new(RDOC_SEARCH_TEMPLATE)
-      res['content-type'] = 'text/html'
-      result = template.result binding
-      res.body = result
-      return true
-    end
-  end
-
-  def run
-    listen
-
-    WEBrick::Daemon.start if @daemon
-
-    @server.mount_proc "/specs.#{Gem.marshal_version}", method(:specs)
-    @server.mount_proc "/specs.#{Gem.marshal_version}.gz", method(:specs)
-
-    @server.mount_proc "/latest_specs.#{Gem.marshal_version}",
-                       method(:latest_specs)
-    @server.mount_proc "/latest_specs.#{Gem.marshal_version}.gz",
-                       method(:latest_specs)
-
-    @server.mount_proc "/prerelease_specs.#{Gem.marshal_version}",
-                       method(:prerelease_specs)
-    @server.mount_proc "/prerelease_specs.#{Gem.marshal_version}.gz",
-                       method(:prerelease_specs)
-
-    @server.mount_proc "/quick/", method(:quick)
-
-    @server.mount_proc("/gem-server-rdoc-style.css") do |req, res|
-      res['content-type'] = 'text/css'
-      add_date res
-      res.body << RDOC_CSS
-    end
-
-    @server.mount_proc "/", method(:root)
-
-    @server.mount_proc "/rdoc", method(:rdoc)
-
-    file_handlers = {
-      '/gems' => '/cache/',
-    }
-
-    if have_rdoc_4_plus?
-      @server.mount '/doc_root', RDoc::Servlet, '/doc_root'
-    else
-      file_handlers['/doc_root'] = '/doc/'
-    end
-
-    @gem_dirs.each do |gem_dir|
-      file_handlers.each do |mount_point, mount_dir|
-        @server.mount(mount_point, WEBrick::HTTPServlet::FileHandler,
-                      File.join(gem_dir, mount_dir), true)
-      end
-    end
-
-    trap("INT") { @server.shutdown; exit! }
-    trap("TERM") { @server.shutdown; exit! }
-
-    launch if @launch
-
-    @server.start
-  end
-
-  def specs(req, res)
-    reset_gems
-
-    add_date res
-
-    specs = Gem::Specification.sort_by(&:sort_obj).map do |spec|
-      platform = spec.original_platform || Gem::Platform::RUBY
-      [spec.name, spec.version, platform]
-    end
-
-    specs = Marshal.dump specs
-
-    if req.path =~ /\.gz$/
-      specs = Gem::Util.gzip specs
-      res['content-type'] = 'application/x-gzip'
-    else
-      res['content-type'] = 'application/octet-stream'
-    end
-
-    if req.request_method == 'HEAD'
-      res['content-length'] = specs.length
-    else
-      res.body << specs
-    end
-  end
-
-  def launch
-    listeners = @server.listeners.map{|l| l.addr[2] }
-
-    # TODO: 0.0.0.0 == any, not localhost.
-    host = listeners.any?{|l| l == '0.0.0.0'} ? 'localhost' : listeners.first
-
-    say "Launching browser to http://#{host}:#{@port}"
-
-    system("#{@launch} http://#{host}:#{@port}")
-  end
-
-end
--- ruby2.7-2.7.6.orig/lib/rubygems/source.rb
+++ ruby2.7-2.7.6/lib/rubygems/source.rb
@@ -1,7 +1,6 @@
 # frozen_string_literal: true
-autoload :FileUtils, 'fileutils'
 
-require "rubygems/text"
+require_relative "text"
 ##
 # A Source knows how to list and fetch gems from a RubyGems marshal index.
 #
@@ -9,14 +8,13 @@ require "rubygems/text"
 # bundler dependency API and so-forth.
 
 class Gem::Source
-
   include Comparable
   include Gem::Text
 
   FILES = { # :nodoc:
-    :released   => 'specs',
-    :latest     => 'latest_specs',
-    :prerelease => 'prerelease_specs',
+    :released   => "specs",
+    :latest     => "latest_specs",
+    :prerelease => "prerelease_specs",
   }.freeze
 
   ##
@@ -28,15 +26,9 @@ class Gem::Source
   # Creates a new Source which will use the index located at +uri+.
 
   def initialize(uri)
-    begin
-      unless uri.kind_of? URI
-        uri = URI.parse(uri.to_s)
-      end
-    rescue URI::InvalidURIError
-      raise if Gem::Source == self.class
-    end
-
-    @uri = uri
+    require_relative "uri"
+    @uri = Gem::Uri.parse!(uri)
+    @update_cache = nil
   end
 
   ##
@@ -70,7 +62,7 @@ class Gem::Source
   end
 
   def ==(other) # :nodoc:
-    self.class === other and @uri == other.uri
+    self.class === other && @uri == other.uri
   end
 
   alias_method :eql?, :== # :nodoc:
@@ -79,9 +71,17 @@ class Gem::Source
   # Returns a Set that can fetch specifications from this source.
 
   def dependency_resolver_set # :nodoc:
-    return Gem::Resolver::IndexSet.new self if 'file' == uri.scheme
+    return Gem::Resolver::IndexSet.new self if "file" == uri.scheme
+
+    fetch_uri = if uri.host == "rubygems.org"
+      index_uri = uri.dup
+      index_uri.host = "index.rubygems.org"
+      index_uri
+    else
+      uri
+    end
 
-    bundler_api_uri = uri + './api/v1/dependencies'
+    bundler_api_uri = enforce_trailing_slash(fetch_uri)
 
     begin
       fetcher = Gem::RemoteFetcher.fetcher
@@ -89,11 +89,7 @@ class Gem::Source
     rescue Gem::RemoteFetcher::FetchError
       Gem::Resolver::IndexSet.new self
     else
-      if response.respond_to? :uri
-        Gem::Resolver::APISet.new response.uri
-      else
-        Gem::Resolver::APISet.new bundler_api_uri
-      end
+      Gem::Resolver::APISet.new response.uri + "./info/"
     end
   end
 
@@ -116,7 +112,8 @@ class Gem::Source
   # Returns true when it is possible and safe to update the cache directory.
 
   def update_cache?
-    @update_cache ||=
+    return @update_cache unless @update_cache.nil?
+    @update_cache =
       begin
         File.stat(Gem.user_home).uid == Process.uid
       rescue Errno::ENOENT
@@ -132,7 +129,7 @@ class Gem::Source
 
     spec_file_name = name_tuple.spec_name
 
-    source_uri = uri + "#{Gem::MARSHAL_SPEC_DIR}#{spec_file_name}"
+    source_uri = enforce_trailing_slash(uri) + "#{Gem::MARSHAL_SPEC_DIR}#{spec_file_name}"
 
     cache_dir = cache_dir source_uri
 
@@ -144,15 +141,16 @@ class Gem::Source
       return spec if spec
     end
 
-    source_uri.path << '.rz'
+    source_uri.path << ".rz"
 
     spec = fetcher.fetch_path source_uri
     spec = Gem::Util.inflate spec
 
     if update_cache?
+      require "fileutils"
       FileUtils.mkdir_p cache_dir
 
-      File.open local_spec, 'wb' do |io|
+      File.open local_spec, "wb" do |io|
         io.write spec
       end
     end
@@ -176,12 +174,15 @@ class Gem::Source
     file       = FILES[type]
     fetcher    = Gem::RemoteFetcher.fetcher
     file_name  = "#{file}.#{Gem.marshal_version}"
-    spec_path  = uri + "#{file_name}.gz"
+    spec_path  = enforce_trailing_slash(uri) + "#{file_name}.gz"
     cache_dir  = cache_dir spec_path
     local_file = File.join(cache_dir, file_name)
     retried    = false
 
-    FileUtils.mkdir_p cache_dir if update_cache?
+    if update_cache?
+      require "fileutils"
+      FileUtils.mkdir_p cache_dir
+    end
 
     spec_dump = fetcher.cache_update_path spec_path, local_file, update_cache?
 
@@ -208,13 +209,13 @@ class Gem::Source
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[Remote:', ']' do
+    q.group 2, "[Remote:", "]" do
       q.breakable
       q.text @uri.to_s
 
       if api = uri
         q.breakable
-        q.text 'API URI: '
+        q.text "API URI: "
         q.text api.to_s
       end
     end
@@ -222,14 +223,19 @@ class Gem::Source
 
   def typo_squatting?(host, distance_threshold=4)
     return if @uri.host.nil?
-    levenshtein_distance(@uri.host, host) <= distance_threshold
+    levenshtein_distance(@uri.host, host).between? 1, distance_threshold
   end
 
+  private
+
+  def enforce_trailing_slash(uri)
+    uri.merge(uri.path.gsub(/\/+$/, "") + "/")
+  end
 end
 
-require 'rubygems/source/git'
-require 'rubygems/source/installed'
-require 'rubygems/source/specific_file'
-require 'rubygems/source/local'
-require 'rubygems/source/lock'
-require 'rubygems/source/vendor'
+require_relative "source/git"
+require_relative "source/installed"
+require_relative "source/specific_file"
+require_relative "source/local"
+require_relative "source/lock"
+require_relative "source/vendor"
--- ruby2.7-2.7.6.orig/lib/rubygems/source/git.rb
+++ ruby2.7-2.7.6/lib/rubygems/source/git.rb
@@ -1,5 +1,4 @@
 # frozen_string_literal: true
-require 'rubygems/util'
 
 ##
 # A git gem for use in a gem dependencies file.
@@ -12,7 +11,6 @@ require 'rubygems/util'
 #   source.specs
 
 class Gem::Source::Git < Gem::Source
-
   ##
   # The name of the gem created by this git gem.
 
@@ -51,8 +49,8 @@ class Gem::Source::Git < Gem::Source
   # will be checked out when the gem is installed.
 
   def initialize(name, repository, reference, submodules = false)
-    super repository
-
+    require_relative "../uri"
+    @uri = Gem::Uri.parse(repository)
     @name            = name
     @repository      = repository
     @reference       = reference
@@ -60,7 +58,7 @@ class Gem::Source::Git < Gem::Source
 
     @remote   = true
     @root_dir = Gem.dir
-    @git      = ENV['git'] || 'git'
+    @git      = ENV["git"] || "git"
   end
 
   def <=>(other)
@@ -78,10 +76,10 @@ class Gem::Source::Git < Gem::Source
   end
 
   def ==(other) # :nodoc:
-    super and
-      @name            == other.name and
-      @repository      == other.repository and
-      @reference       == other.reference and
+    super &&
+      @name            == other.name &&
+      @repository      == other.repository &&
+      @reference       == other.reference &&
       @need_submodules == other.need_submodules
   end
 
@@ -94,18 +92,21 @@ class Gem::Source::Git < Gem::Source
     return false unless File.exist? repo_cache_dir
 
     unless File.exist? install_dir
-      system @git, 'clone', '--quiet', '--no-checkout',
+      system @git, "clone", "--quiet", "--no-checkout",
              repo_cache_dir, install_dir
     end
 
     Dir.chdir install_dir do
-      system @git, 'fetch', '--quiet', '--force', '--tags', install_dir
+      system @git, "fetch", "--quiet", "--force", "--tags", install_dir
 
-      success = system @git, 'reset', '--quiet', '--hard', rev_parse
+      success = system @git, "reset", "--quiet", "--hard", rev_parse
 
-      success &&=
-        Gem::Util.silent_system @git, 'submodule', 'update',
-               '--quiet', '--init', '--recursive' if @need_submodules
+      if @need_submodules
+        require "open3"
+        _, status = Open3.capture2e(@git, "submodule", "update", "--quiet", "--init", "--recursive")
+
+        success &&= status.success?
+      end
 
       success
     end
@@ -119,11 +120,11 @@ class Gem::Source::Git < Gem::Source
 
     if File.exist? repo_cache_dir
       Dir.chdir repo_cache_dir do
-        system @git, 'fetch', '--quiet', '--force', '--tags',
-               @repository, 'refs/heads/*:refs/heads/*'
+        system @git, "fetch", "--quiet", "--force", "--tags",
+               @repository, "refs/heads/*:refs/heads/*"
       end
     else
-      system @git, 'clone', '--quiet', '--bare', '--no-hardlinks',
+      system @git, "clone", "--quiet", "--bare", "--no-hardlinks",
              @repository, repo_cache_dir
     end
   end
@@ -132,7 +133,7 @@ class Gem::Source::Git < Gem::Source
   # Directory where git gems get unpacked and so-forth.
 
   def base_dir # :nodoc:
-    File.join @root_dir, 'bundler'
+    File.join @root_dir, "bundler"
   end
 
   ##
@@ -154,11 +155,11 @@ class Gem::Source::Git < Gem::Source
   def install_dir # :nodoc:
     return unless File.exist? repo_cache_dir
 
-    File.join base_dir, 'gems', "#{@name}-#{dir_shortref}"
+    File.join base_dir, "gems", "#{@name}-#{dir_shortref}"
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[Git: ', ']' do
+    q.group 2, "[Git: ", "]" do
       q.breakable
       q.text @repository
 
@@ -171,7 +172,7 @@ class Gem::Source::Git < Gem::Source
   # The directory where the git gem's repository will be cached.
 
   def repo_cache_dir # :nodoc:
-    File.join @root_dir, 'cache', 'bundler', 'git', "#{@name}-#{uri_hash}"
+    File.join @root_dir, "cache", "bundler", "git", "#{@name}-#{uri_hash}"
   end
 
   ##
@@ -181,7 +182,7 @@ class Gem::Source::Git < Gem::Source
     hash = nil
 
     Dir.chdir repo_cache_dir do
-      hash = Gem::Util.popen(@git, 'rev-parse', @reference).strip
+      hash = Gem::Util.popen(@git, "rev-parse", @reference).strip
     end
 
     raise Gem::Exception,
@@ -200,7 +201,7 @@ class Gem::Source::Git < Gem::Source
     return [] unless install_dir
 
     Dir.chdir install_dir do
-      Dir['{,*,*/*}.gemspec'].map do |spec_file|
+      Dir["{,*,*/*}.gemspec"].map do |spec_file|
         directory = File.dirname spec_file
         file      = File.basename spec_file
 
@@ -210,7 +211,7 @@ class Gem::Source::Git < Gem::Source
             spec.base_dir = base_dir
 
             spec.extension_dir =
-              File.join base_dir, 'extensions', Gem::Platform.local.to_s,
+              File.join base_dir, "extensions", Gem::Platform.local.to_s,
                 Gem.extension_api_version, "#{name}-#{dir_shortref}"
 
             spec.full_gem_path = File.dirname spec.loaded_from if spec
@@ -225,17 +226,16 @@ class Gem::Source::Git < Gem::Source
   # A hash for the git gem based on the git repository URI.
 
   def uri_hash # :nodoc:
-    require 'digest' # required here to avoid deadlocking in Gem.activate_bin_path (because digest is a gem on 2.5+)
+    require_relative "../openssl"
 
     normalized =
-      if @repository =~ %r%^\w+://(\w+@)?%
-        uri = URI(@repository).normalize.to_s.sub %r%/$%,''
+      if @repository =~ %r{^\w+://(\w+@)?}
+        uri = URI(@repository).normalize.to_s.sub %r{/$},""
         uri.sub(/\A(\w+)/) { $1.downcase }
       else
         @repository
       end
 
-    Digest::SHA1.hexdigest normalized
+    OpenSSL::Digest::SHA1.hexdigest normalized
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/source/installed.rb
+++ ruby2.7-2.7.6/lib/rubygems/source/installed.rb
@@ -3,7 +3,6 @@
 # Represents an installed gem.  This is used for dependency resolution.
 
 class Gem::Source::Installed < Gem::Source
-
   def initialize # :nodoc:
     @uri = nil
   end
@@ -34,7 +33,6 @@ class Gem::Source::Installed < Gem::Sour
   end
 
   def pretty_print(q) # :nodoc:
-    q.text '[Installed]'
+    q.text "[Installed]"
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/source/local.rb
+++ ruby2.7-2.7.6/lib/rubygems/source/local.rb
@@ -4,7 +4,6 @@
 # dependencies.
 
 class Gem::Source::Local < Gem::Source
-
   def initialize # :nodoc:
     @specs   = nil
     @api_uri = nil
@@ -30,7 +29,7 @@ class Gem::Source::Local < Gem::Source
   end
 
   def inspect # :nodoc:
-    keys = @specs ? @specs.keys.sort : 'NOT LOADED'
+    keys = @specs ? @specs.keys.sort : "NOT LOADED"
     "#<%s specs: %p>" % [self.class, keys]
   end
 
@@ -61,7 +60,7 @@ class Gem::Source::Local < Gem::Source
           when :latest
             tup = pkg.spec.name_tuple
 
-            cur = names.find { |x| x.name == tup.name }
+            cur = names.find {|x| x.name == tup.name }
             if !cur
               names << tup
             elsif cur.version < tup.version
@@ -98,7 +97,7 @@ class Gem::Source::Local < Gem::Source
       end
     end
 
-    found.max_by { |s| s.version }
+    found.max_by {|s| s.version }
   end
 
   def fetch_spec(name) # :nodoc:
@@ -122,12 +121,11 @@ class Gem::Source::Local < Gem::Source
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[Local gems:', ']' do
+    q.group 2, "[Local gems:", "]" do
       q.breakable
       q.seplist @specs.keys do |v|
         q.text v.full_name
       end
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/source/lock.rb
+++ ruby2.7-2.7.6/lib/rubygems/source/lock.rb
@@ -5,7 +5,6 @@
 # dependency lock files.
 
 class Gem::Source::Lock < Gem::Source
-
   ##
   # The wrapped Gem::Source
 
@@ -48,5 +47,4 @@ class Gem::Source::Lock < Gem::Source
   def uri # :nodoc:
     @wrapped.uri
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/source/specific_file.rb
+++ ruby2.7-2.7.6/lib/rubygems/source/specific_file.rb
@@ -4,7 +4,6 @@
 # local gems.
 
 class Gem::Source::SpecificFile < Gem::Source
-
   ##
   # The path to the gem for this specific file.
 
@@ -43,7 +42,7 @@ class Gem::Source::SpecificFile < Gem::S
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, '[SpecificFile:', ']' do
+    q.group 2, "[SpecificFile:", "]" do
       q.breakable
       q.text @path
     end
@@ -69,5 +68,4 @@ class Gem::Source::SpecificFile < Gem::S
       super
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/source/vendor.rb
+++ ruby2.7-2.7.6/lib/rubygems/source/vendor.rb
@@ -3,7 +3,6 @@
 # This represents a vendored source that is similar to an installed gem.
 
 class Gem::Source::Vendor < Gem::Source::Installed
-
   ##
   # Creates a new Vendor source for a gem that was unpacked at +path+.
 
@@ -23,5 +22,4 @@ class Gem::Source::Vendor < Gem::Source:
       nil
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/source_list.rb
+++ ruby2.7-2.7.6/lib/rubygems/source_list.rb
@@ -1,5 +1,4 @@
 # frozen_string_literal: true
-require 'rubygems/source'
 
 ##
 # The SourceList represents the sources rubygems has been configured to use.
@@ -15,7 +14,6 @@ require 'rubygems/source'
 # The most common way to get a SourceList is Gem.sources.
 
 class Gem::SourceList
-
   include Enumerable
 
   ##
@@ -50,16 +48,12 @@ class Gem::SourceList
   # String.
 
   def <<(obj)
-    require "uri"
-
     src = case obj
-          when URI
-            Gem::Source.new(obj)
-          when Gem::Source
-            obj
-          else
-            Gem::Source.new(URI.parse(obj))
-          end
+    when Gem::Source
+      obj
+    else
+      Gem::Source.new(obj)
+    end
 
     @sources << src unless @sources.include?(src)
     src
@@ -90,7 +84,7 @@ class Gem::SourceList
   # Yields each source URI in the list.
 
   def each
-    @sources.each { |s| yield s.uri.to_s }
+    @sources.each {|s| yield s.uri.to_s }
   end
 
   ##
@@ -115,7 +109,7 @@ class Gem::SourceList
   # Returns an Array of source URI Strings.
 
   def to_a
-    @sources.map { |x| x.uri.to_s }
+    @sources.map {|x| x.uri.to_s }
   end
 
   alias_method :to_ary, :to_a
@@ -135,7 +129,7 @@ class Gem::SourceList
     if other.kind_of? Gem::Source
       @sources.include? other
     else
-      @sources.find { |x| x.uri.to_s == other.to_s }
+      @sources.find {|x| x.uri.to_s == other.to_s }
     end
   end
 
@@ -146,8 +140,7 @@ class Gem::SourceList
     if source.kind_of? Gem::Source
       @sources.delete source
     else
-      @sources.delete_if { |x| x.uri.to_s == source.to_s }
+      @sources.delete_if {|x| x.uri.to_s == source.to_s }
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/source_local.rb
+++ /dev/null
@@ -1,7 +0,0 @@
-# frozen_string_literal: true
-require 'rubygems/source'
-require 'rubygems/source_local'
-
-unless Gem::Deprecate.skip
-  Kernel.warn "#{Gem.location_of_caller(3).join(':')}: Warning: Requiring rubygems/source_local is deprecated; please use rubygems/source/local instead."
-end
--- ruby2.7-2.7.6.orig/lib/rubygems/source_specific_file.rb
+++ /dev/null
@@ -1,6 +0,0 @@
-# frozen_string_literal: true
-require 'rubygems/source/specific_file'
-
-unless Gem::Deprecate.skip
-  Kernel.warn "#{Gem.location_of_caller(3).join(':')}: Warning: Requiring rubygems/source_specific_file is deprecated; please use rubygems/source/specific_file instead."
-end
--- ruby2.7-2.7.6.orig/lib/rubygems/spec_fetcher.rb
+++ ruby2.7-2.7.6/lib/rubygems/spec_fetcher.rb
@@ -1,15 +1,14 @@
 # frozen_string_literal: true
-require 'rubygems/remote_fetcher'
-require 'rubygems/user_interaction'
-require 'rubygems/errors'
-require 'rubygems/text'
-require 'rubygems/name_tuple'
+require_relative "remote_fetcher"
+require_relative "user_interaction"
+require_relative "errors"
+require_relative "text"
+require_relative "name_tuple"
 
 ##
 # SpecFetcher handles metadata updates from remote gem repositories.
 
 class Gem::SpecFetcher
-
   include Gem::UserInteraction
   include Gem::Text
 
@@ -92,14 +91,14 @@ class Gem::SpecFetcher
 
     list.each do |source, specs|
       if dependency.name.is_a?(String) && specs.respond_to?(:bsearch)
-        start_index = (0 ... specs.length).bsearch{ |i| specs[i].name >= dependency.name }
-        end_index   = (0 ... specs.length).bsearch{ |i| specs[i].name > dependency.name }
+        start_index = (0 ... specs.length).bsearch {|i| specs[i].name >= dependency.name }
+        end_index   = (0 ... specs.length).bsearch {|i| specs[i].name > dependency.name }
         specs = specs[start_index ... end_index] if start_index && end_index
       end
 
       found[source] = specs.select do |tup|
         if dependency.match?(tup)
-          if matching_platform and !Gem::Platform.match(tup.platform)
+          if matching_platform && !Gem::Platform.match_gem?(tup.platform, tup.name)
             pm = (
               rejected_specs[dependency] ||= \
                 Gem::PlatformMismatch.new(tup.name, tup.version))
@@ -122,7 +121,7 @@ class Gem::SpecFetcher
       end
     end
 
-    tuples = tuples.sort_by { |x| x[0] }
+    tuples = tuples.sort_by {|x| x[0].version }
 
     return [tuples, errors]
   end
@@ -171,30 +170,33 @@ class Gem::SpecFetcher
   # Suggests gems based on the supplied +gem_name+. Returns an array of
   # alternative gem names.
 
-  def suggest_gems_from_name(gem_name, type = :latest)
-    gem_name        = gem_name.downcase.tr('_-', '')
+  def suggest_gems_from_name(gem_name, type = :latest, num_results = 5)
+    gem_name        = gem_name.downcase.tr("_-", "")
     max             = gem_name.size / 2
     names           = available_specs(type).first.values.flatten(1)
 
     matches = names.map do |n|
       next unless n.match_platform?
-
-      distance = levenshtein_distance gem_name, n.name.downcase.tr('_-', '')
-
-      next if distance >= max
-
-      return [n.name] if distance == 0
-
-      [n.name, distance]
+      [n.name, 0] if n.name.downcase.tr("_-", "").include?(gem_name)
     end.compact
 
+    if matches.length < num_results
+      matches += names.map do |n|
+        next unless n.match_platform?
+        distance = levenshtein_distance gem_name, n.name.downcase.tr("_-", "")
+        next if distance >= max
+        return [n.name] if distance == 0
+        [n.name, distance]
+      end.compact
+    end
+
     matches = if matches.empty? && type != :prerelease
-                suggest_gems_from_name gem_name, :prerelease
-              else
-                matches.uniq.sort_by { |name, dist| dist }
-              end
+      suggest_gems_from_name gem_name, :prerelease
+    else
+      matches.uniq.sort_by {|name, dist| dist }
+    end
 
-    matches.first(5).map { |name, dist| name }
+    matches.map {|name, dist| name }.uniq.first(num_results)
   end
 
   ##
@@ -214,27 +216,27 @@ class Gem::SpecFetcher
     @sources.each_source do |source|
       begin
         names = case type
-                when :latest
-                  tuples_for source, :latest
-                when :released
-                  tuples_for source, :released
-                when :complete
-                  names =
-                    tuples_for(source, :prerelease, true) +
-                    tuples_for(source, :released)
-
-                  names.sort
-                when :abs_latest
-                  names =
-                    tuples_for(source, :prerelease, true) +
-                    tuples_for(source, :latest)
-
-                  names.sort
-                when :prerelease
-                  tuples_for(source, :prerelease)
-                else
-                  raise Gem::Exception, "Unknown type - :#{type}"
-                end
+        when :latest
+          tuples_for source, :latest
+        when :released
+          tuples_for source, :released
+        when :complete
+          names =
+            tuples_for(source, :prerelease, true) +
+            tuples_for(source, :released)
+
+          names.sort
+        when :abs_latest
+          names =
+            tuples_for(source, :prerelease, true) +
+            tuples_for(source, :latest)
+
+          names.sort
+        when :prerelease
+          tuples_for(source, :prerelease)
+        else
+          raise Gem::Exception, "Unknown type - :#{type}"
+        end
       rescue Gem::RemoteFetcher::FetchError => e
         errors << Gem::SourceFetchProblem.new(source, e)
       else
@@ -251,10 +253,9 @@ class Gem::SpecFetcher
 
   def tuples_for(source, type, gracefully_ignore=false) # :nodoc:
     @caches[type][source.uri] ||=
-      source.load_specs(type).sort_by { |tup| tup.name }
+      source.load_specs(type).sort_by {|tup| tup.name }
   rescue Gem::RemoteFetcher::FetchError
     raise unless gracefully_ignore
     []
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/specification.rb
@@ -1,19 +1,16 @@
 # frozen_string_literal: true
-# -*- coding: utf-8 -*-
+#
 #--
 # Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.
 # All rights reserved.
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/version'
-require 'rubygems/requirement'
-require 'rubygems/platform'
-require 'rubygems/deprecate'
-require 'rubygems/basic_specification'
-require 'rubygems/stub_specification'
-require 'rubygems/specification_policy'
-require 'rubygems/util/list'
+require_relative "deprecate"
+require_relative "basic_specification"
+require_relative "stub_specification"
+require_relative "platform"
+require_relative "util/list"
 
 ##
 # The Specification class contains the information for a gem.  Typically
@@ -37,7 +34,6 @@ require 'rubygems/util/list'
 # items you may add to a specification.
 
 class Gem::Specification < Gem::BasicSpecification
-
   extend Gem::Deprecate
 
   # REFACTOR: Consider breaking out this version stuff into a separate
@@ -78,21 +74,21 @@ class Gem::Specification < Gem::BasicSpe
   # key should be equal to the CURRENT_SPECIFICATION_VERSION.
 
   SPECIFICATION_VERSION_HISTORY = { # :nodoc:
-    -1 => ['(RubyGems versions up to and including 0.7 did not have versioned specifications)'],
+    -1 => ["(RubyGems versions up to and including 0.7 did not have versioned specifications)"],
     1  => [
       'Deprecated "test_suite_file" in favor of the new, but equivalent, "test_files"',
-      '"test_file=x" is a shortcut for "test_files=[x]"'
+      '"test_file=x" is a shortcut for "test_files=[x]"',
     ],
     2 => [
       'Added "required_rubygems_version"',
-      'Now forward-compatible with future versions',
+      "Now forward-compatible with future versions",
     ],
     3 => [
-      'Added Fixnum validation to the specification_version'
+      "Added Fixnum validation to the specification_version",
     ],
     4 => [
-      'Added sandboxed freeform metadata to the specification version.'
-    ]
+      "Added sandboxed freeform metadata to the specification version.",
+    ],
   }.freeze
 
   MARSHAL_FIELDS = { # :nodoc:
@@ -106,12 +102,8 @@ class Gem::Specification < Gem::BasicSpe
   today = Time.now.utc
   TODAY = Time.utc(today.year, today.month, today.day) # :nodoc:
 
-  # rubocop:disable Style/MutableConstant
-  LOAD_CACHE = {} # :nodoc:
-  # rubocop:enable Style/MutableConstant
-  LOAD_CACHE_MUTEX = Mutex.new
-
-  private_constant :LOAD_CACHE if defined? private_constant
+  @load_cache = {} # :nodoc:
+  @load_cache_mutex = Thread::Mutex.new
 
   VALID_NAME_PATTERN = /\A[a-zA-Z0-9\.\-\_]+\z/.freeze # :nodoc:
 
@@ -134,7 +126,7 @@ class Gem::Specification < Gem::BasicSpe
   @@default_value = {
     :authors                   => [],
     :autorequire               => nil,
-    :bindir                    => 'bin',
+    :bindir                    => "bin",
     :cert_chain                => [],
     :date                      => nil,
     :dependencies              => [],
@@ -151,7 +143,7 @@ class Gem::Specification < Gem::BasicSpe
     :platform                  => Gem::Platform::RUBY,
     :post_install_message      => nil,
     :rdoc_options              => [],
-    :require_paths             => ['lib'],
+    :require_paths             => ["lib"],
     :required_ruby_version     => Gem::Requirement.default,
     :required_rubygems_version => Gem::Requirement.default,
     :requirements              => [],
@@ -164,34 +156,41 @@ class Gem::Specification < Gem::BasicSpe
   }.freeze
 
   # rubocop:disable Style/MutableConstant
-  INITIALIZE_CODE_FOR_DEFAULTS = { } # :nodoc:
+  INITIALIZE_CODE_FOR_DEFAULTS = {} # :nodoc:
   # rubocop:enable Style/MutableConstant
 
   @@default_value.each do |k,v|
     INITIALIZE_CODE_FOR_DEFAULTS[k] = case v
-                                      when [], {}, true, false, nil, Numeric, Symbol
-                                        v.inspect
-                                      when String
-                                        v.dump
-                                      when Numeric
-                                        "default_value(:#{k})"
-                                      else
-                                        "default_value(:#{k}).dup"
-                                      end
+    when [], {}, true, false, nil, Numeric, Symbol
+      v.inspect
+    when String
+      v.dump
+    when Numeric
+      "default_value(:#{k})"
+    else
+      "default_value(:#{k}).dup"
+    end
   end
 
-  @@attributes = @@default_value.keys.sort_by { |s| s.to_s }
-  @@array_attributes = @@default_value.reject { |k,v| v != [] }.keys
+  @@attributes = @@default_value.keys.sort_by {|s| s.to_s }
+  @@array_attributes = @@default_value.reject {|k,v| v != [] }.keys
   @@nil_attributes, @@non_nil_attributes = @@default_value.keys.partition do |k|
     @@default_value[k].nil?
   end
 
-  @@stubs_by_name = {}
+  def self.clear_specs # :nodoc:
+    @@all = nil
+    @@stubs = nil
+    @@stubs_by_name = {}
+    @@spec_with_requirable_file = {}
+    @@active_stub_with_requirable_file = {}
+  end
+  private_class_method :clear_specs
+
+  clear_specs
 
   # Sentinel object to represent "not found" stubs
   NOT_FOUND = Struct.new(:to_spec, :this).new # :nodoc:
-  @@spec_with_requirable_file = {}
-  @@active_stub_with_requirable_file = {}
 
   # Tracking removed method calls to warn users during build time.
   REMOVED_METHODS = [:rubyforge_project=].freeze # :nodoc:
@@ -225,7 +224,7 @@ class Gem::Specification < Gem::BasicSpe
   attr_reader :version
 
   ##
-  # A short summary of this gem's description.  Displayed in `gem list -d`.
+  # A short summary of this gem's description.  Displayed in <tt>gem list -d</tt>.
   #
   # The #description should be more detailed than the summary.
   #
@@ -249,12 +248,11 @@ class Gem::Specification < Gem::BasicSpe
   #   require 'rake'
   #   spec.files = FileList['lib/**/*.rb',
   #                         'bin/*',
-  #                         '[A-Z]*',
-  #                         'test/**/*'].to_a
+  #                         '[A-Z]*'].to_a
   #
   #   # or without Rake...
   #   spec.files = Dir['lib/**/*.rb'] + Dir['bin/*']
-  #   spec.files += Dir['[A-Z]*'] + Dir['test/**/*']
+  #   spec.files += Dir['[A-Z]*']
   #   spec.files.reject! { |fn| fn.include? "CVS" }
 
   def files
@@ -272,7 +270,7 @@ class Gem::Specification < Gem::BasicSpe
   # A list of authors for this gem.
   #
   # Alternatively, a single author can be specified by assigning a string to
-  # `spec.author`
+  # +spec.author+
   #
   # Usage:
   #
@@ -286,6 +284,15 @@ class Gem::Specification < Gem::BasicSpe
   # :section: Recommended gemspec attributes
 
   ##
+  # The version of Ruby required by this gem
+  #
+  # Usage:
+  #
+  #   spec.required_ruby_version = '>= 2.7.0'
+
+  attr_reader :required_ruby_version
+
+  ##
   # A long description of this gem
   #
   # The description should be more detailed than the summary but not
@@ -328,17 +335,21 @@ class Gem::Specification < Gem::BasicSpe
   # This should just be the name of your license. The full text of the license
   # should be inside of the gem (at the top level) when you build it.
   #
-  # The simplest way, is to specify the standard SPDX ID
+  # The simplest way is to specify the standard SPDX ID
   # https://spdx.org/licenses/ for the license.
-  # Ideally you should pick one that is OSI (Open Source Initiative)
+  # Ideally, you should pick one that is OSI (Open Source Initiative)
   # http://opensource.org/licenses/alphabetical approved.
   #
-  # The most commonly used OSI approved licenses are MIT and Apache-2.0.
+  # The most commonly used OSI-approved licenses are MIT and Apache-2.0.
   # GitHub also provides a license picker at http://choosealicense.com/.
   #
+  # You can also use a custom license file along with your gemspec and specify
+  # a LicenseRef-<idstring>, where idstring is the name of the file containing
+  # the license text.
+  #
   # You should specify a license for your gem so that people know how they are
-  # permitted to use it, and any restrictions you're placing on it.  Not
-  # specifying a license means all rights are reserved; others have no rights
+  # permitted to use it and any restrictions you're placing on it.  Not
+  # specifying a license means all rights are reserved; others have no right
   # to use the code for any purpose.
   #
   # You can set multiple licenses with #licenses=
@@ -390,6 +401,7 @@ class Gem::Specification < Gem::BasicSpe
   #     "mailing_list_uri"  => "https://groups.example.com/bestgemever",
   #     "source_code_uri"   => "https://example.com/user/bestgemever",
   #     "wiki_uri"          => "https://example.com/user/bestgemever/wiki"
+  #     "funding_uri"       => "https://example.com/donate"
   #   }
   #
   # These links will be used on your gem's page on rubygems.org and must pass
@@ -461,7 +473,7 @@ class Gem::Specification < Gem::BasicSpe
   #   spec.platform = Gem::Platform.local
 
   def platform=(platform)
-    if @original_platform.nil? or
+    if @original_platform.nil? ||
        @original_platform == Gem::Platform::RUBY
       @original_platform = platform
     end
@@ -477,12 +489,12 @@ class Gem::Specification < Gem::BasicSpe
     # legacy constants
     when nil, Gem::Platform::RUBY then
       @new_platform = Gem::Platform::RUBY
-    when 'mswin32' then # was Gem::Platform::WIN32
-      @new_platform = Gem::Platform.new 'x86-mswin32'
-    when 'i586-linux' then # was Gem::Platform::LINUX_586
-      @new_platform = Gem::Platform.new 'x86-linux'
-    when 'powerpc-darwin' then # was Gem::Platform::DARWIN
-      @new_platform = Gem::Platform.new 'ppc-darwin'
+    when "mswin32" then # was Gem::Platform::WIN32
+      @new_platform = Gem::Platform.new "x86-mswin32"
+    when "i586-linux" then # was Gem::Platform::LINUX_586
+      @new_platform = Gem::Platform.new "x86-linux"
+    when "powerpc-darwin" then # was Gem::Platform::DARWIN
+      @new_platform = Gem::Platform.new "ppc-darwin"
     else
       @new_platform = Gem::Platform.new platform
     end
@@ -516,11 +528,6 @@ class Gem::Specification < Gem::BasicSpe
   end
 
   ##
-  # The version of Ruby required by this gem
-
-  attr_reader :required_ruby_version
-
-  ##
   # The RubyGems version required by this gem
 
   attr_reader :required_rubygems_version
@@ -560,6 +567,10 @@ class Gem::Specification < Gem::BasicSpe
   #   spec.add_runtime_dependency 'example', '~> 1.1', '>= 1.1.4'
 
   def add_runtime_dependency(gem, *requirements)
+    if requirements.uniq.size != requirements.size
+      warn "WARNING: duplicated #{gem} dependency #{requirements}"
+    end
+
     add_dependency_with_type(gem, :runtime, requirements)
   end
 
@@ -645,6 +656,8 @@ class Gem::Specification < Gem::BasicSpe
     @rdoc_options ||= []
   end
 
+  LATEST_RUBY_WITHOUT_PATCH_VERSIONS = Gem::Version.new("2.1")
+
   ##
   # The version of Ruby required by this gem.  The ruby version can be
   # specified to the patch-level:
@@ -665,9 +678,20 @@ class Gem::Specification < Gem::BasicSpe
   #
   #  # Only prereleases or final releases after 2.6.0.preview2
   #  spec.required_ruby_version = '> 2.6.0.preview2'
+  #
+  #  # This gem will work with 2.3.0 or greater, including major version 3, but lesser than 4.0.0
+  #  spec.required_ruby_version = '>= 2.3', '< 4'
 
   def required_ruby_version=(req)
     @required_ruby_version = Gem::Requirement.create req
+
+    @required_ruby_version.requirements.map! do |op, v|
+      if v >= LATEST_RUBY_WITHOUT_PATCH_VERSIONS && v.release.segments.size == 4
+        [op == "~>" ? "=" : op, Gem::Version.new(v.segments.tap {|s| s.delete_at(3) }.join("."))]
+      else
+        [op, v]
+      end
+    end
   end
 
   ##
@@ -725,7 +749,7 @@ class Gem::Specification < Gem::BasicSpe
   # Deprecated: You must now specify the executable name to  Gem.bin_path.
 
   attr_writer :default_executable
-  deprecate :default_executable=, :none,       2018, 12
+  rubygems_deprecate :default_executable=
 
   ##
   # Allows deinstallation of gems with legacy platforms.
@@ -740,23 +764,15 @@ class Gem::Specification < Gem::BasicSpe
   attr_accessor :specification_version
 
   def self._all # :nodoc:
-    unless defined?(@@all) && @@all
-      @@all = stubs.map(&:to_spec)
-
-      # After a reset, make sure already loaded specs
-      # are still marked as activated.
-      specs = {}
-      Gem.loaded_specs.each_value{|s| specs[s] = true}
-      @@all.each{|s| s.activated = true if specs[s]}
-    end
-    @@all
+    @@all ||= Gem.loaded_specs.values | stubs.map(&:to_spec)
   end
 
-  def self._clear_load_cache # :nodoc:
-    LOAD_CACHE_MUTEX.synchronize do
-      LOAD_CACHE.clear
+  def self.clear_load_cache # :nodoc:
+    @load_cache_mutex.synchronize do
+      @load_cache.clear
     end
   end
+  private_class_method :clear_load_cache
 
   def self.each_gemspec(dirs) # :nodoc:
     dirs.each do |dir|
@@ -767,7 +783,7 @@ class Gem::Specification < Gem::BasicSpe
   end
 
   def self.gemspec_stubs_in(dir, pattern)
-    Gem::Util.glob_files_in_dir(pattern, dir).map { |path| yield path }.select(&:valid?)
+    Gem::Util.glob_files_in_dir(pattern, dir).map {|path| yield path }.select(&:valid?)
   end
   private_class_method :gemspec_stubs_in
 
@@ -782,21 +798,11 @@ class Gem::Specification < Gem::BasicSpe
     dirs.flat_map do |dir|
       base_dir = File.dirname dir
       gems_dir = File.join base_dir, "gems"
-      gemspec_stubs_in(dir, pattern) { |path| yield path, base_dir, gems_dir }
+      gemspec_stubs_in(dir, pattern) {|path| yield path, base_dir, gems_dir }
     end
   end
   private_class_method :map_stubs
 
-  def self.uniq_by(list, &block) # :nodoc:
-    list.uniq(&block)
-  end
-  private_class_method :uniq_by
-
-  def self.sort_by!(list, &block)
-    list.sort_by!(&block)
-  end
-  private_class_method :sort_by!
-
   def self.each_spec(dirs) # :nodoc:
     each_gemspec(dirs) do |path|
       spec = self.load path
@@ -810,11 +816,9 @@ class Gem::Specification < Gem::BasicSpe
   def self.stubs
     @@stubs ||= begin
       pattern = "*.gemspec"
-      stubs = Gem.loaded_specs.values + installed_stubs(dirs, pattern) + default_stubs(pattern)
-      stubs = uniq_by(stubs) { |stub| stub.full_name }
+      stubs = stubs_for_pattern(pattern, false)
 
-      _resort!(stubs)
-      @@stubs_by_name = stubs.select { |s| Gem::Platform.match s.platform }.group_by(&:name)
+      @@stubs_by_name = stubs.select {|s| Gem::Platform.match_spec? s }.group_by(&:name)
       stubs
     end
   end
@@ -830,8 +834,6 @@ class Gem::Specification < Gem::BasicSpe
     end
   end
 
-  EMPTY = [].freeze # :nodoc:
-
   ##
   # Returns a Gem::StubSpecification for installed gem named +name+
   # only returns stubs that match Gem.platforms
@@ -840,23 +842,32 @@ class Gem::Specification < Gem::BasicSpe
     if @@stubs
       @@stubs_by_name[name] || []
     else
-      pattern = "#{name}-*.gemspec"
-      stubs = Gem.loaded_specs.values +
-        installed_stubs(dirs, pattern).select { |s| Gem::Platform.match s.platform } +
-        default_stubs(pattern)
-      stubs = uniq_by(stubs) { |stub| stub.full_name }.group_by(&:name)
-      stubs.each_value { |v| _resort!(v) }
-
-      @@stubs_by_name.merge! stubs
-      @@stubs_by_name[name] ||= EMPTY
+      @@stubs_by_name[name] ||= stubs_for_pattern("#{name}-*.gemspec").select do |s|
+        s.name == name
+      end
     end
   end
 
+  ##
+  # Finds stub specifications matching a pattern from the standard locations,
+  # optionally filtering out specs not matching the current platform
+  #
+  def self.stubs_for_pattern(pattern, match_platform = true) # :nodoc:
+    installed_stubs = installed_stubs(Gem::Specification.dirs, pattern)
+    installed_stubs.select! {|s| Gem::Platform.match_spec? s } if match_platform
+    stubs = installed_stubs + default_stubs(pattern)
+    stubs = stubs.uniq {|stub| stub.full_name }
+    _resort!(stubs)
+    stubs
+  end
+
   def self._resort!(specs) # :nodoc:
     specs.sort! do |a, b|
       names = a.name <=> b.name
       next names if names.nonzero?
-      b.version <=> a.version
+      versions = b.version <=> a.version
+      next versions if versions.nonzero?
+      Gem::Platform.sort_priority(b.platform)
     end
   end
 
@@ -872,6 +883,30 @@ class Gem::Specification < Gem::BasicSpe
   end
 
   ##
+  # Adds +spec+ to the known specifications, keeping the collection
+  # properly sorted.
+
+  def self.add_spec(spec)
+    return if _all.include? spec
+
+    _all << spec
+    stubs << spec
+    (@@stubs_by_name[spec.name] ||= []) << spec
+
+    _resort!(@@stubs_by_name[spec.name])
+    _resort!(stubs)
+  end
+
+  ##
+  # Removes +spec+ from the known specs.
+
+  def self.remove_spec(spec)
+    _all.delete spec.to_spec
+    stubs.delete spec
+    (@@stubs_by_name[spec.name] || []).delete spec
+  end
+
+  ##
   # Returns all specifications. This method is discouraged from use.
   # You probably want to use one of the Enumerable methods instead.
 
@@ -939,7 +974,7 @@ class Gem::Specification < Gem::BasicSpe
   def self.dirs=(dirs)
     self.reset
 
-    @@dirs = Array(dirs).map { |dir| File.join dir, "specifications" }
+    @@dirs = Array(dirs).map {|dir| File.join dir, "specifications" }
   end
 
   extend Enumerable
@@ -992,7 +1027,6 @@ class Gem::Specification < Gem::BasicSpe
   def self.find_by_path(path)
     path = path.dup.freeze
     spec = @@spec_with_requirable_file[path] ||= (stubs.find do |s|
-      next unless Gem::BundlerVersionFinder.compatible?(s)
       s.contains_requirable_file? path
     end || NOT_FOUND)
     spec.to_spec
@@ -1005,7 +1039,6 @@ class Gem::Specification < Gem::BasicSpe
   def self.find_inactive_by_path(path)
     stub = stubs.find do |s|
       next if s.activated?
-      next unless Gem::BundlerVersionFinder.compatible?(s)
       s.contains_requirable_file? path
     end
     stub && stub.to_spec
@@ -1013,7 +1046,7 @@ class Gem::Specification < Gem::BasicSpe
 
   def self.find_active_stub_by_path(path)
     stub = @@active_stub_with_requirable_file[path] ||= (stubs.find do |s|
-      s.activated? and s.contains_requirable_file? path
+      s.activated? && s.contains_requirable_file?(path)
     end || NOT_FOUND)
     stub.this
   end
@@ -1022,10 +1055,7 @@ class Gem::Specification < Gem::BasicSpe
   # Return currently unresolved specs that contain the file matching +path+.
 
   def self.find_in_unresolved(path)
-    # TODO: do we need these?? Kill it
-    specs = unresolved_deps.values.map { |dep| dep.to_specs }.flatten
-
-    specs.find_all { |spec| spec.contains_requirable_file? path }
+    unresolved_specs.find_all {|spec| spec.contains_requirable_file? path }
   end
 
   ##
@@ -1033,9 +1063,7 @@ class Gem::Specification < Gem::BasicSpe
   # specs that contain the file matching +path+.
 
   def self.find_in_unresolved_tree(path)
-    specs = unresolved_deps.values.map { |dep| dep.to_specs }.flatten
-
-    specs.each do |spec|
+    unresolved_specs.each do |spec|
       spec.traverse do |from_spec, dep, to_spec, trail|
         if to_spec.has_conflicts? || to_spec.conficts_when_loaded_with?(trail)
           :next
@@ -1048,6 +1076,11 @@ class Gem::Specification < Gem::BasicSpe
     []
   end
 
+  def self.unresolved_specs
+    unresolved_deps.values.map {|dep| dep.to_specs }.flatten
+  end
+  private_class_method :unresolved_specs
+
   ##
   # Special loader for YAML files.  When a Specification object is loaded
   # from a YAML file, it bypasses the normal Ruby object initialization
@@ -1072,6 +1105,7 @@ class Gem::Specification < Gem::BasicSpe
 
     spec.specification_version ||= NONEXISTENT_SPECIFICATION_VERSION
     spec.reset_nil_attributes_to_default
+    spec.flatten_require_paths
 
     spec
   end
@@ -1081,24 +1115,26 @@ class Gem::Specification < Gem::BasicSpe
   # +prerelease+ is true.
 
   def self.latest_specs(prerelease = false)
-    _latest_specs Gem::Specification._all, prerelease
+    _latest_specs Gem::Specification.stubs, prerelease
+  end
+
+  ##
+  # Return the latest installed spec for gem +name+.
+
+  def self.latest_spec_for(name)
+    latest_specs(true).find {|installed_spec| installed_spec.name == name }
   end
 
   def self._latest_specs(specs, prerelease = false) # :nodoc:
-    result = Hash.new { |h,k| h[k] = {} }
-    native = {}
+    result = {}
 
     specs.reverse_each do |spec|
       next if spec.version.prerelease? unless prerelease
 
-      native[spec.name] = spec.version if spec.platform == Gem::Platform::RUBY
-      result[spec.name][spec.platform] = spec
+      result[spec.name] = spec
     end
 
-    result.map(&:last).map(&:values).flatten.reject do |spec|
-      minimum = native[spec.name]
-      minimum && spec.version < minimum
-    end.sort_by{ |tup| tup.name }
+    result.map(&:last).flatten.sort_by {|tup| tup.name }
   end
 
   ##
@@ -1107,13 +1143,13 @@ class Gem::Specification < Gem::BasicSpe
   def self.load(file)
     return unless file
 
-    _spec = LOAD_CACHE_MUTEX.synchronize { LOAD_CACHE[file] }
+    _spec = @load_cache_mutex.synchronize { @load_cache[file] }
     return _spec if _spec
 
     file = file.dup.tap(&Gem::UNTAINT)
     return unless File.file?(file)
 
-    code = File.read file, :mode => 'r:UTF-8:-'
+    code = Gem.open_file(file, "r:UTF-8:-", &:read)
 
     code.tap(&Gem::UNTAINT)
 
@@ -1122,12 +1158,12 @@ class Gem::Specification < Gem::BasicSpe
 
       if Gem::Specification === _spec
         _spec.loaded_from = File.expand_path file.to_s
-        LOAD_CACHE_MUTEX.synchronize do
-          prev = LOAD_CACHE[file]
+        @load_cache_mutex.synchronize do
+          prev = @load_cache[file]
           if prev
             _spec = prev
           else
-            LOAD_CACHE[file] = _spec
+            @load_cache[file] = _spec
           end
         end
         return _spec
@@ -1155,7 +1191,7 @@ class Gem::Specification < Gem::BasicSpe
 
   def self.normalize_yaml_input(input)
     result = input.respond_to?(:read) ? input.read : input
-    result = "--- " + result unless result =~ /\A--- /
+    result = "--- " + result unless result.start_with?("--- ")
     result = result.dup
     result.gsub!(/ !!null \n/, " \n")
     # date: 2011-04-26 00:00:00.000000000Z
@@ -1172,7 +1208,7 @@ class Gem::Specification < Gem::BasicSpe
   # version as well.
 
   def self.outdated
-    outdated_and_latest_version.map { |local, _| local.name }
+    outdated_and_latest_version.map {|local, _| local.name }
   end
 
   ##
@@ -1193,12 +1229,12 @@ class Gem::Specification < Gem::BasicSpe
         Gem::Dependency.new local_spec.name, ">= #{local_spec.version}"
 
       remotes, = fetcher.search_for_dependency dependency
-      remotes  = remotes.map { |n, _| n.version }
+      remotes  = remotes.map {|n, _| n.version }
 
       latest_remote = remotes.sort.last
 
       yield [local_spec, latest_remote] if
-        latest_remote and local_spec.version < latest_remote
+        latest_remote && local_spec.version < latest_remote
     end
 
     nil
@@ -1224,13 +1260,9 @@ class Gem::Specification < Gem::BasicSpe
 
   def self.reset
     @@dirs = nil
-    Gem.pre_reset_hooks.each { |hook| hook.call }
-    @@all = nil
-    @@stubs = nil
-    @@stubs_by_name = {}
-    @@spec_with_requirable_file = {}
-    @@active_stub_with_requirable_file = {}
-    _clear_load_cache
+    Gem.pre_reset_hooks.each {|hook| hook.call }
+    clear_specs
+    clear_load_cache
     unresolved = unresolved_deps
     unless unresolved.empty?
       w = "W" + "ARN"
@@ -1241,19 +1273,19 @@ class Gem::Specification < Gem::BasicSpe
         versions = find_all_by_name(dep.name)
         unless versions.empty?
           warn "      Available/installed versions of this gem:"
-          versions.each { |s| warn "      - #{s.version}" }
+          versions.each {|s| warn "      - #{s.version}" }
         end
       end
       warn "#{w}: Clearing out unresolved specs. Try 'gem cleanup <gem>'"
       warn "Please report a bug if this causes problems."
       unresolved.clear
     end
-    Gem.post_reset_hooks.each { |hook| hook.call }
+    Gem.post_reset_hooks.each {|hook| hook.call }
   end
 
   # DOC: This method needs documented or nodoc'd
   def self.unresolved_deps
-    @unresolved_deps ||= Hash.new { |h, n| h[n] = Gem::Dependency.new n }
+    @unresolved_deps ||= Hash.new {|h, n| h[n] = Gem::Dependency.new n }
   end
 
   ##
@@ -1262,7 +1294,30 @@ class Gem::Specification < Gem::BasicSpe
   def self._load(str)
     Gem.load_yaml
 
-    array = Marshal.load str
+    array = begin
+      Marshal.load str
+    rescue ArgumentError => e
+      #
+      # Some very old marshaled specs included references to `YAML::PrivateType`
+      # and `YAML::Syck::DefaultKey` constants due to bugs in the old emitter
+      # that generated them. Workaround the issue by defining the necessary
+      # constants and retrying.
+      #
+      message = e.message
+      raise unless message.include?("YAML::")
+
+      Object.const_set "YAML", Psych unless Object.const_defined?(:YAML)
+
+      if message.include?("YAML::Syck::")
+        YAML.const_set "Syck", YAML unless YAML.const_defined?(:Syck)
+
+        YAML::Syck.const_set "DefaultKey", Class.new if message.include?("YAML::Syck::DefaultKey")
+      elsif message.include?("YAML::PrivateType")
+        YAML.const_set "PrivateType", Class.new
+      end
+
+      retry
+    end
 
     spec = Gem::Specification.new
     spec.instance_variable_set :@specification_version, array[1]
@@ -1270,22 +1325,17 @@ class Gem::Specification < Gem::BasicSpe
     current_version = CURRENT_SPECIFICATION_VERSION
 
     field_count = if spec.specification_version > current_version
-                    spec.instance_variable_set :@specification_version,
-                                               current_version
-                    MARSHAL_FIELDS[current_version]
-                  else
-                    MARSHAL_FIELDS[spec.specification_version]
-                  end
+      spec.instance_variable_set :@specification_version,
+                                 current_version
+      MARSHAL_FIELDS[current_version]
+    else
+      MARSHAL_FIELDS[spec.specification_version]
+    end
 
     if array.size < field_count
       raise TypeError, "invalid Gem::Specification format #{array.inspect}"
     end
 
-    # Cleanup any YAML::PrivateType. They only show up for an old bug
-    # where nil => null, so just convert them to nil based on the type.
-
-    array.map! { |e| e.kind_of?(YAML::PrivateType) ? nil : e }
-
     spec.instance_variable_set :@rubygems_version,          array[0]
     # spec version
     spec.instance_variable_set :@name,                      array[2]
@@ -1341,7 +1391,7 @@ class Gem::Specification < Gem::BasicSpe
       @required_rubygems_version,
       @original_platform,
       @dependencies,
-      '', # rubyforge_project
+      "", # rubyforge_project
       @email,
       @authors,
       @description,
@@ -1349,7 +1399,7 @@ class Gem::Specification < Gem::BasicSpe
       true, # has_rdoc
       @new_platform,
       @licenses,
-      @metadata
+      @metadata,
     ]
   end
 
@@ -1397,7 +1447,11 @@ class Gem::Specification < Gem::BasicSpe
         raise e
       end
 
-      specs = spec_dep.to_specs
+      begin
+        specs = spec_dep.to_specs
+      rescue Gem::MissingSpecError => e
+        raise Gem::MissingSpecError.new(e.name, e.requirement, "at: #{self.spec_file}")
+      end
 
       if specs.size == 1
         specs.first.activate
@@ -1433,7 +1487,7 @@ class Gem::Specification < Gem::BasicSpe
     self.summary              = sanitize_string(summary)
     self.description          = sanitize_string(description)
     self.post_install_message = sanitize_string(post_install_message)
-    self.authors              = authors.collect { |a| sanitize_string(a) }
+    self.authors              = authors.collect {|a| sanitize_string(a) }
   end
 
   ##
@@ -1445,13 +1499,7 @@ class Gem::Specification < Gem::BasicSpe
     # HACK the #to_s is in here because RSpec has an Array of Arrays of
     # Strings for authors.  Need a way to disallow bad values on gemspec
     # generation.  (Probably won't happen.)
-    string = string.to_s
-
-    begin
-      Builder::XChar.encode string
-    rescue NameError, NoMethodError
-      string.to_xs
-    end
+    string.to_s
   end
 
   ##
@@ -1462,7 +1510,7 @@ class Gem::Specification < Gem::BasicSpe
     return nil if executables.nil?
 
     if @bindir
-      Array(executables).map { |e| File.join(@bindir, e) }
+      Array(executables).map {|e| File.join(@bindir, e) }
     else
       executables
     end
@@ -1477,10 +1525,10 @@ class Gem::Specification < Gem::BasicSpe
 
   def add_dependency_with_type(dependency, type, requirements)
     requirements = if requirements.empty?
-                     Gem::Requirement.default
-                   else
-                     requirements.flatten
-                   end
+      Gem::Requirement.default
+    else
+      requirements.flatten
+    end
 
     unless dependency.respond_to?(:name) &&
            dependency.respond_to?(:requirement)
@@ -1509,7 +1557,7 @@ class Gem::Specification < Gem::BasicSpe
   # Singular reader for #authors.  Returns the first author in the list
 
   def author
-    val = authors and val.first
+    (val = authors) && val.first
   end
 
   ##
@@ -1544,7 +1592,7 @@ class Gem::Specification < Gem::BasicSpe
   def build_args
     if File.exist? build_info_file
       build_info = File.readlines build_info_file
-      build_info = build_info.map { |x| x.strip }
+      build_info = build_info.map {|x| x.strip }
       build_info.delete ""
       build_info
     else
@@ -1557,12 +1605,11 @@ class Gem::Specification < Gem::BasicSpe
   # the gem.build_complete file is missing.
 
   def build_extensions # :nodoc:
-    return if default_gem?
     return if extensions.empty?
-    return if installed_by_version < Gem::Version.new('2.2.0.preview.2')
+    return if default_gem?
     return if File.exist? gem_build_complete_path
     return if !File.writable?(base_dir)
-    return if !File.exist?(File.join(base_dir, 'extensions'))
+    return if !File.exist?(File.join(base_dir, "extensions"))
 
     begin
       # We need to require things in $LOAD_PATH without looking for the
@@ -1570,9 +1617,9 @@ class Gem::Specification < Gem::BasicSpe
       unresolved_deps = Gem::Specification.unresolved_deps.dup
       Gem::Specification.unresolved_deps.clear
 
-      require 'rubygems/config_file'
-      require 'rubygems/ext'
-      require 'rubygems/user_interaction'
+      require_relative "config_file"
+      require_relative "ext"
+      require_relative "user_interaction"
 
       ui = Gem::SilentUI.new
       Gem::DefaultUserInteraction.use_ui ui do
@@ -1622,7 +1669,7 @@ class Gem::Specification < Gem::BasicSpe
     conflicts = {}
     self.runtime_dependencies.each do |dep|
       spec = Gem.loaded_specs[dep.name]
-      if spec and not spec.satisfies_requirement? dep
+      if spec && !spec.satisfies_requirement?(dep)
         (conflicts[spec] ||= []) << dep
       end
     end
@@ -1636,7 +1683,7 @@ class Gem::Specification < Gem::BasicSpe
 
   def conficts_when_loaded_with?(list_of_specs) # :nodoc:
     result = list_of_specs.any? do |spec|
-      spec.dependencies.any? { |dep| dep.runtime? && (dep.name == name) && !satisfies_requirement?(dep) }
+      spec.dependencies.any? {|dep| dep.runtime? && (dep.name == name) && !satisfies_requirement?(dep) }
     end
     result
   end
@@ -1649,7 +1696,7 @@ class Gem::Specification < Gem::BasicSpe
     self.dependencies.any? do |dep|
       if dep.runtime?
         spec = Gem.loaded_specs[dep.name]
-        spec and not spec.satisfies_requirement? dep
+        spec && !spec.satisfies_requirement?(dep)
       else
         false
       end
@@ -1670,7 +1717,7 @@ class Gem::Specification < Gem::BasicSpe
 
   DateLike = Object.new # :nodoc:
   def DateLike.===(obj) # :nodoc:
-    defined?(::Date) and Date === obj
+    defined?(::Date) && Date === obj
   end
 
   DateTimeFormat = # :nodoc:
@@ -1689,26 +1736,18 @@ class Gem::Specification < Gem::BasicSpe
     # This is the cleanest, most-readable, faster-than-using-Date
     # way to do it.
     @date = case date
-            when String then
-              if DateTimeFormat =~ date
-                Time.utc($1.to_i, $2.to_i, $3.to_i)
-
-              # Workaround for where the date format output from psych isn't
-              # parsed as a Time object by syck and thus comes through as a
-              # string.
-              elsif /\A(\d{4})-(\d{2})-(\d{2}) \d{2}:\d{2}:\d{2}\.\d+?Z\z/ =~ date
-                Time.utc($1.to_i, $2.to_i, $3.to_i)
-              else
-                raise(Gem::InvalidSpecificationException,
-                      "invalid date format in specification: #{date.inspect}")
-              end
-            when Time then
-              Time.utc(date.utc.year, date.utc.month, date.utc.day)
-            when DateLike then
-              Time.utc(date.year, date.month, date.day)
-            else
-              TODAY
-            end
+    when String then
+      if DateTimeFormat =~ date
+        Time.utc($1.to_i, $2.to_i, $3.to_i)
+      else
+        raise(Gem::InvalidSpecificationException,
+              "invalid date format in specification: #{date.inspect}")
+      end
+    when Time, DateLike then
+      Time.utc(date.year, date.month, date.day)
+    else
+      TODAY
+    end
   end
 
   ##
@@ -1718,16 +1757,16 @@ class Gem::Specification < Gem::BasicSpe
   # executable now.  See Gem.bin_path.
 
   def default_executable # :nodoc:
-    if defined?(@default_executable) and @default_executable
+    if defined?(@default_executable) && @default_executable
       result = @default_executable
-    elsif @executables and @executables.size == 1
+    elsif @executables && @executables.size == 1
       result = Array(@executables).first
     else
       result = nil
     end
     result
   end
-  deprecate :default_executable,  :none,       2018, 12
+  rubygems_deprecate :default_executable
 
   ##
   # The default value for specification attribute +name+
@@ -1752,10 +1791,11 @@ class Gem::Specification < Gem::BasicSpe
   #
   #   [depending_gem, dependency, [list_of_gems_that_satisfy_dependency]]
 
-  def dependent_gems
+  def dependent_gems(check_dev=true)
     out = []
     Gem::Specification.each do |spec|
-      spec.dependencies.each do |dep|
+      deps = check_dev ? spec.dependencies : spec.runtime_dependencies
+      deps.each do |dep|
         if self.satisfies_requirement?(dep)
           sats = []
           find_all_satisfiers(dep) do |sat|
@@ -1772,7 +1812,7 @@ class Gem::Specification < Gem::BasicSpe
   # Returns all specs that matches this spec's runtime dependencies.
 
   def dependent_specs
-    runtime_dependencies.map { |dep| dep.to_specs }.flatten
+    runtime_dependencies.map {|dep| dep.to_specs }.flatten
   end
 
   ##
@@ -1786,7 +1826,7 @@ class Gem::Specification < Gem::BasicSpe
   # List of dependencies that are used for development
 
   def development_dependencies
-    dependencies.select { |d| d.type == :development }
+    dependencies.select {|d| d.type == :development }
   end
 
   ##
@@ -1798,7 +1838,7 @@ class Gem::Specification < Gem::BasicSpe
   #   spec.doc_dir 'ri' # => "/path/to/gem_repo/doc/a-1/ri"
 
   def doc_dir(type = nil)
-    @doc_dir ||= File.join base_dir, 'doc', full_name
+    @doc_dir ||= File.join base_dir, "doc", full_name
 
     if type
       File.join @doc_dir, type
@@ -1810,17 +1850,17 @@ class Gem::Specification < Gem::BasicSpe
   def encode_with(coder) # :nodoc:
     mark_version
 
-    coder.add 'name', @name
-    coder.add 'version', @version
+    coder.add "name", @name
+    coder.add "version", @version
     platform = case @original_platform
-               when nil, '' then
-                 'ruby'
-               when String then
-                 @original_platform
-               else
-                 @original_platform.to_s
-               end
-    coder.add 'platform', platform
+    when nil, "" then
+      "ruby"
+    when String then
+      @original_platform
+    else
+      @original_platform.to_s
+    end
+    coder.add "platform", platform
 
     attributes = @@attributes.map(&:to_s) - %w[name version platform]
     attributes.each do |name|
@@ -1836,7 +1876,7 @@ class Gem::Specification < Gem::BasicSpe
   # Singular accessor for #executables
 
   def executable
-    val = executables and val.first
+    (val = executables) && val.first
   end
 
   ##
@@ -1847,29 +1887,23 @@ class Gem::Specification < Gem::BasicSpe
   end
 
   ##
-  # Sets executables to +value+, ensuring it is an array. Don't
-  # use this, push onto the array instead.
+  # Sets executables to +value+, ensuring it is an array.
 
   def executables=(value)
-    # TODO: warn about setting instead of pushing
     @executables = Array(value)
   end
 
   ##
-  # Sets extensions to +extensions+, ensuring it is an array. Don't
-  # use this, push onto the array instead.
+  # Sets extensions to +extensions+, ensuring it is an array.
 
   def extensions=(extensions)
-    # TODO: warn about setting instead of pushing
     @extensions = Array extensions
   end
 
   ##
-  # Sets extra_rdoc_files to +files+, ensuring it is an array. Don't
-  # use this, push onto the array instead.
+  # Sets extra_rdoc_files to +files+, ensuring it is an array.
 
   def extra_rdoc_files=(files)
-    # TODO: warn about setting instead of pushing
     @extra_rdoc_files = Array files
   end
 
@@ -1935,7 +1969,7 @@ class Gem::Specification < Gem::BasicSpe
   def has_rdoc # :nodoc:
     true
   end
-  deprecate :has_rdoc,            :none,       2018, 12
+  rubygems_deprecate :has_rdoc
 
   ##
   # Deprecated and ignored.
@@ -1945,16 +1979,16 @@ class Gem::Specification < Gem::BasicSpe
   def has_rdoc=(ignored) # :nodoc:
     @has_rdoc = true
   end
-  deprecate :has_rdoc=,           :none,       2018, 12
+  rubygems_deprecate :has_rdoc=
 
   alias :has_rdoc? :has_rdoc # :nodoc:
-  deprecate :has_rdoc?,           :none,       2018, 12
+  rubygems_deprecate :has_rdoc?
 
   ##
   # True if this gem has files in test_files
 
   def has_unit_tests? # :nodoc:
-    not test_files.empty?
+    !test_files.empty?
   end
 
   # :stopdoc:
@@ -1970,7 +2004,9 @@ class Gem::Specification < Gem::BasicSpe
     yaml_initialize coder.tag, coder.map
   end
 
-  eval <<-RB, binding, __FILE__, __LINE__ + 1
+  eval <<-RUBY, binding, __FILE__, __LINE__ + 1
+    # frozen_string_literal: true
+
     def set_nil_attributes_to_nil
       #{@@nil_attributes.map {|key| "@#{key} = nil" }.join "; "}
     end
@@ -1980,7 +2016,7 @@ class Gem::Specification < Gem::BasicSpe
       #{@@non_nil_attributes.map {|key| "@#{key} = #{INITIALIZE_CODE_FOR_DEFAULTS[key]}" }.join ";"}
     end
     private :set_not_nil_attributes_to_default_values
-  RB
+  RUBY
 
   ##
   # Specification constructor. Assigns the default values to the attributes
@@ -2005,6 +2041,10 @@ class Gem::Specification < Gem::BasicSpe
     self.name = name if name
     self.version = version if version
 
+    if (platform = Gem.platforms.last) && platform != Gem::Platform::RUBY && platform != Gem::Platform.local
+      self.platform = platform
+    end
+
     yield self if block_given?
   end
 
@@ -2036,10 +2076,10 @@ class Gem::Specification < Gem::BasicSpe
   def base_dir
     return Gem.dir unless loaded_from
     @base_dir ||= if default_gem?
-                    File.dirname File.dirname File.dirname loaded_from
-                  else
-                    File.dirname File.dirname loaded_from
-                  end
+      File.dirname File.dirname File.dirname loaded_from
+    else
+      File.dirname File.dirname loaded_from
+    end
   end
 
   ##
@@ -2116,8 +2156,8 @@ class Gem::Specification < Gem::BasicSpe
       return
     end
 
-    if @specification_version > CURRENT_SPECIFICATION_VERSION and
-      sym.to_s =~ /=$/
+    if @specification_version > CURRENT_SPECIFICATION_VERSION &&
+       sym.to_s.end_with?("=")
       warn "ignoring #{sym} loading #{full_name}" if $DEBUG
     else
       super
@@ -2129,9 +2169,8 @@ class Gem::Specification < Gem::BasicSpe
   # probably want to build_extensions
 
   def missing_extensions?
-    return false if default_gem?
     return false if extensions.empty?
-    return false if installed_by_version < Gem::Version.new('2.2.0.preview.2')
+    return false if default_gem?
     return false if File.exist? gem_build_complete_path
 
     true
@@ -2144,7 +2183,7 @@ class Gem::Specification < Gem::BasicSpe
   #   file list.
 
   def normalize
-    if defined?(@extra_rdoc_files) and @extra_rdoc_files
+    if defined?(@extra_rdoc_files) && @extra_rdoc_files
       @extra_rdoc_files.uniq!
       @files ||= []
       @files.concat(@extra_rdoc_files)
@@ -2169,7 +2208,7 @@ class Gem::Specification < Gem::BasicSpe
   # platform.  For use with legacy gems.
 
   def original_name # :nodoc:
-    if platform == Gem::Platform::RUBY or platform.nil?
+    if platform == Gem::Platform::RUBY || platform.nil?
       "#{@name}-#{@version}"
     else
       "#{@name}-#{@version}-#{@original_platform}"
@@ -2191,7 +2230,7 @@ class Gem::Specification < Gem::BasicSpe
   end
 
   def pretty_print(q) # :nodoc:
-    q.group 2, 'Gem::Specification.new do |s|', 'end' do
+    q.group 2, "Gem::Specification.new do |s|", "end" do
       q.breakable
 
       attributes = @@attributes - [:name, :version]
@@ -2201,9 +2240,9 @@ class Gem::Specification < Gem::BasicSpe
 
       attributes.each do |attr_name|
         current_value = self.send attr_name
-        current_value = current_value.sort if %i(files test_files).include? attr_name
-        if current_value != default_value(attr_name) or
-           self.class.required_attribute? attr_name
+        current_value = current_value.sort if %i[files test_files].include? attr_name
+        if current_value != default_value(attr_name) ||
+           self.class.required_attribute?(attr_name)
 
           q.text "s.#{attr_name} = "
 
@@ -2251,11 +2290,9 @@ class Gem::Specification < Gem::BasicSpe
   end
 
   ##
-  # Sets rdoc_options to +value+, ensuring it is an array. Don't
-  # use this, push onto the array instead.
+  # Sets rdoc_options to +value+, ensuring it is an array.
 
   def rdoc_options=(options)
-    # TODO: warn about setting instead of pushing
     @rdoc_options = Array options
   end
 
@@ -2263,7 +2300,7 @@ class Gem::Specification < Gem::BasicSpe
   # Singular accessor for #require_paths
 
   def require_path
-    val = require_paths and val.first
+    (val = require_paths) && val.first
   end
 
   ##
@@ -2274,11 +2311,9 @@ class Gem::Specification < Gem::BasicSpe
   end
 
   ##
-  # Set requirements to +req+, ensuring it is an array. Don't
-  # use this, push onto the array instead.
+  # Set requirements to +req+, ensuring it is an array.
 
   def requirements=(req)
-    # TODO: warn about setting instead of pushing
     @requirements = Array req
   end
 
@@ -2290,7 +2325,7 @@ class Gem::Specification < Gem::BasicSpe
   # Returns the full path to this spec's ri directory.
 
   def ri_dir
-    @ri_dir ||= File.join base_dir, 'ri', full_name
+    @ri_dir ||= File.join base_dir, "ri", full_name
   end
 
   ##
@@ -2300,13 +2335,13 @@ class Gem::Specification < Gem::BasicSpe
   def ruby_code(obj)
     case obj
     when String             then obj.dump + ".freeze"
-    when Array              then '[' + obj.map { |x| ruby_code x }.join(", ") + ']'
+    when Array              then "[" + obj.map {|x| ruby_code x }.join(", ") + "]"
     when Hash               then
-      seg = obj.keys.sort.map { |k| "#{k.to_s.dump} => #{obj[k].to_s.dump}" }
+      seg = obj.keys.sort.map {|k| "#{k.to_s.dump} => #{obj[k].to_s.dump}" }
       "{ #{seg.join(', ')} }"
     when Gem::Version       then obj.to_s.dump
-    when DateLike           then obj.strftime('%Y-%m-%d').dump
-    when Time               then obj.strftime('%Y-%m-%d').dump
+    when DateLike           then obj.strftime("%Y-%m-%d").dump
+    when Time               then obj.strftime("%Y-%m-%d").dump
     when Numeric            then obj.inspect
     when true, false, nil   then obj.inspect
     when Gem::Platform      then "Gem::Platform.new(#{obj.to_a.inspect})"
@@ -2330,7 +2365,7 @@ class Gem::Specification < Gem::BasicSpe
   # True if this gem has the same attributes as +other+.
 
   def same_attributes?(spec)
-    @@attributes.all? { |name, default| self.send(name) == spec.send(name) }
+    @@attributes.all? {|name, default| self.send(name) == spec.send(name) }
   end
 
   private :same_attributes?
@@ -2340,14 +2375,14 @@ class Gem::Specification < Gem::BasicSpe
 
   def satisfies_requirement?(dependency)
     return @name == dependency.name &&
-      dependency.requirement.satisfied_by?(@version)
+           dependency.requirement.satisfied_by?(@version)
   end
 
   ##
   # Returns an object you can use to sort specifications in #sort_by.
 
   def sort_obj
-    [@name, @version, @new_platform == Gem::Platform::RUBY ? -1 : 1]
+    [@name, @version, Gem::Platform.sort_priority(@new_platform)]
   end
 
   ##
@@ -2394,7 +2429,7 @@ class Gem::Specification < Gem::BasicSpe
   # Singular accessor for #test_files
 
   def test_file # :nodoc:
-    val = test_files and val.first
+    (val = test_files) && val.first
   end
 
   ##
@@ -2416,7 +2451,7 @@ class Gem::Specification < Gem::BasicSpe
       @test_files = [@test_suite_file].flatten
       @test_suite_file = nil
     end
-    if defined?(@test_files) and @test_files
+    if defined?(@test_files) && @test_files
       @test_files
     else
       @test_files = []
@@ -2429,7 +2464,6 @@ class Gem::Specification < Gem::BasicSpe
   # still have their default values are omitted.
 
   def to_ruby
-    require 'openssl'
     mark_version
     result = []
     result << "# -*- encoding: utf-8 -*-"
@@ -2441,13 +2475,13 @@ class Gem::Specification < Gem::BasicSpe
 
     result << "  s.name = #{ruby_code name}"
     result << "  s.version = #{ruby_code version}"
-    unless platform.nil? or platform == Gem::Platform::RUBY
+    unless platform.nil? || platform == Gem::Platform::RUBY
       result << "  s.platform = #{ruby_code original_platform}"
     end
     result << ""
     result << "  s.required_rubygems_version = #{ruby_code required_rubygems_version} if s.respond_to? :required_rubygems_version="
 
-    if metadata and !metadata.empty?
+    if metadata && !metadata.empty?
       result << "  s.metadata = #{ruby_code metadata} if s.respond_to? :metadata="
     end
     result << "  s.require_paths = #{ruby_code raw_require_paths}"
@@ -2462,17 +2496,22 @@ class Gem::Specification < Gem::BasicSpe
       :version,
       :has_rdoc,
       :default_executable,
-      :metadata
+      :metadata,
+      :signing_key,
     ]
 
     @@attributes.each do |attr_name|
       next if handled.include? attr_name
       current_value = self.send(attr_name)
       if current_value != default_value(attr_name) || self.class.required_attribute?(attr_name)
-        result << "  s.#{attr_name} = #{ruby_code current_value}" unless current_value.is_a?(OpenSSL::PKey::RSA)
+        result << "  s.#{attr_name} = #{ruby_code current_value}"
       end
     end
 
+    if String === signing_key
+      result << "  s.signing_key = #{signing_key.dump}.freeze"
+    end
+
     if @installed_by_version
       result << nil
       result << "  s.installed_by_version = \"#{Gem::VERSION}\" if s.respond_to? :installed_by_version"
@@ -2535,14 +2574,14 @@ class Gem::Specification < Gem::BasicSpe
     # back, we have to check again here to make sure that our
     # psych code was properly loaded, and load it if not.
     unless Gem.const_defined?(:NoAliasYAMLTree)
-      require 'rubygems/psych_tree'
+      require_relative "psych_tree"
     end
 
     builder = Gem::NoAliasYAMLTree.create
     builder << self
     ast = builder.tree
 
-    require 'stringio'
+    require "stringio"
     io = StringIO.new
     io.set_encoding Encoding::UTF_8
 
@@ -2560,7 +2599,7 @@ class Gem::Specification < Gem::BasicSpe
     begin
       dependencies.each do |dep|
         next unless dep.runtime?
-        dep.to_specs.each do |dep_spec|
+        dep.matching_specs(true).each do |dep_spec|
           next if visited.has_key?(dep_spec)
           visited[dep_spec] = true
           trail.push(dep_spec)
@@ -2572,7 +2611,7 @@ class Gem::Specification < Gem::BasicSpe
           unless result == :next
             spec_name = dep_spec.name
             dep_spec.traverse(trail, visited, &block) unless
-              trail.any? { |s| s.name == spec_name }
+              trail.any? {|s| s.name == spec_name }
           end
         end
       end
@@ -2597,30 +2636,27 @@ class Gem::Specification < Gem::BasicSpe
   end
 
   def keep_only_files_and_directories
-    @executables.delete_if      { |x| File.directory?(File.join(@bindir, x)) }
-    @extensions.delete_if       { |x| File.directory?(x) && !File.symlink?(x) }
-    @extra_rdoc_files.delete_if { |x| File.directory?(x) && !File.symlink?(x) }
-    @files.delete_if            { |x| File.directory?(x) && !File.symlink?(x) }
-    @test_files.delete_if       { |x| File.directory?(x) && !File.symlink?(x) }
+    @executables.delete_if      {|x| File.directory?(File.join(@bindir, x)) }
+    @extensions.delete_if       {|x| File.directory?(x) && !File.symlink?(x) }
+    @extra_rdoc_files.delete_if {|x| File.directory?(x) && !File.symlink?(x) }
+    @files.delete_if            {|x| File.directory?(x) && !File.symlink?(x) }
+    @test_files.delete_if       {|x| File.directory?(x) && !File.symlink?(x) }
   end
 
   def validate_metadata
     Gem::SpecificationPolicy.new(self).validate_metadata
   end
+  rubygems_deprecate :validate_metadata
 
-  ##
-  # Checks that dependencies use requirements as we recommend.  Warnings are
-  # issued when dependencies are open-ended or overly strict for semantic
-  # versioning.
   def validate_dependencies
     Gem::SpecificationPolicy.new(self).validate_dependencies
   end
+  rubygems_deprecate :validate_dependencies
 
-  ##
-  # Checks to see if the files to be packaged are world-readable.
   def validate_permissions
     Gem::SpecificationPolicy.new(self).validate_permissions
   end
+  rubygems_deprecate :validate_permissions
 
   ##
   # Set the version to +version+, potentially also setting
@@ -2629,10 +2665,12 @@ class Gem::Specification < Gem::BasicSpe
 
   def version=(version)
     @version = Gem::Version.create(version)
+    return if @version.nil?
+
     # skip to set required_ruby_version when pre-released rubygems.
     # It caused to raise CircularDependencyError
     if @version.prerelease? && (@name.nil? || @name.strip != "rubygems")
-      self.required_rubygems_version = '> 1.3.1'
+      self.required_rubygems_version = "> 1.3.1"
     end
     invalidate_memoized_attributes
 
@@ -2670,9 +2708,9 @@ class Gem::Specification < Gem::BasicSpe
       default = self.default_value attribute
 
       value = case default
-              when Time, Numeric, Symbol, true, false, nil then default
-              else default.dup
-              end
+      when Time, Numeric, Symbol, true, false, nil then default
+      else default.dup
+      end
 
       instance_variable_set "@#{attribute}", value
     end
@@ -2680,11 +2718,14 @@ class Gem::Specification < Gem::BasicSpe
     @installed_by_version ||= nil
   end
 
+  def flatten_require_paths # :nodoc:
+    return unless raw_require_paths.first.is_a?(Array)
+
+    warn "#{name} #{version} includes a gemspec with `require_paths` set to an array of arrays. Newer versions of this gem might've already fixed this"
+    raw_require_paths.flatten!
+  end
+
   def raw_require_paths # :nodoc:
     @require_paths
   end
-
 end
-
-# DOC: What is this and why is it here, randomly, at the end of this file?
-Gem.clear_paths
--- ruby2.7-2.7.6.orig/lib/rubygems/specification_policy.rb
+++ ruby2.7-2.7.6/lib/rubygems/specification_policy.rb
@@ -1,14 +1,13 @@
-require 'rubygems/user_interaction'
+require_relative "user_interaction"
 
 class Gem::SpecificationPolicy
-
   include Gem::UserInteraction
 
   VALID_NAME_PATTERN = /\A[a-zA-Z0-9\.\-\_]+\z/.freeze # :nodoc:
 
   SPECIAL_CHARACTERS = /\A[#{Regexp.escape('.-_')}]+/.freeze # :nodoc:
 
-  VALID_URI_PATTERN = %r{\Ahttps?:\/\/([^\s:@]+:[^\s:@]*@)?[A-Za-z\d\-]+(\.[A-Za-z\d\-]+)+\.?(:\d{1,5})?([\/?]\S*)?\z}.freeze  # :nodoc:
+  VALID_URI_PATTERN = %r{\Ahttps?:\/\/([^\s:@]+:[^\s:@]*@)?[A-Za-z\d\-]+(\.[A-Za-z\d\-]+)+\.?(:\d{1,5})?([\/?]\S*)?\z}.freeze # :nodoc:
 
   METADATA_LINK_KEYS = %w[
     bug_tracker_uri
@@ -18,6 +17,7 @@ class Gem::SpecificationPolicy
     mailing_list_uri
     source_code_uri
     wiki_uri
+    funding_uri
   ].freeze # :nodoc:
 
   def initialize(specification)
@@ -32,13 +32,32 @@ class Gem::SpecificationPolicy
   attr_accessor :packaging
 
   ##
-  # Checks that the specification contains all required fields, and does a
-  # very basic sanity check.
+  # Does a sanity check on the specification.
   #
   # Raises InvalidSpecificationException if the spec does not pass the
   # checks.
+  #
+  # It also performs some validations that do not raise but print warning
+  # messages instead.
 
   def validate(strict = false)
+    validate_required!
+
+    validate_optional(strict) if packaging || strict
+
+    true
+  end
+
+  ##
+  # Does a sanity check on the specification.
+  #
+  # Raises InvalidSpecificationException if the spec does not pass the
+  # checks.
+  #
+  # Only runs checks that are considered necessary for the specification to be
+  # functional.
+
+  def validate_required!
     validate_nil_attributes
 
     validate_rubygems_version
@@ -65,16 +84,24 @@ class Gem::SpecificationPolicy
 
     validate_metadata
 
+    validate_licenses_length
+
+    validate_lazy_metadata
+
+    validate_duplicate_dependencies
+  end
+
+  def validate_optional(strict)
     validate_licenses
 
     validate_permissions
 
-    validate_lazy_metadata
-
     validate_values
 
     validate_dependencies
 
+    validate_extensions
+
     validate_removed_attributes
 
     if @warnings > 0
@@ -84,8 +111,6 @@ class Gem::SpecificationPolicy
         alert_warning help_text
       end
     end
-
-    true
   end
 
   ##
@@ -95,43 +120,43 @@ class Gem::SpecificationPolicy
     metadata = @specification.metadata
 
     unless Hash === metadata
-      error 'metadata must be a hash'
+      error "metadata must be a hash"
     end
 
     metadata.each do |key, value|
+      entry = "metadata['#{key}']"
       if !key.kind_of?(String)
         error "metadata keys must be a String"
       end
 
       if key.size > 128
-        error "metadata key too large (#{key.size} > 128)"
+        error "metadata key is too large (#{key.size} > 128)"
       end
 
       if !value.kind_of?(String)
-        error "metadata values must be a String"
+        error "#{entry} value must be a String"
       end
 
       if value.size > 1024
-        error "metadata value too large (#{value.size} > 1024)"
+        error "#{entry} value is too large (#{value.size} > 1024)"
       end
 
       if METADATA_LINK_KEYS.include? key
         if value !~ VALID_URI_PATTERN
-          error "metadata['#{key}'] has invalid link: #{value.inspect}"
+          error "#{entry} has invalid link: #{value.inspect}"
         end
       end
     end
   end
 
   ##
-  # Implementation for Specification#validate_dependencies
+  # Checks that no duplicate dependencies are specified.
 
-  def validate_dependencies # :nodoc:
+  def validate_duplicate_dependencies # :nodoc:
     # NOTE: see REFACTOR note in Gem::Dependency about types - this might be brittle
-    seen = Gem::Dependency::TYPES.inject({}) { |types, type| types.merge({ type => {}}) }
+    seen = Gem::Dependency::TYPES.inject({}) {|types, type| types.merge({ type => {} }) }
 
     error_messages = []
-    warning_messages = []
     @specification.dependencies.each do |dep|
       if prev = seen[dep.type][dep.name]
         error_messages << <<-MESSAGE
@@ -141,7 +166,20 @@ duplicate dependency on #{dep}, (#{prev.
       end
 
       seen[dep.type][dep.name] = dep
+    end
+    if error_messages.any?
+      error error_messages.join
+    end
+  end
 
+  ##
+  # Checks that dependencies use requirements as we recommend.  Warnings are
+  # issued when dependencies are open-ended or overly strict for semantic
+  # versioning.
+
+  def validate_dependencies # :nodoc:
+    warning_messages = []
+    @specification.dependencies.each do |dep|
       prerelease_dep = dep.requirements_list.any? do |req|
         Gem::Requirement.new(req).prerelease?
       end
@@ -150,7 +188,7 @@ duplicate dependency on #{dep}, (#{prev.
           prerelease_dep && !@specification.version.prerelease?
 
       open_ended = dep.requirement.requirements.all? do |op, version|
-        not version.prerelease? and (op == '>' or op == '>=')
+        !version.prerelease? && (op == ">" || op == ">=")
       end
 
       if open_ended
@@ -160,27 +198,24 @@ duplicate dependency on #{dep}, (#{prev.
 
         base = segments.first 2
 
-        recommendation = if (op == '>' || op == '>=') && segments == [0]
-                           "  use a bounded requirement, such as '~> x.y'"
-                         else
-                           bugfix = if op == '>'
-                                      ", '> #{dep_version}'"
-                                    elsif op == '>=' and base != segments
-                                      ", '>= #{dep_version}'"
-                                    end
-
-                           "  if #{dep.name} is semantically versioned, use:\n" \
-                           "    add_#{dep.type}_dependency '#{dep.name}', '~> #{base.join '.'}'#{bugfix}"
-                         end
+        recommendation = if (op == ">" || op == ">=") && segments == [0]
+          "  use a bounded requirement, such as '~> x.y'"
+        else
+          bugfix = if op == ">"
+            ", '> #{dep_version}'"
+          elsif op == ">=" && base != segments
+            ", '>= #{dep_version}'"
+          end
+
+          "  if #{dep.name} is semantically versioned, use:\n" \
+          "    add_#{dep.type}_dependency '#{dep.name}', '~> #{base.join '.'}'#{bugfix}"
+        end
 
         warning_messages << ["open-ended dependency on #{dep} is not recommended", recommendation].join("\n") + "\n"
       end
     end
-    if error_messages.any?
-      error error_messages.join
-    end
     if warning_messages.any?
-      warning_messages.each { |warning_message| warning warning_message }
+      warning_messages.each {|warning_message| warning warning_message }
     end
   end
 
@@ -251,13 +286,13 @@ duplicate dependency on #{dep}, (#{prev.
   def validate_require_paths
     return unless @specification.raw_require_paths.empty?
 
-    error 'specification must have at least one require_path'
+    error "specification must have at least one require_path"
   end
 
   def validate_non_files
     return unless packaging
 
-    non_files = @specification.files.reject {|x| File.file?(x) || File.symlink?(x)}
+    non_files = @specification.files.reject {|x| File.file?(x) || File.symlink?(x) }
 
     unless non_files.empty?
       error "[\"#{non_files.join "\", \""}\"] are not files"
@@ -275,14 +310,14 @@ duplicate dependency on #{dep}, (#{prev.
   def validate_specification_version
     return if @specification.specification_version.is_a?(Integer)
 
-    error 'specification_version must be an Integer (did you mean version?)'
+    error "specification_version must be an Integer (did you mean version?)"
   end
 
   def validate_platform
     platform = @specification.platform
 
     case platform
-    when Gem::Platform, Gem::Platform::RUBY  # ok
+    when Gem::Platform, Gem::Platform::RUBY # ok
     else
       error "invalid platform #{platform.inspect}, see Gem::Platform"
     end
@@ -297,15 +332,14 @@ duplicate dependency on #{dep}, (#{prev.
   def validate_array_attribute(field)
     val = @specification.send(field)
     klass = case field
-            when :dependencies then
-              Gem::Dependency
-            else
-              String
-            end
-
-    unless Array === val and val.all? {|x| x.kind_of?(klass)}
-      raise(Gem::InvalidSpecificationException,
-            "#{field} must be an Array of #{klass}")
+    when :dependencies then
+      Gem::Dependency
+    else
+      String
+    end
+
+    unless Array === val && val.all? {|x| x.kind_of?(klass) }
+      error "#{field} must be an Array of #{klass}"
     end
   end
 
@@ -315,33 +349,39 @@ duplicate dependency on #{dep}, (#{prev.
     error "authors may not be empty"
   end
 
-  def validate_licenses
+  def validate_licenses_length
     licenses = @specification.licenses
 
     licenses.each do |license|
       if license.length > 64
         error "each license must be 64 characters or less"
       end
+    end
+  end
 
+  def validate_licenses
+    licenses = @specification.licenses
+
+    licenses.each do |license|
       if !Gem::Licenses.match?(license)
         suggestions = Gem::Licenses.suggestions(license)
-        message = <<-warning
+        message = <<-WARNING
 license value '#{license}' is invalid.  Use a license identifier from
 http://spdx.org/licenses or '#{Gem::Licenses::NONSTANDARD}' for a nonstandard license.
-        warning
-        message += "Did you mean #{suggestions.map { |s| "'#{s}'"}.join(', ')}?\n" unless suggestions.nil?
+        WARNING
+        message += "Did you mean #{suggestions.map {|s| "'#{s}'" }.join(', ')}?\n" unless suggestions.nil?
         warning(message)
       end
     end
 
-    warning <<-warning if licenses.empty?
+    warning <<-WARNING if licenses.empty?
 licenses is empty, but is recommended.  Use a license identifier from
 http://spdx.org/licenses or '#{Gem::Licenses::NONSTANDARD}' for a nonstandard license.
-    warning
+    WARNING
   end
 
-  LAZY = '"FIxxxXME" or "TOxxxDO"'.gsub(/xxx/, '')
-  LAZY_PATTERN = /FI XME|TO DO/x.freeze
+  LAZY = '"FIxxxXME" or "TOxxxDO"'.gsub(/xxx/, "")
+  LAZY_PATTERN = /\AFI XME|\ATO DO/x.freeze
   HOMEPAGE_URI_PATTERN = /\A[a-z][a-z\d+.-]*:/i.freeze
 
   def validate_lazy_metadata
@@ -364,8 +404,8 @@ http://spdx.org/licenses or '#{Gem::Lice
     homepage = @specification.homepage
 
     # Make sure a homepage is valid HTTP/HTTPS URI
-    if homepage and not homepage.empty?
-      require 'uri'
+    if homepage && !homepage.empty?
+      require "uri"
       begin
         homepage_uri = URI.parse(homepage)
         unless [URI::HTTP, URI::HTTPS].member? homepage_uri.class
@@ -393,7 +433,7 @@ http://spdx.org/licenses or '#{Gem::Lice
       validate_shebang_line_in(executable)
     end
 
-    @specification.files.select { |f| File.symlink?(f) }.each do |file|
+    @specification.files.select {|f| File.symlink?(f) }.each do |file|
       warning "#{file} is a symlink, which is not supported on all platforms"
     end
   end
@@ -405,7 +445,7 @@ http://spdx.org/licenses or '#{Gem::Lice
 
   def validate_shebang_line_in(executable)
     executable_path = File.join(@specification.bindir, executable)
-    return if File.read(executable_path, 2) == '#!'
+    return if File.read(executable_path, 2) == "#!"
 
     warning "#{executable_path} is missing #! line"
   end
@@ -416,6 +456,18 @@ http://spdx.org/licenses or '#{Gem::Lice
     end
   end
 
+  def validate_extensions # :nodoc:
+    require_relative "ext"
+    builder = Gem::Ext::Builder.new(@specification)
+
+    rake_extension = @specification.extensions.any? {|s| builder.builder_for(s) == Gem::Ext::RakeBuilder }
+    rake_dependency = @specification.dependencies.any? {|d| d.name == "rake" }
+
+    warning <<-WARNING if rake_extension && !rake_dependency
+You have specified rake based extension, but rake is not added as dependency. It is recommended to add rake as a dependency in gemspec since there's no guarantee rake will be already installed.
+    WARNING
+  end
+
   def warning(statement) # :nodoc:
     @warnings += 1
 
@@ -431,5 +483,4 @@ http://spdx.org/licenses or '#{Gem::Lice
   def help_text # :nodoc:
     "See https://guides.rubygems.org/specification-reference/ for help"
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/ssl_certs/index.rubygems.org/GlobalSignRootCA.pem
+++ /dev/null
@@ -1,21 +0,0 @@
------BEGIN CERTIFICATE-----
-MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG
-A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv
-b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw
-MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i
-YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT
-aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ
-jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp
-xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp
-1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG
-snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ
-U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8
-9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E
-BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B
-AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz
-yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE
-38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP
-AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad
-DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME
-HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==
------END CERTIFICATE-----
--- ruby2.7-2.7.6.orig/lib/rubygems/ssl_certs/rubygems.global.ssl.fastly.net/DigiCertHighAssuranceEVRootCA.pem
+++ /dev/null
@@ -1,23 +0,0 @@
------BEGIN CERTIFICATE-----
-MIIDxTCCAq2gAwIBAgIQAqxcJmoLQJuPC3nyrkYldzANBgkqhkiG9w0BAQUFADBs
-MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
-d3cuZGlnaWNlcnQuY29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5j
-ZSBFViBSb290IENBMB4XDTA2MTExMDAwMDAwMFoXDTMxMTExMDAwMDAwMFowbDEL
-MAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3
-LmRpZ2ljZXJ0LmNvbTErMCkGA1UEAxMiRGlnaUNlcnQgSGlnaCBBc3N1cmFuY2Ug
-RVYgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMbM5XPm
-+9S75S0tMqbf5YE/yc0lSbZxKsPVlDRnogocsF9ppkCxxLeyj9CYpKlBWTrT3JTW
-PNt0OKRKzE0lgvdKpVMSOO7zSW1xkX5jtqumX8OkhPhPYlG++MXs2ziS4wblCJEM
-xChBVfvLWokVfnHoNb9Ncgk9vjo4UFt3MRuNs8ckRZqnrG0AFFoEt7oT61EKmEFB
-Ik5lYYeBQVCmeVyJ3hlKV9Uu5l0cUyx+mM0aBhakaHPQNAQTXKFx01p8VdteZOE3
-hzBWBOURtCmAEvF5OYiiAhF8J2a3iLd48soKqDirCmTCv2ZdlYTBoSUeh10aUAsg
-EsxBu24LUTi4S8sCAwEAAaNjMGEwDgYDVR0PAQH/BAQDAgGGMA8GA1UdEwEB/wQF
-MAMBAf8wHQYDVR0OBBYEFLE+w2kD+L9HAdSYJhoIAu9jZCvDMB8GA1UdIwQYMBaA
-FLE+w2kD+L9HAdSYJhoIAu9jZCvDMA0GCSqGSIb3DQEBBQUAA4IBAQAcGgaX3Nec
-nzyIZgYIVyHbIUf4KmeqvxgydkAQV8GK83rZEWWONfqe/EW1ntlMMUu4kehDLI6z
-eM7b41N5cdblIZQB2lWHmiRk9opmzN6cN82oNLFpmyPInngiK3BD41VHMWEZ71jF
-hS9OMPagMRYjyOfiZRYzy78aG6A9+MpeizGLYAiJLQwGXFK3xPkKmNEVX58Svnw2
-Yzi9RKR/5CYrCsSXaQ3pjOLAEFe4yHYSkVXySGnYvCoCWw9E1CAx2/S6cCZdkGCe
-vEsXCS+0yx5DaMkHJ8HSXPfqIbloEpw8nL+e/IBcm2PN7EeqJSdnoDfzAIJ9VNep
-+OkuE6N36B9K
------END CERTIFICATE-----
--- ruby2.7-2.7.6.orig/lib/rubygems/ssl_certs/rubygems.org/AddTrustExternalCARoot.pem
+++ /dev/null
@@ -1,25 +0,0 @@
------BEGIN CERTIFICATE-----
-MIIENjCCAx6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBvMQswCQYDVQQGEwJTRTEU
-MBIGA1UEChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFkZFRydXN0IEV4dGVybmFs
-IFRUUCBOZXR3b3JrMSIwIAYDVQQDExlBZGRUcnVzdCBFeHRlcm5hbCBDQSBSb290
-MB4XDTAwMDUzMDEwNDgzOFoXDTIwMDUzMDEwNDgzOFowbzELMAkGA1UEBhMCU0Ux
-FDASBgNVBAoTC0FkZFRydXN0IEFCMSYwJAYDVQQLEx1BZGRUcnVzdCBFeHRlcm5h
-bCBUVFAgTmV0d29yazEiMCAGA1UEAxMZQWRkVHJ1c3QgRXh0ZXJuYWwgQ0EgUm9v
-dDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALf3GjPm8gAELTngTlvt
-H7xsD821+iO2zt6bETOXpClMfZOfvUq8k+0DGuOPz+VtUFrWlymUWoCwSXrbLpX9
-uMq/NzgtHj6RQa1wVsfwTz/oMp50ysiQVOnGXw94nZpAPA6sYapeFI+eh6FqUNzX
-mk6vBbOmcZSccbNQYArHE504B4YCqOmoaSYYkKtMsE8jqzpPhNjfzp/haW+710LX
-a0Tkx63ubUFfclpxCDezeWWkWaCUN/cALw3CknLa0Dhy2xSoRcRdKn23tNbE7qzN
-E0S3ySvdQwAl+mG5aWpYIxG3pzOPVnVZ9c0p10a3CitlttNCbxWyuHv77+ldU9U0
-WicCAwEAAaOB3DCB2TAdBgNVHQ4EFgQUrb2YejS0Jvf6xCZU7wO94CTLVBowCwYD
-VR0PBAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wgZkGA1UdIwSBkTCBjoAUrb2YejS0
-Jvf6xCZU7wO94CTLVBqhc6RxMG8xCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRU
-cnVzdCBBQjEmMCQGA1UECxMdQWRkVHJ1c3QgRXh0ZXJuYWwgVFRQIE5ldHdvcmsx
-IjAgBgNVBAMTGUFkZFRydXN0IEV4dGVybmFsIENBIFJvb3SCAQEwDQYJKoZIhvcN
-AQEFBQADggEBALCb4IUlwtYj4g+WBpKdQZic2YR5gdkeWxQHIzZlj7DYd7usQWxH
-YINRsPkyPef89iYTx4AWpb9a/IfPeHmJIZriTAcKhjW88t5RxNKWt9x+Tu5w/Rw5
-6wwCURQtjr0W4MHfRnXnJK3s9EK0hZNwEGe6nQY1ShjTK3rMUUKhemPR5ruhxSvC
-Nr4TDea9Y355e6cJDUCrat2PisP29owaQgVR1EX1n6diIWgVIEM8med8vSTYqZEX
-c4g/VhsxOBi0cQ+azcgOno4uG+GMmIPLHzHxREzGBHNJdmAPx/i9F4BrLunMTA5a
-mnkPIAou1Z5jJh5VkpTYghdae9C8x49OhgQ=
------END CERTIFICATE-----
--- ruby2.7-2.7.6.orig/lib/rubygems/stub_specification.rb
+++ ruby2.7-2.7.6/lib/rubygems/stub_specification.rb
@@ -5,15 +5,13 @@
 # information.
 
 class Gem::StubSpecification < Gem::BasicSpecification
-
   # :nodoc:
   PREFIX = "# stub: ".freeze
 
   # :nodoc:
-  OPEN_MODE = 'r:UTF-8:-'.freeze
+  OPEN_MODE = "r:UTF-8:-".freeze
 
   class StubLine # :nodoc: all
-
     attr_reader :name, :version, :platform, :require_paths, :extensions,
                 :full_name
 
@@ -21,9 +19,9 @@ class Gem::StubSpecification < Gem::Basi
 
     # These are common require paths.
     REQUIRE_PATHS = { # :nodoc:
-      'lib'  => 'lib'.freeze,
-      'test' => 'test'.freeze,
-      'ext'  => 'ext'.freeze,
+      "lib"  => "lib".freeze,
+      "test" => "test".freeze,
+      "ext"  => "ext".freeze,
     }.freeze
 
     # These are common require path lists.  This hash is used to optimize
@@ -31,32 +29,31 @@ class Gem::StubSpecification < Gem::Basi
     # in their require paths, so lets take advantage of that by pre-allocating
     # a require path list for that case.
     REQUIRE_PATH_LIST = { # :nodoc:
-      'lib' => ['lib'].freeze
+      "lib" => ["lib"].freeze,
     }.freeze
 
     def initialize(data, extensions)
       parts          = data[PREFIX.length..-1].split(" ".freeze, 4)
       @name          = parts[0].freeze
       @version       = if Gem::Version.correct?(parts[1])
-                         Gem::Version.new(parts[1])
-                       else
-                         Gem::Version.new(0)
-                       end
+        Gem::Version.new(parts[1])
+      else
+        Gem::Version.new(0)
+      end
 
       @platform      = Gem::Platform.new parts[2]
       @extensions    = extensions
       @full_name     = if platform == Gem::Platform::RUBY
-                         "#{name}-#{version}"
-                       else
-                         "#{name}-#{version}-#{platform}"
-                       end
+        "#{name}-#{version}"
+      else
+        "#{name}-#{version}-#{platform}"
+      end
 
       path_list = parts.last
       @require_paths = REQUIRE_PATH_LIST[path_list] || path_list.split("\0".freeze).map! do |x|
         REQUIRE_PATHS[x] || x
       end
     end
-
   end
 
   def self.default_gemspec_stub(filename, base_dir, gems_dir)
@@ -113,16 +110,16 @@ class Gem::StubSpecification < Gem::Basi
       begin
         saved_lineno = $.
 
-        File.open loaded_from, OPEN_MODE do |file|
+        Gem.open_file loaded_from, OPEN_MODE do |file|
           begin
             file.readline # discard encoding line
             stubline = file.readline.chomp
             if stubline.start_with?(PREFIX)
               extensions = if /\A#{PREFIX}/ =~ file.readline.chomp
-                             $'.split "\0"
-                           else
-                             StubLine::NO_EXTENSIONS
-                           end
+                $'.split "\0"
+              else
+                StubLine::NO_EXTENSIONS
+              end
 
               @data = StubLine.new stubline, extensions
             end
@@ -188,14 +185,11 @@ class Gem::StubSpecification < Gem::Basi
 
   def to_spec
     @spec ||= if @data
-                loaded = Gem.loaded_specs[name]
-                loaded if loaded && loaded.version == version
-              end
+      loaded = Gem.loaded_specs[name]
+      loaded if loaded && loaded.version == version
+    end
 
     @spec ||= Gem::Specification.load(loaded_from)
-    @spec.ignored = @ignored if @spec
-
-    @spec
   end
 
   ##
@@ -212,5 +206,4 @@ class Gem::StubSpecification < Gem::Basi
   def stubbed?
     data.is_a? StubLine
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/syck_hack.rb
+++ /dev/null
@@ -1,79 +0,0 @@
-# frozen_string_literal: true
-# :stopdoc:
-
-# Hack to handle syck's DefaultKey bug
-#
-# This file is always loaded AFTER either syck or psych are already
-# loaded. It then looks at what constants are available and creates
-# a consistent view on all rubys.
-#
-# All this is so that there is always a YAML::Syck::DefaultKey
-# class no matter if the full yaml library has loaded or not.
-#
-
-module YAML # :nodoc:
-  # In newer 1.9.2, there is a Syck toplevel constant instead of it
-  # being underneath YAML. If so, reference it back under YAML as
-  # well.
-  if defined? ::Syck
-    # for tests that change YAML::ENGINE
-    # 1.8 does not support the second argument to const_defined?
-    remove_const :Syck rescue nil
-
-    Syck = ::Syck
-
-  # JRuby's "Syck" is called "Yecht"
-  elsif defined? YAML::Yecht
-    Syck = YAML::Yecht
-
-  # Otherwise, if there is no YAML::Syck, then we've got just psych
-  # loaded, so lets define a stub for DefaultKey.
-  elsif !defined? YAML::Syck
-    module Syck
-      class DefaultKey # :nodoc:
-      end
-    end
-  end
-
-  # Now that we've got something that is always here, define #to_s
-  # so when code tries to use this, it at least just shows up like it
-  # should.
-  module Syck
-    class DefaultKey
-
-      remove_method :to_s rescue nil
-
-      def to_s
-        '='
-      end
-
-    end
-  end
-
-  SyntaxError = Error unless defined? SyntaxError
-end
-
-# Sometime in the 1.9 dev cycle, the Syck constant was moved from under YAML
-# to be a toplevel constant. So gemspecs created under these versions of Syck
-# will have references to Syck::DefaultKey.
-#
-# So we need to be sure that we reference Syck at the toplevel too so that
-# we can always load these kind of gemspecs.
-#
-if !defined?(Syck)
-  Syck = YAML::Syck
-end
-
-# Now that we've got Syck setup in all the right places, store
-# a reference to the DefaultKey class inside Gem. We do this so that
-# if later on YAML, etc are redefined, we've still got a consistent
-# place to find the DefaultKey class for comparison.
-
-module Gem
-  # for tests that change YAML::ENGINE
-  remove_const :SyckDefaultKey if const_defined? :SyckDefaultKey
-
-  SyckDefaultKey = YAML::Syck::DefaultKey
-end
-
-# :startdoc:
--- ruby2.7-2.7.6.orig/lib/rubygems/test_case.rb
+++ /dev/null
@@ -1,1552 +0,0 @@
-# frozen_string_literal: true
-
-require 'rubygems'
-
-# If bundler gemspec exists, add to stubs
-bundler_gemspec = File.expand_path("../../../bundler/bundler.gemspec", __FILE__)
-if File.exist?(bundler_gemspec)
-  Gem::Specification.dirs.unshift File.dirname(bundler_gemspec)
-  Gem::Specification.class_variable_set :@@stubs, nil
-  Gem::Specification.stubs
-  Gem::Specification.dirs.shift
-end
-
-begin
-  gem 'minitest', '~> 5.0'
-rescue Gem::LoadError
-end
-
-begin
-  require 'simplecov'
-  SimpleCov.start do
-    add_filter "/test/"
-    add_filter "/bundler/"
-    add_filter "/lib/rubygems/resolver/molinillo"
-  end
-rescue LoadError
-end
-
-require 'bundler'
-
-require 'minitest/autorun'
-
-require 'rubygems/deprecate'
-
-require 'fileutils'
-require 'pathname'
-require 'pp'
-require 'rubygems/package'
-require 'shellwords'
-require 'tmpdir'
-require 'uri'
-require 'zlib'
-require 'benchmark' # stdlib
-require 'rubygems/mock_gem_ui'
-
-module Gem
-
-  ##
-  # Allows setting the gem path searcher.  This method is available when
-  # requiring 'rubygems/test_case'
-
-  def self.searcher=(searcher)
-    @searcher = searcher
-  end
-
-  ##
-  # Allows toggling Windows behavior.  This method is available when requiring
-  # 'rubygems/test_case'
-
-  def self.win_platform=(val)
-    @@win_platform = val
-  end
-
-  ##
-  # Allows setting path to Ruby.  This method is available when requiring
-  # 'rubygems/test_case'
-
-  def self.ruby=(ruby)
-    @ruby = ruby
-  end
-
-  ##
-  # When rubygems/test_case is required the default user interaction is a
-  # MockGemUi.
-
-  module DefaultUserInteraction
-    @ui = Gem::MockGemUi.new
-  end
-end
-
-##
-# RubyGemTestCase provides a variety of methods for testing rubygems and
-# gem-related behavior in a sandbox.  Through RubyGemTestCase you can install
-# and uninstall gems, fetch remote gems through a stub fetcher and be assured
-# your normal set of gems is not affected.
-
-class Gem::TestCase < (defined?(Minitest::Test) ? Minitest::Test : MiniTest::Unit::TestCase)
-
-  extend Gem::Deprecate
-
-  attr_accessor :fetcher # :nodoc:
-
-  attr_accessor :gem_repo # :nodoc:
-
-  attr_accessor :uri # :nodoc:
-
-  TEST_PATH = ENV.fetch('RUBYGEMS_TEST_PATH', File.expand_path('../../../test/rubygems', __FILE__))
-
-  def assert_activate(expected, *specs)
-    specs.each do |spec|
-      case spec
-      when String then
-        Gem::Specification.find_by_name(spec).activate
-      when Gem::Specification then
-        spec.activate
-      else
-        flunk spec.inspect
-      end
-    end
-
-    loaded = Gem.loaded_specs.values.map(&:full_name)
-
-    assert_equal expected.sort, loaded.sort if expected
-  end
-
-  # TODO: move to minitest
-  def assert_path_exists(path, msg = nil)
-    msg = message(msg) { "Expected path '#{path}' to exist" }
-    assert File.exist?(path), msg
-  end
-
-  def assert_directory_exists(path, msg = nil)
-    msg = message(msg) { "Expected path '#{path}' to be a directory" }
-    assert_path_exists path
-    assert File.directory?(path), msg
-  end
-
-  ##
-  # Sets the ENABLE_SHARED entry in RbConfig::CONFIG to +value+ and restores
-  # the original value when the block ends
-
-  def enable_shared(value)
-    enable_shared = RbConfig::CONFIG['ENABLE_SHARED']
-    RbConfig::CONFIG['ENABLE_SHARED'] = value
-
-    yield
-  ensure
-    if enable_shared
-      RbConfig::CONFIG['enable_shared'] = enable_shared
-    else
-      RbConfig::CONFIG.delete 'enable_shared'
-    end
-  end
-
-  ##
-  # Sets the vendordir entry in RbConfig::CONFIG to +value+ and restores the
-  # original value when the block ends
-  #
-  def vendordir(value)
-    vendordir = RbConfig::CONFIG['vendordir']
-
-    if value
-      RbConfig::CONFIG['vendordir'] = value
-    else
-      RbConfig::CONFIG.delete 'vendordir'
-    end
-
-    yield
-  ensure
-    if vendordir
-      RbConfig::CONFIG['vendordir'] = vendordir
-    else
-      RbConfig::CONFIG.delete 'vendordir'
-    end
-  end
-
-  ##
-  # Sets the bindir entry in RbConfig::CONFIG to +value+ and restores the
-  # original value when the block ends
-  #
-  def bindir(value)
-    with_clean_path_to_ruby do
-      bindir = RbConfig::CONFIG['bindir']
-
-      if value
-        RbConfig::CONFIG['bindir'] = value
-      else
-        RbConfig::CONFIG.delete 'bindir'
-      end
-
-      begin
-        yield
-      ensure
-        if bindir
-          RbConfig::CONFIG['bindir'] = bindir
-        else
-          RbConfig::CONFIG.delete 'bindir'
-        end
-      end
-    end
-  end
-
-  ##
-  # Sets the EXEEXT entry in RbConfig::CONFIG to +value+ and restores the
-  # original value when the block ends
-  #
-  def exeext(value)
-    exeext = RbConfig::CONFIG['EXEEXT']
-
-    if value
-      RbConfig::CONFIG['EXEEXT'] = value
-    else
-      RbConfig::CONFIG.delete 'EXEEXT'
-    end
-
-    yield
-  ensure
-    if exeext
-      RbConfig::CONFIG['EXEEXT'] = exeext
-    else
-      RbConfig::CONFIG.delete 'EXEEXT'
-    end
-  end
-
-  # TODO: move to minitest
-  def refute_path_exists(path, msg = nil)
-    msg = message(msg) { "Expected path '#{path}' to not exist" }
-    refute File.exist?(path), msg
-  end
-
-  def scan_make_command_lines(output)
-    output.scan(/^#{Regexp.escape make_command}(?:[[:blank:]].*)?$/)
-  end
-
-  def parse_make_command_line(line)
-    command, *args = line.shellsplit
-
-    targets = []
-    macros = {}
-
-    args.each do |arg|
-      case arg
-      when /\A(\w+)=/
-        macros[$1] = $'
-      else
-        targets << arg
-      end
-    end
-
-    targets << '' if targets.empty?
-
-    {
-      :command => command,
-      :targets => targets,
-      :macros => macros,
-    }
-  end
-
-  def assert_contains_make_command(target, output, msg = nil)
-    if output.match(/\n/)
-      msg = message(msg) do
-        'Expected output containing make command "%s": %s' % [
-          ('%s %s' % [make_command, target]).rstrip,
-          output.inspect
-        ]
-      end
-    else
-      msg = message(msg) do
-        'Expected make command "%s": %s' % [
-          ('%s %s' % [make_command, target]).rstrip,
-          output.inspect
-        ]
-      end
-    end
-
-    assert scan_make_command_lines(output).any? { |line|
-      make = parse_make_command_line(line)
-
-      if make[:targets].include?(target)
-        yield make, line if block_given?
-        true
-      else
-        false
-      end
-    }, msg
-  end
-
-  include Gem::DefaultUserInteraction
-
-  undef_method :default_test if instance_methods.include? 'default_test' or
-                                instance_methods.include? :default_test
-
-  ##
-  # #setup prepares a sandboxed location to install gems.  All installs are
-  # directed to a temporary directory.  All install plugins are removed.
-  #
-  # If the +RUBY+ environment variable is set the given path is used for
-  # Gem::ruby.  The local platform is set to <tt>i386-mswin32</tt> for Windows
-  # or <tt>i686-darwin8.10.1</tt> otherwise.
-
-  def setup
-    super
-
-    @orig_env = ENV.to_hash
-
-    ENV['GEM_VENDOR'] = nil
-    ENV['GEMRC'] = nil
-    ENV['SOURCE_DATE_EPOCH'] = nil
-
-    @current_dir = Dir.pwd
-    @fetcher     = nil
-
-    @back_ui                       = Gem::DefaultUserInteraction.ui
-    @ui                            = Gem::MockGemUi.new
-    # This needs to be a new instance since we call use_ui(@ui) when we want to
-    # capture output
-    Gem::DefaultUserInteraction.ui = Gem::MockGemUi.new
-
-    tmpdir = File.realpath Dir.tmpdir
-    tmpdir.tap(&Gem::UNTAINT)
-
-    @tempdir = File.join(tmpdir, "test_rubygems_#{$$}")
-    @tempdir.tap(&Gem::UNTAINT)
-
-    FileUtils.mkdir_p @tempdir
-
-    # This makes the tempdir consistent on Windows.
-    # Dir.tmpdir may return short path name, but Dir[Dir.tmpdir] returns long
-    # path name. https://bugs.ruby-lang.org/issues/10819
-    # File.expand_path or File.realpath doesn't convert path name to long path
-    # name. Only Dir[] (= Dir.glob) works.
-    # Short and long path name is specific to Windows filesystem.
-    if win_platform?
-      @tempdir = Dir[@tempdir][0]
-      @tempdir.tap(&Gem::UNTAINT)
-    end
-
-    @gemhome  = File.join @tempdir, 'gemhome'
-    @userhome = File.join @tempdir, 'userhome'
-    ENV["GEM_SPEC_CACHE"] = File.join @tempdir, 'spec_cache'
-
-    @orig_ruby = if ENV['RUBY']
-                   ruby = Gem.ruby
-                   Gem.ruby = ENV['RUBY']
-                   ruby
-                 end
-
-    @git = ENV['GIT'] || 'git'
-
-    Gem.ensure_gem_subdirectories @gemhome
-
-    @orig_LOAD_PATH = $LOAD_PATH.dup
-    $LOAD_PATH.map! do |s|
-      expand_path = File.realpath(s) rescue File.expand_path(s)
-      if expand_path != s
-        expand_path.tap(&Gem::UNTAINT)
-        if s.instance_variable_defined?(:@gem_prelude_index)
-          expand_path.instance_variable_set(:@gem_prelude_index, expand_path)
-        end
-        expand_path.freeze if s.frozen?
-        s = expand_path
-      end
-      s
-    end
-
-    Dir.chdir @tempdir
-
-    ENV['HOME'] = @userhome
-    Gem.instance_variable_set :@user_home, nil
-    Gem.instance_variable_set :@gemdeps, nil
-    Gem.instance_variable_set :@env_requirements_by_name, nil
-    Gem.send :remove_instance_variable, :@ruby_version if
-      Gem.instance_variables.include? :@ruby_version
-
-    FileUtils.mkdir_p @gemhome
-    FileUtils.mkdir_p @userhome
-
-    ENV['GEM_PRIVATE_KEY_PASSPHRASE'] = PRIVATE_KEY_PASSPHRASE
-
-    @default_dir = File.join @tempdir, 'default'
-    @default_spec_dir = File.join @default_dir, "specifications", "default"
-    if Gem.java_platform?
-      @orig_default_gem_home = RbConfig::CONFIG['default_gem_home']
-      RbConfig::CONFIG['default_gem_home'] = @default_dir
-    else
-      Gem.instance_variable_set(:@default_dir, @default_dir)
-    end
-    FileUtils.mkdir_p @default_spec_dir
-
-    Gem::Specification.unresolved_deps.clear
-    Gem.use_paths(@gemhome)
-
-    Gem::Security.reset
-
-    Gem.loaded_specs.clear
-    Gem.instance_variable_set(:@activated_gem_paths, 0)
-    Gem.clear_default_specs
-    Bundler.reset!
-
-    Gem.configuration.verbose = true
-    Gem.configuration.update_sources = true
-
-    Gem::RemoteFetcher.fetcher = Gem::FakeFetcher.new
-
-    @gem_repo = "http://gems.example.com/"
-    @uri = URI.parse @gem_repo
-    Gem.sources.replace [@gem_repo]
-
-    Gem.searcher = nil
-    Gem::SpecFetcher.fetcher = nil
-
-    @orig_arch = RbConfig::CONFIG['arch']
-
-    if win_platform?
-      util_set_arch 'i386-mswin32'
-    else
-      util_set_arch 'i686-darwin8.10.1'
-    end
-
-    @orig_hooks = {}
-    %w[post_install_hooks done_installing_hooks post_uninstall_hooks pre_uninstall_hooks pre_install_hooks pre_reset_hooks post_reset_hooks post_build_hooks].each do |name|
-      @orig_hooks[name] = Gem.send(name).dup
-    end
-
-    @marshal_version = "#{Marshal::MAJOR_VERSION}.#{Marshal::MINOR_VERSION}"
-    @orig_LOADED_FEATURES = $LOADED_FEATURES.dup
-  end
-
-  ##
-  # #teardown restores the process to its original state and removes the
-  # tempdir
-
-  def teardown
-    $LOAD_PATH.replace @orig_LOAD_PATH if @orig_LOAD_PATH
-    if @orig_LOADED_FEATURES
-      if @orig_LOAD_PATH
-        paths = @orig_LOAD_PATH.map {|path| File.join(File.expand_path(path), "/")}
-        ($LOADED_FEATURES - @orig_LOADED_FEATURES).each do |feat|
-          unless paths.any? {|path| feat.start_with?(path)}
-            $LOADED_FEATURES.delete(feat)
-          end
-        end
-      else
-        $LOADED_FEATURES.replace @orig_LOADED_FEATURES
-      end
-    end
-
-    RbConfig::CONFIG['arch'] = @orig_arch
-
-    if defined? Gem::RemoteFetcher
-      Gem::RemoteFetcher.fetcher = nil
-    end
-
-    Dir.chdir @current_dir
-
-    FileUtils.rm_rf @tempdir
-
-    ENV.replace(@orig_env)
-
-    Gem.ruby = @orig_ruby if @orig_ruby
-
-    if Gem.java_platform?
-      RbConfig::CONFIG['default_gem_home'] = @orig_default_gem_home
-    else
-      Gem.instance_variable_set :@default_dir, nil
-    end
-
-    Gem::Specification._clear_load_cache
-    Gem::Specification.unresolved_deps.clear
-    Gem::refresh
-
-    @orig_hooks.each do |name, hooks|
-      Gem.send(name).replace hooks
-    end
-
-    @back_ui.close
-  end
-
-  def common_installer_setup
-    common_installer_teardown
-
-    Gem.post_build do |installer|
-      @post_build_hook_arg = installer
-      true
-    end
-
-    Gem.post_install do |installer|
-      @post_install_hook_arg = installer
-    end
-
-    Gem.post_uninstall do |uninstaller|
-      @post_uninstall_hook_arg = uninstaller
-    end
-
-    Gem.pre_install do |installer|
-      @pre_install_hook_arg = installer
-      true
-    end
-
-    Gem.pre_uninstall do |uninstaller|
-      @pre_uninstall_hook_arg = uninstaller
-    end
-  end
-
-  def common_installer_teardown
-    Gem.post_build_hooks.clear
-    Gem.post_install_hooks.clear
-    Gem.done_installing_hooks.clear
-    Gem.post_reset_hooks.clear
-    Gem.post_uninstall_hooks.clear
-    Gem.pre_install_hooks.clear
-    Gem.pre_reset_hooks.clear
-    Gem.pre_uninstall_hooks.clear
-  end
-
-  ##
-  # A git_gem is used with a gem dependencies file.  The gem created here
-  # has no files, just a gem specification for the given +name+ and +version+.
-  #
-  # Yields the +specification+ to the block, if given
-
-  def git_gem(name = 'a', version = 1)
-    have_git?
-
-    directory = File.join 'git', name
-    directory = File.expand_path directory
-
-    git_spec = Gem::Specification.new name, version do |specification|
-      yield specification if block_given?
-    end
-
-    FileUtils.mkdir_p directory
-
-    gemspec = "#{name}.gemspec"
-
-    File.open File.join(directory, gemspec), 'w' do |io|
-      io.write git_spec.to_ruby
-    end
-
-    head = nil
-
-    Dir.chdir directory do
-      unless File.exist? '.git'
-        system @git, 'init', '--quiet'
-        system @git, 'config', 'user.name',  'RubyGems Tests'
-        system @git, 'config', 'user.email', 'rubygems@example'
-      end
-
-      system @git, 'add', gemspec
-      system @git, 'commit', '-a', '-m', 'a non-empty commit message', '--quiet'
-      head = Gem::Util.popen(@git, 'rev-parse', 'master').strip
-    end
-
-    return name, git_spec.version, directory, head
-  end
-
-  ##
-  # Skips this test unless you have a git executable
-
-  def have_git?
-    return if in_path? @git
-
-    skip 'cannot find git executable, use GIT environment variable to set'
-  end
-
-  def in_path?(executable) # :nodoc:
-    return true if %r%\A([A-Z]:|/)% =~ executable and File.exist? executable
-
-    ENV['PATH'].split(File::PATH_SEPARATOR).any? do |directory|
-      File.exist? File.join directory, executable
-    end
-  end
-
-  ##
-  # Builds and installs the Gem::Specification +spec+
-
-  def install_gem(spec, options = {})
-    require 'rubygems/installer'
-
-    gem = File.join @tempdir, "gems", "#{spec.full_name}.gem"
-
-    unless File.exist? gem
-      use_ui Gem::MockGemUi.new do
-        Dir.chdir @tempdir do
-          Gem::Package.build spec
-        end
-      end
-
-      gem = File.join(@tempdir, File.basename(spec.cache_file)).tap(&Gem::UNTAINT)
-    end
-
-    Gem::Installer.at(gem, options.merge({:wrappers => true})).install
-  end
-
-  ##
-  # Builds and installs the Gem::Specification +spec+ into the user dir
-
-  def install_gem_user(spec)
-    install_gem spec, :user_install => true
-  end
-
-  ##
-  # Uninstalls the Gem::Specification +spec+
-  def uninstall_gem(spec)
-    require 'rubygems/uninstaller'
-
-    Class.new(Gem::Uninstaller) do
-      def ask_if_ok(spec)
-        true
-      end
-    end.new(spec.name, :executables => true, :user_install => true).uninstall
-  end
-
-  ##
-  # Enables pretty-print for all tests
-
-  def mu_pp(obj)
-    s = String.new
-    s = PP.pp obj, s
-    s = s.force_encoding(Encoding.default_external)
-    s.chomp
-  end
-
-  ##
-  # Reads a Marshal file at +path+
-
-  def read_cache(path)
-    File.open path.dup.tap(&Gem::UNTAINT), 'rb' do |io|
-      Marshal.load io.read
-    end
-  end
-
-  ##
-  # Reads a binary file at +path+
-
-  def read_binary(path)
-    Gem.read_binary path
-  end
-
-  ##
-  # Writes a binary file to +path+ which is relative to +@gemhome+
-
-  def write_file(path)
-    path = File.join @gemhome, path unless Pathname.new(path).absolute?
-    dir = File.dirname path
-    FileUtils.mkdir_p dir unless File.directory? dir
-
-    File.open path, 'wb' do |io|
-      yield io if block_given?
-    end
-
-    path
-  end
-
-  def all_spec_names
-    Gem::Specification.map(&:full_name)
-  end
-
-  ##
-  # Creates a Gem::Specification with a minimum of extra work.  +name+ and
-  # +version+ are the gem's name and version,  platform, author, email,
-  # homepage, summary and description are defaulted.  The specification is
-  # yielded for customization.
-  #
-  # The gem is added to the installed gems in +@gemhome+ and the runtime.
-  #
-  # Use this with #write_file to build an installed gem.
-
-  def quick_gem(name, version='2')
-    require 'rubygems/specification'
-
-    spec = Gem::Specification.new do |s|
-      s.platform    = Gem::Platform::RUBY
-      s.name        = name
-      s.version     = version
-      s.author      = 'A User'
-      s.email       = 'example@example.com'
-      s.homepage    = 'http://example.com'
-      s.summary     = "this is a summary"
-      s.description = "This is a test description"
-
-      yield(s) if block_given?
-    end
-
-    Gem::Specification.map # HACK: force specs to (re-)load before we write
-
-    written_path = write_file spec.spec_file do |io|
-      io.write spec.to_ruby_for_cache
-    end
-
-    spec.loaded_from = written_path
-
-    Gem::Specification.reset
-
-    return spec
-  end
-
-  ##
-  # Builds a gem from +spec+ and places it in <tt>File.join @gemhome,
-  # 'cache'</tt>.  Automatically creates files based on +spec.files+
-
-  def util_build_gem(spec)
-    dir = spec.gem_dir
-    FileUtils.mkdir_p dir
-
-    Dir.chdir dir do
-      spec.files.each do |file|
-        next if File.exist? file
-        FileUtils.mkdir_p File.dirname(file)
-
-        File.open file, 'w' do |fp|
-          fp.puts "# #{file}"
-        end
-      end
-
-      use_ui Gem::MockGemUi.new do
-        Gem::Package.build spec
-      end
-
-      cache = spec.cache_file
-      FileUtils.mv File.basename(cache), cache
-    end
-  end
-
-  def util_remove_gem(spec)
-    FileUtils.rm_rf spec.cache_file
-    FileUtils.rm_rf spec.spec_file
-  end
-
-  ##
-  # Removes all installed gems from +@gemhome+.
-
-  def util_clear_gems
-    FileUtils.rm_rf File.join(@gemhome, "gems")
-    FileUtils.mkdir File.join(@gemhome, "gems")
-    FileUtils.rm_rf File.join(@gemhome, "specifications")
-    FileUtils.mkdir File.join(@gemhome, "specifications")
-    Gem::Specification.reset
-  end
-
-  ##
-  # Install the provided specs
-
-  def install_specs(*specs)
-    specs.each do |spec|
-      Gem::Installer.for_spec(spec).install
-    end
-
-    Gem.searcher = nil
-  end
-
-  ##
-  # Installs the provided default specs including writing the spec file
-
-  def install_default_gems(*specs)
-    install_default_specs(*specs)
-
-    specs.each do |spec|
-      File.open spec.loaded_from, 'w' do |io|
-        io.write spec.to_ruby_for_cache
-      end
-    end
-  end
-
-  ##
-  # Install the provided default specs
-
-  def install_default_specs(*specs)
-    specs.each do |spec|
-      installer = Gem::Installer.for_spec(spec, :install_as_default => true)
-      installer.install
-      Gem.register_default_spec(spec)
-    end
-  end
-
-  def loaded_spec_names
-    Gem.loaded_specs.values.map(&:full_name).sort
-  end
-
-  def unresolved_names
-    Gem::Specification.unresolved_deps.values.map(&:to_s).sort
-  end
-
-  def save_loaded_features
-    old_loaded_features = $LOADED_FEATURES.dup
-    yield
-  ensure
-    prefix = File.dirname(__FILE__) + "/"
-    new_features = ($LOADED_FEATURES - old_loaded_features)
-    old_loaded_features.concat(new_features.select {|f| f.rindex(prefix, 0)})
-    $LOADED_FEATURES.replace old_loaded_features
-  end
-
-  def new_default_spec(name, version, deps = nil, *files)
-    spec = util_spec name, version, deps
-
-    spec.loaded_from = File.join(@default_spec_dir, spec.spec_name)
-    spec.files = files
-
-    lib_dir = File.join(@tempdir, "default_gems", "lib")
-    lib_dir.instance_variable_set(:@gem_prelude_index, lib_dir)
-    $LOAD_PATH.unshift(lib_dir)
-    files.each do |file|
-      rb_path = File.join(lib_dir, file)
-      FileUtils.mkdir_p(File.dirname(rb_path))
-      File.open(rb_path, "w") do |rb|
-        rb << "# #{file}"
-      end
-    end
-
-    spec
-  end
-
-  ##
-  # Creates a spec with +name+, +version+.  +deps+ can specify the dependency
-  # or a +block+ can be given for full customization of the specification.
-
-  def util_spec(name, version = 2, deps = nil, *files) # :yields: specification
-    raise "deps or block, not both" if deps and block_given?
-
-    spec = Gem::Specification.new do |s|
-      s.platform    = Gem::Platform::RUBY
-      s.name        = name
-      s.version     = version
-      s.author      = 'A User'
-      s.email       = 'example@example.com'
-      s.homepage    = 'http://example.com'
-      s.summary     = "this is a summary"
-      s.description = "This is a test description"
-
-      s.files.push(*files) unless files.empty?
-
-      yield s if block_given?
-    end
-
-    if deps
-      # Since Hash#each is unordered in 1.8, sort the keys and iterate that
-      # way so the tests are deterministic on all implementations.
-      deps.keys.sort.each do |n|
-        spec.add_dependency n, (deps[n] || '>= 0')
-      end
-    end
-
-    unless files.empty?
-      write_file spec.spec_file do |io|
-        io.write spec.to_ruby_for_cache
-      end
-
-      util_build_gem spec
-
-      cache_file = File.join @tempdir, 'gems', "#{spec.full_name}.gem"
-      FileUtils.mkdir_p File.dirname cache_file
-      FileUtils.mv spec.cache_file, cache_file
-      FileUtils.rm spec.spec_file
-    end
-
-    return spec
-  end
-
-  ##
-  # Creates a gem with +name+, +version+ and +deps+.  The specification will
-  # be yielded before gem creation for customization.  The gem will be placed
-  # in <tt>File.join @tempdir, 'gems'</tt>.  The specification and .gem file
-  # location are returned.
-
-  def util_gem(name, version, deps = nil, &block)
-    if deps
-      block = proc do |s|
-        # Since Hash#each is unordered in 1.8, sort
-        # the keys and iterate that way so the tests are
-        # deterministic on all implementations.
-        deps.keys.sort.each do |n|
-          s.add_dependency n, (deps[n] || '>= 0')
-        end
-      end
-    end
-
-    spec = quick_gem(name, version, &block)
-
-    util_build_gem spec
-
-    cache_file = File.join @tempdir, 'gems', "#{spec.original_name}.gem"
-    FileUtils.mkdir_p File.dirname cache_file
-    FileUtils.mv spec.cache_file, cache_file
-    FileUtils.rm spec.spec_file
-
-    spec.loaded_from = nil
-
-    [spec, cache_file]
-  end
-
-  ##
-  # Gzips +data+.
-
-  def util_gzip(data)
-    out = StringIO.new
-
-    Zlib::GzipWriter.wrap out do |io|
-      io.write data
-    end
-
-    out.string
-  end
-
-  ##
-  # Creates several default gems which all have a lib/code.rb file.  The gems
-  # are not installed but are available in the cache dir.
-  #
-  # +@a1+:: gem a version 1, this is the best-described gem.
-  # +@a2+:: gem a version 2
-  # +@a3a:: gem a version 3.a
-  # +@a_evil9+:: gem a_evil version 9, use this to ensure similarly-named gems
-  #              don't collide with a.
-  # +@b2+:: gem b version 2
-  # +@c1_2+:: gem c version 1.2
-  # +@pl1+:: gem pl version 1, this gem has a legacy platform of i386-linux.
-  #
-  # Additional +prerelease+ gems may also be created:
-  #
-  # +@a2_pre+:: gem a version 2.a
-  # TODO: nuke this and fix tests. this should speed up a lot
-
-  def util_make_gems(prerelease = false)
-    @a1 = quick_gem 'a', '1' do |s|
-      s.files = %w[lib/code.rb]
-      s.require_paths = %w[lib]
-      s.date = Gem::Specification::TODAY - 86400
-      s.homepage = 'http://a.example.com'
-      s.email = %w[example@example.com example2@example.com]
-      s.authors = %w[Example Example2]
-      s.description = <<-DESC
-This line is really, really long.  So long, in fact, that it is more than eighty characters long!  The purpose of this line is for testing wrapping behavior because sometimes people don't wrap their text to eighty characters.  Without the wrapping, the text might not look good in the RSS feed.
-
-Also, a list:
-  * An entry that\'s actually kind of sort
-  * an entry that\'s really long, which will probably get wrapped funny.  That's ok, somebody wasn't thinking straight when they made it more than eighty characters.
-      DESC
-    end
-
-    init = proc do |s|
-      s.files = %w[lib/code.rb]
-      s.require_paths = %w[lib]
-    end
-
-    @a2      = quick_gem('a', '2',      &init)
-    @a3a     = quick_gem('a', '3.a',    &init)
-    @a_evil9 = quick_gem('a_evil', '9', &init)
-    @b2      = quick_gem('b', '2',      &init)
-    @c1_2    = quick_gem('c', '1.2',    &init)
-    @x       = quick_gem('x', '1',      &init)
-    @dep_x   = quick_gem('dep_x', '1') do |s|
-      s.files = %w[lib/code.rb]
-      s.require_paths = %w[lib]
-      s.add_dependency 'x', '>= 1'
-    end
-
-    @pl1 = quick_gem 'pl', '1' do |s| # l for legacy
-      s.files = %w[lib/code.rb]
-      s.require_paths = %w[lib]
-      s.platform = Gem::Platform.new 'i386-linux'
-      s.instance_variable_set :@original_platform, 'i386-linux'
-    end
-
-    if prerelease
-      @a2_pre = quick_gem('a', '2.a', &init)
-      write_file File.join(*%W[gems #{@a2_pre.original_name} lib code.rb])
-      util_build_gem @a2_pre
-    end
-
-    write_file File.join(*%W[gems #{@a1.original_name}      lib code.rb])
-    write_file File.join(*%W[gems #{@a2.original_name}      lib code.rb])
-    write_file File.join(*%W[gems #{@a3a.original_name}     lib code.rb])
-    write_file File.join(*%W[gems #{@a_evil9.original_name} lib code.rb])
-    write_file File.join(*%W[gems #{@b2.original_name}      lib code.rb])
-    write_file File.join(*%W[gems #{@c1_2.original_name}    lib code.rb])
-    write_file File.join(*%W[gems #{@pl1.original_name}     lib code.rb])
-    write_file File.join(*%W[gems #{@x.original_name}       lib code.rb])
-    write_file File.join(*%W[gems #{@dep_x.original_name}   lib code.rb])
-
-    [@a1, @a2, @a3a, @a_evil9, @b2, @c1_2, @pl1, @x, @dep_x].each do |spec|
-      util_build_gem spec
-    end
-
-    FileUtils.rm_r File.join(@gemhome, "gems", @pl1.original_name)
-  end
-
-  ##
-  # Set the platform to +arch+
-
-  def util_set_arch(arch)
-    RbConfig::CONFIG['arch'] = arch
-    platform = Gem::Platform.new arch
-
-    Gem.instance_variable_set :@platforms, nil
-    Gem::Platform.instance_variable_set :@local, nil
-
-    yield if block_given?
-
-    platform
-  end
-
-  ##
-  # Add +spec+ to +@fetcher+ serving the data in the file +path+.
-  # +repo+ indicates which repo to make +spec+ appear to be in.
-
-  def add_to_fetcher(spec, path=nil, repo=@gem_repo)
-    path ||= spec.cache_file
-    @fetcher.data["#{@gem_repo}gems/#{spec.file_name}"] = read_binary(path)
-  end
-
-  ##
-  # Sets up Gem::SpecFetcher to return information from the gems in +specs+.
-
-  def util_setup_spec_fetcher(*specs)
-    all_specs = Gem::Specification.to_a + specs
-    Gem::Specification._resort! all_specs
-
-    spec_fetcher = Gem::SpecFetcher.fetcher
-
-    prerelease, all = all_specs.partition { |spec| spec.version.prerelease?  }
-    latest = Gem::Specification._latest_specs all_specs
-
-    spec_fetcher.specs[@uri] = []
-    all.each do |spec|
-      spec_fetcher.specs[@uri] << spec.name_tuple
-    end
-
-    spec_fetcher.latest_specs[@uri] = []
-    latest.each do |spec|
-      spec_fetcher.latest_specs[@uri] << spec.name_tuple
-    end
-
-    spec_fetcher.prerelease_specs[@uri] = []
-    prerelease.each do |spec|
-      spec_fetcher.prerelease_specs[@uri] << spec.name_tuple
-    end
-
-    # HACK for test_download_to_cache
-    unless Gem::RemoteFetcher === @fetcher
-      v = Gem.marshal_version
-
-      specs = all.map { |spec| spec.name_tuple }
-      s_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic specs
-
-      latest_specs = latest.map do |spec|
-        spec.name_tuple
-      end
-
-      l_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic latest_specs
-
-      prerelease_specs = prerelease.map { |spec| spec.name_tuple }
-      p_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic prerelease_specs
-
-      @fetcher.data["#{@gem_repo}specs.#{v}.gz"]            = s_zip
-      @fetcher.data["#{@gem_repo}latest_specs.#{v}.gz"]     = l_zip
-      @fetcher.data["#{@gem_repo}prerelease_specs.#{v}.gz"] = p_zip
-
-      v = Gem.marshal_version
-
-      all_specs.each do |spec|
-        path = "#{@gem_repo}quick/Marshal.#{v}/#{spec.original_name}.gemspec.rz"
-        data = Marshal.dump spec
-        data_deflate = Zlib::Deflate.deflate data
-        @fetcher.data[path] = data_deflate
-      end
-    end
-
-    nil # force errors
-  end
-
-  ##
-  # Deflates +data+
-
-  def util_zip(data)
-    Zlib::Deflate.deflate data
-  end
-
-  def util_set_RUBY_VERSION(version, patchlevel = nil, revision = nil, description = nil, engine = "ruby", engine_version = nil)
-    if Gem.instance_variables.include? :@ruby_version
-      Gem.send :remove_instance_variable, :@ruby_version
-    end
-
-    @RUBY_VERSION        = RUBY_VERSION
-    @RUBY_PATCHLEVEL     = RUBY_PATCHLEVEL     if defined?(RUBY_PATCHLEVEL)
-    @RUBY_REVISION       = RUBY_REVISION       if defined?(RUBY_REVISION)
-    @RUBY_DESCRIPTION    = RUBY_DESCRIPTION    if defined?(RUBY_DESCRIPTION)
-    @RUBY_ENGINE         = RUBY_ENGINE
-    @RUBY_ENGINE_VERSION = RUBY_ENGINE_VERSION if defined?(RUBY_ENGINE_VERSION)
-
-    util_clear_RUBY_VERSION
-
-    Object.const_set :RUBY_VERSION,        version
-    Object.const_set :RUBY_PATCHLEVEL,     patchlevel     if patchlevel
-    Object.const_set :RUBY_REVISION,       revision       if revision
-    Object.const_set :RUBY_DESCRIPTION,    description    if description
-    Object.const_set :RUBY_ENGINE,         engine
-    Object.const_set :RUBY_ENGINE_VERSION, engine_version if engine_version
-  end
-
-  def util_restore_RUBY_VERSION
-    util_clear_RUBY_VERSION
-
-    Object.const_set :RUBY_VERSION,        @RUBY_VERSION
-    Object.const_set :RUBY_PATCHLEVEL,     @RUBY_PATCHLEVEL  if
-      defined?(@RUBY_PATCHLEVEL)
-    Object.const_set :RUBY_REVISION,       @RUBY_REVISION    if
-      defined?(@RUBY_REVISION)
-    Object.const_set :RUBY_DESCRIPTION,    @RUBY_DESCRIPTION if
-      defined?(@RUBY_DESCRIPTION)
-    Object.const_set :RUBY_ENGINE,         @RUBY_ENGINE
-    Object.const_set :RUBY_ENGINE_VERSION, @RUBY_ENGINE_VERSION if
-      defined?(@RUBY_ENGINE_VERSION)
-  end
-
-  def util_clear_RUBY_VERSION
-    Object.send :remove_const, :RUBY_VERSION
-    Object.send :remove_const, :RUBY_PATCHLEVEL     if defined?(RUBY_PATCHLEVEL)
-    Object.send :remove_const, :RUBY_REVISION       if defined?(RUBY_REVISION)
-    Object.send :remove_const, :RUBY_DESCRIPTION    if defined?(RUBY_DESCRIPTION)
-    Object.send :remove_const, :RUBY_ENGINE
-    Object.send :remove_const, :RUBY_ENGINE_VERSION if defined?(RUBY_ENGINE_VERSION)
-  end
-
-  ##
-  # Is this test being run on a Windows platform?
-
-  def self.win_platform?
-    Gem.win_platform?
-  end
-
-  ##
-  # Is this test being run on a Windows platform?
-
-  def win_platform?
-    Gem.win_platform?
-  end
-
-  ##
-  # Is this test being run on a Java platform?
-
-  def self.java_platform?
-    Gem.java_platform?
-  end
-
-  ##
-  # Is this test being run on a Java platform?
-
-  def java_platform?
-    Gem.java_platform?
-  end
-
-  ##
-  # Returns whether or not we're on a version of Ruby built with VC++ (or
-  # Borland) versus Cygwin, Mingw, etc.
-
-  def self.vc_windows?
-    RUBY_PLATFORM.match('mswin')
-  end
-
-  ##
-  # Returns whether or not we're on a version of Ruby built with VC++ (or
-  # Borland) versus Cygwin, Mingw, etc.
-
-  def vc_windows?
-    RUBY_PLATFORM.match('mswin')
-  end
-
-  ##
-  # Returns the make command for the current platform. For versions of Ruby
-  # built on MS Windows with VC++ or Borland it will return 'nmake'. On all
-  # other platforms, including Cygwin, it will return 'make'.
-
-  def self.make_command
-    ENV["make"] || ENV["MAKE"] || (vc_windows? ? 'nmake' : 'make')
-  end
-
-  ##
-  # Returns the make command for the current platform. For versions of Ruby
-  # built on MS Windows with VC++ or Borland it will return 'nmake'. On all
-  # other platforms, including Cygwin, it will return 'make'.
-
-  def make_command
-    ENV["make"] || ENV["MAKE"] || (vc_windows? ? 'nmake' : 'make')
-  end
-
-  ##
-  # Returns whether or not the nmake command could be found.
-
-  def nmake_found?
-    system('nmake /? 1>NUL 2>&1')
-  end
-
-  # In case we're building docs in a background process, this method waits for
-  # that process to exit (or if it's already been reaped, or never happened,
-  # swallows the Errno::ECHILD error).
-  def wait_for_child_process_to_exit
-    Process.wait if Process.respond_to?(:fork)
-  rescue Errno::ECHILD
-  end
-
-  ##
-  # Allows tests to use a random (but controlled) port number instead of
-  # a hardcoded one. This helps CI tools when running parallels builds on
-  # the same builder slave.
-
-  def self.process_based_port
-    @@process_based_port ||= 8000 + $$ % 1000
-  end
-
-  ##
-  # See ::process_based_port
-
-  def process_based_port
-    self.class.process_based_port
-  end
-
-  ##
-  # Allows the proper version of +rake+ to be used for the test.
-
-  def build_rake_in(good=true)
-    gem_ruby = Gem.ruby
-    Gem.ruby = @@ruby
-    env_rake = ENV["rake"]
-    rake = (good ? @@good_rake : @@bad_rake)
-    ENV["rake"] = rake
-    yield rake
-  ensure
-    Gem.ruby = gem_ruby
-    if env_rake
-      ENV["rake"] = env_rake
-    else
-      ENV.delete("rake")
-    end
-  end
-
-  ##
-  # Finds the path to the Ruby executable
-
-  def self.rubybin
-    ruby = ENV["RUBY"]
-    return ruby if ruby
-    ruby = "ruby"
-    rubyexe = "#{ruby}.exe"
-
-    3.times do
-      if File.exist? ruby and File.executable? ruby and !File.directory? ruby
-        return File.expand_path(ruby)
-      end
-      if File.exist? rubyexe and File.executable? rubyexe
-        return File.expand_path(rubyexe)
-      end
-      ruby = File.join("..", ruby)
-    end
-
-    begin
-      require "rbconfig"
-      File.join(RbConfig::CONFIG["bindir"],
-                RbConfig::CONFIG["ruby_install_name"] +
-                RbConfig::CONFIG["EXEEXT"])
-    rescue LoadError
-      "ruby"
-    end
-  end
-
-  def with_clean_path_to_ruby
-    orig_ruby = Gem.ruby
-
-    Gem.instance_variable_set :@ruby, nil
-
-    yield
-  ensure
-    Gem.instance_variable_set :@ruby, orig_ruby
-  end
-
-  class << self
-
-    # :nodoc:
-    ##
-    # Return the join path, with escaping backticks, dollars, and
-    # double-quotes.  Unlike `shellescape`, equal-sign is not escaped.
-    private
-
-    def escape_path(*path)
-      path = File.join(*path)
-      if %r'\A[-+:/=@,.\w]+\z' =~ path
-        path
-      else
-        "\"#{path.gsub(/[`$"]/, '\\&')}\""
-      end
-    end
-
-  end
-
-  @@ruby = rubybin
-  @@good_rake = "#{rubybin} #{escape_path(TEST_PATH, 'good_rake.rb')}"
-  @@bad_rake = "#{rubybin} #{escape_path(TEST_PATH, 'bad_rake.rb')}"
-
-  ##
-  # Construct a new Gem::Dependency.
-
-  def dep(name, *requirements)
-    Gem::Dependency.new name, *requirements
-  end
-
-  ##
-  # Constructs a Gem::Resolver::DependencyRequest from a
-  # Gem::Dependency +dep+, a +from_name+ and +from_version+ requesting the
-  # dependency and a +parent+ DependencyRequest
-
-  def dependency_request(dep, from_name, from_version, parent = nil)
-    remote = Gem::Source.new @uri
-
-    unless parent
-      parent_dep = dep from_name, from_version
-      parent = Gem::Resolver::DependencyRequest.new parent_dep, nil
-    end
-
-    spec = Gem::Resolver::IndexSpecification.new \
-      nil, from_name, from_version, remote, Gem::Platform::RUBY
-    activation = Gem::Resolver::ActivationRequest.new spec, parent
-
-    Gem::Resolver::DependencyRequest.new dep, activation
-  end
-
-  ##
-  # Constructs a new Gem::Requirement.
-
-  def req(*requirements)
-    return requirements.first if Gem::Requirement === requirements.first
-    Gem::Requirement.create requirements
-  end
-
-  ##
-  # Constructs a new Gem::Specification.
-
-  def spec(name, version, &block)
-    Gem::Specification.new name, v(version), &block
-  end
-
-  ##
-  # Creates a SpecFetcher pre-filled with the gems or specs defined in the
-  # block.
-  #
-  # Yields a +fetcher+ object that responds to +spec+ and +gem+.  +spec+ adds
-  # a specification to the SpecFetcher while +gem+ adds both a specification
-  # and the gem data to the RemoteFetcher so the built gem can be downloaded.
-  #
-  # If only the a-3 gem is supposed to be downloaded you can save setup
-  # time by creating only specs for the other versions:
-  #
-  #   spec_fetcher do |fetcher|
-  #     fetcher.spec 'a', 1
-  #     fetcher.spec 'a', 2, 'b' => 3 # dependency on b = 3
-  #     fetcher.gem 'a', 3 do |spec|
-  #       # spec is a Gem::Specification
-  #       # ...
-  #     end
-  #   end
-
-  def spec_fetcher(repository = @gem_repo)
-    Gem::TestCase::SpecFetcherSetup.declare self, repository do |spec_fetcher_setup|
-      yield spec_fetcher_setup if block_given?
-    end
-  end
-
-  ##
-  # Construct a new Gem::Version.
-
-  def v(string)
-    Gem::Version.create string
-  end
-
-  ##
-  # A vendor_gem is used with a gem dependencies file.  The gem created here
-  # has no files, just a gem specification for the given +name+ and +version+.
-  #
-  # Yields the +specification+ to the block, if given
-
-  def vendor_gem(name = 'a', version = 1)
-    directory = File.join 'vendor', name
-
-    FileUtils.mkdir_p directory
-
-    save_gemspec name, version, directory
-  end
-
-  ##
-  # create_gemspec creates gem specification in given +directory+ or '.'
-  # for the given +name+ and +version+.
-  #
-  # Yields the +specification+ to the block, if given
-
-  def save_gemspec(name = 'a', version = 1, directory = '.')
-    vendor_spec = Gem::Specification.new name, version do |specification|
-      yield specification if block_given?
-    end
-
-    File.open File.join(directory, "#{name}.gemspec"), 'w' do |io|
-      io.write vendor_spec.to_ruby
-    end
-
-    return name, vendor_spec.version, directory
-  end
-
-  ##
-  # The StaticSet is a static set of gem specifications used for testing only.
-  # It is available by requiring Gem::TestCase.
-
-  class StaticSet < Gem::Resolver::Set
-
-    ##
-    # A StaticSet ignores remote because it has a fixed set of gems.
-
-    attr_accessor :remote
-
-    ##
-    # Creates a new StaticSet for the given +specs+
-
-    def initialize(specs)
-      super()
-
-      @specs = specs
-
-      @remote = true
-    end
-
-    ##
-    # Adds +spec+ to this set.
-
-    def add(spec)
-      @specs << spec
-    end
-
-    ##
-    # Finds +dep+ in this set.
-
-    def find_spec(dep)
-      @specs.reverse_each do |s|
-        return s if dep.matches_spec? s
-      end
-    end
-
-    ##
-    # Finds all gems matching +dep+ in this set.
-
-    def find_all(dep)
-      @specs.find_all { |s| dep.match? s, @prerelease }
-    end
-
-    ##
-    # Loads a Gem::Specification from this set which has the given +name+,
-    # version +ver+, +platform+.  The +source+ is ignored.
-
-    def load_spec(name, ver, platform, source)
-      dep = Gem::Dependency.new name, ver
-      spec = find_spec dep
-
-      Gem::Specification.new spec.name, spec.version do |s|
-        s.platform = spec.platform
-      end
-    end
-
-    def prefetch(reqs) # :nodoc:
-    end
-
-  end
-
-  ##
-  # Loads certificate named +cert_name+ from <tt>test/rubygems/</tt>.
-
-  def self.load_cert(cert_name)
-    cert_file = cert_path cert_name
-
-    cert = File.read cert_file
-
-    OpenSSL::X509::Certificate.new cert
-  end
-
-  ##
-  # Returns the path to the certificate named +cert_name+ from
-  # <tt>test/rubygems/</tt>.
-
-  def self.cert_path(cert_name)
-    if 32 == (Time.at(2**32) rescue 32)
-      cert_file = "#{TEST_PATH}/#{cert_name}_cert_32.pem"
-
-      return cert_file if File.exist? cert_file
-    end
-
-    "#{TEST_PATH}/#{cert_name}_cert.pem"
-  end
-
-  ##
-  # Loads an RSA private key named +key_name+ with +passphrase+ in <tt>test/rubygems/</tt>
-
-  def self.load_key(key_name, passphrase = nil)
-    key_file = key_path key_name
-
-    key = File.read key_file
-
-    OpenSSL::PKey::RSA.new key, passphrase
-  end
-
-  ##
-  # Returns the path to the key named +key_name+ from <tt>test/rubygems</tt>
-
-  def self.key_path(key_name)
-    "#{TEST_PATH}/#{key_name}_key.pem"
-  end
-
-  # :stopdoc:
-  # only available in RubyGems tests
-
-  PRIVATE_KEY_PASSPHRASE = 'Foo bar'.freeze
-
-  begin
-    PRIVATE_KEY                 = load_key 'private'
-    PRIVATE_KEY_PATH            = key_path 'private'
-
-    # ENCRYPTED_PRIVATE_KEY is PRIVATE_KEY encrypted with PRIVATE_KEY_PASSPHRASE
-    ENCRYPTED_PRIVATE_KEY       = load_key 'encrypted_private', PRIVATE_KEY_PASSPHRASE
-    ENCRYPTED_PRIVATE_KEY_PATH  = key_path 'encrypted_private'
-
-    PUBLIC_KEY                  = PRIVATE_KEY.public_key
-
-    PUBLIC_CERT                 = load_cert 'public'
-    PUBLIC_CERT_PATH            = cert_path 'public'
-  rescue Errno::ENOENT
-    PRIVATE_KEY = nil
-    PUBLIC_KEY  = nil
-    PUBLIC_CERT = nil
-  end if defined?(OpenSSL::SSL)
-
-end
-
-# require dependencies that are not discoverable once GEM_HOME and GEM_PATH
-# are wiped
-begin
-  gem 'rake'
-rescue Gem::LoadError
-end
-
-begin
-  require 'rake/packagetask'
-rescue LoadError
-end
-
-begin
-  gem 'rdoc'
-  require 'rdoc'
-
-  require 'rubygems/rdoc'
-rescue LoadError, Gem::LoadError
-end
-
-begin
-  gem 'builder'
-  require 'builder/xchar'
-rescue LoadError, Gem::LoadError
-end
-
-require 'rubygems/test_utilities'
--- ruby2.7-2.7.6.orig/lib/rubygems/test_utilities.rb
+++ /dev/null
@@ -1,380 +0,0 @@
-# frozen_string_literal: true
-require 'tempfile'
-require 'rubygems'
-require 'rubygems/remote_fetcher'
-
-##
-# A fake Gem::RemoteFetcher for use in tests or to avoid real live HTTP
-# requests when testing code that uses RubyGems.
-#
-# Example:
-#
-#   @fetcher = Gem::FakeFetcher.new
-#   @fetcher.data['http://gems.example.com/yaml'] = source_index.to_yaml
-#   Gem::RemoteFetcher.fetcher = @fetcher
-#
-#   use nested array if multiple response is needed
-#
-#   @fetcher.data['http://gems.example.com/sequence'] = [['Success', 200, 'OK'], ['Failed', 401, 'Unauthorized']]
-#
-#   @fetcher.fetch_path('http://gems.example.com/sequence') # => ['Success', 200, 'OK']
-#   @fetcher.fetch_path('http://gems.example.com/sequence') # => ['Failed', 401, 'Unauthorized']
-#
-#   # invoke RubyGems code
-#
-#   paths = @fetcher.paths
-#   assert_equal 'http://gems.example.com/yaml', paths.shift
-#   assert paths.empty?, paths.join(', ')
-#
-# See RubyGems' tests for more examples of FakeFetcher.
-
-class Gem::FakeFetcher
-
-  attr_reader :data
-  attr_reader :last_request
-  attr_accessor :paths
-
-  def initialize
-    @data = {}
-    @paths = []
-  end
-
-  def find_data(path, nargs = 3)
-    return File.read path.path if URI === path and 'file' == path.scheme
-
-    if URI === path and "URI::#{path.scheme.upcase}" != path.class.name
-      raise ArgumentError,
-        "mismatch for scheme #{path.scheme} and class #{path.class}"
-    end
-
-    path = path.to_s
-    @paths << path
-    raise ArgumentError, 'need full URI' unless path =~ %r'^https?://'
-
-    unless @data.key? path
-      raise Gem::RemoteFetcher::FetchError.new("no data for #{path}", path)
-    end
-
-    data = @data[path]
-
-    data.flatten! and return data.shift(nargs) if data.respond_to?(:flatten!)
-    data
-  end
-
-  def fetch_path(path, mtime = nil, head = false)
-    data = find_data(path)
-
-    if data.respond_to?(:call)
-      data.call
-    else
-      if path.to_s =~ /gz$/ and not data.nil? and not data.empty?
-        data = Gem::Util.gunzip data
-      end
-      data
-    end
-  end
-
-  def cache_update_path(uri, path = nil, update = true)
-    if data = fetch_path(uri)
-      open(path, 'wb') { |io| io.write data } if path and update
-      data
-    else
-      Gem.read_binary(path) if path
-    end
-  end
-
-  # Thanks, FakeWeb!
-  def open_uri_or_path(path)
-    data = find_data(path)
-    body, code, msg = data
-
-    response = Net::HTTPResponse.send(:response_class, code.to_s).new("1.0", code.to_s, msg)
-    response.instance_variable_set(:@body, body)
-    response.instance_variable_set(:@read, true)
-    response
-  end
-
-  def request(uri, request_class, last_modified = nil)
-    data = find_data(uri)
-    body, code, msg = (data.respond_to?(:call) ? data.call : data)
-
-    @last_request = request_class.new uri.request_uri
-    yield @last_request if block_given?
-
-    response = Net::HTTPResponse.send(:response_class, code.to_s).new("1.0", code.to_s, msg)
-    response.instance_variable_set(:@body, body)
-    response.instance_variable_set(:@read, true)
-    response
-  end
-
-  def pretty_print(q) # :nodoc:
-    q.group 2, '[FakeFetcher', ']' do
-      q.breakable
-      q.text 'URIs:'
-
-      q.breakable
-      q.pp @data.keys
-    end
-  end
-
-  def fetch_size(path)
-    path = path.to_s
-    @paths << path
-
-    raise ArgumentError, 'need full URI' unless path =~ %r'^http://'
-
-    unless @data.key? path
-      raise Gem::RemoteFetcher::FetchError.new("no data for #{path}", path)
-    end
-
-    data = @data[path]
-
-    data.respond_to?(:call) ? data.call : data.length
-  end
-
-  def download(spec, source_uri, install_dir = Gem.dir)
-    name = File.basename spec.cache_file
-    path = if Dir.pwd == install_dir  # see fetch_command
-             install_dir
-           else
-             File.join install_dir, "cache"
-           end
-
-    path = File.join path, name
-
-    if source_uri =~ /^http/
-      File.open(path, "wb") do |f|
-        f.write fetch_path(File.join(source_uri, "gems", name))
-      end
-    else
-      FileUtils.cp source_uri, path
-    end
-
-    path
-  end
-
-  def download_to_cache(dependency)
-    found, _ = Gem::SpecFetcher.fetcher.spec_for_dependency dependency
-
-    return if found.empty?
-
-    spec, source = found.first
-
-    download spec, source.uri.to_s
-  end
-
-end
-
-# :stopdoc:
-class Gem::RemoteFetcher
-
-  def self.fetcher=(fetcher)
-    @fetcher = fetcher
-  end
-
-end
-# :startdoc:
-
-##
-# The SpecFetcherSetup allows easy setup of a remote source in RubyGems tests:
-#
-#   spec_fetcher do |f|
-#     f.gem  'a', 1
-#     f.spec 'a', 2
-#     f.gem  'b', 1' 'a' => '~> 1.0'
-#   end
-#
-# The above declaration creates two gems, a-1 and b-1, with a dependency from
-# b to a.  The declaration creates an additional spec a-2, but no gem for it
-# (so it cannot be installed).
-#
-# After the gems are created they are removed from Gem.dir.
-
-class Gem::TestCase::SpecFetcherSetup
-
-  ##
-  # Executes a SpecFetcher setup block.  Yields an instance then creates the
-  # gems and specifications defined in the instance.
-
-  def self.declare(test, repository)
-    setup = new test, repository
-
-    yield setup
-
-    setup.execute
-  end
-
-  def initialize(test, repository) # :nodoc:
-    @test       = test
-    @repository = repository
-
-    @gems       = {}
-    @downloaded = []
-    @installed  = []
-    @operations = []
-  end
-
-  ##
-  # Returns a Hash of created Specification full names and the corresponding
-  # Specification.
-
-  def created_specs
-    created = {}
-
-    @gems.keys.each do |spec|
-      created[spec.full_name] = spec
-    end
-
-    created
-  end
-
-  ##
-  # Creates any defined gems or specifications
-
-  def execute # :nodoc:
-    execute_operations
-
-    setup_fetcher
-
-    created_specs
-  end
-
-  def execute_operations # :nodoc:
-    @operations.each do |operation, *arguments|
-      block = arguments.pop
-      case operation
-      when :gem then
-        spec, gem = @test.util_gem(*arguments, &block)
-
-        write_spec spec
-
-        @gems[spec] = gem
-        @installed << spec
-      when :download then
-        spec, gem = @test.util_gem(*arguments, &block)
-
-        @gems[spec] = gem
-        @downloaded << spec
-      when :spec then
-        spec = @test.util_spec(*arguments, &block)
-
-        write_spec spec
-
-        @gems[spec] = nil
-        @installed << spec
-      end
-    end
-  end
-
-  ##
-  # Creates a gem with +name+, +version+ and +deps+.  The created gem can be
-  # downloaded and installed.
-  #
-  # The specification will be yielded before gem creation for customization,
-  # but only the block or the dependencies may be set, not both.
-
-  def gem(name, version, dependencies = nil, &block)
-    @operations << [:gem, name, version, dependencies, block]
-  end
-
-  ##
-  # Creates a gem with +name+, +version+ and +deps+.  The created gem is
-  # downloaded in to the cache directory but is not installed
-  #
-  # The specification will be yielded before gem creation for customization,
-  # but only the block or the dependencies may be set, not both.
-
-  def download(name, version, dependencies = nil, &block)
-    @operations << [:download, name, version, dependencies, block]
-  end
-
-  ##
-  # Creates a legacy platform spec with the name 'pl' and version 1
-
-  def legacy_platform
-    spec 'pl', 1 do |s|
-      s.platform = Gem::Platform.new 'i386-linux'
-      s.instance_variable_set :@original_platform, 'i386-linux'
-    end
-  end
-
-  def setup_fetcher # :nodoc:
-    require 'zlib'
-    require 'socket'
-    require 'rubygems/remote_fetcher'
-
-    unless @test.fetcher
-      @test.fetcher = Gem::FakeFetcher.new
-      Gem::RemoteFetcher.fetcher = @test.fetcher
-    end
-
-    Gem::Specification.reset
-
-    begin
-      gem_repo, @test.gem_repo = @test.gem_repo, @repository
-      @test.uri = URI @repository
-
-      @test.util_setup_spec_fetcher(*@downloaded)
-    ensure
-      @test.gem_repo = gem_repo
-      @test.uri = URI gem_repo
-    end
-
-    @gems.each do |spec, gem|
-      next unless gem
-
-      @test.fetcher.data["#{@repository}gems/#{spec.file_name}"] =
-        Gem.read_binary(gem)
-
-      FileUtils.cp gem, spec.cache_file
-    end
-  end
-
-  ##
-  # Creates a spec with +name+, +version+ and +deps+.  The created gem can be
-  # downloaded and installed.
-  #
-  # The specification will be yielded before creation for customization,
-  # but only the block or the dependencies may be set, not both.
-
-  def spec(name, version, dependencies = nil, &block)
-    @operations << [:spec, name, version, dependencies, block]
-  end
-
-  def write_spec(spec) # :nodoc:
-    File.open spec.spec_file, 'w' do |io|
-      io.write spec.to_ruby_for_cache
-    end
-  end
-
-end
-
-##
-# A StringIO duck-typed class that uses Tempfile instead of String as the
-# backing store.
-#
-# This is available when rubygems/test_utilities is required.
-#--
-# This class was added to flush out problems in Rubinius' IO implementation.
-
-class TempIO < Tempfile
-
-  ##
-  # Creates a new TempIO that will be initialized to contain +string+.
-
-  def initialize(string = '')
-    super "TempIO"
-    binmode
-    write string
-    rewind
-  end
-
-  ##
-  # The content of the TempIO as a String.
-
-  def string
-    flush
-    Gem.read_binary path
-  end
-
-end
--- ruby2.7-2.7.6.orig/lib/rubygems/text.rb
+++ ruby2.7-2.7.6/lib/rubygems/text.rb
@@ -49,37 +49,38 @@ module Gem::Text
     end
   end
 
-  # This code is based directly on the Text gem implementation
   # Returns a value representing the "cost" of transforming str1 into str2
+  # Vendored version of DidYouMean::Levenshtein.distance from the ruby/did_you_mean gem @ 1.4.0
+  # https://git.io/JJgZI
   def levenshtein_distance(str1, str2)
-    s = str1
-    t = str2
-    n = s.length
-    m = t.length
-
-    return m if (0 == n)
-    return n if (0 == m)
+    n = str1.length
+    m = str2.length
+    return m if n.zero?
+    return n if m.zero?
 
     d = (0..m).to_a
     x = nil
 
-    str1.each_char.each_with_index do |char1,i|
-      e = i + 1
+    # to avoid duplicating an enumerable object, create it outside of the loop
+    str2_codepoints = str2.codepoints
 
-      str2.each_char.each_with_index do |char2,j|
-        cost = (char1 == char2) ? 0 : 1
+    str1.each_codepoint.with_index(1) do |char1, i|
+      j = 0
+      while j < m
+        cost = (char1 == str2_codepoints[j]) ? 0 : 1
         x = min3(
-             d[j + 1] + 1, # insertion
-             e + 1,      # deletion
-             d[j] + cost # substitution
-           )
-        d[j] = e
-        e = x
-      end
+          d[j + 1] + 1, # insertion
+          i + 1,      # deletion
+          d[j] + cost # substitution
+        )
+        d[j] = i
+        i = x
 
+        j += 1
+      end
       d[m] = x
     end
 
-    return x
+    x
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/tsort.rb
@@ -0,0 +1,3 @@
+# frozen_string_literal: true
+
+require_relative "tsort/lib/tsort"
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/tsort/.document
@@ -0,0 +1 @@
+# Vendored files do not need to be documented
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/tsort/LICENSE.txt
@@ -0,0 +1,22 @@
+Copyright (C) 1993-2013 Yukihiro Matsumoto. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/tsort/lib/tsort.rb
@@ -0,0 +1,454 @@
+# frozen_string_literal: true
+
+#--
+# tsort.rb - provides a module for topological sorting and strongly connected components.
+#++
+#
+
+#
+# Gem::TSort implements topological sorting using Tarjan's algorithm for
+# strongly connected components.
+#
+# Gem::TSort is designed to be able to be used with any object which can be
+# interpreted as a directed graph.
+#
+# Gem::TSort requires two methods to interpret an object as a graph,
+# tsort_each_node and tsort_each_child.
+#
+# * tsort_each_node is used to iterate for all nodes over a graph.
+# * tsort_each_child is used to iterate for child nodes of a given node.
+#
+# The equality of nodes are defined by eql? and hash since
+# Gem::TSort uses Hash internally.
+#
+# == A Simple Example
+#
+# The following example demonstrates how to mix the Gem::TSort module into an
+# existing class (in this case, Hash). Here, we're treating each key in
+# the hash as a node in the graph, and so we simply alias the required
+# #tsort_each_node method to Hash's #each_key method. For each key in the
+# hash, the associated value is an array of the node's child nodes. This
+# choice in turn leads to our implementation of the required #tsort_each_child
+# method, which fetches the array of child nodes and then iterates over that
+# array using the user-supplied block.
+#
+#   require 'rubygems/tsort/lib/tsort'
+#
+#   class Hash
+#     include Gem::TSort
+#     alias tsort_each_node each_key
+#     def tsort_each_child(node, &block)
+#       fetch(node).each(&block)
+#     end
+#   end
+#
+#   {1=>[2, 3], 2=>[3], 3=>[], 4=>[]}.tsort
+#   #=> [3, 2, 1, 4]
+#
+#   {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}.strongly_connected_components
+#   #=> [[4], [2, 3], [1]]
+#
+# == A More Realistic Example
+#
+# A very simple `make' like tool can be implemented as follows:
+#
+#   require 'rubygems/tsort/lib/tsort'
+#
+#   class Make
+#     def initialize
+#       @dep = {}
+#       @dep.default = []
+#     end
+#
+#     def rule(outputs, inputs=[], &block)
+#       triple = [outputs, inputs, block]
+#       outputs.each {|f| @dep[f] = [triple]}
+#       @dep[triple] = inputs
+#     end
+#
+#     def build(target)
+#       each_strongly_connected_component_from(target) {|ns|
+#         if ns.length != 1
+#           fs = ns.delete_if {|n| Array === n}
+#           raise Gem::TSort::Cyclic.new("cyclic dependencies: #{fs.join ', '}")
+#         end
+#         n = ns.first
+#         if Array === n
+#           outputs, inputs, block = n
+#           inputs_time = inputs.map {|f| File.mtime f}.max
+#           begin
+#             outputs_time = outputs.map {|f| File.mtime f}.min
+#           rescue Errno::ENOENT
+#             outputs_time = nil
+#           end
+#           if outputs_time == nil ||
+#              inputs_time != nil && outputs_time <= inputs_time
+#             sleep 1 if inputs_time != nil && inputs_time.to_i == Time.now.to_i
+#             block.call
+#           end
+#         end
+#       }
+#     end
+#
+#     def tsort_each_child(node, &block)
+#       @dep[node].each(&block)
+#     end
+#     include Gem::TSort
+#   end
+#
+#   def command(arg)
+#     print arg, "\n"
+#     system arg
+#   end
+#
+#   m = Make.new
+#   m.rule(%w[t1]) { command 'date > t1' }
+#   m.rule(%w[t2]) { command 'date > t2' }
+#   m.rule(%w[t3]) { command 'date > t3' }
+#   m.rule(%w[t4], %w[t1 t3]) { command 'cat t1 t3 > t4' }
+#   m.rule(%w[t5], %w[t4 t2]) { command 'cat t4 t2 > t5' }
+#   m.build('t5')
+#
+# == Bugs
+#
+# * 'tsort.rb' is wrong name because this library uses
+#   Tarjan's algorithm for strongly connected components.
+#   Although 'strongly_connected_components.rb' is correct but too long.
+#
+# == References
+#
+# R. E. Tarjan, "Depth First Search and Linear Graph Algorithms",
+# <em>SIAM Journal on Computing</em>, Vol. 1, No. 2, pp. 146-160, June 1972.
+#
+
+module Gem
+  module TSort
+    class Cyclic < StandardError
+    end
+
+    # Returns a topologically sorted array of nodes.
+    # The array is sorted from children to parents, i.e.
+    # the first element has no child and the last node has no parent.
+    #
+    # If there is a cycle, Gem::TSort::Cyclic is raised.
+    #
+    #   class G
+    #     include Gem::TSort
+    #     def initialize(g)
+    #       @g = g
+    #     end
+    #     def tsort_each_child(n, &b) @g[n].each(&b) end
+    #     def tsort_each_node(&b) @g.each_key(&b) end
+    #   end
+    #
+    #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+    #   p graph.tsort #=> [4, 2, 3, 1]
+    #
+    #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+    #   p graph.tsort # raises Gem::TSort::Cyclic
+    #
+    def tsort
+      each_node = method(:tsort_each_node)
+      each_child = method(:tsort_each_child)
+      Gem::TSort.tsort(each_node, each_child)
+    end
+
+    # Returns a topologically sorted array of nodes.
+    # The array is sorted from children to parents, i.e.
+    # the first element has no child and the last node has no parent.
+    #
+    # The graph is represented by _each_node_ and _each_child_.
+    # _each_node_ should have +call+ method which yields for each node in the graph.
+    # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+    #
+    # If there is a cycle, Gem::TSort::Cyclic is raised.
+    #
+    #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   p Gem::TSort.tsort(each_node, each_child) #=> [4, 2, 3, 1]
+    #
+    #   g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   p Gem::TSort.tsort(each_node, each_child) # raises Gem::TSort::Cyclic
+    #
+    def TSort.tsort(each_node, each_child)
+      Gem::TSort.tsort_each(each_node, each_child).to_a
+    end
+
+    # The iterator version of the #tsort method.
+    # <tt><em>obj</em>.tsort_each</tt> is similar to <tt><em>obj</em>.tsort.each</tt>, but
+    # modification of _obj_ during the iteration may lead to unexpected results.
+    #
+    # #tsort_each returns +nil+.
+    # If there is a cycle, Gem::TSort::Cyclic is raised.
+    #
+    #   class G
+    #     include Gem::TSort
+    #     def initialize(g)
+    #       @g = g
+    #     end
+    #     def tsort_each_child(n, &b) @g[n].each(&b) end
+    #     def tsort_each_node(&b) @g.each_key(&b) end
+    #   end
+    #
+    #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+    #   graph.tsort_each {|n| p n }
+    #   #=> 4
+    #   #   2
+    #   #   3
+    #   #   1
+    #
+    def tsort_each(&block) # :yields: node
+      each_node = method(:tsort_each_node)
+      each_child = method(:tsort_each_child)
+      Gem::TSort.tsort_each(each_node, each_child, &block)
+    end
+
+    # The iterator version of the Gem::TSort.tsort method.
+    #
+    # The graph is represented by _each_node_ and _each_child_.
+    # _each_node_ should have +call+ method which yields for each node in the graph.
+    # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+    #
+    #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   Gem::TSort.tsort_each(each_node, each_child) {|n| p n }
+    #   #=> 4
+    #   #   2
+    #   #   3
+    #   #   1
+    #
+    def TSort.tsort_each(each_node, each_child) # :yields: node
+      return to_enum(__method__, each_node, each_child) unless block_given?
+
+      Gem::TSort.each_strongly_connected_component(each_node, each_child) {|component|
+        if component.size == 1
+          yield component.first
+        else
+          raise Cyclic.new("topological sort failed: #{component.inspect}")
+        end
+      }
+    end
+
+    # Returns strongly connected components as an array of arrays of nodes.
+    # The array is sorted from children to parents.
+    # Each elements of the array represents a strongly connected component.
+    #
+    #   class G
+    #     include Gem::TSort
+    #     def initialize(g)
+    #       @g = g
+    #     end
+    #     def tsort_each_child(n, &b) @g[n].each(&b) end
+    #     def tsort_each_node(&b) @g.each_key(&b) end
+    #   end
+    #
+    #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+    #   p graph.strongly_connected_components #=> [[4], [2], [3], [1]]
+    #
+    #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+    #   p graph.strongly_connected_components #=> [[4], [2, 3], [1]]
+    #
+    def strongly_connected_components
+      each_node = method(:tsort_each_node)
+      each_child = method(:tsort_each_child)
+      Gem::TSort.strongly_connected_components(each_node, each_child)
+    end
+
+    # Returns strongly connected components as an array of arrays of nodes.
+    # The array is sorted from children to parents.
+    # Each elements of the array represents a strongly connected component.
+    #
+    # The graph is represented by _each_node_ and _each_child_.
+    # _each_node_ should have +call+ method which yields for each node in the graph.
+    # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+    #
+    #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   p Gem::TSort.strongly_connected_components(each_node, each_child)
+    #   #=> [[4], [2], [3], [1]]
+    #
+    #   g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   p Gem::TSort.strongly_connected_components(each_node, each_child)
+    #   #=> [[4], [2, 3], [1]]
+    #
+    def TSort.strongly_connected_components(each_node, each_child)
+      Gem::TSort.each_strongly_connected_component(each_node, each_child).to_a
+    end
+
+    # The iterator version of the #strongly_connected_components method.
+    # <tt><em>obj</em>.each_strongly_connected_component</tt> is similar to
+    # <tt><em>obj</em>.strongly_connected_components.each</tt>, but
+    # modification of _obj_ during the iteration may lead to unexpected results.
+    #
+    # #each_strongly_connected_component returns +nil+.
+    #
+    #   class G
+    #     include Gem::TSort
+    #     def initialize(g)
+    #       @g = g
+    #     end
+    #     def tsort_each_child(n, &b) @g[n].each(&b) end
+    #     def tsort_each_node(&b) @g.each_key(&b) end
+    #   end
+    #
+    #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+    #   graph.each_strongly_connected_component {|scc| p scc }
+    #   #=> [4]
+    #   #   [2]
+    #   #   [3]
+    #   #   [1]
+    #
+    #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+    #   graph.each_strongly_connected_component {|scc| p scc }
+    #   #=> [4]
+    #   #   [2, 3]
+    #   #   [1]
+    #
+    def each_strongly_connected_component(&block) # :yields: nodes
+      each_node = method(:tsort_each_node)
+      each_child = method(:tsort_each_child)
+      Gem::TSort.each_strongly_connected_component(each_node, each_child, &block)
+    end
+
+    # The iterator version of the Gem::TSort.strongly_connected_components method.
+    #
+    # The graph is represented by _each_node_ and _each_child_.
+    # _each_node_ should have +call+ method which yields for each node in the graph.
+    # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+    #
+    #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   Gem::TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
+    #   #=> [4]
+    #   #   [2]
+    #   #   [3]
+    #   #   [1]
+    #
+    #   g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   Gem::TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
+    #   #=> [4]
+    #   #   [2, 3]
+    #   #   [1]
+    #
+    def TSort.each_strongly_connected_component(each_node, each_child) # :yields: nodes
+      return to_enum(__method__, each_node, each_child) unless block_given?
+
+      id_map = {}
+      stack = []
+      each_node.call {|node|
+        unless id_map.include? node
+          Gem::TSort.each_strongly_connected_component_from(node, each_child, id_map, stack) {|c|
+            yield c
+          }
+        end
+      }
+      nil
+    end
+
+    # Iterates over strongly connected component in the subgraph reachable from
+    # _node_.
+    #
+    # Return value is unspecified.
+    #
+    # #each_strongly_connected_component_from doesn't call #tsort_each_node.
+    #
+    #   class G
+    #     include Gem::TSort
+    #     def initialize(g)
+    #       @g = g
+    #     end
+    #     def tsort_each_child(n, &b) @g[n].each(&b) end
+    #     def tsort_each_node(&b) @g.each_key(&b) end
+    #   end
+    #
+    #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+    #   graph.each_strongly_connected_component_from(2) {|scc| p scc }
+    #   #=> [4]
+    #   #   [2]
+    #
+    #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+    #   graph.each_strongly_connected_component_from(2) {|scc| p scc }
+    #   #=> [4]
+    #   #   [2, 3]
+    #
+    def each_strongly_connected_component_from(node, id_map={}, stack=[], &block) # :yields: nodes
+      Gem::TSort.each_strongly_connected_component_from(node, method(:tsort_each_child), id_map, stack, &block)
+    end
+
+    # Iterates over strongly connected components in a graph.
+    # The graph is represented by _node_ and _each_child_.
+    #
+    # _node_ is the first node.
+    # _each_child_ should have +call+ method which takes a node argument
+    # and yields for each child node.
+    #
+    # Return value is unspecified.
+    #
+    # #Gem::TSort.each_strongly_connected_component_from is a class method and
+    # it doesn't need a class to represent a graph which includes Gem::TSort.
+    #
+    #   graph = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+    #   each_child = lambda {|n, &b| graph[n].each(&b) }
+    #   Gem::TSort.each_strongly_connected_component_from(1, each_child) {|scc|
+    #     p scc
+    #   }
+    #   #=> [4]
+    #   #   [2, 3]
+    #   #   [1]
+    #
+    def TSort.each_strongly_connected_component_from(node, each_child, id_map={}, stack=[]) # :yields: nodes
+      return to_enum(__method__, node, each_child, id_map, stack) unless block_given?
+
+      minimum_id = node_id = id_map[node] = id_map.size
+      stack_length = stack.length
+      stack << node
+
+      each_child.call(node) {|child|
+        if id_map.include? child
+          child_id = id_map[child]
+          minimum_id = child_id if child_id && child_id < minimum_id
+        else
+          sub_minimum_id =
+            Gem::TSort.each_strongly_connected_component_from(child, each_child, id_map, stack) {|c|
+              yield c
+            }
+          minimum_id = sub_minimum_id if sub_minimum_id < minimum_id
+        end
+      }
+
+      if node_id == minimum_id
+        component = stack.slice!(stack_length .. -1)
+        component.each {|n| id_map[n] = nil}
+        yield component
+      end
+
+      minimum_id
+    end
+
+    # Should be implemented by a extended class.
+    #
+    # #tsort_each_node is used to iterate for all nodes over a graph.
+    #
+    def tsort_each_node # :yields: node
+      raise NotImplementedError.new
+    end
+
+    # Should be implemented by a extended class.
+    #
+    # #tsort_each_child is used to iterate for child nodes of _node_.
+    #
+    def tsort_each_child(node) # :yields: child
+      raise NotImplementedError.new
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/lib/rubygems/uninstaller.rb
+++ ruby2.7-2.7.6/lib/rubygems/uninstaller.rb
@@ -5,11 +5,12 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'fileutils'
-require 'rubygems'
-require 'rubygems/dependency_list'
-require 'rubygems/rdoc'
-require 'rubygems/user_interaction'
+require "fileutils"
+require_relative "../rubygems"
+require_relative "installer_uninstaller_utils"
+require_relative "dependency_list"
+require_relative "rdoc"
+require_relative "user_interaction"
 
 ##
 # An Uninstaller.
@@ -20,9 +21,10 @@ require 'rubygems/user_interaction'
 # file.  See Gem.pre_uninstall and Gem.post_uninstall for details.
 
 class Gem::Uninstaller
-
   include Gem::UserInteraction
 
+  include Gem::InstallerUninstallerUtils
+
   ##
   # The directory a gem's executables will be installed into
 
@@ -47,6 +49,7 @@ class Gem::Uninstaller
     @gem                = gem
     @version            = options[:version] || Gem::Requirement.default
     @gem_home           = File.realpath(options[:install_dir] || Gem.dir)
+    @plugins_dir        = Gem.plugindir(@gem_home)
     @force_executables  = options[:executables]
     @force_all          = options[:all]
     @force_ignore       = options[:ignore]
@@ -67,6 +70,9 @@ class Gem::Uninstaller
     # only add user directory if install_dir is not set
     @user_install = false
     @user_install = options[:user_install] unless options[:install_dir]
+
+    # Optimization: populated during #uninstall
+    @default_specs_matching_uninstall_params = []
   end
 
   ##
@@ -95,14 +101,12 @@ class Gem::Uninstaller
     default_specs, list = list.partition do |spec|
       spec.default_gem?
     end
-
-    default_specs.each do |default_spec|
-      say "Gem #{default_spec.full_name} cannot be uninstalled because it is a default gem"
-    end
+    warn_cannot_uninstall_default_gems(default_specs - list)
+    @default_specs_matching_uninstall_params = default_specs
 
     list, other_repo_specs = list.partition do |spec|
-      @gem_home == spec.base_dir or
-        (@user_install and spec.base_dir == Gem.user_dir)
+      @gem_home == spec.base_dir ||
+        (@user_install && spec.base_dir == Gem.user_dir)
     end
 
     list.sort!
@@ -110,10 +114,10 @@ class Gem::Uninstaller
     if list.empty?
       return unless other_repo_specs.any?
 
-      other_repos = other_repo_specs.map { |spec| spec.base_dir }.uniq
+      other_repos = other_repo_specs.map {|spec| spec.base_dir }.uniq
 
       message = ["#{@gem} is not installed in GEM_HOME, try:"]
-      message.concat other_repos.map { |repo|
+      message.concat other_repos.map {|repo|
         "\tgem uninstall -i #{repo} #{@gem}"
       }
 
@@ -122,7 +126,7 @@ class Gem::Uninstaller
       remove_all list
 
     elsif list.size > 1
-      gem_names = list.map { |gem| gem.full_name }
+      gem_names = list.map {|gem| gem.full_name }
       gem_names << "All versions"
 
       say
@@ -158,8 +162,11 @@ class Gem::Uninstaller
     end
 
     remove_executables @spec
+    remove_plugins @spec
     remove @spec
 
+    regenerate_plugins
+
     Gem.post_uninstall_hooks.each do |hook|
       hook.call self
     end
@@ -168,11 +175,10 @@ class Gem::Uninstaller
   end
 
   ##
-  # Removes installed executables and batch files (windows only) for
-  # +gemspec+.
+  # Removes installed executables and batch files (windows only) for +spec+.
 
   def remove_executables(spec)
-    return if spec.nil? or spec.executables.empty?
+    return if spec.executables.empty?
 
     executables = spec.executables.clone
 
@@ -191,16 +197,16 @@ class Gem::Uninstaller
 
     return if executables.empty?
 
-    executables = executables.map { |exec| formatted_program_filename exec }
+    executables = executables.map {|exec| formatted_program_filename exec }
 
     remove = if @force_executables.nil?
-               ask_yes_no("Remove executables:\n" +
-                          "\t#{executables.join ', '}\n\n" +
-                          "in addition to the gem?",
-                          true)
-             else
-               @force_executables
-             end
+      ask_yes_no("Remove executables:\n" +
+                 "\t#{executables.join ', '}\n\n" +
+                 "in addition to the gem?",
+                 true)
+    else
+      @force_executables
+    end
 
     if remove
       bin_dir = @bin_dir || Gem.bindir(spec.base_dir)
@@ -226,19 +232,15 @@ class Gem::Uninstaller
   # NOTE: removes uninstalled gems from +list+.
 
   def remove_all(list)
-    list.each { |spec| uninstall_gem spec }
+    list.each {|spec| uninstall_gem spec }
   end
 
   ##
   # spec:: the spec of the gem to be uninstalled
-  # list:: the list of all such gems
-  #
-  # Warning: this method modifies the +list+ parameter.  Once it has
-  # uninstalled a gem, it is removed from that list.
 
   def remove(spec)
-    unless path_ok?(@gem_home, spec) or
-           (@user_install and path_ok?(Gem.user_dir, spec))
+    unless path_ok?(@gem_home, spec) ||
+           (@user_install && path_ok?(Gem.user_dir, spec))
       e = Gem::GemNotInHomeException.new \
             "Gem '#{spec.full_name}' is not installed in directory #{@gem_home}"
       e.spec = spec
@@ -260,7 +262,10 @@ class Gem::Uninstaller
 
     safe_delete { FileUtils.rm_r gem }
 
-    Gem::RDoc.new(spec).remove
+    begin
+      Gem::RDoc.new(spec).remove
+    rescue NameError
+    end
 
     gemspec = spec.spec_file
 
@@ -269,17 +274,36 @@ class Gem::Uninstaller
     end
 
     safe_delete { FileUtils.rm_r gemspec }
-    say "Successfully uninstalled #{spec.full_name}"
+    announce_deletion_of(spec)
 
     Gem::Specification.reset
   end
 
   ##
+  # Remove any plugin wrappers for +spec+.
+
+  def remove_plugins(spec) # :nodoc:
+    return if spec.plugins.empty?
+
+    remove_plugins_for(spec, @plugins_dir)
+  end
+
+  ##
+  # Regenerates plugin wrappers after removal.
+
+  def regenerate_plugins
+    latest = Gem::Specification.latest_spec_for(@spec.name)
+    return if latest.nil?
+
+    regenerate_plugins_for(latest, @plugins_dir)
+  end
+
+  ##
   # Is +spec+ in +gem_dir+?
 
   def path_ok?(gem_dir, spec)
-    full_path     = File.join gem_dir, 'gems', spec.full_name
-    original_path = File.join gem_dir, 'gems', spec.original_name
+    full_path     = File.join gem_dir, "gems", spec.full_name
+    original_path = File.join gem_dir, "gems", spec.original_name
 
     full_path == spec.full_gem_path || original_path == spec.full_gem_path
   end
@@ -308,23 +332,23 @@ class Gem::Uninstaller
   # Asks if it is OK to remove +spec+.  Returns true if it is OK.
 
   def ask_if_ok(spec) # :nodoc:
-    msg = ['']
-    msg << 'You have requested to uninstall the gem:'
+    msg = [""]
+    msg << "You have requested to uninstall the gem:"
     msg << "\t#{spec.full_name}"
-    msg << ''
+    msg << ""
 
     siblings = Gem::Specification.select do |s|
       s.name == spec.name && s.full_name != spec.full_name
     end
 
-    spec.dependent_gems.each do |dep_spec, dep, satlist|
-      unless siblings.any? { |s| s.satisfies_requirement? dep }
+    spec.dependent_gems(@check_dev).each do |dep_spec, dep, satlist|
+      unless siblings.any? {|s| s.satisfies_requirement? dep }
         msg << "#{dep_spec.name}-#{dep_spec.version} depends on #{dep}"
       end
     end
 
-    msg << 'If you remove this gem, these dependencies will not be met.'
-    msg << 'Continue with Uninstall?'
+    msg << "If you remove this gem, these dependencies will not be met."
+    msg << "Continue with Uninstall?"
     return ask_yes_no(msg.join("\n"), false)
   end
 
@@ -336,7 +360,7 @@ class Gem::Uninstaller
     # of what it did for us to find rather than trying to recreate
     # it again.
     if @format_executable
-      require 'rubygems/installer'
+      require_relative "installer"
       Gem::Installer.exec_format % File.basename(filename)
     else
       filename
@@ -354,4 +378,33 @@ class Gem::Uninstaller
     raise e
   end
 
+  private
+
+  def announce_deletion_of(spec)
+    name = spec.full_name
+    say "Successfully uninstalled #{name}"
+    if default_spec_matches?(spec)
+      say(
+        "There was both a regular copy and a default copy of #{name}. The " \
+          "regular copy was successfully uninstalled, but the default copy " \
+          "was left around because default gems can't be removed."
+      )
+    end
+  end
+
+  # @return true if the specs of any default gems are `==` to the given `spec`.
+  def default_spec_matches?(spec)
+    !default_specs_that_match(spec).empty?
+  end
+
+  # @return [Array] specs of default gems that are `==` to the given `spec`.
+  def default_specs_that_match(spec)
+    @default_specs_matching_uninstall_params.select {|default_spec| spec == default_spec }
+  end
+
+  def warn_cannot_uninstall_default_gems(specs)
+    specs.each do |spec|
+      say "Gem #{spec.full_name} cannot be uninstalled because it is a default gem"
+    end
+  end
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/unknown_command_spell_checker.rb
@@ -0,0 +1,21 @@
+# frozen_string_literal: true
+
+class Gem::UnknownCommandSpellChecker
+  attr_reader :error
+
+  def initialize(error)
+    @error = error
+  end
+
+  def corrections
+    @corrections ||=
+      spell_checker.correct(error.unknown_command).map(&:inspect)
+  end
+
+  private
+
+  def spell_checker
+    dictionary = Gem::CommandManager.instance.command_names
+    DidYouMean::SpellChecker.new(dictionary: dictionary)
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/rubygems/uri.rb
@@ -0,0 +1,126 @@
+# frozen_string_literal: true
+
+##
+# The Uri handles rubygems source URIs.
+#
+
+class Gem::Uri
+  ##
+  # Parses and redacts uri
+
+  def self.redact(uri)
+    new(uri).redacted
+  end
+
+  ##
+  # Parses uri, raising if it's invalid
+
+  def self.parse!(uri)
+    require "uri"
+
+    raise URI::InvalidURIError unless uri
+
+    return uri unless uri.is_a?(String)
+
+    # Always escape URI's to deal with potential spaces and such
+    # It should also be considered that source_uri may already be
+    # a valid URI with escaped characters. e.g. "{DESede}" is encoded
+    # as "%7BDESede%7D". If this is escaped again the percentage
+    # symbols will be escaped.
+    begin
+      URI.parse(uri)
+    rescue URI::InvalidURIError
+      URI.parse(URI::DEFAULT_PARSER.escape(uri))
+    end
+  end
+
+  ##
+  # Parses uri, returning the original uri if it's invalid
+
+  def self.parse(uri)
+    parse!(uri)
+  rescue URI::InvalidURIError
+    uri
+  end
+
+  def initialize(source_uri)
+    @parsed_uri = parse(source_uri)
+  end
+
+  def redacted
+    return self unless valid_uri?
+
+    if token? || oauth_basic?
+      with_redacted_user
+    elsif password?
+      with_redacted_password
+    else
+      self
+    end
+  end
+
+  def to_s
+    @parsed_uri.to_s
+  end
+
+  def redact_credentials_from(text)
+    return text unless valid_uri? && password? && text.include?(to_s)
+
+    text.sub(password, "REDACTED")
+  end
+
+  def method_missing(method_name, *args, &blk)
+    if @parsed_uri.respond_to?(method_name)
+      @parsed_uri.send(method_name, *args, &blk)
+    else
+      super
+    end
+  end
+
+  def respond_to_missing?(method_name, include_private = false)
+    @parsed_uri.respond_to?(method_name, include_private) || super
+  end
+
+  protected
+
+  # Add a protected reader for the cloned instance to access the original object's parsed uri
+  attr_reader :parsed_uri
+
+  private
+
+  def parse!(uri)
+    self.class.parse!(uri)
+  end
+
+  def parse(uri)
+    self.class.parse(uri)
+  end
+
+  def with_redacted_user
+    clone.tap {|uri| uri.user = "REDACTED" }
+  end
+
+  def with_redacted_password
+    clone.tap {|uri| uri.password = "REDACTED" }
+  end
+
+  def valid_uri?
+    !@parsed_uri.is_a?(String)
+  end
+
+  def password?
+    !!password
+  end
+
+  def oauth_basic?
+    password == "x-oauth-basic"
+  end
+
+  def token?
+    !user.nil? && password.nil?
+  end
+
+  def initialize_copy(original)
+    @parsed_uri = original.parsed_uri.clone
+  end
+end
--- ruby2.7-2.7.6.orig/lib/rubygems/uri_formatter.rb
+++ ruby2.7-2.7.6/lib/rubygems/uri_formatter.rb
@@ -1,5 +1,4 @@
 # frozen_string_literal: true
-require 'cgi'
 
 ##
 # The UriFormatter handles URIs from user-input and escaping.
@@ -9,7 +8,6 @@ require 'cgi'
 #   p uf.normalize #=> 'http://example.com'
 
 class Gem::UriFormatter
-
   ##
   # The URI to be formatted.
 
@@ -19,6 +17,8 @@ class Gem::UriFormatter
   # Creates a new URI formatter for +uri+.
 
   def initialize(uri)
+    require "cgi"
+
     @uri = uri
   end
 
@@ -44,5 +44,4 @@ class Gem::UriFormatter
     return unless @uri
     CGI.unescape @uri
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/uri_parser.rb
+++ /dev/null
@@ -1,36 +0,0 @@
-# frozen_string_literal: true
-
-##
-# The UriParser handles parsing URIs.
-#
-
-class Gem::UriParser
-
-  ##
-  # Parses the #uri, raising if it's invalid
-
-  def parse!(uri)
-    raise URI::InvalidURIError unless uri
-
-    # Always escape URI's to deal with potential spaces and such
-    # It should also be considered that source_uri may already be
-    # a valid URI with escaped characters. e.g. "{DESede}" is encoded
-    # as "%7BDESede%7D". If this is escaped again the percentage
-    # symbols will be escaped.
-    begin
-      URI.parse(uri)
-    rescue URI::InvalidURIError
-      URI.parse(URI::DEFAULT_PARSER.escape(uri))
-    end
-  end
-
-  ##
-  # Parses the #uri, returning the original uri if it's invalid
-
-  def parse(uri)
-    parse!(uri)
-  rescue URI::InvalidURIError
-    uri
-  end
-
-end
--- ruby2.7-2.7.6.orig/lib/rubygems/uri_parsing.rb
+++ /dev/null
@@ -1,23 +0,0 @@
-# frozen_string_literal: true
-
-require "rubygems/uri_parser"
-
-module Gem::UriParsing
-
-  def parse_uri(source_uri)
-    return source_uri unless source_uri.is_a?(String)
-
-    uri_parser.parse(source_uri)
-  end
-
-  private :parse_uri
-
-  def uri_parser
-    require "uri"
-
-    Gem::UriParser.new
-  end
-
-  private :uri_parser
-
-end
--- ruby2.7-2.7.6.orig/lib/rubygems/user_interaction.rb
+++ ruby2.7-2.7.6/lib/rubygems/user_interaction.rb
@@ -5,9 +5,8 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/util'
-require 'rubygems/deprecate'
-require 'rubygems/text'
+require_relative "deprecate"
+require_relative "text"
 
 ##
 # Module that defines the default UserInteraction.  Any class including this
@@ -149,7 +148,7 @@ module Gem::UserInteraction
   ##
   # Displays the given +statement+ on the standard output (or equivalent).
 
-  def say(statement = '')
+  def say(statement = "")
     ui.say statement
   end
 
@@ -173,7 +172,6 @@ end
 # Gem::StreamUI implements a simple stream based user interface.
 
 class Gem::StreamUI
-
   extend Gem::Deprecate
 
   ##
@@ -260,23 +258,23 @@ class Gem::StreamUI
     end
 
     default_answer = case default
-                     when nil
-                       'yn'
-                     when true
-                       'Yn'
-                     else
-                       'yN'
-                     end
+    when nil
+      "yn"
+    when true
+      "Yn"
+    else
+      "yN"
+    end
 
     result = nil
 
     while result.nil? do
       result = case ask "#{question} [#{default_answer}]"
-               when /^y/i then true
-               when /^n/i then false
-               when /^$/  then default
-               else            nil
-               end
+      when /^y/i then true
+      when /^n/i then false
+      when /^$/  then default
+      else            nil
+      end
     end
 
     return result
@@ -286,7 +284,7 @@ class Gem::StreamUI
   # Ask a question.  Returns an answer if connected to a tty, nil otherwise.
 
   def ask(question)
-    return nil if not tty?
+    return nil if !tty?
 
     @outs.print(question + "  ")
     @outs.flush
@@ -300,7 +298,7 @@ class Gem::StreamUI
   # Ask for a password. Does not echo response to terminal.
 
   def ask_for_password(question)
-    return nil if not tty?
+    return nil if !tty?
 
     @outs.print(question, "  ")
     @outs.flush
@@ -314,7 +312,7 @@ class Gem::StreamUI
   def require_io_console
     @require_io_console ||= begin
       begin
-        require 'io/console'
+        require "io/console"
       rescue LoadError
       end
       true
@@ -323,7 +321,7 @@ class Gem::StreamUI
 
   def _gets_noecho
     require_io_console
-    @ins.noecho {@ins.gets}
+    @ins.noecho { @ins.gets }
   end
 
   ##
@@ -359,14 +357,6 @@ class Gem::StreamUI
   end
 
   ##
-  # Display a debug message on the same location as error messages.
-
-  def debug(statement)
-    @errs.puts statement
-  end
-  deprecate :debug, :none, 2018, 12
-
-  ##
   # Terminate the application with exit code +status+, running any exit
   # handlers that might have been defined.
 
@@ -396,7 +386,6 @@ class Gem::StreamUI
   # An absolutely silent progress reporter.
 
   class SilentProgressReporter
-
     ##
     # The count of items is never updated for the silent progress reporter.
 
@@ -421,14 +410,12 @@ class Gem::StreamUI
 
     def done
     end
-
   end
 
   ##
   # A basic dotted progress reporter.
 
   class SimpleProgressReporter
-
     include Gem::DefaultUserInteraction
 
     ##
@@ -466,14 +453,12 @@ class Gem::StreamUI
     def done
       @out.puts "\n#{@terminal_message}"
     end
-
   end
 
   ##
   # A progress reporter that prints out messages about the current progress.
 
   class VerboseProgressReporter
-
     include Gem::DefaultUserInteraction
 
     ##
@@ -487,7 +472,7 @@ class Gem::StreamUI
     # and the +terminal_message+ when it is complete.
 
     def initialize(out_stream, size, initial_message,
-                   terminal_message = 'complete')
+                   terminal_message = "complete")
       @out = out_stream
       @total = size
       @count = 0
@@ -510,7 +495,6 @@ class Gem::StreamUI
     def done
       @out.puts @terminal_message
     end
-
   end
 
   ##
@@ -528,7 +512,6 @@ class Gem::StreamUI
   # An absolutely silent download reporter.
 
   class SilentDownloadReporter
-
     ##
     # The silent download reporter ignores all arguments
 
@@ -554,15 +537,13 @@ class Gem::StreamUI
 
     def done
     end
-
   end
 
   ##
   # A progress reporter that behaves nicely with threaded downloading.
 
   class ThreadedDownloadReporter
-
-    MUTEX = Mutex.new
+    MUTEX = Thread::Mutex.new
 
     ##
     # The current file name being displayed
@@ -610,9 +591,7 @@ class Gem::StreamUI
         @out.puts message
       end
     end
-
   end
-
 end
 
 ##
@@ -620,7 +599,6 @@ end
 # STDOUT, and STDERR.
 
 class Gem::ConsoleUI < Gem::StreamUI
-
   ##
   # The Console UI has no arguments as it defaults to reading input from
   # stdin, output to stdout and warnings or errors to stderr.
@@ -628,30 +606,21 @@ class Gem::ConsoleUI < Gem::StreamUI
   def initialize
     super STDIN, STDOUT, STDERR, true
   end
-
 end
 
 ##
 # SilentUI is a UI choice that is absolutely silent.
 
 class Gem::SilentUI < Gem::StreamUI
-
   ##
   # The SilentUI has no arguments as it does not use any stream.
 
   def initialize
-    reader, writer = nil, nil
-
-    reader = File.open(IO::NULL, 'r')
-    writer = File.open(IO::NULL, 'w')
-
-    super reader, writer, writer, false
+    io = NullIO.new
+    super io, io, io, false
   end
 
   def close
-    super
-    @ins.close
-    @outs.close
   end
 
   def download_reporter(*args) # :nodoc:
@@ -662,4 +631,24 @@ class Gem::SilentUI < Gem::StreamUI
     SilentProgressReporter.new(@outs, *args)
   end
 
+  ##
+  # An absolutely silent IO.
+
+  class NullIO
+    def puts(*args)
+    end
+
+    def print(*args)
+    end
+
+    def flush
+    end
+
+    def gets(*args)
+    end
+
+    def tty?
+      false
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/util.rb
+++ ruby2.7-2.7.6/lib/rubygems/util.rb
@@ -1,18 +1,18 @@
 # frozen_string_literal: true
+require_relative "deprecate"
+
 ##
 # This module contains various utility methods as module methods.
 
 module Gem::Util
 
-  @silent_mutex = nil
-
   ##
   # Zlib::GzipReader wrapper that unzips +data+.
 
   def self.gunzip(data)
-    require 'zlib'
-    require 'stringio'
-    data = StringIO.new(data, 'r')
+    require "zlib"
+    require "stringio"
+    data = StringIO.new(data, "r")
 
     gzip_reader = begin
                     Zlib::GzipReader.new(data)
@@ -29,9 +29,9 @@ module Gem::Util
   # Zlib::GzipWriter wrapper that zips +data+.
 
   def self.gzip(data)
-    require 'zlib'
-    require 'stringio'
-    zipped = StringIO.new(String.new, 'w')
+    require "zlib"
+    require "stringio"
+    zipped = StringIO.new(String.new, "w")
     zipped.set_encoding Encoding::BINARY
 
     Zlib::GzipWriter.wrap zipped do |io|
@@ -45,7 +45,7 @@ module Gem::Util
   # A Zlib::Inflate#inflate wrapper
 
   def self.inflate(data)
-    require 'zlib'
+    require "zlib"
     Zlib::Inflate.inflate data
   end
 
@@ -60,7 +60,7 @@ module Gem::Util
   # Invokes system, but silences all output.
 
   def self.silent_system(*command)
-    opt = {:out => IO::NULL, :err => [:child, :out]}
+    opt = { :out => IO::NULL, :err => [:child, :out] }
     if Hash === command.last
       opt.update(command.last)
       cmds = command[0...-1]
@@ -70,6 +70,12 @@ module Gem::Util
     system(*(cmds << opt))
   end
 
+  class << self
+    extend Gem::Deprecate
+
+    rubygems_deprecate :silent_system
+  end
+
   ##
   # Enumerates the parents of +directory+.
 
@@ -80,7 +86,7 @@ module Gem::Util
     loop do
       Dir.chdir here, &block rescue Errno::EACCES
 
-      new_here = File.expand_path('..', here)
+      new_here = File.expand_path("..", here)
       return if new_here == here # toplevel
       here = new_here
     end
@@ -103,7 +109,7 @@ module Gem::Util
   # comes with a leading slash.
 
   def self.correct_for_windows_path(path)
-    if path[0].chr == '/' && path[1].chr =~ /[a-z]/i && path[2].chr == ':'
+    if path[0].chr == "/" && path[1].chr =~ /[a-z]/i && path[2].chr == ":"
       path[1..-1]
     else
       path
--- ruby2.7-2.7.6.orig/lib/rubygems/util/licenses.rb
+++ ruby2.7-2.7.6/lib/rubygems/util/licenses.rb
@@ -1,15 +1,15 @@
 # frozen_string_literal: true
-require 'rubygems/text'
+require_relative "../text"
 
 class Gem::Licenses
-
   extend Gem::Text
 
-  NONSTANDARD = 'Nonstandard'.freeze
+  NONSTANDARD = "Nonstandard".freeze
+  LICENSE_REF = "LicenseRef-.+".freeze
 
   # Software Package Data Exchange (SPDX) standard open-source software
   # license identifiers
-  LICENSE_IDENTIFIERS = %w(
+  LICENSE_IDENTIFIERS = %w[
     0BSD
     AAL
     ADSL
@@ -19,6 +19,8 @@ class Gem::Licenses
     AFL-2.1
     AFL-3.0
     AGPL-1.0
+    AGPL-1.0-only
+    AGPL-1.0-or-later
     AGPL-3.0
     AGPL-3.0-only
     AGPL-3.0-or-later
@@ -26,6 +28,7 @@ class Gem::Licenses
     AML
     AMPAS
     ANTLR-PD
+    ANTLR-PD-fallback
     APAFML
     APL-1.0
     APSL-1.0
@@ -49,29 +52,41 @@ class Gem::Licenses
     BSD-2-Clause-FreeBSD
     BSD-2-Clause-NetBSD
     BSD-2-Clause-Patent
+    BSD-2-Clause-Views
     BSD-3-Clause
     BSD-3-Clause-Attribution
     BSD-3-Clause-Clear
     BSD-3-Clause-LBNL
+    BSD-3-Clause-Modification
+    BSD-3-Clause-No-Military-License
     BSD-3-Clause-No-Nuclear-License
     BSD-3-Clause-No-Nuclear-License-2014
     BSD-3-Clause-No-Nuclear-Warranty
+    BSD-3-Clause-Open-MPI
     BSD-4-Clause
+    BSD-4-Clause-Shortened
     BSD-4-Clause-UC
     BSD-Protection
     BSD-Source-Code
     BSL-1.0
+    BUSL-1.1
     Bahyph
     Barr
     Beerware
     BitTorrent-1.0
     BitTorrent-1.1
+    BlueOak-1.0.0
     Borceux
+    C-UDA-1.0
+    CAL-1.0
+    CAL-1.0-Combined-Work-Exception
     CATOSL-1.1
     CC-BY-1.0
     CC-BY-2.0
     CC-BY-2.5
     CC-BY-3.0
+    CC-BY-3.0-AT
+    CC-BY-3.0-US
     CC-BY-4.0
     CC-BY-NC-1.0
     CC-BY-NC-2.0
@@ -82,6 +97,7 @@ class Gem::Licenses
     CC-BY-NC-ND-2.0
     CC-BY-NC-ND-2.5
     CC-BY-NC-ND-3.0
+    CC-BY-NC-ND-3.0-IGO
     CC-BY-NC-ND-4.0
     CC-BY-NC-SA-1.0
     CC-BY-NC-SA-2.0
@@ -95,12 +111,17 @@ class Gem::Licenses
     CC-BY-ND-4.0
     CC-BY-SA-1.0
     CC-BY-SA-2.0
+    CC-BY-SA-2.0-UK
+    CC-BY-SA-2.1-JP
     CC-BY-SA-2.5
     CC-BY-SA-3.0
+    CC-BY-SA-3.0-AT
     CC-BY-SA-4.0
+    CC-PDDC
     CC0-1.0
     CDDL-1.0
     CDDL-1.1
+    CDL-1.0
     CDLA-Permissive-1.0
     CDLA-Sharing-1.0
     CECILL-1.0
@@ -109,6 +130,11 @@ class Gem::Licenses
     CECILL-2.1
     CECILL-B
     CECILL-C
+    CERN-OHL-1.1
+    CERN-OHL-1.2
+    CERN-OHL-P-2.0
+    CERN-OHL-S-2.0
+    CERN-OHL-W-2.0
     CNRI-Jython
     CNRI-Python
     CNRI-Python-GPL-Compatible
@@ -124,12 +150,14 @@ class Gem::Licenses
     Cube
     D-FSL-1.0
     DOC
+    DRL-1.0
     DSDP
     Dotseqn
     ECL-1.0
     ECL-2.0
     EFL-1.0
     EFL-2.0
+    EPICS
     EPL-1.0
     EPL-2.0
     EUDatagrid
@@ -145,17 +173,32 @@ class Gem::Licenses
     FTL
     Fair
     Frameworx-1.0
+    FreeBSD-DOC
     FreeImage
+    GD
     GFDL-1.1
+    GFDL-1.1-invariants-only
+    GFDL-1.1-invariants-or-later
+    GFDL-1.1-no-invariants-only
+    GFDL-1.1-no-invariants-or-later
     GFDL-1.1-only
     GFDL-1.1-or-later
     GFDL-1.2
+    GFDL-1.2-invariants-only
+    GFDL-1.2-invariants-or-later
+    GFDL-1.2-no-invariants-only
+    GFDL-1.2-no-invariants-or-later
     GFDL-1.2-only
     GFDL-1.2-or-later
     GFDL-1.3
+    GFDL-1.3-invariants-only
+    GFDL-1.3-invariants-or-later
+    GFDL-1.3-no-invariants-only
+    GFDL-1.3-no-invariants-or-later
     GFDL-1.3-only
     GFDL-1.3-or-later
     GL2PS
+    GLWTPL
     GPL-1.0
     GPL-1.0+
     GPL-1.0-only
@@ -179,7 +222,10 @@ class Gem::Licenses
     Glide
     Glulxe
     HPND
+    HPND-sell-variant
+    HTMLTIDY
     HaskellReport
+    Hippocratic-2.1
     IBM-pibs
     ICU
     IJG
@@ -192,6 +238,7 @@ class Gem::Licenses
     Intel
     Intel-ACPI
     Interbase-1.0
+    JPNIC
     JSON
     JasPer-2.0
     LAL-1.2
@@ -222,11 +269,15 @@ class Gem::Licenses
     LiLiQ-R-1.1
     LiLiQ-Rplus-1.1
     Libpng
+    Linux-OpenIB
     MIT
+    MIT-0
     MIT-CMU
+    MIT-Modern-Variant
     MIT-advertising
     MIT-enna
     MIT-feh
+    MIT-open-group
     MITNFA
     MPL-1.0
     MPL-1.1
@@ -238,12 +289,18 @@ class Gem::Licenses
     MakeIndex
     MirOS
     Motosoto
+    MulanPSL-1.0
+    MulanPSL-2.0
     Multics
     Mup
+    NAIST-2003
     NASA-1.3
     NBPL-1.0
+    NCGL-UK-2.0
     NCSA
     NGPL
+    NIST-PD
+    NIST-PD-fallback
     NLOD-1.0
     NLPL
     NOSL
@@ -252,6 +309,7 @@ class Gem::Licenses
     NPOSL-3.0
     NRL
     NTP
+    NTP-0
     Naumen
     Net-SNMP
     NetCDF
@@ -259,11 +317,23 @@ class Gem::Licenses
     Nokia
     Noweb
     Nunit
+    O-UDA-1.0
     OCCT-PL
     OCLC-2.0
+    ODC-By-1.0
     ODbL-1.0
     OFL-1.0
+    OFL-1.0-RFN
+    OFL-1.0-no-RFN
     OFL-1.1
+    OFL-1.1-RFN
+    OFL-1.1-no-RFN
+    OGC-1.0
+    OGDL-Taiwan-1.0
+    OGL-Canada-2.0
+    OGL-UK-1.0
+    OGL-UK-2.0
+    OGL-UK-3.0
     OGTSL
     OLDAP-1.1
     OLDAP-1.2
@@ -293,7 +363,12 @@ class Gem::Licenses
     PDDL-1.0
     PHP-3.0
     PHP-3.01
+    PSF-2.0
+    Parity-6.0.0
+    Parity-7.0.0
     Plexus
+    PolyForm-Noncommercial-1.0.0
+    PolyForm-Small-Business-1.0.0
     PostgreSQL
     Python-2.0
     QPL-1.0
@@ -311,15 +386,21 @@ class Gem::Licenses
     SGI-B-1.0
     SGI-B-1.1
     SGI-B-2.0
+    SHL-0.5
+    SHL-0.51
     SISSL
     SISSL-1.2
     SMLNJ
     SMPPL
     SNIA
     SPL-1.0
+    SSH-OpenSSH
+    SSH-short
+    SSPL-1.0
     SWL
     Saxpath
     Sendmail
+    Sendmail-8.23
     SimPL-2.0
     Sleepycat
     Spencer-86
@@ -327,11 +408,15 @@ class Gem::Licenses
     Spencer-99
     StandardML-NJ
     SugarCRM-1.1.3
+    TAPR-OHL-1.0
     TCL
     TCP-wrappers
     TMate
     TORQUE-1.1
     TOSL
+    TU-Berlin-1.0
+    TU-Berlin-2.0
+    UCL-1.0
     UPL-1.0
     Unicode-DFS-2015
     Unicode-DFS-2016
@@ -361,16 +446,22 @@ class Gem::Licenses
     Zimbra-1.3
     Zimbra-1.4
     Zlib
+    blessing
     bzip2-1.0.5
     bzip2-1.0.6
+    copyleft-next-0.3.0
+    copyleft-next-0.3.1
     curl
     diffmark
     dvipdfm
     eCos-2.0
     eGenix
+    etalab-2.0
     gSOAP-1.3b
     gnuplot
     iMatix
+    libpng-2.0
+    libselinux-1.0
     libtiff
     mpich2
     psfrag
@@ -379,10 +470,10 @@ class Gem::Licenses
     xinetd
     xpp
     zlib-acknowledgement
-  ).freeze
+  ].freeze
 
   # exception identifiers
-  EXCEPTION_IDENTIFIERS = %w(
+  EXCEPTION_IDENTIFIERS = %w[
     389-exception
     Autoconf-exception-2.0
     Autoconf-exception-3.0
@@ -396,12 +487,26 @@ class Gem::Licenses
     Font-exception-2.0
     GCC-exception-2.0
     GCC-exception-3.1
+    GPL-3.0-linking-exception
+    GPL-3.0-linking-source-exception
+    GPL-CC-1.0
+    LGPL-3.0-linking-exception
+    LLVM-exception
     LZMA-exception
     Libtool-exception
     Linux-syscall-note
     Nokia-Qt-exception-1.1
     OCCT-exception-1.0
+    OCaml-LGPL-linking-exception
+    OpenJDK-assembly-exception-1.0
+    PS-or-PDF-font-exception-20170817
+    Qt-GPL-exception-1.0
+    Qt-LGPL-exception-1.1
     Qwt-exception-1.0
+    SHL-2.0
+    SHL-2.1
+    Swift-exception
+    Universal-FOSS-exception-1.0
     WxWindows-exception-3.1
     eCos-exception-2.0
     freertos-exception-2.0
@@ -410,15 +515,16 @@ class Gem::Licenses
     mif-exception
     openvpn-openssl-exception
     u-boot-exception-2.0
-  ).freeze
+  ].freeze
 
   REGEXP = %r{
     \A
-    (
+    (?:
       #{Regexp.union(LICENSE_IDENTIFIERS)}
       \+?
-      (\s WITH \s #{Regexp.union(EXCEPTION_IDENTIFIERS)})?
+      (?:\s WITH \s #{Regexp.union(EXCEPTION_IDENTIFIERS)})?
       | #{NONSTANDARD}
+      | #{LICENSE_REF}
     )
     \Z
   }ox.freeze
@@ -435,5 +541,4 @@ class Gem::Licenses
     return unless lowest < license.size
     by_distance[lowest]
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/util/list.rb
+++ ruby2.7-2.7.6/lib/rubygems/util/list.rb
@@ -1,7 +1,6 @@
 # frozen_string_literal: true
 module Gem
   class List
-
     include Enumerable
     attr_accessor :value, :tail
 
@@ -34,6 +33,5 @@ module Gem
       return List.new(value) unless list
       List.new value, list
     end
-
   end
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/validator.rb
+++ ruby2.7-2.7.6/lib/rubygems/validator.rb
@@ -5,18 +5,17 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/package'
-require 'rubygems/installer'
+require_relative "package"
+require_relative "installer"
 
 ##
 # Validator performs various gem file and gem database validation
 
 class Gem::Validator
-
   include Gem::UserInteraction
 
   def initialize # :nodoc:
-    require 'find'
+    require "find"
   end
 
   private
@@ -60,7 +59,7 @@ class Gem::Validator
   # TODO needs further cleanup
 
   def alien(gems=[])
-    errors = Hash.new { |h,k| h[k] = {} }
+    errors = Hash.new {|h,k| h[k] = {} }
 
     Gem::Specification.each do |spec|
       next unless gems.include? spec.name unless gems.empty?
@@ -111,11 +110,11 @@ class Gem::Validator
             begin
               next unless data # HACK `gem check -a mkrf`
 
-              source = File.join gem_directory, entry['path']
+              source = File.join gem_directory, entry["path"]
 
               File.open source, Gem.binary_mode do |f|
                 unless f.read == data
-                  errors[gem_name][entry['path']] = "Modified from original"
+                  errors[gem_name][entry["path"]] = "Modified from original"
                 end
               end
             end
@@ -141,5 +140,4 @@ class Gem::Validator
 
     errors
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/version.rb
+++ ruby2.7-2.7.6/lib/rubygems/version.rb
@@ -1,4 +1,7 @@
 # frozen_string_literal: true
+
+require_relative "deprecate"
+
 ##
 # The Version class processes string versions into comparable
 # values. A version string should normally be a series of numbers
@@ -150,9 +153,6 @@
 # a zero to give a sensible result.
 
 class Gem::Version
-
-  autoload :Requirement, File.expand_path('requirement', __dir__)
-
   include Comparable
 
   VERSION_PATTERN = '[0-9]+(?>\.[0-9a-zA-Z]+)*(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?'.freeze # :nodoc:
@@ -171,9 +171,7 @@ class Gem::Version
   # True if the +version+ string matches RubyGems' requirements.
 
   def self.correct?(version)
-    unless Gem::Deprecate.skip
-      warn "nil versions are discouraged and will be deprecated in Rubygems 4" if version.nil?
-    end
+    nil_versions_are_discouraged! if version.nil?
 
     !!(version.to_s =~ ANCHORED_VERSION_PATTERN)
   end
@@ -187,9 +185,11 @@ class Gem::Version
   #   ver3 = Version.create(nil)        # -> nil
 
   def self.create(input)
-    if self === input  # check yourself before you wreck yourself
+    if self === input # check yourself before you wreck yourself
       input
     elsif input.nil?
+      nil_versions_are_discouraged!
+
       nil
     else
       new input
@@ -206,6 +206,14 @@ class Gem::Version
     @@all[version] ||= super
   end
 
+  def self.nil_versions_are_discouraged!
+    unless Gem::Deprecate.skip
+      warn "nil versions are discouraged and will be deprecated in Rubygems 4"
+    end
+  end
+
+  private_class_method :nil_versions_are_discouraged!
+
   ##
   # Constructs a Version from the +version+ string.  A version string is a
   # series of digits or ASCII letters separated by dots.
@@ -231,7 +239,7 @@ class Gem::Version
   def bump
     @@bump[self] ||= begin
                        segments = self.segments
-                       segments.pop while segments.any? { |s| String === s }
+                       segments.pop while segments.any? {|s| String === s }
                        segments.pop if segments.size > 1
 
                        segments[-1] = segments[-1].succ
@@ -244,7 +252,7 @@ class Gem::Version
   # same precision. Version "1.0" is not the same as version "1".
 
   def eql?(other)
-    self.class === other and @version == other._version
+    self.class === other && @version == other._version
   end
 
   def hash # :nodoc:
@@ -276,7 +284,7 @@ class Gem::Version
   end
 
   def yaml_initialize(tag, map) # :nodoc:
-    @version = map['version']
+    @version = map["version"]
     @segments = nil
     @hash = nil
   end
@@ -286,7 +294,7 @@ class Gem::Version
   end
 
   def encode_with(coder) # :nodoc:
-    coder.add 'version', @version
+    coder.add "version", @version
   end
 
   ##
@@ -309,12 +317,12 @@ class Gem::Version
 
   def release
     @@release[self] ||= if prerelease?
-                          segments = self.segments
-                          segments.pop while segments.any? { |s| String === s }
-                          self.class.new segments.join('.')
-                        else
-                          self
-                        end
+      segments = self.segments
+      segments.pop while segments.any? {|s| String === s }
+      self.class.new segments.join(".")
+    else
+      self
+    end
   end
 
   def segments # :nodoc:
@@ -327,7 +335,7 @@ class Gem::Version
   def approximate_recommendation
     segments = self.segments
 
-    segments.pop    while segments.any? { |s| String === s }
+    segments.pop    while segments.any? {|s| String === s }
     segments.pop    while segments.size > 2
     segments.push 0 while segments.size < 2
 
@@ -340,9 +348,11 @@ class Gem::Version
   # Compares this version with +other+ returning -1, 0, or 1 if the
   # other version is larger, the same, or smaller than this
   # one. Attempts to compare to something that's not a
-  # <tt>Gem::Version</tt> return +nil+.
+  # <tt>Gem::Version</tt> or a valid version String return +nil+.
 
   def <=>(other)
+    return self <=> self.class.new(other) if (String === other) && self.class.correct?(other)
+
     return unless Gem::Version === other
     return 0 if @version == other._version || canonical_segments == other.canonical_segments
 
@@ -404,5 +414,4 @@ class Gem::Version
     numeric_segments = string_segments.slice!(0, string_start || string_segments.size)
     return numeric_segments, string_segments
   end
-
 end
--- ruby2.7-2.7.6.orig/lib/rubygems/version_option.rb
+++ ruby2.7-2.7.6/lib/rubygems/version_option.rb
@@ -5,7 +5,7 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems'
+require_relative "../rubygems"
 
 ##
 # Mixin methods for --version and --platform Gem::Command options.
@@ -16,7 +16,7 @@ module Gem::VersionOption
   # Add the --platform option to the option parser.
 
   def add_platform_option(task = command, *wrap)
-    OptionParser.accept Gem::Platform do |value|
+    Gem::OptionParser.accept Gem::Platform do |value|
       if value == Gem::Platform::RUBY
         value
       else
@@ -24,7 +24,7 @@ module Gem::VersionOption
       end
     end
 
-    add_option('--platform PLATFORM', Gem::Platform,
+    add_option("--platform PLATFORM", Gem::Platform,
                "Specify the platform of gem to #{task}", *wrap) do
                  |value, options|
       unless options[:added_platform]
@@ -51,11 +51,11 @@ module Gem::VersionOption
   # Add the --version option to the option parser.
 
   def add_version_option(task = command, *wrap)
-    OptionParser.accept Gem::Requirement do |value|
+    Gem::OptionParser.accept Gem::Requirement do |value|
       Gem::Requirement.new(*value.split(/\s*,\s*/))
     end
 
-    add_option('-v', '--version VERSION', Gem::Requirement,
+    add_option("-v", "--version VERSION", Gem::Requirement,
                "Specify version of gem to #{task}", *wrap) do
                  |value, options|
       # Allow handling for multiple --version operators
@@ -73,4 +73,10 @@ module Gem::VersionOption
     end
   end
 
+  ##
+  # Extract platform given on the command line
+
+  def get_platform_from_requirements(requirements)
+    Gem.platforms[1].to_s if requirements.key? :added_platform
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/bogussources.rb
+++ /dev/null
@@ -1,9 +0,0 @@
-# frozen_string_literal: true
-#--
-# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.
-# All rights reserved.
-# See LICENSE.txt for permissions.
-#++
-
-require 'rubygems'
-Gem.use_paths("test/mock/gems")
--- ruby2.7-2.7.6.orig/test/rubygems/encrypted_private_key.pem
+++ ruby2.7-2.7.6/test/rubygems/encrypted_private_key.pem
@@ -1,30 +1,30 @@
 -----BEGIN RSA PRIVATE KEY-----
 Proc-Type: 4,ENCRYPTED
-DEK-Info: DES-CBC,4E38D58B5A059DB6
+DEK-Info: AES-256-CBC,CB6FD0B173EF450C6EE21A01DD785C1D
 
-IgWLfnHVnkErKkhysrUMoE0ubkRDtJXZv9KR02jGGFk/kGqWyTqPk08uzhwVNM+l
-eOk0qfPykkJM3KZgqTsD6xfA1D5WqFp5mLoFXVVTn9I3acSZsqOY0FweCipwdVpI
-x+9Fl+v62kIW06dOjyWLE1abed9hHiXesGGsD87/RJSywy4OBxOcrhR1fJLK4ElR
-ya0UzI7rWnmZMChjaZBssfzT1DR79/dARXhon2m5EiIJDjMpc8BKGYlQy5RHCHwA
-cnrhUTTvsggZbQtmLZ/yVx8FSJ273XpYR0pmwbw4j1R+zeXQRK5MroBnCfOGcYa7
-rmpERmDW3VAuxXR20SUAGdo1XOMTDe1uLbaotn6e56pXghIaYROTPS+HsuOkAZGY
-OYWEkUoyog4l4n+h/C1umFfTFGvKNATLgDugONFvTw/PLbjvl+sWMy2QfqH0MlNB
-DIUPxhEVCFD9oB4nfB86WDAmPp1DH9/IBet/21kbQ2eTIzakTdG3XiC+xzAQRu68
-EOCTbasFWGxlCix66gt4xWMLksEg8UhWSpjS3/HsifrKyNMB8sfUFYmZmOYMW4mf
-NuEtpBL3AdHNObN8nQ75HfehukzNpbYVRsLzWrVgtxvXHVpnvoCCpCvQBMHeRZxK
-6m028mhH1m6yYE/uGFiRKLrN7BKAttbUiqnGgVIg/lQQilFWwylxQ6aXqJGmNgxa
-oihzWZRlXivIhhrM7VMnLoKAF/YfmWpP3zahGpBQGfObtPtm44R0ezXPdtsivnyu
-CmFOPGzRNMKZtH/lwVhuIIK3AFIGDsRRP9ySN4YfjQZnTdu2sRlxBnANP9m8W9T2
-p+C4zVkDYAbsuWq2HpHwsdL8gqIiXeptsHLqkNw+ulSSLyeBCgM9fpV3RsNGjwqu
-k8QLb1CYp2VX46CE8UKvOd/nyFnEsD+EAc3WangEwA41m2IaXcbs9Au7xsG9oacZ
-DrxlJVNxlxO9YyP9dNOTfP0fHIiygKQQY2aU3y3oRneu7ogYES5V2mUNH7cYUWVL
-CHPXAoUXJErvDQ/opW2DroA9Eqv9sST6WqBf6LXRcWU0ntfzcFUbEqgmCmB7Cbu2
-8udEn6iWilQahLyDoAShLkU7+Tk78Z1c6RuqjyY4VboZPzxrTYK8YIXzwX+jj9bG
-KIIGS5eghK185+AjlwtzJ7MBdoL323YIik6uOZluhnJHLaxjxUXGa1VqDgsyqGi7
-ISRMTpVTrbR+UtoEi4ZhMjobtFUr7lGkt24VkXwBKdoyryj4RPHGdp7Tf6XDJufQ
-+KKhqt8QrpOTPiMskFN2disOSF5/YZCmtT84nkhU7Hf1lkQ2kfx1zfNk0GqYYXOW
-zHOAczy8gWBRetDMnhRYohDzQGWn//b+2Wr2n1RD8D9kyjMRhpFMYfQGfRcuPGjW
-91k/T0XFcjcjeZPL9s+HITmrh7zg5WxbCfTEp91j3Oy1bns196SY77TE0BzUsqR2
-geJggcUMEfyvHiiCMtijmSSD9nf8tNIxLVL8Jaf1coA6e1CrlHnYAu2f/Q3GIcvU
-EEEmw+cZRwsk4fffYzh5psxxGdXKBv1KcQ/CeBhZL0WJsCp2y5oxwg==
+KqHn2Df8hSuwNE+W+60MnGtc6xpoXmF3iN25iVwcN67krYn+N6cBhjFeXwXccYwJ
+2gHSu4iEK9Qe32vK0yuv8N9h/fmsabZl0TotnEem/pqO5T8W4LxyK+Rw0s6RB30S
+C+mUisRADTanAxyBxsNU8xR8OAUNMAAxV1me6It0W2lfNE3t5jg/Kr0NWMoRUNRx
+dkE6WlD5D8jBeC3QdZ6OuE7QXOCEAWAjcFMc0d1WJq2t2r3TrLVfTH7EOoRyvL1H
+rrFRx/dEW1UJfM6P11wB5R0nhg3rDXF7oDFszjwO/3tzARke0NZuN37l301lYRl1
+aolO6sShJLa0Ml/TgNcJw0S6rc6a1Z52gTfQKztKcL1UX4HLZg75zKmn6qfatMBC
+iXn+pQRYNsOPQ5h4r7lBBqvuV+gBw+rN768tYpZ2/YVDaygxETHcZAFCdAw/JNbP
+d0XPIbP79NRrCgzSo58LKQGuOQf3Hh0vp1YS+MilMtm/eogoj1enSPM+ymStHRwG
+i+D00xCQ6blSOZ2eUUBJXt11YzP22GYnv+XTR/5kGKkTIvoRMfd+39bQyR32IEv2
+Z+yweAGQInD94eifT9ObbIayJ47y01KP0+Vj6hz4RCFsmJKsYiai5JiKlmf7lV9w
+7zH3TtCOx/xSyomesXVRkqvFkdyeguU72kXc5tiMPaDXGCOeV0GWyR1GU1DUX9/K
+60E7ym0Wx77WGMKk2fkirZzBdOeliyCRUXd7ccN2rBCjTwtjAUIk27lwzdUaTUv7
+EmjauDvSMFtir58c+zjlLmBaSQOzKcj0KXMp0Oucls9bD85WGGbGyzGhTa0AZ+/+
+cCEJt7RAwW0kTEO/uO+BAZe/zBoi9ek+QBn54FK3E7CXfS4Oi9Qbc3fwlVyTlVmz
+ZGrCncO0TIVGErFWK24Z7lX8rBnk8enfnamrPfKtwn4LG9aDfhSj8DtisjlRUVT5
+chDQ+CCi9rh3wXh28lyS+nXJ3yFidCzRgcsc3PpN/c4DNRggZc+C/KDw+J2FW+8Y
+p65OliBQHQcG0PnCa2xRyCGevytPG0rfNDgyaY33dPEo90mBLVcwLbzGiSGBHgFl
+pr8A/rqbnFpRO39NYbACeRFCqPpzyzfARCCcjcDoFrENdIaJui0fjlBkoV3B/KiK
+EVjDcgwt1HAtz8bV2YJ+OpQbhD7E90e2vTRMuXAH21Ygo32VOS0LRlCRc9ZyZW4z
+PTyO/6a+FbXZ1zhVJxu/0bmBERZ14WVmWq56oxQav8knpxYeYPgpEmIZnrHnJ1Ko
+UoXcc8Hy4NKtaBmDcaF8TCobNsRZTxO/htqpdyNsOrBSsnX2kP5D/O1l1vuVYi1/
+RYfUqL9dvGzvfsFuuDDjDlQ/fIA6pFzJV3fy4KJHlF1r33qaE/lNMdpKljBwvUII
+Vog4cGmzxssqK5q9kuogcuyeOuFODjBNW4qt0WylSi9bwwy3ZwaZLRqhngz6+tCV
+Jp45Gk881XiVe3aVU0l+4DmJJ9/5vwqjH5Vo/GJqFU6gzB+Zv/0plYeNkuE0Xo2z
+ecdxnGKVPl42q44lvczjDw2KX0ahxQrfrbcl48//zR295u9POzCL97d6zpioI2NR
 -----END RSA PRIVATE KEY-----
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/helper.rb
@@ -0,0 +1,1620 @@
+# frozen_string_literal: true
+
+require "rubygems"
+
+# If bundler gemspec exists, add to stubs
+bundler_gemspec = File.expand_path("../../bundler/bundler.gemspec", __dir__)
+if File.exist?(bundler_gemspec)
+  Gem::Specification.dirs.unshift File.dirname(bundler_gemspec)
+  Gem::Specification.class_variable_set :@@stubs, nil
+  Gem::Specification.stubs
+  Gem::Specification.dirs.shift
+end
+
+begin
+  gem "test-unit", "~> 3.0"
+rescue Gem::LoadError
+end
+
+if File.exist?(bundler_gemspec)
+  require_relative "../../bundler/lib/bundler"
+else
+  require "bundler"
+end
+
+require "test/unit"
+
+ENV["JARS_SKIP"] = "true" if Gem.java_platform? # avoid unnecessary and noisy `jar-dependencies` post install hook
+
+require "rubygems/deprecate"
+
+require "fileutils"
+require "pathname"
+require "pp"
+require "rubygems/package"
+require "shellwords"
+require "tmpdir"
+require "uri"
+require "zlib"
+require "benchmark" # stdlib
+require "rubygems/mock_gem_ui"
+
+module Gem
+
+  ##
+  # Allows setting the gem path searcher.
+
+  def self.searcher=(searcher)
+    @searcher = searcher
+  end
+
+  ##
+  # Allows toggling Windows behavior.
+
+  def self.win_platform=(val)
+    @@win_platform = val
+  end
+
+  ##
+  # Allows setting path to Ruby.
+
+  def self.ruby=(ruby)
+    @ruby = ruby
+  end
+
+  ##
+  # Sets the default user interaction to a MockGemUi.
+
+  module DefaultUserInteraction
+    @ui = Gem::MockGemUi.new
+  end
+end
+
+require "rubygems/command"
+
+class Gem::Command
+  ##
+  # Allows resetting the hash of specific args per command.
+
+  def self.specific_extra_args_hash=(value)
+    @specific_extra_args_hash = value
+  end
+end
+
+##
+# RubyGemTestCase provides a variety of methods for testing rubygems and
+# gem-related behavior in a sandbox.  Through RubyGemTestCase you can install
+# and uninstall gems, fetch remote gems through a stub fetcher and be assured
+# your normal set of gems is not affected.
+
+class Gem::TestCase < Test::Unit::TestCase
+  extend Gem::Deprecate
+
+  attr_accessor :fetcher # :nodoc:
+
+  attr_accessor :gem_repo # :nodoc:
+
+  attr_accessor :uri # :nodoc:
+
+  def assert_activate(expected, *specs)
+    specs.each do |spec|
+      case spec
+      when String then
+        Gem::Specification.find_by_name(spec).activate
+      when Gem::Specification then
+        spec.activate
+      else
+        flunk spec.inspect
+      end
+    end
+
+    loaded = Gem.loaded_specs.values.map(&:full_name)
+
+    assert_equal expected.sort, loaded.sort if expected
+  end
+
+  def assert_directory_exists(path, msg = nil)
+    msg = build_message(msg, "Expected path '#{path}' to be a directory")
+    assert_path_exist path
+    assert File.directory?(path), msg
+  end
+
+  def refute_directory_exists(path, msg = nil)
+    msg = build_message(msg, "Expected path '#{path}' not to be a directory")
+    assert_path_not_exist path
+    refute File.directory?(path), msg
+  end
+
+  # https://github.com/seattlerb/minitest/blob/21d9e804b63c619f602f3f4ece6c71b48974707a/lib/minitest/assertions.rb#L188
+  def _synchronize
+    yield
+  end
+
+  # https://github.com/seattlerb/minitest/blob/21d9e804b63c619f602f3f4ece6c71b48974707a/lib/minitest/assertions.rb#L546
+  def capture_subprocess_io
+    _synchronize do
+      begin
+        require "tempfile"
+
+        captured_stdout, captured_stderr = Tempfile.new("out"), Tempfile.new("err")
+
+        orig_stdout, orig_stderr = $stdout.dup, $stderr.dup
+        $stdout.reopen captured_stdout
+        $stderr.reopen captured_stderr
+
+        yield
+
+        $stdout.rewind
+        $stderr.rewind
+
+        return captured_stdout.read, captured_stderr.read
+      ensure
+        $stdout.reopen orig_stdout
+        $stderr.reopen orig_stderr
+
+        orig_stdout.close
+        orig_stderr.close
+        captured_stdout.close!
+        captured_stderr.close!
+      end
+    end
+  end
+
+  ##
+  # Sets the ENABLE_SHARED entry in RbConfig::CONFIG to +value+ and restores
+  # the original value when the block ends
+
+  def enable_shared(value)
+    enable_shared = RbConfig::CONFIG["ENABLE_SHARED"]
+    RbConfig::CONFIG["ENABLE_SHARED"] = value
+
+    yield
+  ensure
+    if enable_shared
+      RbConfig::CONFIG["ENABLE_SHARED"] = enable_shared
+    else
+      RbConfig::CONFIG.delete "ENABLE_SHARED"
+    end
+  end
+
+  ##
+  # Sets the vendordir entry in RbConfig::CONFIG to +value+ and restores the
+  # original value when the block ends
+  #
+  def vendordir(value)
+    vendordir = RbConfig::CONFIG["vendordir"]
+
+    if value
+      RbConfig::CONFIG["vendordir"] = value
+    else
+      RbConfig::CONFIG.delete "vendordir"
+    end
+
+    yield
+  ensure
+    if vendordir
+      RbConfig::CONFIG["vendordir"] = vendordir
+    else
+      RbConfig::CONFIG.delete "vendordir"
+    end
+  end
+
+  ##
+  # Sets the bindir entry in RbConfig::CONFIG to +value+ and restores the
+  # original value when the block ends
+  #
+  def bindir(value)
+    with_clean_path_to_ruby do
+      bindir = RbConfig::CONFIG["bindir"]
+
+      if value
+        RbConfig::CONFIG["bindir"] = value
+      else
+        RbConfig::CONFIG.delete "bindir"
+      end
+
+      begin
+        yield
+      ensure
+        if bindir
+          RbConfig::CONFIG["bindir"] = bindir
+        else
+          RbConfig::CONFIG.delete "bindir"
+        end
+      end
+    end
+  end
+
+  ##
+  # Sets the EXEEXT entry in RbConfig::CONFIG to +value+ and restores the
+  # original value when the block ends
+  #
+  def exeext(value)
+    exeext = RbConfig::CONFIG["EXEEXT"]
+
+    if value
+      RbConfig::CONFIG["EXEEXT"] = value
+    else
+      RbConfig::CONFIG.delete "EXEEXT"
+    end
+
+    yield
+  ensure
+    if exeext
+      RbConfig::CONFIG["EXEEXT"] = exeext
+    else
+      RbConfig::CONFIG.delete "EXEEXT"
+    end
+  end
+
+  def scan_make_command_lines(output)
+    output.scan(/^#{Regexp.escape make_command}(?:[[:blank:]].*)?$/)
+  end
+
+  def parse_make_command_line_targets(line)
+    args = line.sub(/^#{Regexp.escape make_command}/, "").shellsplit
+
+    targets = []
+
+    args.each do |arg|
+      case arg
+      when /\A(\w+)=/
+      else
+        targets << arg
+      end
+    end
+
+    targets << "" if targets.empty?
+
+    targets
+  end
+
+  def assert_contains_make_command(target, output, msg = nil)
+    if output.match(/\n/)
+      msg = build_message(msg,
+        "Expected output containing make command \"%s\", but was \n\nBEGIN_OF_OUTPUT\n%sEND_OF_OUTPUT" % [
+          ("%s %s" % [make_command, target]).rstrip,
+          output,
+        ]
+      )
+    else
+      msg = build_message(msg,
+        'Expected make command "%s", but was "%s"' % [
+          ("%s %s" % [make_command, target]).rstrip,
+          output,
+        ]
+      )
+    end
+
+    assert scan_make_command_lines(output).any? {|line|
+      targets = parse_make_command_line_targets(line)
+
+      if targets.include?(target)
+        true
+      else
+        false
+      end
+    }, msg
+  end
+
+  include Gem::DefaultUserInteraction
+
+  ##
+  # #setup prepares a sandboxed location to install gems.  All installs are
+  # directed to a temporary directory.  All install plugins are removed.
+  #
+  # If the +RUBY+ environment variable is set the given path is used for
+  # Gem::ruby.  The local platform is set to <tt>i386-mswin32</tt> for Windows
+  # or <tt>i686-darwin8.10.1</tt> otherwise.
+
+  def setup
+    @orig_hooks = {}
+    @orig_env = ENV.to_hash
+    @tmp = File.expand_path("tmp")
+
+    FileUtils.mkdir_p @tmp
+
+    @tempdir = Dir.mktmpdir("test_rubygems_", @tmp)
+    @tempdir.tap(&Gem::UNTAINT)
+
+    ENV["GEM_VENDOR"] = nil
+    ENV["GEMRC"] = nil
+    ENV["XDG_CACHE_HOME"] = nil
+    ENV["XDG_CONFIG_HOME"] = nil
+    ENV["XDG_DATA_HOME"] = nil
+    ENV["SOURCE_DATE_EPOCH"] = nil
+    ENV["BUNDLER_VERSION"] = nil
+
+    @current_dir = Dir.pwd
+    @fetcher     = nil
+
+    @back_ui                       = Gem::DefaultUserInteraction.ui
+    @ui                            = Gem::MockGemUi.new
+    # This needs to be a new instance since we call use_ui(@ui) when we want to
+    # capture output
+    Gem::DefaultUserInteraction.ui = Gem::MockGemUi.new
+
+    @orig_SYSTEM_WIDE_CONFIG_FILE = Gem::ConfigFile::SYSTEM_WIDE_CONFIG_FILE
+    Gem::ConfigFile.send :remove_const, :SYSTEM_WIDE_CONFIG_FILE
+    Gem::ConfigFile.send :const_set, :SYSTEM_WIDE_CONFIG_FILE,
+                         File.join(@tempdir, "system-gemrc")
+
+    @gemhome  = File.join @tempdir, "gemhome"
+    @userhome = File.join @tempdir, "userhome"
+    ENV["GEM_SPEC_CACHE"] = File.join @tempdir, "spec_cache"
+
+    @orig_ruby = if ENV["RUBY"]
+      ruby = Gem.ruby
+      Gem.ruby = ENV["RUBY"]
+      ruby
+    end
+
+    @git = ENV["GIT"] || (win_platform? ? "git.exe" : "git")
+
+    Gem.ensure_gem_subdirectories @gemhome
+    Gem.ensure_default_gem_subdirectories @gemhome
+
+    @orig_LOAD_PATH = $LOAD_PATH.dup
+    $LOAD_PATH.map! do |s|
+      expand_path = File.realpath(s) rescue File.expand_path(s)
+      if expand_path != s
+        expand_path.tap(&Gem::UNTAINT)
+        if s.instance_variable_defined?(:@gem_prelude_index)
+          expand_path.instance_variable_set(:@gem_prelude_index, expand_path)
+        end
+        expand_path.freeze if s.frozen?
+        s = expand_path
+      end
+      s
+    end
+
+    Dir.chdir @tempdir
+
+    ENV["HOME"] = @userhome
+    Gem.instance_variable_set :@config_file, nil
+    Gem.instance_variable_set :@user_home, nil
+    Gem.instance_variable_set :@config_home, nil
+    Gem.instance_variable_set :@data_home, nil
+    Gem.instance_variable_set :@gemdeps, nil
+    Gem.instance_variable_set :@env_requirements_by_name, nil
+    Gem.send :remove_instance_variable, :@ruby_version if
+      Gem.instance_variables.include? :@ruby_version
+
+    FileUtils.mkdir_p @userhome
+
+    ENV["GEM_PRIVATE_KEY_PASSPHRASE"] = PRIVATE_KEY_PASSPHRASE
+
+    Gem.instance_variable_set(:@default_specifications_dir, nil)
+    if Gem.java_platform?
+      @orig_default_gem_home = RbConfig::CONFIG["default_gem_home"]
+      RbConfig::CONFIG["default_gem_home"] = @gemhome
+    else
+      Gem.instance_variable_set(:@default_dir, @gemhome)
+    end
+
+    @orig_bindir = RbConfig::CONFIG["bindir"]
+    RbConfig::CONFIG["bindir"] = File.join @gemhome, "bin"
+
+    @orig_sitelibdir = RbConfig::CONFIG["sitelibdir"]
+    new_sitelibdir = @orig_sitelibdir.sub(RbConfig::CONFIG["prefix"], @gemhome)
+    $LOAD_PATH.insert(Gem.load_path_insert_index, new_sitelibdir)
+    RbConfig::CONFIG["sitelibdir"] = new_sitelibdir
+
+    @orig_mandir = RbConfig::CONFIG["mandir"]
+    RbConfig::CONFIG["mandir"] = File.join @gemhome, "share", "man"
+
+    Gem::Specification.unresolved_deps.clear
+    Gem.use_paths(@gemhome)
+
+    Gem.loaded_specs.clear
+    Gem.instance_variable_set(:@activated_gem_paths, 0)
+    Gem.clear_default_specs
+    Bundler.reset!
+
+    Gem.configuration.verbose = true
+    Gem.configuration.update_sources = true
+
+    Gem::RemoteFetcher.fetcher = Gem::FakeFetcher.new
+
+    @gem_repo = "http://gems.example.com/"
+    @uri = URI.parse @gem_repo
+    Gem.sources.replace [@gem_repo]
+
+    Gem.searcher = nil
+    Gem::SpecFetcher.fetcher = nil
+
+    @orig_arch = RbConfig::CONFIG["arch"]
+
+    if win_platform?
+      util_set_arch "i386-mswin32"
+    else
+      util_set_arch "i686-darwin8.10.1"
+    end
+
+    %w[post_install_hooks done_installing_hooks post_uninstall_hooks pre_uninstall_hooks pre_install_hooks pre_reset_hooks post_reset_hooks post_build_hooks].each do |name|
+      @orig_hooks[name] = Gem.send(name).dup
+    end
+
+    @marshal_version = "#{Marshal::MAJOR_VERSION}.#{Marshal::MINOR_VERSION}"
+    @orig_LOADED_FEATURES = $LOADED_FEATURES.dup
+  end
+
+  ##
+  # #teardown restores the process to its original state and removes the
+  # tempdir
+
+  def teardown
+    $LOAD_PATH.replace @orig_LOAD_PATH if @orig_LOAD_PATH
+    if @orig_LOADED_FEATURES
+      if @orig_LOAD_PATH
+        ($LOADED_FEATURES - @orig_LOADED_FEATURES).each do |feat|
+          $LOADED_FEATURES.delete(feat) if feat.start_with?(@tmp)
+        end
+      else
+        $LOADED_FEATURES.replace @orig_LOADED_FEATURES
+      end
+    end
+
+    RbConfig::CONFIG["arch"] = @orig_arch
+
+    if defined? Gem::RemoteFetcher
+      Gem::RemoteFetcher.fetcher = nil
+    end
+
+    Dir.chdir @current_dir
+
+    FileUtils.rm_rf @tempdir
+
+    ENV.replace(@orig_env)
+
+    Gem::ConfigFile.send :remove_const, :SYSTEM_WIDE_CONFIG_FILE
+    Gem::ConfigFile.send :const_set, :SYSTEM_WIDE_CONFIG_FILE,
+                         @orig_SYSTEM_WIDE_CONFIG_FILE
+
+    Gem.ruby = @orig_ruby if @orig_ruby
+
+    RbConfig::CONFIG["mandir"] = @orig_mandir
+    RbConfig::CONFIG["sitelibdir"] = @orig_sitelibdir
+    RbConfig::CONFIG["bindir"] = @orig_bindir
+
+    Gem.instance_variable_set :@default_specifications_dir, nil
+    if Gem.java_platform?
+      RbConfig::CONFIG["default_gem_home"] = @orig_default_gem_home
+    else
+      Gem.instance_variable_set :@default_dir, nil
+    end
+
+    Gem::Specification.unresolved_deps.clear
+    Gem::refresh
+
+    @orig_hooks.each do |name, hooks|
+      Gem.send(name).replace hooks
+    end
+
+    @back_ui.close
+  end
+
+  def credential_setup
+    @temp_cred = File.join(@userhome, ".gem", "credentials")
+    FileUtils.mkdir_p File.dirname(@temp_cred)
+    File.write @temp_cred, ":rubygems_api_key: 701229f217cdf23b1344c7b4b54ca97"
+    File.chmod 0600, @temp_cred
+  end
+
+  def credential_teardown
+    FileUtils.rm_rf @temp_cred
+  end
+
+  def common_installer_setup
+    common_installer_teardown
+
+    Gem.post_build do |installer|
+      @post_build_hook_arg = installer
+      true
+    end
+
+    Gem.post_install do |installer|
+      @post_install_hook_arg = installer
+    end
+
+    Gem.post_uninstall do |uninstaller|
+      @post_uninstall_hook_arg = uninstaller
+    end
+
+    Gem.pre_install do |installer|
+      @pre_install_hook_arg = installer
+      true
+    end
+
+    Gem.pre_uninstall do |uninstaller|
+      @pre_uninstall_hook_arg = uninstaller
+    end
+  end
+
+  def common_installer_teardown
+    Gem.post_build_hooks.clear
+    Gem.post_install_hooks.clear
+    Gem.done_installing_hooks.clear
+    Gem.post_reset_hooks.clear
+    Gem.post_uninstall_hooks.clear
+    Gem.pre_install_hooks.clear
+    Gem.pre_reset_hooks.clear
+    Gem.pre_uninstall_hooks.clear
+  end
+
+  def without_any_upwards_gemfiles
+    ENV["BUNDLE_GEMFILE"] = File.join(@tempdir, "Gemfile")
+  end
+
+  ##
+  # A git_gem is used with a gem dependencies file.  The gem created here
+  # has no files, just a gem specification for the given +name+ and +version+.
+  #
+  # Yields the +specification+ to the block, if given
+
+  def git_gem(name = "a", version = 1)
+    have_git?
+
+    directory = File.join "git", name
+    directory = File.expand_path directory
+
+    git_spec = Gem::Specification.new name, version do |specification|
+      yield specification if block_given?
+    end
+
+    FileUtils.mkdir_p directory
+
+    gemspec = "#{name}.gemspec"
+
+    File.open File.join(directory, gemspec), "w" do |io|
+      io.write git_spec.to_ruby
+    end
+
+    head = nil
+
+    Dir.chdir directory do
+      unless File.exist? ".git"
+        system @git, "init", "--quiet"
+        system @git, "config", "user.name",  "RubyGems Tests"
+        system @git, "config", "user.email", "rubygems@example"
+      end
+
+      system @git, "add", gemspec
+      system @git, "commit", "-a", "-m", "a non-empty commit message", "--quiet"
+      head = Gem::Util.popen(@git, "rev-parse", "master").strip
+    end
+
+    return name, git_spec.version, directory, head
+  end
+
+  ##
+  # Skips this test unless you have a git executable
+
+  def have_git?
+    return if in_path? @git
+
+    pend "cannot find git executable, use GIT environment variable to set"
+  end
+
+  def in_path?(executable) # :nodoc:
+    return true if %r{\A([A-Z]:|/)} =~ executable && File.exist?(executable)
+
+    ENV["PATH"].split(File::PATH_SEPARATOR).any? do |directory|
+      File.exist? File.join directory, executable
+    end
+  end
+
+  ##
+  # Builds and installs the Gem::Specification +spec+
+
+  def install_gem(spec, options = {})
+    require "rubygems/installer"
+
+    gem = spec.cache_file
+
+    unless File.exist? gem
+      use_ui Gem::MockGemUi.new do
+        Dir.chdir @tempdir do
+          Gem::Package.build spec
+        end
+      end
+
+      gem = File.join(@tempdir, File.basename(gem)).tap(&Gem::UNTAINT)
+    end
+
+    Gem::Installer.at(gem, options.merge({ :wrappers => true })).install
+  end
+
+  ##
+  # Builds and installs the Gem::Specification +spec+ into the user dir
+
+  def install_gem_user(spec)
+    install_gem spec, :user_install => true
+  end
+
+  ##
+  # Uninstalls the Gem::Specification +spec+
+  def uninstall_gem(spec)
+    require "rubygems/uninstaller"
+
+    Class.new(Gem::Uninstaller) do
+      def ask_if_ok(spec)
+        true
+      end
+    end.new(spec.name, :executables => true, :user_install => true).uninstall
+  end
+
+  ##
+  # Enables pretty-print for all tests
+
+  def mu_pp(obj)
+    s = String.new
+    s = PP.pp obj, s
+    s = s.force_encoding(Encoding.default_external)
+    s.chomp
+  end
+
+  ##
+  # Reads a Marshal file at +path+
+
+  def read_cache(path)
+    File.open path.dup.tap(&Gem::UNTAINT), "rb" do |io|
+      Marshal.load io.read
+    end
+  end
+
+  ##
+  # Reads a binary file at +path+
+
+  def read_binary(path)
+    Gem.read_binary path
+  end
+
+  ##
+  # Writes a binary file to +path+ which is relative to +@gemhome+
+
+  def write_file(path)
+    path = File.join @gemhome, path unless Pathname.new(path).absolute?
+    dir = File.dirname path
+    FileUtils.mkdir_p dir unless File.directory? dir
+
+    File.open path, "wb" do |io|
+      yield io if block_given?
+    end
+
+    path
+  end
+
+  ##
+  # Load a YAML string, the psych 3 way
+
+  def load_yaml(yaml)
+    if Psych.respond_to?(:unsafe_load)
+      Psych.unsafe_load(yaml)
+    else
+      Psych.load(yaml)
+    end
+  end
+
+  ##
+  # Load a YAML file, the psych 3 way
+
+  def load_yaml_file(file)
+    if Psych.respond_to?(:unsafe_load_file)
+      Psych.unsafe_load_file(file)
+    else
+      Psych.load_file(file)
+    end
+  end
+
+  def all_spec_names
+    Gem::Specification.map(&:full_name)
+  end
+
+  ##
+  # Creates a Gem::Specification with a minimum of extra work.  +name+ and
+  # +version+ are the gem's name and version,  platform, author, email,
+  # homepage, summary and description are defaulted.  The specification is
+  # yielded for customization.
+  #
+  # The gem is added to the installed gems in +@gemhome+ and the runtime.
+  #
+  # Use this with #write_file to build an installed gem.
+
+  def quick_gem(name, version="2")
+    require "rubygems/specification"
+
+    spec = Gem::Specification.new do |s|
+      s.platform    = Gem::Platform::RUBY
+      s.name        = name
+      s.version     = version
+      s.author      = "A User"
+      s.email       = "example@example.com"
+      s.homepage    = "http://example.com"
+      s.summary     = "this is a summary"
+      s.description = "This is a test description"
+
+      yield(s) if block_given?
+    end
+
+    written_path = write_file spec.spec_file do |io|
+      io.write spec.to_ruby_for_cache
+    end
+
+    spec.loaded_from = written_path
+
+    Gem::Specification.reset
+
+    return spec
+  end
+
+  ##
+  # Builds a gem from +spec+ and places it in <tt>File.join @gemhome,
+  # 'cache'</tt>.  Automatically creates files based on +spec.files+
+
+  def util_build_gem(spec)
+    dir = spec.gem_dir
+    FileUtils.mkdir_p dir
+
+    Dir.chdir dir do
+      spec.files.each do |file|
+        next if File.exist? file
+        FileUtils.mkdir_p File.dirname(file)
+
+        File.open file, "w" do |fp|
+          fp.puts "# #{file}"
+        end
+      end
+
+      use_ui Gem::MockGemUi.new do
+        Gem::Package.build spec
+      end
+
+      cache = spec.cache_file
+      FileUtils.mv File.basename(cache), cache
+    end
+  end
+
+  def util_remove_gem(spec)
+    FileUtils.rm_rf spec.cache_file
+    FileUtils.rm_rf spec.spec_file
+  end
+
+  ##
+  # Removes all installed gems from +@gemhome+.
+
+  def util_clear_gems
+    FileUtils.rm_rf File.join(@gemhome, "gems")
+    FileUtils.mkdir File.join(@gemhome, "gems")
+    FileUtils.rm_rf File.join(@gemhome, "specifications")
+    FileUtils.mkdir File.join(@gemhome, "specifications")
+    Gem::Specification.reset
+  end
+
+  ##
+  # Install the provided specs
+
+  def install_specs(*specs)
+    specs.each do |spec|
+      Gem::Installer.for_spec(spec, :force => true).install
+    end
+
+    Gem.searcher = nil
+  end
+
+  ##
+  # Installs the provided default specs including writing the spec file
+
+  def install_default_gems(*specs)
+    specs.each do |spec|
+      installer = Gem::Installer.for_spec(spec, :install_as_default => true)
+      installer.install
+      Gem.register_default_spec(spec)
+    end
+  end
+
+  def loaded_spec_names
+    Gem.loaded_specs.values.map(&:full_name).sort
+  end
+
+  def unresolved_names
+    Gem::Specification.unresolved_deps.values.map(&:to_s).sort
+  end
+
+  def new_default_spec(name, version, deps = nil, *files)
+    spec = util_spec name, version, deps
+
+    spec.loaded_from = File.join(@gemhome, "specifications", "default", spec.spec_name)
+    spec.files = files
+
+    lib_dir = File.join(@tempdir, "default_gems", "lib")
+    lib_dir.instance_variable_set(:@gem_prelude_index, lib_dir)
+    Gem.instance_variable_set(:@default_gem_load_paths, [*Gem.send(:default_gem_load_paths), lib_dir])
+    $LOAD_PATH.unshift(lib_dir)
+    files.each do |file|
+      rb_path = File.join(lib_dir, file)
+      FileUtils.mkdir_p(File.dirname(rb_path))
+      File.open(rb_path, "w") do |rb|
+        rb << "# #{file}"
+      end
+    end
+
+    spec
+  end
+
+  ##
+  # Creates a spec with +name+, +version+.  +deps+ can specify the dependency
+  # or a +block+ can be given for full customization of the specification.
+
+  def util_spec(name, version = 2, deps = nil, *files) # :yields: specification
+    raise "deps or block, not both" if deps && block_given?
+
+    spec = Gem::Specification.new do |s|
+      s.platform    = Gem::Platform::RUBY
+      s.name        = name
+      s.version     = version
+      s.author      = "A User"
+      s.email       = "example@example.com"
+      s.homepage    = "http://example.com"
+      s.summary     = "this is a summary"
+      s.description = "This is a test description"
+
+      s.files.push(*files) unless files.empty?
+
+      yield s if block_given?
+    end
+
+    if deps
+      deps.keys.each do |n|
+        spec.add_dependency n, (deps[n] || ">= 0")
+      end
+    end
+
+    unless files.empty?
+      write_file spec.spec_file do |io|
+        io.write spec.to_ruby_for_cache
+      end
+
+      util_build_gem spec
+
+      FileUtils.rm spec.spec_file
+    end
+
+    return spec
+  end
+
+  ##
+  # Creates a gem with +name+, +version+ and +deps+.  The specification will
+  # be yielded before gem creation for customization.  The gem will be placed
+  # in <tt>File.join @tempdir, 'gems'</tt>.  The specification and .gem file
+  # location are returned.
+
+  def util_gem(name, version, deps = nil, &block)
+    if deps
+      block = proc do |s|
+        deps.keys.each do |n|
+          s.add_dependency n, (deps[n] || ">= 0")
+        end
+      end
+    end
+
+    spec = quick_gem(name, version, &block)
+
+    util_build_gem spec
+
+    cache_file = File.join @tempdir, "gems", "#{spec.original_name}.gem"
+    FileUtils.mkdir_p File.dirname cache_file
+    FileUtils.mv spec.cache_file, cache_file
+    FileUtils.rm spec.spec_file
+
+    spec.loaded_from = nil
+
+    [spec, cache_file]
+  end
+
+  ##
+  # Gzips +data+.
+
+  def util_gzip(data)
+    out = StringIO.new
+
+    Zlib::GzipWriter.wrap out do |io|
+      io.write data
+    end
+
+    out.string
+  end
+
+  ##
+  # Creates several default gems which all have a lib/code.rb file.  The gems
+  # are not installed but are available in the cache dir.
+  #
+  # +@a1+:: gem a version 1, this is the best-described gem.
+  # +@a2+:: gem a version 2
+  # +@a3a:: gem a version 3.a
+  # +@a_evil9+:: gem a_evil version 9, use this to ensure similarly-named gems
+  #              don't collide with a.
+  # +@b2+:: gem b version 2
+  # +@c1_2+:: gem c version 1.2
+  # +@pl1+:: gem pl version 1, this gem has a legacy platform of i386-linux.
+  #
+  # Additional +prerelease+ gems may also be created:
+  #
+  # +@a2_pre+:: gem a version 2.a
+  # TODO: nuke this and fix tests. this should speed up a lot
+
+  def util_make_gems(prerelease = false)
+    @a1 = quick_gem "a", "1" do |s|
+      s.files = %w[lib/code.rb]
+      s.require_paths = %w[lib]
+      s.date = Gem::Specification::TODAY - 86400
+      s.homepage = "http://a.example.com"
+      s.email = %w[example@example.com example2@example.com]
+      s.authors = %w[Example Example2]
+      s.description = <<-DESC
+This line is really, really long.  So long, in fact, that it is more than eighty characters long!  The purpose of this line is for testing wrapping behavior because sometimes people don't wrap their text to eighty characters.  Without the wrapping, the text might not look good in the RSS feed.
+
+Also, a list:
+  * An entry that\'s actually kind of sort
+  * an entry that\'s really long, which will probably get wrapped funny.  That's ok, somebody wasn't thinking straight when they made it more than eighty characters.
+      DESC
+    end
+
+    init = proc do |s|
+      s.files = %w[lib/code.rb]
+      s.require_paths = %w[lib]
+    end
+
+    @a2      = quick_gem("a", "2",      &init)
+    @a3a     = quick_gem("a", "3.a",    &init)
+    @a_evil9 = quick_gem("a_evil", "9", &init)
+    @b2      = quick_gem("b", "2",      &init)
+    @c1_2    = quick_gem("c", "1.2",    &init)
+    @x       = quick_gem("x", "1",      &init)
+    @dep_x   = quick_gem("dep_x", "1") do |s|
+      s.files = %w[lib/code.rb]
+      s.require_paths = %w[lib]
+      s.add_dependency "x", ">= 1"
+    end
+
+    @pl1 = quick_gem "pl", "1" do |s| # l for legacy
+      s.files = %w[lib/code.rb]
+      s.require_paths = %w[lib]
+      s.platform = Gem::Platform.new "i386-linux"
+      s.instance_variable_set :@original_platform, "i386-linux"
+    end
+
+    if prerelease
+      @a2_pre = quick_gem("a", "2.a", &init)
+      write_file File.join(*%W[gems #{@a2_pre.original_name} lib code.rb])
+      util_build_gem @a2_pre
+    end
+
+    write_file File.join(*%W[gems #{@a1.original_name}      lib code.rb])
+    write_file File.join(*%W[gems #{@a2.original_name}      lib code.rb])
+    write_file File.join(*%W[gems #{@a3a.original_name}     lib code.rb])
+    write_file File.join(*%W[gems #{@a_evil9.original_name} lib code.rb])
+    write_file File.join(*%W[gems #{@b2.original_name}      lib code.rb])
+    write_file File.join(*%W[gems #{@c1_2.original_name}    lib code.rb])
+    write_file File.join(*%W[gems #{@pl1.original_name}     lib code.rb])
+    write_file File.join(*%W[gems #{@x.original_name}       lib code.rb])
+    write_file File.join(*%W[gems #{@dep_x.original_name}   lib code.rb])
+
+    [@a1, @a2, @a3a, @a_evil9, @b2, @c1_2, @pl1, @x, @dep_x].each do |spec|
+      util_build_gem spec
+    end
+
+    FileUtils.rm_r File.join(@gemhome, "gems", @pl1.original_name)
+  end
+
+  ##
+  # Set the platform to +arch+
+
+  def util_set_arch(arch)
+    RbConfig::CONFIG["arch"] = arch
+    platform = Gem::Platform.new arch
+
+    Gem.instance_variable_set :@platforms, nil
+    Gem::Platform.instance_variable_set :@local, nil
+
+    yield if block_given?
+
+    platform
+  end
+
+  ##
+  # Add +spec+ to +@fetcher+ serving the data in the file +path+.
+  # +repo+ indicates which repo to make +spec+ appear to be in.
+
+  def add_to_fetcher(spec, path=nil, repo=@gem_repo)
+    path ||= spec.cache_file
+    @fetcher.data["#{@gem_repo}gems/#{spec.file_name}"] = read_binary(path)
+  end
+
+  ##
+  # Sets up Gem::SpecFetcher to return information from the gems in +specs+.
+
+  def util_setup_spec_fetcher(*specs)
+    all_specs = Gem::Specification.to_a + specs
+    Gem::Specification._resort! all_specs
+
+    spec_fetcher = Gem::SpecFetcher.fetcher
+
+    prerelease, all = all_specs.partition {|spec| spec.version.prerelease? }
+    latest = Gem::Specification._latest_specs all_specs
+
+    spec_fetcher.specs[@uri] = []
+    all.each do |spec|
+      spec_fetcher.specs[@uri] << spec.name_tuple
+    end
+
+    spec_fetcher.latest_specs[@uri] = []
+    latest.each do |spec|
+      spec_fetcher.latest_specs[@uri] << spec.name_tuple
+    end
+
+    spec_fetcher.prerelease_specs[@uri] = []
+    prerelease.each do |spec|
+      spec_fetcher.prerelease_specs[@uri] << spec.name_tuple
+    end
+
+    # HACK for test_download_to_cache
+    unless Gem::RemoteFetcher === @fetcher
+      v = Gem.marshal_version
+
+      specs = all.map {|spec| spec.name_tuple }
+      s_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic specs
+
+      latest_specs = latest.map do |spec|
+        spec.name_tuple
+      end
+
+      l_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic latest_specs
+
+      prerelease_specs = prerelease.map {|spec| spec.name_tuple }
+      p_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic prerelease_specs
+
+      @fetcher.data["#{@gem_repo}specs.#{v}.gz"]            = s_zip
+      @fetcher.data["#{@gem_repo}latest_specs.#{v}.gz"]     = l_zip
+      @fetcher.data["#{@gem_repo}prerelease_specs.#{v}.gz"] = p_zip
+
+      write_marshalled_gemspecs(*all_specs)
+    end
+
+    nil # force errors
+  end
+
+  def write_marshalled_gemspecs(*all_specs)
+    v = Gem.marshal_version
+
+    all_specs.each do |spec|
+      path = "#{@gem_repo}quick/Marshal.#{v}/#{spec.original_name}.gemspec.rz"
+      data = Marshal.dump spec
+      data_deflate = Zlib::Deflate.deflate data
+      @fetcher.data[path] = data_deflate
+    end
+  end
+
+  ##
+  # Deflates +data+
+
+  def util_zip(data)
+    Zlib::Deflate.deflate data
+  end
+
+  def util_set_RUBY_VERSION(version, patchlevel, revision, description, engine = "ruby", engine_version = nil)
+    if Gem.instance_variables.include? :@ruby_version
+      Gem.send :remove_instance_variable, :@ruby_version
+    end
+
+    @RUBY_VERSION        = RUBY_VERSION
+    @RUBY_PATCHLEVEL     = RUBY_PATCHLEVEL     if defined?(RUBY_PATCHLEVEL)
+    @RUBY_REVISION       = RUBY_REVISION       if defined?(RUBY_REVISION)
+    @RUBY_DESCRIPTION    = RUBY_DESCRIPTION
+    @RUBY_ENGINE         = RUBY_ENGINE
+    @RUBY_ENGINE_VERSION = RUBY_ENGINE_VERSION if defined?(RUBY_ENGINE_VERSION)
+
+    util_clear_RUBY_VERSION
+
+    Object.const_set :RUBY_VERSION,        version
+    Object.const_set :RUBY_PATCHLEVEL,     patchlevel
+    Object.const_set :RUBY_REVISION,       revision
+    Object.const_set :RUBY_DESCRIPTION,    description
+    Object.const_set :RUBY_ENGINE,         engine
+    Object.const_set :RUBY_ENGINE_VERSION, engine_version if engine_version
+  end
+
+  def util_restore_RUBY_VERSION
+    util_clear_RUBY_VERSION
+
+    Object.const_set :RUBY_VERSION,        @RUBY_VERSION
+    Object.const_set :RUBY_PATCHLEVEL,     @RUBY_PATCHLEVEL  if
+      defined?(@RUBY_PATCHLEVEL)
+    Object.const_set :RUBY_REVISION,       @RUBY_REVISION    if
+      defined?(@RUBY_REVISION)
+    Object.const_set :RUBY_DESCRIPTION,    @RUBY_DESCRIPTION
+    Object.const_set :RUBY_ENGINE,         @RUBY_ENGINE
+    Object.const_set :RUBY_ENGINE_VERSION, @RUBY_ENGINE_VERSION if
+      defined?(@RUBY_ENGINE_VERSION)
+  end
+
+  def util_clear_RUBY_VERSION
+    Object.send :remove_const, :RUBY_VERSION
+    Object.send :remove_const, :RUBY_PATCHLEVEL     if defined?(RUBY_PATCHLEVEL)
+    Object.send :remove_const, :RUBY_REVISION       if defined?(RUBY_REVISION)
+    Object.send :remove_const, :RUBY_DESCRIPTION    if defined?(RUBY_DESCRIPTION)
+    Object.send :remove_const, :RUBY_ENGINE
+    Object.send :remove_const, :RUBY_ENGINE_VERSION if defined?(RUBY_ENGINE_VERSION)
+  end
+
+  ##
+  # Is this test being run on a Windows platform?
+
+  def self.win_platform?
+    Gem.win_platform?
+  end
+
+  ##
+  # Is this test being run on a Windows platform?
+
+  def win_platform?
+    Gem.win_platform?
+  end
+
+  ##
+  # Is this test being run on a Java platform?
+
+  def self.java_platform?
+    Gem.java_platform?
+  end
+
+  ##
+  # Is this test being run on a Java platform?
+
+  def java_platform?
+    Gem.java_platform?
+  end
+
+  ##
+  # Returns whether or not we're on a version of Ruby built with VC++ (or
+  # Borland) versus Cygwin, Mingw, etc.
+
+  def self.vc_windows?
+    RUBY_PLATFORM.match("mswin")
+  end
+
+  ##
+  # Returns whether or not we're on a version of Ruby built with VC++ (or
+  # Borland) versus Cygwin, Mingw, etc.
+
+  def vc_windows?
+    RUBY_PLATFORM.match("mswin")
+  end
+
+  ##
+  # Is this test being run on a ruby/ruby repository?
+  #
+
+  def ruby_repo?
+    !ENV["GEM_COMMAND"].nil?
+  end
+
+  ##
+  # Returns the make command for the current platform. For versions of Ruby
+  # built on MS Windows with VC++ or Borland it will return 'nmake'. On all
+  # other platforms, including Cygwin, it will return 'make'.
+
+  def self.make_command
+    ENV["make"] || ENV["MAKE"] || (vc_windows? ? "nmake" : "make")
+  end
+
+  ##
+  # Returns the make command for the current platform. For versions of Ruby
+  # built on MS Windows with VC++ or Borland it will return 'nmake'. On all
+  # other platforms, including Cygwin, it will return 'make'.
+
+  def make_command
+    ENV["make"] || ENV["MAKE"] || (vc_windows? ? "nmake" : "make")
+  end
+
+  ##
+  # Returns whether or not the nmake command could be found.
+
+  def nmake_found?
+    system("nmake /? 1>NUL 2>&1")
+  end
+
+  # In case we're building docs in a background process, this method waits for
+  # that process to exit (or if it's already been reaped, or never happened,
+  # swallows the Errno::ECHILD error).
+  def wait_for_child_process_to_exit
+    Process.wait if Process.respond_to?(:fork)
+  rescue Errno::ECHILD
+  end
+
+  ##
+  # Allows tests to use a random (but controlled) port number instead of
+  # a hardcoded one. This helps CI tools when running parallels builds on
+  # the same builder slave.
+
+  def self.process_based_port
+    @@process_based_port ||= 8000 + $$ % 1000
+  end
+
+  ##
+  # See ::process_based_port
+
+  def process_based_port
+    self.class.process_based_port
+  end
+
+  ##
+  # Allows the proper version of +rake+ to be used for the test.
+
+  def build_rake_in(good=true)
+    gem_ruby = Gem.ruby
+    Gem.ruby = self.class.rubybin
+    env_rake = ENV["rake"]
+    rake = (good ? @@good_rake : @@bad_rake)
+    ENV["rake"] = rake
+    yield rake
+  ensure
+    Gem.ruby = gem_ruby
+    if env_rake
+      ENV["rake"] = env_rake
+    else
+      ENV.delete("rake")
+    end
+  end
+
+  ##
+  # Finds the path to the Ruby executable
+
+  def self.rubybin
+    ruby = ENV["RUBY"]
+    return ruby if ruby
+    ruby = "ruby"
+    rubyexe = "#{ruby}.exe"
+
+    3.times do
+      if File.exist?(ruby) && File.executable?(ruby) && !File.directory?(ruby)
+        return File.expand_path(ruby)
+      end
+      if File.exist?(rubyexe) && File.executable?(rubyexe)
+        return File.expand_path(rubyexe)
+      end
+      ruby = File.join("..", ruby)
+    end
+
+    begin
+      Gem.ruby
+    rescue LoadError
+      "ruby"
+    end
+  end
+
+  def ruby_with_rubygems_in_load_path
+    [Gem.ruby, "-I", rubygems_path]
+  end
+
+  def rubygems_path
+    $LOAD_PATH.find {|p| p == File.dirname($LOADED_FEATURES.find {|f| f.end_with?("/rubygems.rb") }) }
+  end
+
+  def with_clean_path_to_ruby
+    orig_ruby = Gem.ruby
+
+    Gem.instance_variable_set :@ruby, nil
+
+    yield
+  ensure
+    Gem.instance_variable_set :@ruby, orig_ruby
+  end
+
+  def with_internal_encoding(encoding)
+    int_enc = Encoding.default_internal
+    silence_warnings { Encoding.default_internal = encoding }
+
+    yield
+  ensure
+    silence_warnings { Encoding.default_internal = int_enc }
+  end
+
+  def silence_warnings
+    old_verbose, $VERBOSE = $VERBOSE, false
+    yield
+  ensure
+    $VERBOSE = old_verbose
+  end
+
+  class << self
+    # :nodoc:
+    ##
+    # Return the join path, with escaping backticks, dollars, and
+    # double-quotes.  Unlike `shellescape`, equal-sign is not escaped.
+
+    private
+
+    def escape_path(*path)
+      path = File.join(*path)
+      if %r{\A[-+:/=@,.\w]+\z} =~ path
+        path
+      else
+        "\"#{path.gsub(/[`$"]/, '\\&')}\""
+      end
+    end
+  end
+
+  @@good_rake = "#{rubybin} #{escape_path(__dir__, 'good_rake.rb')}"
+  @@bad_rake = "#{rubybin} #{escape_path(__dir__, 'bad_rake.rb')}"
+
+  ##
+  # Construct a new Gem::Dependency.
+
+  def dep(name, *requirements)
+    Gem::Dependency.new name, *requirements
+  end
+
+  ##
+  # Constructs a Gem::Resolver::DependencyRequest from a
+  # Gem::Dependency +dep+, a +from_name+ and +from_version+ requesting the
+  # dependency and a +parent+ DependencyRequest
+
+  def dependency_request(dep, from_name, from_version, parent = nil)
+    remote = Gem::Source.new @uri
+
+    unless parent
+      parent_dep = dep from_name, from_version
+      parent = Gem::Resolver::DependencyRequest.new parent_dep, nil
+    end
+
+    spec = Gem::Resolver::IndexSpecification.new \
+      nil, from_name, from_version, remote, Gem::Platform::RUBY
+    activation = Gem::Resolver::ActivationRequest.new spec, parent
+
+    Gem::Resolver::DependencyRequest.new dep, activation
+  end
+
+  ##
+  # Constructs a new Gem::Requirement.
+
+  def req(*requirements)
+    return requirements.first if Gem::Requirement === requirements.first
+    Gem::Requirement.create requirements
+  end
+
+  ##
+  # Constructs a new Gem::Specification.
+
+  def spec(name, version, &block)
+    Gem::Specification.new name, v(version), &block
+  end
+
+  ##
+  # Creates a SpecFetcher pre-filled with the gems or specs defined in the
+  # block.
+  #
+  # Yields a +fetcher+ object that responds to +spec+ and +gem+.  +spec+ adds
+  # a specification to the SpecFetcher while +gem+ adds both a specification
+  # and the gem data to the RemoteFetcher so the built gem can be downloaded.
+  #
+  # If only the a-3 gem is supposed to be downloaded you can save setup
+  # time by creating only specs for the other versions:
+  #
+  #   spec_fetcher do |fetcher|
+  #     fetcher.spec 'a', 1
+  #     fetcher.spec 'a', 2, 'b' => 3 # dependency on b = 3
+  #     fetcher.gem 'a', 3 do |spec|
+  #       # spec is a Gem::Specification
+  #       # ...
+  #     end
+  #   end
+
+  def spec_fetcher(repository = @gem_repo)
+    Gem::TestCase::SpecFetcherSetup.declare self, repository do |spec_fetcher_setup|
+      yield spec_fetcher_setup if block_given?
+    end
+  end
+
+  ##
+  # Construct a new Gem::Version.
+
+  def v(string)
+    Gem::Version.create string
+  end
+
+  ##
+  # A vendor_gem is used with a gem dependencies file.  The gem created here
+  # has no files, just a gem specification for the given +name+ and +version+.
+  #
+  # Yields the +specification+ to the block, if given
+
+  def vendor_gem(name = "a", version = 1)
+    directory = File.join "vendor", name
+
+    FileUtils.mkdir_p directory
+
+    save_gemspec name, version, directory
+  end
+
+  ##
+  # create_gemspec creates gem specification in given +directory+ or '.'
+  # for the given +name+ and +version+.
+  #
+  # Yields the +specification+ to the block, if given
+
+  def save_gemspec(name = "a", version = 1, directory = ".")
+    vendor_spec = Gem::Specification.new name, version do |specification|
+      yield specification if block_given?
+    end
+
+    File.open File.join(directory, "#{name}.gemspec"), "w" do |io|
+      io.write vendor_spec.to_ruby
+    end
+
+    return name, vendor_spec.version, directory
+  end
+
+  ##
+  # The StaticSet is a static set of gem specifications used for testing only.
+  # It is available by requiring Gem::TestCase.
+
+  class StaticSet < Gem::Resolver::Set
+    ##
+    # A StaticSet ignores remote because it has a fixed set of gems.
+
+    attr_accessor :remote
+
+    ##
+    # Creates a new StaticSet for the given +specs+
+
+    def initialize(specs)
+      super()
+
+      @specs = specs
+
+      @remote = true
+    end
+
+    ##
+    # Adds +spec+ to this set.
+
+    def add(spec)
+      @specs << spec
+    end
+
+    ##
+    # Finds +dep+ in this set.
+
+    def find_spec(dep)
+      @specs.reverse_each do |s|
+        return s if dep.matches_spec? s
+      end
+    end
+
+    ##
+    # Finds all gems matching +dep+ in this set.
+
+    def find_all(dep)
+      @specs.find_all {|s| dep.match? s, @prerelease }
+    end
+
+    ##
+    # Loads a Gem::Specification from this set which has the given +name+,
+    # version +ver+, +platform+.  The +source+ is ignored.
+
+    def load_spec(name, ver, platform, source)
+      dep = Gem::Dependency.new name, ver
+      spec = find_spec dep
+
+      Gem::Specification.new spec.name, spec.version do |s|
+        s.platform = spec.platform
+      end
+    end
+
+    def prefetch(reqs) # :nodoc:
+    end
+  end
+
+  ##
+  # Loads certificate named +cert_name+ from <tt>test/rubygems/</tt>.
+
+  def self.load_cert(cert_name)
+    cert_file = cert_path cert_name
+
+    cert = File.read cert_file
+
+    OpenSSL::X509::Certificate.new cert
+  end
+
+  ##
+  # Returns the path to the certificate named +cert_name+ from
+  # <tt>test/rubygems/</tt>.
+
+  def self.cert_path(cert_name)
+    if 32 == (Time.at(2**32) rescue 32)
+      cert_file = "#{__dir__}/#{cert_name}_cert_32.pem"
+
+      return cert_file if File.exist? cert_file
+    end
+
+    "#{__dir__}/#{cert_name}_cert.pem"
+  end
+
+  ##
+  # Loads a private key named +key_name+ with +passphrase+ in <tt>test/rubygems/</tt>
+
+  def self.load_key(key_name, passphrase = nil)
+    key_file = key_path key_name
+
+    key = File.read key_file
+
+    OpenSSL::PKey.read key, passphrase
+  end
+
+  ##
+  # Returns the path to the key named +key_name+ from <tt>test/rubygems</tt>
+
+  def self.key_path(key_name)
+    "#{__dir__}/#{key_name}_key.pem"
+  end
+
+  # :stopdoc:
+  # only available in RubyGems tests
+
+  PRIVATE_KEY_PASSPHRASE = "Foo bar".freeze
+
+  begin
+    PRIVATE_KEY                 = load_key "private"
+    PRIVATE_KEY_PATH            = key_path "private"
+
+    # ENCRYPTED_PRIVATE_KEY is PRIVATE_KEY encrypted with PRIVATE_KEY_PASSPHRASE
+    ENCRYPTED_PRIVATE_KEY       = load_key "encrypted_private", PRIVATE_KEY_PASSPHRASE
+    ENCRYPTED_PRIVATE_KEY_PATH  = key_path "encrypted_private"
+
+    PUBLIC_KEY                  = PRIVATE_KEY.public_key
+
+    PUBLIC_CERT                 = load_cert "public"
+    PUBLIC_CERT_PATH            = cert_path "public"
+  rescue Errno::ENOENT
+    PRIVATE_KEY = nil
+    PUBLIC_KEY  = nil
+    PUBLIC_CERT = nil
+  end if Gem::HAVE_OPENSSL
+end
+
+# https://github.com/seattlerb/minitest/blob/13c48a03d84a2a87855a4de0c959f96800100357/lib/minitest/mock.rb#L192
+class Object
+  def stub(name, val_or_callable, *block_args)
+    new_name = "__minitest_stub__#{name}"
+
+    metaclass = class << self; self; end
+
+    if respond_to?(name) && !methods.map(&:to_s).include?(name.to_s)
+      metaclass.send :define_method, name do |*args|
+        super(*args)
+      end
+    end
+
+    metaclass.send :alias_method, new_name, name
+
+    metaclass.send :define_method, name do |*args, &blk|
+      if val_or_callable.respond_to? :call
+        val_or_callable.call(*args, &blk)
+      else
+        blk.call(*block_args) if blk
+        val_or_callable
+      end
+    end
+
+    metaclass.send(:ruby2_keywords, name) if metaclass.respond_to?(:ruby2_keywords, true)
+
+    yield self
+  ensure
+    metaclass.send :undef_method, name
+    metaclass.send :alias_method, name, new_name
+    metaclass.send :undef_method, new_name
+  end unless method_defined?(:stub) # lib/resolv/test_dns.rb also has the same method definition
+end
+
+require_relative "utilities"
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/installer_test_case.rb
@@ -0,0 +1,247 @@
+# frozen_string_literal: true
+require_relative "helper"
+require "rubygems/installer"
+
+class Gem::Installer
+  ##
+  # Available through requiring rubygems/installer_test_case
+
+  attr_writer :bin_dir
+
+  ##
+  # Available through requiring rubygems/installer_test_case
+
+  attr_writer :build_args
+
+  ##
+  # Available through requiring rubygems/installer_test_case
+
+  attr_writer :gem_dir
+
+  ##
+  # Available through requiring rubygems/installer_test_case
+
+  attr_writer :force
+
+  ##
+  # Available through requiring rubygems/installer_test_case
+
+  attr_writer :format
+
+  ##
+  # Available through requiring rubygems/installer_test_case
+
+  attr_writer :gem_home
+
+  ##
+  # Available through requiring rubygems/installer_test_case
+
+  attr_writer :env_shebang
+
+  ##
+  # Available through requiring rubygems/installer_test_case
+
+  attr_writer :ignore_dependencies
+
+  ##
+  # Available through requiring rubygems/installer_test_case
+
+  attr_writer :format_executable
+
+  ##
+  # Available through requiring rubygems/installer_test_case
+
+  attr_writer :security_policy
+
+  ##
+  # Available through requiring rubygems/installer_test_case
+
+  attr_writer :wrappers
+end
+
+##
+# A test case for Gem::Installer.
+
+class Gem::InstallerTestCase < Gem::TestCase
+  def setup
+    super
+
+    Gem::Installer.path_warning = false
+  end
+
+  ##
+  # The path where installed executables live
+
+  def util_inst_bindir
+    File.join @gemhome, "bin"
+  end
+
+  ##
+  # Adds an executable named "executable" to +spec+ with the given +shebang+.
+  #
+  # The executable is also written to the bin dir in @tmpdir and the installed
+  # gem directory for +spec+.
+
+  def util_make_exec(spec = @spec, shebang = "#!/usr/bin/ruby", bindir = "bin")
+    spec.executables = %w[executable]
+    spec.bindir = bindir
+
+    exec_path = spec.bin_file "executable"
+    write_file exec_path do |io|
+      io.puts shebang
+    end
+
+    bin_path = File.join @tempdir, "bin", "executable"
+    write_file bin_path do |io|
+      io.puts shebang
+    end
+  end
+
+  ##
+  # Creates the following instance variables:
+  #
+  # @spec::
+  #   a spec named 'a', intended for regular installs
+  #
+  # @gem::
+  #   the path to a built gem from @spec
+  #
+  # And returns a Gem::Installer for the @spec that installs into @gemhome
+
+  def setup_base_installer(force = true)
+    @gem = setup_base_gem
+    util_installer @spec, @gemhome, false, force
+  end
+
+  ##
+  # Creates the following instance variables:
+  #
+  # @spec::
+  #   a spec named 'a', intended for regular installs
+  #
+  # And returns a gem built for the @spec
+
+  def setup_base_gem
+    @spec = setup_base_spec
+    util_build_gem @spec
+    @spec.cache_file
+  end
+
+  ##
+  # Sets up a generic specification for testing the rubygems installer
+  #
+  # And returns it
+
+  def setup_base_spec
+    quick_gem "a" do |spec|
+      util_make_exec spec
+    end
+  end
+
+  ##
+  # Creates the following instance variables:
+  #
+  # @spec::
+  #   a spec named 'a', intended for regular installs
+  # @user_spec::
+  #   a spec named 'b', intended for user installs
+  #
+  # @gem::
+  #   the path to a built gem from @spec
+  # @user_gem::
+  #   the path to a built gem from @user_spec
+  #
+  # And returns a Gem::Installer for the @user_spec that installs into Gem.user_dir
+
+  def setup_base_user_installer
+    @user_spec = quick_gem "b" do |spec|
+      util_make_exec spec
+    end
+
+    util_build_gem @user_spec
+
+    @user_gem = @user_spec.cache_file
+
+    util_installer @user_spec, Gem.user_dir, :user
+  end
+
+  ##
+  # Sets up the base @gem, builds it and returns an installer for it.
+  #
+  def util_setup_installer(&block)
+    @gem = setup_base_gem
+
+    util_setup_gem(&block)
+  end
+
+  ##
+  # Builds the @spec gem and returns an installer for it.  The built gem
+  # includes:
+  #
+  #   bin/executable
+  #   lib/code.rb
+  #   ext/a/mkrf_conf.rb
+
+  def util_setup_gem(ui = @ui, force = true)
+    @spec.files << File.join("lib", "code.rb")
+    @spec.extensions << File.join("ext", "a", "mkrf_conf.rb")
+
+    Dir.chdir @tempdir do
+      FileUtils.mkdir_p "bin"
+      FileUtils.mkdir_p "lib"
+      FileUtils.mkdir_p File.join("ext", "a")
+
+      File.open File.join("bin", "executable"), "w" do |f|
+        f.puts "raise 'ran executable'"
+      end
+
+      File.open File.join("lib", "code.rb"), "w" do |f|
+        f.puts "1"
+      end
+
+      File.open File.join("ext", "a", "mkrf_conf.rb"), "w" do |f|
+        f << <<-EOF
+          File.open 'Rakefile', 'w' do |rf| rf.puts "task :default" end
+        EOF
+      end
+
+      yield @spec if block_given?
+
+      use_ui ui do
+        FileUtils.rm_f @gem
+
+        @gem = Gem::Package.build @spec
+      end
+    end
+
+    Gem::Installer.at @gem, :force => force
+  end
+
+  ##
+  # Creates an installer for +spec+ that will install into +gem_home+.  If
+  # +user+ is true a user-install will be performed.
+
+  def util_installer(spec, gem_home, user=false, force=true)
+    Gem::Installer.at(spec.cache_file,
+                       :install_dir => gem_home,
+                       :user_install => user,
+                       :force => force)
+  end
+
+  @@symlink_supported = nil
+
+  # This is needed for Windows environment without symlink support enabled (the default
+  # for non admin) to be able to skip test for features using symlinks.
+  def symlink_supported?
+    if @@symlink_supported.nil?
+      begin
+        File.symlink("", "")
+      rescue Errno::ENOENT, Errno::EEXIST
+        @@symlink_supported = true
+      rescue NotImplementedError, SystemCallError
+        @@symlink_supported = false
+      end
+    end
+    @@symlink_supported
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/package/tar_test_case.rb
@@ -0,0 +1,139 @@
+# frozen_string_literal: true
+require_relative "../helper"
+require "rubygems/package"
+
+##
+# A test case for Gem::Package::Tar* classes
+
+class Gem::Package::TarTestCase < Gem::TestCase
+  def ASCIIZ(str, length)
+    str + "\0" * (length - str.length)
+  end
+
+  def SP(s)
+    s + " "
+  end
+
+  def SP_Z(s)
+    s + " \0"
+  end
+
+  def Z(s)
+    s + "\0"
+  end
+
+  def assert_headers_equal(expected, actual)
+    expected = expected.to_s unless String === expected
+    actual = actual.to_s unless String === actual
+
+    fields = %w[
+      name 100
+      mode 8
+      uid 8
+      gid 8
+      size 12
+      mtime 12
+      checksum 8
+      typeflag 1
+      linkname 100
+      magic 6
+      version 2
+      uname 32
+      gname 32
+      devmajor 8
+      devminor 8
+      prefix 155
+    ]
+
+    offset = 0
+
+    until fields.empty? do
+      name = fields.shift
+      length = fields.shift.to_i
+
+      if name == "checksum"
+        chksum_off = offset
+        offset += length
+        next
+      end
+
+      assert_equal expected[offset, length], actual[offset, length],
+                   "Field #{name} of the tar header differs."
+
+      offset += length
+    end
+
+    assert_equal expected[chksum_off, 8], actual[chksum_off, 8]
+  end
+
+  def calc_checksum(header)
+    sum = header.unpack("C*").inject {|s,a| s + a }
+    SP(Z(to_oct(sum, 6)))
+  end
+
+  def header(type, fname, dname, length, mode, mtime, checksum = nil, linkname = "")
+    checksum ||= " " * 8
+
+    arr = [                  # struct tarfile_entry_posix
+      ASCIIZ(fname, 100),    # char name[100];     ASCII + (Z unless filled)
+      Z(to_oct(mode, 7)),    # char mode[8];       0 padded, octal null
+      Z(to_oct(0, 7)),       # char uid[8];        ditto
+      Z(to_oct(0, 7)),       # char gid[8];        ditto
+      Z(to_oct(length, 11)), # char size[12];      0 padded, octal, null
+      Z(to_oct(mtime, 11)),  # char mtime[12];     0 padded, octal, null
+      checksum,              # char checksum[8];   0 padded, octal, null, space
+      type,                  # char typeflag[1];   file: "0"  dir: "5"
+      ASCIIZ(linkname, 100), # char linkname[100]; ASCII + (Z unless filled)
+      "ustar\0",             # char magic[6];      "ustar\0"
+      "00",                  # char version[2];    "00"
+      ASCIIZ("wheel", 32),   # char uname[32];     ASCIIZ
+      ASCIIZ("wheel", 32),   # char gname[32];     ASCIIZ
+      Z(to_oct(0, 7)),       # char devmajor[8];   0 padded, octal, null
+      Z(to_oct(0, 7)),       # char devminor[8];   0 padded, octal, null
+      ASCIIZ(dname, 155), # char prefix[155];   ASCII + (Z unless filled)
+    ]
+
+    h = arr.join
+    ret = h + "\0" * (512 - h.size)
+    assert_equal(512, ret.size)
+    ret
+  end
+
+  def tar_dir_header(name, prefix, mode, mtime)
+    h = header("5", name, prefix, 0, mode, mtime)
+    checksum = calc_checksum(h)
+    header("5", name, prefix, 0, mode, mtime, checksum)
+  end
+
+  def tar_file_header(fname, dname, mode, length, mtime)
+    h = header("0", fname, dname, length, mode, mtime)
+    checksum = calc_checksum(h)
+    header("0", fname, dname, length, mode, mtime, checksum)
+  end
+
+  def tar_symlink_header(fname, prefix, mode, mtime, linkname)
+    h = header("2", fname, prefix, 0, mode, mtime, nil, linkname)
+    checksum = calc_checksum(h)
+    header("2", fname, prefix, 0, mode, mtime, checksum, linkname)
+  end
+
+  def to_oct(n, pad_size)
+    "%0#{pad_size}o" % n
+  end
+
+  def util_entry(tar)
+    io = TempIO.new tar
+
+    header = Gem::Package::TarHeader.from io
+
+    Gem::Package::TarReader::Entry.new header, io
+  end
+
+  def util_dir_entry
+    util_entry tar_dir_header("foo", "bar", 0, Time.now)
+  end
+
+  def util_symlink_entry
+    util_entry tar_symlink_header("foo", "bar", 0, Time.now, "link")
+  end
+end
--- ruby2.7-2.7.6.orig/test/rubygems/plugin/exception/rubygems_plugin.rb
+++ ruby2.7-2.7.6/test/rubygems/plugin/exception/rubygems_plugin.rb
@@ -1,3 +1,3 @@
 # frozen_string_literal: true
 TestGem::TEST_PLUGIN_EXCEPTION = :loaded
-raise Exception.new('boom')
+raise Exception.new("boom")
--- ruby2.7-2.7.6.orig/test/rubygems/plugin/load/rubygems_plugin.rb
+++ ruby2.7-2.7.6/test/rubygems/plugin/load/rubygems_plugin.rb
@@ -1,6 +1,4 @@
 # frozen_string_literal: true
 class TestGem
-
   TEST_PLUGIN_LOAD = :loaded
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/plugin/standarderror/rubygems_plugin.rb
+++ ruby2.7-2.7.6/test/rubygems/plugin/standarderror/rubygems_plugin.rb
@@ -1,3 +1,3 @@
 # frozen_string_literal: true
 TestGem::TEST_PLUGIN_STANDARDERROR = :loaded
-raise StandardError.new('boom')
+raise StandardError.new("boom")
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/private_ec_key.pem
@@ -0,0 +1,9 @@
+-----BEGIN EC PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: AES-256-CBC,4107F98A374CB8EC18F1AA4EA4B6A0DB
+
+BRklFxJGcz7gqQYxek8TZkt8qbPhB0FSR6nyw3SYuio/2tlT9ohs74mlK3EbG9Lt
+Y4OquJbksBFmoB7fIoM4vnuIZ0Eoz2ooxn9tjhBtqJ3mVscYXwZmA3UDUWDMlviQ
+Fu37OpikQv4TFA1jlmUK0LM8xmUCfUeLl0kHD17lFsz2gkO2kwg8mn/YUMOIaDOu
+EnnmxbAwnZBpemQkQfpTt2mYL9gu3CcMt5gokBuGDxY=
+-----END EC PRIVATE KEY-----
--- ruby2.7-2.7.6.orig/test/rubygems/rubygems/commands/crash_command.rb
+++ ruby2.7-2.7.6/test/rubygems/rubygems/commands/crash_command.rb
@@ -1,6 +1,4 @@
 # frozen_string_literal: true
 class Gem::Commands::CrashCommand < Gem::Command
-
   raise "crash"
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/rubygems_plugin.rb
+++ ruby2.7-2.7.6/test/rubygems/rubygems_plugin.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/command_manager'
+require "rubygems/command_manager"
 
 ##
 # This is an example of exactly what NOT to do.
@@ -11,15 +11,13 @@ module Gem::Commands
 end
 
 class Gem::Commands::InterruptCommand < Gem::Command
-
   def initialize
-    super('interrupt', 'Raises an Interrupt Exception', {})
+    super("interrupt", "Raises an Interrupt Exception", {})
   end
 
   def execute
     raise Interrupt, "Interrupt exception"
   end
-
 end
 
 Gem::CommandManager.instance.register_command :interrupt
--- ruby2.7-2.7.6.orig/test/rubygems/specifications/bar-0.0.2.gemspec
+++ ruby2.7-2.7.6/test/rubygems/specifications/bar-0.0.2.gemspec
@@ -1,5 +1,3 @@
-# -*- encoding: utf-8 -*-
-
 Gem::Specification.new do |s|
   s.name          = "bar"
   s.version       = "0.0.2"
--- ruby2.7-2.7.6.orig/test/rubygems/specifications/rubyforge-0.0.1.gemspec
+++ ruby2.7-2.7.6/test/rubygems/specifications/rubyforge-0.0.1.gemspec
@@ -1,5 +1,3 @@
-# -*- encoding: utf-8 -*-
-
 Gem::Specification.new do |s|
   s.name              = "rubyforge"
   s.version           = "0.0.1"
@@ -7,8 +5,8 @@ Gem::Specification.new do |s|
   s.require_paths     = ["lib"]
   s.summary           = "A very bar gem"
   s.authors           = ["unknown"]
-  s.license           = 'MIT'
-  s.homepage          = 'http://example.com'
-  s.files             = ['README.md']
-  s.rubyforge_project = 'abc'
+  s.license           = "MIT"
+  s.homepage          = "http://example.com"
+  s.files             = ["README.md"]
+  s.rubyforge_project = "abc"
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_bundled_ca.rb
+++ ruby2.7-2.7.6/test/rubygems/test_bundled_ca.rb
@@ -1,67 +1,60 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'net/https'
-require 'rubygems/request'
+require_relative "helper"
+require "net/http"
+require "rubygems/openssl"
+
+unless Gem::HAVE_OPENSSL
+  warn "Skipping bundled certificates tests.  openssl not found."
+end
+
+require "rubygems/request"
 
 # = Testing Bundled CA
 #
 # The tested hosts are explained in detail here: https://github.com/rubygems/rubygems/commit/5e16a5428f973667cabfa07e94ff939e7a83ebd9
 #
 
-if ENV["CI"] || ENV["TEST_SSL"]
-  class TestBundledCA < Gem::TestCase
-
-    THIS_FILE = File.expand_path __FILE__
-
-    def bundled_certificate_store
-      store = OpenSSL::X509::Store.new
+class TestBundledCA < Gem::TestCase
+  def bundled_certificate_store
+    store = OpenSSL::X509::Store.new
 
-      ssl_cert_glob =
-        File.expand_path '../../../lib/rubygems/ssl_certs/*/*.pem', THIS_FILE
-
-      Dir[ssl_cert_glob].each do |ssl_cert|
-        store.add_file ssl_cert
-      end
-
-      store
+    Gem::Request.get_cert_files.each do |ssl_cert|
+      store.add_file ssl_cert
     end
 
-    def assert_https(host)
-      if self.respond_to? :_assertions # minitest <= 4
-        self._assertions += 1
-      else # minitest >= 5
-        self.assertions += 1
-      end
-      http = Net::HTTP.new(host, 443)
-      http.use_ssl = true
-      http.verify_mode = OpenSSL::SSL::VERIFY_PEER
-      http.cert_store = bundled_certificate_store
-      http.get('/')
-    rescue Errno::ENOENT, Errno::ETIMEDOUT, SocketError
-      skip "#{host} seems offline, I can't tell whether ssl would work."
-    rescue OpenSSL::SSL::SSLError => e
-      # Only fail for certificate verification errors
-      if e.message =~ /certificate verify failed/
-        flunk "#{host} is not verifiable using the included certificates. Error was: #{e.message}"
-      end
-      raise
-    end
+    store
+  end
 
-    def test_accessing_rubygems
-      assert_https('rubygems.org')
+  def assert_https(host)
+    assert true
+    http = Net::HTTP.new(host, 443)
+    http.use_ssl = true
+    http.verify_mode = OpenSSL::SSL::VERIFY_PEER
+    http.cert_store = bundled_certificate_store
+    http.get("/")
+  rescue Errno::ENOENT, Errno::ETIMEDOUT, SocketError
+    pend "#{host} seems offline, I can't tell whether ssl would work."
+  rescue OpenSSL::SSL::SSLError => e
+    # Only fail for certificate verification errors
+    if e.message =~ /certificate verify failed/
+      flunk "#{host} is not verifiable using the included certificates. Error was: #{e.message}"
     end
+    raise
+  end
 
-    def test_accessing_www_rubygems
-      assert_https('www.rubygems.org')
-    end
+  def test_accessing_rubygems
+    assert_https("rubygems.org")
+  end
 
-    def test_accessing_staging
-      assert_https('staging.rubygems.org')
-    end
+  def test_accessing_www_rubygems
+    assert_https("www.rubygems.org")
+  end
 
-    def test_accessing_new_index
-      assert_https('index.rubygems.org')
-    end
+  def test_accessing_staging
+    assert_https("staging.rubygems.org")
+  end
 
+  def test_accessing_new_index
+    assert_https("index.rubygems.org")
   end
-end
+end if Gem::HAVE_OPENSSL
--- ruby2.7-2.7.6.orig/test/rubygems/test_config.rb
+++ ruby2.7-2.7.6/test/rubygems/test_config.rb
@@ -1,10 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems'
-require 'shellwords'
+require_relative "helper"
+require "rubygems"
+require "shellwords"
 
 class TestConfig < Gem::TestCase
-
   def test_datadir
     util_make_gems
     spec = Gem::Specification.find_by_name("a")
@@ -13,17 +12,16 @@ class TestConfig < Gem::TestCase
   end
 
   def test_good_rake_path_is_escaped
-    path = Gem::TestCase.class_eval('@@good_rake')
+    path = Gem::TestCase.class_variable_get(:@@good_rake)
     ruby, rake = path.shellsplit
     assert_equal(Gem.ruby, ruby)
     assert_match(/\/good_rake.rb\z/, rake)
   end
 
   def test_bad_rake_path_is_escaped
-    path = Gem::TestCase.class_eval('@@bad_rake')
+    path = Gem::TestCase.class_variable_get(:@@bad_rake)
     ruby, rake = path.shellsplit
     assert_equal(Gem.ruby, ruby)
     assert_match(/\/bad_rake.rb\z/, rake)
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_deprecate.rb
+++ ruby2.7-2.7.6/test/rubygems/test_deprecate.rb
@@ -1,15 +1,11 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-# require 'rubygems/builder'
-# require 'rubygems/package'
-require 'rubygems/deprecate'
+require_relative "helper"
+require "rubygems/deprecate"
 
 class TestDeprecate < Gem::TestCase
-
   def setup
     super
 
-    # Gem::Deprecate.saved_warnings.clear
     @original_skip = Gem::Deprecate.skip
     Gem::Deprecate.skip = false
   end
@@ -17,7 +13,6 @@ class TestDeprecate < Gem::TestCase
   def teardown
     super
 
-    # Gem::Deprecate.saved_warnings.clear
     Gem::Deprecate.skip = @original_skip
   end
 
@@ -45,7 +40,34 @@ class TestDeprecate < Gem::TestCase
   end
 
   class Thing
+    extend Gem::Deprecate
+    attr_accessor :message
+    def foo
+      @message = "foo"
+    end
+    def bar
+      @message = "bar"
+    end
+    rubygems_deprecate :foo, :bar
+
+    def foo_arg(msg)
+      @message = "foo" + msg
+    end
+    def bar_arg(msg)
+      @message = "bar" + msg
+    end
+    rubygems_deprecate :foo_arg, :bar_arg
+
+    def foo_kwarg(message:)
+      @message = "foo" + message
+    end
+    def bar_kwarg(message:)
+      @message = "bar" + message
+    end
+    rubygems_deprecate :foo_kwarg, :bar_kwarg
+  end
 
+  class OtherThing
     extend Gem::Deprecate
     attr_accessor :message
     def foo
@@ -56,25 +78,80 @@ class TestDeprecate < Gem::TestCase
     end
     deprecate :foo, :bar, 2099, 3
 
+    def foo_arg(msg)
+      @message = "foo" + msg
+    end
+    def bar_arg(msg)
+      @message = "bar" + msg
+    end
+    deprecate :foo_arg, :bar_arg, 2099, 3
+
+    def foo_kwarg(message:)
+      @message = "foo" + message
+    end
+    def bar_kwarg(message:)
+      @message = "bar" + message
+    end
+    deprecate :foo_kwarg, :bar_kwarg, 2099, 3
   end
 
   def test_deprecated_method_calls_the_old_method
-    capture_io do
+    capture_output do
       thing = Thing.new
       thing.foo
       assert_equal "foo", thing.message
+      thing.foo_arg("msg")
+      assert_equal "foomsg", thing.message
+      thing.foo_kwarg(message: "msg")
+      assert_equal "foomsg", thing.message
     end
   end
 
   def test_deprecated_method_outputs_a_warning
-    out, err = capture_io do
+    out, err = capture_output do
       thing = Thing.new
       thing.foo
+      thing.foo_arg("msg")
+      thing.foo_kwarg(message: "msg")
     end
 
     assert_equal "", out
     assert_match(/Thing#foo is deprecated; use bar instead\./, err)
-    assert_match(/on or after 2099-03-01/, err)
+    assert_match(/Thing#foo_arg is deprecated; use bar_arg instead\./, err)
+    assert_match(/Thing#foo_kwarg is deprecated; use bar_kwarg instead\./, err)
+    assert_match(/in Rubygems [0-9]+/, err)
+  end
+
+  def test_rubygems_deprecate_command
+    require "rubygems/command"
+    foo_command = Class.new(Gem::Command) do
+      extend Gem::Deprecate
+
+      rubygems_deprecate_command
+
+      def execute
+        puts "pew pew!"
+      end
+    end
+
+    Gem::Commands.send(:const_set, :FooCommand, foo_command)
+    assert Gem::Commands::FooCommand.new("foo").deprecated?
+  ensure
+    Gem::Commands.send(:remove_const, :FooCommand)
   end
 
+  def test_deprecated_method_outputs_a_warning_old_way
+    out, err = capture_output do
+      thing = OtherThing.new
+      thing.foo
+      thing.foo_arg("msg")
+      thing.foo_kwarg(message: "msg")
+    end
+
+    assert_equal "", out
+    assert_match(/OtherThing#foo is deprecated; use bar instead\./, err)
+    assert_match(/OtherThing#foo_arg is deprecated; use bar_arg instead\./, err)
+    assert_match(/OtherThing#foo_kwarg is deprecated; use bar_kwarg instead\./, err)
+    assert_match(/on or after 2099-03/, err)
+  end
 end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_exit.rb
@@ -0,0 +1,11 @@
+# frozen_string_literal: true
+
+require_relative "helper"
+require "rubygems"
+
+class TestExit < Gem::TestCase
+  def test_exit
+    system(*ruby_with_rubygems_in_load_path, "-e", "raise Gem::SystemExitException.new(2)")
+    assert_equal 2, $?.exitstatus
+  end
+end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem.rb
@@ -1,27 +1,16 @@
 # coding: US-ASCII
-require 'rubygems/test_case'
-require 'rubygems'
-require 'rubygems/command'
-require 'rubygems/installer'
-require 'pathname'
-require 'tmpdir'
-require 'rbconfig'
-
-if File.exist?(File.join(Dir.tmpdir, "Gemfile"))
-  raise "rubygems/bundler tests do not work correctly if there is #{ File.join(Dir.tmpdir, "Gemfile") }"
-end
-
-# TODO: push this up to test_case.rb once battle tested
-
-$LOAD_PATH.map! do |path|
-  path.dup.tap(&Gem::UNTAINT)
-end
+require_relative "helper"
+require "rubygems"
+require "rubygems/command"
+require "rubygems/installer"
+require "pathname"
+require "tmpdir"
+require "rbconfig"
 
 class TestGem < Gem::TestCase
-
   PLUGINS_LOADED = [] # rubocop:disable Style/MutableConstant
 
-  PROJECT_DIR = File.expand_path('../../..', __FILE__).tap(&Gem::UNTAINT)
+  PROJECT_DIR = File.expand_path("../..", __dir__).tap(&Gem::UNTAINT)
 
   def setup
     super
@@ -30,111 +19,104 @@ class TestGem < Gem::TestCase
 
     common_installer_setup
 
-    ENV.delete 'RUBYGEMS_GEMDEPS'
-    @additional = %w[a b].map { |d| File.join @tempdir, d }
+    @additional = %w[a b].map {|d| File.join @tempdir, d }
 
     util_remove_interrupt_command
   end
 
   def test_self_finish_resolve
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      b1 = util_spec "b", "1", "c" => ">= 1"
-      b2 = util_spec "b", "2", "c" => ">= 2"
-      c1 = util_spec "c", "1"
-      c2 = util_spec "c", "2"
+    a1 = util_spec "a", "1", "b" => "> 0"
+    b1 = util_spec "b", "1", "c" => ">= 1"
+    b2 = util_spec "b", "2", "c" => ">= 2"
+    c1 = util_spec "c", "1"
+    c2 = util_spec "c", "2"
 
-      install_specs c1, c2, b1, b2, a1
+    install_specs c1, c2, b1, b2, a1
 
-      a1.activate
+    a1.activate
 
-      assert_equal %w(a-1), loaded_spec_names
-      assert_equal ["b (> 0)"], unresolved_names
+    assert_equal %w[a-1], loaded_spec_names
+    assert_equal ["b (> 0)"], unresolved_names
 
-      Gem.finish_resolve
+    Gem.finish_resolve
 
-      assert_equal %w(a-1 b-2 c-2), loaded_spec_names
-      assert_equal [], unresolved_names
-    end
+    assert_equal %w[a-1 b-2 c-2], loaded_spec_names
+    assert_equal [], unresolved_names
   end
 
   def test_self_finish_resolve_wtf
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0", "d" => "> 0"    # this
-      b1 = util_spec "b", "1", { "c" => ">= 1" }, "lib/b.rb" # this
-      b2 = util_spec "b", "2", { "c" => ">= 2" }, "lib/b.rb"
-      c1 = util_spec "c", "1"                                # this
-      c2 = util_spec "c", "2"
-      d1 = util_spec "d", "1", { "c" => "< 2" },  "lib/d.rb"
-      d2 = util_spec "d", "2", { "c" => "< 2" },  "lib/d.rb" # this
-
-      install_specs c1, c2, b1, b2, d1, d2, a1
-
-      a1.activate
+    a1 = util_spec "a", "1", "b" => "> 0", "d" => "> 0"    # this
+    b1 = util_spec "b", "1", { "c" => ">= 1" }, "lib/b.rb" # this
+    b2 = util_spec "b", "2", { "c" => ">= 2" }, "lib/b.rb"
+    c1 = util_spec "c", "1"                                # this
+    c2 = util_spec "c", "2"
+    d1 = util_spec "d", "1", { "c" => "< 2" },  "lib/d.rb"
+    d2 = util_spec "d", "2", { "c" => "< 2" },  "lib/d.rb" # this
+
+    install_specs c1, c2, b1, b2, d1, d2, a1
 
-      assert_equal %w(a-1), loaded_spec_names
-      assert_equal ["b (> 0)", "d (> 0)"], unresolved_names
+    a1.activate
 
-      Gem.finish_resolve
+    assert_equal %w[a-1], loaded_spec_names
+    assert_equal ["b (> 0)", "d (> 0)"], unresolved_names
 
-      assert_equal %w(a-1 b-1 c-1 d-2), loaded_spec_names
-      assert_equal [], unresolved_names
-    end
+    Gem.finish_resolve
+
+    assert_equal %w[a-1 b-1 c-1 d-2], loaded_spec_names
+    assert_equal [], unresolved_names
   end
 
   def test_self_finish_resolve_respects_loaded_specs
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      b1 = util_spec "b", "1", "c" => ">= 1"
-      b2 = util_spec "b", "2", "c" => ">= 2"
-      c1 = util_spec "c", "1"
-      c2 = util_spec "c", "2"
+    a1 = util_spec "a", "1", "b" => "> 0"
+    b1 = util_spec "b", "1", "c" => ">= 1"
+    b2 = util_spec "b", "2", "c" => ">= 2"
+    c1 = util_spec "c", "1"
+    c2 = util_spec "c", "2"
 
-      install_specs c1, c2, b1, b2, a1
+    install_specs c1, c2, b1, b2, a1
 
-      a1.activate
-      c1.activate
+    a1.activate
+    c1.activate
 
-      assert_equal %w(a-1 c-1), loaded_spec_names
-      assert_equal ["b (> 0)"], unresolved_names
+    assert_equal %w[a-1 c-1], loaded_spec_names
+    assert_equal ["b (> 0)"], unresolved_names
 
-      Gem.finish_resolve
+    Gem.finish_resolve
 
-      assert_equal %w(a-1 b-1 c-1), loaded_spec_names
-      assert_equal [], unresolved_names
-    end
+    assert_equal %w[a-1 b-1 c-1], loaded_spec_names
+    assert_equal [], unresolved_names
   end
 
   def test_self_install
     spec_fetcher do |f|
-      f.gem  'a', 1
-      f.spec 'a', 2
+      f.gem  "a", 1
+      f.spec "a", 2
     end
 
     gemhome2 = "#{@gemhome}2"
 
-    installed = Gem.install 'a', '= 1', :install_dir => gemhome2
+    installed = Gem.install "a", "= 1", :install_dir => gemhome2
 
-    assert_equal %w[a-1], installed.map { |spec| spec.full_name }
+    assert_equal %w[a-1], installed.map {|spec| spec.full_name }
 
-    assert_path_exists File.join(gemhome2, 'gems', 'a-1')
+    assert_path_exist File.join(gemhome2, "gems", "a-1")
   end
 
   def test_self_install_in_rescue
     spec_fetcher do |f|
-      f.gem  'a', 1
-      f.spec 'a', 2
+      f.gem  "a", 1
+      f.spec "a", 2
     end
 
     gemhome2 = "#{@gemhome}2"
 
     installed =
       begin
-        raise 'Error'
+        raise "Error"
       rescue StandardError
-        Gem.install 'a', '= 1', :install_dir => gemhome2
+        Gem.install "a", "= 1", :install_dir => gemhome2
       end
-    assert_equal %w[a-1], installed.map { |spec| spec.full_name }
+    assert_equal %w[a-1], installed.map {|spec| spec.full_name }
   end
 
   def test_self_install_permissions
@@ -161,7 +143,7 @@ class TestGem < Gem::TestCase
 
   def test_self_install_permissions_with_format_executable_and_non_standard_ruby_install_name
     Gem::Installer.exec_format = nil
-    ruby_install_name 'ruby27' do
+    ruby_install_name "ruby27" do
       assert_self_install_permissions(format_executable: true)
     end
   ensure
@@ -175,38 +157,38 @@ class TestGem < Gem::TestCase
       :prog_mode => win_platform? ? 0410 : 0510,
       :data_mode => 0640,
       :wrappers => true,
-      :format_executable => format_executable
+      :format_executable => format_executable,
     }
     Dir.chdir @tempdir do
-      Dir.mkdir 'bin'
-      Dir.mkdir 'data'
+      Dir.mkdir "bin"
+      Dir.mkdir "data"
 
-      File.write 'bin/foo', "#!/usr/bin/env ruby\n"
-      File.chmod 0755, 'bin/foo'
+      File.write "bin/foo", "#!/usr/bin/env ruby\n"
+      File.chmod 0755, "bin/foo"
 
-      File.write 'data/foo.txt', "blah\n"
+      File.write "data/foo.txt", "blah\n"
 
       spec_fetcher do |f|
-        f.gem 'foo', 1 do |s|
-          s.executables = ['foo']
+        f.gem "foo", 1 do |s|
+          s.executables = ["foo"]
           s.files = %w[bin/foo data/foo.txt]
         end
       end
-      Gem.install 'foo', Gem::Requirement.default, options
+      Gem.install "foo", Gem::Requirement.default, options
     end
 
     prog_mode = (options[:prog_mode] & mask).to_s(8)
     dir_mode = (options[:dir_mode] & mask).to_s(8)
     data_mode = (options[:data_mode] & mask).to_s(8)
-    prog_name = 'foo'
-    prog_name = RbConfig::CONFIG['ruby_install_name'].sub('ruby', 'foo') if options[:format_executable]
+    prog_name = "foo"
+    prog_name = RbConfig::CONFIG["ruby_install_name"].sub("ruby", "foo") if options[:format_executable]
     expected = {
       "bin/#{prog_name}" => prog_mode,
-      'gems/foo-1' => dir_mode,
-      'gems/foo-1/bin' => dir_mode,
-      'gems/foo-1/data' => dir_mode,
-      'gems/foo-1/bin/foo' => prog_mode,
-      'gems/foo-1/data/foo.txt' => data_mode,
+      "gems/foo-1" => dir_mode,
+      "gems/foo-1/bin" => dir_mode,
+      "gems/foo-1/data" => dir_mode,
+      "gems/foo-1/bin/foo" => prog_mode,
+      "gems/foo-1/data/foo.txt" => data_mode,
     }
     # add Windows script
     expected["bin/#{prog_name}.bat"] = mask.to_s(8) if win_platform?
@@ -218,83 +200,79 @@ class TestGem < Gem::TestCase
     end
     assert_equal(expected, result)
   ensure
-    File.chmod(0755, *Dir.glob(@gemhome + '/gems/**/').map {|path| path.tap(&Gem::UNTAINT)})
+    File.chmod(0755, *Dir.glob(@gemhome + "/gems/**/").map {|path| path.tap(&Gem::UNTAINT) })
   end
 
   def test_require_missing
-    save_loaded_features do
-      assert_raises ::LoadError do
-        require "test_require_missing"
-      end
+    assert_raise ::LoadError do
+      require "test_require_missing"
     end
   end
 
   def test_require_does_not_glob
-    save_loaded_features do
-      a1 = util_spec "a", "1", nil, "lib/a1.rb"
+    a1 = util_spec "a", "1", nil, "lib/a1.rb"
 
-      install_specs a1
-
-      assert_raises ::LoadError do
-        require "a*"
-      end
+    install_specs a1
 
-      assert_equal [], loaded_spec_names
+    assert_raise ::LoadError do
+      require "a*"
     end
+
+    assert_equal [], loaded_spec_names
   end
 
   def test_self_bin_path_active
-    a1 = util_spec 'a', '1' do |s|
-      s.executables = ['exec']
+    a1 = util_spec "a", "1" do |s|
+      s.executables = ["exec"]
     end
 
-    util_spec 'a', '2' do |s|
-      s.executables = ['exec']
+    util_spec "a", "2" do |s|
+      s.executables = ["exec"]
     end
 
     a1.activate
 
-    assert_match 'a-1/bin/exec', Gem.bin_path('a', 'exec', '>= 0')
+    assert_match "a-1/bin/exec", Gem.bin_path("a", "exec", ">= 0")
   end
 
   def test_self_bin_path_picking_newest
-    a1 = util_spec 'a', '1' do |s|
-      s.executables = ['exec']
+    a1 = util_spec "a", "1" do |s|
+      s.executables = ["exec"]
     end
 
-    a2 = util_spec 'a', '2' do |s|
-      s.executables = ['exec']
+    a2 = util_spec "a", "2" do |s|
+      s.executables = ["exec"]
     end
 
     install_specs a1, a2
 
-    assert_match 'a-2/bin/exec', Gem.bin_path('a', 'exec', '>= 0')
+    assert_match "a-2/bin/exec", Gem.bin_path("a", "exec", ">= 0")
   end
 
   def test_self_activate_bin_path_no_exec_name
-    e = assert_raises ArgumentError do
-      Gem.activate_bin_path 'a'
+    e = assert_raise ArgumentError do
+      Gem.activate_bin_path "a"
     end
 
-    assert_equal 'you must supply exec_name', e.message
+    assert_equal "you must supply exec_name", e.message
   end
 
   def test_activate_bin_path_resolves_eagerly
-    a1 = util_spec 'a', '1' do |s|
-      s.executables = ['exec']
-      s.add_dependency 'b'
+    a1 = util_spec "a", "1" do |s|
+      s.executables = ["exec"]
+      s.add_dependency "b"
     end
 
-    b1 = util_spec 'b', '1' do |s|
-      s.add_dependency 'c', '2'
+    b1 = util_spec "b", "1" do |s|
+      s.add_dependency "c", "2"
     end
 
-    b2 = util_spec 'b', '2' do |s|
-      s.add_dependency 'c', '1'
+    b2 = util_spec "b", "2" do |s|
+      s.add_dependency "c", "1"
     end
 
-    c1 = util_spec 'c', '1'
-    c2 = util_spec 'c', '2'
+    c1 = util_spec "c", "1"
+    c2 = util_spec "c", "2"
 
     install_specs c1, c2, b1, b2, a1
 
@@ -302,33 +280,90 @@ class TestGem < Gem::TestCase
 
     # If we didn't eagerly resolve, this would activate c-2 and then the
     # finish_resolve would cause a conflict
-    gem 'c'
+    gem "c"
     Gem.finish_resolve
 
-    assert_equal %w(a-1 b-2 c-1), loaded_spec_names
+    assert_equal %w[a-1 b-2 c-1], loaded_spec_names
+  end
+
+  def test_activate_bin_path_does_not_error_if_a_gem_thats_not_finally_activated_has_orphaned_dependencies
+    a1 = util_spec "a", "1" do |s|
+      s.executables = ["exec"]
+      s.add_dependency "b"
+    end
+
+    b1 = util_spec "b", "1" do |s|
+      s.add_dependency "c", "1"
+    end
+
+    b2 = util_spec "b", "2" do |s|
+      s.add_dependency "c", "2"
+    end
+
+    c2 = util_spec "c", "2"
+
+    install_specs c2, b1, b2, a1
+
+    # c1 is missing, but not needed for activation, so we should not get any errors here
+
+    Gem.activate_bin_path("a", "exec", ">= 0")
+
+    assert_equal %w[a-1 b-2 c-2], loaded_spec_names
+  end
+
+  def test_activate_bin_path_raises_a_meaningful_error_if_a_gem_thats_finally_activated_has_orphaned_dependencies
+    a1 = util_spec "a", "1" do |s|
+      s.executables = ["exec"]
+      s.add_dependency "b"
+    end
+
+    b1 = util_spec "b", "1" do |s|
+      s.add_dependency "c", "1"
+    end
+
+    b2 = util_spec "b", "2" do |s|
+      s.add_dependency "c", "2"
+    end
+
+    c1 = util_spec "c", "1"
+
+    install_specs c1, b1, b2, a1
+
+    # c2 is missing, and b2 which has it as a dependency will be activated, so we should get an error about the orphaned dependency
+
+    e = assert_raise Gem::UnsatisfiableDependencyError do
+      load Gem.activate_bin_path("a", "exec", ">= 0")
+    end
+
+    assert_equal "Unable to resolve dependency: 'b (>= 0)' requires 'c (= 2)'", e.message
   end
 
   def test_activate_bin_path_in_debug_mode
-    a1 = util_spec 'a', '1' do |s|
-      s.executables = ['exec']
+    a1 = util_spec "a", "1" do |s|
+      s.executables = ["exec"]
     end
 
     install_specs a1
 
+    require "open3"
     output, status = Open3.capture2e(
       { "GEM_HOME" => Gem.paths.home, "DEBUG_RESOLVER" => "1" },
-      Gem.ruby, "-I", File.expand_path("../../lib", __dir__), "-e", "\"Gem.activate_bin_path('a', 'exec', '>= 0')\""
+      *ruby_with_rubygems_in_load_path, "-e", "\"Gem.activate_bin_path('a', 'exec', '>= 0')\""
     )
 
     assert status.success?, output
   end
 
-  def test_activate_bin_path_gives_proper_error_for_bundler
-    bundler = util_spec 'bundler', '2' do |s|
-      s.executables = ['bundle']
+  def test_activate_bin_path_selects_exact_bundler_version_if_present
+    bundler_latest = util_spec "bundler", "2.0.1" do |s|
+      s.executables = ["bundle"]
+    end
+
+    bundler_previous = util_spec "bundler", "2.0.0" do |s|
+      s.executables = ["bundle"]
     end
 
-    install_specs bundler
+    install_specs bundler_latest, bundler_previous
 
     File.open("Gemfile.lock", "w") do |f|
       f.write <<-L.gsub(/ {8}/, "")
@@ -342,29 +377,24 @@ class TestGem < Gem::TestCase
         DEPENDENCIES
 
         BUNDLED WITH
-          9999
+          2.0.0
       L
     end
 
-    File.open("Gemfile", "w") { |f| f.puts('source "https://rubygems.org"') }
+    File.open("Gemfile", "w") {|f| f.puts('source "https://rubygems.org"') }
 
-    e = assert_raises Gem::GemNotFoundException do
-      load Gem.activate_bin_path("bundler", "bundle", ">= 0.a")
-    end
+    load Gem.activate_bin_path("bundler", "bundle", ">= 0.a")
 
-    assert_includes e.message, "Could not find 'bundler' (9999) required by your #{File.expand_path("Gemfile.lock")}."
-    assert_includes e.message, "To update to the latest version installed on your system, run `bundle update --bundler`."
-    assert_includes e.message, "To install the missing version, run `gem install bundler:9999`"
-    refute_includes e.message, "can't find gem bundler (>= 0.a) with executable bundle"
+    assert_equal %w[bundler-2.0.0], loaded_spec_names
   end
 
-  def test_activate_bin_path_selects_exact_bundler_version_if_present
-    bundler_latest = util_spec 'bundler', '2.0.1' do |s|
-      s.executables = ['bundle']
+  def test_activate_bin_path_respects_underscore_selection_if_given
+    bundler_latest = util_spec "bundler", "2.0.1" do |s|
+      s.executables = ["bundle"]
     end
 
-    bundler_previous = util_spec 'bundler', '2.0.0' do |s|
-      s.executables = ['bundle']
+    bundler_previous = util_spec "bundler", "1.17.3" do |s|
+      s.executables = ["bundle"]
     end
 
     install_specs bundler_latest, bundler_previous
@@ -381,28 +411,18 @@ class TestGem < Gem::TestCase
         DEPENDENCIES
 
         BUNDLED WITH
-          2.0.0
+          2.0.1
       L
     end
 
-    File.open("Gemfile", "w") { |f| f.puts('source "https://rubygems.org"') }
+    File.open("Gemfile", "w") {|f| f.puts('source "https://rubygems.org"') }
 
-    load Gem.activate_bin_path("bundler", "bundle", ">= 0.a")
+    load Gem.activate_bin_path("bundler", "bundle", "= 1.17.3")
 
-    assert_equal %w(bundler-2.0.0), loaded_spec_names
+    assert_equal %w[bundler-1.17.3], loaded_spec_names
   end
 
-  def test_activate_bin_path_respects_underscore_selection_if_given
-    bundler_latest = util_spec 'bundler', '2.0.1' do |s|
-      s.executables = ['bundle']
-    end
-
-    bundler_previous = util_spec 'bundler', '1.17.3' do |s|
-      s.executables = ['bundle']
-    end
-
-    install_specs bundler_latest, bundler_previous
-
+  def test_activate_bin_path_gives_proper_error_for_bundler_when_underscore_selection_given
     File.open("Gemfile.lock", "w") do |f|
       f.write <<-L.gsub(/ {8}/, "")
         GEM
@@ -415,71 +435,72 @@ class TestGem < Gem::TestCase
         DEPENDENCIES
 
         BUNDLED WITH
-          2.0.1
+          2.1.4
       L
     end
 
-    File.open("Gemfile", "w") { |f| f.puts('source "https://rubygems.org"') }
+    File.open("Gemfile", "w") {|f| f.puts('source "https://rubygems.org"') }
 
-    load Gem.activate_bin_path("bundler", "bundle", "= 1.17.3")
+    e = assert_raise Gem::GemNotFoundException do
+      load Gem.activate_bin_path("bundler", "bundle", "= 2.2.8")
+    end
 
-    assert_equal %w(bundler-1.17.3), loaded_spec_names
+    assert_equal "can't find gem bundler (= 2.2.8) with executable bundle", e.message
   end
 
   def test_self_bin_path_no_exec_name
-    e = assert_raises ArgumentError do
-      Gem.bin_path 'a'
+    e = assert_raise ArgumentError do
+      Gem.bin_path "a"
     end
 
-    assert_equal 'you must supply exec_name', e.message
+    assert_equal "you must supply exec_name", e.message
   end
 
   def test_self_bin_path_bin_name
     install_specs util_exec_gem
-    assert_equal @abin_path, Gem.bin_path('a', 'abin')
+    assert_equal @abin_path, Gem.bin_path("a", "abin")
   end
 
   def test_self_bin_path_bin_name_version
     install_specs util_exec_gem
-    assert_equal @abin_path, Gem.bin_path('a', 'abin', '4')
+    assert_equal @abin_path, Gem.bin_path("a", "abin", "4")
   end
 
   def test_self_bin_path_nonexistent_binfile
-    util_spec 'a', '2' do |s|
-      s.executables = ['exec']
+    util_spec "a", "2" do |s|
+      s.executables = ["exec"]
     end
-    assert_raises(Gem::GemNotFoundException) do
-      Gem.bin_path('a', 'other', '2')
+    assert_raise(Gem::GemNotFoundException) do
+      Gem.bin_path("a", "other", "2")
     end
   end
 
   def test_self_bin_path_no_bin_file
-    util_spec 'a', '1'
-    assert_raises(ArgumentError) do
-      Gem.bin_path('a', nil, '1')
+    util_spec "a", "1"
+    assert_raise(ArgumentError) do
+      Gem.bin_path("a", nil, "1")
     end
   end
 
   def test_self_bin_path_not_found
-    assert_raises(Gem::GemNotFoundException) do
-      Gem.bin_path('non-existent', 'blah')
+    assert_raise(Gem::GemNotFoundException) do
+      Gem.bin_path("non-existent", "blah")
     end
   end
 
   def test_self_bin_path_bin_file_gone_in_latest
     install_specs util_exec_gem
-    spec = util_spec 'a', '10' do |s|
+    spec = util_spec "a", "10" do |s|
       s.executables = []
     end
     install_specs spec
-    # Should not find a-10's non-abin (bug)
-    assert_equal @abin_path, Gem.bin_path('a', 'abin')
+    assert_equal @abin_path, Gem.bin_path("a", "abin")
   end
 
   def test_self_bindir
-    assert_equal File.join(@gemhome, 'bin'), Gem.bindir
-    assert_equal File.join(@gemhome, 'bin'), Gem.bindir(Gem.dir)
-    assert_equal File.join(@gemhome, 'bin'), Gem.bindir(Pathname.new(Gem.dir))
+    assert_equal File.join(@gemhome, "bin"), Gem.bindir
+    assert_equal File.join(@gemhome, "bin"), Gem.bindir(Gem.dir)
+    assert_equal File.join(@gemhome, "bin"), Gem.bindir(Pathname.new(Gem.dir))
   end
 
   def test_self_bindir_default_dir
@@ -508,51 +529,51 @@ class TestGem < Gem::TestCase
     foo = nil
 
     Dir.chdir @tempdir do
-      FileUtils.mkdir_p 'data'
-      File.open File.join('data', 'foo.txt'), 'w' do |fp|
-        fp.puts 'blah'
+      FileUtils.mkdir_p "data"
+      File.open File.join("data", "foo.txt"), "w" do |fp|
+        fp.puts "blah"
       end
 
-      foo = util_spec 'foo' do |s|
+      foo = util_spec "foo" do |s|
         s.files = %w[data/foo.txt]
       end
 
       install_gem foo
     end
 
-    gem 'foo'
+    gem "foo"
 
-    expected = File.join @gemhome, 'gems', foo.full_name, 'data', 'foo'
+    expected = File.join @gemhome, "gems", foo.full_name, "data", "foo"
 
     assert_equal expected, Gem::Specification.find_by_name("foo").datadir
   end
 
   def test_self_datadir_nonexistent_package
-    assert_raises(Gem::MissingSpecError) do
+    assert_raise(Gem::MissingSpecError) do
       Gem::Specification.find_by_name("xyzzy").datadir
     end
   end
 
   def test_self_default_exec_format
-    ruby_install_name 'ruby' do
-      assert_equal '%s', Gem.default_exec_format
+    ruby_install_name "ruby" do
+      assert_equal "%s", Gem.default_exec_format
     end
   end
 
   def test_self_default_exec_format_18
-    ruby_install_name 'ruby18' do
-      assert_equal '%s18', Gem.default_exec_format
+    ruby_install_name "ruby18" do
+      assert_equal "%s18", Gem.default_exec_format
     end
   end
 
   def test_self_default_exec_format_jruby
-    ruby_install_name 'jruby' do
-      assert_equal 'j%s', Gem.default_exec_format
+    ruby_install_name "jruby" do
+      assert_equal "j%s", Gem.default_exec_format
     end
   end
 
   def test_default_path
-    vendordir(File.join(@tempdir, 'vendor')) do
+    vendordir(File.join(@tempdir, "vendor")) do
       FileUtils.rm_rf Gem.user_home
 
       expected = [Gem.default_dir]
@@ -572,7 +593,7 @@ class TestGem < Gem::TestCase
   end
 
   def test_default_path_user_home
-    vendordir(File.join(@tempdir, 'vendor')) do
+    vendordir(File.join(@tempdir, "vendor")) do
       expected = [Gem.user_dir, Gem.default_dir]
 
       assert_equal expected, Gem.default_path
@@ -580,7 +601,7 @@ class TestGem < Gem::TestCase
   end
 
   def test_default_path_vendor_dir
-    vendordir(File.join(@tempdir, 'vendor')) do
+    vendordir(File.join(@tempdir, "vendor")) do
       FileUtils.mkdir_p Gem.vendor_dir
 
       FileUtils.rm_rf Gem.user_home
@@ -596,22 +617,22 @@ class TestGem < Gem::TestCase
   end
 
   def test_self_use_gemdeps
-    rubygems_gemdeps, ENV['RUBYGEMS_GEMDEPS'] = ENV['RUBYGEMS_GEMDEPS'], '-'
+    with_rubygems_gemdeps("-") do
+      FileUtils.mkdir_p "detect/a/b"
+      FileUtils.mkdir_p "detect/a/Isolate"
 
-    FileUtils.mkdir_p 'detect/a/b'
-    FileUtils.mkdir_p 'detect/a/Isolate'
+      FileUtils.touch "detect/Isolate"
 
-    FileUtils.touch 'detect/Isolate'
+      begin
+        Dir.chdir "detect/a/b"
 
-    begin
-      Dir.chdir 'detect/a/b'
+        Gem.use_gemdeps
 
-      assert_equal add_bundler_full_name([]), Gem.use_gemdeps.map(&:full_name)
-    ensure
-      Dir.chdir @tempdir
+        assert_equal add_bundler_full_name([]), loaded_spec_names
+      ensure
+        Dir.chdir @tempdir
+      end
     end
-  ensure
-    ENV['RUBYGEMS_GEMDEPS'] = rubygems_gemdeps
   end
 
   def test_self_dir
@@ -624,12 +645,12 @@ class TestGem < Gem::TestCase
 
     Gem.ensure_gem_subdirectories @gemhome
 
-    assert_path_exists File.join @gemhome, 'build_info'
-    assert_path_exists File.join @gemhome, 'cache'
-    assert_path_exists File.join @gemhome, 'doc'
-    assert_path_exists File.join @gemhome, 'extensions'
-    assert_path_exists File.join @gemhome, 'gems'
-    assert_path_exists File.join @gemhome, 'specifications'
+    assert_path_exist File.join @gemhome, "build_info"
+    assert_path_exist File.join @gemhome, "cache"
+    assert_path_exist File.join @gemhome, "doc"
+    assert_path_exist File.join @gemhome, "extensions"
+    assert_path_exist File.join @gemhome, "gems"
+    assert_path_exist File.join @gemhome, "specifications"
   end
 
   def test_self_ensure_gem_directories_permissions
@@ -659,9 +680,9 @@ class TestGem < Gem::TestCase
   end unless win_platform?
 
   def test_self_ensure_gem_directories_missing_parents
-    gemdir = File.join @tempdir, 'a/b/c/gemdir'
-    FileUtils.rm_rf File.join(@tempdir, 'a') rescue nil
-    refute File.exist?(File.join(@tempdir, 'a')),
+    gemdir = File.join @tempdir, "a/b/c/gemdir"
+    FileUtils.rm_rf File.join(@tempdir, "a") rescue nil
+    refute File.exist?(File.join(@tempdir, "a")),
            "manually remove #{File.join @tempdir, 'a'}, tests are broken"
     Gem.use_paths gemdir
 
@@ -670,7 +691,7 @@ class TestGem < Gem::TestCase
     assert_directory_exists util_cache_dir
   end
 
-  unless win_platform? || Process.uid.zero?  # only for FS that support write protection
+  unless win_platform? || Process.uid.zero? # only for FS that support write protection
     def test_self_ensure_gem_directories_write_protected
       gemdir = File.join @tempdir, "egd"
       FileUtils.rm_r gemdir rescue nil
@@ -702,16 +723,21 @@ class TestGem < Gem::TestCase
     ensure
       FileUtils.chmod 0600, parent
     end
+
+    def test_self_ensure_gem_directories_non_existent_paths
+      Gem.ensure_gem_subdirectories "/proc/0123456789/bogus" # should not raise
+      Gem.ensure_gem_subdirectories "classpath:/bogus/x" # JRuby embed scenario
+    end
   end
 
   def test_self_extension_dir_shared
-    enable_shared 'yes' do
+    enable_shared "yes" do
       assert_equal Gem.ruby_api_version, Gem.extension_api_version
     end
   end
 
   def test_self_extension_dir_static
-    enable_shared 'no' do
+    enable_shared "no" do
       assert_equal "#{Gem.ruby_api_version}-static", Gem.extension_api_version
     end
   end
@@ -720,14 +746,14 @@ class TestGem < Gem::TestCase
     cwd = File.expand_path("test/rubygems", PROJECT_DIR)
     $LOAD_PATH.unshift cwd
 
-    discover_path = File.join 'lib', 'sff', 'discover.rb'
+    discover_path = File.join "lib", "sff", "discover.rb"
 
-    foo1, foo2 = %w(1 2).map do |version|
-      spec = quick_gem 'sff', version do |s|
+    foo1, foo2 = %w[1 2].map do |version|
+      spec = quick_gem "sff", version do |s|
         s.files << discover_path
       end
 
-      write_file(File.join 'gems', spec.full_name, discover_path) do |fp|
+      write_file(File.join "gems", spec.full_name, discover_path) do |fp|
         fp.puts "# #{spec.full_name}"
       end
 
@@ -737,13 +763,13 @@ class TestGem < Gem::TestCase
     Gem.refresh
 
     expected = [
-      File.expand_path('test/rubygems/sff/discover.rb', PROJECT_DIR),
+      File.expand_path("test/rubygems/sff/discover.rb", PROJECT_DIR),
       File.join(foo2.full_gem_path, discover_path),
       File.join(foo1.full_gem_path, discover_path),
     ]
 
-    assert_equal expected, Gem.find_files('sff/discover')
-    assert_equal expected, Gem.find_files('sff/**.rb'), '[ruby-core:31730]'
+    assert_equal expected, Gem.find_files("sff/discover")
+    assert_equal expected, Gem.find_files("sff/**.rb"), "[ruby-core:31730]"
   ensure
     assert_equal cwd, $LOAD_PATH.shift
   end
@@ -752,14 +778,14 @@ class TestGem < Gem::TestCase
     cwd = File.expand_path("test/rubygems", PROJECT_DIR)
     actual_load_path = $LOAD_PATH.unshift(cwd).dup
 
-    discover_path = File.join 'lib', 'sff', 'discover.rb'
+    discover_path = File.join "lib", "sff", "discover.rb"
 
-    foo1, _ = %w(1 2).map do |version|
-      spec = quick_gem 'sff', version do |s|
+    foo1, _ = %w[1 2].map do |version|
+      spec = quick_gem "sff", version do |s|
         s.files << discover_path
       end
 
-      write_file(File.join 'gems', spec.full_name, discover_path) do |fp|
+      write_file(File.join "gems", spec.full_name, discover_path) do |fp|
         fp.puts "# #{spec.full_name}"
       end
 
@@ -767,19 +793,19 @@ class TestGem < Gem::TestCase
     end
     Gem.refresh
 
-    write_file(File.join Dir.pwd, 'Gemfile') do |fp|
+    write_file(File.join Dir.pwd, "Gemfile") do |fp|
       fp.puts "source 'https://rubygems.org'"
       fp.puts "gem '#{foo1.name}', '#{foo1.version}'"
     end
-    Gem.use_gemdeps(File.join Dir.pwd, 'Gemfile')
+    Gem.use_gemdeps(File.join Dir.pwd, "Gemfile")
 
     expected = [
-      File.expand_path('test/rubygems/sff/discover.rb', PROJECT_DIR),
-      File.join(foo1.full_gem_path, discover_path)
+      File.expand_path("test/rubygems/sff/discover.rb", PROJECT_DIR),
+      File.join(foo1.full_gem_path, discover_path),
     ].sort
 
-    assert_equal expected, Gem.find_files('sff/discover').sort
-    assert_equal expected, Gem.find_files('sff/**.rb').sort, '[ruby-core:31730]'
+    assert_equal expected, Gem.find_files("sff/discover").sort
+    assert_equal expected, Gem.find_files("sff/**.rb").sort, "[ruby-core:31730]"
   ensure
     assert_equal cwd, actual_load_path.shift unless Gem.java_platform?
   end
@@ -788,14 +814,14 @@ class TestGem < Gem::TestCase
     cwd = File.expand_path("test/rubygems", PROJECT_DIR)
     $LOAD_PATH.unshift cwd
 
-    discover_path = File.join 'lib', 'sff', 'discover.rb'
+    discover_path = File.join "lib", "sff", "discover.rb"
 
-    _, foo2 = %w(1 2).map do |version|
-      spec = quick_gem 'sff', version do |s|
+    _, foo2 = %w[1 2].map do |version|
+      spec = quick_gem "sff", version do |s|
         s.files << discover_path
       end
 
-      write_file(File.join 'gems', spec.full_name, discover_path) do |fp|
+      write_file(File.join "gems", spec.full_name, discover_path) do |fp|
         fp.puts "# #{spec.full_name}"
       end
 
@@ -805,64 +831,103 @@ class TestGem < Gem::TestCase
     Gem.refresh
 
     expected = [
-      File.expand_path('test/rubygems/sff/discover.rb', PROJECT_DIR),
+      File.expand_path("test/rubygems/sff/discover.rb", PROJECT_DIR),
       File.join(foo2.full_gem_path, discover_path),
     ]
 
-    assert_equal expected, Gem.find_latest_files('sff/discover')
-    assert_equal expected, Gem.find_latest_files('sff/**.rb'), '[ruby-core:31730]'
+    assert_equal expected, Gem.find_latest_files("sff/discover")
+    assert_equal expected, Gem.find_latest_files("sff/**.rb"), "[ruby-core:31730]"
   ensure
     assert_equal cwd, $LOAD_PATH.shift
   end
 
   def test_self_latest_spec_for
     gems = spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', '3.a'
-      fetcher.spec 'a', 2
+      fetcher.spec "a", 1
+      fetcher.spec "a", "3.a"
+      fetcher.spec "a", 2
     end
 
-    spec = Gem.latest_spec_for 'a'
+    spec = Gem.latest_spec_for "a"
+
+    assert_equal gems["a-2"], spec
+  end
+
+  def test_self_latest_spec_for_multiple_sources
+    uri = "https://example.sample.com/"
+    source = Gem::Source.new(uri)
+    source_list = Gem::SourceList.new
+    source_list << Gem::Source.new(@uri)
+    source_list << source
+    Gem.sources.replace source_list
+
+    spec_fetcher(uri) do |fetcher|
+      fetcher.spec "a", 1.1
+    end
 
-    assert_equal gems['a-2'], spec
+    gems = spec_fetcher do |fetcher|
+      fetcher.spec "a", 1
+      fetcher.spec "a", "3.a"
+      fetcher.spec "a", 2
+    end
+    spec = Gem.latest_spec_for "a"
+    assert_equal gems["a-2"], spec
   end
 
   def test_self_latest_rubygems_version
     spec_fetcher do |fetcher|
-      fetcher.spec 'rubygems-update', '1.8.23'
-      fetcher.spec 'rubygems-update', '1.8.24'
-      fetcher.spec 'rubygems-update', '2.0.0.preview3'
+      fetcher.spec "rubygems-update", "1.8.23"
+      fetcher.spec "rubygems-update", "1.8.24"
+      fetcher.spec "rubygems-update", "2.0.0.preview3"
     end
 
     version = Gem.latest_rubygems_version
 
-    assert_equal Gem::Version.new('1.8.24'), version
+    assert_equal Gem::Version.new("1.8.24"), version
   end
 
   def test_self_latest_version_for
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', 2
-      fetcher.spec 'a', '3.a'
+      fetcher.spec "a", 1
+      fetcher.spec "a", 2
+      fetcher.spec "a", "3.a"
     end
 
-    version = Gem.latest_version_for 'a'
+    version = Gem.latest_version_for "a"
+
+    assert_equal Gem::Version.new(2), version
+  end
+
+  def test_self_latest_version_for_multiple_sources
+    uri = "https://example.sample.com/"
+    source = Gem::Source.new(uri)
+    source_list = Gem::SourceList.new
+    source_list << Gem::Source.new(@uri)
+    source_list << source
+    Gem.sources.replace source_list
+
+    spec_fetcher(uri) do |fetcher|
+      fetcher.spec "a", 1.1
+    end
+
+    spec_fetcher do |fetcher|
+      fetcher.spec "a", 1
+      fetcher.spec "a", 2
+      fetcher.spec "a", "3.a"
+    end
+
+    version = Gem.latest_version_for "a"
 
     assert_equal Gem::Version.new(2), version
   end
 
   def test_self_loaded_specs
-    foo = util_spec 'foo'
+    foo = util_spec "foo"
     install_gem foo
 
     foo.activate
 
-    assert_equal true, Gem.loaded_specs.keys.include?('foo')
-  end
-
-  def util_path
-    ENV.delete "GEM_HOME"
-    ENV.delete "GEM_PATH"
+    assert_equal true, Gem.loaded_specs.keys.include?("foo")
   end
 
   def test_self_path
@@ -870,53 +935,19 @@ class TestGem < Gem::TestCase
   end
 
   def test_self_path_default
-    util_path
-
-    if defined?(APPLE_GEM_HOME)
-      orig_APPLE_GEM_HOME = APPLE_GEM_HOME
-      Object.send :remove_const, :APPLE_GEM_HOME
-    end
+    ENV.delete "GEM_HOME"
+    ENV.delete "GEM_PATH"
 
     Gem.instance_variable_set :@paths, nil
 
     assert_equal [Gem.default_path, Gem.dir].flatten.uniq, Gem.path
-  ensure
-    Object.const_set :APPLE_GEM_HOME, orig_APPLE_GEM_HOME if orig_APPLE_GEM_HOME
-  end
-
-  unless win_platform?
-    def test_self_path_APPLE_GEM_HOME
-      util_path
-
-      Gem.clear_paths
-      apple_gem_home = File.join @tempdir, 'apple_gem_home'
-
-      old, $-w = $-w, nil
-      Object.const_set :APPLE_GEM_HOME, apple_gem_home
-      $-w = old
-
-      assert_includes Gem.path, apple_gem_home
-    ensure
-      Object.send :remove_const, :APPLE_GEM_HOME
-    end
-
-    def test_self_path_APPLE_GEM_HOME_GEM_PATH
-      Gem.clear_paths
-      ENV['GEM_PATH'] = @gemhome
-      apple_gem_home = File.join @tempdir, 'apple_gem_home'
-      Gem.const_set :APPLE_GEM_HOME, apple_gem_home
-
-      refute Gem.path.include?(apple_gem_home)
-    ensure
-      Gem.send :remove_const, :APPLE_GEM_HOME
-    end
   end
 
   def test_self_path_ENV_PATH
     path_count = Gem.path.size
     Gem.clear_paths
 
-    ENV['GEM_PATH'] = @additional.join(File::PATH_SEPARATOR)
+    ENV["GEM_PATH"] = @additional.join(File::PATH_SEPARATOR)
 
     assert_equal @additional, Gem.path[0,2]
 
@@ -928,10 +959,10 @@ class TestGem < Gem::TestCase
   def test_self_path_duplicate
     Gem.clear_paths
     util_ensure_gem_dirs
-    dirs = @additional + [@gemhome] + [File.join(@tempdir, 'a')]
+    dirs = @additional + [@gemhome] + [File.join(@tempdir, "a")]
 
-    ENV['GEM_HOME'] = @gemhome
-    ENV['GEM_PATH'] = dirs.join File::PATH_SEPARATOR
+    ENV["GEM_HOME"] = @gemhome
+    ENV["GEM_PATH"] = dirs.join File::PATH_SEPARATOR
 
     assert_equal @gemhome, Gem.dir
 
@@ -943,8 +974,8 @@ class TestGem < Gem::TestCase
     Gem.clear_paths
 
     util_ensure_gem_dirs
-    ENV['GEM_HOME'] = @gemhome
-    ENV['GEM_PATH'] = @additional.join(File::PATH_SEPARATOR)
+    ENV["GEM_HOME"] = @gemhome
+    ENV["GEM_PATH"] = @additional.join(File::PATH_SEPARATOR)
 
     assert_equal @gemhome, Gem.dir
 
@@ -961,38 +992,38 @@ class TestGem < Gem::TestCase
   end
 
   def test_self_prefix_libdir
-    orig_libdir = RbConfig::CONFIG['libdir']
-    RbConfig::CONFIG['libdir'] = PROJECT_DIR
+    orig_libdir = RbConfig::CONFIG["libdir"]
+    RbConfig::CONFIG["libdir"] = PROJECT_DIR
 
     assert_nil Gem.prefix
   ensure
-    RbConfig::CONFIG['libdir'] = orig_libdir
+    RbConfig::CONFIG["libdir"] = orig_libdir
   end
 
   def test_self_prefix_sitelibdir
-    orig_sitelibdir = RbConfig::CONFIG['sitelibdir']
-    RbConfig::CONFIG['sitelibdir'] = PROJECT_DIR
+    orig_sitelibdir = RbConfig::CONFIG["sitelibdir"]
+    RbConfig::CONFIG["sitelibdir"] = PROJECT_DIR
 
     assert_nil Gem.prefix
   ensure
-    RbConfig::CONFIG['sitelibdir'] = orig_sitelibdir
+    RbConfig::CONFIG["sitelibdir"] = orig_sitelibdir
   end
 
   def test_self_read_binary
-    File.open 'test', 'w' do |io|
+    File.open "test", "w" do |io|
       io.write "\xCF\x80"
     end
 
-    assert_equal ["\xCF", "\x80"], Gem.read_binary('test').chars.to_a
+    assert_equal ["\xCF", "\x80"], Gem.read_binary("test").chars.to_a
 
-    skip 'chmod not supported' if Gem.win_platform?
+    pend "chmod not supported" if Gem.win_platform?
 
     begin
-      File.chmod 0444, 'test'
+      File.chmod 0444, "test"
 
-      assert_equal ["\xCF", "\x80"], Gem.read_binary('test').chars.to_a
+      assert_equal ["\xCF", "\x80"], Gem.read_binary("test").chars.to_a
     ensure
-      File.chmod 0644, 'test'
+      File.chmod 0644, "test"
     end
   end
 
@@ -1030,111 +1061,95 @@ class TestGem < Gem::TestCase
 
     Gem.refresh
 
-    Gem::Specification.each{|spec| assert spec.activated? if spec == s}
+    Gem::Specification.each {|spec| assert spec.activated? if spec == s }
 
     Gem.loaded_specs.delete(s)
     Gem.refresh
   end
 
   def test_self_ruby_escaping_spaces_in_path
-    with_bindir_and_exeext("C:/Ruby 1.8/bin", ".exe") do
-      ruby_install_name "ruby" do
+    with_clean_path_to_ruby do
+      with_rb_config_ruby("C:/Ruby 1.8/bin/ruby.exe") do
         assert_equal "\"C:/Ruby 1.8/bin/ruby.exe\"", Gem.ruby
       end
     end
   end
 
   def test_self_ruby_path_without_spaces
-    with_bindir_and_exeext("C:/Ruby18/bin", ".exe") do
-      ruby_install_name "ruby" do
+    with_clean_path_to_ruby do
+      with_rb_config_ruby("C:/Ruby18/bin/ruby.exe") do
         assert_equal "C:/Ruby18/bin/ruby.exe", Gem.ruby
       end
     end
   end
 
   def test_self_ruby_api_version
-    orig_ruby_version, RbConfig::CONFIG['ruby_version'] = RbConfig::CONFIG['ruby_version'], '1.2.3'
+    orig_ruby_version, RbConfig::CONFIG["ruby_version"] = RbConfig::CONFIG["ruby_version"], "1.2.3"
 
     Gem.instance_variable_set :@ruby_api_version, nil
 
-    assert_equal '1.2.3', Gem.ruby_api_version
+    assert_equal "1.2.3", Gem.ruby_api_version
   ensure
     Gem.instance_variable_set :@ruby_api_version, nil
 
-    RbConfig::CONFIG['ruby_version'] = orig_ruby_version
+    RbConfig::CONFIG["ruby_version"] = orig_ruby_version
   end
 
   def test_self_env_requirement
-    ENV["GEM_REQUIREMENT_FOO"] = '>= 1.2.3'
-    ENV["GEM_REQUIREMENT_BAR"] = '1.2.3'
-    ENV["GEM_REQUIREMENT_BAZ"] = 'abcd'
-
-    assert_equal Gem::Requirement.create('>= 1.2.3'), Gem.env_requirement('foo')
-    assert_equal Gem::Requirement.create('1.2.3'), Gem.env_requirement('bAr')
-    assert_raises(Gem::Requirement::BadRequirementError) { Gem.env_requirement('baz') }
-    assert_equal Gem::Requirement.default, Gem.env_requirement('qux')
-  end
-
-  def test_self_ruby_version_with_patchlevel_less_ancient_rubies
-    util_set_RUBY_VERSION '1.8.5'
-
-    assert_equal Gem::Version.new('1.8.5'), Gem.ruby_version
-  ensure
-    util_restore_RUBY_VERSION
-  end
-
-  def test_self_ruby_version_with_release
-    util_set_RUBY_VERSION '1.8.6', 287
-
-    assert_equal Gem::Version.new('1.8.6.287'), Gem.ruby_version
-  ensure
-    util_restore_RUBY_VERSION
+    ENV["GEM_REQUIREMENT_FOO"] = ">= 1.2.3"
+    ENV["GEM_REQUIREMENT_BAR"] = "1.2.3"
+    ENV["GEM_REQUIREMENT_BAZ"] = "abcd"
+
+    assert_equal Gem::Requirement.create(">= 1.2.3"), Gem.env_requirement("foo")
+    assert_equal Gem::Requirement.create("1.2.3"), Gem.env_requirement("bAr")
+    assert_raise(Gem::Requirement::BadRequirementError) { Gem.env_requirement("baz") }
+    assert_equal Gem::Requirement.default, Gem.env_requirement("qux")
   end
 
   def test_self_ruby_version_with_non_mri_implementations
-    util_set_RUBY_VERSION '2.5.0', 0, 60928, 'jruby 9.2.0.0 (2.5.0) 2018-05-24 81156a8 OpenJDK 64-Bit Server VM 25.171-b11 on 1.8.0_171-8u171-b11-0ubuntu0.16.04.1-b11 [linux-x86_64]'
+    util_set_RUBY_VERSION "2.5.0", 0, 60928, "jruby 9.2.0.0 (2.5.0) 2018-05-24 81156a8 OpenJDK 64-Bit Server VM 25.171-b11 on 1.8.0_171-8u171-b11-0ubuntu0.16.04.1-b11 [linux-x86_64]"
 
-    assert_equal Gem::Version.new('2.5.0'), Gem.ruby_version
+    assert_equal Gem::Version.new("2.5.0"), Gem.ruby_version
   ensure
     util_restore_RUBY_VERSION
   end
 
   def test_self_ruby_version_with_svn_prerelease
-    util_set_RUBY_VERSION '2.6.0', -1, 63539, 'ruby 2.6.0preview2 (2018-05-31 trunk 63539) [x86_64-linux]'
+    util_set_RUBY_VERSION "2.6.0", -1, 63539, "ruby 2.6.0preview2 (2018-05-31 trunk 63539) [x86_64-linux]"
 
-    assert_equal Gem::Version.new('2.6.0.preview2'), Gem.ruby_version
+    assert_equal Gem::Version.new("2.6.0.preview2"), Gem.ruby_version
   ensure
     util_restore_RUBY_VERSION
   end
 
   def test_self_ruby_version_with_git_prerelease
-    util_set_RUBY_VERSION '2.7.0', -1, 'b563439274a402e33541f5695b1bfd4ac1085638', 'ruby 2.7.0preview3 (2019-11-23 master b563439274) [x86_64-linux]'
+    util_set_RUBY_VERSION "2.7.0", -1, "b563439274a402e33541f5695b1bfd4ac1085638", "ruby 2.7.0preview3 (2019-11-23 master b563439274) [x86_64-linux]"
 
-    assert_equal Gem::Version.new('2.7.0.preview3'), Gem.ruby_version
+    assert_equal Gem::Version.new("2.7.0.preview3"), Gem.ruby_version
   ensure
     util_restore_RUBY_VERSION
   end
 
   def test_self_ruby_version_with_non_mri_implementations_with_mri_prerelase_compatibility
-    util_set_RUBY_VERSION '2.6.0', -1, 63539, 'weirdjruby 9.2.0.0 (2.6.0preview2) 2018-05-24 81156a8 OpenJDK 64-Bit Server VM 25.171-b11 on 1.8.0_171-8u171-b11-0ubuntu0.16.04.1-b11 [linux-x86_64]', 'weirdjruby', '9.2.0.0'
+    util_set_RUBY_VERSION "2.6.0", -1, 63539, "weirdjruby 9.2.0.0 (2.6.0preview2) 2018-05-24 81156a8 OpenJDK 64-Bit Server VM 25.171-b11 on 1.8.0_171-8u171-b11-0ubuntu0.16.04.1-b11 [linux-x86_64]", "weirdjruby", "9.2.0.0"
 
-    assert_equal Gem::Version.new('2.6.0.preview2'), Gem.ruby_version
+    assert_equal Gem::Version.new("2.6.0.preview2"), Gem.ruby_version
   ensure
     util_restore_RUBY_VERSION
   end
 
   def test_self_ruby_version_with_svn_trunk
-    util_set_RUBY_VERSION '1.9.2', -1, 23493, 'ruby 1.9.2dev (2009-05-20 trunk 23493) [x86_64-linux]'
+    util_set_RUBY_VERSION "1.9.2", -1, 23493, "ruby 1.9.2dev (2009-05-20 trunk 23493) [x86_64-linux]"
 
-    assert_equal Gem::Version.new('1.9.2.dev'), Gem.ruby_version
+    assert_equal Gem::Version.new("1.9.2.dev"), Gem.ruby_version
   ensure
     util_restore_RUBY_VERSION
   end
 
   def test_self_ruby_version_with_git_master
-    util_set_RUBY_VERSION '2.7.0', -1, '5de284ec78220e75643f89b454ce999da0c1c195', 'ruby 2.7.0dev (2019-12-23T01:37:30Z master 5de284ec78) [x86_64-linux]'
+    util_set_RUBY_VERSION "2.7.0", -1, "5de284ec78220e75643f89b454ce999da0c1c195", "ruby 2.7.0dev (2019-12-23T01:37:30Z master 5de284ec78) [x86_64-linux]"
 
-    assert_equal Gem::Version.new('2.7.0.dev'), Gem.ruby_version
+    assert_equal Gem::Version.new("2.7.0.dev"), Gem.ruby_version
   ensure
     util_restore_RUBY_VERSION
   end
@@ -1144,7 +1159,7 @@ class TestGem < Gem::TestCase
   end
 
   def test_self_paths_eq
-    other = File.join @tempdir, 'other'
+    other = File.join @tempdir, "other"
     path = [@userhome, other].join File::PATH_SEPARATOR
 
     #
@@ -1157,12 +1172,12 @@ class TestGem < Gem::TestCase
   end
 
   def test_self_paths_eq_nonexistent_home
-    ENV['GEM_HOME'] = @gemhome
+    ENV["GEM_HOME"] = @gemhome
     Gem.clear_paths
 
-    other = File.join @tempdir, 'other'
+    other = File.join @tempdir, "other"
 
-    ENV['HOME'] = other
+    ENV["HOME"] = other
 
     Gem.paths = { "GEM_PATH" => other }
 
@@ -1172,7 +1187,7 @@ class TestGem < Gem::TestCase
   def test_self_post_build
     assert_equal 1, Gem.post_build_hooks.length
 
-    Gem.post_build { |installer| }
+    Gem.post_build {|installer| }
 
     assert_equal 2, Gem.post_build_hooks.length
   end
@@ -1180,7 +1195,7 @@ class TestGem < Gem::TestCase
   def test_self_post_install
     assert_equal 1, Gem.post_install_hooks.length
 
-    Gem.post_install { |installer| }
+    Gem.post_install {|installer| }
 
     assert_equal 2, Gem.post_install_hooks.length
   end
@@ -1188,7 +1203,7 @@ class TestGem < Gem::TestCase
   def test_self_done_installing
     assert_empty Gem.done_installing_hooks
 
-    Gem.done_installing { |gems| }
+    Gem.done_installing {|gems| }
 
     assert_equal 1, Gem.done_installing_hooks.length
   end
@@ -1196,7 +1211,7 @@ class TestGem < Gem::TestCase
   def test_self_post_reset
     assert_empty Gem.post_reset_hooks
 
-    Gem.post_reset { }
+    Gem.post_reset {}
 
     assert_equal 1, Gem.post_reset_hooks.length
   end
@@ -1204,7 +1219,7 @@ class TestGem < Gem::TestCase
   def test_self_post_uninstall
     assert_equal 1, Gem.post_uninstall_hooks.length
 
-    Gem.post_uninstall { |installer| }
+    Gem.post_uninstall {|installer| }
 
     assert_equal 2, Gem.post_uninstall_hooks.length
   end
@@ -1212,7 +1227,7 @@ class TestGem < Gem::TestCase
   def test_self_pre_install
     assert_equal 1, Gem.pre_install_hooks.length
 
-    Gem.pre_install { |installer| }
+    Gem.pre_install {|installer| }
 
     assert_equal 2, Gem.pre_install_hooks.length
   end
@@ -1220,7 +1235,7 @@ class TestGem < Gem::TestCase
   def test_self_pre_reset
     assert_empty Gem.pre_reset_hooks
 
-    Gem.pre_reset { }
+    Gem.pre_reset {}
 
     assert_equal 1, Gem.pre_reset_hooks.length
   end
@@ -1228,7 +1243,7 @@ class TestGem < Gem::TestCase
   def test_self_pre_uninstall
     assert_equal 1, Gem.pre_uninstall_hooks.length
 
-    Gem.pre_uninstall { |installer| }
+    Gem.pre_uninstall {|installer| }
 
     assert_equal 2, Gem.pre_uninstall_hooks.length
   end
@@ -1241,73 +1256,74 @@ class TestGem < Gem::TestCase
   end
 
   def test_try_activate_returns_true_for_activated_specs
-    b = util_spec 'b', '1.0' do |spec|
-      spec.files << 'lib/b.rb'
+    b = util_spec "b", "1.0" do |spec|
+      spec.files << "lib/b.rb"
     end
     install_specs b
 
-    assert Gem.try_activate('b'), 'try_activate should return true'
-    assert Gem.try_activate('b'), 'try_activate should still return true'
+    assert Gem.try_activate("b"), "try_activate should return true"
+    assert Gem.try_activate("b"), "try_activate should still return true"
   end
 
   def test_spec_order_is_consistent
-    b1 = util_spec 'b', '1.0'
-    b2 = util_spec 'b', '2.0'
-    b3 = util_spec 'b', '3.0'
+    b1 = util_spec "b", "1.0"
+    b2 = util_spec "b", "2.0"
+    b3 = util_spec "b", "3.0"
 
     install_specs b1, b2, b3
 
-    specs1 = Gem::Specification.stubs.find_all { |s| s.name == 'b' }
+    specs1 = Gem::Specification.stubs.find_all {|s| s.name == "b" }
     Gem::Specification.reset
-    specs2 = Gem::Specification.stubs_for('b')
+    specs2 = Gem::Specification.stubs_for("b")
     assert_equal specs1.map(&:version), specs2.map(&:version)
   end
 
   def test_self_try_activate_missing_dep
-    b = util_spec 'b', '1.0'
-    a = util_spec 'a', '1.0', 'b' => '>= 1.0'
+    b = util_spec "b", "1.0"
+    a = util_spec "a", "1.0", "b" => ">= 1.0"
 
     install_specs b, a
     uninstall_gem b
 
-    a_file = File.join a.gem_dir, 'lib', 'a_file.rb'
+    a_file = File.join a.gem_dir, "lib", "a_file.rb"
 
     write_file a_file do |io|
-      io.puts '# a_file.rb'
+      io.puts "# a_file.rb"
     end
 
-    e = assert_raises Gem::MissingSpecError do
-      Gem.try_activate 'a_file'
+    e = assert_raise Gem::MissingSpecError do
+      Gem.try_activate "a_file"
     end
 
-    assert_match %r%Could not find 'b' %, e.message
+    assert_match %r{Could not find 'b' }, e.message
+    assert_match %r{at: #{a.spec_file}}, e.message
   end
 
   def test_self_try_activate_missing_prerelease
-    b = util_spec 'b', '1.0rc1'
-    a = util_spec 'a', '1.0rc1', 'b' => '1.0rc1'
+    b = util_spec "b", "1.0rc1"
+    a = util_spec "a", "1.0rc1", "b" => "1.0rc1"
 
     install_specs b, a
     uninstall_gem b
 
-    a_file = File.join a.gem_dir, 'lib', 'a_file.rb'
+    a_file = File.join a.gem_dir, "lib", "a_file.rb"
 
     write_file a_file do |io|
-      io.puts '# a_file.rb'
+      io.puts "# a_file.rb"
     end
 
-    e = assert_raises Gem::MissingSpecError do
-      Gem.try_activate 'a_file'
+    e = assert_raise Gem::MissingSpecError do
+      Gem.try_activate "a_file"
     end
 
-    assert_match %r%Could not find 'b' \(= 1.0rc1\)%, e.message
+    assert_match %r{Could not find 'b' \(= 1.0rc1\)}, e.message
   end
 
   def test_self_try_activate_missing_extensions
-    spec = util_spec 'ext', '1' do |s|
+    spec = util_spec "ext", "1" do |s|
       s.extensions = %w[ext/extconf.rb]
       s.mark_version
-      s.installed_by_version = v('2.2')
+      s.installed_by_version = v("2.2")
     end
 
     # write the spec without install to simulate a failed install
@@ -1315,8 +1331,8 @@ class TestGem < Gem::TestCase
       io.write spec.to_ruby_for_cache
     end
 
-    _, err = capture_io do
-      refute Gem.try_activate 'nonexistent'
+    _, err = capture_output do
+      refute Gem.try_activate "nonexistent"
     end
 
     unless Gem.java_platform?
@@ -1328,43 +1344,43 @@ class TestGem < Gem::TestCase
   end
 
   def test_self_use_paths_with_nils
-    orig_home = ENV.delete 'GEM_HOME'
-    orig_path = ENV.delete 'GEM_PATH'
+    orig_home = ENV.delete "GEM_HOME"
+    orig_path = ENV.delete "GEM_PATH"
     Gem.use_paths nil, nil
     assert_equal Gem.default_dir, Gem.paths.home
     path = (Gem.default_path + [Gem.paths.home]).uniq
     assert_equal path, Gem.paths.path
   ensure
-    ENV['GEM_HOME'] = orig_home
-    ENV['GEM_PATH'] = orig_path
+    ENV["GEM_HOME"] = orig_home
+    ENV["GEM_PATH"] = orig_path
   end
 
   def test_setting_paths_does_not_warn_about_unknown_keys
-    stdout, stderr = capture_io do
-      Gem.paths = { 'foo'      => [],
-                    'bar'      => Object.new,
-                    'GEM_HOME' => Gem.paths.home,
-                    'GEM_PATH' => 'foo' }
-    end
-    assert_equal ['foo', Gem.paths.home], Gem.paths.path
-    assert_equal '', stderr
-    assert_equal '', stdout
+    stdout, stderr = capture_output do
+      Gem.paths = { "foo"      => [],
+                    "bar"      => Object.new,
+                    "GEM_HOME" => Gem.paths.home,
+                    "GEM_PATH" => "foo" }
+    end
+    assert_equal ["foo", Gem.paths.home], Gem.paths.path
+    assert_equal "", stderr
+    assert_equal "", stdout
   end
 
   def test_setting_paths_does_not_mutate_parameter_object
-    Gem.paths = { 'GEM_HOME' => Gem.paths.home,
-                  'GEM_PATH' => 'foo' }.freeze
-    assert_equal ['foo', Gem.paths.home], Gem.paths.path
+    Gem.paths = { "GEM_HOME" => Gem.paths.home,
+                  "GEM_PATH" => "foo" }.freeze
+    assert_equal ["foo", Gem.paths.home], Gem.paths.path
   end
 
   def test_deprecated_paths=
-    stdout, stderr = capture_io do
-      Gem.paths = { 'GEM_HOME' => Gem.paths.home,
-                    'GEM_PATH' => [Gem.paths.home, 'foo'] }
+    stdout, stderr = capture_output do
+      Gem.paths = { "GEM_HOME" => Gem.paths.home,
+                    "GEM_PATH" => [Gem.paths.home, "foo"] }
     end
-    assert_equal [Gem.paths.home, 'foo'], Gem.paths.path
+    assert_equal [Gem.paths.home, "foo"], Gem.paths.path
     assert_match(/Array values in the parameter to `Gem.paths=` are deprecated.\nPlease use a String or nil/m, stderr)
-    assert_equal '', stdout
+    assert_equal "", stdout
   end
 
   def test_self_use_paths
@@ -1377,17 +1393,19 @@ class TestGem < Gem::TestCase
   end
 
   def test_self_user_dir
-    parts = [@userhome, '.gem', Gem.ruby_engine]
-    parts << RbConfig::CONFIG['ruby_version'] unless RbConfig::CONFIG['ruby_version'].empty?
+    parts = [@userhome, ".gem", Gem.ruby_engine]
+    parts << RbConfig::CONFIG["ruby_version"] unless RbConfig::CONFIG["ruby_version"].empty?
+
+    FileUtils.mkdir_p File.join(parts)
 
     assert_equal File.join(parts), Gem.user_dir
   end
 
   def test_self_user_home
-    if ENV['HOME']
-      assert_equal ENV['HOME'], Gem.user_home
+    if ENV["HOME"]
+      assert_equal ENV["HOME"], Gem.user_home
     else
-      assert true, 'count this test'
+      assert true, "count this test"
     end
   end
 
@@ -1403,30 +1421,28 @@ class TestGem < Gem::TestCase
       r.gem "b", "= 1"
     end
 
-    activated = Gem::Specification.map { |x| x.full_name }
+    activated = Gem::Specification.map {|x| x.full_name }
 
-    assert_equal %w!a-1 b-1 c-2!, activated.sort
+    assert_equal %w[a-1 b-1 c-2], activated.sort
   end
 
   def test_self_needs_picks_up_unresolved_deps
-    save_loaded_features do
-      a = util_spec "a", "1"
-      b = util_spec "b", "1", "c" => nil
-      c = util_spec "c", "2"
-      d = util_spec "d", "1", {'e' => '= 1'}, "lib/d#{$$}.rb"
-      e = util_spec "e", "1"
-
-      install_specs a, c, b, e, d
+    a = util_spec "a", "1"
+    b = util_spec "b", "1", "c" => nil
+    c = util_spec "c", "2"
+    d = util_spec "d", "1", { "e" => "= 1" }, "lib/d#{$$}.rb"
+    e = util_spec "e", "1"
 
-      Gem.needs do |r|
-        r.gem "a"
-        r.gem "b", "= 1"
+    install_specs a, c, b, e, d
 
-        require "d#{$$}"
-      end
+    Gem.needs do |r|
+      r.gem "a"
+      r.gem "b", "= 1"
 
-      assert_equal %w!a-1 b-1 c-2 d-1 e-1!, loaded_spec_names
+      require "d#{$$}"
     end
+
+    assert_equal %w[a-1 b-1 c-2 d-1 e-1], loaded_spec_names
   end
 
   def test_self_gunzip
@@ -1435,35 +1451,35 @@ class TestGem < Gem::TestCase
 
     output = Gem::Util.gunzip input
 
-    assert_equal 'hello', output
+    assert_equal "hello", output
     assert_equal Encoding::BINARY, output.encoding
   end
 
   def test_self_gzip
-    input = 'hello'
+    input = "hello"
 
     output = Gem::Util.gzip input
 
     zipped = StringIO.new output
 
-    assert_equal 'hello', Zlib::GzipReader.new(zipped).read
+    assert_equal "hello", Zlib::GzipReader.new(zipped).read
     assert_equal Encoding::BINARY, output.encoding
   end
 
   def test_self_vendor_dir
-    vendordir(File.join(@tempdir, 'vendor')) do
+    vendordir(File.join(@tempdir, "vendor")) do
       expected =
-        File.join RbConfig::CONFIG['vendordir'], 'gems',
-                  RbConfig::CONFIG['ruby_version']
+        File.join RbConfig::CONFIG["vendordir"], "gems",
+                  RbConfig::CONFIG["ruby_version"]
 
       assert_equal expected, Gem.vendor_dir
     end
   end
 
   def test_self_vendor_dir_ENV_GEM_VENDOR
-    ENV['GEM_VENDOR'] = File.join @tempdir, 'vendor', 'gems'
+    ENV["GEM_VENDOR"] = File.join @tempdir, "vendor", "gems"
 
-    assert_equal ENV['GEM_VENDOR'], Gem.vendor_dir
+    assert_equal ENV["GEM_VENDOR"], Gem.vendor_dir
     refute Gem.vendor_dir.frozen?
   end
 
@@ -1477,28 +1493,52 @@ class TestGem < Gem::TestCase
     plugin_path = File.join "lib", "rubygems_plugin.rb"
 
     Dir.chdir @tempdir do
-      FileUtils.mkdir_p 'lib'
+      FileUtils.mkdir_p "lib"
       File.open plugin_path, "w" do |fp|
         fp.puts "class TestGem; PLUGINS_LOADED << 'plugin'; end"
       end
 
-      foo1 = util_spec 'foo', '1' do |s|
+      foo1 = util_spec "foo", "1" do |s|
         s.files << plugin_path
       end
 
       install_gem foo1
 
-      foo2 = util_spec 'foo', '2' do |s|
+      foo2 = util_spec "foo", "2" do |s|
         s.files << plugin_path
       end
 
       install_gem foo2
     end
 
-    Gem.searcher = nil
     Gem::Specification.reset
 
-    gem 'foo'
+    gem "foo"
+
+    Gem.load_plugins
+
+    assert_equal %w[plugin], PLUGINS_LOADED
+  end
+
+  def test_load_user_installed_plugins
+    plugin_path = File.join "lib", "rubygems_plugin.rb"
+
+    Dir.chdir @tempdir do
+      FileUtils.mkdir_p "lib"
+      File.open plugin_path, "w" do |fp|
+        fp.puts "class TestGem; PLUGINS_LOADED << 'plugin'; end"
+      end
+
+      foo = util_spec "foo", "1" do |s|
+        s.files << plugin_path
+      end
+
+      install_gem_user foo
+    end
+
+    Gem.paths = { "GEM_PATH" => [Gem.dir, Gem.user_dir].join(File::PATH_SEPARATOR) }
+
+    gem "foo"
 
     Gem.load_plugins
 
@@ -1506,30 +1546,30 @@ class TestGem < Gem::TestCase
   end
 
   def test_load_env_plugins
-    with_plugin('load') { Gem.load_env_plugins }
+    with_plugin("load") { Gem.load_env_plugins }
     assert_equal :loaded, TEST_PLUGIN_LOAD rescue nil
 
     util_remove_interrupt_command
 
     # Should attempt to cause a StandardError
-    with_plugin('standarderror') { Gem.load_env_plugins }
+    with_plugin("standarderror") { Gem.load_env_plugins }
     assert_equal :loaded, TEST_PLUGIN_STANDARDERROR rescue nil
 
     util_remove_interrupt_command
 
     # Should attempt to cause an Exception
-    with_plugin('exception') { Gem.load_env_plugins }
+    with_plugin("exception") { Gem.load_env_plugins }
     assert_equal :loaded, TEST_PLUGIN_EXCEPTION rescue nil
   end
 
   def test_gem_path_ordering
     refute_equal Gem.dir, Gem.user_dir
 
-    write_file File.join(@tempdir, 'lib', "g.rb") { |fp| fp.puts "" }
-    write_file File.join(@tempdir, 'lib', 'm.rb') { |fp| fp.puts "" }
+    write_file File.join(@tempdir, "lib", "g.rb") {|fp| fp.puts "" }
+    write_file File.join(@tempdir, "lib", "m.rb") {|fp| fp.puts "" }
 
-    g = util_spec 'g', '1', nil, "lib/g.rb"
-    m = util_spec 'm', '1', nil, "lib/m.rb"
+    g = util_spec "g", "1", nil, "lib/g.rb"
+    m = util_spec "m", "1", nil, "lib/m.rb"
 
     install_gem g, :install_dir => Gem.dir
     m0 = install_gem m, :install_dir => Gem.dir
@@ -1540,7 +1580,7 @@ class TestGem < Gem::TestCase
 
     tests = [
       [:dir0, [ Gem.dir, Gem.user_dir], m0],
-      [:dir1, [ Gem.user_dir, Gem.dir], m1]
+      [:dir1, [ Gem.user_dir, Gem.dir], m1],
     ]
 
     tests.each do |_name, _paths, expected|
@@ -1548,15 +1588,15 @@ class TestGem < Gem::TestCase
       Gem::Specification.reset
       Gem.searcher = nil
 
-      assert_equal Gem::Dependency.new('m','1').to_specs,
-                   Gem::Dependency.new('m','1').to_specs.sort
+      assert_equal Gem::Dependency.new("m","1").to_specs,
+                   Gem::Dependency.new("m","1").to_specs.sort
 
       assert_equal \
         [expected.gem_dir],
-        Gem::Dependency.new('m','1').to_specs.map(&:gem_dir).sort,
+        Gem::Dependency.new("m","1").to_specs.map(&:gem_dir).sort,
         "Wrong specs for #{_name}"
 
-      spec = Gem::Dependency.new('m','1').to_spec
+      spec = Gem::Dependency.new("m","1").to_spec
 
       assert_equal \
         File.join(_paths.first, "gems", "m-1"),
@@ -1566,7 +1606,7 @@ class TestGem < Gem::TestCase
 
       gem "m"
 
-      spec = Gem::Dependency.new('m','1').to_spec
+      spec = Gem::Dependency.new("m","1").to_spec
       assert spec.activated?, "dependency not activated for #{_name}"
 
       assert_equal \
@@ -1581,11 +1621,11 @@ class TestGem < Gem::TestCase
   end
 
   def test_gem_path_ordering_short
-    write_file File.join(@tempdir, 'lib', "g.rb") { |fp| fp.puts "" }
-    write_file File.join(@tempdir, 'lib', 'm.rb') { |fp| fp.puts "" }
+    write_file File.join(@tempdir, "lib", "g.rb") {|fp| fp.puts "" }
+    write_file File.join(@tempdir, "lib", "m.rb") {|fp| fp.puts "" }
 
-    g = util_spec 'g', '1', nil, "lib/g.rb"
-    m = util_spec 'm', '1', nil, "lib/m.rb"
+    g = util_spec "g", "1", nil, "lib/g.rb"
+    m = util_spec "m", "1", nil, "lib/m.rb"
 
     install_gem g, :install_dir => Gem.dir
     install_gem m, :install_dir => Gem.dir
@@ -1595,7 +1635,7 @@ class TestGem < Gem::TestCase
 
     assert_equal \
       File.join(Gem.dir, "gems", "m-1"),
-      Gem::Dependency.new('m','1').to_spec.gem_dir,
+      Gem::Dependency.new("m","1").to_spec.gem_dir,
       "Wrong spec selected"
   end
 
@@ -1614,11 +1654,11 @@ class TestGem < Gem::TestCase
       f.puts "gem 'c'"
     end
 
-    ENV['RUBYGEMS_GEMDEPS'] = path
+    with_rubygems_gemdeps(path) do
+      Gem.use_gemdeps
 
-    Gem.use_gemdeps
-
-    assert_equal add_bundler_full_name(%W(a-1 b-1 c-1)), loaded_spec_names
+      assert_equal add_bundler_full_name(%W[a-1 b-1 c-1]), loaded_spec_names
+    end
   end
 
   def test_auto_activation_of_used_gemdeps_file
@@ -1636,14 +1676,16 @@ class TestGem < Gem::TestCase
       f.puts "gem 'c'"
     end
 
-    ENV['RUBYGEMS_GEMDEPS'] = "-"
+    with_rubygems_gemdeps("-") do
+      expected_specs = [a, b, util_spec("bundler", Bundler::VERSION), c].compact.map(&:full_name)
 
-    expected_specs = [a, b, util_spec("bundler", Bundler::VERSION), c].compact
-    assert_equal expected_specs, Gem.use_gemdeps.sort_by { |s| s.name }
+      Gem.use_gemdeps
+
+      assert_equal expected_specs, loaded_spec_names
+    end
   end
 
-  LIB_PATH = File.expand_path "../../../lib".dup.tap(&Gem::UNTAINT), __FILE__.dup.tap(&Gem::UNTAINT)
-  BUNDLER_LIB_PATH = File.expand_path $LOAD_PATH.find {|lp| File.file?(File.join(lp, "bundler.rb")) }.dup.tap(&Gem::UNTAINT)
+  BUNDLER_LIB_PATH = File.expand_path $LOAD_PATH.find {|lp| File.file?(File.join(lp, "bundler.rb")) }
   BUNDLER_FULL_NAME = "bundler-#{Bundler::VERSION}".freeze
 
   def add_bundler_full_name(names)
@@ -1652,10 +1694,18 @@ class TestGem < Gem::TestCase
     names
   end
 
-  def test_looks_for_gemdeps_files_automatically_on_start
-    skip "Requiring bundler messes things up" if Gem.java_platform?
+  def test_looks_for_gemdeps_files_automatically_from_binstubs
+    pend "Requiring bundler messes things up" if Gem.java_platform?
+
+    a = util_spec "a", "1" do |s|
+      s.executables = %w[foo]
+      s.bindir = "exe"
+    end
+
+    write_file File.join(@tempdir, "exe", "foo") do |fp|
+      fp.puts "puts Gem.loaded_specs.values.map(&:full_name).sort"
+    end
 
-    a = util_spec "a", "1", nil, "lib/a.rb"
     b = util_spec "b", "1", nil, "lib/b.rb"
     c = util_spec "c", "1", nil, "lib/c.rb"
 
@@ -1666,32 +1716,45 @@ class TestGem < Gem::TestCase
     install_gem b, :install_dir => path
     install_gem c, :install_dir => path
 
-    ENV['GEM_PATH'] = path
-    ENV['RUBYGEMS_GEMDEPS'] = "-"
+    ENV["GEM_PATH"] = path
 
-    path = File.join @tempdir, "gem.deps.rb"
-    cmd = [Gem.ruby.dup.tap(&Gem::UNTAINT), "-I#{LIB_PATH.tap(&Gem::UNTAINT)}",
-           "-I#{BUNDLER_LIB_PATH.tap(&Gem::UNTAINT)}", "-rrubygems"]
-    cmd << "-eputs Gem.loaded_specs.values.map(&:full_name).sort"
+    with_rubygems_gemdeps("-") do
+      new_PATH = [File.join(path, "bin"), ENV["PATH"]].join(File::PATH_SEPARATOR)
+      new_RUBYOPT = "-I#{rubygems_path} -I#{BUNDLER_LIB_PATH}"
 
-    File.open path, "w" do |f|
-      f.puts "gem 'a'"
-    end
-    out0 = IO.popen(cmd, &:read).split(/\n/)
+      path = File.join @tempdir, "gem.deps.rb"
 
-    File.open path, "a" do |f|
-      f.puts "gem 'b'"
-      f.puts "gem 'c'"
-    end
-    out = IO.popen(cmd, &:read).split(/\n/)
+      File.open path, "w" do |f|
+        f.puts "gem 'a'"
+      end
+      out0 = with_path_and_rubyopt(new_PATH, new_RUBYOPT) do
+        IO.popen("foo", &:read).split(/\n/)
+      end
+
+      File.open path, "a" do |f|
+        f.puts "gem 'b'"
+        f.puts "gem 'c'"
+      end
+      out = with_path_and_rubyopt(new_PATH, new_RUBYOPT) do
+        IO.popen("foo", &:read).split(/\n/)
+      end
 
-    assert_equal ["b-1", "c-1"], out - out0
+      assert_equal ["b-1", "c-1"], out - out0
+    end
   end
 
-  def test_looks_for_gemdeps_files_automatically_on_start_in_parent_dir
-    skip "Requiring bundler messes things up" if Gem.java_platform?
+  def test_looks_for_gemdeps_files_automatically_from_binstubs_in_parent_dir
+    pend "Requiring bundler messes things up" if Gem.java_platform?
+
+    a = util_spec "a", "1" do |s|
+      s.executables = %w[foo]
+      s.bindir = "exe"
+    end
+
+    write_file File.join(@tempdir, "exe", "foo") do |fp|
+      fp.puts "puts Gem.loaded_specs.values.map(&:full_name).sort"
+    end
 
-    a = util_spec "a", "1", nil, "lib/a.rb"
     b = util_spec "b", "1", nil, "lib/b.rb"
     c = util_spec "c", "1", nil, "lib/c.rb"
 
@@ -1702,30 +1765,35 @@ class TestGem < Gem::TestCase
     install_gem b, :install_dir => path
     install_gem c, :install_dir => path
 
-    ENV['GEM_PATH'] = path
-    ENV['RUBYGEMS_GEMDEPS'] = "-"
+    ENV["GEM_PATH"] = path
 
-    Dir.mkdir "sub1"
+    with_rubygems_gemdeps("-") do
+      Dir.mkdir "sub1"
 
-    path = File.join @tempdir, "gem.deps.rb"
-    cmd = [Gem.ruby.dup.tap(&Gem::UNTAINT), "-Csub1", "-I#{LIB_PATH.tap(&Gem::UNTAINT)}",
-           "-I#{BUNDLER_LIB_PATH.tap(&Gem::UNTAINT)}", "-rrubygems"]
-    cmd << "-eputs Gem.loaded_specs.values.map(&:full_name).sort"
+      new_PATH = [File.join(path, "bin"), ENV["PATH"]].join(File::PATH_SEPARATOR)
+      new_RUBYOPT = "-I#{rubygems_path} -I#{BUNDLER_LIB_PATH}"
 
-    File.open path, "w" do |f|
-      f.puts "gem 'a'"
-    end
-    out0 = IO.popen(cmd, &:read).split(/\n/)
+      path = File.join @tempdir, "gem.deps.rb"
 
-    File.open path, "a" do |f|
-      f.puts "gem 'b'"
-      f.puts "gem 'c'"
-    end
-    out = IO.popen(cmd, &:read).split(/\n/)
+      File.open path, "w" do |f|
+        f.puts "gem 'a'"
+      end
+      out0 = with_path_and_rubyopt(new_PATH, new_RUBYOPT) do
+        IO.popen("foo", :chdir => "sub1", &:read).split(/\n/)
+      end
 
-    Dir.rmdir "sub1"
+      File.open path, "a" do |f|
+        f.puts "gem 'b'"
+        f.puts "gem 'c'"
+      end
+      out = with_path_and_rubyopt(new_PATH, new_RUBYOPT) do
+        IO.popen("foo", :chdir => "sub1", &:read).split(/\n/)
+      end
 
-    assert_equal ["b-1", "c-1"], out - out0
+      Dir.rmdir "sub1"
+
+      assert_equal ["b-1", "c-1"], out - out0
+    end
   end
 
   def test_register_default_spec
@@ -1769,14 +1837,14 @@ class TestGem < Gem::TestCase
   end
 
   def test_use_gemdeps
-    gem_deps_file = 'gem.deps.rb'.tap(&Gem::UNTAINT)
-    spec = util_spec 'a', 1
+    gem_deps_file = "gem.deps.rb".tap(&Gem::UNTAINT)
+    spec = util_spec "a", 1
     install_specs spec
 
-    spec = Gem::Specification.find { |s| s == spec }
+    spec = Gem::Specification.find {|s| s == spec }
     refute spec.activated?
 
-    File.open gem_deps_file, 'w' do |io|
+    File.open gem_deps_file, "w" do |io|
       io.write 'gem "a"'
     end
 
@@ -1784,146 +1852,126 @@ class TestGem < Gem::TestCase
 
     Gem.use_gemdeps gem_deps_file
 
-    assert_equal add_bundler_full_name(%W(a-1)), loaded_spec_names
+    assert_equal add_bundler_full_name(%W[a-1]), loaded_spec_names
     refute_nil Gem.gemdeps
   end
 
   def test_use_gemdeps_ENV
-    rubygems_gemdeps, ENV['RUBYGEMS_GEMDEPS'] = ENV['RUBYGEMS_GEMDEPS'], nil
+    with_rubygems_gemdeps(nil) do
+      spec = util_spec "a", 1
 
-    spec = util_spec 'a', 1
+      refute spec.activated?
 
-    refute spec.activated?
-
-    File.open 'gem.deps.rb', 'w' do |io|
-      io.write 'gem "a"'
-    end
+      File.open "gem.deps.rb", "w" do |io|
+        io.write 'gem "a"'
+      end
 
-    Gem.use_gemdeps
+      Gem.use_gemdeps
 
-    refute spec.activated?
-  ensure
-    ENV['RUBYGEMS_GEMDEPS'] = rubygems_gemdeps
+      refute spec.activated?
+    end
   end
 
   def test_use_gemdeps_argument_missing
-    e = assert_raises ArgumentError do
-      Gem.use_gemdeps 'gem.deps.rb'
+    e = assert_raise ArgumentError do
+      Gem.use_gemdeps "gem.deps.rb"
     end
 
-    assert_equal 'Unable to find gem dependencies file at gem.deps.rb',
+    assert_equal "Unable to find gem dependencies file at gem.deps.rb",
                  e.message
   end
 
   def test_use_gemdeps_argument_missing_match_ENV
-    rubygems_gemdeps, ENV['RUBYGEMS_GEMDEPS'] =
-      ENV['RUBYGEMS_GEMDEPS'], 'gem.deps.rb'
+    with_rubygems_gemdeps("gem.deps.rb") do
+      e = assert_raise ArgumentError do
+        Gem.use_gemdeps "gem.deps.rb"
+      end
 
-    e = assert_raises ArgumentError do
-      Gem.use_gemdeps 'gem.deps.rb'
+      assert_equal "Unable to find gem dependencies file at gem.deps.rb",
+                   e.message
     end
-
-    assert_equal 'Unable to find gem dependencies file at gem.deps.rb',
-                 e.message
-  ensure
-    ENV['RUBYGEMS_GEMDEPS'] = rubygems_gemdeps
   end
 
   def test_use_gemdeps_automatic
-    rubygems_gemdeps, ENV['RUBYGEMS_GEMDEPS'] = ENV['RUBYGEMS_GEMDEPS'], '-'
-
-    spec = util_spec 'a', 1
-    install_specs spec
-    spec = Gem::Specification.find { |s| s == spec }
+    with_rubygems_gemdeps("-") do
+      spec = util_spec "a", 1
+      install_specs spec
+      spec = Gem::Specification.find {|s| s == spec }
 
-    refute spec.activated?
+      refute spec.activated?
 
-    File.open 'Gemfile', 'w' do |io|
-      io.write 'gem "a"'
-    end
+      File.open "Gemfile", "w" do |io|
+        io.write 'gem "a"'
+      end
 
-    Gem.use_gemdeps
+      Gem.use_gemdeps
 
-    assert_equal add_bundler_full_name(%W(a-1)), loaded_spec_names
-  ensure
-    ENV['RUBYGEMS_GEMDEPS'] = rubygems_gemdeps
+      assert_equal add_bundler_full_name(%W[a-1]), loaded_spec_names
+    end
   end
 
   def test_use_gemdeps_automatic_missing
-    rubygems_gemdeps, ENV['RUBYGEMS_GEMDEPS'] = ENV['RUBYGEMS_GEMDEPS'], '-'
+    with_rubygems_gemdeps("-") do
+      Gem.use_gemdeps
 
-    Gem.use_gemdeps
-
-    assert true # count
-  ensure
-    ENV['RUBYGEMS_GEMDEPS'] = rubygems_gemdeps
+      assert true # count
+    end
   end
 
   def test_use_gemdeps_disabled
-    rubygems_gemdeps, ENV['RUBYGEMS_GEMDEPS'] = ENV['RUBYGEMS_GEMDEPS'], ''
+    with_rubygems_gemdeps("") do
+      spec = util_spec "a", 1
 
-    spec = util_spec 'a', 1
+      refute spec.activated?
 
-    refute spec.activated?
-
-    File.open 'gem.deps.rb', 'w' do |io|
-      io.write 'gem "a"'
-    end
+      File.open "gem.deps.rb", "w" do |io|
+        io.write 'gem "a"'
+      end
 
-    Gem.use_gemdeps
+      Gem.use_gemdeps
 
-    refute spec.activated?
-  ensure
-    ENV['RUBYGEMS_GEMDEPS'] = rubygems_gemdeps
+      refute spec.activated?
+    end
   end
 
   def test_use_gemdeps_missing_gem
-    rubygems_gemdeps, ENV['RUBYGEMS_GEMDEPS'] = ENV['RUBYGEMS_GEMDEPS'], 'x'
-
-    File.open 'x', 'w' do |io|
-      io.write 'gem "a"'
-    end
-
-    platform = Bundler::GemHelpers.generic_local_platform
-    if platform == Gem::Platform::RUBY
-      platform = ''
-    else
-      platform = " #{platform}"
-    end
+    with_rubygems_gemdeps("x") do
+      File.open "x", "w" do |io|
+        io.write 'gem "a"'
+      end
 
-    expected = <<-EXPECTED
-Could not find gem 'a#{platform}' in any of the gem sources listed in your Gemfile.
-You may need to `gem install -g` to install missing gems
+      expected = <<-EXPECTED
+Could not find gem 'a' in locally installed gems.
+You may need to `bundle install` to install missing gems
 
-    EXPECTED
+      EXPECTED
 
-    Gem::Deprecate.skip_during do
-      assert_output nil, expected do
-        Gem.use_gemdeps
+      Gem::Deprecate.skip_during do
+        actual_stdout, actual_stderr = capture_output do
+          Gem.use_gemdeps
+        end
+        assert_empty actual_stdout
+        assert_equal(expected, actual_stderr)
       end
     end
-  ensure
-    ENV['RUBYGEMS_GEMDEPS'] = rubygems_gemdeps
   end
 
   def test_use_gemdeps_specific
-    rubygems_gemdeps, ENV['RUBYGEMS_GEMDEPS'] = ENV['RUBYGEMS_GEMDEPS'], 'x'
+    with_rubygems_gemdeps("x") do
+      spec = util_spec "a", 1
+      install_specs spec
 
-    spec = util_spec 'a', 1
-    install_specs spec
-
-    spec = Gem::Specification.find { |s| s == spec }
-    refute spec.activated?
+      spec = Gem::Specification.find {|s| s == spec }
+      refute spec.activated?
 
-    File.open 'x', 'w' do |io|
-      io.write 'gem "a"'
-    end
+      File.open "x", "w" do |io|
+        io.write 'gem "a"'
+      end
 
-    Gem.use_gemdeps
+      Gem.use_gemdeps
 
-    assert_equal add_bundler_full_name(%W(a-1)), loaded_spec_names
-  ensure
-    ENV['RUBYGEMS_GEMDEPS'] = rubygems_gemdeps
+      assert_equal add_bundler_full_name(%W[a-1]), loaded_spec_names
+    end
   end
 
   def test_operating_system_defaults
@@ -1943,8 +1991,8 @@ You may need to `gem install -g` to inst
   # Ensure that `Gem.source_date_epoch` is consistent even if
   # $SOURCE_DATE_EPOCH has not been set.
   def test_default_source_date_epoch_doesnt_change
-    old_epoch = ENV['SOURCE_DATE_EPOCH']
-    ENV['SOURCE_DATE_EPOCH'] = nil
+    old_epoch = ENV["SOURCE_DATE_EPOCH"]
+    ENV["SOURCE_DATE_EPOCH"] = nil
 
     # Unfortunately, there is no real way to test this aside from waiting
     # enough for `Time.now.to_i` to change -- which is a whole second.
@@ -1955,31 +2003,46 @@ You may need to `gem install -g` to inst
     b = Gem.source_date_epoch
     assert_equal a, b
   ensure
-    ENV['SOURCE_DATE_EPOCH'] = old_epoch
+    ENV["SOURCE_DATE_EPOCH"] = old_epoch
   end
 
+  private
+
   def ruby_install_name(name)
     with_clean_path_to_ruby do
-      orig_RUBY_INSTALL_NAME = RbConfig::CONFIG['ruby_install_name']
-      RbConfig::CONFIG['ruby_install_name'] = name
+      orig_RUBY_INSTALL_NAME = RbConfig::CONFIG["ruby_install_name"]
+      RbConfig::CONFIG["ruby_install_name"] = name
 
       begin
         yield
       ensure
         if orig_RUBY_INSTALL_NAME
-          RbConfig::CONFIG['ruby_install_name'] = orig_RUBY_INSTALL_NAME
+          RbConfig::CONFIG["ruby_install_name"] = orig_RUBY_INSTALL_NAME
         else
-          RbConfig::CONFIG.delete 'ruby_install_name'
+          RbConfig::CONFIG.delete "ruby_install_name"
         end
       end
     end
   end
 
-  def with_bindir_and_exeext(bindir, exeext)
-    bindir(bindir) do
-      exeext(exeext) do
-        yield
-      end
+  def with_rb_config_ruby(path)
+    rb_config_singleton_class = class << RbConfig; self; end
+    orig_path = RbConfig.ruby
+
+    redefine_method(rb_config_singleton_class, :ruby, path)
+
+    yield
+  ensure
+    redefine_method(rb_config_singleton_class, :ruby, orig_path)
+  end
+
+  def redefine_method(base, method, new_result)
+    if RUBY_VERSION >= "2.5"
+      base.alias_method(method, method)
+      base.define_method(method) { new_result }
+    else
+      base.send(:alias_method, method, method)
+      base.send(:define_method, method) { new_result }
     end
   end
 
@@ -1992,7 +2055,7 @@ You may need to `gem install -g` to inst
     refute_includes $LOAD_PATH, test_plugin_path
     $LOAD_PATH.unshift test_plugin_path
 
-    capture_io do
+    capture_output do
       yield
     end
   ensure
@@ -2011,12 +2074,12 @@ You may need to `gem install -g` to inst
   end
 
   def util_exec_gem
-    spec, _ = util_spec 'a', '4' do |s|
-      s.executables = ['exec', 'abin']
+    spec, _ = util_spec "a", "4" do |s|
+      s.executables = ["exec", "abin"]
     end
 
-    @exec_path = File.join spec.full_gem_path, spec.bindir, 'exec'
-    @abin_path = File.join spec.full_gem_path, spec.bindir, 'abin'
+    @exec_path = File.join spec.full_gem_path, spec.bindir, "exec"
+    @abin_path = File.join spec.full_gem_path, spec.bindir, "abin"
     spec
   end
 
@@ -2029,4 +2092,21 @@ You may need to `gem install -g` to inst
     File.join Gem.dir, "cache"
   end
 
+  def with_path_and_rubyopt(path_value, rubyopt_value)
+    path, ENV["PATH"] = ENV["PATH"], path_value
+    rubyopt, ENV["RUBYOPT"] = ENV["RUBYOPT"], rubyopt_value
+
+    yield
+  ensure
+    ENV["PATH"] = path
+    ENV["RUBYOPT"] = rubyopt
+  end
+
+  def with_rubygems_gemdeps(value)
+    rubygems_gemdeps, ENV["RUBYGEMS_GEMDEPS"] = ENV["RUBYGEMS_GEMDEPS"], value
+
+    yield
+  ensure
+    ENV["RUBYGEMS_GEMDEPS"] = rubygems_gemdeps
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_available_set.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_available_set.rb
@@ -1,10 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/available_set'
-require 'rubygems/security'
+require_relative "helper"
+require "rubygems/available_set"
+require "rubygems/security"
 
 class TestGemAvailableSet < Gem::TestCase
-
   def setup
     super
 
@@ -12,7 +11,7 @@ class TestGemAvailableSet < Gem::TestCas
   end
 
   def test_add_and_empty
-    a1, _ = util_gem 'a', '1'
+    a1, _ = util_gem "a", "1"
 
     set = Gem::AvailableSet.new
     assert set.empty?
@@ -25,8 +24,8 @@ class TestGemAvailableSet < Gem::TestCas
   end
 
   def test_find_all
-    a1,  a1_gem  = util_gem 'a', 1
-    a1a, a1a_gem = util_gem 'a', '1.a'
+    a1,  a1_gem  = util_gem "a", 1
+    a1a, a1a_gem = util_gem "a", "1.a"
 
     a1_source  = Gem::Source::SpecificFile.new a1_gem
     a1a_source = Gem::Source::SpecificFile.new a1a_gem
@@ -35,26 +34,26 @@ class TestGemAvailableSet < Gem::TestCas
     set.add a1,  a1_source
     set.add a1a, a1a_source
 
-    dep = Gem::Resolver::DependencyRequest.new dep('a'), nil
+    dep = Gem::Resolver::DependencyRequest.new dep("a"), nil
 
-    assert_equal %w[a-1], set.find_all(dep).map { |spec| spec.full_name }
+    assert_equal %w[a-1], set.find_all(dep).map {|spec| spec.full_name }
 
-    dep = Gem::Resolver::DependencyRequest.new dep('a', '>= 0.a'), nil
+    dep = Gem::Resolver::DependencyRequest.new dep("a", ">= 0.a"), nil
 
     assert_equal %w[a-1 a-1.a],
-                 set.find_all(dep).map { |spec| spec.full_name }.sort
+                 set.find_all(dep).map {|spec| spec.full_name }.sort
   end
 
   def test_match_platform
-    a1, _ = util_gem 'a', '1' do |g|
+    a1, _ = util_gem "a", "1" do |g|
       g.platform = "something-weird-yep"
     end
 
-    a1c, _ = util_gem 'a', '2' do |g|
+    a1c, _ = util_gem "a", "2" do |g|
       g.platform = Gem::Platform.local
     end
 
-    a2, _ = util_gem 'a', '2'
+    a2, _ = util_gem "a", "2"
 
     set = Gem::AvailableSet.new
     set.add a1, @source
@@ -67,8 +66,8 @@ class TestGemAvailableSet < Gem::TestCas
   end
 
   def test_best
-    a1, _ = util_gem 'a', '1'
-    a2, _ = util_gem 'a', '2'
+    a1, _ = util_gem "a", "1"
+    a2, _ = util_gem "a", "2"
 
     set = Gem::AvailableSet.new
     set.add a1, @source
@@ -80,7 +79,7 @@ class TestGemAvailableSet < Gem::TestCas
   end
 
   def test_remove_installed_bang
-    a1, _ = util_spec 'a', '1'
+    a1, _ = util_spec "a", "1"
     install_specs a1
 
     a1.activate
@@ -96,8 +95,8 @@ class TestGemAvailableSet < Gem::TestCas
   end
 
   def test_sorted_normal_versions
-    a1, _ = util_gem 'a', '1'
-    a2, _ = util_gem 'a', '2'
+    a1, _ = util_gem "a", "1"
+    a2, _ = util_gem "a", "2"
 
     set = Gem::AvailableSet.new
     set.add a1, @source
@@ -110,11 +109,11 @@ class TestGemAvailableSet < Gem::TestCas
   end
 
   def test_sorted_respect_pre
-    a1a, _ = util_gem 'a', '1.a'
-    a1,  _ = util_gem 'a', '1'
-    a2a, _ = util_gem 'a', '2.a'
-    a2,  _ = util_gem 'a', '2'
-    a3a, _ = util_gem 'a', '3.a'
+    a1a, _ = util_gem "a", "1.a"
+    a1,  _ = util_gem "a", "1"
+    a2a, _ = util_gem "a", "2.a"
+    a2,  _ = util_gem "a", "2"
+    a3a, _ = util_gem "a", "3.a"
 
     set = Gem::AvailableSet.new
     set.add a1, @source
@@ -123,9 +122,8 @@ class TestGemAvailableSet < Gem::TestCas
     set.add a2a, @source
     set.add a2, @source
 
-    g = set.sorted.map { |t| t.spec }
+    g = set.sorted.map {|t| t.spec }
 
     assert_equal [a3a, a2, a2a, a1, a1a], g
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_bundler_version_finder.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_bundler_version_finder.rb
@@ -1,20 +1,17 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemBundlerVersionFinder < Gem::TestCase
-
   def setup
     super
 
     @argv = ARGV.dup
-    @env = ENV.to_hash.clone
-    ENV.delete("BUNDLER_VERSION")
     @dollar_0 = $0
+    without_any_upwards_gemfiles
   end
 
   def teardown
     ARGV.replace @argv
-    ENV.replace @env
     $0 = @dollar_0
 
     super
@@ -51,82 +48,78 @@ class TestGemBundlerVersionFinder < Gem:
   end
 
   def test_bundler_version_with_lockfile
-    bvf.stub(:lockfile_contents, [nil, ""]) do
+    bvf.stub(:lockfile_contents, "") do
       assert_nil bvf.bundler_version
     end
-    bvf.stub(:lockfile_contents, [nil, "\n\nBUNDLED WITH\n   1.1.1.1\n"]) do
+    bvf.stub(:lockfile_contents, "\n\nBUNDLED WITH\n   1.1.1.1\n") do
       assert_equal v("1.1.1.1"), bvf.bundler_version
     end
-    bvf.stub(:lockfile_contents, [nil, "\n\nBUNDLED WITH\n   fjdkslfjdkslfjsldk\n"]) do
+    bvf.stub(:lockfile_contents, "\n\nBUNDLED WITH\n   fjdkslfjdkslfjsldk\n") do
       assert_nil bvf.bundler_version
     end
   end
 
-  def test_bundler_version_with_reason
-    assert_nil bvf.bundler_version_with_reason
-    bvf.stub(:lockfile_contents, [nil, "\n\nBUNDLED WITH\n   1.1.1.1\n"]) do
-      assert_equal ["1.1.1.1", "your lockfile"], bvf.bundler_version_with_reason
+  def test_bundler_version
+    assert_nil bvf.bundler_version
+    bvf.stub(:lockfile_contents, "\n\nBUNDLED WITH\n   1.1.1.1\n") do
+      assert_equal "1.1.1.1", bvf.bundler_version.to_s
 
       $0 = "bundle"
       ARGV.replace %w[update --bundler]
-      assert_nil bvf.bundler_version_with_reason
+      assert_nil bvf.bundler_version
+
       ARGV.replace %w[update --bundler=1.1.1.2]
-      assert_equal ["1.1.1.2", "`bundle update --bundler`"], bvf.bundler_version_with_reason
+      assert_equal "1.1.1.2",  bvf.bundler_version.to_s
 
       ENV["BUNDLER_VERSION"] = "1.1.1.3"
-      assert_equal ["1.1.1.3", "`$BUNDLER_VERSION`"], bvf.bundler_version_with_reason
+      assert_equal "1.1.1.3", bvf.bundler_version.to_s
     end
   end
 
-  def test_compatible
-    assert bvf.compatible?(util_spec("foo"))
-    assert bvf.compatible?(util_spec("bundler", 1.1))
+  def test_deleted_directory
+    pend "Cannot perform this test on windows" if win_platform?
+    pend "Cannot perform this test on Solaris" if /solaris/ =~ RUBY_PLATFORM
+    require "tmpdir"
 
-    bvf.stub(:bundler_version, v("1.1.1.1")) do
-      assert bvf.compatible?(util_spec("foo"))
-      assert bvf.compatible?(util_spec("bundler", "1.1.1.1"))
-      assert bvf.compatible?(util_spec("bundler", "1.1.1.a"))
-      assert bvf.compatible?(util_spec("bundler", "1.999"))
-      refute bvf.compatible?(util_spec("bundler", "2.999"))
-    end
+    orig_dir = Dir.pwd
 
-    bvf.stub(:bundler_version, v("2.1.1.1")) do
-      assert bvf.compatible?(util_spec("foo"))
-      assert bvf.compatible?(util_spec("bundler", "2.1.1.1"))
-      assert bvf.compatible?(util_spec("bundler", "2.1.1.a"))
-      assert bvf.compatible?(util_spec("bundler", "2.999"))
-      refute bvf.compatible?(util_spec("bundler", "1.999"))
-      refute bvf.compatible?(util_spec("bundler", "3.0.0"))
+    begin
+      Dir.mktmpdir("some_dir") do |dir|
+        Dir.chdir(dir)
+      end
+    ensure
+      Dir.chdir(orig_dir)
     end
+
+    assert_nil bvf.bundler_version
   end
 
-  def test_filter
+  def test_prioritize
     versions = %w[1 1.0 1.0.1.1 2 2.a 2.0 2.1.1 3 3.a 3.0 3.1.1]
-    specs = versions.map { |v| util_spec("bundler", v) }
+    specs = versions.map {|v| util_spec("bundler", v) }
 
-    assert_equal %w[1 1.0 1.0.1.1 2 2.a 2.0 2.1.1 3 3.a 3.0 3.1.1], util_filter_specs(specs).map(&:version).map(&:to_s)
+    assert_equal %w[1 1.0 1.0.1.1 2 2.a 2.0 2.1.1 3 3.a 3.0 3.1.1], util_prioritize_specs(specs)
 
     bvf.stub(:bundler_version, v("2.1.1.1")) do
-      assert_equal %w[2 2.a 2.0 2.1.1], util_filter_specs(specs).map(&:version).map(&:to_s)
+      assert_equal %w[1 1.0 1.0.1.1 2 2.a 2.0 2.1.1 3 3.a 3.0 3.1.1], util_prioritize_specs(specs)
     end
     bvf.stub(:bundler_version, v("1.1.1.1")) do
-      assert_equal %w[1 1.0 1.0.1.1], util_filter_specs(specs).map(&:version).map(&:to_s)
+      assert_equal %w[1 1.0 1.0.1.1 2 2.a 2.0 2.1.1 3 3.a 3.0 3.1.1], util_prioritize_specs(specs)
     end
     bvf.stub(:bundler_version, v("1")) do
-      assert_equal %w[1 1.0 1.0.1.1], util_filter_specs(specs).map(&:version).map(&:to_s)
+      assert_equal %w[1 1.0 1.0.1.1 2 2.a 2.0 2.1.1 3 3.a 3.0 3.1.1], util_prioritize_specs(specs)
     end
     bvf.stub(:bundler_version, v("2.a")) do
-      assert_equal %w[2.a 2 2.0 2.1.1], util_filter_specs(specs).map(&:version).map(&:to_s)
+      assert_equal %w[2.a 1 1.0 1.0.1.1 2 2.0 2.1.1 3 3.a 3.0 3.1.1], util_prioritize_specs(specs)
     end
     bvf.stub(:bundler_version, v("3")) do
-      assert_equal %w[3 3.a 3.0 3.1.1], util_filter_specs(specs).map(&:version).map(&:to_s)
+      assert_equal %w[3 1 1.0 1.0.1.1 2 2.a 2.0 2.1.1 3.a 3.0 3.1.1], util_prioritize_specs(specs)
     end
   end
 
-  def util_filter_specs(specs)
+  def util_prioritize_specs(specs)
     specs = specs.dup
-    bvf.filter!(specs)
-    specs
+    bvf.prioritize!(specs)
+    specs.map(&:version).map(&:to_s)
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_command.rb
@@ -1,15 +1,12 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/command'
+require_relative "helper"
+require "rubygems/command"
 
 class Gem::Command
-
   public :parser
-
 end
 
 class TestGemCommand < Gem::TestCase
-
   def setup
     super
 
@@ -18,13 +15,13 @@ class TestGemCommand < Gem::TestCase
     @common_options = Gem::Command.common_options.dup
     Gem::Command.common_options.clear
     Gem::Command.common_options << [
-      ['-x', '--exe', 'Execute'], lambda do |*a|
+      ["-x", "--exe", "Execute"], lambda do |*a|
         @xopt = true
       end
     ]
 
-    @cmd_name = 'doit'
-    @cmd = Gem::Command.new @cmd_name, 'summary'
+    @cmd_name = "doit"
+    @cmd = Gem::Command.new @cmd_name, "summary"
   end
 
   def teardown
@@ -34,7 +31,7 @@ class TestGemCommand < Gem::TestCase
 
   def test_self_add_specific_extra_args
     added_args = %w[--all]
-    @cmd.add_option('--all') { |v,o| }
+    @cmd.add_option("--all") {|v,o| }
 
     Gem::Command.add_specific_extra_args @cmd_name, added_args
 
@@ -57,6 +54,27 @@ class TestGemCommand < Gem::TestCase
     assert_equal [], h
   end
 
+  def test_self_extra_args
+    verbose, $VERBOSE, separator = $VERBOSE, nil, $;
+    extra_args = Gem::Command.extra_args
+
+    Gem::Command.extra_args = %w[--all]
+    assert_equal %w[--all], Gem::Command.extra_args
+
+    Gem::Command.extra_args = "--file --help"
+    assert_equal %w[--file --help], Gem::Command.extra_args
+
+    $; = "="
+
+    Gem::Command.extra_args = "--awesome=true --verbose"
+    assert_equal %w[--awesome=true --verbose], Gem::Command.extra_args
+
+  ensure
+    Gem::Command.extra_args = extra_args
+    $; = separator
+    $VERBOSE = verbose
+  end
+
   def test_basic_accessors
     assert_equal "doit", @cmd.command
     assert_equal "gem doit", @cmd.program_name
@@ -68,7 +86,7 @@ class TestGemCommand < Gem::TestCase
   end
 
   def test_defaults
-    @cmd.add_option('-h', '--help [COMMAND]', 'Get help on COMMAND') do |value, options|
+    @cmd.add_option("-h", "--help [COMMAND]", "Get help on COMMAND") do |value, options|
       options[:help] = value
     end
 
@@ -82,7 +100,7 @@ class TestGemCommand < Gem::TestCase
       @cmd.invoke
     end
 
-    assert_match %r|Usage: gem doit|, @ui.output
+    assert_match %r{Usage: gem doit}, @ui.output
   end
 
   def test_invoke
@@ -100,8 +118,8 @@ class TestGemCommand < Gem::TestCase
     use_ui @ui do
       @cmd.when_invoked { true }
 
-      ex = assert_raises OptionParser::InvalidOption do
-        @cmd.invoke('-zzz')
+      ex = assert_raise Gem::OptionParser::InvalidOption do
+        @cmd.invoke("-zzz")
       end
 
       assert_match(/invalid option:/, ex.message)
@@ -133,12 +151,12 @@ class TestGemCommand < Gem::TestCase
     done = false
 
     use_ui @ui do
-      @cmd.add_option('-h', '--help [COMMAND]', 'Get help on COMMAND') do |value, options|
+      @cmd.add_option("-h", "--help [COMMAND]", "Get help on COMMAND") do |value, options|
         options[:help] = true
         done = true
       end
 
-      @cmd.invoke('--help')
+      @cmd.invoke("--help")
 
       assert done
     end
@@ -156,7 +174,7 @@ class TestGemCommand < Gem::TestCase
   end
 
   def test_invoke_with_options
-    @cmd.add_option('-h', '--help [COMMAND]', 'Get help on COMMAND') do |value, options|
+    @cmd.add_option("-h", "--help [COMMAND]", "Get help on COMMAND") do |value, options|
       options[:help] = true
     end
 
@@ -165,36 +183,48 @@ class TestGemCommand < Gem::TestCase
     end
 
     use_ui @ui do
-      @cmd.invoke '-h'
+      @cmd.invoke "-h"
+    end
+
+    assert_match %r{Usage: gem doit}, @ui.output
+  end
+
+  def test_add_option
+    assert_nothing_raised RuntimeError do
+      @cmd.add_option("--force", "skip validation of the spec") {|v,o| }
     end
+  end
 
-    assert_match %r|Usage: gem doit|, @ui.output
+  def test_add_option_with_empty
+    assert_raise RuntimeError, "Do not pass an empty string in opts" do
+      @cmd.add_option("", "skip validation of the spec") {|v,o| }
+    end
   end
 
   def test_option_recognition
-    @cmd.add_option('-h', '--help [COMMAND]', 'Get help on COMMAND') do |value, options|
+    @cmd.add_option("-h", "--help [COMMAND]", "Get help on COMMAND") do |value, options|
       options[:help] = true
     end
-    @cmd.add_option('-f', '--file FILE', 'File option') do |value, options|
+    @cmd.add_option("-f", "--file FILE", "File option") do |value, options|
       options[:help] = true
     end
-    @cmd.add_option('--silent', 'Silence RubyGems output') do |value, options|
+    @cmd.add_option("--silent", "Silence RubyGems output") do |value, options|
       options[:silent] = true
     end
-    assert @cmd.handles?(['-x'])
-    assert @cmd.handles?(['-h'])
-    assert @cmd.handles?(['-h', 'command'])
-    assert @cmd.handles?(['--help', 'command'])
-    assert @cmd.handles?(['-f', 'filename'])
-    assert @cmd.handles?(['--file=filename'])
-    assert @cmd.handles?(['--silent'])
-    refute @cmd.handles?(['-z'])
-    refute @cmd.handles?(['-f'])
-    refute @cmd.handles?(['--toothpaste'])
+    assert @cmd.handles?(["-x"])
+    assert @cmd.handles?(["-h"])
+    assert @cmd.handles?(["-h", "command"])
+    assert @cmd.handles?(["--help", "command"])
+    assert @cmd.handles?(["-f", "filename"])
+    assert @cmd.handles?(["--file=filename"])
+    assert @cmd.handles?(["--silent"])
+    refute @cmd.handles?(["-z"])
+    refute @cmd.handles?(["-f"])
+    refute @cmd.handles?(["--toothpaste"])
 
-    args = ['-h', 'command']
+    args = ["-h", "command"]
     @cmd.handles?(args)
-    assert_equal ['-h', 'command'], args
+    assert_equal ["-h", "command"], args
   end
 
   def test_deprecate_option
@@ -204,13 +234,13 @@ WARNING:  The \"--test\" option has been
 
     testCommand = Class.new(Gem::Command) do
       def initialize
-        super('test', 'Gem::Command instance for testing')
+        super("test", "Gem::Command instance for testing")
 
-        add_option('-t', '--test', 'Test command') do |value, options|
+        add_option("-t", "--test", "Test command") do |value, options|
           options[:test] = true
         end
 
-        deprecate_option('--test', version: '3.1')
+        deprecate_option("--test", version: "3.1")
       end
 
       def execute
@@ -233,13 +263,13 @@ WARNING:  The \"--test\" option has been
 
     testCommand = Class.new(Gem::Command) do
       def initialize
-        super('test', 'Gem::Command instance for testing')
+        super("test", "Gem::Command instance for testing")
 
-        add_option('-t', '--test', 'Test command') do |value, options|
+        add_option("-t", "--test", "Test command") do |value, options|
           options[:test] = true
         end
 
-        deprecate_option('--test')
+        deprecate_option("--test")
       end
 
       def execute
@@ -262,13 +292,13 @@ WARNING:  The \"--test\" option has been
 
     testCommand = Class.new(Gem::Command) do
       def initialize
-        super('test', 'Gem::Command instance for testing')
+        super("test", "Gem::Command instance for testing")
 
-        add_option('-t', '--test', 'Test command') do |value, options|
+        add_option("-t", "--test", "Test command") do |value, options|
           options[:test] = true
         end
 
-        deprecate_option('--test', version: '3.1', extra_msg: 'Whether you set `--test` mode or not, this dummy app always runs in test mode.')
+        deprecate_option("--test", version: "3.1", extra_msg: "Whether you set `--test` mode or not, this dummy app always runs in test mode.")
       end
 
       def execute
@@ -291,13 +321,13 @@ WARNING:  The \"--test\" option has been
 
     testCommand = Class.new(Gem::Command) do
       def initialize
-        super('test', 'Gem::Command instance for testing')
+        super("test", "Gem::Command instance for testing")
 
-        add_option('-t', '--test', 'Test command') do |value, options|
+        add_option("-t", "--test", "Test command") do |value, options|
           options[:test] = true
         end
 
-        deprecate_option('--test', extra_msg: 'Whether you set `--test` mode or not, this dummy app always runs in test mode.')
+        deprecate_option("--test", extra_msg: "Whether you set `--test` mode or not, this dummy app always runs in test mode.")
       end
 
       def execute
@@ -334,11 +364,11 @@ ERROR:  Could not find a valid gem 'none
 
   def test_show_lookup_failure_suggestions_none
     spec_fetcher do |fetcher|
-      fetcher.spec 'correct', 2
+      fetcher.spec "correct", 2
     end
 
     use_ui @ui do
-      @cmd.show_lookup_failure 'other', Gem::Requirement.default, [], :remote
+      @cmd.show_lookup_failure "other", Gem::Requirement.default, [], :remote
     end
 
     expected = <<-EXPECTED
@@ -367,5 +397,4 @@ ERROR:  Possible alternatives: non_exist
 
     assert_equal expected, @ui.error
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_command_manager.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_command_manager.rb
@@ -1,10 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/command_manager'
+require_relative "helper"
+require "rubygems/command_manager"
 
 class TestGemCommandManager < Gem::TestCase
-
-  PROJECT_DIR = File.expand_path('../../..', __FILE__).tap(&Gem::UNTAINT)
+  PROJECT_DIR = File.expand_path("../..", __dir__).tap(&Gem::UNTAINT)
 
   def setup
     super
@@ -13,37 +12,49 @@ class TestGemCommandManager < Gem::TestC
   end
 
   def test_find_command
-    command = @command_manager.find_command 'install'
+    command = @command_manager.find_command "install"
 
     assert_kind_of Gem::Commands::InstallCommand, command
 
-    command = @command_manager.find_command 'ins'
+    command = @command_manager.find_command "ins"
 
     assert_kind_of Gem::Commands::InstallCommand, command
   end
 
   def test_find_command_ambiguous
-    e = assert_raises Gem::CommandLineError do
-      @command_manager.find_command 'u'
+    e = assert_raise Gem::CommandLineError do
+      @command_manager.find_command "u"
     end
 
-    assert_equal 'Ambiguous command u matches [uninstall, unpack, update]',
+    assert_equal "Ambiguous command u matches [uninstall, unpack, update]",
                  e.message
   end
 
   def test_find_alias_command
-    command = @command_manager.find_command 'i'
+    command = @command_manager.find_command "i"
 
     assert_kind_of Gem::Commands::InstallCommand, command
   end
 
+  def test_find_login_alias_command
+    command = @command_manager.find_command "login"
+
+    assert_kind_of Gem::Commands::SigninCommand, command
+  end
+
+  def test_find_logout_alias_comamnd
+    command = @command_manager.find_command "logout"
+
+    assert_kind_of Gem::Commands::SignoutCommand, command
+  end
+
   def test_find_command_ambiguous_exact
     ins_command = Class.new
     Gem::Commands.send :const_set, :InsCommand, ins_command
 
     @command_manager.register_command :ins
 
-    command = @command_manager.find_command 'ins'
+    command = @command_manager.find_command "ins"
 
     assert_kind_of ins_command, command
   ensure
@@ -51,11 +62,31 @@ class TestGemCommandManager < Gem::TestC
   end
 
   def test_find_command_unknown
-    e = assert_raises Gem::CommandLineError do
-      @command_manager.find_command 'xyz'
+    e = assert_raise Gem::UnknownCommandError do
+      @command_manager.find_command "xyz"
+    end
+
+    assert_equal "Unknown command xyz", e.message
+  end
+
+  def test_find_command_unknown_suggestions
+    e = assert_raise Gem::UnknownCommandError do
+      @command_manager.find_command "pish"
+    end
+
+    message = "Unknown command pish".dup
+
+    if RUBY_VERSION >= "2.4" && defined?(DidYouMean::SPELL_CHECKERS) && defined?(DidYouMean::Correctable)
+      message << "\nDid you mean?  \"push\""
+    end
+
+    if e.respond_to?(:detailed_message)
+      actual_message = e.detailed_message(highlight: false).sub(/\A(.*?)(?: \(.+?\))/) { $1 }
+    else
+      actual_message = e.message
     end
 
-    assert_equal 'Unknown command xyz', e.message
+    assert_equal message, actual_message
   end
 
   def test_run_interrupt
@@ -66,10 +97,10 @@ class TestGemCommandManager < Gem::TestC
     @command_manager.register_command :interrupt
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @command_manager.run %w[interrupt]
       end
-      assert_equal '', ui.output
+      assert_equal "", ui.output
       assert_equal "ERROR:  Interrupted\n", ui.error
     end
   ensure
@@ -83,10 +114,10 @@ class TestGemCommandManager < Gem::TestC
 
     @command_manager.register_command :crash
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @command_manager.run %w[crash]
       end
-      assert_equal '', ui.output
+      assert_equal "", ui.output
       err = ui.error.split("\n").first
       assert_equal "ERROR:  Loading command: crash (RuntimeError)", err
     end
@@ -97,7 +128,7 @@ class TestGemCommandManager < Gem::TestC
 
   def test_process_args_bad_arg
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @command_manager.process_args %w[--bad-arg]
       end
     end
@@ -110,7 +141,7 @@ class TestGemCommandManager < Gem::TestC
     #capture all install options
     use_ui @ui do
       check_options = nil
-      @command_manager['install'].when_invoked do |options|
+      @command_manager["install"].when_invoked do |options|
         check_options = options
         true
       end
@@ -135,7 +166,7 @@ class TestGemCommandManager < Gem::TestC
       assert_equal true, check_options[:force]
       assert_equal :local, check_options[:domain]
       assert_equal false, check_options[:wrappers]
-      assert_equal Gem::Requirement.new('3.0'), check_options[:version]
+      assert_equal Gem::Requirement.new("3.0"), check_options[:version]
       assert_equal Dir.pwd, check_options[:install_dir]
       assert_equal Dir.pwd, check_options[:bin_dir]
 
@@ -160,7 +191,7 @@ class TestGemCommandManager < Gem::TestC
   def test_process_args_uninstall
     #capture all uninstall options
     check_options = nil
-    @command_manager['uninstall'].when_invoked do |options|
+    @command_manager["uninstall"].when_invoked do |options|
       check_options = options
       true
     end
@@ -173,14 +204,14 @@ class TestGemCommandManager < Gem::TestC
     check_options = nil
     @command_manager.process_args %w[uninstall foobar --version 3.0]
     assert_equal "foobar", check_options[:args].first
-    assert_equal Gem::Requirement.new('3.0'), check_options[:version]
+    assert_equal Gem::Requirement.new("3.0"), check_options[:version]
   end
 
   # HACK move to check command test
   def test_process_args_check
     #capture all check options
     check_options = nil
-    @command_manager['check'].when_invoked do |options|
+    @command_manager["check"].when_invoked do |options|
       check_options = options
       true
     end
@@ -199,7 +230,7 @@ class TestGemCommandManager < Gem::TestC
   def test_process_args_build
     #capture all build options
     check_options = nil
-    @command_manager['build'].when_invoked do |options|
+    @command_manager["build"].when_invoked do |options|
       check_options = options
       true
     end
@@ -211,39 +242,47 @@ class TestGemCommandManager < Gem::TestC
     #check settings
     check_options = nil
     @command_manager.process_args %w[build foobar.rb]
-    assert_equal 'foobar.rb', check_options[:args].first
+    assert_equal "foobar.rb", check_options[:args].first
   end
 
   # HACK move to query command test
   def test_process_args_query
     #capture all query options
     check_options = nil
-    @command_manager['query'].when_invoked do |options|
+    @command_manager["query"].when_invoked do |options|
       check_options = options
       true
     end
 
     #check defaults
-    @command_manager.process_args %w[query]
-    assert_equal(//, check_options[:name])
+    Gem::Deprecate.skip_during do
+      @command_manager.process_args %w[query]
+    end
+    assert_nil(check_options[:name])
     assert_equal :local, check_options[:domain]
     assert_equal false, check_options[:details]
 
     #check settings
     check_options = nil
-    @command_manager.process_args %w[query --name foobar --local --details]
+    Gem::Deprecate.skip_during do
+      @command_manager.process_args %w[query --name foobar --local --details]
+    end
     assert_equal(/foobar/i, check_options[:name])
     assert_equal :local, check_options[:domain]
     assert_equal true, check_options[:details]
 
     #remote domain
     check_options = nil
-    @command_manager.process_args %w[query --remote]
+    Gem::Deprecate.skip_during do
+      @command_manager.process_args %w[query --remote]
+    end
     assert_equal :remote, check_options[:domain]
 
     #both (local/remote) domains
     check_options = nil
-    @command_manager.process_args %w[query --both]
+    Gem::Deprecate.skip_during do
+      @command_manager.process_args %w[query --both]
+    end
     assert_equal :both, check_options[:domain]
   end
 
@@ -251,21 +290,45 @@ class TestGemCommandManager < Gem::TestC
   def test_process_args_update
     #capture all update options
     check_options = nil
-    @command_manager['update'].when_invoked do |options|
+    @command_manager["update"].when_invoked do |options|
       check_options = options
       true
     end
 
     #check defaults
     @command_manager.process_args %w[update]
-    assert_includes check_options[:document], 'rdoc'
+    assert_includes check_options[:document], "ri"
 
     #check settings
     check_options = nil
     @command_manager.process_args %w[update --force --document=ri --install-dir .]
-    assert_includes check_options[:document], 'ri'
+    assert_includes check_options[:document], "ri"
     assert_equal true, check_options[:force]
     assert_equal Dir.pwd, check_options[:install_dir]
   end
 
+  def test_deprecated_command
+    require "rubygems/command"
+    foo_command = Class.new(Gem::Command) do
+      extend Gem::Deprecate
+
+      rubygems_deprecate_command
+
+      def execute
+        say "pew pew!"
+      end
+    end
+
+    Gem::Commands.send(:const_set, :FooCommand, foo_command)
+    @command_manager.register_command(:foo, foo_command.new("foo"))
+
+    use_ui @ui do
+      @command_manager.process_args(%w[foo])
+    end
+
+    assert_equal "pew pew!\n", @ui.output
+    assert_match(/WARNING:  foo command is deprecated. It will be removed in Rubygems [0-9]+/, @ui.error)
+  ensure
+    Gem::Commands.send(:remove_const, :FooCommand)
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_build_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_build_command.rb
@@ -1,29 +1,32 @@
-
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/build_command'
-require 'rubygems/package'
+require_relative "helper"
+require "rubygems/commands/build_command"
+require "rubygems/package"
 
 class TestGemCommandsBuildCommand < Gem::TestCase
+  CERT_FILE = cert_path "public3072"
+  SIGNING_KEY = key_path "private3072"
 
-  CERT_FILE = cert_path 'public3072'
-  SIGNING_KEY = key_path 'private3072'
-
-  EXPIRED_CERT_FILE = cert_path 'expired'
-  PRIVATE_KEY_FILE  = key_path 'private'
+  EXPIRED_CERT_FILE = cert_path "expired"
+  PRIVATE_KEY_FILE  = key_path "private"
 
   def setup
     super
 
-    readme_file = File.join(@tempdir, 'README.md')
+    readme_file = File.join(@tempdir, "README.md")
 
-    File.open readme_file, 'w' do |f|
-      f.write 'My awesome gem'
+    begin
+      umask_orig = File.umask(2)
+      File.open readme_file, "w" do |f|
+        f.write "My awesome gem"
+      end
+    ensure
+      File.umask(umask_orig)
     end
 
-    @gem = util_spec 'some_gem' do |s|
-      s.license = 'AGPL-3.0'
-      s.files = ['README.md']
+    @gem = util_spec "some_gem" do |s|
+      s.license = "AGPL-3.0"
+      s.files = ["README.md"]
     end
 
     @cmd = Gem::Commands::BuildCommand.new
@@ -34,12 +37,14 @@ class TestGemCommandsBuildCommand < Gem:
 
     assert @cmd.options[:force]
     assert @cmd.options[:strict]
+    assert @cmd.handles?(%W[--platform #{Gem::Platform.local}])
+    assert_includes Gem.platforms, Gem::Platform.local
   end
 
   def test_options_filename
     gemspec_file = File.join(@tempdir, @gem.spec_name)
 
-    File.open gemspec_file, 'w' do |gs|
+    File.open gemspec_file, "w" do |gs|
       gs.write @gem.to_ruby
     end
 
@@ -74,7 +79,7 @@ class TestGemCommandsBuildCommand < Gem:
   def test_execute
     gemspec_file = File.join(@tempdir, @gem.spec_name)
 
-    File.open gemspec_file, 'w' do |gs|
+    File.open gemspec_file, "w" do |gs|
       gs.write @gem.to_ruby
     end
 
@@ -83,17 +88,37 @@ class TestGemCommandsBuildCommand < Gem:
     util_test_build_gem @gem
   end
 
+  def test_execute_platform
+    gemspec_file = File.join(@tempdir, @gem.spec_name)
+
+    File.open gemspec_file, "w" do |gs|
+      gs.write @gem.to_ruby
+    end
+
+    @cmd.options[:args] = [gemspec_file]
+
+    platforms = Gem.platforms.dup
+    begin
+      Gem.platforms << Gem::Platform.new("java")
+
+      spec = util_test_build_gem @gem, suffix: "java"
+    ensure
+      Gem.platforms.replace(platforms)
+    end
+    assert_match spec.platform, "java"
+  end
+
   def test_execute_bad_name
     [".", "-", "_"].each do |special_char|
-      gem = util_spec 'some_gem_with_bad_name' do |s|
+      gem = util_spec "some_gem_with_bad_name" do |s|
         s.name = "#{special_char}bad_gem_name"
-        s.license = 'AGPL-3.0'
-        s.files = ['README.md']
+        s.license = "AGPL-3.0"
+        s.files = ["README.md"]
       end
 
       gemspec_file = File.join(@tempdir, gem.spec_name)
 
-      File.open gemspec_file, 'w' do |gs|
+      File.open gemspec_file, "w" do |gs|
         gs.write gem.to_ruby
       end
 
@@ -101,7 +126,7 @@ class TestGemCommandsBuildCommand < Gem:
 
       use_ui @ui do
         Dir.chdir @tempdir do
-          assert_raises Gem::InvalidSpecificationException do
+          assert_raise Gem::InvalidSpecificationException do
             @cmd.execute
           end
         end
@@ -112,7 +137,7 @@ class TestGemCommandsBuildCommand < Gem:
   def test_execute_strict_without_warnings
     gemspec_file = File.join(@tempdir, @gem.spec_name)
 
-    File.open gemspec_file, 'w' do |gs|
+    File.open gemspec_file, "w" do |gs|
       gs.write @gem.to_ruby
     end
 
@@ -140,13 +165,13 @@ class TestGemCommandsBuildCommand < Gem:
   end
 
   def test_execute_strict_with_warnings
-    bad_gem = util_spec 'some_bad_gem' do |s|
-      s.files = ['README.md']
+    bad_gem = util_spec "some_bad_gem" do |s|
+      s.files = ["README.md"]
     end
 
     gemspec_file = File.join(@tempdir, bad_gem.spec_name)
 
-    File.open gemspec_file, 'w' do |gs|
+    File.open gemspec_file, "w" do |gs|
       gs.write bad_gem.to_ruby
     end
 
@@ -155,7 +180,7 @@ class TestGemCommandsBuildCommand < Gem:
 
     use_ui @ui do
       Dir.chdir @tempdir do
-        assert_raises Gem::InvalidSpecificationException do
+        assert_raise Gem::InvalidSpecificationException do
           @cmd.execute
         end
       end
@@ -176,15 +201,15 @@ class TestGemCommandsBuildCommand < Gem:
 
     gemspec_file = File.join(@tempdir, @gem.spec_name)
 
-    File.open gemspec_file, 'w' do |gs|
+    File.open gemspec_file, "w" do |gs|
       gs.write @gem.to_ruby.sub(/11-08/, "11-8")
     end
 
     @cmd.options[:args] = [gemspec_file]
 
     out, err = use_ui @ui do
-      capture_io do
-        assert_raises Gem::MockGemUi::TermError do
+      capture_output do
+        assert_raise Gem::MockGemUi::TermError do
           @cmd.execute
         end
       end
@@ -193,34 +218,34 @@ class TestGemCommandsBuildCommand < Gem:
     assert_equal "", out
     assert_match(/invalid date format in specification/, err)
 
-    assert_equal '', @ui.output
+    assert_equal "", @ui.output
     assert_equal "ERROR:  Error loading gemspec. Aborting.\n", @ui.error
   end
 
   def test_execute_missing_file
     @cmd.options[:args] = %w[some_gem]
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
 
-    assert_equal '', @ui.output
-    assert_equal "ERROR:  Gemspec file not found: some_gem.gemspec\n", @ui.error
+    assert_equal "", @ui.output
+    assert_equal "ERROR:  Couldn't find a gemspec file matching 'some_gem' in #{@tempdir}\n", @ui.error
   end
 
   def test_execute_outside_dir
-    gemspec_dir = File.join @tempdir, 'build_command_gem'
+    gemspec_dir = File.join @tempdir, "build_command_gem"
     gemspec_file = File.join gemspec_dir, @gem.spec_name
-    readme_file = File.join gemspec_dir, 'README.md'
+    readme_file = File.join gemspec_dir, "README.md"
 
     FileUtils.mkdir_p gemspec_dir
 
-    File.open readme_file, 'w' do |f|
+    File.open readme_file, "w" do |f|
       f.write "My awesome gem"
     end
 
-    File.open gemspec_file, 'w' do |gs|
+    File.open gemspec_file, "w" do |gs|
       gs.write @gem.to_ruby
     end
 
@@ -247,10 +272,202 @@ class TestGemCommandsBuildCommand < Gem:
     assert_equal "this is a summary", spec.summary
   end
 
+  def test_execute_outside_dir_with_glob_argument
+    gemspec_dir = File.join @tempdir, "build_command_gem"
+    gemspec_file = File.join gemspec_dir, @gem.spec_name
+    readme_file = File.join gemspec_dir, "README.md"
+
+    FileUtils.mkdir_p gemspec_dir
+
+    File.open readme_file, "w" do |f|
+      f.write "My awesome gem"
+    end
+
+    File.open gemspec_file, "w" do |gs|
+      gs.write @gem.to_ruby
+    end
+
+    @cmd.options[:build_path] = gemspec_dir
+    @cmd.options[:args] = ["*.gemspec"]
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    output = @ui.output.split "\n"
+    assert_equal "  Successfully built RubyGem", output.shift
+    assert_equal "  Name: some_gem", output.shift
+    assert_equal "  Version: 2", output.shift
+    assert_equal "  File: some_gem-2.gem", output.shift
+    assert_equal [], output
+
+    gem_file = File.join gemspec_dir, File.basename(@gem.cache_file)
+    assert File.exist?(gem_file)
+
+    spec = Gem::Package.new(gem_file).spec
+
+    assert_equal "some_gem", spec.name
+    assert_equal "this is a summary", spec.summary
+  end
+
+  def test_execute_outside_dir_no_gemspec_present
+    gemspec_dir = File.join @tempdir, "build_command_gem"
+    gemspec_file = File.join @tempdir, @gem.spec_name
+    readme_file = File.join gemspec_dir, "README.md"
+
+    FileUtils.mkdir_p gemspec_dir
+
+    File.open readme_file, "w" do |f|
+      f.write "My awesome gem"
+    end
+
+    File.open gemspec_file, "w" do |gs|
+      gs.write @gem.to_ruby
+    end
+
+    @cmd.options[:build_path] = gemspec_dir
+    @cmd.options[:args] = ["*.gemspec"]
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::TermError do
+        @cmd.execute
+      end
+    end
+
+    assert_equal "", @ui.output
+    assert_equal "ERROR:  Couldn't find a gemspec file matching '*.gemspec' in #{gemspec_dir}\n", @ui.error
+
+    gem_file = File.join gemspec_dir, File.basename(@gem.cache_file)
+    refute File.exist?(gem_file)
+  end
+
+  def test_execute_outside_dir_without_gem_name
+    gemspec_dir = File.join(@tempdir, "build_command_gem")
+    gemspec_file = File.join(gemspec_dir, @gem.spec_name)
+
+    readme_file = File.join gemspec_dir, "README.md"
+
+    FileUtils.mkdir_p(gemspec_dir)
+
+    File.open readme_file, "w" do |f|
+      f.write "My awesome gem"
+    end
+
+    File.open(gemspec_file, "w") do |gs|
+      gs.write(@gem.to_ruby)
+    end
+
+    @cmd.options[:build_path] = gemspec_dir
+    @cmd.options[:args] = []
+
+    use_ui @ui do
+      Dir.chdir(gemspec_dir) do
+        @cmd.execute
+      end
+    end
+
+    output = @ui.output.split("\n")
+    assert_equal "  Successfully built RubyGem", output.shift
+    assert_equal "  Name: some_gem", output.shift
+    assert_equal "  Version: 2", output.shift
+    assert_equal "  File: some_gem-2.gem", output.shift
+    assert_equal [], output
+
+    gem_file = File.join gemspec_dir, File.basename(@gem.cache_file)
+    assert File.exist?(gem_file)
+
+    spec = Gem::Package.new(gem_file).spec
+
+    assert_equal "some_gem", spec.name
+    assert_equal "this is a summary", spec.summary
+  end
+
+  def test_execute_outside_dir_with_external_gemspec
+    gemspec_dir = File.join @tempdir, "gemspec_dir"
+    gemspec_file = File.join gemspec_dir, @gem.spec_name
+
+    gemcode_dir = File.join @tempdir, "build_command_gem"
+    readme_file = File.join gemcode_dir, "README.md"
+
+    FileUtils.mkdir_p gemspec_dir
+    FileUtils.mkdir_p gemcode_dir
+
+    File.open readme_file, "w" do |f|
+      f.write "My awesome gem in nested directory"
+    end
+
+    File.open gemspec_file, "w" do |gs|
+      gs.write @gem.to_ruby
+    end
+
+    @cmd.options[:build_path] = gemcode_dir
+    @cmd.options[:args] = [gemspec_file]
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    output = @ui.output.split "\n"
+    assert_equal "  Successfully built RubyGem", output.shift
+    assert_equal "  Name: some_gem", output.shift
+    assert_equal "  Version: 2", output.shift
+    assert_equal "  File: some_gem-2.gem", output.shift
+    assert_equal [], output
+
+    gem_file = File.join gemcode_dir, File.basename(@gem.cache_file)
+    assert File.exist?(gem_file)
+
+    spec = Gem::Package.new(gem_file).spec
+
+    assert_equal "some_gem", spec.name
+    assert_equal "this is a summary", spec.summary
+  end
+
+  def test_execute_outside_dir_with_external_relative_gemspec
+    gemspec_dir = File.join @tempdir, "gemspec_dir"
+    gemspec_file = File.join gemspec_dir, @gem.spec_name
+
+    gemcode_dir = File.join @tempdir, "build_command_gem"
+    readme_file = File.join gemcode_dir, "README.md"
+
+    FileUtils.mkdir_p gemspec_dir
+    FileUtils.mkdir_p gemcode_dir
+
+    File.open readme_file, "w" do |f|
+      f.write "My awesome gem in nested directory"
+    end
+
+    File.open gemspec_file, "w" do |gs|
+      gs.write @gem.to_ruby
+    end
+
+    @cmd.options[:build_path] = gemcode_dir
+    @cmd.options[:args] = [File.join("..", "gemspec_dir", @gem.spec_name)]
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    output = @ui.output.split "\n"
+    assert_equal "  Successfully built RubyGem", output.shift
+    assert_equal "  Name: some_gem", output.shift
+    assert_equal "  Version: 2", output.shift
+    assert_equal "  File: some_gem-2.gem", output.shift
+    assert_equal [], output
+
+    gem_file = File.join gemcode_dir, File.basename(@gem.cache_file)
+    assert File.exist?(gem_file)
+
+    spec = Gem::Package.new(gem_file).spec
+
+    assert_equal "some_gem", spec.name
+    assert_equal "this is a summary", spec.summary
+  end
+
   def test_can_find_gemspecs_without_dot_gemspec
-    gemspec_file = File.join(@tempdir, @gem.spec_name)
+    gemspec_file = File.join(@tempdir, @gem.name)
 
-    File.open gemspec_file + ".gemspec", 'w' do |gs|
+    File.open gemspec_file + ".gemspec", "w" do |gs|
       gs.write @gem.to_ruby
     end
 
@@ -310,7 +527,7 @@ class TestGemCommandsBuildCommand < Gem:
 
     use_ui @ui do
       Dir.chdir(gemspec_dir) do
-        assert_raises Gem::MockGemUi::TermError do
+        assert_raise Gem::MockGemUi::TermError do
           @cmd.execute
         end
       end
@@ -324,27 +541,29 @@ class TestGemCommandsBuildCommand < Gem:
     refute File.exist?(expected_gem)
   end
 
-  def util_test_build_gem(gem)
+  def util_test_build_gem(gem, suffix: nil)
     use_ui @ui do
       Dir.chdir @tempdir do
         @cmd.execute
       end
     end
-
+    suffix &&= "-#{suffix}"
+    gem_file = "some_gem-2#{suffix}.gem"
     output = @ui.output.split "\n"
     assert_equal "  Successfully built RubyGem", output.shift
     assert_equal "  Name: some_gem", output.shift
     assert_equal "  Version: 2", output.shift
-    assert_equal "  File: some_gem-2.gem", output.shift
+    assert_equal "  File: #{gem_file}", output.shift
     assert_equal [], output
 
-    gem_file = File.join(@tempdir, File.basename(gem.cache_file))
+    gem_file = File.join(@tempdir, gem_file)
     assert File.exist?(gem_file)
 
     spec = Gem::Package.new(gem_file).spec
 
     assert_equal "some_gem", spec.name
     assert_equal "this is a summary", spec.summary
+    spec
   end
 
   def test_execute_force
@@ -352,7 +571,7 @@ class TestGemCommandsBuildCommand < Gem:
 
     @gem.send :remove_instance_variable, :@rubygems_version
 
-    File.open gemspec_file, 'w' do |gs|
+    File.open gemspec_file, "w" do |gs|
       gs.write @gem.to_ruby
     end
 
@@ -363,18 +582,18 @@ class TestGemCommandsBuildCommand < Gem:
   end
 
   def test_build_signed_gem
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL) && !java_platform?
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL && !java_platform?
 
     trust_dir = Gem::Security.trust_dir
 
-    spec = util_spec 'some_gem' do |s|
+    spec = util_spec "some_gem" do |s|
       s.signing_key = SIGNING_KEY
       s.cert_chain = [CERT_FILE]
     end
 
     gemspec_file = File.join(@tempdir, spec.spec_name)
 
-    File.open gemspec_file, 'w' do |gs|
+    File.open gemspec_file, "w" do |gs|
       gs.write spec.to_ruby
     end
 
@@ -390,7 +609,7 @@ class TestGemCommandsBuildCommand < Gem:
   end
 
   def test_build_signed_gem_with_cert_expiration_length_days
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL) && !java_platform?
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL && !java_platform?
 
     gem_path = File.join Gem.user_home, ".gem"
     Dir.mkdir gem_path
@@ -403,14 +622,14 @@ class TestGemCommandsBuildCommand < Gem:
     tmp_private_key_file = File.join gem_path, "gem-private_key.pem"
     File.write(tmp_private_key_file, File.read(PRIVATE_KEY_FILE))
 
-    spec = util_spec 'some_gem' do |s|
+    spec = util_spec "some_gem" do |s|
       s.signing_key = tmp_private_key_file
       s.cert_chain  = [tmp_expired_cert_file]
     end
 
     gemspec_file = File.join(@tempdir, spec.spec_name)
 
-    File.open gemspec_file, 'w' do |gs|
+    File.open gemspec_file, "w" do |gs|
       gs.write spec.to_ruby
     end
 
@@ -434,7 +653,7 @@ class TestGemCommandsBuildCommand < Gem:
   end
 
   def test_build_auto_resign_cert
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL) && !java_platform?
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL && !java_platform?
 
     gem_path = File.join Gem.user_home, ".gem"
     Dir.mkdir gem_path
@@ -447,14 +666,14 @@ class TestGemCommandsBuildCommand < Gem:
     tmp_private_key_file = File.join gem_path, "gem-private_key.pem"
     File.write(tmp_private_key_file, File.read(PRIVATE_KEY_FILE))
 
-    spec = util_spec 'some_gem' do |s|
+    spec = util_spec "some_gem" do |s|
       s.signing_key = tmp_private_key_file
       s.cert_chain  = [tmp_expired_cert_file]
     end
 
     gemspec_file = File.join(@tempdir, spec.spec_name)
 
-    File.open gemspec_file, 'w' do |gs|
+    File.open gemspec_file, "w" do |gs|
       gs.write spec.to_ruby
     end
 
@@ -505,5 +724,4 @@ class TestGemCommandsBuildCommand < Gem:
   ensure
     ENV["SOURCE_DATE_EPOCH"] = epoch
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_cert_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_cert_command.rb
@@ -1,28 +1,28 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/cert_command'
+require_relative "helper"
+require "rubygems/commands/cert_command"
 
-unless defined?(OpenSSL::SSL)
-  warn 'Skipping `gem cert` tests.  openssl not found.'
+unless Gem::HAVE_OPENSSL
+  warn "Skipping `gem cert` tests.  openssl not found."
 end
 
 if Gem.java_platform?
-  warn 'Skipping `gem cert` tests on jruby.'
+  warn "Skipping `gem cert` tests on jruby."
 end
 
 class TestGemCommandsCertCommand < Gem::TestCase
+  ALTERNATE_CERT = load_cert "alternate"
+  EXPIRED_PUBLIC_CERT = load_cert "expired"
 
-  ALTERNATE_CERT = load_cert 'alternate'
-  EXPIRED_PUBLIC_CERT = load_cert 'expired'
-
-  ALTERNATE_KEY_FILE = key_path 'alternate'
-  PRIVATE_KEY_FILE   = key_path 'private'
-  PUBLIC_KEY_FILE    = key_path 'public'
-
-  ALTERNATE_CERT_FILE      = cert_path 'alternate'
-  CHILD_CERT_FILE          = cert_path 'child'
-  PUBLIC_CERT_FILE         = cert_path 'public'
-  EXPIRED_PUBLIC_CERT_FILE = cert_path 'expired'
+  ALTERNATE_KEY_FILE  = key_path "alternate"
+  PRIVATE_KEY_FILE    = key_path "private"
+  PRIVATE_EC_KEY_FILE = key_path "private_ec"
+  PUBLIC_KEY_FILE     = key_path "public"
+
+  ALTERNATE_CERT_FILE      = cert_path "alternate"
+  CHILD_CERT_FILE          = cert_path "child"
+  PUBLIC_CERT_FILE         = cert_path "public"
+  EXPIRED_PUBLIC_CERT_FILE = cert_path "expired"
 
   def setup
     super
@@ -44,7 +44,7 @@ class TestGemCommandsCertCommand < Gem::
     @trust_dir.trust_cert PUBLIC_CERT
     @trust_dir.trust_cert ALTERNATE_CERT
 
-    matches = @cmd.certificates_matching ''
+    matches = @cmd.certificates_matching ""
 
     # HACK OpenSSL::X509::Certificate#== is Object#==, so do this the hard way
     match = matches.next
@@ -55,7 +55,7 @@ class TestGemCommandsCertCommand < Gem::
     assert_equal PUBLIC_CERT.to_pem, match.first.to_pem
     assert_equal @trust_dir.cert_path(PUBLIC_CERT), match.last
 
-    assert_raises StopIteration do
+    assert_raise StopIteration do
       matches.next
     end
   end
@@ -64,13 +64,13 @@ class TestGemCommandsCertCommand < Gem::
     @trust_dir.trust_cert PUBLIC_CERT
     @trust_dir.trust_cert ALTERNATE_CERT
 
-    matches = @cmd.certificates_matching 'alternate'
+    matches = @cmd.certificates_matching "alternate"
 
     match = matches.next
     assert_equal ALTERNATE_CERT.to_pem, match.first.to_pem
     assert_equal @trust_dir.cert_path(ALTERNATE_CERT), match.last
 
-    assert_raises StopIteration do
+    assert_raise StopIteration do
       matches.next
     end
   end
@@ -84,14 +84,14 @@ class TestGemCommandsCertCommand < Gem::
 
     cert_path = @trust_dir.cert_path PUBLIC_CERT
 
-    assert_path_exists cert_path
+    assert_path_exist cert_path
 
     assert_equal "Added '/CN=nobody/DC=example'\n", @ui.output
     assert_empty @ui.error
   end
 
   def test_execute_add_twice
-    self.class.cert_path 'alternate'
+    self.class.cert_path "alternate"
 
     @cmd.handle_options %W[
       --add #{PUBLIC_CERT_FILE}
@@ -112,7 +112,7 @@ Added '/CN=alternate/DC=example'
   end
 
   def test_execute_build
-    passphrase = 'Foo bar'
+    passphrase = "Foo bar"
 
     @cmd.handle_options %W[--build nobody@example.com]
 
@@ -139,12 +139,48 @@ Added '/CN=alternate/DC=example'
     assert_empty output
     assert_empty @build_ui.error
 
-    assert_path_exists File.join(@tempdir, 'gem-private_key.pem')
-    assert_path_exists File.join(@tempdir, 'gem-public_cert.pem')
+    assert_path_exist File.join(@tempdir, "gem-private_key.pem")
+    assert_path_exist File.join(@tempdir, "gem-public_cert.pem")
+  end
+
+  def test_execute_build_key_algorithm_ec_key
+    passphrase = "Foo bar"
+
+    @cmd.handle_options %W[--build nobody@example.com --key-algorithm ec]
+
+    @build_ui = Gem::MockGemUi.new "#{passphrase}\n#{passphrase}"
+
+    use_ui @build_ui do
+      @cmd.execute
+    end
+
+    output = @build_ui.output.squeeze("\n").split "\n"
+
+    assert_equal "Passphrase for your Private Key:  ",
+                 output.shift
+    assert_equal "Please repeat the passphrase for your Private Key:  ",
+                 output.shift
+    assert_equal "Certificate: #{File.join @tempdir, 'gem-public_cert.pem'}",
+                 output.shift
+    assert_equal "Private Key: #{File.join @tempdir, 'gem-private_key.pem'}",
+                 output.shift
+
+    assert_equal "Don't forget to move the key file to somewhere private!",
+                 output.shift
+
+    assert_empty output
+    assert_empty @build_ui.error
+
+    assert_path_exist File.join(@tempdir, "gem-private_key.pem")
+
+    cert_path = File.join(@tempdir, "gem-public_cert.pem")
+    assert_path_exist cert_path
+    cert = OpenSSL::X509::Certificate.new(File.read(cert_path))
+    assert cert.public_key.is_a? OpenSSL::PKey::EC
   end
 
   def test_execute_build_bad_email_address
-    passphrase = 'Foo bar'
+    passphrase = "Foo bar"
     email = "nobody@"
 
     @cmd.handle_options %W[--build #{email}]
@@ -152,21 +188,20 @@ Added '/CN=alternate/DC=example'
     @build_ui = Gem::MockGemUi.new "#{passphrase}\n#{passphrase}"
 
     use_ui @build_ui do
-
-      e = assert_raises Gem::CommandLineError do
+      e = assert_raise Gem::CommandLineError do
         @cmd.execute
       end
 
       assert_equal "Invalid email address #{email}",
         e.message
 
-      refute_path_exists File.join(@tempdir, 'gem-private_key.pem')
-      refute_path_exists File.join(@tempdir, 'gem-public_cert.pem')
+      assert_path_not_exist File.join(@tempdir, "gem-private_key.pem")
+      assert_path_not_exist File.join(@tempdir, "gem-public_cert.pem")
     end
   end
 
   def test_execute_build_expiration_days
-    passphrase = 'Foo bar'
+    passphrase = "Foo bar"
 
     @cmd.handle_options %W[
       --build nobody@example.com
@@ -196,8 +231,8 @@ Added '/CN=alternate/DC=example'
     assert_empty output
     assert_empty @build_ui.error
 
-    assert_path_exists File.join(@tempdir, 'gem-private_key.pem')
-    assert_path_exists File.join(@tempdir, 'gem-public_cert.pem')
+    assert_path_exist File.join(@tempdir, "gem-private_key.pem")
+    assert_path_exist File.join(@tempdir, "gem-public_cert.pem")
 
     pem = File.read("#{@tempdir}/gem-public_cert.pem")
     cert = OpenSSL::X509::Certificate.new(pem)
@@ -207,15 +242,15 @@ Added '/CN=alternate/DC=example'
   end
 
   def test_execute_build_bad_passphrase_confirmation
-    passphrase = 'Foo bar'
-    passphrase_confirmation = 'Fu bar'
+    passphrase = "Foo bar"
+    passphrase_confirmation = "Fu bar"
 
     @cmd.handle_options %W[--build nobody@example.com]
 
     @build_ui = Gem::MockGemUi.new "#{passphrase}\n#{passphrase_confirmation}"
 
     use_ui @build_ui do
-      e = assert_raises Gem::CommandLineError do
+      e = assert_raise Gem::CommandLineError do
         @cmd.execute
       end
 
@@ -230,11 +265,10 @@ Added '/CN=alternate/DC=example'
 
       assert_equal "Passphrase and passphrase confirmation don't match",
                    e.message
-
     end
 
-    refute_path_exists File.join(@tempdir, 'gem-private_key.pem')
-    refute_path_exists File.join(@tempdir, 'gem-public_cert.pem')
+    assert_path_not_exist File.join(@tempdir, "gem-private_key.pem")
+    assert_path_not_exist File.join(@tempdir, "gem-public_cert.pem")
   end
 
   def test_execute_build_key
@@ -255,8 +289,8 @@ Added '/CN=alternate/DC=example'
     assert_empty output
     assert_empty @ui.error
 
-    assert_path_exists File.join(@tempdir, 'gem-public_cert.pem')
-    refute_path_exists File.join(@tempdir, 'gem-private_key.pem')
+    assert_path_exist File.join(@tempdir, "gem-public_cert.pem")
+    assert_path_not_exist File.join(@tempdir, "gem-private_key.pem")
   end
 
   def test_execute_build_encrypted_key
@@ -277,7 +311,29 @@ Added '/CN=alternate/DC=example'
     assert_empty output
     assert_empty @ui.error
 
-    assert_path_exists File.join(@tempdir, 'gem-public_cert.pem')
+    assert_path_exist File.join(@tempdir, "gem-public_cert.pem")
+  end
+
+  def test_execute_build_ec_key
+    @cmd.handle_options %W[
+      --build nobody@example.com
+      --private-key #{PRIVATE_EC_KEY_FILE}
+    ]
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    output = @ui.output.split "\n"
+
+    assert_equal "Certificate: #{File.join @tempdir, 'gem-public_cert.pem'}",
+                 output.shift
+
+    assert_empty output
+    assert_empty @ui.error
+
+    assert_path_exist File.join(@tempdir, "gem-public_cert.pem")
+    assert_path_not_exist File.join(@tempdir, "gem-private_key.pem")
   end
 
   def test_execute_certificate
@@ -285,8 +341,8 @@ Added '/CN=alternate/DC=example'
       @cmd.handle_options %W[--certificate #{PUBLIC_CERT_FILE}]
     end
 
-    assert_equal '', @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.output
+    assert_equal "", @ui.error
 
     assert_equal PUBLIC_CERT.to_pem, @cmd.options[:issuer_cert].to_pem
   end
@@ -325,8 +381,8 @@ Added '/CN=alternate/DC=example'
       @cmd.send :handle_options, %W[--private-key #{PRIVATE_KEY_FILE}]
     end
 
-    assert_equal '', @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.output
+    assert_equal "", @ui.error
 
     assert_equal PRIVATE_KEY.to_pem, @cmd.options[:key].to_pem
   end
@@ -336,8 +392,8 @@ Added '/CN=alternate/DC=example'
       @cmd.send :handle_options, %W[--private-key #{ENCRYPTED_PRIVATE_KEY_PATH}]
     end
 
-    assert_equal '', @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.output
+    assert_equal "", @ui.error
 
     assert_equal ENCRYPTED_PRIVATE_KEY.to_pem, @cmd.options[:key].to_pem
   end
@@ -347,7 +403,7 @@ Added '/CN=alternate/DC=example'
 
     cert_path = @trust_dir.cert_path PUBLIC_CERT
 
-    assert_path_exists cert_path
+    assert_path_exist cert_path
 
     @cmd.handle_options %W[--remove nobody]
 
@@ -356,9 +412,9 @@ Added '/CN=alternate/DC=example'
     end
 
     assert_equal "Removed '/CN=nobody/DC=example'\n", @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
 
-    refute_path_exists cert_path
+    assert_path_not_exist cert_path
   end
 
   def test_execute_remove_multiple
@@ -368,8 +424,8 @@ Added '/CN=alternate/DC=example'
     public_path = @trust_dir.cert_path PUBLIC_CERT
     alternate_path = @trust_dir.cert_path ALTERNATE_CERT
 
-    assert_path_exists public_path
-    assert_path_exists alternate_path
+    assert_path_exist public_path
+    assert_path_exist alternate_path
 
     @cmd.handle_options %W[--remove example]
 
@@ -383,10 +439,10 @@ Removed '/CN=nobody/DC=example'
     EXPECTED
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
 
-    refute_path_exists public_path
-    refute_path_exists alternate_path
+    assert_path_not_exist public_path
+    assert_path_not_exist alternate_path
   end
 
   def test_execute_remove_twice
@@ -396,8 +452,8 @@ Removed '/CN=nobody/DC=example'
     public_path = @trust_dir.cert_path PUBLIC_CERT
     alternate_path = @trust_dir.cert_path ALTERNATE_CERT
 
-    assert_path_exists public_path
-    assert_path_exists alternate_path
+    assert_path_exist public_path
+    assert_path_exist alternate_path
 
     @cmd.handle_options %W[--remove nobody --remove alternate]
 
@@ -411,17 +467,17 @@ Removed '/CN=alternate/DC=example'
     EXPECTED
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
 
-    refute_path_exists public_path
-    refute_path_exists alternate_path
+    assert_path_not_exist public_path
+    assert_path_not_exist alternate_path
   end
 
   def test_execute_sign
-    path = File.join @tempdir, 'cert.pem'
+    path = File.join @tempdir, "cert.pem"
     Gem::Security.write ALTERNATE_CERT, path, 0600
 
-    assert_equal '/CN=alternate/DC=example', ALTERNATE_CERT.issuer.to_s
+    assert_equal "/CN=alternate/DC=example", ALTERNATE_CERT.issuer.to_s
 
     @cmd.handle_options %W[
       --private-key #{PRIVATE_KEY_FILE}
@@ -434,12 +490,12 @@ Removed '/CN=alternate/DC=example'
       @cmd.execute
     end
 
-    assert_equal '', @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.output
+    assert_equal "", @ui.error
 
     cert = OpenSSL::X509::Certificate.new File.read path
 
-    assert_equal '/CN=nobody/DC=example', cert.issuer.to_s
+    assert_equal "/CN=nobody/DC=example", cert.issuer.to_s
 
     mask = 0100600 & (~File.umask)
 
@@ -447,10 +503,10 @@ Removed '/CN=alternate/DC=example'
   end
 
   def test_execute_sign_encrypted_key
-    path = File.join @tempdir, 'cert.pem'
+    path = File.join @tempdir, "cert.pem"
     Gem::Security.write ALTERNATE_CERT, path, 0600
 
-    assert_equal '/CN=alternate/DC=example', ALTERNATE_CERT.issuer.to_s
+    assert_equal "/CN=alternate/DC=example", ALTERNATE_CERT.issuer.to_s
 
     @cmd.handle_options %W[
       --private-key #{ENCRYPTED_PRIVATE_KEY_PATH}
@@ -463,12 +519,12 @@ Removed '/CN=alternate/DC=example'
       @cmd.execute
     end
 
-    assert_equal '', @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.output
+    assert_equal "", @ui.error
 
     cert = OpenSSL::X509::Certificate.new File.read path
 
-    assert_equal '/CN=nobody/DC=example', cert.issuer.to_s
+    assert_equal "/CN=nobody/DC=example", cert.issuer.to_s
 
     mask = 0100600 & (~File.umask)
 
@@ -476,18 +532,18 @@ Removed '/CN=alternate/DC=example'
   end
 
   def test_execute_sign_default
-    FileUtils.mkdir_p File.join Gem.user_home, '.gem'
+    FileUtils.mkdir_p File.join Gem.user_home, ".gem"
 
-    private_key_path = File.join Gem.user_home, '.gem', 'gem-private_key.pem'
+    private_key_path = File.join Gem.user_home, ".gem", "gem-private_key.pem"
     Gem::Security.write PRIVATE_KEY, private_key_path
 
-    public_cert_path = File.join Gem.user_home, '.gem', 'gem-public_cert.pem'
+    public_cert_path = File.join Gem.user_home, ".gem", "gem-public_cert.pem"
     Gem::Security.write PUBLIC_CERT, public_cert_path
 
-    path = File.join @tempdir, 'cert.pem'
+    path = File.join @tempdir, "cert.pem"
     Gem::Security.write ALTERNATE_CERT, path, 0600
 
-    assert_equal '/CN=alternate/DC=example', ALTERNATE_CERT.issuer.to_s
+    assert_equal "/CN=alternate/DC=example", ALTERNATE_CERT.issuer.to_s
 
     @cmd.handle_options %W[--sign #{path}]
 
@@ -495,12 +551,12 @@ Removed '/CN=alternate/DC=example'
       @cmd.execute
     end
 
-    assert_equal '', @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.output
+    assert_equal "", @ui.error
 
     cert = OpenSSL::X509::Certificate.new File.read path
 
-    assert_equal '/CN=nobody/DC=example', cert.issuer.to_s
+    assert_equal "/CN=nobody/DC=example", cert.issuer.to_s
 
     mask = 0100600 & (~File.umask)
 
@@ -508,18 +564,18 @@ Removed '/CN=alternate/DC=example'
   end
 
   def test_execute_sign_default_encrypted_key
-    FileUtils.mkdir_p File.join(Gem.user_home, '.gem')
+    FileUtils.mkdir_p File.join(Gem.user_home, ".gem")
 
-    private_key_path = File.join Gem.user_home, '.gem', 'gem-private_key.pem'
+    private_key_path = File.join Gem.user_home, ".gem", "gem-private_key.pem"
     Gem::Security.write ENCRYPTED_PRIVATE_KEY, private_key_path, 0600, PRIVATE_KEY_PASSPHRASE
 
-    public_cert_path = File.join Gem.user_home, '.gem', 'gem-public_cert.pem'
+    public_cert_path = File.join Gem.user_home, ".gem", "gem-public_cert.pem"
     Gem::Security.write PUBLIC_CERT, public_cert_path
 
-    path = File.join @tempdir, 'cert.pem'
+    path = File.join @tempdir, "cert.pem"
     Gem::Security.write ALTERNATE_CERT, path, 0600
 
-    assert_equal '/CN=alternate/DC=example', ALTERNATE_CERT.issuer.to_s
+    assert_equal "/CN=alternate/DC=example", ALTERNATE_CERT.issuer.to_s
 
     @cmd.handle_options %W[--sign #{path}]
 
@@ -527,12 +583,12 @@ Removed '/CN=alternate/DC=example'
       @cmd.execute
     end
 
-    assert_equal '', @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.output
+    assert_equal "", @ui.error
 
     cert = OpenSSL::X509::Certificate.new File.read path
 
-    assert_equal '/CN=nobody/DC=example', cert.issuer.to_s
+    assert_equal "/CN=nobody/DC=example", cert.issuer.to_s
 
     mask = 0100600 & (~File.umask)
 
@@ -540,25 +596,25 @@ Removed '/CN=alternate/DC=example'
   end
 
   def test_execute_sign_no_cert
-    FileUtils.mkdir_p File.join Gem.user_home, '.gem'
+    FileUtils.mkdir_p File.join Gem.user_home, ".gem"
 
-    private_key_path = File.join Gem.user_home, '.gem', 'gem-private_key.pem'
+    private_key_path = File.join Gem.user_home, ".gem", "gem-private_key.pem"
     Gem::Security.write PRIVATE_KEY, private_key_path
 
-    path = File.join @tempdir, 'cert.pem'
+    path = File.join @tempdir, "cert.pem"
     Gem::Security.write ALTERNATE_CERT, path, 0600
 
-    assert_equal '/CN=alternate/DC=example', ALTERNATE_CERT.issuer.to_s
+    assert_equal "/CN=alternate/DC=example", ALTERNATE_CERT.issuer.to_s
 
     @cmd.handle_options %W[--sign #{path}]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
 
-    assert_equal '', @ui.output
+    assert_equal "", @ui.output
 
     expected = <<-EXPECTED
 ERROR:  --certificate not specified and ~/.gem/gem-public_cert.pem does not exist
@@ -568,25 +624,25 @@ ERROR:  --certificate not specified and 
   end
 
   def test_execute_sign_no_key
-    FileUtils.mkdir_p File.join Gem.user_home, '.gem'
+    FileUtils.mkdir_p File.join Gem.user_home, ".gem"
 
-    public_cert_path = File.join Gem.user_home, '.gem', 'gem-public_cert.pem'
+    public_cert_path = File.join Gem.user_home, ".gem", "gem-public_cert.pem"
     Gem::Security.write PUBLIC_CERT, public_cert_path
 
-    path = File.join @tempdir, 'cert.pem'
+    path = File.join @tempdir, "cert.pem"
     Gem::Security.write ALTERNATE_CERT, path, 0600
 
-    assert_equal '/CN=alternate/DC=example', ALTERNATE_CERT.issuer.to_s
+    assert_equal "/CN=alternate/DC=example", ALTERNATE_CERT.issuer.to_s
 
     @cmd.handle_options %W[--sign #{path}]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
 
-    assert_equal '', @ui.output
+    assert_equal "", @ui.output
 
     expected = <<-EXPECTED
 ERROR:  --private-key not specified and ~/.gem/gem-private_key.pem does not exist
@@ -599,10 +655,10 @@ ERROR:  --private-key not specified and 
     gem_path = File.join Gem.user_home, ".gem"
     Dir.mkdir gem_path
 
-    path = File.join @tempdir, 'cert.pem'
+    path = File.join @tempdir, "cert.pem"
     Gem::Security.write EXPIRED_PUBLIC_CERT, path, 0600
 
-    assert_equal '/CN=nobody/DC=example', EXPIRED_PUBLIC_CERT.issuer.to_s
+    assert_equal "/CN=nobody/DC=example", EXPIRED_PUBLIC_CERT.issuer.to_s
 
     tmp_expired_cert_file = File.join(Dir.tmpdir, File.basename(EXPIRED_PUBLIC_CERT_FILE))
     @cleanup << tmp_expired_cert_file
@@ -624,17 +680,17 @@ ERROR:  --private-key not specified and 
       /INFO:  Your certificate #{tmp_expired_cert_file} has been re-signed\nINFO:  Your expired certificate will be located at: #{expected_path}\.[0-9]+/,
       @ui.output
     )
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_re_sign_with_cert_expiration_length_days
     gem_path = File.join Gem.user_home, ".gem"
     Dir.mkdir gem_path
 
-    path = File.join @tempdir, 'cert.pem'
+    path = File.join @tempdir, "cert.pem"
     Gem::Security.write EXPIRED_PUBLIC_CERT, path, 0600
 
-    assert_equal '/CN=nobody/DC=example', EXPIRED_PUBLIC_CERT.issuer.to_s
+    assert_equal "/CN=nobody/DC=example", EXPIRED_PUBLIC_CERT.issuer.to_s
 
     tmp_expired_cert_file = File.join(Dir.tmpdir, File.basename(EXPIRED_PUBLIC_CERT_FILE))
     @cleanup << tmp_expired_cert_file
@@ -656,7 +712,7 @@ ERROR:  --private-key not specified and 
     cert_days_to_expire = (re_signed_cert.not_after - re_signed_cert.not_before).to_i / (24 * 60 * 60)
 
     assert_equal(28, cert_days_to_expire)
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_handle_options
@@ -675,29 +731,29 @@ ERROR:  --private-key not specified and 
     ]
 
     assert_equal [PUBLIC_CERT.to_pem, ALTERNATE_CERT.to_pem],
-                 @cmd.options[:add].map { |cert| cert.to_pem }
+                 @cmd.options[:add].map {|cert| cert.to_pem }
 
     assert_equal %w[nobody example], @cmd.options[:remove]
 
     assert_equal %w[nobody@example other@example],
-                 @cmd.options[:build].map { |name| name.to_s }
+                 @cmd.options[:build].map {|name| name.to_s }
 
-    assert_equal ['', 'example'], @cmd.options[:list]
+    assert_equal ["", "example"], @cmd.options[:list]
   end
 
   def test_handle_options_add_bad
-    nonexistent = File.join @tempdir, 'nonexistent'
-    e = assert_raises OptionParser::InvalidArgument do
+    nonexistent = File.join @tempdir, "nonexistent"
+    e = assert_raise Gem::OptionParser::InvalidArgument do
       @cmd.handle_options %W[--add #{nonexistent}]
     end
 
     assert_equal "invalid argument: --add #{nonexistent}: does not exist",
                  e.message
 
-    bad = File.join @tempdir, 'bad'
+    bad = File.join @tempdir, "bad"
     FileUtils.touch bad
 
-    e = assert_raises OptionParser::InvalidArgument do
+    e = assert_raise Gem::OptionParser::InvalidArgument do
       @cmd.handle_options %W[--add #{bad}]
     end
 
@@ -706,18 +762,18 @@ ERROR:  --private-key not specified and 
   end
 
   def test_handle_options_certificate
-    nonexistent = File.join @tempdir, 'nonexistent'
-    e = assert_raises OptionParser::InvalidArgument do
+    nonexistent = File.join @tempdir, "nonexistent"
+    e = assert_raise Gem::OptionParser::InvalidArgument do
       @cmd.handle_options %W[--certificate #{nonexistent}]
     end
 
     assert_equal "invalid argument: --certificate #{nonexistent}: does not exist",
                  e.message
 
-    bad = File.join @tempdir, 'bad'
+    bad = File.join @tempdir, "bad"
     FileUtils.touch bad
 
-    e = assert_raises OptionParser::InvalidArgument do
+    e = assert_raise Gem::OptionParser::InvalidArgument do
       @cmd.handle_options %W[--certificate #{bad}]
     end
 
@@ -727,8 +783,8 @@ ERROR:  --private-key not specified and 
   end
 
   def test_handle_options_key_bad
-    nonexistent = File.join @tempdir, 'nonexistent'
-    e = assert_raises OptionParser::InvalidArgument do
+    nonexistent = File.join @tempdir, "nonexistent"
+    e = assert_raise Gem::OptionParser::InvalidArgument do
       @cmd.handle_options %W[--private-key #{nonexistent}]
     end
 
@@ -736,17 +792,17 @@ ERROR:  --private-key not specified and 
                  "--private-key #{nonexistent}: does not exist",
                  e.message
 
-    bad = File.join @tempdir, 'bad'
+    bad = File.join @tempdir, "bad"
     FileUtils.touch bad
 
-    e = assert_raises OptionParser::InvalidArgument do
+    e = assert_raise Gem::OptionParser::InvalidArgument do
       @cmd.handle_options %W[--private-key #{bad}]
     end
 
-    assert_equal "invalid argument: --private-key #{bad}: invalid RSA key",
+    assert_equal "invalid argument: --private-key #{bad}: invalid RSA, DSA, or EC key",
                  e.message
 
-    e = assert_raises OptionParser::InvalidArgument do
+    e = assert_raise Gem::OptionParser::InvalidArgument do
       @cmd.handle_options %W[--private-key #{PUBLIC_KEY_FILE}]
     end
 
@@ -792,8 +848,8 @@ ERROR:  --private-key not specified and 
   end
 
   def test_handle_options_sign_nonexistent
-    nonexistent = File.join @tempdir, 'nonexistent'
-    e = assert_raises OptionParser::InvalidArgument do
+    nonexistent = File.join @tempdir, "nonexistent"
+    e = assert_raise Gem::OptionParser::InvalidArgument do
       @cmd.handle_options %W[
         --private-key #{ALTERNATE_KEY_FILE}
 
@@ -806,5 +862,4 @@ ERROR:  --private-key not specified and 
     assert_equal "invalid argument: --sign #{nonexistent}: does not exist",
                  e.message
   end
-
-end if defined?(OpenSSL::SSL) && !Gem.java_platform?
+end if Gem::HAVE_OPENSSL && !Gem.java_platform?
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_check_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_check_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/check_command'
+require_relative "helper"
+require "rubygems/commands/check_command"
 
 class TestGemCommandsCheckCommand < Gem::TestCase
-
   def setup
     super
 
@@ -46,24 +45,23 @@ class TestGemCommandsCheckCommand < Gem:
   end
 
   def test_doctor
-    gem 'a'
-    b = gem 'b'
+    gem "a"
+    b = gem "b"
 
     FileUtils.rm b.spec_file
 
-    assert_path_exists b.gem_dir
-    refute_path_exists b.spec_file
+    assert_path_exist b.gem_dir
+    assert_path_not_exist b.spec_file
 
     Gem.use_paths @gemhome
 
-    capture_io do
+    capture_output do
       use_ui @ui do
         @cmd.doctor
       end
     end
 
-    refute_path_exists b.gem_dir
-    refute_path_exists b.spec_file
+    assert_path_not_exist b.gem_dir
+    assert_path_not_exist b.spec_file
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_cleanup_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_cleanup_command.rb
@@ -1,17 +1,16 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/cleanup_command'
-require 'rubygems/installer'
+require_relative "helper"
+require "rubygems/commands/cleanup_command"
+require "rubygems/installer"
 
 class TestGemCommandsCleanupCommand < Gem::TestCase
-
   def setup
     super
 
     @cmd = Gem::Commands::CleanupCommand.new
 
-    @a_1 = util_spec 'a', 1
-    @a_2 = util_spec 'a', 2
+    @a_1 = util_spec "a", 1
+    @a_2 = util_spec "a", 2
 
     install_gem @a_1
     install_gem @a_2
@@ -23,10 +22,21 @@ class TestGemCommandsCleanupCommand < Ge
   end
 
   def test_handle_options_dry_run
-    @cmd.handle_options %w[--dryrun]
+    @cmd.handle_options %w[--dry-run]
     assert @cmd.options[:dryrun]
   end
 
+  def test_handle_options_deprecated_dry_run
+    use_ui @ui do
+      @cmd.handle_options %w[--dryrun]
+      assert @cmd.options[:dryrun]
+    end
+
+    assert_equal \
+      "WARNING:  The \"--dryrun\" option has been deprecated and will be removed in future versions of Rubygems. Use --dry-run instead\n",
+      @ui.error
+  end
+
   def test_handle_options_n
     @cmd.handle_options %w[-n]
     assert @cmd.options[:dryrun]
@@ -52,16 +62,16 @@ class TestGemCommandsCleanupCommand < Ge
 
     @cmd.execute
 
-    refute_path_exists @a_1.gem_dir
+    assert_path_not_exist @a_1.gem_dir
   end
 
   def test_execute_all_dependencies
-    @b_1 = util_spec 'b', 1 do |s|
-      s.add_dependency 'a', '1'
+    @b_1 = util_spec "b", 1 do |s|
+      s.add_dependency "a", "1"
     end
 
-    @b_2 = util_spec 'b', 2 do |s|
-      s.add_dependency 'a', '2'
+    @b_2 = util_spec "b", 2 do |s|
+      s.add_dependency "a", "2"
     end
 
     install_gem @b_1
@@ -71,17 +81,17 @@ class TestGemCommandsCleanupCommand < Ge
 
     @cmd.execute
 
-    refute_path_exists @a_1.gem_dir
-    refute_path_exists @b_1.gem_dir
+    assert_path_not_exist @a_1.gem_dir
+    assert_path_not_exist @b_1.gem_dir
   end
 
   def test_execute_dev_dependencies
-    @b_1 = util_spec 'b', 1 do |s|
-      s.add_development_dependency 'a', '1'
+    @b_1 = util_spec "b", 1 do |s|
+      s.add_development_dependency "a", "1"
     end
 
-    @c_1 = util_spec 'c', 1 do |s|
-      s.add_development_dependency 'a', '2'
+    @c_1 = util_spec "c", 1 do |s|
+      s.add_development_dependency "a", "2"
     end
 
     install_gem @b_1
@@ -91,16 +101,16 @@ class TestGemCommandsCleanupCommand < Ge
 
     @cmd.execute
 
-    assert_path_exists @a_1.gem_dir
+    assert_path_exist @a_1.gem_dir
   end
 
   def test_execute_without_dev_dependencies
-    @b_1 = util_spec 'b', 1 do |s|
-      s.add_development_dependency 'a', '1'
+    @b_1 = util_spec "b", 1 do |s|
+      s.add_development_dependency "a", "1"
     end
 
-    @c_1 = util_spec 'c', 1 do |s|
-      s.add_development_dependency 'a', '2'
+    @c_1 = util_spec "c", 1 do |s|
+      s.add_development_dependency "a", "2"
     end
 
     install_gem @b_1
@@ -110,18 +120,18 @@ class TestGemCommandsCleanupCommand < Ge
 
     @cmd.execute
 
-    refute_path_exists @a_1.gem_dir
+    assert_path_not_exist @a_1.gem_dir
   end
 
   def test_execute_all
-    gemhome2 = File.join @tempdir, 'gemhome2'
+    gemhome2 = File.join @tempdir, "gemhome2"
 
     Gem.ensure_gem_subdirectories gemhome2
 
     Gem.use_paths @gemhome, gemhome2
 
-    @b_1 = util_spec 'b', 1
-    @b_2 = util_spec 'b', 2
+    @b_1 = util_spec "b", 1
+    @b_2 = util_spec "b", 2
 
     install_gem @b_1
     install_gem @b_2
@@ -130,47 +140,47 @@ class TestGemCommandsCleanupCommand < Ge
 
     @cmd.execute
 
-    assert_equal @gemhome, Gem.dir, 'GEM_HOME'
-    assert_equal [@gemhome, gemhome2], Gem.path.sort, 'GEM_PATH'
+    assert_equal @gemhome, Gem.dir, "GEM_HOME"
+    assert_equal [@gemhome, gemhome2], Gem.path.sort, "GEM_PATH"
 
-    refute_path_exists @a_1.gem_dir
-    refute_path_exists @b_1.gem_dir
+    assert_path_not_exist @a_1.gem_dir
+    assert_path_not_exist @b_1.gem_dir
   end
 
   def test_execute_all_user
-    @a_1_1, = util_gem 'a', '1.1'
+    @a_1_1, = util_gem "a", "1.1"
     @a_1_1 = install_gem @a_1_1 # pick up user install path
 
     Gem::Specification.dirs = [Gem.dir, Gem.user_dir]
 
-    assert_path_exists @a_1.gem_dir
-    assert_path_exists @a_1_1.gem_dir
+    assert_path_exist @a_1.gem_dir
+    assert_path_exist @a_1_1.gem_dir
 
     @cmd.options[:args] = %w[a]
 
     @cmd.execute
 
-    refute_path_exists @a_1.gem_dir
-    refute_path_exists @a_1_1.gem_dir
+    assert_path_not_exist @a_1.gem_dir
+    assert_path_not_exist @a_1_1.gem_dir
   end
 
   def test_execute_all_user_no_sudo
     FileUtils.chmod 0555, @gemhome
 
-    @a_1_1, = util_gem 'a', '1.1'
+    @a_1_1, = util_gem "a", "1.1"
     @a_1_1 = install_gem @a_1_1, :user_install => true # pick up user install path
 
     Gem::Specification.dirs = [Gem.dir, Gem.user_dir]
 
-    assert_path_exists @a_1.gem_dir
-    assert_path_exists @a_1_1.gem_dir
+    assert_path_exist @a_1.gem_dir
+    assert_path_exist @a_1_1.gem_dir
 
     @cmd.options[:args] = %w[a]
 
     @cmd.execute
 
-    assert_path_exists @a_1.gem_dir
-    assert_path_exists @a_1_1.gem_dir
+    assert_path_exist @a_1.gem_dir
+    assert_path_exist @a_1_1.gem_dir
   ensure
     FileUtils.chmod 0755, @gemhome
   end unless win_platform? || Process.uid.zero?
@@ -181,15 +191,15 @@ class TestGemCommandsCleanupCommand < Ge
 
     @cmd.execute
 
-    assert_path_exists @a_1.gem_dir
+    assert_path_exist @a_1.gem_dir
   end
 
   def test_execute_keeps_older_versions_with_deps
-    @b_1 = util_spec 'b', 1
-    @b_2 = util_spec 'b', 2
+    @b_1 = util_spec "b", 1
+    @b_2 = util_spec "b", 2
 
-    @c = util_spec 'c', 1 do |s|
-      s.add_dependency 'b', '1'
+    @c = util_spec "c", 1 do |s|
+      s.add_dependency "b", "1"
     end
 
     install_gem @b_1
@@ -200,18 +210,18 @@ class TestGemCommandsCleanupCommand < Ge
 
     @cmd.execute
 
-    assert_path_exists @b_1.gem_dir
+    assert_path_exist @b_1.gem_dir
   end
 
   def test_execute_ignore_default_gem_verbose
     Gem.configuration.verbose = :really
 
-    @b_1 = util_spec 'b', 1
+    @b_1 = util_spec "b", 1
     @b_default = new_default_spec "b", "2"
-    @b_2 = util_spec 'b', 3
+    @b_2 = util_spec "b", 3
 
     install_gem @b_1
-    install_default_specs @b_default
+    install_default_gems @b_default
     install_gem @b_2
 
     @cmd.options[:args] = []
@@ -220,17 +230,17 @@ class TestGemCommandsCleanupCommand < Ge
       @cmd.execute
     end
 
-    assert_match %r%^Skipped default gems: b-2%, @ui.output
+    assert_match %r{^Skipped default gems: b-2}, @ui.output
     assert_empty @ui.error
   end
 
   def test_execute_remove_gem_home_only
-    c_1, = util_gem 'c', '1'
-    c_2, = util_gem 'c', '2'
-    d_1, = util_gem 'd', '1'
-    d_2, = util_gem 'd', '2'
-    e_1, = util_gem 'e', '1'
-    e_2, = util_gem 'e', '2'
+    c_1, = util_gem "c", "1"
+    c_2, = util_gem "c", "2"
+    d_1, = util_gem "d", "1"
+    d_2, = util_gem "d", "2"
+    e_1, = util_gem "e", "1"
+    e_2, = util_gem "e", "2"
 
     c_1 = install_gem c_1, :user_install => true # pick up user install path
     c_2 = install_gem c_2
@@ -247,17 +257,17 @@ class TestGemCommandsCleanupCommand < Ge
 
     @cmd.execute
 
-    assert_path_exists c_1.gem_dir
-    refute_path_exists d_1.gem_dir
-    refute_path_exists e_1.gem_dir
+    assert_path_exist c_1.gem_dir
+    assert_path_not_exist d_1.gem_dir
+    assert_path_not_exist e_1.gem_dir
   end
 
   def test_execute_user_install
-    c_1, = util_gem 'c', '1.0'
-    c_2, = util_gem 'c', '1.1'
+    c_1, = util_gem "c", "1.0"
+    c_2, = util_gem "c", "1.1"
 
-    d_1, = util_gem 'd', '1.0'
-    d_2, = util_gem 'd', '1.1'
+    d_1, = util_gem "d", "1.0"
+    d_2, = util_gem "d", "1.1"
 
     c_1 = install_gem c_1, :user_install => true # pick up user install path
     c_2 = install_gem c_2, :user_install => true # pick up user install path
@@ -272,11 +282,10 @@ class TestGemCommandsCleanupCommand < Ge
 
     @cmd.execute
 
-    refute_path_exists c_1.gem_dir
-    assert_path_exists c_2.gem_dir
+    assert_path_not_exist c_1.gem_dir
+    assert_path_exist c_2.gem_dir
 
-    assert_path_exists d_1.gem_dir
-    assert_path_exists d_2.gem_dir
+    assert_path_exist d_1.gem_dir
+    assert_path_exist d_2.gem_dir
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_contents_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_contents_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/contents_command'
+require_relative "helper"
+require "rubygems/commands/contents_command"
 
 class TestGemCommandsContentsCommand < Gem::TestCase
-
   def setup
     super
 
@@ -21,58 +20,58 @@ class TestGemCommandsContentsCommand < G
   def test_execute
     @cmd.options[:args] = %w[foo]
 
-    gem 'foo'
+    gem "foo"
 
     use_ui @ui do
       @cmd.execute
     end
 
-    assert_match %r|lib/foo\.rb|, @ui.output
-    assert_match %r|Rakefile|, @ui.output
+    assert_match %r{lib/foo\.rb}, @ui.output
+    assert_match %r{Rakefile}, @ui.output
     assert_equal "", @ui.error
   end
 
   def test_execute_all
     @cmd.options[:all] = true
 
-    gem 'foo'
-    gem 'bar'
+    gem "foo"
+    gem "bar"
 
     use_ui @ui do
       @cmd.execute
     end
 
-    assert_match %r|lib/foo\.rb|, @ui.output
-    assert_match %r|lib/bar\.rb|, @ui.output
-    assert_match %r|Rakefile|, @ui.output
+    assert_match %r{lib/foo\.rb}, @ui.output
+    assert_match %r{lib/bar\.rb}, @ui.output
+    assert_match %r{Rakefile}, @ui.output
     assert_equal "", @ui.error
   end
 
   def test_execute_bad_gem
     @cmd.options[:args] = %w[foo]
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @ui do
         @cmd.execute
       end
     end
 
-    assert_match %r|Unable to find gem 'foo' in default gem paths|, @ui.output
-    assert_match %r|Directories searched:|, @ui.output
+    assert_match %r{Unable to find gem 'foo' in default gem paths}, @ui.output
+    assert_match %r{Directories searched:}, @ui.output
     assert_equal "", @ui.error
   end
 
   def test_execute_exact_match
     @cmd.options[:args] = %w[foo]
-    gem 'foo'
-    gem 'bar'
+    gem "foo"
+    gem "bar"
 
     use_ui @ui do
       @cmd.execute
     end
 
-    assert_match %r|lib/foo\.rb|, @ui.output
-    assert_match %r|Rakefile|, @ui.output
+    assert_match %r{lib/foo\.rb}, @ui.output
+    assert_match %r{Rakefile}, @ui.output
     assert_equal "", @ui.error
   end
 
@@ -80,14 +79,14 @@ class TestGemCommandsContentsCommand < G
     @cmd.options[:args] = %w[foo]
     @cmd.options[:lib_only] = true
 
-    gem 'foo'
+    gem "foo"
 
     use_ui @ui do
       @cmd.execute
     end
 
-    assert_match %r|lib/foo\.rb|, @ui.output
-    refute_match %r|Rakefile|, @ui.output
+    assert_match %r{lib/foo\.rb}, @ui.output
+    refute_match %r{Rakefile}, @ui.output
 
     assert_equal "", @ui.error
   end
@@ -95,7 +94,23 @@ class TestGemCommandsContentsCommand < G
   def test_execute_missing_single
     @cmd.options[:args] = %w[foo]
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
+      use_ui @ui do
+        @cmd.execute
+      end
+    end
+
+    assert_match "Unable to find gem 'foo'", @ui.output
+    assert_empty @ui.error
+  end
+
+  def test_execute_missing_version
+    @cmd.options[:args] = %w[foo]
+    @cmd.options[:version] = Gem::Requirement.new "= 2"
+
+    gem "foo", 1
+
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @ui do
         @cmd.execute
       end
@@ -108,7 +123,7 @@ class TestGemCommandsContentsCommand < G
   def test_execute_missing_multiple
     @cmd.options[:args] = %w[foo bar]
 
-    gem 'foo'
+    gem "foo"
 
     use_ui @ui do
       @cmd.execute
@@ -123,16 +138,16 @@ class TestGemCommandsContentsCommand < G
   def test_execute_multiple
     @cmd.options[:args] = %w[foo bar]
 
-    gem 'foo'
-    gem 'bar'
+    gem "foo"
+    gem "bar"
 
     use_ui @ui do
       @cmd.execute
     end
 
-    assert_match %r|lib/foo\.rb|, @ui.output
-    assert_match %r|lib/bar\.rb|, @ui.output
-    assert_match %r|Rakefile|, @ui.output
+    assert_match %r{lib/foo\.rb}, @ui.output
+    assert_match %r{lib/bar\.rb}, @ui.output
+    assert_match %r{Rakefile}, @ui.output
     assert_equal "", @ui.error
   end
 
@@ -140,13 +155,30 @@ class TestGemCommandsContentsCommand < G
     @cmd.options[:args] = %w[foo]
     @cmd.options[:show_install_dir] = true
 
-    gem 'foo'
+    gem "foo"
 
     use_ui @ui do
       @cmd.execute
     end
 
-    expected = File.join @gemhome, 'gems', 'foo-2'
+    expected = File.join @gemhome, "gems", "foo-2"
+
+    assert_equal "#{expected}\n", @ui.output
+    assert_equal "", @ui.error
+  end
+
+  def test_execute_show_install_dir_latest_version
+    @cmd.options[:args] = %w[foo]
+    @cmd.options[:show_install_dir] = true
+
+    gem "foo", 1
+    gem "foo", 2
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    expected = File.join @gemhome, "gems", "foo-2"
 
     assert_equal "#{expected}\n", @ui.output
     assert_equal "", @ui.error
@@ -155,16 +187,16 @@ class TestGemCommandsContentsCommand < G
   def test_execute_show_install_dir_version
     @cmd.options[:args] = %w[foo]
     @cmd.options[:show_install_dir] = true
-    @cmd.options[:version] = Gem::Requirement.new '= 1'
+    @cmd.options[:version] = Gem::Requirement.new "= 1"
 
-    gem 'foo', 1
-    gem 'foo', 2
+    gem "foo", 1
+    gem "foo", 2
 
     use_ui @ui do
       @cmd.execute
     end
 
-    expected = File.join @gemhome, 'gems', 'foo-1'
+    expected = File.join @gemhome, "gems", "foo-1"
 
     assert_equal "#{expected}\n", @ui.output
     assert_equal "", @ui.error
@@ -174,7 +206,7 @@ class TestGemCommandsContentsCommand < G
     @cmd.options[:args] = %w[foo]
     @cmd.options[:prefix] = false
 
-    gem 'foo'
+    gem "foo"
 
     use_ui @ui do
       @cmd.execute
@@ -195,7 +227,7 @@ lib/foo.rb
                                         nil, "default/gem.rb")
     default_gem_spec.executables = ["default_command"]
     default_gem_spec.files += ["default_gem.so"]
-    install_default_specs(default_gem_spec)
+    install_default_gems(default_gem_spec)
 
     @cmd.options[:args] = %w[default]
 
@@ -204,10 +236,10 @@ lib/foo.rb
     end
 
     expected = [
-      [RbConfig::CONFIG['bindir'], 'default_command'],
-      [RbConfig::CONFIG['rubylibdir'], 'default/gem.rb'],
-      [RbConfig::CONFIG['archdir'], 'default_gem.so']
-    ].sort.map{|a|File.join a}.join "\n"
+      [RbConfig::CONFIG["bindir"], "default_command"],
+      [RbConfig::CONFIG["rubylibdir"], "default/gem.rb"],
+      [RbConfig::CONFIG["archdir"], "default_gem.so"],
+    ].sort.map {|a|File.join a }.join "\n"
 
     assert_equal expected, @ui.output.chomp
     assert_equal "", @ui.error
@@ -232,8 +264,7 @@ lib/foo.rb
     assert @cmd.options[:lib_only]
     refute @cmd.options[:prefix]
     assert_equal %w[foo], @cmd.options[:specdirs]
-    assert_equal Gem::Requirement.new('0.0.2'), @cmd.options[:version]
+    assert_equal Gem::Requirement.new("0.0.2"), @cmd.options[:version]
     assert @cmd.options[:show_install_dir]
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_dependency_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_dependency_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/dependency_command'
+require_relative "helper"
+require "rubygems/commands/dependency_command"
 
 class TestGemCommandsDependencyCommand < Gem::TestCase
-
   def setup
     super
     @stub_ui = Gem::MockGemUi.new
@@ -12,9 +11,9 @@ class TestGemCommandsDependencyCommand <
   end
 
   def test_execute
-    quick_gem 'foo' do |gem|
-      gem.add_dependency 'bar', '> 1'
-      gem.add_dependency 'baz', '> 1'
+    quick_gem "foo" do |gem|
+      gem.add_dependency "bar", "> 1"
+      gem.add_dependency "baz", "> 1"
     end
 
     @cmd.options[:args] = %w[foo]
@@ -25,16 +24,16 @@ class TestGemCommandsDependencyCommand <
 
     assert_equal "Gem foo-2\n  bar (> 1)\n  baz (> 1)\n\n",
                  @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_no_args
-    install_specs util_spec 'x', '2'
+    install_specs util_spec "x", "2"
 
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', '2.a'
-      fetcher.spec 'dep_x', 1, 'x' => '>= 1'
+      fetcher.spec "a", 1
+      fetcher.spec "a", "2.a"
+      fetcher.spec "dep_x", 1, "x" => ">= 1"
       fetcher.legacy_platform
     end
 
@@ -59,27 +58,27 @@ Gem x-2
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_no_match
     @cmd.options[:args] = %w[foo]
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @stub_ui do
         @cmd.execute
       end
     end
 
     assert_equal "No gems found matching foo (>= 0)\n", @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_pipe_format
-    spec = util_spec 'foo' do |gem|
-      gem.add_dependency 'bar', '> 1'
+    spec = util_spec "foo" do |gem|
+      gem.add_dependency "bar", "> 1"
     end
-    install_specs util_spec 'bar', 2
+    install_specs util_spec "bar", 2
     install_specs spec
 
     @cmd.options[:args] = %w[foo]
@@ -90,15 +89,15 @@ Gem x-2
     end
 
     assert_equal "bar --version '> 1'\n", @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_regexp
     spec_fetcher do |fetcher|
-      fetcher.spec 'a',      1
-      fetcher.spec 'a',      '2.a'
-      fetcher.spec 'a_evil', 9
-      fetcher.spec 'b',      2
+      fetcher.spec "a",      1
+      fetcher.spec "a",      "2.a"
+      fetcher.spec "a_evil", 9
+      fetcher.spec "b",      2
     end
 
     @cmd.options[:args] = %w[[ab]]
@@ -119,17 +118,17 @@ Gem b-2
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_reverse
     # FIX: this shouldn't need to write out, but fails if you switch it
-    quick_gem 'foo' do |gem|
-      gem.add_dependency 'bar', '> 1'
+    quick_gem "foo" do |gem|
+      gem.add_dependency "bar", "> 1"
     end
 
-    quick_gem 'baz' do |gem|
-      gem.add_dependency 'foo'
+    quick_gem "baz" do |gem|
+      gem.add_dependency "foo"
     end
 
     @cmd.options[:args] = %w[foo]
@@ -148,7 +147,7 @@ Gem foo-2
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_reverse_remote
@@ -156,7 +155,7 @@ Gem foo-2
     @cmd.options[:reverse_dependencies] = true
     @cmd.options[:domain] = :remote
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @stub_ui do
         @cmd.execute
       end
@@ -166,15 +165,15 @@ Gem foo-2
 ERROR:  Only reverse dependencies for local gems are supported.
     EOF
 
-    assert_equal '', @stub_ui.output
+    assert_equal "", @stub_ui.output
     assert_equal expected, @stub_ui.error
   end
 
   def test_execute_remote
-    install_specs util_spec 'bar', '2'
+    install_specs util_spec "bar", "2"
 
     spec_fetcher do |fetcher|
-      fetcher.spec 'foo', 2, 'bar' => '> 1'
+      fetcher.spec "foo", 2, "bar" => "> 1"
     end
 
     @cmd.options[:args] = %w[foo]
@@ -185,7 +184,7 @@ ERROR:  Only reverse dependencies for lo
     end
 
     assert_equal "Gem foo-2\n  bar (> 1)\n\n", @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_remote_version
@@ -193,25 +192,25 @@ ERROR:  Only reverse dependencies for lo
     Gem::RemoteFetcher.fetcher = @fetcher
 
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', 2
+      fetcher.spec "a", 1
+      fetcher.spec "a", 2
     end
 
     @cmd.options[:args] = %w[a]
     @cmd.options[:domain] = :remote
-    @cmd.options[:version] = req '= 1'
+    @cmd.options[:version] = req "= 1"
 
     use_ui @stub_ui do
       @cmd.execute
     end
 
     assert_equal "Gem a-1\n\n", @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_prerelease
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', '2.a'
+      fetcher.spec "a", "2.a"
     end
 
     @cmd.options[:args] = %w[a]
@@ -223,7 +222,6 @@ ERROR:  Only reverse dependencies for lo
     end
 
     assert_equal "Gem a-2.a\n\n", @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_environment_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_environment_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/environment_command'
+require_relative "helper"
+require "rubygems/commands/environment_command"
 
 class TestGemCommandsEnvironmentCommand < Gem::TestCase
-
   def setup
     super
 
@@ -12,9 +11,9 @@ class TestGemCommandsEnvironmentCommand 
 
   def test_execute
     orig_sources = Gem.sources.dup
-    orig_path, ENV['PATH'] = ENV['PATH'], %w[/usr/local/bin /usr/bin /bin].join(File::PATH_SEPARATOR)
+    orig_path, ENV["PATH"] = ENV["PATH"], %w[/usr/local/bin /usr/bin /bin].join(File::PATH_SEPARATOR)
     Gem.sources.replace %w[http://gems.example.com]
-    Gem.configuration['gemcutter_key'] = 'blah'
+    Gem.configuration["gemcutter_key"] = "blah"
 
     @cmd.send :handle_options, %w[]
 
@@ -22,35 +21,37 @@ class TestGemCommandsEnvironmentCommand 
       @cmd.execute
     end
 
-    assert_match %r|RUBYGEMS VERSION: (\d\.)+\d|, @ui.output
-    assert_match %r|RUBY VERSION: \d+\.\d+\.\d+ \(.*\) \[.*\]|, @ui.output
-    assert_match %r|INSTALLATION DIRECTORY: #{Regexp.escape @gemhome}|,
+    assert_match %r{RUBYGEMS VERSION: (\d\.)+\d}, @ui.output
+    assert_match %r{RUBY VERSION: \d+\.\d+\.\d+ \(.*\) \[.*\]}, @ui.output
+    assert_match %r{INSTALLATION DIRECTORY: #{Regexp.escape @gemhome}},
+                 @ui.output
+    assert_match %r{USER INSTALLATION DIRECTORY: #{Regexp.escape Gem.user_dir}},
                  @ui.output
-    assert_match %r|RUBYGEMS PREFIX: |, @ui.output
-    assert_match %r|RUBY EXECUTABLE:.*#{RbConfig::CONFIG['ruby_install_name']}|,
+    assert_match %r{RUBYGEMS PREFIX: }, @ui.output
+    assert_match %r{RUBY EXECUTABLE:.*#{RbConfig::CONFIG['ruby_install_name']}},
                  @ui.output
-    assert_match %r|GIT EXECUTABLE: #{@cmd.send(:git_path)}|, @ui.output
-    assert_match %r|SYSTEM CONFIGURATION DIRECTORY:|, @ui.output
-    assert_match %r|EXECUTABLE DIRECTORY:|, @ui.output
-    assert_match %r|RUBYGEMS PLATFORMS:|, @ui.output
-    assert_match %r|- #{Gem::Platform.local}|, @ui.output
-    assert_match %r|GEM PATHS:|, @ui.output
-    assert_match %r|- #{Regexp.escape @gemhome}|, @ui.output
-    assert_match %r|GEM CONFIGURATION:|, @ui.output
-    assert_match %r|"gemcutter_key" => "\*\*\*\*"|, @ui.output
-    assert_match %r|:verbose => |, @ui.output
-    assert_match %r|REMOTE SOURCES:|, @ui.output
-
-    assert_match %r|- SHELL PATH:|,     @ui.output
-    assert_match %r|- /usr/local/bin$|, @ui.output
-    assert_match %r|- /usr/bin$|,       @ui.output
-    assert_match %r|- /bin$|,           @ui.output
+    assert_match %r{GIT EXECUTABLE: #{@cmd.send(:git_path)}}, @ui.output
+    assert_match %r{SYSTEM CONFIGURATION DIRECTORY:}, @ui.output
+    assert_match %r{EXECUTABLE DIRECTORY:}, @ui.output
+    assert_match %r{RUBYGEMS PLATFORMS:}, @ui.output
+    assert_match %r{- #{Gem::Platform.local}}, @ui.output
+    assert_match %r{GEM PATHS:}, @ui.output
+    assert_match %r{- #{Regexp.escape @gemhome}}, @ui.output
+    assert_match %r{GEM CONFIGURATION:}, @ui.output
+    assert_match %r{"gemcutter_key" => "\*\*\*\*"}, @ui.output
+    assert_match %r{:verbose => }, @ui.output
+    assert_match %r{REMOTE SOURCES:}, @ui.output
+
+    assert_match %r{- SHELL PATH:},     @ui.output
+    assert_match %r{- /usr/local/bin$}, @ui.output
+    assert_match %r{- /usr/bin$},       @ui.output
+    assert_match %r{- /bin$},           @ui.output
 
     assert_empty @ui.error
 
   ensure
     Gem.sources.replace orig_sources
-    ENV['PATH'] = orig_path
+    ENV["PATH"] = orig_path
   end
 
   def test_execute_gemdir
@@ -61,7 +62,29 @@ class TestGemCommandsEnvironmentCommand 
     end
 
     assert_equal "#{@gemhome}\n", @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
+  end
+
+  def test_execute_user_gemdir
+    @cmd.send :handle_options, %w[user_gemdir]
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    assert_equal "#{Gem.user_dir}\n", @ui.output
+    assert_equal "", @ui.error
+  end
+
+  def test_execute_user_gemhome
+    @cmd.send :handle_options, %w[user_gemhome]
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    assert_equal "#{Gem.user_dir}\n", @ui.output
+    assert_equal "", @ui.error
   end
 
   def test_execute_gempath
@@ -72,13 +95,13 @@ class TestGemCommandsEnvironmentCommand 
     end
 
     assert_equal "#{@gemhome}\n", @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_gempath_multiple
     Gem.clear_paths
     path = [@gemhome, "#{@gemhome}2"].join File::PATH_SEPARATOR
-    ENV['GEM_PATH'] = path
+    ENV["GEM_PATH"] = path
 
     @cmd.send :handle_options, %w[gempath]
 
@@ -87,7 +110,7 @@ class TestGemCommandsEnvironmentCommand 
     end
 
     assert_equal "#{Gem.path.join File::PATH_SEPARATOR}\n", @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_remotesources
@@ -101,7 +124,7 @@ class TestGemCommandsEnvironmentCommand 
     end
 
     assert_equal "http://gems.example.com\n", @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
 
   ensure
     Gem.sources.replace orig_sources
@@ -110,14 +133,14 @@ class TestGemCommandsEnvironmentCommand 
   def test_execute_unknown
     @cmd.send :handle_options, %w[unknown]
 
-    assert_raises Gem::CommandLineError do
+    assert_raise Gem::CommandLineError do
       use_ui @ui do
         @cmd.execute
       end
     end
 
-    assert_equal '', @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.output
+    assert_equal "", @ui.error
   end
 
   def test_execute_version
@@ -128,7 +151,7 @@ class TestGemCommandsEnvironmentCommand 
     end
 
     assert_equal "#{Gem::VERSION}\n", @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_platform
@@ -139,7 +162,6 @@ class TestGemCommandsEnvironmentCommand 
     end
 
     assert_equal "#{Gem.platforms.join File::PATH_SEPARATOR}\n", @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_fetch_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_fetch_command.rb
@@ -1,11 +1,10 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/package'
-require 'rubygems/security'
-require 'rubygems/commands/fetch_command'
+require_relative "helper"
+require "rubygems/package"
+require "rubygems/security"
+require "rubygems/commands/fetch_command"
 
 class TestGemCommandsFetchCommand < Gem::TestCase
-
   def setup
     super
 
@@ -14,10 +13,10 @@ class TestGemCommandsFetchCommand < Gem:
 
   def test_execute
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
-    refute_path_exists File.join(@tempdir, 'cache'), 'sanity check'
+    assert_path_not_exist File.join(@tempdir, "cache"), "sanity check"
 
     @cmd.options[:args] = %w[a]
 
@@ -27,24 +26,24 @@ class TestGemCommandsFetchCommand < Gem:
       end
     end
 
-    a2 = specs['a-2']
+    a2 = specs["a-2"]
 
-    assert_path_exists(File.join(@tempdir, a2.file_name),
+    assert_path_exist(File.join(@tempdir, a2.file_name),
                        "#{a2.full_name} not fetched")
-    refute_path_exists File.join(@tempdir, 'cache'),
-                       'gem repository directories must not be created'
+    assert_path_not_exist File.join(@tempdir, "cache"),
+                       "gem repository directories must not be created"
   end
 
   def test_execute_latest
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 1
+      fetcher.gem "a", 2
     end
 
-    refute_path_exists File.join(@tempdir, 'cache'), 'sanity check'
+    assert_path_not_exist File.join(@tempdir, "cache"), "sanity check"
 
     @cmd.options[:args] = %w[a]
-    @cmd.options[:version] = req('>= 0.1')
+    @cmd.options[:version] = req(">= 0.1")
 
     use_ui @ui do
       Dir.chdir @tempdir do
@@ -52,17 +51,17 @@ class TestGemCommandsFetchCommand < Gem:
       end
     end
 
-    a2 = specs['a-2']
-    assert_path_exists(File.join(@tempdir, a2.file_name),
+    a2 = specs["a-2"]
+    assert_path_exist(File.join(@tempdir, a2.file_name),
                        "#{a2.full_name} not fetched")
-    refute_path_exists File.join(@tempdir, 'cache'),
-                       'gem repository directories must not be created'
+    assert_path_not_exist File.join(@tempdir, "cache"),
+                       "gem repository directories must not be created"
   end
 
   def test_execute_prerelease
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
-      fetcher.gem 'a', '2.a'
+      fetcher.gem "a", 2
+      fetcher.gem "a", "2.a"
     end
 
     @cmd.options[:args] = %w[a]
@@ -74,16 +73,52 @@ class TestGemCommandsFetchCommand < Gem:
       end
     end
 
-    a2 = specs['a-2']
+    a2 = specs["a-2"]
 
-    assert_path_exists(File.join(@tempdir, a2.file_name),
+    assert_path_exist(File.join(@tempdir, a2.file_name),
                        "#{a2.full_name} not fetched")
   end
 
+  def test_execute_platform
+    a2_spec, a2 = util_gem("a", "2")
+
+    a2_universal_darwin_spec, a2_universal_darwin = util_gem("a", "2") do |s|
+      s.platform = "universal-darwin"
+    end
+
+    Gem::RemoteFetcher.fetcher = @fetcher = Gem::FakeFetcher.new
+
+    write_marshalled_gemspecs(a2_spec, a2_universal_darwin_spec)
+
+    @cmd.options[:args] = %w[a]
+
+    @fetcher.data["#{@gem_repo}latest_specs.#{Gem.marshal_version}.gz"] = util_gzip(Marshal.dump([
+      Gem::NameTuple.new(a2_spec.name, a2_spec.version, a2_spec.platform),
+      Gem::NameTuple.new(a2_universal_darwin_spec.name, a2_universal_darwin_spec.version, a2_universal_darwin_spec.platform),
+    ]))
+
+    @fetcher.data["#{@gem_repo}gems/#{a2_spec.file_name}"] = Gem.read_binary(a2)
+    FileUtils.cp a2, a2_spec.cache_file
+
+    @fetcher.data["#{@gem_repo}gems/#{a2_universal_darwin_spec.file_name}"] = Gem.read_binary(a2_universal_darwin)
+    FileUtils.cp a2_universal_darwin, a2_universal_darwin_spec.cache_file
+
+    util_set_arch "arm64-darwin20" do
+      use_ui @ui do
+        Dir.chdir @tempdir do
+          @cmd.execute
+        end
+      end
+    end
+
+    assert_path_exist(File.join(@tempdir, a2_universal_darwin_spec.file_name),
+                       "#{a2_universal_darwin_spec.full_name} not fetched")
+  end
+
   def test_execute_specific_prerelease
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
-      fetcher.gem 'a', '2.a'
+      fetcher.gem "a", 2
+      fetcher.gem "a", "2.a"
     end
 
     @cmd.options[:args] = %w[a]
@@ -96,20 +131,39 @@ class TestGemCommandsFetchCommand < Gem:
       end
     end
 
-    a2_pre = specs['a-2.a']
+    a2_pre = specs["a-2.a"]
 
-    assert_path_exists(File.join(@tempdir, a2_pre.file_name),
+    assert_path_exist(File.join(@tempdir, a2_pre.file_name),
                        "#{a2_pre.full_name} not fetched")
   end
 
   def test_execute_version
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 1
+      fetcher.gem "a", 2
     end
 
     @cmd.options[:args] = %w[a]
-    @cmd.options[:version] = Gem::Requirement.new '1'
+    @cmd.options[:version] = Gem::Requirement.new "1"
+
+    use_ui @ui do
+      Dir.chdir @tempdir do
+        @cmd.execute
+      end
+    end
+
+    a1 = specs["a-1"]
+
+    assert_path_exist(File.join(@tempdir, a1.file_name),
+                       "#{a1.full_name} not fetched")
+  end
+
+  def test_execute_version_specified_by_colon
+    specs = spec_fetcher do |fetcher|
+      fetcher.gem "a", 1
+    end
+
+    @cmd.options[:args] = %w[a:1]
 
     use_ui @ui do
       Dir.chdir @tempdir do
@@ -117,10 +171,87 @@ class TestGemCommandsFetchCommand < Gem:
       end
     end
 
-    a1 = specs['a-1']
+    a1 = specs["a-1"]
 
-    assert_path_exists(File.join(@tempdir, a1.file_name),
+    assert_path_exist(File.join(@tempdir, a1.file_name),
                        "#{a1.full_name} not fetched")
   end
 
+  def test_execute_two_version
+    @cmd.options[:args] = %w[a b]
+    @cmd.options[:version] = Gem::Requirement.new "1"
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::TermError, @ui.error do
+        @cmd.execute
+      end
+    end
+
+    msg = "ERROR:  Can't use --version with multiple gems. You can specify multiple gems with" \
+      " version requirements using `gem fetch 'my_gem:1.0.0' 'my_other_gem:~>2.0.0'`"
+
+    assert_empty @ui.output
+    assert_equal msg, @ui.error.chomp
+  end
+
+  def test_execute_two_version_specified_by_colon
+    specs = spec_fetcher do |fetcher|
+      fetcher.gem "a", 1
+      fetcher.gem "b", 1
+    end
+
+    @cmd.options[:args] = %w[a:1 b:1]
+
+    use_ui @ui do
+      Dir.chdir @tempdir do
+        @cmd.execute
+      end
+    end
+
+    a1 = specs["a-1"]
+    b1 = specs["b-1"]
+
+    assert_path_exist(File.join(@tempdir, a1.file_name),
+                       "#{a1.full_name} not fetched")
+    assert_path_exist(File.join(@tempdir, b1.file_name),
+                       "#{b1.full_name} not fetched")
+  end
+
+  def test_execute_version_nonexistent
+    spec_fetcher do |fetcher|
+      fetcher.spec "foo", 1
+    end
+
+    @cmd.options[:args] = %w[foo:2]
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    expected = <<-EXPECTED
+ERROR:  Could not find a valid gem 'foo' (2) in any repository
+ERROR:  Possible alternatives: foo
+    EXPECTED
+
+    assert_equal expected, @ui.error
+  end
+
+  def test_execute_nonexistent_hint_disabled
+    spec_fetcher do |fetcher|
+      fetcher.spec "foo", 1
+    end
+
+    @cmd.options[:args] = %w[foo:2]
+    @cmd.options[:suggest_alternate] = false
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    expected = <<-EXPECTED
+ERROR:  Could not find a valid gem 'foo' (2) in any repository
+    EXPECTED
+
+    assert_equal expected, @ui.error
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_generate_index_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_generate_index_command.rb
@@ -1,14 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/indexer'
-require 'rubygems/commands/generate_index_command'
-
-unless defined?(Builder::XChar)
-  warn "generate_index tests are being skipped.  Install builder gem."
-end
+require_relative "helper"
+require "rubygems/indexer"
+require "rubygems/commands/generate_index_command"
 
 class TestGemCommandsGenerateIndexCommand < Gem::TestCase
-
   def setup
     super
 
@@ -40,21 +35,21 @@ class TestGemCommandsGenerateIndexComman
 
   def test_handle_options_directory
     return if win_platform?
-    refute_equal '/nonexistent', @cmd.options[:directory]
+    refute_equal "/nonexistent", @cmd.options[:directory]
 
     @cmd.handle_options %w[--directory /nonexistent]
 
-    assert_equal '/nonexistent', @cmd.options[:directory]
+    assert_equal "/nonexistent", @cmd.options[:directory]
   end
 
   def test_handle_options_directory_windows
     return unless win_platform?
 
-    refute_equal '/nonexistent', @cmd.options[:directory]
+    refute_equal "/nonexistent", @cmd.options[:directory]
 
     @cmd.handle_options %w[--directory C:/nonexistent]
 
-    assert_equal 'C:/nonexistent', @cmd.options[:directory]
+    assert_equal "C:/nonexistent", @cmd.options[:directory]
   end
 
   def test_handle_options_update
@@ -82,5 +77,4 @@ class TestGemCommandsGenerateIndexComman
       "WARNING:  The \"--no-modern\" option has been deprecated and will be removed in Rubygems 4.0. The `--no-modern` option is currently ignored. Modern indexes (specs, latest_specs, and prerelease_specs) are always generated.\n",
       @ui.error
   end
-
-end if defined?(Builder::XChar)
+end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_help_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_help_command.rb
@@ -1,53 +1,72 @@
 # frozen_string_literal: true
 require "rubygems"
-require "rubygems/test_case"
+require_relative "helper"
 require "rubygems/commands/help_command"
 require "rubygems/package"
 require "rubygems/command_manager"
 
 class TestGemCommandsHelpCommand < Gem::TestCase
-
   def setup
     super
 
     @cmd = Gem::Commands::HelpCommand.new
 
-    load File.expand_path('../rubygems_plugin.rb', __FILE__) unless Gem::Commands.const_defined? :InterruptCommand
+    load File.expand_path("rubygems_plugin.rb", __dir__) unless Gem::Commands.const_defined? :InterruptCommand
   end
 
   def test_gem_help_bad
-    util_gem 'bad' do |out, err|
-      assert_equal('', out)
+    util_gem "bad" do |out, err|
+      assert_equal("", out)
       assert_match "Unknown command bad", err
     end
   end
 
   def test_gem_help_gem_dependencies
-    util_gem 'gem_dependencies' do |out, err|
-      assert_match 'gem.deps.rb', out
-      assert_equal '', err
+    util_gem "gem_dependencies" do |out, err|
+      assert_match "gem.deps.rb", out
+      assert_equal "", err
     end
   end
 
   def test_gem_help_platforms
-    util_gem 'platforms' do |out, err|
+    util_gem "platforms" do |out, err|
       assert_match(/x86-freebsd/, out)
-      assert_equal '', err
+      assert_equal "", err
+    end
+  end
+
+  def test_gem_help_build
+    util_gem "build" do |out, err|
+      assert_match(/-C PATH *Run as if gem build was started in <PATH>/, out)
+      assert_equal "", err
     end
   end
 
   def test_gem_help_commands
     mgr = Gem::CommandManager.new
 
-    util_gem 'commands' do |out, err|
+    util_gem "commands" do |out, err|
       mgr.command_names.each do |cmd|
-        assert_match(/\s+#{cmd}\s+\S+/, out)
+        unless mgr[cmd].deprecated?
+          assert_match(/\s+#{cmd}\s+\S+/, out)
+        end
       end
 
-      if defined?(OpenSSL::SSL)
+      if Gem::HAVE_OPENSSL
         assert_empty err
 
-        refute_match 'No command found for ', out
+        refute_match %r{No command found for }, out
+      end
+    end
+  end
+
+  def test_gem_help_commands_omits_deprecated_commands
+    mgr = Gem::CommandManager.new
+
+    util_gem "commands" do |out, err|
+      deprecated_commands = mgr.command_names.select {|cmd| mgr[cmd].deprecated? }
+      deprecated_commands.each do |cmd|
+        refute_match(/\A\s+#{cmd}\s+\S+\z/, out)
       end
     end
   end
@@ -56,7 +75,7 @@ class TestGemCommandsHelpCommand < Gem::
     util_gem do |out, err|
       assert_match(/Usage:/, out)
       assert_match(/gem install/, out)
-      assert_equal '', err
+      assert_equal "", err
     end
   end
 
@@ -71,5 +90,4 @@ class TestGemCommandsHelpCommand < Gem::
 
     yield @ui.output, @ui.error
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_info_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_info_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/info_command'
+require_relative "helper"
+require "rubygems/commands/info_command"
 
 class TestGemCommandsInfoCommand < Gem::TestCase
-
   def setup
     super
 
@@ -33,13 +32,38 @@ class TestGemCommandsInfoCommand < Gem::
       @cmd.execute
     end
 
-    assert_match %r%#{@gem.name} \(#{@gem.version}\)\n%, @ui.output
-    assert_match %r%Authors: #{@gem.authors.join(', ')}\n%, @ui.output
-    assert_match %r%Homepage: #{@gem.homepage}\n%, @ui.output
-    assert_match %r%License: #{@gem.license}\n%, @ui.output
-    assert_match %r%Installed at: #{@gem.base_dir}\n%, @ui.output
-    assert_match %r%#{@gem.summary}\n%, @ui.output
+    assert_match %r{#{@gem.name} \(#{@gem.version}\)\n}, @ui.output
+    assert_match %r{Authors: #{@gem.authors.join(', ')}\n}, @ui.output
+    assert_match %r{Homepage: #{@gem.homepage}\n}, @ui.output
+    assert_match %r{License: #{@gem.license}\n}, @ui.output
+    assert_match %r{Installed at: #{@gem.base_dir}\n}, @ui.output
+    assert_match %r{#{@gem.summary}\n}, @ui.output
     assert_match "", @ui.error
   end
 
+  def test_execute_with_version_flag
+    spec_fetcher do |fetcher|
+      fetcher.spec "coolgem", "1.0"
+      fetcher.spec "coolgem", "2.0"
+    end
+
+    @cmd.handle_options %w[coolgem --remote --version 1.0]
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    expected = <<-EOF
+
+*** REMOTE GEMS ***
+
+coolgem (1.0)
+    Author: A User
+    Homepage: http://example.com
+
+    this is a summary
+    EOF
+
+    assert_equal expected, @ui.output
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_install_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_install_command.rb
@@ -1,11 +1,10 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/install_command'
-require 'rubygems/request_set'
-require 'rubygems/rdoc'
+require_relative "helper"
+require "rubygems/commands/install_command"
+require "rubygems/request_set"
+require "rubygems/rdoc"
 
 class TestGemCommandsInstallCommand < Gem::TestCase
-
   def setup
     super
     common_installer_setup
@@ -31,51 +30,51 @@ class TestGemCommandsInstallCommand < Ge
 
   def test_execute_exclude_prerelease
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
-      fetcher.gem 'a', '2.pre'
+      fetcher.gem "a", 2
+      fetcher.gem "a", "2.pre"
     end
 
     @cmd.options[:args] = %w[a]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[a-2], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-2], @cmd.installed_specs.map {|spec| spec.full_name }
   end
 
   def test_execute_explicit_version_includes_prerelease
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
-      fetcher.gem 'a', '2.a'
+      fetcher.gem "a", 2
+      fetcher.gem "a", "2.a"
     end
 
-    a2_pre = specs['a-2.a']
+    a2_pre = specs["a-2.a"]
 
-    @cmd.handle_options [a2_pre.name, '--version', a2_pre.version.to_s,
+    @cmd.handle_options [a2_pre.name, "--version", a2_pre.version.to_s,
                          "--no-document"]
     assert @cmd.options[:prerelease]
     assert @cmd.options[:version].satisfied_by?(a2_pre.version)
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[a-2.a], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-2.a], @cmd.installed_specs.map {|spec| spec.full_name }
   end
 
   def test_execute_local
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     @cmd.options[:domain] = :local
 
-    FileUtils.mv specs['a-2'].cache_file, @tempdir
+    FileUtils.mv specs["a-2"].cache_file, @tempdir
 
     @cmd.options[:args] = %w[a]
 
@@ -83,7 +82,7 @@ class TestGemCommandsInstallCommand < Ge
       orig_dir = Dir.pwd
       begin
         Dir.chdir @tempdir
-        assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+        assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
           @cmd.execute
         end
       ensure
@@ -91,27 +90,27 @@ class TestGemCommandsInstallCommand < Ge
       end
     end
 
-    assert_equal %w[a-2], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-2], @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_match "1 gem installed", @ui.output
   end
 
   def test_execute_local_dependency_nonexistent
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'foo', 2, 'bar' => '0.5'
+      fetcher.gem "foo", 2, "bar" => "0.5"
     end
 
     @cmd.options[:domain] = :local
 
-    FileUtils.mv specs['foo-2'].cache_file, @tempdir
+    FileUtils.mv specs["foo-2"].cache_file, @tempdir
 
-    @cmd.options[:args] = ['foo']
+    @cmd.options[:args] = ["foo"]
 
     use_ui @ui do
       orig_dir = Dir.pwd
       begin
         Dir.chdir @tempdir
-        e = assert_raises Gem::MockGemUi::TermError do
+        e = assert_raise Gem::MockGemUi::TermError do
           @cmd.execute
         end
         assert_equal 2, e.exit_code
@@ -129,21 +128,21 @@ ERROR:  Could not find a valid gem 'bar'
 
   def test_execute_local_dependency_nonexistent_ignore_dependencies
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'foo', 2, 'bar' => '0.5'
+      fetcher.gem "foo", 2, "bar" => "0.5"
     end
 
     @cmd.options[:domain] = :local
     @cmd.options[:ignore_dependencies] = true
 
-    FileUtils.mv specs['foo-2'].cache_file, @tempdir
+    FileUtils.mv specs["foo-2"].cache_file, @tempdir
 
-    @cmd.options[:args] = ['foo']
+    @cmd.options[:args] = ["foo"]
 
     use_ui @ui do
       orig_dir = Dir.pwd
       begin
         Dir.chdir orig_dir
-        assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+        assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
           @cmd.execute
         end
       ensure
@@ -156,16 +155,16 @@ ERROR:  Could not find a valid gem 'bar'
 
   def test_execute_local_transitive_prerelease
     specs = spec_fetcher do |fetcher|
-      fetcher.download 'a', 2, 'b' => "2.a", 'c' => '3'
-      fetcher.download 'b', '2.a'
-      fetcher.download 'c', '3'
+      fetcher.download "a", 2, "b" => "2.a", "c" => "3"
+      fetcher.download "b", "2.a"
+      fetcher.download "c", "3"
     end
 
     @cmd.options[:domain] = :local
 
-    FileUtils.mv specs['a-2'].cache_file, @tempdir
-    FileUtils.mv specs['b-2.a'].cache_file, @tempdir
-    FileUtils.mv specs['c-3'].cache_file, @tempdir
+    FileUtils.mv specs["a-2"].cache_file, @tempdir
+    FileUtils.mv specs["b-2.a"].cache_file, @tempdir
+    FileUtils.mv specs["c-3"].cache_file, @tempdir
 
     @cmd.options[:args] = %w[a]
 
@@ -174,7 +173,7 @@ ERROR:  Could not find a valid gem 'bar'
       begin
         Dir.chdir @tempdir
         FileUtils.rm_r [@gemhome, "gems"]
-        assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+        assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
           @cmd.execute
         end
       ensure
@@ -182,22 +181,22 @@ ERROR:  Could not find a valid gem 'bar'
       end
     end
 
-    assert_equal %w[a-2 b-2.a c-3], @cmd.installed_specs.map { |spec| spec.full_name }.sort
+    assert_equal %w[a-2 b-2.a c-3], @cmd.installed_specs.map {|spec| spec.full_name }.sort
 
     assert_match "3 gems installed", @ui.output
   end
 
   def test_execute_no_user_install
-    skip 'skipped on MS Windows (chmod has no effect)' if win_platform?
-    skip 'skipped in root privilege' if Process.uid.zero?
+    pend "skipped on MS Windows (chmod has no effect)" if win_platform?
+    pend "skipped in root privilege" if Process.uid.zero?
 
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     @cmd.options[:user_install] = false
 
-    FileUtils.mv specs['a-2'].cache_file, @tempdir
+    FileUtils.mv specs["a-2"].cache_file, @tempdir
 
     @cmd.options[:args] = %w[a]
 
@@ -208,7 +207,7 @@ ERROR:  Could not find a valid gem 'bar'
         FileUtils.chmod 0555, @gemhome
 
         Dir.chdir @tempdir
-        assert_raises Gem::FilePermissionError do
+        assert_raise Gem::FilePermissionError do
           @cmd.execute
         end
       ensure
@@ -226,7 +225,7 @@ ERROR:  Could not find a valid gem 'bar'
     @cmd.options[:args] = %w[no_such_gem]
 
     use_ui @ui do
-      e = assert_raises Gem::MockGemUi::TermError do
+      e = assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
       assert_equal 2, e.exit_code
@@ -245,7 +244,7 @@ ERROR:  Could not find a valid gem 'bar'
     @cmd.options[:args] = %w[no_such_gem]
 
     use_ui @ui do
-      e = assert_raises Gem::MockGemUi::TermError do
+      e = assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
       assert_equal 2, e.exit_code
@@ -258,7 +257,7 @@ ERROR:  Could not find a valid gem 'bar'
   def test_execute_no_gem
     @cmd.options[:args] = %w[]
 
-    assert_raises Gem::CommandLineError do
+    assert_raise Gem::CommandLineError do
       @cmd.execute
     end
   end
@@ -269,7 +268,23 @@ ERROR:  Could not find a valid gem 'bar'
     @cmd.options[:args] = %w[nonexistent]
 
     use_ui @ui do
-      e = assert_raises Gem::MockGemUi::TermError do
+      e = assert_raise Gem::MockGemUi::TermError do
+        @cmd.execute
+      end
+      assert_equal 2, e.exit_code
+    end
+
+    assert_match(/ould not find a valid gem 'nonexistent'/, @ui.error)
+  end
+
+  def test_execute_nonexistent_force
+    spec_fetcher
+
+    @cmd.options[:args] = %w[nonexistent]
+    @cmd.options[:force] = true
+
+    use_ui @ui do
+      e = assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
       assert_equal 2, e.exit_code
@@ -280,13 +295,13 @@ ERROR:  Could not find a valid gem 'bar'
 
   def test_execute_dependency_nonexistent
     spec_fetcher do |fetcher|
-      fetcher.spec 'foo', 2, 'bar' => '0.5'
+      fetcher.spec "foo", 2, "bar" => "0.5"
     end
 
-    @cmd.options[:args] = ['foo']
+    @cmd.options[:args] = ["foo"]
 
     use_ui @ui do
-      e = assert_raises Gem::MockGemUi::TermError do
+      e = assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
 
@@ -302,7 +317,7 @@ ERROR:  Could not find a valid gem 'bar'
 
   def test_execute_http_proxy
     use_ui @ui do
-      e = assert_raises ArgumentError, @ui.error do
+      e = assert_raise ArgumentError, @ui.error do
         @cmd.handle_options %w[-p=foo.bar.com]
       end
 
@@ -328,7 +343,7 @@ ERROR:  Could not find a valid gem 'bar'
     @cmd.options[:args] = %w[nonexistent]
 
     use_ui @ui do
-      e = assert_raises Gem::MockGemUi::TermError do
+      e = assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
       assert_equal 2, e.exit_code
@@ -337,7 +352,7 @@ ERROR:  Could not find a valid gem 'bar'
     errs = @ui.error.split("\n")
 
     assert_match(/ould not find a valid gem 'nonexistent'/, errs.shift)
-    assert_match(%r!Unable to download data from http://not-there.nothing!, errs.shift)
+    assert_match(%r{Unable to download data from http://not-there.nothing}, errs.shift)
   end
 
   def test_execute_nonexistent_hint_disabled
@@ -352,7 +367,7 @@ ERROR:  Could not find a valid gem 'bar'
     @cmd.options[:suggest_alternate] = false
 
     use_ui @ui do
-      e = assert_raises Gem::MockGemUi::TermError do
+      e = assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
 
@@ -377,7 +392,7 @@ ERROR:  Could not find a valid gem 'none
     @cmd.options[:args] = [misspelled]
 
     use_ui @ui do
-      e = assert_raises Gem::MockGemUi::TermError do
+      e = assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
 
@@ -402,7 +417,7 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:args] = [misspelled]
 
     use_ui @ui do
-      e = assert_raises Gem::MockGemUi::TermError do
+      e = assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
 
@@ -411,7 +426,7 @@ ERROR:  Possible alternatives: non_exist
 
     expected = [
       "ERROR:  Could not find a valid gem 'non-existent_with-hint' (>= 0) in any repository",
-      "ERROR:  Possible alternatives: nonexistent-with_hint"
+      "ERROR:  Possible alternatives: nonexistent-with_hint",
     ]
 
     output = @ui.error.split "\n"
@@ -424,7 +439,7 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:install_dir] = "whatever"
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
@@ -436,78 +451,209 @@ ERROR:  Possible alternatives: non_exist
 
   def test_execute_prerelease_skipped_when_no_flag_set
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
-      fetcher.gem 'a', '3.a'
+      fetcher.gem "a", 1
+      fetcher.gem "a", "3.a"
     end
 
     @cmd.options[:prerelease] = false
     @cmd.options[:args] = %w[a]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[a-1], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-1], @cmd.installed_specs.map {|spec| spec.full_name }
   end
 
   def test_execute_prerelease_wins_over_previous_ver
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 1
-      fetcher.download 'a', '2.a'
+      fetcher.download "a", 1
+      fetcher.download "a", "2.a"
     end
 
     @cmd.options[:prerelease] = true
     @cmd.options[:args] = %w[a]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[a-2.a], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-2.a], @cmd.installed_specs.map {|spec| spec.full_name }
   end
 
   def test_execute_with_version_specified_by_colon
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 1
-      fetcher.download 'a', 2
+      fetcher.download "a", 1
+      fetcher.download "a", 2
     end
 
     @cmd.options[:args] = %w[a:1]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[a-1], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-1], @cmd.installed_specs.map {|spec| spec.full_name }
   end
 
   def test_execute_prerelease_skipped_when_non_pre_available
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', '2.pre'
-      fetcher.gem 'a', 2
+      fetcher.gem "a", "2.pre"
+      fetcher.gem "a", 2
     end
 
     @cmd.options[:prerelease] = true
     @cmd.options[:args] = %w[a]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
+        @cmd.execute
+      end
+    end
+
+    assert_equal %w[a-2], @cmd.installed_specs.map {|spec| spec.full_name }
+  end
+
+  def test_execute_required_ruby_version
+    next_ruby = Gem.ruby_version.segments.map.with_index {|n, i| i == 1 ? n + 1 : n }.join(".")
+
+    local = Gem::Platform.local
+    spec_fetcher do |fetcher|
+      fetcher.download "a", 2
+      fetcher.download "a", 2 do |s|
+        s.required_ruby_version = "< #{RUBY_VERSION}.a"
+        s.platform = local
+      end
+      fetcher.download "a", 3 do |s|
+        s.required_ruby_version = ">= #{next_ruby}"
+      end
+      fetcher.download "a", 3 do |s|
+        s.required_ruby_version = ">= #{next_ruby}"
+        s.platform = local
+      end
+    end
+
+    @cmd.options[:args] = %w[a]
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
+        @cmd.execute
+      end
+    end
+
+    assert_equal %w[a-2], @cmd.installed_specs.map {|spec| spec.full_name }
+  end
+
+  def test_execute_required_ruby_version_upper_bound
+    local = Gem::Platform.local
+    spec_fetcher do |fetcher|
+      fetcher.gem "a", 2.0
+      fetcher.gem "a", 2.0 do |s|
+        s.required_ruby_version = "< #{RUBY_VERSION}.a"
+        s.platform = local
+      end
+    end
+
+    @cmd.options[:args] = %w[a]
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
+        @cmd.execute
+      end
+    end
+
+    assert_equal %w[a-2.0], @cmd.installed_specs.map {|spec| spec.full_name }
+  end
+
+  def test_execute_required_ruby_version_specific_not_met
+    spec_fetcher do |fetcher|
+      fetcher.gem "a", "1.0" do |s|
+        s.required_ruby_version = "= 1.4.6"
+      end
+    end
+
+    @cmd.options[:args] = %w[a]
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::TermError do
+        @cmd.execute
+      end
+    end
+
+    errs = @ui.error.split("\n")
+    assert_equal "ERROR:  Error installing a:", errs.shift
+    assert_equal "\ta-1.0 requires Ruby version = 1.4.6. The current ruby version is #{Gem.ruby_version}.", errs.shift
+  end
+
+  def test_execute_required_ruby_version_specific_prerelease_met
+    spec_fetcher do |fetcher|
+      fetcher.gem "a", "1.0" do |s|
+        s.required_ruby_version = ">= 1.4.6.preview2"
+      end
+    end
+
+    @cmd.options[:args] = %w[a]
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[a-2], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-1.0], @cmd.installed_specs.map {|spec| spec.full_name }
+  end
+
+  def test_execute_required_ruby_version_specific_prerelease_not_met
+    next_ruby_pre = Gem.ruby_version.segments.map.with_index {|n, i| i == 1 ? n + 1 : n }.join(".") + ".a"
+
+    spec_fetcher do |fetcher|
+      fetcher.gem "a", "1.0" do |s|
+        s.required_ruby_version = "> #{next_ruby_pre}"
+      end
+    end
+
+    @cmd.options[:args] = %w[a]
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::TermError do
+        @cmd.execute
+      end
+    end
+
+    errs = @ui.error.split("\n")
+    assert_equal "ERROR:  Error installing a:", errs.shift
+    assert_equal "\ta-1.0 requires Ruby version > #{next_ruby_pre}. The current ruby version is #{Gem.ruby_version}.", errs.shift
+  end
+
+  def test_execute_required_rubygems_version_wrong
+    spec_fetcher do |fetcher|
+      fetcher.gem "a", "1.0" do |s|
+        s.required_rubygems_version = "< 0"
+      end
+    end
+
+    @cmd.options[:args] = %w[a]
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::TermError do
+        @cmd.execute
+      end
+    end
+
+    errs = @ui.error.split("\n")
+    assert_equal "ERROR:  Error installing a:", errs.shift
+    assert_equal "\ta-1.0 requires RubyGems version < 0. The current RubyGems version is #{Gem.rubygems_version}. Try 'gem update --system' to update RubyGems itself.", errs.shift
   end
 
   def test_execute_rdoc
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     Gem.done_installing(&Gem::RDoc.method(:generation_hook))
@@ -515,7 +661,7 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:document] = %w[rdoc ri]
     @cmd.options[:domain] = :local
 
-    a2 = specs['a-2']
+    a2 = specs["a-2"]
     FileUtils.mv a2.cache_file, @tempdir
 
     @cmd.options[:args] = %w[a]
@@ -527,7 +673,7 @@ ERROR:  Possible alternatives: non_exist
 
       begin
         Dir.chdir @tempdir
-        assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+        assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
           @cmd.execute
         end
       ensure
@@ -537,22 +683,22 @@ ERROR:  Possible alternatives: non_exist
 
     wait_for_child_process_to_exit
 
-    assert_path_exists File.join(a2.doc_dir, 'ri')
-    assert_path_exists File.join(a2.doc_dir, 'rdoc')
+    assert_path_exist File.join(a2.doc_dir, "ri")
+    assert_path_exist File.join(a2.doc_dir, "rdoc")
   end
 
   def test_execute_rdoc_with_path
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     Gem.done_installing(&Gem::RDoc.method(:generation_hook))
 
     @cmd.options[:document] = %w[rdoc ri]
     @cmd.options[:domain] = :local
-    @cmd.options[:install_dir] = 'whatever'
+    @cmd.options[:install_dir] = "whatever"
 
-    a2 = specs['a-2']
+    a2 = specs["a-2"]
     FileUtils.mv a2.cache_file, @tempdir
 
     @cmd.options[:args] = %w[a]
@@ -564,7 +710,7 @@ ERROR:  Possible alternatives: non_exist
 
       begin
         Dir.chdir @tempdir
-        assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+        assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
           @cmd.execute
         end
       ensure
@@ -574,19 +720,19 @@ ERROR:  Possible alternatives: non_exist
 
     wait_for_child_process_to_exit
 
-    assert_path_exists 'whatever/doc/a-2', 'documentation not installed'
+    assert_path_exist "whatever/doc/a-2", "documentation not installed"
   end
 
   def test_execute_saves_build_args
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
-    args = %w!--with-awesome=true --more-awesome=yes!
+    args = %w[--with-awesome=true --more-awesome=yes]
 
     Gem::Command.build_args = args
 
-    a2 = specs['a-2']
+    a2 = specs["a-2"]
     FileUtils.mv a2.cache_file, @tempdir
 
     @cmd.options[:domain] = :local
@@ -600,7 +746,7 @@ ERROR:  Possible alternatives: non_exist
 
       begin
         Dir.chdir @tempdir
-        assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+        assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
           @cmd.execute
         end
       ensure
@@ -609,25 +755,25 @@ ERROR:  Possible alternatives: non_exist
     end
 
     path = a2.build_info_file
-    assert_path_exists path
+    assert_path_exist path
 
     assert_equal args, a2.build_args
   end
 
   def test_execute_remote
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     @cmd.options[:args] = %w[a]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[a-2], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-2], @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_match "1 gem installed", @ui.output
   end
@@ -636,32 +782,65 @@ ERROR:  Possible alternatives: non_exist
     FileUtils.touch("a.gem")
 
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     @cmd.options[:args] = %w[a]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[a-2], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-2], @cmd.installed_specs.map {|spec| spec.full_name }
+
+    assert_match "1 gem installed", @ui.output
+  end
+
+  def test_execute_remote_truncates_existing_gemspecs
+    spec_fetcher do |fetcher|
+      fetcher.gem "a", 1
+    end
+
+    @cmd.options[:domain] = :remote
+
+    @cmd.options[:args] = %w[a]
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
+        @cmd.execute
+      end
+    end
 
+    assert_equal %w[a-1], @cmd.installed_specs.map {|spec| spec.full_name }
     assert_match "1 gem installed", @ui.output
+
+    a1_gemspec = File.join(@gemhome, "specifications", "a-1.gemspec")
+
+    initial_a1_gemspec_content = File.read(a1_gemspec)
+    modified_a1_gemspec_content = initial_a1_gemspec_content + "\n  # AAAAAAA\n"
+    File.write(a1_gemspec, modified_a1_gemspec_content)
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
+        @cmd.execute
+      end
+    end
+
+    assert_equal initial_a1_gemspec_content, File.read(a1_gemspec)
   end
 
   def test_execute_remote_ignores_files
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 1
+      fetcher.gem "a", 2
     end
 
     @cmd.options[:domain] = :remote
 
-    a1 = specs['a-1']
-    a2 = specs['a-2']
+    a1 = specs["a-1"]
+    a2 = specs["a-2"]
 
     FileUtils.mv a2.cache_file, @tempdir
 
@@ -670,7 +849,7 @@ ERROR:  Possible alternatives: non_exist
 
     @cmd.options[:args] = [a2.name]
 
-    gemdir = File.join @gemhome, 'specifications'
+    gemdir = File.join @gemhome, "specifications"
 
     a2_gemspec = File.join(gemdir, "a-2.gemspec")
     a1_gemspec = File.join(gemdir, "a-1.gemspec")
@@ -682,13 +861,13 @@ ERROR:  Possible alternatives: non_exist
 
     use_ui @ui do
       Dir.chdir @tempdir do
-        assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+        assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
           @cmd.execute
         end
       end
     end
 
-    assert_equal %w[a-1], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-1], @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_match "1 gem installed", @ui.output
 
@@ -699,12 +878,12 @@ ERROR:  Possible alternatives: non_exist
 
   def test_execute_two
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
-      fetcher.gem 'b', 2
+      fetcher.gem "a", 2
+      fetcher.gem "b", 2
     end
 
-    FileUtils.mv specs['a-2'].cache_file, @tempdir
-    FileUtils.mv specs['b-2'].cache_file, @tempdir
+    FileUtils.mv specs["a-2"].cache_file, @tempdir
+    FileUtils.mv specs["b-2"].cache_file, @tempdir
 
     @cmd.options[:domain] = :local
 
@@ -714,7 +893,7 @@ ERROR:  Possible alternatives: non_exist
       orig_dir = Dir.pwd
       begin
         Dir.chdir @tempdir
-        assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+        assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
           @cmd.execute
         end
       ensure
@@ -722,7 +901,7 @@ ERROR:  Possible alternatives: non_exist
       end
     end
 
-    assert_equal %w[a-2 b-2], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-2 b-2], @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_match "2 gems installed", @ui.output
   end
@@ -732,7 +911,7 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:version] = Gem::Requirement.new("> 1")
 
     use_ui @ui do
-      e = assert_raises Gem::MockGemUi::TermError do
+      e = assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
 
@@ -750,28 +929,28 @@ ERROR:  Possible alternatives: non_exist
 
   def test_execute_two_version_specified_by_colon
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
-      fetcher.gem 'a', 2
-      fetcher.gem 'b', 1
-      fetcher.gem 'b', 2
+      fetcher.gem "a", 1
+      fetcher.gem "a", 2
+      fetcher.gem "b", 1
+      fetcher.gem "b", 2
     end
 
     @cmd.options[:args] = %w[a:1 b:1]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[a-1 b-1], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-1 b-1], @cmd.installed_specs.map {|spec| spec.full_name }
   end
 
   def test_execute_conservative
     spec_fetcher do |fetcher|
-      fetcher.download 'b', 2
+      fetcher.download "b", 2
 
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     @cmd.options[:conservative] = true
@@ -782,7 +961,7 @@ ERROR:  Possible alternatives: non_exist
       orig_dir = Dir.pwd
       begin
         Dir.chdir @tempdir
-        assert_raises Gem::MockGemUi::SystemExitException do
+        assert_raise Gem::MockGemUi::SystemExitException do
           @cmd.execute
         end
       ensure
@@ -790,7 +969,7 @@ ERROR:  Possible alternatives: non_exist
       end
     end
 
-    assert_equal %w[b-2], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[b-2], @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_equal "", @ui.error
     assert_match "1 gem installed", @ui.output
@@ -802,7 +981,7 @@ ERROR:  Possible alternatives: non_exist
       done_installing = true
     end
 
-    spec = util_spec 'a', 2
+    spec = util_spec "a", 2
 
     util_build_gem spec
 
@@ -810,44 +989,44 @@ ERROR:  Possible alternatives: non_exist
 
     @cmd.options[:ignore_dependencies] = true
 
-    @cmd.install_gem 'a', '>= 0'
+    @cmd.install_gem "a", ">= 0"
 
-    assert_equal %w[a-2], @cmd.installed_specs.map { |s| s.full_name }
+    assert_equal %w[a-2], @cmd.installed_specs.map {|s| s.full_name }
 
-    assert done_installing, 'documentation was not generated'
+    assert done_installing, "documentation was not generated"
   end
 
   def test_install_gem_ignore_dependencies_remote
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     @cmd.options[:ignore_dependencies] = true
 
-    @cmd.install_gem 'a', '>= 0'
+    @cmd.install_gem "a", ">= 0"
 
-    assert_equal %w[a-2], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-2], @cmd.installed_specs.map {|spec| spec.full_name }
   end
 
   def test_install_gem_ignore_dependencies_remote_platform_local
     local = Gem::Platform.local
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 3
+      fetcher.gem "a", 3
 
-      fetcher.gem 'a', 3 do |s|
+      fetcher.gem "a", 3 do |s|
         s.platform = local
       end
     end
 
     @cmd.options[:ignore_dependencies] = true
 
-    @cmd.install_gem 'a', '>= 0'
+    @cmd.install_gem "a", ">= 0"
 
-    assert_equal %W[a-3-#{local}], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %W[a-3-#{local}], @cmd.installed_specs.map {|spec| spec.full_name }
   end
 
   def test_install_gem_ignore_dependencies_specific_file
-    spec = util_spec 'a', 2
+    spec = util_spec "a", 2
 
     util_build_gem spec
 
@@ -857,13 +1036,13 @@ ERROR:  Possible alternatives: non_exist
 
     @cmd.install_gem File.join(@tempdir, spec.file_name), nil
 
-    assert_equal %w[a-2], @cmd.installed_specs.map { |s| s.full_name }
+    assert_equal %w[a-2], @cmd.installed_specs.map {|s| s.full_name }
   end
 
   def test_parses_requirement_from_gemname
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
-      fetcher.gem 'b', 2
+      fetcher.gem "a", 2
+      fetcher.gem "b", 2
     end
 
     @cmd.options[:domain] = :local
@@ -877,7 +1056,7 @@ ERROR:  Possible alternatives: non_exist
       orig_dir = Dir.pwd
       begin
         Dir.chdir @tempdir
-        e = assert_raises Gem::MockGemUi::TermError do
+        e = assert_raise Gem::MockGemUi::TermError do
           @cmd.execute
         end
       ensure
@@ -886,7 +1065,7 @@ ERROR:  Possible alternatives: non_exist
     end
 
     assert_equal 2, e.exit_code
-    assert_match %r!Could not find a valid gem 'a' \(= 10.0\)!, @ui.error
+    assert_match %r{Could not find a valid gem 'a' \(= 10.0\)}, @ui.error
   end
 
   def test_show_errors_on_failure
@@ -899,7 +1078,7 @@ ERROR:  Possible alternatives: non_exist
       orig_dir = Dir.pwd
       begin
         Dir.chdir @tempdir
-        e = assert_raises Gem::MockGemUi::TermError do
+        e = assert_raise Gem::MockGemUi::TermError do
           @cmd.execute
         end
       ensure
@@ -909,12 +1088,12 @@ ERROR:  Possible alternatives: non_exist
 
     assert_equal 2, e.exit_code
 
-    assert_match 'Unable to download data', @ui.error
+    assert_match "Unable to download data", @ui.error
   end
 
   def test_show_source_problems_even_on_success
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
+      fetcher.download "a", 2
     end
 
     Gem.sources << "http://nonexistent.example"
@@ -922,12 +1101,12 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:args] = %w[a]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[a-2], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-2], @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_match "1 gem installed", @ui.output
 
@@ -937,9 +1116,34 @@ ERROR:  Possible alternatives: non_exist
     assert_equal x, e
   end
 
+  def test_redact_credentials_from_uri_on_warning
+    spec_fetcher do |fetcher|
+      fetcher.download "a", 2
+    end
+
+    Gem.sources << "http://username:SECURE_TOKEN@nonexistent.example"
+
+    @cmd.options[:args] = %w[a]
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
+        @cmd.execute
+      end
+    end
+
+    assert_equal %w[a-2], @cmd.installed_specs.map {|spec| spec.full_name }
+
+    assert_match "1 gem installed", @ui.output
+
+    e = @ui.error
+
+    x = "WARNING:  Unable to pull data from 'http://username:REDACTED@nonexistent.example': no data for http://username:REDACTED@nonexistent.example/specs.4.8.gz (http://username:REDACTED@nonexistent.example/specs.4.8.gz)\n"
+    assert_equal x, e
+  end
+
   def test_execute_uses_from_a_gemdeps
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     File.open @gemdeps, "w" do |f|
@@ -949,12 +1153,12 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:gemdeps] = @gemdeps
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[], @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_match "Using a (2)", @ui.output
     assert File.exist?("#{@gemdeps}.lock")
@@ -962,7 +1166,7 @@ ERROR:  Possible alternatives: non_exist
 
   def test_execute_uses_from_a_gemdeps_with_no_lock
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     File.open @gemdeps, "w" do |f|
@@ -973,12 +1177,12 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:gemdeps] = @gemdeps
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[], @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_match "Using a (2)", @ui.output
     assert !File.exist?("#{@gemdeps}.lock")
@@ -986,8 +1190,8 @@ ERROR:  Possible alternatives: non_exist
 
   def test_execute_installs_from_a_gemdeps_with_conservative
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
-      fetcher.gem 'a', 1
+      fetcher.download "a", 2
+      fetcher.gem "a", 1
     end
 
     File.open @gemdeps, "w" do |f|
@@ -998,19 +1202,19 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:gemdeps] = @gemdeps
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[], @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_match "Using a (1)", @ui.output
   end
 
   def test_execute_installs_from_a_gemdeps
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
+      fetcher.download "a", 2
     end
 
     File.open @gemdeps, "w" do |f|
@@ -1020,20 +1224,20 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:gemdeps] = @gemdeps
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    assert_equal %w[a-2], @cmd.installed_specs.map { |spec| spec.full_name }
+    assert_equal %w[a-2], @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_match "Installing a (2)", @ui.output
   end
 
   def test_execute_installs_deps_a_gemdeps
     spec_fetcher do |fetcher|
-      fetcher.download 'q', '1.0'
-      fetcher.download 'r', '2.0', 'q' => nil
+      fetcher.download "q", "1.0"
+      fetcher.download "r", "2.0", "q" => nil
     end
 
     File.open @gemdeps, "w" do |f|
@@ -1043,12 +1247,12 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:gemdeps] = @gemdeps
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    names = @cmd.installed_specs.map { |spec| spec.full_name }
+    names = @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_equal %w[q-1.0 r-2.0], names
 
@@ -1058,9 +1262,9 @@ ERROR:  Possible alternatives: non_exist
 
   def test_execute_uses_deps_a_gemdeps
     spec_fetcher do |fetcher|
-      fetcher.download 'r', '2.0', 'q' => nil
+      fetcher.download "r", "2.0", "q" => nil
 
-      fetcher.spec 'q', '1.0'
+      fetcher.spec "q", "1.0"
     end
 
     File.open @gemdeps, "w" do |f|
@@ -1070,12 +1274,12 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:gemdeps] = @gemdeps
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    names = @cmd.installed_specs.map { |spec| spec.full_name }
+    names = @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_equal %w[r-2.0], names
 
@@ -1085,8 +1289,8 @@ ERROR:  Possible alternatives: non_exist
 
   def test_execute_installs_deps_a_gemdeps_into_a_path
     spec_fetcher do |fetcher|
-      fetcher.download 'q', '1.0'
-      fetcher.download 'r', '2.0', 'q' => nil
+      fetcher.download "q", "1.0"
+      fetcher.download "r", "2.0", "q" => nil
     end
 
     File.open @gemdeps, "w" do |f|
@@ -1097,12 +1301,12 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:gemdeps] = @gemdeps
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    names = @cmd.installed_specs.map { |spec| spec.full_name }
+    names = @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_equal %w[q-1.0 r-2.0], names
 
@@ -1115,11 +1319,11 @@ ERROR:  Possible alternatives: non_exist
 
   def test_execute_with_gemdeps_path_ignores_system
     specs = spec_fetcher do |fetcher|
-      fetcher.download 'q', '1.0'
-      fetcher.download 'r', '2.0', 'q' => nil
+      fetcher.download "q", "1.0"
+      fetcher.download "r", "2.0", "q" => nil
     end
 
-    install_specs specs['q-1.0']
+    install_specs specs["q-1.0"]
 
     File.open @gemdeps, "w" do |f|
       f << "gem 'r'"
@@ -1129,12 +1333,12 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:gemdeps] = @gemdeps
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    names = @cmd.installed_specs.map { |spec| spec.full_name }
+    names = @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_equal %w[q-1.0 r-2.0], names
 
@@ -1147,11 +1351,11 @@ ERROR:  Possible alternatives: non_exist
 
   def test_execute_uses_deps_a_gemdeps_with_a_path
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'q', '1.0'
-      fetcher.gem 'r', '2.0', 'q' => nil
+      fetcher.gem "q", "1.0"
+      fetcher.gem "r", "2.0", "q" => nil
     end
 
-    i = Gem::Installer.at specs['q-1.0'].cache_file, :install_dir => "gf-path"
+    i = Gem::Installer.at specs["q-1.0"].cache_file, :install_dir => "gf-path"
     i.install
 
     assert File.file?("gf-path/specifications/q-1.0.gemspec"), "not installed"
@@ -1164,12 +1368,12 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:gemdeps] = @gemdeps
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
 
-    names = @cmd.installed_specs.map { |spec| spec.full_name }
+    names = @cmd.installed_specs.map {|spec| spec.full_name }
 
     assert_equal %w[r-2.0], names
 
@@ -1178,39 +1382,39 @@ ERROR:  Possible alternatives: non_exist
   end
 
   def test_handle_options_file
-    FileUtils.touch 'Gemfile'
+    FileUtils.touch "Gemfile"
 
     @cmd.handle_options %w[-g Gemfile]
 
-    assert_equal 'Gemfile', @cmd.options[:gemdeps]
+    assert_equal "Gemfile", @cmd.options[:gemdeps]
 
-    FileUtils.rm 'Gemfile'
+    FileUtils.rm "Gemfile"
 
-    FileUtils.touch 'gem.deps.rb'
+    FileUtils.touch "gem.deps.rb"
 
     @cmd.handle_options %w[--file gem.deps.rb]
 
-    assert_equal 'gem.deps.rb', @cmd.options[:gemdeps]
+    assert_equal "gem.deps.rb", @cmd.options[:gemdeps]
 
-    FileUtils.rm 'gem.deps.rb'
+    FileUtils.rm "gem.deps.rb"
 
-    FileUtils.touch 'Isolate'
+    FileUtils.touch "Isolate"
 
     @cmd.handle_options %w[-g]
 
-    assert_equal 'Isolate', @cmd.options[:gemdeps]
+    assert_equal "Isolate", @cmd.options[:gemdeps]
 
-    FileUtils.touch 'Gemfile'
+    FileUtils.touch "Gemfile"
 
     @cmd.handle_options %w[-g]
 
-    assert_equal 'Gemfile', @cmd.options[:gemdeps]
+    assert_equal "Gemfile", @cmd.options[:gemdeps]
 
-    FileUtils.touch 'gem.deps.rb'
+    FileUtils.touch "gem.deps.rb"
 
     @cmd.handle_options %w[-g]
 
-    assert_equal 'gem.deps.rb', @cmd.options[:gemdeps]
+    assert_equal "gem.deps.rb", @cmd.options[:gemdeps]
   end
 
   def test_handle_options_suggest
@@ -1238,9 +1442,9 @@ ERROR:  Possible alternatives: non_exist
   def test_explain_platform_local
     local = Gem::Platform.local
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2
+      fetcher.spec "a", 2
 
-      fetcher.spec 'a', 2 do |s|
+      fetcher.spec "a", 2 do |s|
         s.platform = local
       end
     end
@@ -1249,7 +1453,7 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:args] = %w[a]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
@@ -1264,9 +1468,9 @@ ERROR:  Possible alternatives: non_exist
   def test_explain_platform_local_ignore_dependencies
     local = Gem::Platform.local
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 3
+      fetcher.spec "a", 3
 
-      fetcher.spec 'a', 3 do |s|
+      fetcher.spec "a", 3 do |s|
         s.platform = local
       end
     end
@@ -1276,7 +1480,7 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:args] = %w[a]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
@@ -1291,9 +1495,9 @@ ERROR:  Possible alternatives: non_exist
   def test_explain_platform_ruby
     local = Gem::Platform.local
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2
+      fetcher.spec "a", 2
 
-      fetcher.spec 'a', 2 do |s|
+      fetcher.spec "a", 2 do |s|
         s.platform = local
       end
     end
@@ -1305,7 +1509,7 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:args] = %w[a]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
@@ -1320,9 +1524,9 @@ ERROR:  Possible alternatives: non_exist
   def test_explain_platform_ruby_ignore_dependencies
     local = Gem::Platform.local
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 3
+      fetcher.spec "a", 3
 
-      fetcher.spec 'a', 3 do |s|
+      fetcher.spec "a", 3 do |s|
         s.platform = local
       end
     end
@@ -1335,7 +1539,7 @@ ERROR:  Possible alternatives: non_exist
     @cmd.options[:args] = %w[a]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::SystemExitException, @ui.error do
+      assert_raise Gem::MockGemUi::SystemExitException, @ui.error do
         @cmd.execute
       end
     end
@@ -1346,5 +1550,4 @@ ERROR:  Possible alternatives: non_exist
     assert_equal "  a-3", out.shift
     assert_empty out
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_list_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_list_command.rb
@@ -1,16 +1,15 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/list_command'
+require_relative "helper"
+require "rubygems/commands/list_command"
 
 class TestGemCommandsListCommand < Gem::TestCase
-
   def setup
     super
 
     @cmd = Gem::Commands::ListCommand.new
 
     spec_fetcher do |fetcher|
-      fetcher.spec 'c', 1
+      fetcher.spec "c", 1
     end
 
     @fetcher.data["#{@gem_repo}Marshal.#{Gem.marshal_version}"] = proc do
@@ -21,14 +20,13 @@ class TestGemCommandsListCommand < Gem::
   def test_execute_installed
     @cmd.handle_options %w[c --installed]
 
-    assert_raises Gem::MockGemUi::SystemExitException do
+    assert_raise Gem::MockGemUi::SystemExitException do
       use_ui @ui do
         @cmd.execute
       end
     end
 
     assert_equal "true\n", @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_lock_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_lock_command.rb
@@ -1,19 +1,18 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/lock_command'
+require_relative "helper"
+require "rubygems/commands/lock_command"
 
 class TestGemCommandsLockCommand < Gem::TestCase
-
   def setup
     super
 
-    @a1 = quick_gem 'a', '1'
-    @b1 = quick_gem 'b', '1' do |s|
-      s.add_runtime_dependency 'a'
+    @a1 = quick_gem "a", "1"
+    @b1 = quick_gem "b", "1" do |s|
+      s.add_runtime_dependency "a"
     end
 
-    @d1 = quick_gem 'd', '1' do |s|
-      s.add_runtime_dependency 'z'
+    @d1 = quick_gem "d", "1" do |s|
+      s.add_runtime_dependency "z"
     end
 
     @cmd = Gem::Commands::LockCommand.new
@@ -33,7 +32,7 @@ gem 'a', '= 1'
     EXPECTED
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_missing_dependency
@@ -50,19 +49,18 @@ gem 'd', '= 1'
     EXPECTED
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_strict
     @cmd.handle_options %w[c-1 --strict]
 
-    e = assert_raises Gem::Exception do
+    e = assert_raise Gem::Exception do
       use_ui @ui do
         @cmd.execute
       end
     end
 
-    assert_equal 'Could not find gem c-1, try using the full name', e.message
+    assert_equal "Could not find gem c-1, try using the full name", e.message
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_mirror.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_mirror.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/mirror_command'
+require_relative "helper"
+require "rubygems/commands/mirror_command"
 
 class TestGemCommandsMirrorCommand < Gem::TestCase
-
   def setup
     super
 
@@ -15,7 +14,6 @@ class TestGemCommandsMirrorCommand < Gem
       @cmd.execute
     end
 
-    assert_match %r%Install the rubygems-mirror%i, @ui.error
+    assert_match %r{Install the rubygems-mirror}i, @ui.error
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_open_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_open_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/open_command'
+require_relative "helper"
+require "rubygems/commands/open_command"
 
 class TestGemCommandsOpenCommand < Gem::TestCase
-
   def setup
     super
 
@@ -22,20 +21,19 @@ class TestGemCommandsOpenCommand < Gem::
 
   def test_execute
     @cmd.options[:args] = %w[foo]
-    @cmd.options[:editor] = "#{Gem.ruby} -e0 --"
+    @cmd.options[:editor] = "#{ruby_with_rubygems_in_load_path} -eexit --"
 
-    gem 'foo', '1.0.0'
-    spec = gem 'foo', '1.0.1'
-    mock = MiniTest::Mock.new
-    mock.expect(:call, true, [spec.full_gem_path])
+    gem "foo", "1.0.0"
+    spec = gem "foo", "1.0.1"
 
-    Dir.stub(:chdir, mock) do
-      use_ui @ui do
-        @cmd.execute
+    assert_nothing_raised Gem::MockGemUi::TermError do
+      Dir.stub(:chdir, spec.full_gem_path) do
+        use_ui @ui do
+          @cmd.execute
+        end
       end
     end
 
-    assert mock.verify
     assert_equal "", @ui.error
   end
 
@@ -45,26 +43,26 @@ class TestGemCommandsOpenCommand < Gem::
 
     gem "foo", "5.0"
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @ui do
         @cmd.execute
       end
     end
 
-    assert_match %r|Unable to find gem 'foo'|, @ui.output
+    assert_match %r{Unable to find gem 'foo'}, @ui.output
     assert_equal "", @ui.error
   end
 
   def test_execute_bad_gem
     @cmd.options[:args] = %w[foo]
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @ui do
         @cmd.execute
       end
     end
 
-    assert_match %r|Unable to find gem 'foo'|, @ui.output
+    assert_match %r{Unable to find gem 'foo'}, @ui.output
     assert_equal "", @ui.error
   end
 
@@ -87,14 +85,13 @@ class TestGemCommandsOpenCommand < Gem::
 
     gem("foo", "1.0")
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @ui do
         @cmd.execute
       end
     end
 
-    assert_match %r|'foo' is a default gem and can't be opened\.| , @ui.output
+    assert_match %r{'foo' is a default gem and can't be opened\.} , @ui.output
     assert_equal "", @ui.error
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_outdated_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_outdated_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/outdated_command'
+require_relative "helper"
+require "rubygems/commands/outdated_command"
 
 class TestGemCommandsOutdatedCommand < Gem::TestCase
-
   def setup
     super
 
@@ -16,10 +15,10 @@ class TestGemCommandsOutdatedCommand < G
 
   def test_execute
     spec_fetcher do |fetcher|
-      fetcher.download 'foo', '1.0'
-      fetcher.download 'foo', '2.0'
-      fetcher.gem 'foo', '0.1'
-      fetcher.gem 'foo', '0.2'
+      fetcher.download "foo", "1.0"
+      fetcher.download "foo", "2.0"
+      fetcher.gem "foo", "0.1"
+      fetcher.gem "foo", "0.2"
     end
 
     use_ui @ui do
@@ -30,4 +29,21 @@ class TestGemCommandsOutdatedCommand < G
     assert_equal "", @ui.error
   end
 
+  def test_execute_with_up_to_date_platform_specific_gem
+    spec_fetcher do |fetcher|
+      fetcher.download "foo", "2.0"
+
+      fetcher.gem "foo", "1.0"
+      fetcher.gem "foo", "2.0" do |s|
+        s.platform = Gem::Platform.local
+      end
+    end
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    assert_equal "", @ui.output
+    assert_equal "", @ui.error
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_owner_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_owner_command.rb
@@ -1,12 +1,13 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/owner_command'
+require_relative "helper"
+require "rubygems/commands/owner_command"
 
 class TestGemCommandsOwnerCommand < Gem::TestCase
-
   def setup
     super
 
+    credential_setup
+
     ENV["RUBYGEMS_HOST"] = nil
     @stub_ui = Gem::MockGemUi.new
     @stub_fetcher = Gem::FakeFetcher.new
@@ -17,6 +18,12 @@ class TestGemCommandsOwnerCommand < Gem:
     @cmd = Gem::Commands::OwnerCommand.new
   end
 
+  def teardown
+    credential_teardown
+
+    super
+  end
+
   def test_show_owners
     response = <<EOF
 ---
@@ -29,7 +36,7 @@ class TestGemCommandsOwnerCommand < Gem:
 - id: 4
 EOF
 
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners.yaml"] = [response, 200, 'OK']
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners.yaml"] = [response, 200, "OK"]
 
     use_ui @stub_ui do
       @cmd.show_owners("freewill")
@@ -46,7 +53,7 @@ EOF
   end
 
   def test_show_owners_dont_load_objects
-    skip "testing a psych-only API" unless defined?(::Psych::DisallowedClass)
+    pend "testing a psych-only API" unless defined?(::Psych::DisallowedClass)
 
     response = <<EOF
 ---
@@ -59,9 +66,9 @@ EOF
 - id: 4
 EOF
 
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners.yaml"] = [response, 200, 'OK']
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners.yaml"] = [response, 200, "OK"]
 
-    assert_raises Psych::DisallowedClass do
+    assert_raise Psych::DisallowedClass do
       use_ui @ui do
         @cmd.show_owners("freewill")
       end
@@ -73,7 +80,7 @@ EOF
     host = "http://rubygems.example"
     ENV["RUBYGEMS_HOST"] = host
 
-    @stub_fetcher.data["#{host}/api/v1/gems/freewill/owners.yaml"] = [response, 200, 'OK']
+    @stub_fetcher.data["#{host}/api/v1/gems/freewill/owners.yaml"] = [response, 200, "OK"]
 
     use_ui @stub_ui do
       @cmd.show_owners("freewill")
@@ -88,7 +95,7 @@ EOF
     host = "http://rubygems.example"
     @cmd.host = host
 
-    @stub_fetcher.data["#{host}/api/v1/gems/freewill/owners.yaml"] = [response, 200, 'OK']
+    @stub_fetcher.data["#{host}/api/v1/gems/freewill/owners.yaml"] = [response, 200, "OK"]
 
     use_ui @stub_ui do
       @cmd.show_owners("freewill")
@@ -100,9 +107,9 @@ EOF
 
   def test_show_owners_denied
     response = "You don't have permission to push to this gem"
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners.yaml"] = [response, 403, 'Forbidden']
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners.yaml"] = [response, 403, "Forbidden"]
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @stub_ui do
         @cmd.show_owners("freewill")
       end
@@ -113,21 +120,21 @@ EOF
 
   def test_show_owners_key
     response = "- email: user1@example.com\n"
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners.yaml"] = [response, 200, 'OK']
-    File.open Gem.configuration.credentials_path, 'a' do |f|
-      f.write ':other: 701229f217cdf23b1344c7b4b54ca97'
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners.yaml"] = [response, 200, "OK"]
+    File.open Gem.configuration.credentials_path, "a" do |f|
+      f.write ":other: 701229f217cdf23b1344c7b4b54ca97"
     end
     Gem.configuration.load_api_keys
 
-    @cmd.handle_options %w(-k other)
-    @cmd.show_owners('freewill')
+    @cmd.handle_options %w[-k other]
+    @cmd.show_owners("freewill")
 
-    assert_equal '701229f217cdf23b1344c7b4b54ca97', @stub_fetcher.last_request['Authorization']
+    assert_equal "701229f217cdf23b1344c7b4b54ca97", @stub_fetcher.last_request["Authorization"]
   end
 
   def test_add_owners
     response = "Owner added successfully."
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 200, 'OK']
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 200, "OK"]
 
     use_ui @stub_ui do
       @cmd.add_owners("freewill", ["user-new1@example.com"])
@@ -142,7 +149,7 @@ EOF
 
   def test_add_owners_denied
     response = "You don't have permission to push to this gem"
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 403, 'Forbidden']
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 403, "Forbidden"]
 
     use_ui @stub_ui do
       @cmd.add_owners("freewill", ["user-new1@example.com"])
@@ -155,8 +162,8 @@ EOF
     host = "http://rubygems.example"
     add_owner_response = "Owner added successfully."
     show_owners_response = "- email: user1@example.com\n"
-    @stub_fetcher.data["#{host}/api/v1/gems/freewill/owners"] = [add_owner_response, 200, 'OK']
-    @stub_fetcher.data["#{host}/api/v1/gems/freewill/owners.yaml"] = [show_owners_response, 200, 'OK']
+    @stub_fetcher.data["#{host}/api/v1/gems/freewill/owners"] = [add_owner_response, 200, "OK"]
+    @stub_fetcher.data["#{host}/api/v1/gems/freewill/owners.yaml"] = [show_owners_response, 200, "OK"]
 
     @cmd.handle_options %W[--host #{host} --add user-new1@example.com freewill]
 
@@ -171,21 +178,21 @@ EOF
 
   def test_add_owners_key
     response = "Owner added successfully."
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 200, 'OK']
-    File.open Gem.configuration.credentials_path, 'a' do |f|
-      f.write ':other: 701229f217cdf23b1344c7b4b54ca97'
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 200, "OK"]
+    File.open Gem.configuration.credentials_path, "a" do |f|
+      f.write ":other: 701229f217cdf23b1344c7b4b54ca97"
     end
     Gem.configuration.load_api_keys
 
-    @cmd.handle_options %w(-k other)
-    @cmd.add_owners('freewill', ['user-new1@example.com'])
+    @cmd.handle_options %w[-k other]
+    @cmd.add_owners("freewill", ["user-new1@example.com"])
 
-    assert_equal '701229f217cdf23b1344c7b4b54ca97', @stub_fetcher.last_request['Authorization']
+    assert_equal "701229f217cdf23b1344c7b4b54ca97", @stub_fetcher.last_request["Authorization"]
   end
 
   def test_remove_owners
     response = "Owner removed successfully."
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 200, 'OK']
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 200, "OK"]
 
     use_ui @stub_ui do
       @cmd.remove_owners("freewill", ["user-remove1@example.com"])
@@ -200,7 +207,7 @@ EOF
 
   def test_remove_owners_denied
     response = "You don't have permission to push to this gem"
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 403, 'Forbidden']
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 403, "Forbidden"]
 
     use_ui @stub_ui do
       @cmd.remove_owners("freewill", ["user-remove1@example.com"])
@@ -211,21 +218,21 @@ EOF
 
   def test_remove_owners_key
     response = "Owner removed successfully."
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 200, 'OK']
-    File.open Gem.configuration.credentials_path, 'a' do |f|
-      f.write ':other: 701229f217cdf23b1344c7b4b54ca97'
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 200, "OK"]
+    File.open Gem.configuration.credentials_path, "a" do |f|
+      f.write ":other: 701229f217cdf23b1344c7b4b54ca97"
     end
     Gem.configuration.load_api_keys
 
-    @cmd.handle_options %w(-k other)
-    @cmd.remove_owners('freewill', ['user-remove1@example.com'])
+    @cmd.handle_options %w[-k other]
+    @cmd.remove_owners("freewill", ["user-remove1@example.com"])
 
-    assert_equal '701229f217cdf23b1344c7b4b54ca97', @stub_fetcher.last_request['Authorization']
+    assert_equal "701229f217cdf23b1344c7b4b54ca97", @stub_fetcher.last_request["Authorization"]
   end
 
   def test_remove_owners_missing
-    response = 'Owner could not be found.'
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 404, 'Not Found']
+    response = "Owner could not be found."
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 404, "Not Found"]
 
     use_ui @stub_ui do
       @cmd.remove_owners("freewill", ["missing@example"])
@@ -239,8 +246,8 @@ EOF
     response_success = "Owner added successfully."
 
     @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [
-      [response_fail, 401, 'Unauthorized'],
-      [response_success, 200, 'OK']
+      [response_fail, 401, "Unauthorized"],
+      [response_success, 200, "OK"],
     ]
 
     @otp_ui = Gem::MockGemUi.new "111111\n"
@@ -248,15 +255,15 @@ EOF
       @cmd.add_owners("freewill", ["user-new1@example.com"])
     end
 
-    assert_match 'You have enabled multi-factor authentication. Please enter OTP code.', @otp_ui.output
-    assert_match 'Code: ', @otp_ui.output
+    assert_match "You have enabled multi-factor authentication. Please enter OTP code.", @otp_ui.output
+    assert_match "Code: ", @otp_ui.output
     assert_match response_success, @otp_ui.output
-    assert_equal '111111', @stub_fetcher.last_request['OTP']
+    assert_equal "111111", @stub_fetcher.last_request["OTP"]
   end
 
   def test_otp_verified_failure
     response = "You have enabled multifactor authentication but your request doesn't have the correct OTP code. Please check it and retry."
-    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 401, 'Unauthorized']
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [response, 401, "Unauthorized"]
 
     @otp_ui = Gem::MockGemUi.new "111111\n"
     use_ui @otp_ui do
@@ -264,9 +271,56 @@ EOF
     end
 
     assert_match response, @otp_ui.output
-    assert_match 'You have enabled multi-factor authentication. Please enter OTP code.', @otp_ui.output
-    assert_match 'Code: ', @otp_ui.output
-    assert_equal '111111', @stub_fetcher.last_request['OTP']
+    assert_match "You have enabled multi-factor authentication. Please enter OTP code.", @otp_ui.output
+    assert_match "Code: ", @otp_ui.output
+    assert_equal "111111", @stub_fetcher.last_request["OTP"]
   end
 
+  def test_remove_owners_unathorized_api_key
+    response_forbidden = "The API key doesn't have access"
+    response_success   = "Owner removed successfully."
+
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [
+      [response_forbidden, 403, "Forbidden"],
+      [response_success, 200, "OK"],
+    ]
+    @stub_fetcher.data["#{Gem.host}/api/v1/api_key"] = ["", 200, "OK"]
+    @cmd.instance_variable_set :@scope, :remove_owner
+
+    @stub_ui = Gem::MockGemUi.new "some@mail.com\npass\n"
+    use_ui @stub_ui do
+      @cmd.remove_owners("freewill", ["some@example"])
+    end
+
+    access_notice = "The existing key doesn't have access of remove_owner on RubyGems.org. Please sign in to update access."
+    assert_match access_notice, @stub_ui.output
+    assert_match "Email:", @stub_ui.output
+    assert_match "Password:", @stub_ui.output
+    assert_match "Added remove_owner scope to the existing API key", @stub_ui.output
+    assert_match response_success, @stub_ui.output
+  end
+
+  def test_add_owners_unathorized_api_key
+    response_forbidden = "The API key doesn't have access"
+    response_success   = "Owner added successfully."
+
+    @stub_fetcher.data["#{Gem.host}/api/v1/gems/freewill/owners"] = [
+      [response_forbidden, 403, "Forbidden"],
+      [response_success, 200, "OK"],
+    ]
+    @stub_fetcher.data["#{Gem.host}/api/v1/api_key"] = ["", 200, "OK"]
+    @cmd.instance_variable_set :@scope, :add_owner
+
+    @stub_ui = Gem::MockGemUi.new "some@mail.com\npass\n"
+    use_ui @stub_ui do
+      @cmd.add_owners("freewill", ["some@example"])
+    end
+
+    access_notice = "The existing key doesn't have access of add_owner on RubyGems.org. Please sign in to update access."
+    assert_match access_notice, @stub_ui.output
+    assert_match "Email:", @stub_ui.output
+    assert_match "Password:", @stub_ui.output
+    assert_match "Added add_owner scope to the existing API key", @stub_ui.output
+    assert_match response_success, @stub_ui.output
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_pristine_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_pristine_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/pristine_command'
+require_relative "helper"
+require "rubygems/commands/pristine_command"
 
 class TestGemCommandsPristineCommand < Gem::TestCase
-
   def setup
     super
     common_installer_setup
@@ -12,29 +11,29 @@ class TestGemCommandsPristineCommand < G
   end
 
   def test_execute
-    a = util_spec 'a' do |s|
+    a = util_spec "a" do |s|
       s.executables = %w[foo]
       s.files = %w[bin/foo lib/a.rb]
     end
 
-    write_file File.join(@tempdir, 'lib', 'a.rb') do |fp|
+    write_file File.join(@tempdir, "lib", "a.rb") do |fp|
       fp.puts "puts __FILE__"
     end
-    write_file File.join(@tempdir, 'bin', 'foo') do |fp|
+    write_file File.join(@tempdir, "bin", "foo") do |fp|
       fp.puts "#!/usr/bin/ruby"
     end
 
     install_gem a
 
-    foo_path  = File.join @gemhome, 'gems', a.full_name, 'bin', 'foo'
-    a_rb_path = File.join @gemhome, 'gems', a.full_name, 'lib', 'a.rb'
+    foo_path  = File.join @gemhome, "gems", a.full_name, "bin", "foo"
+    a_rb_path = File.join @gemhome, "gems", a.full_name, "lib", "a.rb"
 
     write_file foo_path do |io|
-      io.puts 'I changed it!'
+      io.puts "I changed it!"
     end
 
     write_file a_rb_path do |io|
-      io.puts 'I changed it!'
+      io.puts "I changed it!"
     end
 
     @cmd.options[:args] = %w[a]
@@ -103,18 +102,18 @@ class TestGemCommandsPristineCommand < G
   end
 
   def test_execute_all
-    a = util_spec 'a' do |s|
+    a = util_spec "a" do |s|
       s.executables = %w[foo]
     end
 
-    write_file File.join(@tempdir, 'bin', 'foo') do |fp|
+    write_file File.join(@tempdir, "bin", "foo") do |fp|
       fp.puts "#!/usr/bin/ruby"
     end
 
     install_gem a
 
-    gem_bin  = File.join @gemhome, 'gems', a.full_name, 'bin', 'foo'
-    gem_stub = File.join @gemhome, 'bin', 'foo'
+    gem_bin  = File.join @gemhome, "gems", a.full_name, "bin", "foo"
+    gem_stub = File.join @gemhome, "bin", "foo"
 
     FileUtils.rm gem_bin
     FileUtils.rm gem_stub
@@ -136,17 +135,17 @@ class TestGemCommandsPristineCommand < G
   end
 
   def test_execute_env_shebang
-    a = util_spec 'a' do |s|
+    a = util_spec "a" do |s|
       s.executables = %w[foo]
       s.files = %w[bin/foo]
     end
-    write_file File.join(@tempdir, 'bin', 'foo') do |fp|
+    write_file File.join(@tempdir, "bin", "foo") do |fp|
       fp.puts "#!/usr/bin/ruby"
     end
 
     install_gem a
 
-    gem_exec = File.join @gemhome, 'bin', 'foo'
+    gem_exec = File.join @gemhome, "bin", "foo"
 
     FileUtils.rm gem_exec
 
@@ -156,23 +155,21 @@ class TestGemCommandsPristineCommand < G
       @cmd.execute
     end
 
-    assert_path_exists gem_exec
+    assert_path_exist gem_exec
 
-    ruby_exec = sprintf Gem.default_exec_format, 'ruby'
+    ruby_exec = sprintf Gem.default_exec_format, "ruby"
 
-    if win_platform?
-      assert_match %r%\A#!\s*#{ruby_exec}%, File.read(gem_exec)
-    else
-      assert_match %r%\A#!\s*/usr/bin/env #{ruby_exec}%, File.read(gem_exec)
-    end
+    bin_env = win_platform? ? "" : %w[/usr/bin/env /bin/env].find {|f| File.executable?(f) } + " "
+
+    assert_match %r{\A#!\s*#{bin_env}#{ruby_exec}}, File.read(gem_exec)
   end
 
   def test_execute_extensions_explicit
-    a = util_spec 'a' do |s|
-      s.extensions << 'ext/a/extconf.rb'
+    a = util_spec "a" do |s|
+      s.extensions << "ext/a/extconf.rb"
     end
 
-    ext_path = File.join @tempdir, 'ext', 'a', 'extconf.rb'
+    ext_path = File.join @tempdir, "ext", "a", "extconf.rb"
     write_file ext_path do |io|
       io.write <<-'RUBY'
       File.open "Makefile", "w" do |f|
@@ -183,7 +180,7 @@ class TestGemCommandsPristineCommand < G
       RUBY
     end
 
-    b = util_spec 'b'
+    b = util_spec "b"
 
     install_gem a
     install_gem b
@@ -198,24 +195,23 @@ class TestGemCommandsPristineCommand < G
 
     out = @ui.output.split "\n"
 
-    assert_equal 'Restoring gems to pristine condition...', out.shift
-    assert_equal 'Building native extensions. This could take a while...',
+    assert_equal "Restoring gems to pristine condition...", out.shift
+    assert_equal "Building native extensions. This could take a while...",
                  out.shift
     assert_equal "Restored #{a.full_name}", out.shift
     assert_empty out, out.inspect
   end
 
   def test_execute_no_extension
-    a = util_spec 'a' do |s|
-      s.extensions << 'ext/a/extconf.rb'
+    a = util_spec "a" do |s|
+      s.extensions << "ext/a/extconf.rb"
     end
 
-    ext_path = File.join @tempdir, 'ext', 'a', 'extconf.rb'
+    ext_path = File.join @tempdir, "ext", "a", "extconf.rb"
     write_file ext_path do |io|
       io.write "# extconf.rb\nrequire 'mkmf'; create_makefile 'a'"
     end
 
-    util_build_gem a
     install_gem a
 
     @cmd.options[:args] = %w[a]
@@ -227,18 +223,18 @@ class TestGemCommandsPristineCommand < G
 
     out = @ui.output.split "\n"
 
-    assert_equal 'Restoring gems to pristine condition...', out.shift
+    assert_equal "Restoring gems to pristine condition...", out.shift
     assert_equal "Skipped #{a.full_name}, it needs to compile an extension",
                  out.shift
     assert_empty out, out.inspect
   end
 
   def test_execute_with_extension_with_build_args
-    a = util_spec 'a' do |s|
-      s.extensions << 'ext/a/extconf.rb'
+    a = util_spec "a" do |s|
+      s.extensions << "ext/a/extconf.rb"
     end
 
-    ext_path = File.join @tempdir, 'ext', 'a', 'extconf.rb'
+    ext_path = File.join @tempdir, "ext", "a", "extconf.rb"
     write_file ext_path do |io|
       io.write <<-'RUBY'
       File.open "Makefile", "w" do |f|
@@ -249,7 +245,7 @@ class TestGemCommandsPristineCommand < G
       RUBY
     end
 
-    build_args = %w!--with-awesome=true --sweet!
+    build_args = %w[--with-awesome=true --sweet]
 
     install_gem a, :build_args => build_args
 
@@ -261,7 +257,7 @@ class TestGemCommandsPristineCommand < G
 
     out = @ui.output.split "\n"
 
-    assert_equal 'Restoring gems to pristine condition...', out.shift
+    assert_equal "Restoring gems to pristine condition...", out.shift
     assert_equal "Building native extensions with: '--with-awesome=true --sweet'", out.shift
     assert_equal "This could take a while...", out.shift
     assert_equal "Restored #{a.full_name}", out.shift
@@ -269,8 +265,8 @@ class TestGemCommandsPristineCommand < G
   end
 
   def test_execute_many
-    a = util_spec 'a'
-    b = util_spec 'b'
+    a = util_spec "a"
+    b = util_spec "b"
 
     install_gem a
     install_gem b
@@ -290,14 +286,14 @@ class TestGemCommandsPristineCommand < G
   end
 
   def test_skip
-    a = util_spec 'a'
-    b = util_spec 'b'
+    a = util_spec "a"
+    b = util_spec "b"
 
     install_gem a
     install_gem b
 
     @cmd.options[:args] = %w[a b]
-    @cmd.options[:skip] = 'a'
+    @cmd.options[:skip] = "a"
 
     use_ui @ui do
       @cmd.execute
@@ -312,16 +308,16 @@ class TestGemCommandsPristineCommand < G
   end
 
   def test_skip_many_gems
-    a = util_spec 'a'
-    b = util_spec 'b'
-    c = util_spec 'c'
+    a = util_spec "a"
+    b = util_spec "b"
+    c = util_spec "c"
 
     install_gem a
     install_gem b
     install_gem c
 
     @cmd.options[:args] = %w[a b c]
-    @cmd.options[:skip] = ['a', 'c']
+    @cmd.options[:skip] = ["a", "c"]
 
     use_ui @ui do
       @cmd.execute
@@ -337,14 +333,14 @@ class TestGemCommandsPristineCommand < G
   end
 
   def test_execute_many_multi_repo
-    a = util_spec 'a'
+    a = util_spec "a"
     install_gem a
 
     Gem.clear_paths
-    gemhome2 = File.join @tempdir, 'gemhome2'
+    gemhome2 = File.join @tempdir, "gemhome2"
     Gem.use_paths gemhome2, [gemhome2, @gemhome]
 
-    b = util_spec 'b'
+    b = util_spec "b"
     install_gem b
 
     @cmd.options[:args] = %w[a b]
@@ -360,21 +356,21 @@ class TestGemCommandsPristineCommand < G
     assert_equal "Restored #{b.full_name}", out.shift
     assert_empty out, out.inspect
 
-    assert_path_exists File.join(@gemhome, "gems", 'a-2')
-    refute_path_exists File.join(gemhome2, "gems", 'a-2')
-    assert_path_exists File.join(gemhome2, "gems", 'b-2')
-    refute_path_exists File.join(@gemhome, "gems", 'b-2')
+    assert_path_exist File.join(@gemhome, "gems", "a-2")
+    assert_path_not_exist File.join(gemhome2, "gems", "a-2")
+    assert_path_exist File.join(gemhome2, "gems", "b-2")
+    assert_path_not_exist File.join(@gemhome, "gems", "b-2")
   end
 
   def test_execute_missing_cache_gem
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
-      fetcher.gem 'a', 2
-      fetcher.gem 'a', 3
-      fetcher.gem 'a', '3.a'
+      fetcher.gem "a", 1
+      fetcher.gem "a", 2
+      fetcher.gem "a", 3
+      fetcher.gem "a", "3.a"
     end
 
-    FileUtils.rm specs['a-2'].cache_file
+    FileUtils.rm specs["a-2"].cache_file
 
     @cmd.options[:args] = %w[a]
 
@@ -400,22 +396,23 @@ class TestGemCommandsPristineCommand < G
 
   def test_execute_missing_cache_gem_when_multi_repo
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
-      fetcher.gem 'b', 1
+      fetcher.gem "a", 1
+      fetcher.gem "b", 1
     end
 
-    FileUtils.rm_rf File.join(@gemhome, 'gems', 'a-1')
-    FileUtils.rm_rf File.join(@gemhome, 'gems', 'b-1')
+    FileUtils.rm_rf File.join(@gemhome, "gems", "a-1")
+    FileUtils.rm_rf File.join(@gemhome, "gems", "b-1")
 
     install_gem specs["a-1"]
-    FileUtils.rm File.join(@gemhome, 'cache', 'a-1.gem')
+    FileUtils.rm File.join(@gemhome, "cache", "a-1.gem")
 
     Gem.clear_paths
-    gemhome2 = File.join(@tempdir, 'gemhome2')
+    gemhome2 = File.join(@tempdir, "gemhome2")
     Gem.use_paths gemhome2, [gemhome2, @gemhome]
 
     install_gem specs["b-1"]
-    FileUtils.rm File.join(gemhome2, 'cache', 'b-1.gem')
+    FileUtils.rm File.join(gemhome2, "cache", "b-1.gem")
+    Gem::Specification.reset
 
     @cmd.options[:args] = %w[a b]
 
@@ -438,45 +435,45 @@ class TestGemCommandsPristineCommand < G
     assert_empty out, out.inspect
     assert_empty @ui.error
 
-    assert_path_exists File.join(@gemhome, "cache", 'a-1.gem')
-    refute_path_exists File.join(gemhome2, "cache", 'a-2.gem')
-    assert_path_exists File.join(@gemhome, "gems", 'a-1')
-    refute_path_exists File.join(gemhome2, "gems", 'a-1')
-
-    assert_path_exists File.join(gemhome2, "cache", 'b-1.gem')
-    refute_path_exists File.join(@gemhome, "cache", 'b-2.gem')
-    assert_path_exists File.join(gemhome2, "gems", 'b-1')
-    refute_path_exists File.join(@gemhome, "gems", 'b-1')
+    assert_path_exist File.join(@gemhome, "cache", "a-1.gem")
+    assert_path_not_exist File.join(gemhome2, "cache", "a-2.gem")
+    assert_path_exist File.join(@gemhome, "gems", "a-1")
+    assert_path_not_exist File.join(gemhome2, "gems", "a-1")
+
+    assert_path_exist File.join(gemhome2, "cache", "b-1.gem")
+    assert_path_not_exist File.join(@gemhome, "cache", "b-2.gem")
+    assert_path_exist File.join(gemhome2, "gems", "b-1")
+    assert_path_not_exist File.join(@gemhome, "gems", "b-1")
   end
 
   def test_execute_no_gem
     @cmd.options[:args] = %w[]
 
-    e = assert_raises Gem::CommandLineError do
+    e = assert_raise Gem::CommandLineError do
       use_ui @ui do
         @cmd.execute
       end
     end
 
-    assert_match %r|at least one gem name|, e.message
+    assert_match %r{at least one gem name}, e.message
   end
 
   def test_execute_only_executables
-    a = util_spec 'a' do |s|
+    a = util_spec "a" do |s|
       s.executables = %w[foo]
       s.files = %w[bin/foo lib/a.rb]
     end
-    write_file File.join(@tempdir, 'lib', 'a.rb') do |fp|
+    write_file File.join(@tempdir, "lib", "a.rb") do |fp|
       fp.puts "puts __FILE__"
     end
-    write_file File.join(@tempdir, 'bin', 'foo') do |fp|
+    write_file File.join(@tempdir, "bin", "foo") do |fp|
       fp.puts "#!/usr/bin/ruby"
     end
 
     install_gem a
 
-    gem_lib  = File.join @gemhome, 'gems', a.full_name, 'lib', 'a.rb'
-    gem_exec = File.join @gemhome, 'bin', 'foo'
+    gem_lib  = File.join @gemhome, "gems", a.full_name, "lib", "a.rb"
+    gem_exec = File.join @gemhome, "bin", "foo"
 
     FileUtils.rm gem_exec
     FileUtils.rm gem_lib
@@ -491,25 +488,61 @@ class TestGemCommandsPristineCommand < G
     refute File.exist? gem_lib
   end
 
+  def test_execute_only_plugins
+    a = util_spec "a" do |s|
+      s.executables = %w[foo]
+      s.files = %w[bin/foo lib/a.rb lib/rubygems_plugin.rb]
+    end
+    write_file File.join(@tempdir, "lib", "a.rb") do |fp|
+      fp.puts "puts __FILE__"
+    end
+    write_file File.join(@tempdir, "lib", "rubygems_plugin.rb") do |fp|
+      fp.puts "puts __FILE__"
+    end
+    write_file File.join(@tempdir, "bin", "foo") do |fp|
+      fp.puts "#!/usr/bin/ruby"
+    end
+
+    install_gem a
+
+    gem_lib = File.join @gemhome, "gems", a.full_name, "lib", "a.rb"
+    gem_plugin = File.join @gemhome, "plugins", "a_plugin.rb"
+    gem_exec = File.join @gemhome, "bin", "foo"
+
+    FileUtils.rm gem_exec
+    FileUtils.rm gem_plugin
+    FileUtils.rm gem_lib
+
+    @cmd.handle_options %w[--all --only-plugins]
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    refute File.exist? gem_exec
+    assert File.exist? gem_plugin
+    refute File.exist? gem_lib
+  end
+
   def test_execute_bindir
-    a = util_spec 'a' do |s|
+    a = util_spec "a" do |s|
       s.name = "test_gem"
       s.executables = %w[foo]
       s.files = %w[bin/foo]
     end
 
-    write_file File.join(@tempdir, 'bin', 'foo') do |fp|
+    write_file File.join(@tempdir, "bin", "foo") do |fp|
       fp.puts "#!/usr/bin/ruby"
     end
 
-    write_file File.join(@tempdir, 'test_bin', 'foo') do |fp|
+    write_file File.join(@tempdir, "test_bin", "foo") do |fp|
       fp.puts "#!/usr/bin/ruby"
     end
 
     install_gem a
 
-    gem_exec = File.join @gemhome, 'bin', 'foo'
-    gem_bindir = File.join @tempdir, 'test_bin', 'foo'
+    gem_exec = File.join @gemhome, "bin", "foo"
+    gem_bindir = File.join @tempdir, "test_bin", "foo"
 
     FileUtils.rm gem_exec
     FileUtils.rm gem_bindir
@@ -525,7 +558,7 @@ class TestGemCommandsPristineCommand < G
   end
 
   def test_execute_unknown_gem_at_remote_source
-    install_specs util_spec 'a'
+    install_specs util_spec "a"
 
     @cmd.options[:args] = %w[a]
 
@@ -536,7 +569,7 @@ class TestGemCommandsPristineCommand < G
     assert_equal([
       "Restoring gems to pristine condition...",
       "Cached gem for a-2 not found, attempting to fetch...",
-      "Skipped a-2, it was not found from cache and remote sources"
+      "Skipped a-2, it was not found from cache and remote sources",
     ], @ui.output.split("\n"))
 
     assert_empty @ui.error
@@ -545,7 +578,7 @@ class TestGemCommandsPristineCommand < G
   def test_execute_default_gem
     default_gem_spec = new_default_spec("default", "2.0.0.0",
                                         nil, "default/gem.rb")
-    install_default_specs(default_gem_spec)
+    install_default_gems(default_gem_spec)
 
     @cmd.options[:args] = %w[default]
 
@@ -564,16 +597,16 @@ class TestGemCommandsPristineCommand < G
   end
 
   def test_execute_multi_platform
-    a = util_spec 'a' do |s|
-      s.extensions << 'ext/a/extconf.rb'
+    a = util_spec "a" do |s|
+      s.extensions << "ext/a/extconf.rb"
     end
 
-    b = util_spec 'b' do |s|
-      s.extensions << 'ext/a/extconf.rb'
+    b = util_spec "b" do |s|
+      s.extensions << "ext/a/extconf.rb"
       s.platform = Gem::Platform.new("java")
     end
 
-    ext_path = File.join @tempdir, 'ext', 'a', 'extconf.rb'
+    ext_path = File.join @tempdir, "ext", "a", "extconf.rb"
     write_file ext_path do |io|
       io.write <<-'RUBY'
       File.open "Makefile", "w" do |f|
@@ -599,8 +632,8 @@ class TestGemCommandsPristineCommand < G
 
     out = @ui.output.split "\n"
 
-    assert_equal 'Restoring gems to pristine condition...', out.shift
-    assert_equal 'Building native extensions. This could take a while...',
+    assert_equal "Restoring gems to pristine condition...", out.shift
+    assert_equal "Building native extensions. This could take a while...",
                  out.shift
     assert_equal "Restored #{a.full_name}", out.shift
     assert_empty out, out.inspect
@@ -623,5 +656,4 @@ class TestGemCommandsPristineCommand < G
     assert @cmd.options[:extensions]
     assert @cmd.options[:extensions_set]
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_push_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_push_command.rb
@@ -1,16 +1,18 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/push_command'
+require_relative "helper"
+require "rubygems/commands/push_command"
 
 class TestGemCommandsPushCommand < Gem::TestCase
-
   def setup
     super
+
+    credential_setup
+
     ENV["RUBYGEMS_HOST"] = nil
     Gem.host = Gem::DEFAULT_HOST
     Gem.configuration.disable_default_gem_server = false
 
-    @gems_dir  = File.join @tempdir, 'gems'
+    @gems_dir  = File.join @tempdir, "gems"
     @cache_dir = File.join @gemhome, "cache"
 
     FileUtils.mkdir @gems_dir
@@ -19,7 +21,7 @@ class TestGemCommandsPushCommand < Gem::
       "ed244fbf2b1a52e012da8616c512fa47f9aa5250"
 
     @spec, @path = util_gem "freewill", "1.0.0"
-    @host = 'https://rubygems.example'
+    @host = "https://rubygems.example"
     @api_key = Gem.configuration.rubygems_api_key
 
     @fetcher = Gem::FakeFetcher.new
@@ -37,6 +39,8 @@ class TestGemCommandsPushCommand < Gem::
   end
 
   def teardown
+    credential_teardown
+
     super
 
     singleton_gem_class.class_eval do
@@ -64,7 +68,7 @@ class TestGemCommandsPushCommand < Gem::
 
   def test_execute
     @response = "Successfully registered gem: freewill (1.0.0)"
-    @fetcher.data["#{Gem.host}/api/v1/gems"] = [@response, 200, 'OK']
+    @fetcher.data["#{Gem.host}/api/v1/gems"] = [@response, 200, "OK"]
 
     @cmd.options[:args] = [@path]
 
@@ -77,12 +81,12 @@ class TestGemCommandsPushCommand < Gem::
   end
 
   def test_execute_host
-    host = 'https://other.example'
+    host = "https://other.example"
 
     @response = "Successfully registered gem: freewill (1.0.0)"
-    @fetcher.data["#{host}/api/v1/gems"] = [@response, 200, 'OK']
+    @fetcher.data["#{host}/api/v1/gems"] = [@response, 200, "OK"]
     @fetcher.data["#{Gem.host}/api/v1/gems"] =
-      ['fail', 500, 'Internal Server Error']
+      ["fail", 500, "Internal Server Error"]
 
     @cmd.options[:host] = host
     @cmd.options[:args] = [@path]
@@ -97,13 +101,13 @@ class TestGemCommandsPushCommand < Gem::
 
   def test_execute_allowed_push_host
     @spec, @path = util_gem "freebird", "1.0.1" do |spec|
-      spec.metadata['allowed_push_host'] = "https://privategemserver.example"
+      spec.metadata["allowed_push_host"] = "https://privategemserver.example"
     end
 
     @response = "Successfully registered gem: freewill (1.0.0)"
-    @fetcher.data["#{@spec.metadata['allowed_push_host']}/api/v1/gems"] = [@response, 200, 'OK']
+    @fetcher.data["#{@spec.metadata['allowed_push_host']}/api/v1/gems"] = [@response, 200, "OK"]
     @fetcher.data["#{Gem.host}/api/v1/gems"] =
-      ['fail', 500, 'Internal Server Error']
+      ["fail", 500, "Internal Server Error"]
 
     @cmd.options[:args] = [@path]
 
@@ -119,7 +123,7 @@ class TestGemCommandsPushCommand < Gem::
     Gem.configuration.disable_default_gem_server = true
     response = "You must specify a gem server"
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @ui do
         @cmd.send_gem(@path)
       end
@@ -132,7 +136,7 @@ class TestGemCommandsPushCommand < Gem::
     ENV["RUBYGEMS_HOST"] = @host
     Gem.configuration.disable_default_gem_server = true
     @response = "Successfully registered gem: freewill (1.0.0)"
-    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, 'OK']
+    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, "OK"]
 
     send_battery
   end
@@ -141,18 +145,17 @@ class TestGemCommandsPushCommand < Gem::
     @host = "http://privategemserver.example"
 
     @spec, @path = util_gem "freebird", "1.0.1" do |spec|
-      spec.metadata['default_gem_server'] = @host
+      spec.metadata["default_gem_server"] = @host
     end
 
     @api_key = "EYKEY"
 
     keys = {
-      :rubygems_api_key => 'KEY',
-      @host => @api_key
+      :rubygems_api_key => "KEY",
+      @host => @api_key,
     }
 
-    FileUtils.mkdir_p File.dirname Gem.configuration.credentials_path
-    File.open Gem.configuration.credentials_path, 'w' do |f|
+    File.open Gem.configuration.credentials_path, "w" do |f|
       f.write keys.to_yaml
     end
     Gem.configuration.load_api_keys
@@ -160,14 +163,14 @@ class TestGemCommandsPushCommand < Gem::
     FileUtils.rm Gem.configuration.credentials_path
 
     @response = "Successfully registered gem: freebird (1.0.1)"
-    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, 'OK']
+    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, "OK"]
 
     send_battery
   end
 
   def test_sending_gem
     @response = "Successfully registered gem: freewill (1.0.0)"
-    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, 'OK']
+    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, "OK"]
 
     send_battery
   end
@@ -176,18 +179,17 @@ class TestGemCommandsPushCommand < Gem::
     @host = "http://privategemserver.example"
 
     @spec, @path = util_gem "freebird", "1.0.1" do |spec|
-      spec.metadata['allowed_push_host'] = @host
+      spec.metadata["allowed_push_host"] = @host
     end
 
     @api_key = "PRIVKEY"
 
     keys = {
-      :rubygems_api_key => 'KEY',
-      @host => @api_key
+      :rubygems_api_key => "KEY",
+      @host => @api_key,
     }
 
-    FileUtils.mkdir_p File.dirname Gem.configuration.credentials_path
-    File.open Gem.configuration.credentials_path, 'w' do |f|
+    File.open Gem.configuration.credentials_path, "w" do |f|
       f.write keys.to_yaml
     end
     Gem.configuration.load_api_keys
@@ -195,7 +197,7 @@ class TestGemCommandsPushCommand < Gem::
     FileUtils.rm Gem.configuration.credentials_path
 
     @response = "Successfully registered gem: freebird (1.0.1)"
-    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, 'OK']
+    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, "OK"]
     send_battery
   end
 
@@ -203,14 +205,14 @@ class TestGemCommandsPushCommand < Gem::
     @host = "http://privategemserver.example"
 
     @spec, @path = util_gem "freebird", "1.0.1" do |spec|
-      spec.metadata['allowed_push_host'] = @host
+      spec.metadata["allowed_push_host"] = @host
     end
 
     @api_key = "PRIVKEY"
     ENV["GEM_HOST_API_KEY"] = "PRIVKEY"
 
     @response = "Successfully registered gem: freebird (1.0.1)"
-    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, 'OK']
+    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, "OK"]
     send_battery
   end
 
@@ -219,7 +221,7 @@ class TestGemCommandsPushCommand < Gem::
     @host           = "http://user:password@privategemserver.example"
 
     @spec, @path = util_gem "freebird", "1.0.1" do |spec|
-      spec.metadata['allowed_push_host'] = @sanitized_host
+      spec.metadata["allowed_push_host"] = @sanitized_host
     end
 
     @api_key = "DOESNTMATTER"
@@ -228,8 +230,7 @@ class TestGemCommandsPushCommand < Gem::
       :rubygems_api_key => @api_key,
     }
 
-    FileUtils.mkdir_p File.dirname Gem.configuration.credentials_path
-    File.open Gem.configuration.credentials_path, 'w' do |f|
+    File.open Gem.configuration.credentials_path, "w" do |f|
       f.write keys.to_yaml
     end
     Gem.configuration.load_api_keys
@@ -237,18 +238,18 @@ class TestGemCommandsPushCommand < Gem::
     FileUtils.rm Gem.configuration.credentials_path
 
     @response = "Successfully registered gem: freebird (1.0.1)"
-    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, 'OK']
+    @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, "OK"]
     send_battery
   end
 
   def test_sending_gem_to_disallowed_default_host
     @spec, @path = util_gem "freebird", "1.0.1" do |spec|
-      spec.metadata['allowed_push_host'] = "https://privategemserver.example"
+      spec.metadata["allowed_push_host"] = "https://privategemserver.example"
     end
 
-    response = %{ERROR:  "#{@host}" is not allowed by the gemspec, which only allows "https://privategemserver.example"}
+    response = %(ERROR:  "#{@host}" is not allowed by the gemspec, which only allows "https://privategemserver.example")
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       send_battery
     end
 
@@ -260,18 +261,17 @@ class TestGemCommandsPushCommand < Gem::
     push_host = "https://privategemserver.example"
 
     @spec, @path = util_gem "freebird", "1.0.1" do |spec|
-      spec.metadata['allowed_push_host'] = push_host
+      spec.metadata["allowed_push_host"] = push_host
     end
 
     @api_key = "PRIVKEY"
 
     keys = {
-      :rubygems_api_key => 'KEY',
-      @host => @api_key
+      :rubygems_api_key => "KEY",
+      @host => @api_key,
     }
 
-    FileUtils.mkdir_p File.dirname Gem.configuration.credentials_path
-    File.open Gem.configuration.credentials_path, 'w' do |f|
+    File.open Gem.configuration.credentials_path, "w" do |f|
       f.write keys.to_yaml
     end
     Gem.configuration.load_api_keys
@@ -280,7 +280,7 @@ class TestGemCommandsPushCommand < Gem::
 
     response = "ERROR:  \"#{@host}\" is not allowed by the gemspec, which only allows \"#{push_host}\""
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       send_battery
     end
 
@@ -291,18 +291,17 @@ class TestGemCommandsPushCommand < Gem::
     host = "http://privategemserver.example"
 
     @spec, @path = util_gem "freebird", "1.0.1" do |spec|
-      spec.metadata.delete('default_gem_server')
-      spec.metadata['allowed_push_host'] = host
+      spec.metadata.delete("default_gem_server")
+      spec.metadata["allowed_push_host"] = host
     end
 
     api_key = "PRIVKEY"
 
     keys = {
-      host => api_key
+      host => api_key,
     }
 
-    FileUtils.mkdir_p File.dirname Gem.configuration.credentials_path
-    File.open Gem.configuration.credentials_path, 'w' do |f|
+    File.open Gem.configuration.credentials_path, "w" do |f|
       f.write keys.to_yaml
     end
     Gem.configuration.load_api_keys
@@ -310,7 +309,7 @@ class TestGemCommandsPushCommand < Gem::
     FileUtils.rm Gem.configuration.credentials_path
 
     @response = "Successfully registered gem: freebird (1.0.1)"
-    @fetcher.data["#{host}/api/v1/gems"] = [@response, 200, 'OK']
+    @fetcher.data["#{host}/api/v1/gems"] = [@response, 200, "OK"]
 
     # do not set @host
     use_ui(@ui) { @cmd.send_gem(@path) }
@@ -328,17 +327,17 @@ class TestGemCommandsPushCommand < Gem::
 
   def test_raises_error_with_no_arguments
     def @cmd.sign_in(*); end
-    assert_raises Gem::CommandLineError do
+    assert_raise Gem::CommandLineError do
       @cmd.execute
     end
   end
 
   def test_sending_gem_denied
     response = "You don't have permission to push to this gem"
-    @fetcher.data["#{@host}/api/v1/gems"] = [response, 403, 'Forbidden']
+    @fetcher.data["#{@host}/api/v1/gems"] = [response, 403, "Forbidden"]
     @cmd.instance_variable_set :@host, @host
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @ui do
         @cmd.send_gem(@path)
       end
@@ -350,12 +349,12 @@ class TestGemCommandsPushCommand < Gem::
   def test_sending_gem_key
     @response = "Successfully registered gem: freewill (1.0.0)"
     @fetcher.data["#{@host}/api/v1/gems"] = [@response, 200, "OK"]
-    File.open Gem.configuration.credentials_path, 'a' do |f|
-      f.write ':other: 701229f217cdf23b1344c7b4b54ca97'
+    File.open Gem.configuration.credentials_path, "a" do |f|
+      f.write ":other: 701229f217cdf23b1344c7b4b54ca97"
     end
     Gem.configuration.load_api_keys
 
-    @cmd.handle_options %w(-k other)
+    @cmd.handle_options %w[-k other]
     @cmd.instance_variable_set :@host, @host
     @cmd.send_gem(@path)
 
@@ -365,11 +364,11 @@ class TestGemCommandsPushCommand < Gem::
 
   def test_otp_verified_success
     response_fail = "You have enabled multifactor authentication but your request doesn't have the correct OTP code. Please check it and retry."
-    response_success = 'Successfully registered gem: freewill (1.0.0)'
+    response_success = "Successfully registered gem: freewill (1.0.0)"
 
     @fetcher.data["#{Gem.host}/api/v1/gems"] = [
-      [response_fail, 401, 'Unauthorized'],
-      [response_success, 200, 'OK']
+      [response_fail, 401, "Unauthorized"],
+      [response_success, 200, "OK"],
     ]
 
     @otp_ui = Gem::MockGemUi.new "111111\n"
@@ -377,27 +376,97 @@ class TestGemCommandsPushCommand < Gem::
       @cmd.send_gem(@path)
     end
 
-    assert_match 'You have enabled multi-factor authentication. Please enter OTP code.', @otp_ui.output
-    assert_match 'Code: ', @otp_ui.output
+    assert_match "You have enabled multi-factor authentication. Please enter OTP code.", @otp_ui.output
+    assert_match "Code: ", @otp_ui.output
     assert_match response_success, @otp_ui.output
-    assert_equal '111111', @fetcher.last_request['OTP']
+    assert_equal "111111", @fetcher.last_request["OTP"]
   end
 
   def test_otp_verified_failure
     response = "You have enabled multifactor authentication but your request doesn't have the correct OTP code. Please check it and retry."
-    @fetcher.data["#{Gem.host}/api/v1/gems"] = [response, 401, 'Unauthorized']
+    @fetcher.data["#{Gem.host}/api/v1/gems"] = [response, 401, "Unauthorized"]
 
     @otp_ui = Gem::MockGemUi.new "111111\n"
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @otp_ui do
         @cmd.send_gem(@path)
       end
     end
 
     assert_match response, @otp_ui.output
-    assert_match 'You have enabled multi-factor authentication. Please enter OTP code.', @otp_ui.output
-    assert_match 'Code: ', @otp_ui.output
-    assert_equal '111111', @fetcher.last_request['OTP']
+    assert_match "You have enabled multi-factor authentication. Please enter OTP code.", @otp_ui.output
+    assert_match "Code: ", @otp_ui.output
+    assert_equal "111111", @fetcher.last_request["OTP"]
+  end
+
+  def test_sending_gem_unathorized_api_key_with_mfa_enabled
+    response_mfa_enabled = "You have enabled multifactor authentication but your request doesn't have the correct OTP code. Please check it and retry."
+    response_forbidden = "The API key doesn't have access"
+    response_success   = "Successfully registered gem: freewill (1.0.0)"
+
+    @fetcher.data["#{@host}/api/v1/gems"] = [
+      [response_mfa_enabled, 401, "Unauthorized"],
+      [response_forbidden, 403, "Forbidden"],
+      [response_success, 200, "OK"],
+    ]
+
+    @fetcher.data["#{@host}/api/v1/api_key"] = ["", 200, "OK"]
+    @cmd.instance_variable_set :@host, @host
+    @cmd.instance_variable_set :@scope, :push_rubygem
+
+    @ui = Gem::MockGemUi.new "11111\nsome@mail.com\npass\n"
+    use_ui @ui do
+      @cmd.send_gem(@path)
+    end
+
+    mfa_notice = "You have enabled multi-factor authentication. Please enter OTP code."
+    access_notice = "The existing key doesn't have access of push_rubygem on https://rubygems.example. Please sign in to update access."
+    assert_match mfa_notice, @ui.output
+    assert_match access_notice, @ui.output
+    assert_match "Email:", @ui.output
+    assert_match "Password:", @ui.output
+    assert_match "Added push_rubygem scope to the existing API key", @ui.output
+    assert_match response_success, @ui.output
+    assert_equal "11111", @fetcher.last_request["OTP"]
+  end
+
+  def test_sending_gem_with_no_local_creds
+    Gem.configuration.rubygems_api_key = nil
+
+    response_mfa_enabled = "You have enabled multifactor authentication but your request doesn't have the correct OTP code. Please check it and retry."
+    response_success     = "Successfully registered gem: freewill (1.0.0)"
+    response_profile     = "mfa: disabled\n"
+
+    @fetcher.data["#{@host}/api/v1/gems"] = [
+      [response_success, 200, "OK"],
+    ]
+
+    @fetcher.data["#{@host}/api/v1/api_key"] = [
+      [response_mfa_enabled, 401, "Unauthorized"],
+      ["", 200, "OK"],
+    ]
+
+    @fetcher.data["#{@host}/api/v1/profile/me.yaml"] = [
+      [response_profile, 200, "OK"],
+    ]
+
+    @cmd.instance_variable_set :@scope, :push_rubygem
+    @cmd.options[:args] = [@path]
+    @cmd.options[:host] = @host
+
+    @ui = Gem::MockGemUi.new "some@mail.com\npass\n11111\n"
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    mfa_notice = "You have enabled multi-factor authentication. Please enter OTP code."
+    assert_match mfa_notice, @ui.output
+    assert_match "Enter your https://rubygems.example credentials.", @ui.output
+    assert_match "Email:", @ui.output
+    assert_match "Password:", @ui.output
+    assert_match "Signed in with API key:", @ui.output
+    assert_match response_success, @ui.output
+    assert_equal "11111", @fetcher.last_request["OTP"]
   end
 
   private
@@ -405,5 +474,4 @@ class TestGemCommandsPushCommand < Gem::
   def singleton_gem_class
     class << Gem; self; end
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_query_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_query_command.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/query_command'
+require_relative "helper"
+require "rubygems/commands/query_command"
 
 module TestGemCommandsQueryCommandSetup
   def setup
@@ -19,7 +19,6 @@ module TestGemCommandsQueryCommandSetup
 end
 
 class TestGemCommandsQueryCommandWithInstalledGems < Gem::TestCase
-
   include TestGemCommandsQueryCommandSetup
 
   def test_execute
@@ -42,7 +41,7 @@ pl (1 i386-linux)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_all
@@ -65,7 +64,7 @@ pl (1 i386-linux)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_all_prerelease
@@ -88,15 +87,15 @@ pl (1 i386-linux)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_details
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2 do |s|
-        s.summary = 'This is a lot of text. ' * 4
-        s.authors = ['Abraham Lincoln', 'Hirohito']
-        s.homepage = 'http://a.example.com/'
+      fetcher.spec "a", 2 do |s|
+        s.summary = "This is a lot of text. " * 4
+        s.authors = ["Abraham Lincoln", "Hirohito"]
+        s.homepage = "http://a.example.com/"
       end
 
       fetcher.legacy_platform
@@ -128,13 +127,13 @@ pl (1)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_details_cleans_text
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2 do |s|
-        s.summary = 'This is a lot of text. ' * 4
+      fetcher.spec "a", 2 do |s|
+        s.summary = "This is a lot of text. " * 4
         s.authors = ["Abraham Lincoln \x01", "\x02 Hirohito"]
         s.homepage = "http://a.example.com/\x03"
       end
@@ -168,13 +167,13 @@ pl (1)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_details_truncates_summary
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2 do |s|
-        s.summary = 'This is a lot of text. ' * 10_000
+      fetcher.spec "a", 2 do |s|
+        s.summary = "This is a lot of text. " * 10_000
         s.authors = ["Abraham Lincoln \x01", "\x02 Hirohito"]
         s.homepage = "http://a.example.com/\x03"
       end
@@ -208,33 +207,33 @@ pl (1)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_installed
     @cmd.handle_options %w[-n a --installed]
 
-    assert_raises Gem::MockGemUi::SystemExitException do
+    assert_raise Gem::MockGemUi::SystemExitException do
       use_ui @stub_ui do
         @cmd.execute
       end
     end
 
     assert_equal "true\n", @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_installed_inverse
     @cmd.handle_options %w[-n a --no-installed]
 
-    e = assert_raises Gem::MockGemUi::TermError do
+    e = assert_raise Gem::MockGemUi::TermError do
       use_ui @stub_ui do
         @cmd.execute
       end
     end
 
     assert_equal "false\n", @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
 
     assert_equal 1, e.exit_code
   end
@@ -242,26 +241,26 @@ pl (1)
   def test_execute_installed_inverse_not_installed
     @cmd.handle_options %w[-n not_installed --no-installed]
 
-    assert_raises Gem::MockGemUi::SystemExitException do
+    assert_raise Gem::MockGemUi::SystemExitException do
       use_ui @stub_ui do
         @cmd.execute
       end
     end
 
     assert_equal "true\n", @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_installed_no_name
     @cmd.handle_options %w[--installed]
 
-    e = assert_raises Gem::MockGemUi::TermError do
+    e = assert_raise Gem::MockGemUi::TermError do
       use_ui @stub_ui do
         @cmd.execute
       end
     end
 
-    assert_equal '', @stub_ui.output
+    assert_equal "", @stub_ui.output
     assert_equal "ERROR:  You must specify a gem name\n", @stub_ui.error
 
     assert_equal 4, e.exit_code
@@ -270,14 +269,14 @@ pl (1)
   def test_execute_installed_not_installed
     @cmd.handle_options %w[-n not_installed --installed]
 
-    e = assert_raises Gem::MockGemUi::TermError do
+    e = assert_raise Gem::MockGemUi::TermError do
       use_ui @stub_ui do
         @cmd.execute
       end
     end
 
     assert_equal "false\n", @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
 
     assert_equal 1, e.exit_code
   end
@@ -285,27 +284,27 @@ pl (1)
   def test_execute_installed_version
     @cmd.handle_options %w[-n a --installed --version 2]
 
-    assert_raises Gem::MockGemUi::SystemExitException do
+    assert_raise Gem::MockGemUi::SystemExitException do
       use_ui @stub_ui do
         @cmd.execute
       end
     end
 
     assert_equal "true\n", @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_installed_version_not_installed
     @cmd.handle_options %w[-n c --installed --version 2]
 
-    e = assert_raises Gem::MockGemUi::TermError do
+    e = assert_raise Gem::MockGemUi::TermError do
       use_ui @stub_ui do
         @cmd.execute
       end
     end
 
     assert_equal "false\n", @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
 
     assert_equal 1, e.exit_code
   end
@@ -330,7 +329,7 @@ pl (1 i386-linux)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_local_notty
@@ -352,7 +351,7 @@ pl (1 i386-linux)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_local_quiet
@@ -373,7 +372,7 @@ pl (1 i386-linux)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_no_versions
@@ -396,7 +395,7 @@ pl
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_notty
@@ -418,7 +417,7 @@ pl (1 i386-linux)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_prerelease
@@ -436,7 +435,7 @@ a (3.a)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_prerelease_local
@@ -503,7 +502,7 @@ pl (1 i386-linux)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_remote_notty
@@ -525,7 +524,7 @@ pl (1 i386-linux)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_remote_quiet
@@ -546,16 +545,16 @@ pl (1 i386-linux)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_make_entry
-    a_2_name = @specs['a-2'].original_name
+    a_2_name = @specs["a-2"].original_name
 
     @stub_fetcher.data.delete \
       "#{@gem_repo}quick/Marshal.#{Gem.marshal_version}/#{a_2_name}.gemspec.rz"
 
-    a2 = @specs['a-2']
+    a2 = @specs["a-2"]
     entry_tuples = [
       [Gem::NameTuple.new(a2.name, a2.version, a2.platform),
        Gem.sources.first],
@@ -565,7 +564,7 @@ pl (1 i386-linux)
 
     entry = @cmd.send :make_entry, entry_tuples, platforms
 
-    assert_equal 'a (2)', entry
+    assert_equal "a (2)", entry
   end
 
   # Test for multiple args handling!
@@ -580,9 +579,9 @@ pl (1 i386-linux)
       @cmd.execute
     end
 
-    assert_match %r%^a %, @stub_ui.output
-    assert_match %r%^pl %, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_match %r{^a }, @stub_ui.output
+    assert_match %r{^pl }, @stub_ui.output
+    assert_equal "", @stub_ui.error
   end
 
   def test_show_gems
@@ -593,8 +592,8 @@ pl (1 i386-linux)
       @cmd.send :show_gems, /a/i
     end
 
-    assert_match %r%^a %,  @stub_ui.output
-    refute_match %r%^pl %, @stub_ui.output
+    assert_match %r{^a },  @stub_ui.output
+    refute_match %r{^pl }, @stub_ui.output
     assert_empty @stub_ui.error
   end
 
@@ -602,27 +601,25 @@ pl (1 i386-linux)
 
   def add_gems_to_fetcher
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', 2
-      fetcher.spec 'a', '3.a'
+      fetcher.spec "a", 1
+      fetcher.spec "a", 2
+      fetcher.spec "a", "3.a"
     end
   end
-
 end
 
 class TestGemCommandsQueryCommandWithoutInstalledGems < Gem::TestCase
-
   include TestGemCommandsQueryCommandSetup
 
   def test_execute_platform
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', 1 do |s|
-        s.platform = 'x86-linux'
+      fetcher.spec "a", 1
+      fetcher.spec "a", 1 do |s|
+        s.platform = "x86-linux"
       end
 
-      fetcher.spec 'a', 2 do |s|
-        s.platform = 'universal-darwin'
+      fetcher.spec "a", 2 do |s|
+        s.platform = "universal-darwin"
       end
     end
 
@@ -640,14 +637,14 @@ a (2 universal-darwin, 1 ruby x86-linux)
     EOF
 
     assert_equal expected, @stub_ui.output
-    assert_equal '', @stub_ui.error
+    assert_equal "", @stub_ui.error
   end
 
   def test_execute_show_default_gems
-    spec_fetcher { |fetcher| fetcher.spec 'a', 2 }
+    spec_fetcher {|fetcher| fetcher.spec "a", 2 }
 
-    a1 = new_default_spec 'a', 1
-    install_default_specs a1
+    a1 = new_default_spec "a", 1
+    install_default_gems a1
 
     use_ui @stub_ui do
       @cmd.execute
@@ -664,9 +661,9 @@ EOF
   end
 
   def test_execute_show_default_gems_with_platform
-    a1 = new_default_spec 'a', 1
-    a1.platform = 'java'
-    install_default_specs a1
+    a1 = new_default_spec "a", 1
+    a1.platform = "java"
+    install_default_gems a1
 
     use_ui @stub_ui do
       @cmd.execute
@@ -684,11 +681,11 @@ EOF
 
   def test_execute_default_details
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2
+      fetcher.spec "a", 2
     end
 
-    a1 = new_default_spec 'a', 1
-    install_default_specs a1
+    a1 = new_default_spec "a", 1
+    install_default_gems a1
 
     @cmd.handle_options %w[-l -d]
 
@@ -714,15 +711,15 @@ a (2, 1)
 
   def test_execute_local_details
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1 do |s|
-        s.platform = 'x86-linux'
+      fetcher.spec "a", 1 do |s|
+        s.platform = "x86-linux"
       end
 
-      fetcher.spec 'a', 2 do |s|
-        s.summary = 'This is a lot of text. ' * 4
-        s.authors = ['Abraham Lincoln', 'Hirohito']
-        s.homepage = 'http://a.example.com/'
-        s.platform = 'universal-darwin'
+      fetcher.spec "a", 2 do |s|
+        s.summary = "This is a lot of text. " * 4
+        s.authors = ["Abraham Lincoln", "Hirohito"]
+        s.homepage = "http://a.example.com/"
+        s.platform = "universal-darwin"
       end
 
       fetcher.legacy_platform
@@ -769,9 +766,9 @@ pl (1)
 
   def test_execute_exact_remote
     spec_fetcher do |fetcher|
-      fetcher.spec 'coolgem-omg', 3
-      fetcher.spec 'coolgem', '4.2.1'
-      fetcher.spec 'wow_coolgem', 1
+      fetcher.spec "coolgem-omg", 3
+      fetcher.spec "coolgem", "4.2.1"
+      fetcher.spec "wow_coolgem", 1
     end
 
     @cmd.handle_options %w[--remote --exact coolgem]
@@ -792,9 +789,9 @@ coolgem (4.2.1)
 
   def test_execute_exact_local
     spec_fetcher do |fetcher|
-      fetcher.spec 'coolgem-omg', 3
-      fetcher.spec 'coolgem', '4.2.1'
-      fetcher.spec 'wow_coolgem', 1
+      fetcher.spec "coolgem-omg", 3
+      fetcher.spec "coolgem", "4.2.1"
+      fetcher.spec "wow_coolgem", 1
     end
 
     @cmd.handle_options %w[--exact coolgem]
@@ -815,13 +812,13 @@ coolgem (4.2.1)
 
   def test_execute_exact_multiple
     spec_fetcher do |fetcher|
-      fetcher.spec 'coolgem-omg', 3
-      fetcher.spec 'coolgem', '4.2.1'
-      fetcher.spec 'wow_coolgem', 1
-
-      fetcher.spec 'othergem-omg', 3
-      fetcher.spec 'othergem', '1.2.3'
-      fetcher.spec 'wow_othergem', 1
+      fetcher.spec "coolgem-omg", 3
+      fetcher.spec "coolgem", "4.2.1"
+      fetcher.spec "wow_coolgem", 1
+
+      fetcher.spec "othergem-omg", 3
+      fetcher.spec "othergem", "1.2.3"
+      fetcher.spec "wow_othergem", 1
     end
 
     @cmd.handle_options %w[--exact coolgem othergem]
@@ -844,14 +841,17 @@ othergem (1.2.3)
     assert_equal expected, @stub_ui.output
   end
 
+  def test_depprecated
+    assert @cmd.deprecated?
+  end
+
   private
 
   def add_gems_to_fetcher
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 1
-      fetcher.download 'a', 2
-      fetcher.download 'a', '3.a'
+      fetcher.download "a", 1
+      fetcher.download "a", 2
+      fetcher.download "a", "3.a"
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_search_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_search_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/search_command'
+require_relative "helper"
+require "rubygems/commands/search_command"
 
 class TestGemCommandsSearchCommand < Gem::TestCase
-
   def setup
     super
 
@@ -13,5 +12,4 @@ class TestGemCommandsSearchCommand < Gem
   def test_initialize
     assert_equal :remote, @cmd.defaults[:domain]
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_server_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_server_command.rb
@@ -1,63 +1,19 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/server_command'
+require_relative "helper"
+require "rubygems/commands/server_command"
 
 class TestGemCommandsServerCommand < Gem::TestCase
-
   def setup
     super
 
     @cmd = Gem::Commands::ServerCommand.new
   end
 
-  def test_handle_options
-    @cmd.send :handle_options, %w[-p 8808 --no-daemon]
-
-    assert_equal false, @cmd.options[:daemon]
-    assert_equal [], @cmd.options[:gemdir]
-    assert_equal 8808, @cmd.options[:port]
-
-    @cmd.send :handle_options, %w[-p 9999 -d /nonexistent --daemon]
-
-    assert_equal true, @cmd.options[:daemon]
-    assert_equal [File.expand_path('/nonexistent')], @cmd.options[:gemdir]
-    assert_equal 9999, @cmd.options[:port]
-  end
-
-  def test_handle_options_gemdir
-    @cmd.send :handle_options, %w[--dir a --dir b]
-
-    assert_equal [File.expand_path('a'), File.expand_path('b')],
-                 @cmd.options[:gemdir]
-  end
-
-  def test_handle_options_port
-    @cmd.send :handle_options, %w[-p 0]
-    assert_equal 0, @cmd.options[:port]
-
-    @cmd.send :handle_options, %w[-p 65535]
-    assert_equal 65535, @cmd.options[:port]
-
-    begin
-      @cmd.send :handle_options, %w[-p discard]
-      assert_equal 9, @cmd.options[:port]
-    rescue OptionParser::InvalidArgument
-      # for container environment on GitHub Actions
-    end
-
-    e = assert_raises OptionParser::InvalidArgument do
-      @cmd.send :handle_options, %w[-p nonexistent]
+  def test_execute
+    use_ui @ui do
+      @cmd.execute
     end
 
-    assert_equal 'invalid argument: -p nonexistent: no such named service',
-                 e.message
-
-    e = assert_raises OptionParser::InvalidArgument do
-      @cmd.send :handle_options, %w[-p 65536]
-    end
-
-    assert_equal 'invalid argument: -p 65536: not a port number',
-                 e.message
+    assert_match %r{Install the rubygems-server}i, @ui.error
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_setup_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_setup_command.rb
@@ -1,12 +1,10 @@
-# coding: UTF-8
 # frozen_string_literal: true
 
-require 'rubygems/test_case'
-require 'rubygems/commands/setup_command'
+require_relative "helper"
+require "rubygems/commands/setup_command"
 
 class TestGemCommandsSetupCommand < Gem::TestCase
-
-  bundler_gemspec = File.expand_path("../../../bundler/lib/bundler/version.rb", __FILE__)
+  bundler_gemspec = File.expand_path("../../bundler/lib/bundler/version.rb", __dir__)
   if File.exist?(bundler_gemspec)
     BUNDLER_VERS = File.read(bundler_gemspec).match(/VERSION = "(#{Gem::Version::VERSION_PATTERN})"/)[1]
   else
@@ -16,92 +14,56 @@ class TestGemCommandsSetupCommand < Gem:
   def setup
     super
 
-    @install_dir = File.join @tempdir, 'install'
     @cmd = Gem::Commands::SetupCommand.new
-    @cmd.options[:prefix] = @install_dir
-
-    FileUtils.mkdir_p 'bin'
-    FileUtils.mkdir_p 'lib/rubygems/ssl_certs/rubygems.org'
 
-    File.open 'bin/gem',                   'w' do
-      |io| io.puts '# gem'
-    end
-
-    File.open 'lib/rubygems.rb',           'w' do |io|
-      io.puts '# rubygems.rb'
-    end
-
-    File.open 'lib/rubygems/test_case.rb', 'w' do |io|
-      io.puts '# test_case.rb'
-    end
-
-    File.open 'lib/rubygems/ssl_certs/rubygems.org/foo.pem', 'w' do |io|
-      io.puts 'PEM'
-    end
+    filelist = %w[
+      bin/gem
+      lib/rubygems.rb
+      lib/rubygems/requirement.rb
+      lib/rubygems/ssl_certs/rubygems.org/foo.pem
+      bundler/exe/bundle
+      bundler/exe/bundler
+      bundler/lib/bundler.rb
+      bundler/lib/bundler/b.rb
+      bundler/bin/bundler/man/bundle-b.1
+      bundler/lib/bundler/man/bundle-b.1.ronn
+      bundler/lib/bundler/man/gemfile.5
+      bundler/lib/bundler/man/gemfile.5.ronn
+      bundler/lib/bundler/templates/.circleci/config.yml
+      bundler/lib/bundler/templates/.travis.yml
+    ]
 
-    FileUtils.mkdir_p 'bundler/exe'
-    FileUtils.mkdir_p 'bundler/lib/bundler'
-
-    File.open 'bundler/exe/bundle',        'w' do |io|
-      io.puts '# bundle'
-    end
-
-    File.open 'bundler/lib/bundler.rb',    'w' do |io|
-      io.puts '# bundler.rb'
-    end
-
-    File.open 'bundler/lib/bundler/b.rb',  'w' do |io|
-      io.puts '# b.rb'
-    end
-
-    FileUtils.mkdir_p 'default/gems'
+    create_dummy_files(filelist)
 
     gemspec = Gem::Specification.new
     gemspec.author = "Us"
     gemspec.name = "bundler"
     gemspec.version = BUNDLER_VERS
     gemspec.bindir = "exe"
-    gemspec.executables = ["bundle"]
+    gemspec.executables = ["bundle", "bundler"]
 
-    File.open 'bundler/bundler.gemspec',   'w' do |io|
+    File.open "bundler/bundler.gemspec", "w" do |io|
       io.puts gemspec.to_ruby
     end
 
-    open(File.join(Gem.default_specifications_dir, "bundler-1.15.4.gemspec"), 'w') do |io|
+    File.open(File.join(Gem.default_specifications_dir, "bundler-1.15.4.gemspec"), "w") do |io|
       gemspec.version = "1.15.4"
       io.puts gemspec.to_ruby
     end
 
-    FileUtils.mkdir_p File.join(Gem.default_dir, "specifications")
-
-    open(File.join(Gem.default_dir, "specifications", "bundler-#{BUNDLER_VERS}.gemspec"), 'w') do |io|
-      io.puts "# bundler-#{BUNDLER_VERS}"
-    end
-
-    open(File.join(Gem.default_dir, "specifications", "bundler-audit-1.0.0.gemspec"), 'w') do |io|
-      io.puts '# bundler-audit'
-    end
+    spec_fetcher do |fetcher|
+      fetcher.download "bundler", "1.15.4"
 
-    FileUtils.mkdir_p 'default/gems/bundler-1.15.4'
-    FileUtils.mkdir_p 'default/gems/bundler-audit-1.0.0'
-  end
+      fetcher.gem "bundler", bundler_version
 
-  def gem_install(name)
-    gem = util_spec name do |s|
-      s.executables = [name]
-      s.files = %W[bin/#{name}]
-    end
-    write_file File.join @tempdir, 'bin', name do |f|
-      f.puts '#!/usr/bin/ruby'
+      fetcher.gem "bundler-audit", "1.0.0"
     end
-    install_gem gem
-    File.join @gemhome, 'bin', name
   end
 
   def test_execute_regenerate_binstubs
-    gem_bin_path = gem_install 'a'
+    gem_bin_path = gem_install "a"
     write_file gem_bin_path do |io|
-      io.puts 'I changed it!'
+      io.puts "I changed it!"
     end
 
     @cmd.options[:document] = []
@@ -111,9 +73,9 @@ class TestGemCommandsSetupCommand < Gem:
   end
 
   def test_execute_no_regenerate_binstubs
-    gem_bin_path = gem_install 'a'
+    gem_bin_path = gem_install "a"
     write_file gem_bin_path do |io|
-      io.puts 'I changed it!'
+      io.puts "I changed it!"
     end
 
     @cmd.options[:document] = []
@@ -123,7 +85,46 @@ class TestGemCommandsSetupCommand < Gem:
     assert_equal "I changed it!\n", File.read(gem_bin_path)
   end
 
+  def test_execute_regenerate_plugins
+    gem_plugin_path = gem_install_with_plugin "a"
+    write_file gem_plugin_path do |io|
+      io.puts "I changed it!"
+    end
+
+    @cmd.options[:document] = []
+    @cmd.execute
+
+    assert_match %r{\Arequire}, File.read(gem_plugin_path)
+  end
+
+  def test_execute_no_regenerate_plugins
+    gem_plugin_path = gem_install_with_plugin "a"
+    write_file gem_plugin_path do |io|
+      io.puts "I changed it!"
+    end
+
+    @cmd.options[:document] = []
+    @cmd.options[:regenerate_plugins] = false
+    @cmd.execute
+
+    assert_equal "I changed it!\n", File.read(gem_plugin_path)
+  end
+
+  def test_execute_regenerate_plugins_creates_plugins_dir_if_not_there
+    gem_plugin_path = gem_install_with_plugin "a"
+
+    # Simulate gem installed with an older rubygems without a plugins layout
+    FileUtils.rm_rf Gem.plugindir
+
+    @cmd.options[:document] = []
+    @cmd.execute
+
+    assert_match %r{\Arequire}, File.read(gem_plugin_path)
+  end
+
   def test_execute_informs_about_installed_executables
+    @cmd.options[:document] = []
+
     use_ui @ui do
       @cmd.execute
     end
@@ -133,207 +134,260 @@ class TestGemCommandsSetupCommand < Gem:
     exec_line = out.shift until exec_line == "RubyGems installed the following executables:"
     assert_equal "\t#{default_gem_bin_path}", out.shift
     assert_equal "\t#{default_bundle_bin_path}", out.shift
+    assert_equal "\t#{default_bundler_bin_path}", out.shift
   end
 
   def test_env_shebang_flag
-    gem_bin_path = gem_install 'a'
+    gem_bin_path = gem_install "a"
     write_file gem_bin_path do |io|
-      io.puts 'I changed it!'
+      io.puts "I changed it!"
     end
 
     @cmd.options[:document] = []
     @cmd.options[:env_shebang] = true
     @cmd.execute
 
-    ruby_exec = sprintf Gem.default_exec_format, 'ruby'
+    ruby_exec = sprintf Gem.default_exec_format, "ruby"
 
-    if Gem.win_platform?
-      assert_match %r%\A#!\s*#{ruby_exec}%, File.read(default_gem_bin_path)
-      assert_match %r%\A#!\s*#{ruby_exec}%, File.read(default_bundle_bin_path)
-      assert_match %r%\A#!\s*#{ruby_exec}%, File.read(gem_bin_path)
-    else
-      assert_match %r%\A#!/usr/bin/env #{ruby_exec}%, File.read(default_gem_bin_path)
-      assert_match %r%\A#!/usr/bin/env #{ruby_exec}%, File.read(default_bundle_bin_path)
-      assert_match %r%\A#!/usr/bin/env #{ruby_exec}%, File.read(gem_bin_path)
-    end
+    bin_env = win_platform? ? "" : %w[/usr/bin/env /bin/env].find {|f| File.executable?(f) } + " "
+    assert_match %r{\A#!\s*#{bin_env}#{ruby_exec}}, File.read(default_gem_bin_path)
+    assert_match %r{\A#!\s*#{bin_env}#{ruby_exec}}, File.read(default_bundle_bin_path)
+    assert_match %r{\A#!\s*#{bin_env}#{ruby_exec}}, File.read(default_bundler_bin_path)
+    assert_match %r{\A#!\s*#{bin_env}#{ruby_exec}}, File.read(gem_bin_path)
   end
 
-  def test_pem_files_in
-    assert_equal %w[rubygems/ssl_certs/rubygems.org/foo.pem],
-                 @cmd.pem_files_in('lib').sort
+  def test_destdir_flag_does_not_try_to_write_to_the_default_gem_home
+    FileUtils.chmod "-w", File.join(@gemhome, "plugins")
+
+    destdir = File.join(@tempdir, "foo")
+
+    @cmd.options[:destdir] = destdir
+    @cmd.execute
+
+    bundler_spec.executables.each do |e|
+      assert_path_exist prepend_destdir(destdir, File.join(@gemhome, "gems", bundler_spec.full_name, bundler_spec.bindir, e))
+    end
   end
 
-  def test_rb_files_in
-    assert_equal %w[rubygems.rb rubygems/test_case.rb],
-                 @cmd.rb_files_in('lib').sort
+  def test_files_in
+    assert_equal %w[rubygems.rb rubygems/requirement.rb rubygems/ssl_certs/rubygems.org/foo.pem],
+                 @cmd.files_in("lib").sort
   end
 
   def test_install_lib
     @cmd.extend FileUtils
 
-    Dir.mktmpdir 'lib' do |dir|
+    Dir.mktmpdir "lib" do |dir|
       @cmd.install_lib dir
 
-      assert_path_exists File.join(dir, 'rubygems.rb')
-      assert_path_exists File.join(dir, 'rubygems/ssl_certs/rubygems.org/foo.pem')
+      assert_path_exist File.join(dir, "rubygems.rb")
+      assert_path_exist File.join(dir, "rubygems/ssl_certs/rubygems.org/foo.pem")
+
+      assert_path_exist File.join(dir, "bundler.rb")
+      assert_path_exist File.join(dir, "bundler/b.rb")
 
-      assert_path_exists File.join(dir, 'bundler.rb')
-      assert_path_exists File.join(dir, 'bundler/b.rb')
+      assert_path_exist File.join(dir, "bundler/templates/.circleci/config.yml")
+      assert_path_exist File.join(dir, "bundler/templates/.travis.yml")
     end
   end
 
   def test_install_default_bundler_gem
     @cmd.extend FileUtils
 
-    bin_dir = File.join(@gemhome, 'bin')
+    bin_dir = File.join(@gemhome, "bin")
     @cmd.install_default_bundler_gem bin_dir
 
-    bundler_spec = Gem::Specification.load("bundler/bundler.gemspec")
     default_spec_path = File.join(Gem.default_specifications_dir, "#{bundler_spec.full_name}.gemspec")
     spec = Gem::Specification.load(default_spec_path)
 
     spec.executables.each do |e|
       if Gem.win_platform?
-        assert_path_exists File.join(bin_dir, "#{e}.bat")
+        assert_path_exist File.join(bin_dir, "#{e}.bat")
       end
 
-      assert_path_exists File.join bin_dir, Gem.default_exec_format % e
+      assert_path_exist File.join bin_dir, e
     end
 
-    default_dir = Gem.default_specifications_dir
-
     # expect to remove other versions of bundler gemspecs on default specification directory.
-    refute_path_exists File.join(default_dir, "bundler-1.15.4.gemspec")
-    assert_path_exists File.join(default_dir, "bundler-#{BUNDLER_VERS}.gemspec")
+    assert_path_not_exist previous_bundler_specification_path
+    assert_path_exist new_bundler_specification_path
 
     # expect to not remove bundler-* gemspecs.
-    assert_path_exists File.join(Gem.default_dir, "specifications", "bundler-audit-1.0.0.gemspec")
+    assert_path_exist File.join(Gem.dir, "specifications", "bundler-audit-1.0.0.gemspec")
 
     # expect to remove normal gem that was same version. because it's promoted default gems.
-    refute_path_exists File.join(Gem.default_dir, "specifications", "bundler-#{BUNDLER_VERS}.gemspec")
+    assert_path_not_exist File.join(Gem.dir, "specifications", "bundler-#{bundler_version}.gemspec")
+
+    assert_path_exist "#{Gem.dir}/gems/bundler-#{bundler_version}"
+    assert_path_exist "#{Gem.dir}/gems/bundler-1.15.4"
+    assert_path_exist "#{Gem.dir}/gems/bundler-audit-1.0.0"
+  end
+
+  def test_install_default_bundler_gem_with_default_gems_not_installed_at_default_dir
+    @cmd.extend FileUtils
 
-    # expect to install default gems. It location was `site_ruby` directory on real world.
-    assert_path_exists "default/gems/bundler-#{BUNDLER_VERS}"
+    gemhome2 = File.join(@tempdir, "gemhome2")
+    Gem.instance_variable_set(:@default_dir, gemhome2)
 
-    # expect to not remove other versions of bundler on `site_ruby`
-    assert_path_exists 'default/gems/bundler-1.15.4'
+    FileUtils.mkdir_p gemhome2
+    bin_dir = File.join(gemhome2, "bin")
 
-    # TODO: We need to assert to remove same version of bundler on gem_dir directory(It's not site_ruby dir)
+    @cmd.install_default_bundler_gem bin_dir
 
-    # expect to not remove bundler-* directory.
-    assert_path_exists 'default/gems/bundler-audit-1.0.0'
+    # expect to remove other versions of bundler gemspecs on default specification directory.
+    assert_path_not_exist previous_bundler_specification_path
+    assert_path_exist new_bundler_specification_path
   end
 
   def test_install_default_bundler_gem_with_force_flag
     @cmd.extend FileUtils
 
-    bin_dir = File.join(@gemhome, 'bin')
-    bundle_bin = File.join(bin_dir, 'bundle')
+    bin_dir = File.join(@gemhome, "bin")
+    bundle_bin = File.join(bin_dir, "bundle")
 
     write_file bundle_bin do |f|
-      f.puts '#!/usr/bin/ruby'
-      f.puts ''
+      f.puts "#!/usr/bin/ruby"
+      f.puts ""
       f.puts 'echo "hello"'
     end
 
-    bindir(bin_dir) do
-      @cmd.options[:force] = true
-
-      @cmd.install_default_bundler_gem bin_dir
+    @cmd.options[:force] = true
 
-      bundler_spec = Gem::Specification.load("bundler/bundler.gemspec")
-      default_spec_path = File.join(Gem.default_specifications_dir, "#{bundler_spec.full_name}.gemspec")
-      spec = Gem::Specification.load(default_spec_path)
+    @cmd.install_default_bundler_gem bin_dir
 
-      spec.executables.each do |e|
-        if Gem.win_platform?
-          assert_path_exists File.join(bin_dir, "#{e}.bat")
-        end
+    default_spec_path = File.join(Gem.default_specifications_dir, "#{bundler_spec.full_name}.gemspec")
+    spec = Gem::Specification.load(default_spec_path)
 
-        assert_path_exists File.join bin_dir, Gem.default_exec_format % e
+    spec.executables.each do |e|
+      if Gem.win_platform?
+        assert_path_exist File.join(bin_dir, "#{e}.bat")
       end
+
+      assert_path_exist File.join bin_dir, e
     end
   end
 
-  def test_remove_old_lib_files
-    lib                   = File.join @install_dir, 'lib'
-    lib_rubygems          = File.join lib, 'rubygems'
-    lib_bundler           = File.join lib, 'bundler'
-    lib_rubygems_defaults = File.join lib_rubygems, 'defaults'
+  def test_install_default_bundler_gem_with_destdir_flag
+    @cmd.extend FileUtils
 
-    securerandom_rb = File.join lib, 'securerandom.rb'
+    FileUtils.chmod "-w", @gemhome
 
-    engine_defaults_rb = File.join lib_rubygems_defaults, 'jruby.rb'
-    os_defaults_rb     = File.join lib_rubygems_defaults, 'operating_system.rb'
+    destdir = File.join(@tempdir, "foo")
+    bin_dir = File.join(destdir, "bin")
 
-    old_builder_rb     = File.join lib_rubygems, 'builder.rb'
-    old_format_rb      = File.join lib_rubygems, 'format.rb'
-    old_bundler_c_rb   = File.join lib_bundler,  'c.rb'
+    @cmd.options[:destdir] = destdir
 
-    FileUtils.mkdir_p lib_rubygems_defaults
-    FileUtils.mkdir_p lib_bundler
+    @cmd.install_default_bundler_gem bin_dir
 
-    File.open securerandom_rb,    'w' do |io|
-      io.puts '# securerandom.rb'
-    end
+    # leaves other versions of bundler gemspecs on default specification directory.
+    assert_path_exist previous_bundler_specification_path
+    assert_path_not_exist new_bundler_specification_path
+
+    # installs the updated bundler gemspec to destdir
+    assert_path_not_exist prepend_destdir(destdir, previous_bundler_specification_path)
+    assert_path_exist prepend_destdir(destdir, new_bundler_specification_path)
 
-    File.open old_builder_rb,     'w' do |io|
-      io.puts '# builder.rb'
+    bundler_spec.executables.each do |e|
+      assert_path_exist prepend_destdir(destdir, File.join(@gemhome, "gems", bundler_spec.full_name, bundler_spec.bindir, e))
     end
+  ensure
+    FileUtils.chmod "+w", @gemhome
+  end
 
-    File.open old_format_rb,      'w' do |io|
-      io.puts '# format.rb'
-    end
+  def test_install_default_bundler_gem_with_destdir_and_prefix_flags
+    @cmd.extend FileUtils
 
-    File.open old_bundler_c_rb,   'w' do |io|
-      io.puts '# c.rb'
-    end
+    destdir = File.join(@tempdir, "foo")
+    bin_dir = File.join(destdir, "bin")
 
-    File.open engine_defaults_rb, 'w' do |io|
-      io.puts '# jruby.rb'
-    end
+    @cmd.options[:destdir] = destdir
+    @cmd.options[:prefix] = "/"
+
+    @cmd.install_default_bundler_gem bin_dir
 
-    File.open os_defaults_rb,     'w' do |io|
-      io.puts '# operating_system.rb'
+    bundler_spec.executables.each do |e|
+      assert_path_exist File.join destdir, "gems", bundler_spec.full_name, bundler_spec.bindir, e
     end
+  end
+
+  def test_remove_old_lib_files
+    lib                   = RbConfig::CONFIG["sitelibdir"]
+    lib_rubygems          = File.join lib, "rubygems"
+    lib_bundler           = File.join lib, "bundler"
+    lib_rubygems_defaults = File.join lib_rubygems, "defaults"
+    lib_bundler_templates = File.join lib_bundler, "templates"
+
+    securerandom_rb = File.join lib, "securerandom.rb"
+
+    engine_defaults_rb = File.join lib_rubygems_defaults, "jruby.rb"
+    os_defaults_rb     = File.join lib_rubygems_defaults, "operating_system.rb"
+
+    old_gauntlet_rubygems_rb = File.join lib, "gauntlet_rubygems.rb"
+
+    old_builder_rb     = File.join lib_rubygems, "builder.rb"
+    old_format_rb      = File.join lib_rubygems, "format.rb"
+    old_bundler_c_rb   = File.join lib_bundler,  "c.rb"
+    old_bundler_ci     = File.join lib_bundler_templates, ".lecacy_ci", "config.yml"
+
+    files_that_go   = [old_gauntlet_rubygems_rb, old_builder_rb, old_format_rb, old_bundler_c_rb, old_bundler_ci]
+    files_that_stay = [securerandom_rb, engine_defaults_rb, os_defaults_rb]
+
+    create_dummy_files(files_that_go + files_that_stay)
 
     @cmd.remove_old_lib_files lib
 
-    refute_path_exists old_builder_rb
-    refute_path_exists old_format_rb
-    refute_path_exists old_bundler_c_rb
-
-    assert_path_exists securerandom_rb
-    assert_path_exists engine_defaults_rb
-    assert_path_exists os_defaults_rb
+    files_that_go.each {|file| assert_path_not_exist(file) unless file == old_bundler_ci }
+
+    files_that_stay.each {|file| assert_path_exist file }
+  end
+
+  def test_remove_old_man_files
+    man = File.join RbConfig::CONFIG["mandir"], "man"
+
+    ruby_1             = File.join man, "man1", "ruby.1"
+    bundle_b_1         = File.join man, "man1", "bundle-b.1"
+    bundle_b_1_ronn    = File.join man, "man1", "bundle-b.1.ronn"
+    bundle_b_1_txt     = File.join man, "man1", "bundle-b.1.txt"
+    gemfile_5          = File.join man, "man5", "gemfile.5"
+    gemfile_5_ronn     = File.join man, "man5", "gemfile.5.ronn"
+    gemfile_5_txt      = File.join man, "man5", "gemfile.5.txt"
+
+    files_that_go   = [bundle_b_1, bundle_b_1_txt, bundle_b_1_ronn, gemfile_5, gemfile_5_txt, gemfile_5_ronn]
+    files_that_stay = [ruby_1]
+
+    create_dummy_files(files_that_go + files_that_stay)
+
+    @cmd.remove_old_man_files man
+
+    files_that_go.each {|file| assert_path_not_exist file }
+
+    files_that_stay.each {|file| assert_path_exist file }
   end
 
   def test_show_release_notes
     @default_external = @ui.outs.external_encoding
     @ui.outs.set_encoding Encoding::US_ASCII
 
-    @cmd.options[:previous_version] = Gem::Version.new '2.0.2'
+    @cmd.options[:previous_version] = Gem::Version.new "2.0.2"
 
-    File.open 'History.txt', 'w' do |io|
-      io.puts <<-History_txt
-# coding: UTF-8
+    File.open "CHANGELOG.md", "w" do |io|
+      io.puts <<-HISTORY_TXT
+# #{Gem::VERSION} / 2013-03-26
 
-=== #{Gem::VERSION} / 2013-03-26
-
-* Bug fixes:
+## Bug fixes:
   * Fixed release note display for LANG=C when installing rubygems
   *  is tasty
 
-=== 2.0.2 / 2013-03-06
+# 2.0.2 / 2013-03-06
 
-* Bug fixes:
+## Bug fixes:
   * Other bugs fixed
 
-=== 2.0.1 / 2013-03-05
+# 2.0.1 / 2013-03-05
 
-* Bug fixes:
+## Bug fixes:
   * Yet more bugs fixed
-      History_txt
+      HISTORY_TXT
     end
 
     use_ui @ui do
@@ -341,9 +395,9 @@ class TestGemCommandsSetupCommand < Gem:
     end
 
     expected = <<-EXPECTED
-=== #{Gem::VERSION} / 2013-03-26
+# #{Gem::VERSION} / 2013-03-26
 
-* Bug fixes:
+## Bug fixes:
   * Fixed release note display for LANG=C when installing rubygems
   *  is tasty
 
@@ -359,14 +413,69 @@ class TestGemCommandsSetupCommand < Gem:
 
   private
 
+  def create_dummy_files(list)
+    list.each do |file|
+      FileUtils.mkdir_p File.dirname(file)
+
+      File.open file, "w" do |io|
+        io.puts "# #{File.basename(file)}"
+      end
+    end
+  end
+
+  def gem_install(name)
+    gem = util_spec name do |s|
+      s.executables = [name]
+      s.files = %W[bin/#{name}]
+    end
+    write_file File.join @tempdir, "bin", name do |f|
+      f.puts "#!/usr/bin/ruby"
+    end
+    install_gem gem
+    File.join @gemhome, "bin", name
+  end
+
+  def gem_install_with_plugin(name)
+    gem = util_spec name do |s|
+      s.files = %W[lib/rubygems_plugin.rb]
+    end
+    write_file File.join @tempdir, "lib", "rubygems_plugin.rb" do |f|
+      f.puts "require '#{gem.plugins.first}'"
+    end
+    install_gem gem
+
+    File.join Gem.plugindir, "#{name}_plugin.rb"
+  end
+
   def default_gem_bin_path
-    gem_exec = sprintf Gem.default_exec_format, 'gem'
-    File.join @install_dir, 'bin', gem_exec
+    File.join RbConfig::CONFIG["bindir"], "gem"
   end
 
   def default_bundle_bin_path
-    bundle_exec = sprintf Gem.default_exec_format, 'bundle'
-    File.join @install_dir, 'bin', bundle_exec
+    File.join RbConfig::CONFIG["bindir"], "bundle"
+  end
+
+  def default_bundler_bin_path
+    File.join RbConfig::CONFIG["bindir"], "bundler"
+  end
+
+  def previous_bundler_specification_path
+    File.join(Gem.default_specifications_dir, "bundler-1.15.4.gemspec")
+  end
+
+  def new_bundler_specification_path
+    File.join(Gem.default_specifications_dir, "bundler-#{bundler_version}.gemspec")
+  end
+
+  def bundler_spec
+    Gem::Specification.load("bundler/bundler.gemspec")
+  end
+
+  def bundler_version
+    bundler_spec.version
   end
 
+  def prepend_destdir(destdir, path)
+    File.join(destdir, path.gsub(/^[a-zA-Z]:/, ""))
+  end
 end unless Gem.java_platform?
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_signin_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_signin_command.rb
@@ -1,13 +1,14 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/signin_command'
-require 'rubygems/installer'
+require_relative "helper"
+require "rubygems/commands/signin_command"
+require "rubygems/installer"
 
 class TestGemCommandsSigninCommand < Gem::TestCase
-
   def setup
     super
 
+    credential_setup
+
     Gem.configuration.rubygems_api_key = nil
     Gem.configuration.api_keys.clear
 
@@ -15,36 +16,43 @@ class TestGemCommandsSigninCommand < Gem
   end
 
   def teardown
-    credentials_path = Gem.configuration.credentials_path
-    File.delete(credentials_path)  if File.exist?(credentials_path)
+    credential_teardown
+
     super
   end
 
   def test_execute_when_not_already_signed_in
-    sign_in_ui = util_capture() { @cmd.execute }
+    sign_in_ui = util_capture { @cmd.execute }
+    assert_match %r{Signed in.}, sign_in_ui.output
+  end
+
+  def test_execute_when_not_already_signed_in_and_not_preexisting_credentials_folder
+    FileUtils.rm Gem.configuration.credentials_path
+
+    sign_in_ui = util_capture { @cmd.execute }
     assert_match %r{Signed in.}, sign_in_ui.output
   end
 
   def test_execute_when_already_signed_in_with_same_host
-    host = 'http://some-gemcutter-compatible-host.org'
+    host = "http://some-gemcutter-compatible-host.org"
 
     util_capture(nil, host) { @cmd.execute }
-    old_credentials = YAML.load_file Gem.configuration.credentials_path
+    old_credentials = load_yaml_file Gem.configuration.credentials_path
 
     util_capture(nil, host) { @cmd.execute }
-    new_credentials = YAML.load_file Gem.configuration.credentials_path
+    new_credentials = load_yaml_file Gem.configuration.credentials_path
 
     assert_equal old_credentials[host], new_credentials[host]
   end
 
   def test_execute_when_already_signed_in_with_different_host
-    api_key = 'a5fdbb6ba150cbb83aad2bb2fede64cf04045xxxx'
+    api_key = "a5fdbb6ba150cbb83aad2bb2fede64cf04045xxxx"
 
     util_capture(nil, nil, api_key) { @cmd.execute }
-    host = 'http://some-gemcutter-compatible-host.org'
+    host = "http://some-gemcutter-compatible-host.org"
 
     util_capture(nil, host, api_key) { @cmd.execute }
-    credentials = YAML.load_file Gem.configuration.credentials_path
+    credentials = load_yaml_file Gem.configuration.credentials_path
 
     assert_equal credentials[:rubygems_api_key], api_key
 
@@ -52,42 +60,169 @@ class TestGemCommandsSigninCommand < Gem
   end
 
   def test_execute_with_host_supplied
-    host = 'http://some-gemcutter-compatible-host.org'
+    host = "http://some-gemcutter-compatible-host.org"
 
     sign_in_ui = util_capture(nil, host) { @cmd.execute }
     assert_match %r{Enter your #{host} credentials.}, sign_in_ui.output
     assert_match %r{Signed in.}, sign_in_ui.output
 
-    api_key     = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
-    credentials = YAML.load_file Gem.configuration.credentials_path
+    api_key     = "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
+    credentials = load_yaml_file Gem.configuration.credentials_path
     assert_equal api_key, credentials[host]
   end
 
   def test_execute_with_valid_creds_set_for_default_host
-    util_capture {@cmd.execute}
+    util_capture { @cmd.execute }
+
+    api_key     = "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
+    credentials = load_yaml_file Gem.configuration.credentials_path
+
+    assert_equal api_key, credentials[:rubygems_api_key]
+  end
 
-    api_key     = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
-    credentials = YAML.load_file Gem.configuration.credentials_path
+  def test_execute_with_key_name_and_scope
+    email     = "you@example.com"
+    password  = "secret"
+    api_key   = "1234"
+    fetcher   = Gem::RemoteFetcher.fetcher
+
+    key_name_ui = Gem::MockGemUi.new "#{email}\n#{password}\ntest-key\n\ny\n\n\n\n\n\n"
+    util_capture(key_name_ui, nil, api_key, fetcher) { @cmd.execute }
+
+    user = ENV["USER"] || ENV["USERNAME"]
+
+    assert_match "API Key name [#{Socket.gethostname}-#{user}", key_name_ui.output
+    assert_match "index_rubygems [yN]", key_name_ui.output
+    assert_match "push_rubygem [yN]", key_name_ui.output
+    assert_match "yank_rubygem [yN]", key_name_ui.output
+    assert_match "add_owner [yN]", key_name_ui.output
+    assert_match "remove_owner [yN]", key_name_ui.output
+    assert_match "access_webhooks [yN]", key_name_ui.output
+    assert_match "show_dashboard [yN]", key_name_ui.output
+    assert_equal "name=test-key&push_rubygem=true", fetcher.last_request.body
 
+    credentials = load_yaml_file Gem.configuration.credentials_path
     assert_equal api_key, credentials[:rubygems_api_key]
   end
 
+  def test_execute_with_key_name_scope_and_mfa_level_of_ui_only
+    email     = "you@example.com"
+    password  = "secret"
+    api_key   = "1234"
+    fetcher   = Gem::RemoteFetcher.fetcher
+    mfa_level = "ui_only"
+
+    key_name_ui = Gem::MockGemUi.new "#{email}\n#{password}\ntest-key\n\ny\n\n\n\n\n\ny"
+    util_capture(key_name_ui, nil, api_key, fetcher, mfa_level) { @cmd.execute }
+
+    user = ENV["USER"] || ENV["USERNAME"]
+
+    assert_match "API Key name [#{Socket.gethostname}-#{user}", key_name_ui.output
+    assert_match "index_rubygems [yN]", key_name_ui.output
+    assert_match "push_rubygem [yN]", key_name_ui.output
+    assert_match "yank_rubygem [yN]", key_name_ui.output
+    assert_match "add_owner [yN]", key_name_ui.output
+    assert_match "remove_owner [yN]", key_name_ui.output
+    assert_match "access_webhooks [yN]", key_name_ui.output
+    assert_match "show_dashboard [yN]", key_name_ui.output
+    assert_match "Would you like to enable MFA for this key? (strongly recommended) [yn]", key_name_ui.output
+    assert_equal "name=test-key&push_rubygem=true&mfa=true", fetcher.last_request.body
+
+    credentials = load_yaml_file Gem.configuration.credentials_path
+    assert_equal api_key, credentials[:rubygems_api_key]
+  end
+
+  def test_execute_with_key_name_scope_and_mfa_level_of_gem_signin
+    email     = "you@example.com"
+    password  = "secret"
+    api_key   = "1234"
+    fetcher   = Gem::RemoteFetcher.fetcher
+    mfa_level = "ui_and_gem_signin"
+
+    key_name_ui = Gem::MockGemUi.new "#{email}\n#{password}\ntest-key\n\ny\n\n\n\n\n\ny"
+    util_capture(key_name_ui, nil, api_key, fetcher, mfa_level) { @cmd.execute }
+
+    user = ENV["USER"] || ENV["USERNAME"]
+
+    assert_match "API Key name [#{Socket.gethostname}-#{user}", key_name_ui.output
+    assert_match "index_rubygems [yN]", key_name_ui.output
+    assert_match "push_rubygem [yN]", key_name_ui.output
+    assert_match "yank_rubygem [yN]", key_name_ui.output
+    assert_match "add_owner [yN]", key_name_ui.output
+    assert_match "remove_owner [yN]", key_name_ui.output
+    assert_match "access_webhooks [yN]", key_name_ui.output
+    assert_match "show_dashboard [yN]", key_name_ui.output
+    assert_match "Would you like to enable MFA for this key? (strongly recommended) [yn]", key_name_ui.output
+    assert_equal "name=test-key&push_rubygem=true&mfa=true", fetcher.last_request.body
+
+    credentials = load_yaml_file Gem.configuration.credentials_path
+    assert_equal api_key, credentials[:rubygems_api_key]
+  end
+
+  def test_execute_with_warnings
+    email     = "you@example.com"
+    password  = "secret"
+    api_key   = "1234"
+    fetcher   = Gem::RemoteFetcher.fetcher
+    mfa_level = "disabled"
+    warning   = "/[WARNING/] For protection of your account and gems"
+
+    key_name_ui = Gem::MockGemUi.new "#{email}\n#{password}\ntest-key\n\ny\n\n\n\n\n\ny"
+    util_capture(key_name_ui, nil, api_key, fetcher, mfa_level, warning) { @cmd.execute }
+
+    assert_match warning, key_name_ui.output
+  end
+
+  def test_execute_on_gemserver_without_profile_me_endpoint
+    host = "http://some-gemcutter-compatible-host.org"
+
+    email     = "you@example.com"
+    password  = "secret"
+    api_key   = "1234"
+    fetcher   = Gem::RemoteFetcher.fetcher
+
+    key_name_ui = Gem::MockGemUi.new "#{email}\n#{password}\ntest-key\n\ny\n\n\n\n\n\ny"
+
+    # Set the expected response for the Web-API supplied
+    ENV["RUBYGEMS_HOST"]       = host
+    data_key                   = "#{ENV['RUBYGEMS_HOST']}/api/v1/api_key"
+    fetcher.data[data_key]     = [api_key, 200, "OK"]
+
+    use_ui key_name_ui do
+      @cmd.execute
+    end
+
+    user = ENV["USER"] || ENV["USERNAME"]
+
+    assert_match "API Key name [#{Socket.gethostname}-#{user}", key_name_ui.output
+    assert_match "index_rubygems [yN]", key_name_ui.output
+    assert_match "push_rubygem [yN]", key_name_ui.output
+    assert_match "yank_rubygem [yN]", key_name_ui.output
+    assert_match "add_owner [yN]", key_name_ui.output
+    assert_match "remove_owner [yN]", key_name_ui.output
+    assert_match "access_webhooks [yN]", key_name_ui.output
+    assert_match "show_dashboard [yN]", key_name_ui.output
+    assert_equal "name=test-key&push_rubygem=true", fetcher.last_request.body
+  end
+
   # Utility method to capture IO/UI within the block passed
 
-  def util_capture(ui_stub = nil, host = nil, api_key = nil)
-    api_key ||= 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
-    response  = [api_key, 200, 'OK']
-    email     = 'you@example.com'
-    password  = 'secret'
-    fetcher   = Gem::FakeFetcher.new
+  def util_capture(ui_stub = nil, host = nil, api_key = nil, fetcher = Gem::FakeFetcher.new, mfa_level = "disabled", warning = nil)
+    api_key        ||= "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
+    response         = [api_key, 200, "OK"]
+    profile_response = [ "mfa: #{mfa_level}\nwarning: #{warning}" , 200, "OK"]
+    email            = "you@example.com"
+    password         = "secret"
 
     # Set the expected response for the Web-API supplied
-    ENV['RUBYGEMS_HOST']       = host || Gem::DEFAULT_HOST
+    ENV["RUBYGEMS_HOST"]       = host || Gem::DEFAULT_HOST
     data_key                   = "#{ENV['RUBYGEMS_HOST']}/api/v1/api_key"
     fetcher.data[data_key]     = response
+    profile                    = "#{ENV['RUBYGEMS_HOST']}/api/v1/profile/me.yaml"
+    fetcher.data[profile]      = profile_response
     Gem::RemoteFetcher.fetcher = fetcher
 
-    sign_in_ui = ui_stub || Gem::MockGemUi.new("#{email}\n#{password}\n")
+    sign_in_ui = ui_stub || Gem::MockGemUi.new("#{email}\n#{password}\n\n\n\n\n\n\n\n\n")
 
     use_ui sign_in_ui do
       yield
@@ -95,5 +230,4 @@ class TestGemCommandsSigninCommand < Gem
 
     sign_in_ui
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_signout_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_signout_command.rb
@@ -1,21 +1,15 @@
 # frozen_string_literal: true
 
-require 'rubygems/test_case'
-require 'rubygems/commands/signout_command'
-require 'rubygems/installer'
+require_relative "helper"
+require "rubygems/commands/signout_command"
+require "rubygems/installer"
 
 class TestGemCommandsSignoutCommand < Gem::TestCase
-
   def setup
     super
     @cmd = Gem::Commands::SignoutCommand.new
   end
 
-  def teardown
-    super
-    File.delete Gem.configuration.credentials_path if File.exist?(Gem.configuration.credentials_path)
-  end
-
   def test_execute_when_user_is_signed_in
     FileUtils.mkdir_p File.dirname(Gem.configuration.credentials_path)
     FileUtils::touch Gem.configuration.credentials_path
@@ -33,5 +27,4 @@ class TestGemCommandsSignoutCommand < Ge
 
     assert_match %r{You are not currently signed in}, @sign_out_ui.error
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_sources_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_sources_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/sources_command'
+require_relative "helper"
+require "rubygems/commands/sources_command"
 
 class TestGemCommandsSourcesCommand < Gem::TestCase
-
   def setup
     super
 
@@ -21,7 +20,7 @@ class TestGemCommandsSourcesCommand < Ge
   end
 
   def test_initialize_proxy
-    assert @cmd.handles?(['--http-proxy', 'http://proxy.example.com'])
+    assert @cmd.handles?(["--http-proxy", "http://proxy.example.com"])
   end
 
   def test_execute
@@ -38,12 +37,12 @@ class TestGemCommandsSourcesCommand < Ge
     EOF
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_add
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
     specs = Gem::Specification.map do |spec|
@@ -71,7 +70,7 @@ class TestGemCommandsSourcesCommand < Ge
     EOF
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_add_allow_typo_squatting_source
@@ -108,6 +107,36 @@ class TestGemCommandsSourcesCommand < Ge
     assert_empty ui.error
   end
 
+  def test_execute_add_allow_typo_squatting_source_forced
+    rubygems_org = "https://rubyems.org"
+
+    spec_fetcher do |fetcher|
+      fetcher.spec("a", 1)
+    end
+
+    specs = Gem::Specification.map do |spec|
+      [spec.name, spec.version, spec.original_platform]
+    end
+
+    specs_dump_gz = StringIO.new
+    Zlib::GzipWriter.wrap(specs_dump_gz) do |io|
+      Marshal.dump(specs, io)
+    end
+
+    @fetcher.data["#{rubygems_org}/specs.#{@marshal_version}.gz"] = specs_dump_gz.string
+    @cmd.handle_options %W[--force --add #{rubygems_org}]
+
+    @cmd.execute
+
+    expected = "https://rubyems.org added to sources\n"
+    assert_equal expected, ui.output
+
+    source = Gem::Source.new(rubygems_org)
+    assert Gem.sources.include?(source)
+
+    assert_empty ui.error
+  end
+
   def test_execute_add_deny_typo_squatting_source
     rubygems_org = "https://rubyems.org"
 
@@ -132,8 +161,7 @@ class TestGemCommandsSourcesCommand < Ge
     ui = Gem::MockGemUi.new("n")
 
     use_ui ui do
-
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
@@ -153,13 +181,13 @@ class TestGemCommandsSourcesCommand < Ge
 
     uri = "http://beta-gems.example.com/specs.#{@marshal_version}.gz"
     @fetcher.data[uri] = proc do
-      raise Gem::RemoteFetcher::FetchError.new('it died', uri)
+      raise Gem::RemoteFetcher::FetchError.new("it died", uri)
     end
 
     @cmd.handle_options %w[--add http://beta-gems.example.com]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
@@ -170,7 +198,57 @@ Error fetching http://beta-gems.example.
     EOF
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
+  end
+
+  def test_execute_add_existent_source_invalid_uri
+    spec_fetcher
+
+    uri = "https://u:p@example.com/specs.#{@marshal_version}.gz"
+
+    @cmd.handle_options %w[--add https://u:p@example.com]
+    @fetcher.data[uri] = proc do
+      raise Gem::RemoteFetcher::FetchError.new("it died", uri)
+    end
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::TermError do
+        @cmd.execute
+      end
+    end
+
+    expected = <<-EOF
+Error fetching https://u:REDACTED@example.com:
+\tit died (https://u:REDACTED@example.com/specs.#{@marshal_version}.gz)
+    EOF
+
+    assert_equal expected, @ui.output
+    assert_equal "", @ui.error
+  end
+
+  def test_execute_add_existent_source_invalid_uri_with_error_by_chance_including_the_uri_password
+    spec_fetcher
+
+    uri = "https://u:secret@example.com/specs.#{@marshal_version}.gz"
+
+    @cmd.handle_options %w[--add https://u:secret@example.com]
+    @fetcher.data[uri] = proc do
+      raise Gem::RemoteFetcher::FetchError.new("it secretly died", uri)
+    end
+
+    use_ui @ui do
+      assert_raise Gem::MockGemUi::TermError do
+        @cmd.execute
+      end
+    end
+
+    expected = <<-EOF
+Error fetching https://u:REDACTED@example.com:
+\tit secretly died (https://u:REDACTED@example.com/specs.#{@marshal_version}.gz)
+    EOF
+
+    assert_equal expected, @ui.output
+    assert_equal "", @ui.error
   end
 
   def test_execute_add_redundant_source
@@ -189,7 +267,7 @@ source #{@gem_repo} already present in t
     EOF
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_add_redundant_source_trailing_slash
@@ -209,7 +287,7 @@ source #{@gem_repo} already present in t
     EOF
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
 
     # Re-add pre-existing gem source (w/o slash)
     repo_without_slash = "http://gems.example.com"
@@ -226,7 +304,7 @@ http://gems.example.com added to sources
     EOF
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
 
     # Re-add original gem source (w/ slash)
     @cmd.handle_options %W[--add #{repo_with_slash}]
@@ -243,14 +321,14 @@ source http://gems.example.com/ already 
     EOF
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_add_http_rubygems_org
-    http_rubygems_org = 'http://rubygems.org/'
+    http_rubygems_org = "http://rubygems.org/"
 
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
     specs = Gem::Specification.map do |spec|
@@ -270,7 +348,7 @@ source http://gems.example.com/ already 
     ui = Gem::MockGemUi.new "n"
 
     use_ui ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
@@ -284,11 +362,41 @@ source http://gems.example.com/ already 
     assert_empty @ui.error
   end
 
+  def test_execute_add_http_rubygems_org_forced
+    rubygems_org = "http://rubygems.org"
+
+    spec_fetcher do |fetcher|
+      fetcher.spec("a", 1)
+    end
+
+    specs = Gem::Specification.map do |spec|
+      [spec.name, spec.version, spec.original_platform]
+    end
+
+    specs_dump_gz = StringIO.new
+    Zlib::GzipWriter.wrap(specs_dump_gz) do |io|
+      Marshal.dump(specs, io)
+    end
+
+    @fetcher.data["#{rubygems_org}/specs.#{@marshal_version}.gz"] = specs_dump_gz.string
+    @cmd.handle_options %W[--force --add #{rubygems_org}]
+
+    @cmd.execute
+
+    expected = "http://rubygems.org added to sources\n"
+    assert_equal expected, ui.output
+
+    source = Gem::Source.new(rubygems_org)
+    assert Gem.sources.include?(source)
+
+    assert_empty ui.error
+  end
+
   def test_execute_add_https_rubygems_org
-    https_rubygems_org = 'https://rubygems.org/'
+    https_rubygems_org = "https://rubygems.org/"
 
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
     specs = Gem::Specification.map do |spec|
@@ -308,7 +416,7 @@ source http://gems.example.com/ already 
     ui = Gem::MockGemUi.new "n"
 
     use_ui ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
@@ -326,7 +434,7 @@ source http://gems.example.com/ already 
     @cmd.handle_options %w[--add beta-gems.example.com]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
@@ -338,7 +446,7 @@ beta-gems.example.com is not a URI
     EOF
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_clear_all
@@ -353,10 +461,10 @@ beta-gems.example.com is not a URI
     EOF
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
 
     dir = Gem.spec_cache_dir
-    refute File.exist?(dir), 'cache dir removed'
+    refute File.exist?(dir), "cache dir removed"
   end
 
   def test_execute_list
@@ -373,7 +481,7 @@ beta-gems.example.com is not a URI
     EOF
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_remove
@@ -386,7 +494,7 @@ beta-gems.example.com is not a URI
     expected = "#{@gem_repo} removed from sources\n"
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_remove_no_network
@@ -405,14 +513,14 @@ beta-gems.example.com is not a URI
     expected = "#{@gem_repo} removed from sources\n"
 
     assert_equal expected, @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_update
     @cmd.handle_options %w[--update]
 
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
+      fetcher.gem "a", 1
     end
 
     use_ui @ui do
@@ -420,7 +528,6 @@ beta-gems.example.com is not a URI
     end
 
     assert_equal "source cache successfully updated\n", @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_specification_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_specification_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/specification_command'
+require_relative "helper"
+require "rubygems/commands/specification_command"
 
 class TestGemCommandsSpecificationCommand < Gem::TestCase
-
   def setup
     super
 
@@ -11,7 +10,7 @@ class TestGemCommandsSpecificationComman
   end
 
   def test_execute
-    foo = util_spec 'foo'
+    foo = util_spec "foo"
 
     install_specs foo
 
@@ -21,14 +20,14 @@ class TestGemCommandsSpecificationComman
       @cmd.execute
     end
 
-    assert_match %r|Gem::Specification|, @ui.output
-    assert_match %r|name: foo|, @ui.output
-    assert_equal '', @ui.error
+    assert_match %r{Gem::Specification}, @ui.output
+    assert_match %r{name: foo}, @ui.output
+    assert_equal "", @ui.error
   end
 
   def test_execute_all
-    install_specs util_spec 'foo', '0.0.1'
-    install_specs util_spec 'foo', '0.0.2'
+    install_specs util_spec "foo", "0.0.1"
+    install_specs util_spec "foo", "0.0.2"
 
     @cmd.options[:args] = %w[foo]
     @cmd.options[:all] = true
@@ -37,41 +36,41 @@ class TestGemCommandsSpecificationComman
       @cmd.execute
     end
 
-    assert_match %r|Gem::Specification|, @ui.output
-    assert_match %r|name: foo|, @ui.output
-    assert_match %r|version: 0.0.1|, @ui.output
-    assert_match %r|version: 0.0.2|, @ui.output
-    assert_equal '', @ui.error
+    assert_match %r{Gem::Specification}, @ui.output
+    assert_match %r{name: foo}, @ui.output
+    assert_match %r{version: 0.0.1}, @ui.output
+    assert_match %r{version: 0.0.2}, @ui.output
+    assert_equal "", @ui.error
   end
 
   def test_execute_all_conflicts_with_version
-    util_spec 'foo', '0.0.1'
-    util_spec 'foo', '0.0.2'
+    util_spec "foo", "0.0.1"
+    util_spec "foo", "0.0.2"
 
     @cmd.options[:args] = %w[foo]
     @cmd.options[:all] = true
     @cmd.options[:version] = "1"
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @ui do
         @cmd.execute
       end
     end
 
-    assert_equal '', @ui.output
+    assert_equal "", @ui.output
     assert_equal "ERROR:  Specify --all or -v, not both\n", @ui.error
   end
 
   def test_execute_bad_name
     @cmd.options[:args] = %w[foo]
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @ui do
         @cmd.execute
       end
     end
 
-    assert_equal '', @ui.output
+    assert_equal "", @ui.output
     assert_equal "ERROR:  No gem matching 'foo (>= 0)' found\n", @ui.error
   end
 
@@ -79,19 +78,19 @@ class TestGemCommandsSpecificationComman
     @cmd.options[:args] = %w[foo]
     @cmd.options[:version] = "1.3.2"
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @ui do
         @cmd.execute
       end
     end
 
-    assert_equal '', @ui.output
+    assert_equal "", @ui.output
     assert_equal "ERROR:  No gem matching 'foo (= 1.3.2)' found\n", @ui.error
   end
 
   def test_execute_exact_match
-    install_specs util_spec 'foo'
-    install_specs util_spec 'foo_bar'
+    install_specs util_spec "foo"
+    install_specs util_spec "foo_bar"
 
     @cmd.options[:args] = %w[foo]
 
@@ -99,13 +98,13 @@ class TestGemCommandsSpecificationComman
       @cmd.execute
     end
 
-    assert_match %r|Gem::Specification|, @ui.output
-    assert_match %r|name: foo|, @ui.output
-    assert_equal '', @ui.error
+    assert_match %r{Gem::Specification}, @ui.output
+    assert_match %r{name: foo}, @ui.output
+    assert_equal "", @ui.error
   end
 
   def test_execute_field
-    foo = util_spec 'foo', '2'
+    foo = util_spec "foo", "2"
 
     install_specs foo
 
@@ -115,11 +114,11 @@ class TestGemCommandsSpecificationComman
       @cmd.execute
     end
 
-    assert_equal "foo", YAML.load(@ui.output)
+    assert_equal "foo", load_yaml(@ui.output)
   end
 
   def test_execute_file
-    foo = util_spec 'foo' do |s|
+    foo = util_spec "foo" do |s|
       s.files = %w[lib/code.rb]
     end
 
@@ -131,13 +130,13 @@ class TestGemCommandsSpecificationComman
       @cmd.execute
     end
 
-    assert_match %r|Gem::Specification|, @ui.output
-    assert_match %r|name: foo|, @ui.output
-    assert_equal '', @ui.error
+    assert_match %r{Gem::Specification}, @ui.output
+    assert_match %r{name: foo}, @ui.output
+    assert_equal "", @ui.error
   end
 
   def test_execute_marshal
-    foo = util_spec 'foo', '2'
+    foo = util_spec "foo", "2"
 
     install_specs foo
 
@@ -149,12 +148,12 @@ class TestGemCommandsSpecificationComman
     end
 
     assert_equal foo, Marshal.load(@ui.output)
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_remote
     spec_fetcher do |fetcher|
-      fetcher.spec 'foo', 1
+      fetcher.spec "foo", 1
     end
 
     @cmd.options[:args] = %w[foo]
@@ -164,19 +163,44 @@ class TestGemCommandsSpecificationComman
       @cmd.execute
     end
 
-    assert_match %r|\A--- !ruby/object:Gem::Specification|, @ui.output
-    assert_match %r|name: foo|, @ui.output
+    assert_match %r{\A--- !ruby/object:Gem::Specification}, @ui.output
+    assert_match %r{name: foo}, @ui.output
   end
 
   def test_execute_remote_with_version
     spec_fetcher do |fetcher|
-      fetcher.spec 'foo', "1"
-      fetcher.spec 'foo', "2"
+      fetcher.spec "foo", "1"
+      fetcher.spec "foo", "2"
+    end
+
+    @cmd.options[:args] = %w[foo]
+    @cmd.options[:version] = "1"
+    @cmd.options[:domain] = :remote
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    spec = Gem::Specification.from_yaml @ui.output
+
+    assert_equal Gem::Version.new("1"), spec.version
+  end
+
+  def test_execute_remote_with_version_and_platform
+    original_platforms = Gem.platforms.dup
+
+    spec_fetcher do |fetcher|
+      fetcher.spec "foo", "1"
+      fetcher.spec "foo", "1" do |s|
+        s.platform = "x86_64-linux"
+      end
     end
 
     @cmd.options[:args] = %w[foo]
     @cmd.options[:version] = "1"
     @cmd.options[:domain] = :remote
+    @cmd.options[:added_platform] = true
+    Gem.platforms = [Gem::Platform::RUBY, Gem::Platform.new("x86_64-linux")]
 
     use_ui @ui do
       @cmd.execute
@@ -185,12 +209,15 @@ class TestGemCommandsSpecificationComman
     spec = Gem::Specification.from_yaml @ui.output
 
     assert_equal Gem::Version.new("1"), spec.version
+    assert_equal Gem::Platform.new("x86_64-linux"), spec.platform
+  ensure
+    Gem.platforms = original_platforms
   end
 
   def test_execute_remote_without_prerelease
     spec_fetcher do |fetcher|
-      fetcher.spec 'foo', '2.0.0'
-      fetcher.spec 'foo', '2.0.1.pre'
+      fetcher.spec "foo", "2.0.0"
+      fetcher.spec "foo", "2.0.1.pre"
     end
 
     @cmd.options[:args] = %w[foo]
@@ -200,18 +227,18 @@ class TestGemCommandsSpecificationComman
       @cmd.execute
     end
 
-    assert_match %r|\A--- !ruby/object:Gem::Specification|, @ui.output
-    assert_match %r|name: foo|, @ui.output
+    assert_match %r{\A--- !ruby/object:Gem::Specification}, @ui.output
+    assert_match %r{name: foo}, @ui.output
 
-    spec = YAML.load @ui.output
+    spec = load_yaml @ui.output
 
     assert_equal Gem::Version.new("2.0.0"), spec.version
   end
 
   def test_execute_remote_with_prerelease
     spec_fetcher do |fetcher|
-      fetcher.spec 'foo', '2.0.0'
-      fetcher.spec 'foo', '2.0.1.pre'
+      fetcher.spec "foo", "2.0.0"
+      fetcher.spec "foo", "2.0.1.pre"
     end
 
     @cmd.options[:args] = %w[foo]
@@ -222,16 +249,16 @@ class TestGemCommandsSpecificationComman
       @cmd.execute
     end
 
-    assert_match %r|\A--- !ruby/object:Gem::Specification|, @ui.output
-    assert_match %r|name: foo|, @ui.output
+    assert_match %r{\A--- !ruby/object:Gem::Specification}, @ui.output
+    assert_match %r{name: foo}, @ui.output
 
-    spec = YAML.load @ui.output
+    spec = load_yaml @ui.output
 
     assert_equal Gem::Version.new("2.0.1.pre"), spec.version
   end
 
   def test_execute_ruby
-    foo = util_spec 'foo'
+    foo = util_spec "foo"
 
     install_specs foo
 
@@ -242,9 +269,8 @@ class TestGemCommandsSpecificationComman
       @cmd.execute
     end
 
-    assert_match %r|Gem::Specification.new|, @ui.output
-    assert_match %r|s.name = "foo"|, @ui.output
-    assert_equal '', @ui.error
+    assert_match %r{Gem::Specification.new}, @ui.output
+    assert_match %r{s.name = "foo"}, @ui.output
+    assert_equal "", @ui.error
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_stale_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_stale_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/stale_command'
+require_relative "helper"
+require "rubygems/commands/stale_command"
 
 class TestGemCommandsStaleCommand < Gem::TestCase
-
   def setup
     super
     @stub_ui = Gem::MockGemUi.new
@@ -12,12 +11,12 @@ class TestGemCommandsStaleCommand < Gem:
 
   def test_execute_sorts
     files = %w[lib/foo_bar.rb Rakefile]
-    foo_bar = util_spec 'foo_bar' do |gem|
+    foo_bar = util_spec "foo_bar" do |gem|
       gem.files = files
     end
     install_specs foo_bar
 
-    bar_baz = util_spec 'bar_baz' do |gem|
+    bar_baz = util_spec "bar_baz" do |gem|
       gem.files = files
     end
     install_specs bar_baz
@@ -40,5 +39,4 @@ class TestGemCommandsStaleCommand < Gem:
     assert_equal("#{foo_bar.name}-#{foo_bar.version}", lines[0].split.first)
     assert_equal("#{bar_baz.name}-#{bar_baz.version}", lines[1].split.first)
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_uninstall_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_uninstall_command.rb
@@ -1,13 +1,12 @@
 # frozen_string_literal: true
-require 'rubygems/installer_test_case'
-require 'rubygems/commands/uninstall_command'
+require_relative "installer_test_case"
+require "rubygems/commands/uninstall_command"
 
 class TestGemCommandsUninstallCommand < Gem::InstallerTestCase
-
   def setup
     super
     @cmd = Gem::Commands::UninstallCommand.new
-    @executable = File.join(@gemhome, 'bin', 'executable')
+    @executable = File.join(@gemhome, "bin", "executable")
   end
 
   def test_execute_all_named
@@ -15,20 +14,20 @@ class TestGemCommandsUninstallCommand < 
 
     util_make_gems
 
-    default = new_default_spec 'default', '1'
+    default = new_default_spec "default", "1"
     install_default_gems default
 
     gemhome2 = "#{@gemhome}2"
 
-    a_4, = util_gem 'a', 4
+    a_4, = util_gem "a", 4
     install_gem a_4, :install_dir => gemhome2
 
     Gem::Specification.dirs = [@gemhome, gemhome2]
 
-    assert_includes Gem::Specification.all_names, 'a-1'
-    assert_includes Gem::Specification.all_names, 'a-4'
-    assert_includes Gem::Specification.all_names, 'b-2'
-    assert_includes Gem::Specification.all_names, 'default-1'
+    assert_includes Gem::Specification.all_names, "a-1"
+    assert_includes Gem::Specification.all_names, "a-4"
+    assert_includes Gem::Specification.all_names, "b-2"
+    assert_includes Gem::Specification.all_names, "default-1"
 
     @cmd.options[:all] = true
     @cmd.options[:args] = %w[a]
@@ -42,10 +41,10 @@ class TestGemCommandsUninstallCommand < 
   end
 
   def test_execute_all_named_default_single
-    z_1 = new_default_spec 'z', '1'
+    z_1 = new_default_spec "z", "1"
     install_default_gems z_1
 
-    assert_includes Gem::Specification.all_names, 'z-1'
+    assert_includes Gem::Specification.all_names, "z-1"
 
     @cmd.options[:all] = true
     @cmd.options[:args] = %w[z]
@@ -58,18 +57,18 @@ class TestGemCommandsUninstallCommand < 
 
     output = @ui.output.split "\n"
 
-    assert_equal 'Gem z-1 cannot be uninstalled because it is a default gem', output.shift
+    assert_equal "Gem z-1 cannot be uninstalled because it is a default gem", output.shift
   end
 
   def test_execute_all_named_default_multiple
-    z_1 = new_default_spec 'z', '1'
+    z_1 = new_default_spec "z", "1"
     install_default_gems z_1
 
-    z_2, = util_gem 'z', 2
+    z_2, = util_gem "z", 2
     install_gem z_2
 
-    assert_includes Gem::Specification.all_names, 'z-1'
-    assert_includes Gem::Specification.all_names, 'z-2'
+    assert_includes Gem::Specification.all_names, "z-1"
+    assert_includes Gem::Specification.all_names, "z-2"
 
     @cmd.options[:all] = true
     @cmd.options[:args] = %w[z]
@@ -82,15 +81,15 @@ class TestGemCommandsUninstallCommand < 
 
     output = @ui.output.split "\n"
 
-    assert_equal 'Gem z-1 cannot be uninstalled because it is a default gem', output.shift
-    assert_equal 'Successfully uninstalled z-2', output.shift
+    assert_equal "Gem z-1 cannot be uninstalled because it is a default gem", output.shift
+    assert_equal "Successfully uninstalled z-2", output.shift
   end
 
   def test_execute_dependency_order
     initial_install
 
-    c = quick_gem 'c' do |spec|
-      spec.add_dependency 'a'
+    c = quick_gem "c" do |spec|
+      spec.add_dependency "a"
     end
 
     util_build_gem c
@@ -111,9 +110,9 @@ class TestGemCommandsUninstallCommand < 
 
     output = ui.output.split "\n"
 
-    assert_equal 'Successfully uninstalled c-2', output.shift
+    assert_equal "Successfully uninstalled c-2", output.shift
     assert_equal "Removing executable",          output.shift
-    assert_equal 'Successfully uninstalled a-2', output.shift
+    assert_equal "Successfully uninstalled a-2", output.shift
   end
 
   def test_execute_removes_executable
@@ -150,12 +149,12 @@ class TestGemCommandsUninstallCommand < 
 
     FileUtils.rm_f @executable # Wish this didn't happen in #setup
 
-    Gem::Installer.exec_format = 'foo-%s-bar'
+    Gem::Installer.exec_format = "foo-%s-bar"
 
     installer.format_executable = true
     installer.install
 
-    formatted_executable = File.join @gemhome, 'bin', 'foo-executable-bar'
+    formatted_executable = File.join @gemhome, "bin", "foo-executable-bar"
     assert_equal true, File.exist?(formatted_executable)
 
     @cmd.options[:executables] = true
@@ -198,19 +197,19 @@ class TestGemCommandsUninstallCommand < 
 
     util_make_gems
 
-    assert_equal 3, Gem::Specification.find_all_by_name('a').length
+    assert_equal 3, Gem::Specification.find_all_by_name("a").length
 
-    @cmd.options[:version] = '1'
+    @cmd.options[:version] = "1"
     @cmd.options[:force] = true
-    @cmd.options[:args] = ['a']
+    @cmd.options[:args] = ["a"]
 
     use_ui ui do
       @cmd.execute
     end
 
-    assert_equal 2, Gem::Specification.find_all_by_name('a').length
+    assert_equal 2, Gem::Specification.find_all_by_name("a").length
 
-    assert File.exist? File.join(@gemhome, 'bin', 'executable')
+    assert File.exist? File.join(@gemhome, "bin", "executable")
   end
 
   def test_execute_with_version_specified_as_colon
@@ -220,18 +219,18 @@ class TestGemCommandsUninstallCommand < 
 
     util_make_gems
 
-    assert_equal 3, Gem::Specification.find_all_by_name('a').length
+    assert_equal 3, Gem::Specification.find_all_by_name("a").length
 
     @cmd.options[:force] = true
-    @cmd.options[:args] = ['a:1']
+    @cmd.options[:args] = ["a:1"]
 
     use_ui ui do
       @cmd.execute
     end
 
-    assert_equal 2, Gem::Specification.find_all_by_name('a').length
+    assert_equal 2, Gem::Specification.find_all_by_name("a").length
 
-    assert File.exist? File.join(@gemhome, 'bin', 'executable')
+    assert File.exist? File.join(@gemhome, "bin", "executable")
   end
 
   def test_uninstall_selection
@@ -239,22 +238,22 @@ class TestGemCommandsUninstallCommand < 
 
     util_make_gems
 
-    list = Gem::Specification.find_all_by_name 'a'
+    list = Gem::Specification.find_all_by_name "a"
 
-    @cmd.options[:args] = ['a']
+    @cmd.options[:args] = ["a"]
 
     use_ui ui do
       @cmd.execute
     end
 
-    updated_list = Gem::Specification.find_all_by_name('a')
+    updated_list = Gem::Specification.find_all_by_name("a")
     assert_equal list.length - 1, updated_list.length
 
-    assert_match ' 1. a-1',          ui.output
-    assert_match ' 2. a-2',          ui.output
-    assert_match ' 3. a-3.a',        ui.output
-    assert_match ' 4. All versions', ui.output
-    assert_match 'uninstalled a-1',  ui.output
+    assert_match " 1. a-1",          ui.output
+    assert_match " 2. a-2",          ui.output
+    assert_match " 3. a-3.a",        ui.output
+    assert_match " 4. All versions", ui.output
+    assert_match "uninstalled a-1",  ui.output
   end
 
   def test_uninstall_selection_multiple_gems
@@ -262,31 +261,31 @@ class TestGemCommandsUninstallCommand < 
 
     util_make_gems
 
-    a_list = Gem::Specification.find_all_by_name('a')
-    b_list = Gem::Specification.find_all_by_name('b')
+    a_list = Gem::Specification.find_all_by_name("a")
+    b_list = Gem::Specification.find_all_by_name("b")
     list   = a_list + b_list
 
-    @cmd.options[:args] = ['a', 'b']
+    @cmd.options[:args] = ["a", "b"]
 
     use_ui ui do
       @cmd.execute
     end
 
-    updated_a_list = Gem::Specification.find_all_by_name('a')
-    updated_b_list = Gem::Specification.find_all_by_name('b')
+    updated_a_list = Gem::Specification.find_all_by_name("a")
+    updated_b_list = Gem::Specification.find_all_by_name("b")
     updated_list   = updated_a_list + updated_b_list
 
     assert_equal list.length - 2, updated_list.length
 
     out = ui.output.split("\n")
-    assert_match 'uninstalled b-2',          out.shift
-    assert_match '',                         out.shift
-    assert_match 'Select gem to uninstall:', out.shift
-    assert_match ' 1. a-1',                  out.shift
-    assert_match ' 2. a-2',                  out.shift
-    assert_match ' 3. a-3.a',                out.shift
-    assert_match ' 4. All versions',         out.shift
-    assert_match 'uninstalled a-1',          out.shift
+    assert_match "uninstalled b-2",          out.shift
+    assert_match "",                         out.shift
+    assert_match "Select gem to uninstall:", out.shift
+    assert_match " 1. a-1",                  out.shift
+    assert_match " 2. a-2",                  out.shift
+    assert_match " 3. a-3.a",                out.shift
+    assert_match " 4. All versions",         out.shift
+    assert_match "uninstalled a-1",          out.shift
     assert_empty                             out
   end
 
@@ -295,22 +294,22 @@ class TestGemCommandsUninstallCommand < 
 
     ui = Gem::MockGemUi.new "y\n"
 
-    a_1, = util_gem 'a', 1
+    a_1, = util_gem "a", 1
     install_gem a_1
 
-    a_3a, = util_gem 'a', '3.a'
+    a_3a, = util_gem "a", "3.a"
     install_gem a_3a
 
-    assert_equal 3, Gem::Specification.find_all_by_name('a').length
+    assert_equal 3, Gem::Specification.find_all_by_name("a").length
 
     @cmd.options[:force] = true
-    @cmd.options[:args] = ['a']
+    @cmd.options[:args] = ["a"]
 
     use_ui ui do
       @cmd.execute
     end
 
-    assert_empty Gem::Specification.find_all_by_name('a')
+    assert_empty Gem::Specification.find_all_by_name("a")
     assert_match "Removing executable", ui.output
     refute File.exist? @executable
   end
@@ -322,36 +321,36 @@ class TestGemCommandsUninstallCommand < 
 
     util_make_gems
 
-    assert Gem::Specification.find_all_by_name('dep_x').length > 0
-    assert Gem::Specification.find_all_by_name('x').length > 0
+    assert Gem::Specification.find_all_by_name("dep_x").length > 0
+    assert Gem::Specification.find_all_by_name("x").length > 0
 
     @cmd.options[:force] = true
-    @cmd.options[:args] = ['x']
+    @cmd.options[:args] = ["x"]
 
     use_ui ui do
       @cmd.execute
     end
 
-    assert Gem::Specification.find_all_by_name('dep_x').length > 0
-    assert Gem::Specification.find_all_by_name('x').length.zero?
+    assert Gem::Specification.find_all_by_name("dep_x").length > 0
+    assert Gem::Specification.find_all_by_name("x").length.zero?
   end
 
   def test_execute_all
     util_make_gems
 
-    default = new_default_spec 'default', '1'
+    default = new_default_spec "default", "1"
     install_default_gems default
 
     gemhome2 = "#{@gemhome}2"
 
-    a_4, = util_gem 'a', 4
+    a_4, = util_gem "a", 4
     install_gem a_4
 
     Gem::Specification.dirs = [@gemhome, gemhome2]
 
-    assert_includes Gem::Specification.all_names, 'a-1'
-    assert_includes Gem::Specification.all_names, 'a-4'
-    assert_includes Gem::Specification.all_names, 'default-1'
+    assert_includes Gem::Specification.all_names, "a-1"
+    assert_includes Gem::Specification.all_names, "a-4"
+    assert_includes Gem::Specification.all_names, "default-1"
 
     @cmd.options[:all] = true
     @cmd.options[:args] = []
@@ -369,16 +368,16 @@ class TestGemCommandsUninstallCommand < 
 
     gemhome2 = "#{@gemhome}2"
 
-    a_4, = util_gem 'a', 4
+    a_4, = util_gem "a", 4
     install_gem a_4 , :install_dir => gemhome2
 
     Gem::Specification.dirs = [@gemhome, gemhome2]
 
-    assert_includes Gem::Specification.all_names, 'a-4'
+    assert_includes Gem::Specification.all_names, "a-4"
 
-    @cmd.options[:args] = ['a:4']
+    @cmd.options[:args] = ["a:4"]
 
-    e = assert_raises Gem::InstallError do
+    e = assert_raise Gem::InstallError do
       use_ui ui do
         @cmd.execute
       end
@@ -398,7 +397,7 @@ class TestGemCommandsUninstallCommand < 
   end
 
   def test_handle_options_vendor
-    vendordir(File.join(@tempdir, 'vendor')) do
+    vendordir(File.join(@tempdir, "vendor")) do
       use_ui @ui do
         @cmd.handle_options %w[--vendor]
       end
@@ -421,7 +420,7 @@ WARNING:  Use your OS package manager to
     @cmd.options[:version] = Gem::Requirement.new("> 1")
 
     use_ui @ui do
-      e = assert_raises Gem::MockGemUi::TermError do
+      e = assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
 
@@ -437,11 +436,11 @@ WARNING:  Use your OS package manager to
 
   def test_handle_options_vendor_missing
     vendordir(nil) do
-      e = assert_raises OptionParser::InvalidOption do
+      e = assert_raise Gem::OptionParser::InvalidOption do
         @cmd.handle_options %w[--vendor]
       end
 
-      assert_equal 'invalid option: --vendor your platform is not supported',
+      assert_equal "invalid option: --vendor your platform is not supported",
                    e.message
 
       refute @cmd.options[:vendor]
@@ -450,7 +449,7 @@ WARNING:  Use your OS package manager to
   end
 
   def test_execute_with_gem_not_installed
-    @cmd.options[:args] = ['d']
+    @cmd.options[:args] = ["d"]
 
     use_ui ui do
       @cmd.execute
@@ -478,7 +477,7 @@ WARNING:  Use your OS package manager to
     e = nil
     @cmd.stub :uninstall, uninstall_exception do
       use_ui @ui do
-        e = assert_raises Gem::MockGemUi::TermError do
+        e = assert_raise Gem::MockGemUi::TermError do
           @cmd.execute
         end
       end
@@ -487,7 +486,7 @@ WARNING:  Use your OS package manager to
     end
 
     assert_empty @ui.output
-    assert_match %r!Error: unable to successfully uninstall '#{@spec.name}'!, @ui.error
+    assert_match %r{Error: unable to successfully uninstall '#{@spec.name}'}, @ui.error
   end
 
   private
@@ -502,5 +501,4 @@ WARNING:  Use your OS package manager to
       end
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_unpack_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_unpack_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/unpack_command'
+require_relative "helper"
+require "rubygems/commands/unpack_command"
 
 class TestGemCommandsUnpackCommand < Gem::TestCase
-
   def setup
     super
 
@@ -18,28 +17,28 @@ class TestGemCommandsUnpackCommand < Gem
     assert_equal(
       @cmd.find_in_cache(File.basename @a1.cache_file),
       @a1.cache_file,
-      'found a-1.gem in the cache'
+      "found a-1.gem in the cache"
     )
   end
 
   def test_get_path
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
+      fetcher.gem "a", 1
     end
 
-    dep = Gem::Dependency.new 'a', 1
+    dep = Gem::Dependency.new "a", 1
     assert_equal(
       @cmd.get_path(dep),
-      specs['a-1'].cache_file,
-      'fetches a-1 and returns the cache path'
+      specs["a-1"].cache_file,
+      "fetches a-1 and returns the cache path"
     )
 
-    FileUtils.rm specs['a-1'].cache_file
+    FileUtils.rm specs["a-1"].cache_file
 
     assert_equal(
       @cmd.get_path(dep),
-      specs['a-1'].cache_file,
-      'when removed from cache, refetches a-1'
+      specs["a-1"].cache_file,
+      "when removed from cache, refetches a-1"
     )
   end
 
@@ -54,18 +53,18 @@ class TestGemCommandsUnpackCommand < Gem
       end
     end
 
-    assert File.exist?(File.join(@tempdir, 'a-3.a')), 'a should be unpacked'
-    assert File.exist?(File.join(@tempdir, 'b-2')),   'b should be unpacked'
+    assert File.exist?(File.join(@tempdir, "a-3.a")), "a should be unpacked"
+    assert File.exist?(File.join(@tempdir, "b-2")),   "b should be unpacked"
   end
 
   def test_execute_gem_path
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', '3.a'
+      fetcher.gem "a", "3.a"
     end
 
     Gem.clear_paths
 
-    gemhome2 = File.join @tempdir, 'gemhome2'
+    gemhome2 = File.join @tempdir, "gemhome2"
 
     Gem.use_paths gemhome2, [gemhome2, @gemhome]
 
@@ -77,7 +76,7 @@ class TestGemCommandsUnpackCommand < Gem
       end
     end
 
-    assert File.exist?(File.join(@tempdir, 'a-3.a'))
+    assert File.exist?(File.join(@tempdir, "a-3.a"))
   end
 
   def test_execute_gem_path_missing
@@ -85,7 +84,7 @@ class TestGemCommandsUnpackCommand < Gem
 
     Gem.clear_paths
 
-    gemhome2 = File.join @tempdir, 'gemhome2'
+    gemhome2 = File.join @tempdir, "gemhome2"
 
     Gem.use_paths gemhome2, [gemhome2, @gemhome]
 
@@ -97,13 +96,13 @@ class TestGemCommandsUnpackCommand < Gem
       end
     end
 
-    assert_equal '', @ui.output
+    assert_equal "", @ui.output
   end
 
   def test_execute_remote
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 1
-      fetcher.download 'a', 2
+      fetcher.download "a", 1
+      fetcher.download "a", 2
     end
 
     Gem.configuration.verbose = :really
@@ -115,7 +114,7 @@ class TestGemCommandsUnpackCommand < Gem
       end
     end
 
-    assert File.exist?(File.join(@tempdir, 'a-2')), 'a should be unpacked'
+    assert File.exist?(File.join(@tempdir, "a-2")), "a should be unpacked"
   end
 
   def test_execute_spec
@@ -130,15 +129,15 @@ class TestGemCommandsUnpackCommand < Gem
       end
     end
 
-    assert File.exist?(File.join(@tempdir, 'a-3.a.gemspec'))
-    assert File.exist?(File.join(@tempdir, 'b-2.gemspec'))
+    assert File.exist?(File.join(@tempdir, "a-3.a.gemspec"))
+    assert File.exist?(File.join(@tempdir, "b-2.gemspec"))
   end
 
   def test_execute_spec_target
     util_make_gems
 
     @cmd.options[:args] = %w[a b]
-    @cmd.options[:target] = 'specs'
+    @cmd.options[:target] = "specs"
     @cmd.options[:spec] = true
 
     use_ui @ui do
@@ -147,12 +146,12 @@ class TestGemCommandsUnpackCommand < Gem
       end
     end
 
-    assert File.exist?(File.join(@tempdir, 'specs/a-3.a.gemspec'))
-    assert File.exist?(File.join(@tempdir, 'specs/b-2.gemspec'))
+    assert File.exist?(File.join(@tempdir, "specs/a-3.a.gemspec"))
+    assert File.exist?(File.join(@tempdir, "specs/b-2.gemspec"))
   end
 
   def test_execute_sudo
-    skip 'Cannot perform this test on windows (chmod)' if win_platform?
+    pend "Cannot perform this test on windows (chmod)" if win_platform?
 
     util_make_gems
 
@@ -166,7 +165,7 @@ class TestGemCommandsUnpackCommand < Gem
       end
     end
 
-    assert File.exist?(File.join(@tempdir, 'b-2')), 'b should be unpacked'
+    assert File.exist?(File.join(@tempdir, "b-2")), "b should be unpacked"
   ensure
     FileUtils.chmod 0755, @gemhome
   end
@@ -174,7 +173,7 @@ class TestGemCommandsUnpackCommand < Gem
   def test_execute_with_target_option
     util_make_gems
 
-    target = 'with_target'
+    target = "with_target"
     @cmd.options[:args] = %w[a]
     @cmd.options[:target] = target
 
@@ -184,12 +183,12 @@ class TestGemCommandsUnpackCommand < Gem
       end
     end
 
-    assert File.exist?(File.join(@tempdir, target, 'a-3.a'))
+    assert File.exist?(File.join(@tempdir, target, "a-3.a"))
   end
 
   def test_execute_exact_match
-    foo_spec = util_spec 'foo'
-    foo_bar_spec = util_spec 'foo_bar'
+    foo_spec = util_spec "foo"
+    foo_bar_spec = util_spec "foo_bar"
 
     use_ui @ui do
       Dir.chdir @tempdir do
@@ -211,7 +210,7 @@ class TestGemCommandsUnpackCommand < Gem
       end
     end
 
-    assert_path_exists File.join(@tempdir, foo_spec.full_name)
+    assert_path_exist File.join(@tempdir, foo_spec.full_name)
   end
 
   def test_handle_options_metadata
@@ -221,5 +220,4 @@ class TestGemCommandsUnpackCommand < Gem
 
     assert @cmd.options[:spec]
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_update_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_update_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/update_command'
+require_relative "helper"
+require "rubygems/commands/update_command"
 
 class TestGemCommandsUpdateCommand < Gem::TestCase
-
   def setup
     super
     common_installer_setup
@@ -13,20 +12,20 @@ class TestGemCommandsUpdateCommand < Gem
     @cmd.options[:document] = []
 
     @specs = spec_fetcher do |fetcher|
-      fetcher.download 'a', 1
-      fetcher.download 'a', 2
-      fetcher.download 'a', '3.a'
+      fetcher.download "a", 1
+      fetcher.download "a", 2
+      fetcher.download "a", "3.a"
     end
 
-    @a1_path  = @specs['a-1'].cache_file
-    @a2_path  = @specs['a-1'].cache_file
-    @a3a_path = @specs['a-3.a'].cache_file
+    @a1_path  = @specs["a-1"].cache_file
+    @a2_path  = @specs["a-1"].cache_file
+    @a3a_path = @specs["a-3.a"].cache_file
   end
 
   def test_execute
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
-      fetcher.spec 'a', 1
+      fetcher.download "a", 2
+      fetcher.spec "a", 1
     end
 
     @cmd.options[:args] = []
@@ -44,11 +43,11 @@ class TestGemCommandsUpdateCommand < Gem
 
   def test_execute_multiple
     spec_fetcher do |fetcher|
-      fetcher.download 'a',  2
-      fetcher.download 'ab', 2
+      fetcher.download "a",  2
+      fetcher.download "ab", 2
 
-      fetcher.spec 'a',  1
-      fetcher.spec 'ab', 1
+      fetcher.spec "a",  1
+      fetcher.spec "ab", 1
     end
 
     @cmd.options[:args] = %w[a]
@@ -66,7 +65,7 @@ class TestGemCommandsUpdateCommand < Gem
 
   def test_execute_system
     spec_fetcher do |fetcher|
-      fetcher.download 'rubygems-update', 9 do |s|
+      fetcher.download "rubygems-update", 9 do |s|
         s.files = %w[setup.rb]
       end
     end
@@ -88,7 +87,7 @@ class TestGemCommandsUpdateCommand < Gem
 
   def test_execute_system_at_latest
     spec_fetcher do |fetcher|
-      fetcher.download 'rubygems-update', Gem::VERSION do |s|
+      fetcher.download "rubygems-update", Gem::VERSION do |s|
         s.files = %w[setup.rb]
       end
     end
@@ -96,7 +95,7 @@ class TestGemCommandsUpdateCommand < Gem
     @cmd.options[:args]          = []
     @cmd.options[:system]        = true
 
-    assert_raises Gem::MockGemUi::SystemExitException do
+    assert_raise Gem::MockGemUi::SystemExitException do
       use_ui @ui do
         @cmd.execute
       end
@@ -107,17 +106,76 @@ class TestGemCommandsUpdateCommand < Gem
     assert_empty out
   end
 
+  def test_execute_system_when_latest_does_not_support_your_ruby
+    spec_fetcher do |fetcher|
+      fetcher.download "rubygems-update", 9 do |s|
+        s.files = %w[setup.rb]
+        s.required_ruby_version = "> 9"
+      end
+    end
+
+    @cmd.options[:args]          = []
+    @cmd.options[:system]        = true
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    out = @ui.output.split "\n"
+    assert_equal "Updating rubygems-update", out.shift
+    assert_empty out
+
+    err = @ui.error.split "\n"
+    assert_equal "ERROR:  Error installing rubygems-update:", err.shift
+    assert_equal "\trubygems-update-9 requires Ruby version > 9. The current ruby version is #{Gem.ruby_version}.", err.shift
+    assert_empty err
+  end
+
   def test_execute_system_multiple
     spec_fetcher do |fetcher|
-      fetcher.download 'rubygems-update', 8 do |s|
+      fetcher.download "rubygems-update", 8 do |s|
+        s.files = %w[setup.rb]
+      end
+
+      fetcher.download "rubygems-update", 9 do |s|
+        s.files = %w[setup.rb]
+      end
+    end
+
+    @cmd.options[:args]          = []
+    @cmd.options[:system]        = true
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    out = @ui.output.split "\n"
+    assert_equal "Updating rubygems-update", out.shift
+    assert_equal "Installing RubyGems 9", out.shift
+    assert_equal "RubyGems system software updated", out.shift
+
+    assert_empty out
+  end
+
+  def test_execute_system_update_installed
+    spec_fetcher do |fetcher|
+      fetcher.download "rubygems-update", 8 do |s|
         s.files = %w[setup.rb]
       end
+    end
+
+    @cmd.options[:args]          = []
+    @cmd.options[:system]        = true
+
+    @cmd.execute
 
-      fetcher.download 'rubygems-update', 9 do |s|
+    spec_fetcher do |fetcher|
+      fetcher.download "rubygems-update", 9 do |s|
         s.files = %w[setup.rb]
       end
     end
 
+    @cmd = Gem::Commands::UpdateCommand.new
     @cmd.options[:args]          = []
     @cmd.options[:system]        = true
 
@@ -133,13 +191,44 @@ class TestGemCommandsUpdateCommand < Gem
     assert_empty out
   end
 
+  def test_execute_system_update_installed_in_non_default_gem_path
+    rubygems_update_spec = quick_gem "rubygems-update", 9 do |s|
+      write_file File.join(@tempdir, "setup.rb")
+
+      s.files += %w[setup.rb]
+    end
+
+    util_setup_spec_fetcher rubygems_update_spec
+
+    rubygems_update_package = Gem::Package.build rubygems_update_spec
+
+    gemhome2 = "#{@gemhome}2"
+
+    Gem::Installer.at(rubygems_update_package, :install_dir => gemhome2).install
+
+    Gem.use_paths @gemhome, [gemhome2, @gemhome]
+
+    @cmd.options[:args]          = []
+    @cmd.options[:system]        = true
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    out = @ui.output.split "\n"
+    assert_equal "Installing RubyGems 9", out.shift
+    assert_equal "RubyGems system software updated", out.shift
+
+    assert_empty out
+  end
+
   def test_execute_system_specific
     spec_fetcher do |fetcher|
-      fetcher.download 'rubygems-update', 8 do |s|
+      fetcher.download "rubygems-update", 8 do |s|
         s.files = %w[setup.rb]
       end
 
-      fetcher.download 'rubygems-update', 9 do |s|
+      fetcher.download "rubygems-update", 9 do |s|
         s.files = %w[setup.rb]
       end
     end
@@ -159,13 +248,98 @@ class TestGemCommandsUpdateCommand < Gem
     assert_empty out
   end
 
+  def test_execute_system_specific_older_than_minimum_supported_rubygems
+    spec_fetcher do |fetcher|
+      fetcher.download "rubygems-update", "2.5.1" do |s|
+        s.files = %w[setup.rb]
+      end
+    end
+
+    @cmd.options[:args]          = []
+    @cmd.options[:system]        = "2.5.1"
+
+    oldest_version_mod = Module.new do
+      def oldest_supported_version
+        Gem::Version.new("2.5.2")
+      end
+      private :oldest_supported_version
+    end
+
+    @cmd.extend(oldest_version_mod)
+
+    assert_raise Gem::MockGemUi::TermError do
+      use_ui @ui do
+        @cmd.execute
+      end
+    end
+
+    assert_empty @ui.output
+    assert_equal "ERROR:  rubygems 2.5.1 is not supported on #{RUBY_VERSION}. The oldest version supported by this ruby is 2.5.2\n", @ui.error
+  end
+
+  def test_execute_system_specific_older_than_3_2_removes_plugins_dir
+    spec_fetcher do |fetcher|
+      fetcher.download "rubygems-update", 3.1 do |s|
+        s.files = %w[setup.rb]
+      end
+    end
+
+    oldest_version_mod = Module.new do
+      def oldest_supported_version
+        Gem::Version.new("2.5.2")
+      end
+      private :oldest_supported_version
+    end
+
+    @cmd.extend(oldest_version_mod)
+
+    @cmd.options[:args]          = []
+    @cmd.options[:system]        = "3.1"
+
+    FileUtils.mkdir_p Gem.plugindir
+    write_file File.join(Gem.plugindir, "a_plugin.rb")
+
+    @cmd.execute
+
+    assert_path_not_exist Gem.plugindir, "Plugins folder not removed when updating rubygems to pre-3.2"
+  end
+
+  def test_execute_system_specific_newer_than_or_equal_to_3_2_leaves_plugins_dir_alone
+    spec_fetcher do |fetcher|
+      fetcher.download "rubygems-update", "3.2.a" do |s|
+        s.files = %w[setup.rb]
+      end
+    end
+
+    oldest_version_mod = Module.new do
+      def oldest_supported_version
+        Gem::Version.new("2.5.2")
+      end
+      private :oldest_supported_version
+    end
+
+    @cmd.extend(oldest_version_mod)
+
+    @cmd.options[:args]          = []
+    @cmd.options[:system]        = "3.2.a"
+
+    FileUtils.mkdir_p Gem.plugindir
+    plugin_file = File.join(Gem.plugindir, "a_plugin.rb")
+    write_file plugin_file
+
+    @cmd.execute
+
+    assert_path_exist Gem.plugindir, "Plugin folder removed when updating rubygems to post-3.2"
+    assert_path_exist plugin_file, "Plugin removed when updating rubygems to post-3.2"
+  end
+
   def test_execute_system_specifically_to_latest_version
     spec_fetcher do |fetcher|
-      fetcher.download 'rubygems-update', 8 do |s|
+      fetcher.download "rubygems-update", 8 do |s|
         s.files = %w[setup.rb]
       end
 
-      fetcher.download 'rubygems-update', 9 do |s|
+      fetcher.download "rubygems-update", 9 do |s|
         s.files = %w[setup.rb]
       end
     end
@@ -189,7 +363,7 @@ class TestGemCommandsUpdateCommand < Gem
     @cmd.options[:args]          = %w[gem]
     @cmd.options[:system]        = true
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       use_ui @ui do
         @cmd.execute
       end
@@ -200,6 +374,53 @@ class TestGemCommandsUpdateCommand < Gem
                  @ui.error
   end
 
+  def test_execute_system_with_disabled_update
+    old_disable_system_update_message = Gem.disable_system_update_message
+    Gem.disable_system_update_message = "Please use package manager instead."
+
+    @cmd.options[:args] = []
+    @cmd.options[:system] = true
+
+    assert_raise Gem::MockGemUi::TermError do
+      use_ui @ui do
+        @cmd.execute
+      end
+    end
+
+    assert_empty @ui.output
+    assert_equal "ERROR:  Please use package manager instead.\n", @ui.error
+  ensure
+    Gem.disable_system_update_message = old_disable_system_update_message
+  end
+
+  # The other style of `gem update --system` tests don't actually run
+  # setup.rb, so we just check that setup.rb gets the `--silent` flag.
+  def test_execute_system_silent_passed_to_setuprb
+    @cmd.options[:args] = []
+    @cmd.options[:system] = true
+    @cmd.options[:silent] = true
+
+    assert_equal true, @cmd.update_rubygems_arguments.include?("--silent")
+  end
+
+  def test_execute_system_silent
+    spec_fetcher do |fetcher|
+      fetcher.download "rubygems-update", 9 do |s|
+        s.files = %w[setup.rb]
+      end
+    end
+
+    @cmd.options[:args]          = []
+    @cmd.options[:system]        = true
+    @cmd.options[:silent]        = true
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    assert_empty @ui.output
+  end
+
   # before:
   #   a1 -> c1.2
   # after:
@@ -208,12 +429,12 @@ class TestGemCommandsUpdateCommand < Gem
 
   def test_execute_dependencies
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2, 'b' => 2, 'c' => 2
-      fetcher.download 'b', 2
-      fetcher.download 'c', 2
+      fetcher.download "a", 2, "b" => 2, "c" => 2
+      fetcher.download "b", 2
+      fetcher.download "c", 2
 
-      fetcher.spec 'a', 1, 'c' => '1.2'
-      fetcher.spec 'c', '1.2'
+      fetcher.spec "a", 1, "c" => "1.2"
+      fetcher.spec "c", "1.2"
     end
 
     Gem::Specification.reset
@@ -235,8 +456,8 @@ class TestGemCommandsUpdateCommand < Gem
 
   def test_execute_rdoc
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
-      fetcher.spec 'a', 1
+      fetcher.download "a", 2
+      fetcher.spec "a", 1
     end
 
     Gem.done_installing(&Gem::RDoc.method(:generation_hook))
@@ -251,16 +472,16 @@ class TestGemCommandsUpdateCommand < Gem
 
     wait_for_child_process_to_exit
 
-    a2 = @specs['a-2']
+    a2 = @specs["a-2"]
 
-    assert_path_exists File.join(a2.doc_dir, 'rdoc')
+    assert_path_exist File.join(a2.doc_dir, "rdoc")
   end
 
   def test_execute_named
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
+      fetcher.download "a", 2
 
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
     @cmd.options[:args] = %w[a]
@@ -279,10 +500,10 @@ class TestGemCommandsUpdateCommand < Gem
 
   def test_execute_named_some_up_to_date
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
-      fetcher.spec 'a', 1
+      fetcher.download "a", 2
+      fetcher.spec "a", 1
 
-      fetcher.spec 'b', 2
+      fetcher.spec "b", 2
     end
 
     @cmd.options[:args] = %w[a b]
@@ -302,7 +523,7 @@ class TestGemCommandsUpdateCommand < Gem
 
   def test_execute_named_up_to_date
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2
+      fetcher.spec "a", 2
     end
 
     @cmd.options[:args] = %w[a]
@@ -314,15 +535,16 @@ class TestGemCommandsUpdateCommand < Gem
     out = @ui.output.split "\n"
     assert_equal "Updating installed gems", out.shift
     assert_equal "Nothing to update", out.shift
+    assert_equal "Gems already up-to-date: a", out.shift
 
     assert_empty out
   end
 
   def test_execute_named_up_to_date_prerelease
     spec_fetcher do |fetcher|
-      fetcher.download 'a', '3.a'
+      fetcher.download "a", "3.a"
 
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     @cmd.options[:args] = %w[a]
@@ -342,7 +564,7 @@ class TestGemCommandsUpdateCommand < Gem
 
   def test_execute_up_to_date
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     @cmd.options[:args] = []
@@ -359,10 +581,10 @@ class TestGemCommandsUpdateCommand < Gem
   end
 
   def test_execute_user_install
-    spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
-      fetcher.spec 'a', 1
-    end
+    a = util_spec "a", 1
+    b = util_spec "b", 1
+    install_gem_user(a)
+    install_gem(b)
 
     @cmd.handle_options %w[--user-install]
 
@@ -373,68 +595,74 @@ class TestGemCommandsUpdateCommand < Gem
     installer = @cmd.installer
     user_install = installer.instance_variable_get :@user_install
 
-    assert user_install, 'user_install must be set on the installer'
+    assert user_install, "user_install must be set on the installer"
+
+    out = @ui.output.split "\n"
+    assert_equal "Updating installed gems", out.shift
+    assert_equal "Updating a", out.shift
+    assert_equal "Gems updated: a", out.shift
+    assert_empty out
   end
 
   def test_fetch_remote_gems
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 1
+      fetcher.gem "a", 2
     end
 
     expected = [
-      [Gem::NameTuple.new('a', v(2), Gem::Platform::RUBY),
+      [Gem::NameTuple.new("a", v(2), Gem::Platform::RUBY),
        Gem::Source.new(@gem_repo)],
     ]
 
-    assert_equal expected, @cmd.fetch_remote_gems(specs['a-1'])
+    assert_equal expected, @cmd.fetch_remote_gems(specs["a-1"])
   end
 
   def test_fetch_remote_gems_error
     Gem.sources.replace %w[http://nonexistent.example]
 
-    assert_raises Gem::RemoteFetcher::FetchError do
-      @cmd.fetch_remote_gems @specs['a-1']
+    assert_raise Gem::RemoteFetcher::FetchError do
+      @cmd.fetch_remote_gems @specs["a-1"]
     end
   end
 
   def test_fetch_remote_gems_mismatch
-    platform = Gem::Platform.new 'x86-freebsd9'
+    platform = Gem::Platform.new "x86-freebsd9"
 
     specs = spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', 2
+      fetcher.spec "a", 1
+      fetcher.spec "a", 2
 
-      fetcher.spec 'a', 2 do |s|
+      fetcher.spec "a", 2 do |s|
         s.platform = platform
       end
     end
 
     expected = [
-      [Gem::NameTuple.new('a', v(2), Gem::Platform::RUBY),
+      [Gem::NameTuple.new("a", v(2), Gem::Platform::RUBY),
        Gem::Source.new(@gem_repo)],
     ]
 
-    assert_equal expected, @cmd.fetch_remote_gems(specs['a-1'])
+    assert_equal expected, @cmd.fetch_remote_gems(specs["a-1"])
   end
 
   def test_fetch_remote_gems_prerelease
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
-      fetcher.gem 'a', 2
-      fetcher.gem 'a', '3.a'
+      fetcher.gem "a", 1
+      fetcher.gem "a", 2
+      fetcher.gem "a", "3.a"
     end
 
     @cmd.options[:prerelease] = true
 
     expected = [
-      [Gem::NameTuple.new('a', v(2), Gem::Platform::RUBY),
+      [Gem::NameTuple.new("a", v(2), Gem::Platform::RUBY),
        Gem::Source.new(@gem_repo)],
-      [Gem::NameTuple.new('a', v('3.a'), Gem::Platform::RUBY),
+      [Gem::NameTuple.new("a", v("3.a"), Gem::Platform::RUBY),
        Gem::Source.new(@gem_repo)],
     ]
 
-    assert_equal expected, @cmd.fetch_remote_gems(specs['a-1'])
+    assert_equal expected, @cmd.fetch_remote_gems(specs["a-1"])
   end
 
   def test_handle_options_system
@@ -442,7 +670,7 @@ class TestGemCommandsUpdateCommand < Gem
 
     expected = {
       :args     => [],
-      :document => %w[rdoc ri],
+      :document => %w[ri],
       :force    => false,
       :system   => true,
     }
@@ -451,7 +679,7 @@ class TestGemCommandsUpdateCommand < Gem
   end
 
   def test_handle_options_system_non_version
-    assert_raises ArgumentError do
+    assert_raise ArgumentError do
       @cmd.handle_options %w[--system non-version]
     end
   end
@@ -461,7 +689,7 @@ class TestGemCommandsUpdateCommand < Gem
 
     expected = {
       :args     => [],
-      :document => %w[rdoc ri],
+      :document => %w[ri],
       :force    => false,
       :system   => "1.3.7",
     }
@@ -471,11 +699,11 @@ class TestGemCommandsUpdateCommand < Gem
 
   def test_update_gem_prerelease
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', '1.a'
-      fetcher.gem  'a', '1.b'
+      fetcher.spec "a", "1.a"
+      fetcher.gem  "a", "1.b"
     end
 
-    @cmd.update_gem 'a', Gem::Requirement.new('= 1.b')
+    @cmd.update_gem "a", Gem::Requirement.new("= 1.b")
 
     refute_empty @cmd.updated
 
@@ -484,15 +712,15 @@ class TestGemCommandsUpdateCommand < Gem
 
   def test_update_gem_unresolved_dependency
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.gem  'a', 2 do |s|
-        s.add_dependency 'b', '>= 2'
+      fetcher.spec "a", 1
+      fetcher.gem  "a", 2 do |s|
+        s.add_dependency "b", ">= 2"
       end
 
-      fetcher.spec 'b', 1
+      fetcher.spec "b", 1
     end
 
-    @cmd.update_gem 'a'
+    @cmd.update_gem "a"
 
     assert_empty @cmd.updated
   end
@@ -502,18 +730,18 @@ class TestGemCommandsUpdateCommand < Gem
 
     arguments = @cmd.update_rubygems_arguments
 
-    assert_equal '--prefix',           arguments.shift
+    assert_equal "--prefix",           arguments.shift
     assert_equal Gem.prefix,           arguments.shift
-    assert_equal '--no-document',      arguments.shift
-    assert_equal '--previous-version', arguments.shift
+    assert_equal "--no-document",      arguments.shift
+    assert_equal "--previous-version", arguments.shift
     assert_equal Gem::VERSION,         arguments.shift
     assert_empty arguments
   end
 
   def test_explain
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
-      fetcher.spec 'a', 1
+      fetcher.download "a", 2
+      fetcher.spec "a", 1
     end
 
     @cmd.options[:explain] = true
@@ -533,13 +761,13 @@ class TestGemCommandsUpdateCommand < Gem
   def test_explain_platform_local
     local = Gem::Platform.local
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
+      fetcher.download "a", 2
 
-      fetcher.download 'a', 2 do |s|
+      fetcher.download "a", 2 do |s|
         s.platform = local
       end
 
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
     @cmd.options[:explain] = true
@@ -559,13 +787,13 @@ class TestGemCommandsUpdateCommand < Gem
   def test_explain_platform_ruby
     local = Gem::Platform.local
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
+      fetcher.download "a", 2
 
-      fetcher.download 'a', 2 do |s|
+      fetcher.download "a", 2 do |s|
         s.platform = local
       end
 
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
     # equivalent to --platform=ruby
@@ -585,4 +813,23 @@ class TestGemCommandsUpdateCommand < Gem
     assert_empty out
   end
 
+  def test_execute_named_not_installed_and_no_update
+    spec_fetcher do |fetcher|
+      fetcher.spec "a", 2
+    end
+
+    @cmd.options[:args] = %w[a b]
+
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    out = @ui.output.split "\n"
+    assert_equal "Updating installed gems", out.shift
+    assert_equal "Nothing to update", out.shift
+    assert_equal "Gems already up-to-date: a", out.shift
+    assert_equal "Gems not currently installed: b", out.shift
+
+    assert_empty out
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_which_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_which_command.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/which_command'
+require_relative "helper"
+require "rubygems/commands/which_command"
 
 class TestGemCommandsWhichCommand < Gem::TestCase
-
   def setup
     super
     Gem::Specification.reset
@@ -20,20 +19,20 @@ class TestGemCommandsWhichCommand < Gem:
     end
 
     assert_equal "#{@foo_bar.full_gem_path}/lib/foo_bar.rb\n", @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_execute_directory
     @cmd.handle_options %w[directory]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
 
-    assert_equal '', @ui.output
-    assert_match %r%Can.t find Ruby library file or shared library directory\n%,
+    assert_equal "", @ui.output
+    assert_match %r{Can.t find Ruby library file or shared library directory\n},
                  @ui.error
   end
 
@@ -45,13 +44,13 @@ class TestGemCommandsWhichCommand < Gem:
     @cmd.handle_options %w[foo_bar missinglib]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
 
     assert_equal "#{@foo_bar.full_gem_path}/lib/foo_bar.rb\n", @ui.output
-    assert_match %r%Can.t find Ruby library file or shared library missinglib\n%,
+    assert_match %r{Can.t find Ruby library file or shared library missinglib\n},
                  @ui.error
   end
 
@@ -59,19 +58,19 @@ class TestGemCommandsWhichCommand < Gem:
     @cmd.handle_options %w[missinglib]
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cmd.execute
       end
     end
 
-    assert_equal '', @ui.output
-    assert_match %r%Can.t find Ruby library file or shared library missinglib\n%,
+    assert_equal "", @ui.output
+    assert_match %r{Can.t find Ruby library file or shared library missinglib\n},
                  @ui.error
   end
 
   def util_foo_bar
     files = %w[lib/foo_bar.rb lib/directory/baz.rb Rakefile]
-    @foo_bar = util_spec 'foo_bar' do |gem|
+    @foo_bar = util_spec "foo_bar" do |gem|
       gem.files = files
     end
     install_specs @foo_bar
@@ -82,5 +81,4 @@ class TestGemCommandsWhichCommand < Gem:
       FileUtils.touch filename
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_commands_yank_command.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_commands_yank_command.rb
@@ -1,19 +1,26 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/commands/yank_command'
+require_relative "helper"
+require "rubygems/commands/yank_command"
 
 class TestGemCommandsYankCommand < Gem::TestCase
-
   def setup
     super
 
+    credential_setup
+
     @cmd = Gem::Commands::YankCommand.new
-    @cmd.options[:host] = 'http://example'
+    @cmd.options[:host] = "http://example"
 
     @fetcher = Gem::RemoteFetcher.fetcher
 
-    Gem.configuration.rubygems_api_key = 'key'
-    Gem.configuration.api_keys[:KEY] = 'other'
+    Gem.configuration.rubygems_api_key = "key"
+    Gem.configuration.api_keys[:KEY] = "other"
+  end
+
+  def teardown
+    credential_teardown
+
+    super
   end
 
   def test_handle_options
@@ -23,122 +30,151 @@ class TestGemCommandsYankCommand < Gem::
     assert_equal :KEY,         @cmd.options[:key]
     assert_equal "HOST",       @cmd.options[:host]
     assert_nil                 @cmd.options[:platform]
-    assert_equal req('= 1.0'), @cmd.options[:version]
+    assert_equal req("= 1.0"), @cmd.options[:version]
   end
 
   def test_handle_options_missing_argument
     %w[-v --version -p --platform].each do |option|
-      assert_raises OptionParser::MissingArgument do
+      assert_raise Gem::OptionParser::MissingArgument do
         @cmd.handle_options %W[a #{option}]
       end
     end
   end
 
   def test_execute
-    yank_uri = 'http://example/api/v1/gems/yank'
-    @fetcher.data[yank_uri] = ['Successfully yanked', 200, 'OK']
+    yank_uri = "http://example/api/v1/gems/yank"
+    @fetcher.data[yank_uri] = ["Successfully yanked", 200, "OK"]
 
     @cmd.options[:args]           = %w[a]
     @cmd.options[:added_platform] = true
-    @cmd.options[:version]        = req('= 1.0')
+    @cmd.options[:version]        = req("= 1.0")
 
     use_ui @ui do
       @cmd.execute
     end
 
-    assert_match %r%Yanking gem from http://example%, @ui.output
-    assert_match %r%Successfully yanked%,      @ui.output
+    assert_match %r{Yanking gem from http://example}, @ui.output
+    assert_match %r{Successfully yanked}, @ui.output
 
     platform = Gem.platforms[1]
-    body = @fetcher.last_request.body.split('&').sort
+    body = @fetcher.last_request.body.split("&").sort
     assert_equal %W[gem_name=a platform=#{platform} version=1.0], body
 
-    assert_equal 'key', @fetcher.last_request['Authorization']
+    assert_equal "key", @fetcher.last_request["Authorization"]
 
     assert_equal [yank_uri], @fetcher.paths
   end
 
   def test_execute_with_otp_success
-    response_fail = 'You have enabled multifactor authentication but your request doesn\'t have the correct OTP code. Please check it and retry.'
-    yank_uri = 'http://example/api/v1/gems/yank'
+    response_fail = "You have enabled multifactor authentication but your request doesn't have the correct OTP code. Please check it and retry."
+    yank_uri = "http://example/api/v1/gems/yank"
     @fetcher.data[yank_uri] = [
-      [response_fail, 401, 'Unauthorized'],
-      ['Successfully yanked', 200, 'OK']
+      [response_fail, 401, "Unauthorized"],
+      ["Successfully yanked", 200, "OK"],
     ]
 
     @cmd.options[:args]           = %w[a]
     @cmd.options[:added_platform] = true
-    @cmd.options[:version]        = req('= 1.0')
+    @cmd.options[:version]        = req("= 1.0")
 
     @otp_ui = Gem::MockGemUi.new "111111\n"
     use_ui @otp_ui do
       @cmd.execute
     end
 
-    assert_match 'You have enabled multi-factor authentication. Please enter OTP code.', @otp_ui.output
-    assert_match 'Code: ', @otp_ui.output
-    assert_match %r%Yanking gem from http://example%, @otp_ui.output
-    assert_match %r%Successfully yanked%,      @otp_ui.output
-    assert_equal '111111', @fetcher.last_request['OTP']
+    assert_match "You have enabled multi-factor authentication. Please enter OTP code.", @otp_ui.output
+    assert_match "Code: ", @otp_ui.output
+    assert_match %r{Yanking gem from http://example}, @otp_ui.output
+    assert_match %r{Successfully yanked}, @otp_ui.output
+    assert_equal "111111", @fetcher.last_request["OTP"]
   end
 
   def test_execute_with_otp_failure
-    response = 'You have enabled multifactor authentication but your request doesn\'t have the correct OTP code. Please check it and retry.'
-    yank_uri = 'http://example/api/v1/gems/yank'
-    @fetcher.data[yank_uri] = [response, 401, 'Unauthorized']
+    response = "You have enabled multifactor authentication but your request doesn't have the correct OTP code. Please check it and retry."
+    yank_uri = "http://example/api/v1/gems/yank"
+    @fetcher.data[yank_uri] = [response, 401, "Unauthorized"]
 
     @cmd.options[:args]           = %w[a]
     @cmd.options[:added_platform] = true
-    @cmd.options[:version]        = req('= 1.0')
+    @cmd.options[:version]        = req("= 1.0")
 
     @otp_ui = Gem::MockGemUi.new "111111\n"
     use_ui @otp_ui do
       @cmd.execute
     end
 
-    assert_match 'You have enabled multi-factor authentication. Please enter OTP code.', @otp_ui.output
+    assert_match "You have enabled multi-factor authentication. Please enter OTP code.", @otp_ui.output
     assert_match response, @otp_ui.output
-    assert_match 'Code: ', @otp_ui.output
-    assert_equal '111111', @fetcher.last_request['OTP']
+    assert_match "Code: ", @otp_ui.output
+    assert_equal "111111", @fetcher.last_request["OTP"]
   end
 
   def test_execute_key
-    yank_uri = 'http://example/api/v1/gems/yank'
-    @fetcher.data[yank_uri] = ['Successfully yanked', 200, 'OK']
+    yank_uri = "http://example/api/v1/gems/yank"
+    @fetcher.data[yank_uri] = ["Successfully yanked", 200, "OK"]
 
     @cmd.options[:args]    = %w[a]
-    @cmd.options[:version] = req('= 1.0')
+    @cmd.options[:version] = req("= 1.0")
     @cmd.options[:key]     = :KEY
 
     use_ui @ui do
       @cmd.execute
     end
 
-    body = @fetcher.last_request.body.split('&').sort
+    body = @fetcher.last_request.body.split("&").sort
     assert_equal %w[gem_name=a version=1.0], body
-    assert_equal 'other', @fetcher.last_request['Authorization']
+    assert_equal "other", @fetcher.last_request["Authorization"]
   end
 
   def test_execute_host
-    host = 'https://other.example'
+    host = "https://other.example"
     yank_uri = "#{host}/api/v1/gems/yank"
-    @fetcher.data[yank_uri] = ['Successfully yanked', 200, 'OK']
+    @fetcher.data[yank_uri] = ["Successfully yanked", 200, "OK"]
 
     @cmd.options[:args]    = %w[a]
-    @cmd.options[:version] = req('= 1.0')
+    @cmd.options[:version] = req("= 1.0")
     @cmd.options[:host]    = host
 
     use_ui @ui do
       @cmd.execute
     end
 
-    assert_match %r%Yanking gem from https://other.example%, @ui.output
-    assert_match %r%Successfully yanked%,      @ui.output
+    assert_match %r{Yanking gem from https://other.example}, @ui.output
+    assert_match %r{Successfully yanked}, @ui.output
 
-    body = @fetcher.last_request.body.split('&').sort
+    body = @fetcher.last_request.body.split("&").sort
     assert_equal %w[gem_name=a version=1.0], body
-    assert_equal 'key', @fetcher.last_request['Authorization']
+    assert_equal "key", @fetcher.last_request["Authorization"]
     assert_equal [yank_uri], @fetcher.paths
   end
 
+  def test_yank_gem_unathorized_api_key
+    response_forbidden = "The API key doesn't have access"
+    response_success   = "Successfully yanked"
+    host               = "http://example"
+
+    @fetcher.data["#{host}/api/v1/gems/yank"] = [
+      [response_forbidden, 403, "Forbidden"],
+      [response_success, 200, "OK"],
+    ]
+
+    @fetcher.data["#{host}/api/v1/api_key"] = ["", 200, "OK"]
+    @cmd.options[:args]           = %w[a]
+    @cmd.options[:added_platform] = true
+    @cmd.options[:version]        = req("= 1.0")
+    @cmd.instance_variable_set :@host, host
+    @cmd.instance_variable_set :@scope, :yank_rubygem
+
+    @ui = Gem::MockGemUi.new "some@mail.com\npass\n"
+    use_ui @ui do
+      @cmd.execute
+    end
+
+    access_notice = "The existing key doesn't have access of yank_rubygem on http://example. Please sign in to update access."
+    assert_match access_notice, @ui.output
+    assert_match "Email:", @ui.output
+    assert_match "Password:", @ui.output
+    assert_match "Added yank_rubygem scope to the existing API key", @ui.output
+    assert_match response_success, @ui.output
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_config_file.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_config_file.rb
@@ -1,25 +1,22 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/config_file'
+require_relative "helper"
+require "rubygems/config_file"
 
 class TestGemConfigFile < Gem::TestCase
-
   def setup
     super
 
-    @temp_conf = File.join @tempdir, '.gemrc'
+    credential_setup
+
+    @temp_conf = File.join @tempdir, ".gemrc"
 
     @cfg_args = %W[--config-file #{@temp_conf}]
 
-    @orig_SYSTEM_WIDE_CONFIG_FILE = Gem::ConfigFile::SYSTEM_WIDE_CONFIG_FILE
-    Gem::ConfigFile.send :remove_const, :SYSTEM_WIDE_CONFIG_FILE
-    Gem::ConfigFile.send :const_set, :SYSTEM_WIDE_CONFIG_FILE,
-                         File.join(@tempdir, 'system-gemrc')
     Gem::ConfigFile::OPERATING_SYSTEM_DEFAULTS.clear
     Gem::ConfigFile::PLATFORM_DEFAULTS.clear
 
-    @env_gemrc = ENV['GEMRC']
-    ENV['GEMRC'] = ''
+    @env_gemrc = ENV["GEMRC"]
+    ENV["GEMRC"] = ""
 
     util_config_file
   end
@@ -27,11 +24,10 @@ class TestGemConfigFile < Gem::TestCase
   def teardown
     Gem::ConfigFile::OPERATING_SYSTEM_DEFAULTS.clear
     Gem::ConfigFile::PLATFORM_DEFAULTS.clear
-    Gem::ConfigFile.send :remove_const, :SYSTEM_WIDE_CONFIG_FILE
-    Gem::ConfigFile.send :const_set, :SYSTEM_WIDE_CONFIG_FILE,
-                         @orig_SYSTEM_WIDE_CONFIG_FILE
 
-    ENV['GEMRC'] = @env_gemrc
+    ENV["GEMRC"] = @env_gemrc
+
+    credential_teardown
 
     super
   end
@@ -39,14 +35,15 @@ class TestGemConfigFile < Gem::TestCase
   def test_initialize
     assert_equal @temp_conf, @cfg.config_file_name
 
-    assert_equal false, @cfg.backtrace
+    assert_equal true, @cfg.backtrace
     assert_equal true, @cfg.update_sources
     assert_equal Gem::ConfigFile::DEFAULT_BULK_THRESHOLD, @cfg.bulk_threshold
     assert_equal true, @cfg.verbose
     assert_equal [@gem_repo], Gem.sources
     assert_equal 365, @cfg.cert_expiration_length_days
+    assert_equal false, @cfg.ipv4_fallback_enabled
 
-    File.open @temp_conf, 'w' do |fp|
+    File.open @temp_conf, "w" do |fp|
       fp.puts ":backtrace: true"
       fp.puts ":update_sources: false"
       fp.puts ":bulk_threshold: 10"
@@ -60,6 +57,7 @@ class TestGemConfigFile < Gem::TestCase
       fp.puts ":ssl_verify_mode: 0"
       fp.puts ":ssl_ca_cert: /etc/ssl/certs"
       fp.puts ":cert_expiration_length_days: 28"
+      fp.puts ":ipv4_fallback_enabled: true"
     end
 
     util_config_file
@@ -68,12 +66,20 @@ class TestGemConfigFile < Gem::TestCase
     assert_equal false, @cfg.verbose
     assert_equal false, @cfg.update_sources
     assert_equal %w[http://more-gems.example.com], @cfg.sources
-    assert_equal '--wrappers', @cfg[:install]
-    assert_equal(['/usr/ruby/1.8/lib/ruby/gems/1.8', '/var/ruby/1.8/gem_home'],
+    assert_equal "--wrappers", @cfg[:install]
+    assert_equal(["/usr/ruby/1.8/lib/ruby/gems/1.8", "/var/ruby/1.8/gem_home"],
                  @cfg.path)
     assert_equal 0, @cfg.ssl_verify_mode
-    assert_equal '/etc/ssl/certs', @cfg.ssl_ca_cert
+    assert_equal "/etc/ssl/certs", @cfg.ssl_ca_cert
     assert_equal 28, @cfg.cert_expiration_length_days
+    assert_equal true, @cfg.ipv4_fallback_enabled
+  end
+
+  def test_initialize_ipv4_fallback_enabled_env
+    ENV["IPV4_FALLBACK_ENABLED"] = "true"
+    util_config_file %W[--config-file #{@temp_conf}]
+
+    assert_equal true, @cfg.ipv4_fallback_enabled
   end
 
   def test_initialize_handle_arguments_config_file
@@ -96,37 +102,37 @@ class TestGemConfigFile < Gem::TestCase
 
   def test_initialize_operating_system_override
     Gem::ConfigFile::OPERATING_SYSTEM_DEFAULTS[:bulk_threshold] = 1
-    Gem::ConfigFile::OPERATING_SYSTEM_DEFAULTS['install'] = '--no-env-shebang'
+    Gem::ConfigFile::OPERATING_SYSTEM_DEFAULTS["install"] = "--no-env-shebang"
 
     Gem::ConfigFile::PLATFORM_DEFAULTS[:bulk_threshold] = 2
 
     util_config_file
 
     assert_equal 2, @cfg.bulk_threshold
-    assert_equal '--no-env-shebang', @cfg[:install]
+    assert_equal "--no-env-shebang", @cfg[:install]
   end
 
   def test_initialize_platform_override
     Gem::ConfigFile::PLATFORM_DEFAULTS[:bulk_threshold] = 2
-    Gem::ConfigFile::PLATFORM_DEFAULTS['install'] = '--no-env-shebang'
+    Gem::ConfigFile::PLATFORM_DEFAULTS["install"] = "--no-env-shebang"
 
-    File.open Gem::ConfigFile::SYSTEM_WIDE_CONFIG_FILE, 'w' do |fp|
+    File.open Gem::ConfigFile::SYSTEM_WIDE_CONFIG_FILE, "w" do |fp|
       fp.puts ":bulk_threshold: 3"
     end
 
     util_config_file
 
     assert_equal 3, @cfg.bulk_threshold
-    assert_equal '--no-env-shebang', @cfg[:install]
+    assert_equal "--no-env-shebang", @cfg[:install]
   end
 
   def test_initialize_system_wide_override
-    File.open Gem::ConfigFile::SYSTEM_WIDE_CONFIG_FILE, 'w' do |fp|
+    File.open Gem::ConfigFile::SYSTEM_WIDE_CONFIG_FILE, "w" do |fp|
       fp.puts ":backtrace: false"
       fp.puts ":bulk_threshold: 2048"
     end
 
-    File.open @temp_conf, 'w' do |fp|
+    File.open @temp_conf, "w" do |fp|
       fp.puts ":backtrace: true"
     end
 
@@ -137,28 +143,28 @@ class TestGemConfigFile < Gem::TestCase
   end
 
   def test_initialize_environment_variable_override
-    File.open Gem::ConfigFile::SYSTEM_WIDE_CONFIG_FILE, 'w' do |fp|
-      fp.puts ':backtrace: false'
-      fp.puts ':verbose: false'
-      fp.puts ':bulk_threshold: 2048'
+    File.open Gem::ConfigFile::SYSTEM_WIDE_CONFIG_FILE, "w" do |fp|
+      fp.puts ":backtrace: false"
+      fp.puts ":verbose: false"
+      fp.puts ":bulk_threshold: 2048"
     end
 
-    conf1 = File.join @tempdir, 'gemrc1'
-    File.open conf1, 'w' do |fp|
-      fp.puts ':backtrace: true'
+    conf1 = File.join @tempdir, "gemrc1"
+    File.open conf1, "w" do |fp|
+      fp.puts ":backtrace: true"
     end
 
-    conf2 = File.join @tempdir, 'gemrc2'
-    File.open conf2, 'w' do |fp|
-      fp.puts ':verbose: true'
+    conf2 = File.join @tempdir, "gemrc2"
+    File.open conf2, "w" do |fp|
+      fp.puts ":verbose: true"
     end
 
-    conf3 = File.join @tempdir, 'gemrc3'
-    File.open conf3, 'w' do |fp|
-      fp.puts ':verbose: :loud'
+    conf3 = File.join @tempdir, "gemrc3"
+    File.open conf3, "w" do |fp|
+      fp.puts ":verbose: :loud"
     end
     ps = File::PATH_SEPARATOR
-    ENV['GEMRC'] = conf1 + ps + conf2 + ps + conf3
+    ENV["GEMRC"] = conf1 + ps + conf2 + ps + conf3
 
     util_config_file
 
@@ -168,7 +174,7 @@ class TestGemConfigFile < Gem::TestCase
   end
 
   def test_set_config_file_name_from_environment_variable
-    ENV['GEMRC'] = "/tmp/.gemrc"
+    ENV["GEMRC"] = "/tmp/.gemrc"
     cfg = Gem::ConfigFile.new([])
     assert_equal cfg.config_file_name, "/tmp/.gemrc"
   end
@@ -176,27 +182,27 @@ class TestGemConfigFile < Gem::TestCase
   def test_api_keys
     assert_nil @cfg.instance_variable_get :@api_keys
 
-    temp_cred = File.join Gem.user_home, '.gem', 'credentials'
-    FileUtils.mkdir File.dirname(temp_cred)
-    File.open temp_cred, 'w', 0600 do |fp|
-      fp.puts ':rubygems_api_key: 701229f217cdf23b1344c7b4b54ca97'
+    temp_cred = File.join Gem.user_home, ".gem", "credentials"
+    FileUtils.mkdir_p File.dirname(temp_cred)
+    File.open temp_cred, "w", 0600 do |fp|
+      fp.puts ":rubygems_api_key: 701229f217cdf23b1344c7b4b54ca97"
     end
 
     util_config_file
 
-    assert_equal({:rubygems => '701229f217cdf23b1344c7b4b54ca97'},
+    assert_equal({ :rubygems => "701229f217cdf23b1344c7b4b54ca97" },
                  @cfg.api_keys)
   end
 
   def test_check_credentials_permissions
-    skip 'chmod not supported' if win_platform?
+    pend "chmod not supported" if win_platform?
 
-    @cfg.rubygems_api_key = 'x'
+    @cfg.rubygems_api_key = "x"
 
     File.chmod 0644, @cfg.credentials_path
 
     use_ui @ui do
-      assert_raises Gem::MockGemUi::TermError do
+      assert_raise Gem::MockGemUi::TermError do
         @cfg.load_api_keys
       end
     end
@@ -233,6 +239,12 @@ if you believe they were disclosed to a 
   end
 
   def test_handle_arguments_backtrace
+    File.open @temp_conf, "w" do |fp|
+      fp.puts ":backtrace: false"
+    end
+
+    util_config_file %W[--config-file=#{@temp_conf}]
+
     assert_equal false, @cfg.backtrace
 
     args = %w[--backtrace]
@@ -247,11 +259,11 @@ if you believe they were disclosed to a 
 
     args = %w[--debug]
 
-    _, err = capture_io do
+    _, err = capture_output do
       @cfg.handle_arguments args
     end
 
-    assert_match 'NOTE', err
+    assert_match "NOTE", err
 
     assert_equal true, $DEBUG
   ensure
@@ -259,7 +271,7 @@ if you believe they were disclosed to a 
   end
 
   def test_handle_arguments_override
-    File.open @temp_conf, 'w' do |fp|
+    File.open @temp_conf, "w" do |fp|
       fp.puts ":backtrace: false"
     end
 
@@ -269,6 +281,12 @@ if you believe they were disclosed to a 
   end
 
   def test_handle_arguments_traceback
+    File.open @temp_conf, "w" do |fp|
+      fp.puts ":backtrace: false"
+    end
+
+    util_config_file %W[--config-file=#{@temp_conf}]
+
     assert_equal false, @cfg.backtrace
 
     args = %w[--traceback]
@@ -281,8 +299,8 @@ if you believe they were disclosed to a 
   def test_handle_arguments_norc
     assert_equal @temp_conf, @cfg.config_file_name
 
-    File.open @temp_conf, 'w' do |fp|
-      fp.puts ":backtrace: true"
+    File.open @temp_conf, "w" do |fp|
+      fp.puts ":backtrace: false"
       fp.puts ":update_sources: false"
       fp.puts ":bulk_threshold: 10"
       fp.puts ":verbose: false"
@@ -294,7 +312,7 @@ if you believe they were disclosed to a 
 
     util_config_file args
 
-    assert_equal false, @cfg.backtrace
+    assert_equal true, @cfg.backtrace
     assert_equal true, @cfg.update_sources
     assert_equal Gem::ConfigFile::DEFAULT_BULK_THRESHOLD, @cfg.bulk_threshold
     assert_equal true, @cfg.verbose
@@ -302,27 +320,27 @@ if you believe they were disclosed to a 
   end
 
   def test_load_api_keys
-    temp_cred = File.join Gem.user_home, '.gem', 'credentials'
-    FileUtils.mkdir File.dirname(temp_cred)
-    File.open temp_cred, 'w', 0600 do |fp|
+    temp_cred = File.join Gem.user_home, ".gem", "credentials"
+    FileUtils.mkdir_p File.dirname(temp_cred)
+    File.open temp_cred, "w", 0600 do |fp|
       fp.puts ":rubygems_api_key: 701229f217cdf23b1344c7b4b54ca97"
       fp.puts ":other: a5fdbb6ba150cbb83aad2bb2fede64c"
     end
 
     util_config_file
 
-    assert_equal({:rubygems => '701229f217cdf23b1344c7b4b54ca97',
-                  :other => 'a5fdbb6ba150cbb83aad2bb2fede64c'}, @cfg.api_keys)
+    assert_equal({ :rubygems => "701229f217cdf23b1344c7b4b54ca97",
+                  :other => "a5fdbb6ba150cbb83aad2bb2fede64c" }, @cfg.api_keys)
   end
 
   def test_load_api_keys_bad_permission
-    skip 'chmod not supported' if win_platform?
+    pend "chmod not supported" if win_platform?
 
-    @cfg.rubygems_api_key = 'x'
+    @cfg.rubygems_api_key = "x"
 
     File.chmod 0644, @cfg.credentials_path
 
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       @cfg.load_api_keys
     end
   end
@@ -340,15 +358,15 @@ if you believe they were disclosed to a 
   end
 
   def test_rubygems_api_key_equals
-    @cfg.rubygems_api_key = 'x'
+    @cfg.rubygems_api_key = "x"
 
-    assert_equal 'x', @cfg.rubygems_api_key
+    assert_equal "x", @cfg.rubygems_api_key
 
     expected = {
-      :rubygems_api_key => 'x',
+      :rubygems_api_key => "x",
     }
 
-    assert_equal expected, YAML.load_file(@cfg.credentials_path)
+    assert_equal expected, load_yaml_file(@cfg.credentials_path)
 
     unless win_platform?
       stat = File.stat @cfg.credentials_path
@@ -358,21 +376,21 @@ if you believe they were disclosed to a 
   end
 
   def test_rubygems_api_key_equals_bad_permission
-    skip 'chmod not supported' if win_platform?
+    pend "chmod not supported" if win_platform?
 
-    @cfg.rubygems_api_key = 'x'
+    @cfg.rubygems_api_key = "x"
 
     File.chmod 0644, @cfg.credentials_path
 
-    assert_raises Gem::MockGemUi::TermError do
-      @cfg.rubygems_api_key = 'y'
+    assert_raise Gem::MockGemUi::TermError do
+      @cfg.rubygems_api_key = "y"
     end
 
     expected = {
-      :rubygems_api_key => 'x',
+      :rubygems_api_key => "x",
     }
 
-    assert_equal expected, YAML.load_file(@cfg.credentials_path)
+    assert_equal expected, load_yaml_file(@cfg.credentials_path)
 
     stat = File.stat @cfg.credentials_path
 
@@ -380,32 +398,32 @@ if you believe they were disclosed to a 
   end
 
   def test_write
-    @cfg.backtrace = true
+    @cfg.backtrace = false
     @cfg.update_sources = false
     @cfg.bulk_threshold = 10
     @cfg.verbose = false
     Gem.sources.replace %w[http://more-gems.example.com]
-    @cfg[:install] = '--wrappers'
+    @cfg[:install] = "--wrappers"
 
     @cfg.write
 
     util_config_file
 
     # These should not be written out to the config file.
-    assert_equal false, @cfg.backtrace,     'backtrace'
+    assert_equal true, @cfg.backtrace, "backtrace"
     assert_equal Gem::ConfigFile::DEFAULT_BULK_THRESHOLD, @cfg.bulk_threshold,
-                 'bulk_threshold'
-    assert_equal true, @cfg.update_sources, 'update_sources'
-    assert_equal true, @cfg.verbose,        'verbose'
+                 "bulk_threshold"
+    assert_equal true, @cfg.update_sources, "update_sources"
+    assert_equal true, @cfg.verbose,        "verbose"
 
-    assert_equal '--wrappers', @cfg[:install], 'install'
+    assert_equal "--wrappers", @cfg[:install], "install"
 
     # this should be written out to the config file.
     assert_equal %w[http://more-gems.example.com], Gem.sources
   end
 
   def test_write_from_hash
-    File.open @temp_conf, 'w' do |fp|
+    File.open @temp_conf, "w" do |fp|
       fp.puts ":backtrace: true"
       fp.puts ":bulk_threshold: 10"
       fp.puts ":update_sources: false"
@@ -425,29 +443,29 @@ if you believe they were disclosed to a 
     @cfg.bulk_threshold = 20
     @cfg.verbose = :junk
     Gem.sources.replace %w[http://even-more-gems.example.com]
-    @cfg[:install] = '--wrappers --no-rdoc'
+    @cfg[:install] = "--wrappers --no-rdoc"
 
     @cfg.write
 
     util_config_file
 
     # These should not be written out to the config file
-    assert_equal true,  @cfg.backtrace,      'backtrace'
-    assert_equal 10,    @cfg.bulk_threshold, 'bulk_threshold'
-    assert_equal false, @cfg.update_sources, 'update_sources'
-    assert_equal false, @cfg.verbose,        'verbose'
+    assert_equal true,  @cfg.backtrace,      "backtrace"
+    assert_equal 10,    @cfg.bulk_threshold, "bulk_threshold"
+    assert_equal false, @cfg.update_sources, "update_sources"
+    assert_equal false, @cfg.verbose,        "verbose"
 
     assert_equal 2,                              @cfg.ssl_verify_mode
-    assert_equal '/nonexistent/ca_cert.pem',     @cfg.ssl_ca_cert
-    assert_equal '/nonexistent/client_cert.pem', @cfg.ssl_client_cert
+    assert_equal "/nonexistent/ca_cert.pem",     @cfg.ssl_ca_cert
+    assert_equal "/nonexistent/client_cert.pem", @cfg.ssl_client_cert
 
-    assert_equal '--wrappers --no-rdoc', @cfg[:install], 'install'
+    assert_equal "--wrappers --no-rdoc", @cfg[:install], "install"
 
     assert_equal %w[http://even-more-gems.example.com], Gem.sources
   end
 
   def test_ignore_invalid_config_file
-    File.open @temp_conf, 'w' do |fp|
+    File.open @temp_conf, "w" do |fp|
       fp.puts "invalid: yaml:"
     end
 
@@ -461,7 +479,7 @@ if you believe they were disclosed to a 
   end
 
   def test_load_ssl_verify_mode_from_config
-    File.open @temp_conf, 'w' do |fp|
+    File.open @temp_conf, "w" do |fp|
       fp.puts ":ssl_verify_mode: 1"
     end
     util_config_file
@@ -469,19 +487,19 @@ if you believe they were disclosed to a 
   end
 
   def test_load_ssl_ca_cert_from_config
-    File.open @temp_conf, 'w' do |fp|
+    File.open @temp_conf, "w" do |fp|
       fp.puts ":ssl_ca_cert: /home/me/certs"
     end
     util_config_file
-    assert_equal('/home/me/certs', @cfg.ssl_ca_cert)
+    assert_equal("/home/me/certs", @cfg.ssl_ca_cert)
   end
 
   def test_load_ssl_client_cert_from_config
-    File.open @temp_conf, 'w' do |fp|
+    File.open @temp_conf, "w" do |fp|
       fp.puts ":ssl_client_cert: /home/me/mine.pem"
     end
     util_config_file
-    assert_equal('/home/me/mine.pem', @cfg.ssl_client_cert)
+    assert_equal("/home/me/mine.pem", @cfg.ssl_client_cert)
   end
 
   def util_config_file(args = @cfg_args)
@@ -489,11 +507,10 @@ if you believe they were disclosed to a 
   end
 
   def test_disable_default_gem_server
-    File.open @temp_conf, 'w' do |fp|
+    File.open @temp_conf, "w" do |fp|
       fp.puts ":disable_default_gem_server: true"
     end
     util_config_file
     assert_equal(true, @cfg.disable_default_gem_server)
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_dependency.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_dependency.rb
@@ -1,8 +1,13 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/dependency'
+require_relative "helper"
+require "rubygems/dependency"
 
 class TestGemDependency < Gem::TestCase
+  def setup
+    super
+
+    without_any_upwards_gemfiles
+  end
 
   def test_initialize
     d = dep "pkg", "> 1.0"
@@ -12,8 +17,8 @@ class TestGemDependency < Gem::TestCase
   end
 
   def test_initialize_type_bad
-    e = assert_raises ArgumentError do
-      Gem::Dependency.new 'monkey' => '1.0'
+    e = assert_raise ArgumentError do
+      Gem::Dependency.new "monkey" => "1.0"
     end
 
     assert_equal 'dependency name must be a String, was {"monkey"=>"1.0"}',
@@ -31,11 +36,11 @@ class TestGemDependency < Gem::TestCase
   end
 
   def test_initialize_prerelease
-    d = dep 'd', '1.a'
+    d = dep "d", "1.a"
 
     assert d.prerelease?
 
-    d = dep 'd', '= 1.a'
+    d = dep "d", "= 1.a"
 
     assert d.prerelease?
   end
@@ -44,7 +49,7 @@ class TestGemDependency < Gem::TestCase
     assert_equal :runtime, dep("pkg").type
     assert_equal :development, dep("pkg", [], :development).type
 
-    assert_raises ArgumentError do
+    assert_raise ArgumentError do
       dep "pkg", :sometimes
     end
   end
@@ -100,8 +105,8 @@ class TestGemDependency < Gem::TestCase
 
   def test_equals_tilde_object
     o = Object.new
-    def o.name    ; 'a' end
-    def o.version ; '0' end
+    def o.name    ; "a" end
+    def o.version ; "0" end
 
     assert_match dep("a"), o
   end
@@ -128,142 +133,142 @@ class TestGemDependency < Gem::TestCase
   end
 
   def test_match_eh_name_tuple
-    a_dep = dep 'a'
+    a_dep = dep "a"
 
-    a_tup = Gem::NameTuple.new 'a', 1
-    b_tup = Gem::NameTuple.new 'b', 2
-    c_tup = Gem::NameTuple.new 'c', '2.a'
+    a_tup = Gem::NameTuple.new "a", 1
+    b_tup = Gem::NameTuple.new "b", 2
+    c_tup = Gem::NameTuple.new "c", "2.a"
 
     assert a_dep.match? a_tup
     refute a_dep.match? b_tup
 
-    b_dep = dep 'b', '>= 3'
+    b_dep = dep "b", ">= 3"
 
     refute b_dep.match? b_tup
 
-    c_dep = dep 'c', '>= 1'
+    c_dep = dep "c", ">= 1"
 
     refute c_dep.match? c_tup
 
-    c_dep = dep 'c'
+    c_dep = dep "c"
 
     refute c_dep.match? c_tup
 
-    c_dep = dep 'c', '2.a'
+    c_dep = dep "c", "2.a"
 
     assert c_dep.match? c_tup
   end
 
   def test_match_eh_allow_prerelease
-    a_dep = dep 'a'
+    a_dep = dep "a"
 
-    a_tup = Gem::NameTuple.new 'a', 1
-    b_tup = Gem::NameTuple.new 'b', 2
-    c_tup = Gem::NameTuple.new 'c', '2.a'
+    a_tup = Gem::NameTuple.new "a", 1
+    b_tup = Gem::NameTuple.new "b", 2
+    c_tup = Gem::NameTuple.new "c", "2.a"
 
     assert a_dep.match? a_tup, nil, true
     refute a_dep.match? b_tup, nil, true
 
-    b_dep = dep 'b', '>= 3'
+    b_dep = dep "b", ">= 3"
 
     refute b_dep.match? b_tup, nil, true
 
-    c_dep = dep 'c', '>= 1'
+    c_dep = dep "c", ">= 1"
 
     assert c_dep.match? c_tup, nil, true
 
-    c_dep = dep 'c'
+    c_dep = dep "c"
 
     assert c_dep.match? c_tup, nil, true
 
-    c_dep = dep 'c', '2.a'
+    c_dep = dep "c", "2.a"
 
     assert c_dep.match? c_tup, nil, true
   end
 
   def test_match_eh_specification
-    a_dep = dep 'a'
+    a_dep = dep "a"
 
-    a_spec = util_spec 'a', 1
-    b_spec = util_spec 'b', 2
-    c_spec = util_spec 'c', '2.a'
+    a_spec = util_spec "a", 1
+    b_spec = util_spec "b", 2
+    c_spec = util_spec "c", "2.a"
 
     assert a_dep.match? a_spec
     refute a_dep.match? b_spec
 
-    b_dep = dep 'b', '>= 3'
+    b_dep = dep "b", ">= 3"
 
     refute b_dep.match? b_spec
 
-    c_dep = dep 'c', '>= 1'
+    c_dep = dep "c", ">= 1"
 
     refute c_dep.match? c_spec
 
-    c_dep = dep 'c'
+    c_dep = dep "c"
 
     refute c_dep.match? c_spec
 
-    c_dep = dep 'c', '2.a'
+    c_dep = dep "c", "2.a"
 
     assert c_dep.match? c_spec
   end
 
   def test_matches_spec_eh
-    spec = util_spec 'b', 2
+    spec = util_spec "b", 2
 
-    refute dep('a')        .matches_spec?(spec), 'name mismatch'
-    assert dep('b')        .matches_spec?(spec), 'name match'
-    refute dep('b', '= 1') .matches_spec?(spec), 'requirement mismatch'
-    assert dep('b', '~> 2').matches_spec?(spec), 'requirement match'
+    refute dep("a")        .matches_spec?(spec), "name mismatch"
+    assert dep("b")        .matches_spec?(spec), "name match"
+    refute dep("b", "= 1") .matches_spec?(spec), "requirement mismatch"
+    assert dep("b", "~> 2").matches_spec?(spec), "requirement match"
   end
 
   def test_matches_spec_eh_prerelease
-    spec = util_spec 'b', '2.1.a'
+    spec = util_spec "b", "2.1.a"
 
-    refute dep('a')          .matches_spec?(spec), 'name mismatch'
-    assert dep('b')          .matches_spec?(spec), 'name match'
-    refute dep('b', '= 1')   .matches_spec?(spec), 'requirement mismatch'
-    assert dep('b', '~> 2')  .matches_spec?(spec), 'requirement match'
-    assert dep('b', '~> 2.a').matches_spec?(spec), 'prerelease requirement'
+    refute dep("a")          .matches_spec?(spec), "name mismatch"
+    assert dep("b")          .matches_spec?(spec), "name match"
+    refute dep("b", "= 1")   .matches_spec?(spec), "requirement mismatch"
+    assert dep("b", "~> 2")  .matches_spec?(spec), "requirement match"
+    assert dep("b", "~> 2.a").matches_spec?(spec), "prerelease requirement"
   end
 
   def test_merge
-    a1 = dep 'a', '~> 1.0'
-    a2 = dep 'a', '= 1.0'
+    a1 = dep "a", "~> 1.0"
+    a2 = dep "a", "= 1.0"
 
     a3 = a1.merge a2
 
-    assert_equal dep('a', '~> 1.0', '= 1.0'), a3
+    assert_equal dep("a", "~> 1.0", "= 1.0"), a3
   end
 
   def test_merge_default
-    a1 = dep 'a'
-    a2 = dep 'a', '1'
+    a1 = dep "a"
+    a2 = dep "a", "1"
 
     a3 = a1.merge a2
 
-    assert_equal dep('a', '1'), a3
+    assert_equal dep("a", "1"), a3
   end
 
   def test_merge_name_mismatch
-    a = dep 'a'
-    b = dep 'b'
+    a = dep "a"
+    b = dep "b"
 
-    e = assert_raises ArgumentError do
+    e = assert_raise ArgumentError do
       a.merge b
     end
 
-    assert_equal 'a (>= 0) and b (>= 0) have different names',
+    assert_equal "a (>= 0) and b (>= 0) have different names",
                  e.message
   end
 
   def test_merge_other_default
-    a1 = dep 'a', '1'
-    a2 = dep 'a'
+    a1 = dep "a", "1"
+    a2 = dep "a"
 
     a3 = a1.merge a2
 
-    assert_equal dep('a', '1'), a3
+    assert_equal dep("a", "1"), a3
   end
 
   def test_prerelease_eh
@@ -289,49 +294,49 @@ class TestGemDependency < Gem::TestCase
   end
 
   def test_specific
-    refute dep('a', '> 1').specific?
+    refute dep("a", "> 1").specific?
 
-    assert dep('a', '= 1').specific?
+    assert dep("a", "= 1").specific?
   end
 
   def test_to_spec
-    a_1 = util_spec 'a', '1'
-    a_2 = util_spec 'a', '2'
+    a_1 = util_spec "a", "1"
+    a_2 = util_spec "a", "2"
 
-    a_dep = dep 'a', '>= 0'
+    a_dep = dep "a", ">= 0"
     install_specs a_1, a_2
 
     assert_equal a_2, a_dep.to_spec
   end
 
   def test_to_spec_prerelease
-    a_1     = util_spec 'a', '1'
-    a_1_1_a = util_spec 'a', '1.1.a'
+    a_1     = util_spec "a", "1"
+    a_1_1_a = util_spec "a", "1.1.a"
 
-    a_dep = dep 'a', '>= 0'
+    a_dep = dep "a", ">= 0"
     install_specs a_1, a_1_1_a
 
     assert_equal a_1, a_dep.to_spec
 
-    a_pre_dep = dep 'a', '>= 0'
+    a_pre_dep = dep "a", ">= 0"
     a_pre_dep.prerelease = true
 
     assert_equal a_1_1_a, a_pre_dep.to_spec
   end
 
   def test_to_specs_suggests_other_versions
-    a = util_spec 'a', '1.0'
+    a = util_spec "a", "1.0"
     install_specs a
 
-    a_file = File.join a.gem_dir, 'lib', 'a_file.rb'
+    a_file = File.join a.gem_dir, "lib", "a_file.rb"
 
     write_file a_file do |io|
-      io.puts '# a_file.rb'
+      io.puts "# a_file.rb"
     end
 
     dep = Gem::Dependency.new "a", "= 2.0"
 
-    e = assert_raises Gem::MissingSpecVersionError do
+    e = assert_raise Gem::MissingSpecVersionError do
       dep.to_specs
     end
 
@@ -339,46 +344,42 @@ class TestGemDependency < Gem::TestCase
   end
 
   def test_to_specs_respects_bundler_version
-    b = util_spec 'bundler', '2.0.0.pre.1'
-    b_1 = util_spec 'bundler', '1'
+    b = util_spec "bundler", "2.0.0.pre.1"
+    b_1 = util_spec "bundler", "1"
     install_specs b, b_1
 
-    b_file = File.join b.gem_dir, 'lib', 'bundler', 'setup.rb'
+    b_file = File.join b.gem_dir, "lib", "bundler", "setup.rb"
 
     write_file b_file do |io|
-      io.puts '# setup.rb'
+      io.puts "# setup.rb"
     end
 
     dep = Gem::Dependency.new "bundler", ">= 0.a"
 
     assert_equal [b, b_1], dep.to_specs
 
-    Gem::BundlerVersionFinder.stub(:bundler_version_with_reason, ["3.5", "reason"]) do
-      e = assert_raises Gem::MissingSpecVersionError do
-        dep.to_specs
-      end
-
-      assert_match "Could not find 'bundler' (3.5) required by reason.\nTo update to the latest version installed on your system, run `bundle update --bundler`.\nTo install the missing version, run `gem install bundler:3.5`\n", e.message
+    Gem::BundlerVersionFinder.stub(:bundler_version, Gem::Version.new("1")) do
+      assert_equal [b_1, b], dep.to_specs
     end
 
-    Gem::BundlerVersionFinder.stub(:bundler_version_with_reason, ["2.0.0.pre.1", "reason"]) do
-      assert_equal [b], dep.to_specs
+    Gem::BundlerVersionFinder.stub(:bundler_version, Gem::Version.new("2.0.0.pre.1")) do
+      assert_equal [b, b_1], dep.to_specs
     end
   end
 
   def test_to_specs_indicates_total_gem_set_size
-    a = util_spec 'a', '1.0'
+    a = util_spec "a", "1.0"
     install_specs a
 
-    a_file = File.join a.gem_dir, 'lib', 'a_file.rb'
+    a_file = File.join a.gem_dir, "lib", "a_file.rb"
 
     write_file a_file do |io|
-      io.puts '# a_file.rb'
+      io.puts "# a_file.rb"
     end
 
     dep = Gem::Dependency.new "b", "= 2.0"
 
-    e = assert_raises Gem::MissingSpecError do
+    e = assert_raise Gem::MissingSpecError do
       dep.to_specs
     end
 
@@ -391,5 +392,4 @@ class TestGemDependency < Gem::TestCase
     assert_equal dep("a", " >= 1.a").identity, :abs_latest
     assert_equal dep("a").identity, :latest
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_dependency_installer.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_dependency_installer.rb
@@ -1,16 +1,15 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/dependency_installer'
-require 'rubygems/security'
+require_relative "helper"
+require "rubygems/dependency_installer"
+require "rubygems/security"
 
 class TestGemDependencyInstaller < Gem::TestCase
-
   def setup
     super
     common_installer_setup
 
-    @gems_dir  = File.join @tempdir, 'gems'
-    @cache_dir = File.join @gemhome, 'cache'
+    @gems_dir  = File.join @tempdir, "gems"
+    @cache_dir = File.join @gemhome, "cache"
 
     FileUtils.mkdir @gems_dir
 
@@ -26,89 +25,26 @@ class TestGemDependencyInstaller < Gem::
   end
 
   def util_setup_gems
-    @a1, @a1_gem = util_gem 'a', '1' do |s|
-      s.executables << 'a_bin'
-    end
-
-    @a1_pre, @a1_pre_gem = util_gem 'a', '1.a'
-
-    @b1, @b1_gem = util_gem 'b', '1' do |s|
-      s.add_dependency 'a'
-      s.add_development_dependency 'aa'
-    end
-
-    @c1, @c1_gem = util_gem 'c', '1' do |s|
-      s.add_development_dependency 'b'
-    end
-
-    @d1, @d1_gem = util_gem 'd', '1' do |s|
-      s.add_development_dependency 'c'
+    @a1, @a1_gem = util_gem "a", "1" do |s|
+      s.executables << "a_bin"
     end
 
-    util_reset_gems
-  end
-
-  def test_available_set_for_name
-    util_setup_gems
-    p1a, = util_gem 'a', '10.a'
-    util_setup_spec_fetcher p1a, @a1, @a1_pre
-
-    inst = Gem::DependencyInstaller.new
+    @a1_pre, @a1_pre_gem = util_gem "a", "1.a"
 
-    available = Gem::Deprecate.skip_during do
-      inst.available_set_for 'a', Gem::Requirement.default
+    @b1, @b1_gem = util_gem "b", "1" do |s|
+      s.add_dependency "a"
+      s.add_development_dependency "aa"
     end
 
-    assert_equal %w[a-1], available.set.map { |s| s.spec.full_name }
-  end
-
-  def test_available_set_for_name_prerelease
-    util_setup_gems
-    p1a, = util_gem 'a', '10.a'
-    util_setup_spec_fetcher p1a, @a1, @a1_pre
-
-    inst = Gem::DependencyInstaller.new :prerelease => true
-
-    available = Gem::Deprecate.skip_during do
-      inst.available_set_for 'a', Gem::Requirement.default
+    @c1, @c1_gem = util_gem "c", "1" do |s|
+      s.add_development_dependency "b"
     end
 
-    assert_equal %w[a-10.a],
-                 available.sorted.map { |s| s.spec.full_name }
-  end
-
-  def test_available_set_for_dep
-    util_setup_gems
-    p1a, = util_gem 'a', '10.a'
-    util_setup_spec_fetcher p1a, @a1, @a1_pre
-
-    inst = Gem::DependencyInstaller.new
-
-    dep = Gem::Dependency.new 'a', Gem::Requirement.default
-
-    available = Gem::Deprecate.skip_during do
-      inst.available_set_for dep, Gem::Requirement.default
+    @d1, @d1_gem = util_gem "d", "1" do |s|
+      s.add_development_dependency "c"
     end
 
-    assert_equal %w[a-1], available.set.map { |s| s.spec.full_name }
-  end
-
-  def test_available_set_for_dep_prerelease
-    util_setup_gems
-    p1a, = util_gem 'a', '10.a'
-    util_setup_spec_fetcher p1a, @a1, @a1_pre
-
-    inst = Gem::DependencyInstaller.new :prerelease => true
-
-    dep = Gem::Dependency.new 'a', Gem::Requirement.default
-    dep.prerelease = true
-
-    available = Gem::Deprecate.skip_during do
-      inst.available_set_for dep, Gem::Requirement.default
-    end
-
-    assert_equal %w[a-10.a],
-                 available.sorted.map { |s| s.spec.full_name }
+    util_setup_spec_fetcher(@a1, @a1_pre, @b1, @d1)
   end
 
   def test_install
@@ -119,7 +55,7 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new
-      inst.install 'a'
+      inst.install "a"
     end
 
     assert_equal %w[a-1], Gem::Specification.map(&:full_name)
@@ -129,13 +65,13 @@ class TestGemDependencyInstaller < Gem::
   def test_install_prerelease
     util_setup_gems
 
-    p1a, gem = util_gem 'a', '10.a'
+    p1a, gem = util_gem "a", "10.a"
 
     util_setup_spec_fetcher(p1a, @a1, @a1_pre)
 
     p1a_data = Gem.read_binary(gem)
 
-    @fetcher.data['http://gems.example.com/gems/a-10.a.gem'] = p1a_data
+    @fetcher.data["http://gems.example.com/gems/a-10.a.gem"] = p1a_data
 
     dep = Gem::Dependency.new "a"
     inst = Gem::DependencyInstaller.new :prerelease => true
@@ -147,18 +83,18 @@ class TestGemDependencyInstaller < Gem::
 
   def test_install_prerelease_bug_990
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', '1.b' do |s|
-        s.add_dependency 'b', '~> 1.a'
+      fetcher.gem "a", "1.b" do |s|
+        s.add_dependency "b", "~> 1.a"
       end
 
-      fetcher.gem 'b', '1.b' do |s|
-        s.add_dependency 'c', '>= 1'
+      fetcher.gem "b", "1.b" do |s|
+        s.add_dependency "c", ">= 1"
       end
 
-      fetcher.gem 'c', '1.1.b'
+      fetcher.gem "c", "1.1.b"
     end
 
-    dep = Gem::Dependency.new 'a'
+    dep = Gem::Dependency.new "a"
 
     inst = Gem::DependencyInstaller.new :prerelease => true
     inst.install dep
@@ -167,17 +103,17 @@ class TestGemDependencyInstaller < Gem::
   end
 
   def test_install_when_only_prerelease
-    p1a, gem = util_gem 'p', '1.a'
+    p1a, gem = util_gem "p", "1.a"
 
     util_setup_spec_fetcher(p1a)
 
     p1a_data = Gem.read_binary(gem)
 
-    @fetcher.data['http://gems.example.com/gems/p-1.a.gem'] = p1a_data
+    @fetcher.data["http://gems.example.com/gems/p-1.a.gem"] = p1a_data
 
     dep = Gem::Dependency.new "p"
     inst = Gem::DependencyInstaller.new
-    assert_raises Gem::UnsatisfiableDependencyError do
+    assert_raise Gem::UnsatisfiableDependencyError do
       inst.install dep
     end
 
@@ -192,7 +128,7 @@ class TestGemDependencyInstaller < Gem::
 
     p1a_data = Gem.read_binary(@a1_gem)
 
-    @fetcher.data['http://gems.example.com/gems/a-1.gem'] = p1a_data
+    @fetcher.data["http://gems.example.com/gems/a-1.gem"] = p1a_data
 
     dep = Gem::Dependency.new "a"
     inst = Gem::DependencyInstaller.new :prerelease => true
@@ -205,30 +141,30 @@ class TestGemDependencyInstaller < Gem::
   def test_install_all_dependencies
     util_setup_gems
 
-    _, e1_gem = util_gem 'e', '1' do |s|
-      s.add_dependency 'b'
+    _, e1_gem = util_gem "e", "1" do |s|
+      s.add_dependency "b"
     end
 
     FileUtils.mv @a1_gem, @tempdir
     FileUtils.mv @b1_gem, @tempdir
-    FileUtils.mv  e1_gem, @tempdir
+    FileUtils.mv e1_gem, @tempdir
 
     inst = nil
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :ignore_dependencies => true
-      inst.install 'b'
+      inst.install "b"
     end
 
-    assert_equal %w[b-1], inst.installed_gems.map { |s| s.full_name },
-                 'sanity check'
+    assert_equal %w[b-1], inst.installed_gems.map {|s| s.full_name },
+                 "sanity check"
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new
-      inst.install 'e'
+      inst.install "e"
     end
 
-    assert_equal %w[a-1 e-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1 e-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_cache_dir
@@ -242,10 +178,10 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir dir do
       inst = Gem::DependencyInstaller.new :cache_dir => @tempdir
-      inst.install 'b'
+      inst.install "b"
     end
 
-    assert_equal %w[a-1 b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1 b-1], inst.installed_gems.map {|s| s.full_name }
 
     assert File.exist? File.join(@gemhome, "cache", @a1.file_name)
     assert File.exist? File.join(@gemhome, "cache", @b1.file_name)
@@ -254,9 +190,9 @@ class TestGemDependencyInstaller < Gem::
   def test_install_dependencies_satisfied
     util_setup_gems
 
-    a2, a2_gem = util_gem 'a', '2'
+    a2, a2_gem = util_gem "a", "2"
 
-    FileUtils.rm_rf File.join(@gemhome, 'gems')
+    FileUtils.rm_rf File.join(@gemhome, "gems")
 
     Gem::Specification.reset
 
@@ -267,21 +203,21 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new
-      inst.install 'a', req("= 2")
+      inst.install "a", req("= 2")
     end
 
-    assert_equal %w[a-2], inst.installed_gems.map { |s| s.full_name },
-                 'sanity check'
+    assert_equal %w[a-2], inst.installed_gems.map {|s| s.full_name },
+                 "sanity check"
 
     FileUtils.rm File.join(@tempdir, a2.file_name)
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new
-      inst.install 'b'
+      inst.install "b"
     end
 
     assert_equal %w[a-2 b-1], Gem::Specification.map(&:full_name)
-    assert_equal %w[b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[b-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   # This asserts that if a gem's dependency is satisfied by an
@@ -290,22 +226,22 @@ class TestGemDependencyInstaller < Gem::
   def test_install_doesnt_upgrade_installed_dependencies
     util_setup_gems
 
-    a2, a2_gem = util_gem 'a', '2'
-    a3, a3_gem = util_gem 'a', '3'
+    a2, a2_gem = util_gem "a", "2"
+    a3, a3_gem = util_gem "a", "3"
 
     util_setup_spec_fetcher @a1, a3, @b1
 
-    FileUtils.rm_rf File.join(@gemhome, 'gems')
+    FileUtils.rm_rf File.join(@gemhome, "gems")
 
     Gem::Specification.reset
 
     FileUtils.mv @a1_gem, @tempdir
     FileUtils.mv  a2_gem, @tempdir # not in index
     FileUtils.mv @b1_gem, @tempdir
-    FileUtils.mv  a3_gem, @tempdir
+    FileUtils.mv a3_gem, @tempdir
 
     Dir.chdir @tempdir do
-      Gem::DependencyInstaller.new.install 'a', req("= 2")
+      Gem::DependencyInstaller.new.install "a", req("= 2")
     end
 
     FileUtils.rm File.join(@tempdir, a2.file_name)
@@ -314,11 +250,11 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new
-      inst.install 'b'
+      inst.install "b"
     end
 
     assert_equal %w[a-2 b-1], Gem::Specification.map(&:full_name)
-    assert_equal %w[b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[b-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_dependency
@@ -338,20 +274,18 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new(:build_docs_in_background => false)
-      inst.install 'b'
+      inst.install "b"
     end
 
-    assert_equal %w[a-1 b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1 b-1], inst.installed_gems.map {|s| s.full_name }
 
-    assert done_installing_ran, 'post installs hook was not run'
+    assert done_installing_ran, "post installs hook was not run"
   end
 
   def test_install_dependency_development
     util_setup_gems
 
-    @aa1, @aa1_gem = util_gem 'aa', '1'
-
-    util_reset_gems
+    @aa1, @aa1_gem = util_gem "aa", "1"
 
     FileUtils.mv @a1_gem, @tempdir
     FileUtils.mv @aa1_gem, @tempdir
@@ -360,18 +294,16 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new(:development => true)
-      inst.install 'b'
+      inst.install "b"
     end
 
-    assert_equal %w[a-1 aa-1 b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1 aa-1 b-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_dependency_development_deep
     util_setup_gems
 
-    @aa1, @aa1_gem = util_gem 'aa', '1'
-
-    util_reset_gems
+    @aa1, @aa1_gem = util_gem "aa", "1"
 
     FileUtils.mv @a1_gem, @tempdir
     FileUtils.mv @aa1_gem, @tempdir
@@ -382,18 +314,16 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new(:development => true)
-      inst.install 'd'
+      inst.install "d"
     end
 
-    assert_equal %w[a-1 aa-1 b-1 c-1 d-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1 aa-1 b-1 c-1 d-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_dependency_development_shallow
     util_setup_gems
 
-    @aa1, @aa1_gem = util_gem 'aa', '1'
-
-    util_reset_gems
+    @aa1, @aa1_gem = util_gem "aa", "1"
 
     FileUtils.mv @a1_gem, @tempdir
     FileUtils.mv @aa1_gem, @tempdir
@@ -404,10 +334,10 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new(:development => true, :dev_shallow => true)
-      inst.install 'd'
+      inst.install "d"
     end
 
-    assert_equal %w[c-1 d-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[c-1 d-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_dependency_existing
@@ -420,29 +350,29 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new
-      inst.install 'b'
+      inst.install "b"
     end
 
-    assert_equal %w[b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[b-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_dependency_existing_extension
-    extconf_rb = File.join @gemhome, 'gems', 'e-1', 'extconf.rb'
+    extconf_rb = File.join @gemhome, "gems", "e-1", "extconf.rb"
     FileUtils.mkdir_p File.dirname extconf_rb
 
-    File.open extconf_rb, 'w' do |io|
+    File.open extconf_rb, "w" do |io|
       io.write <<-EXTCONF_RB
         require 'mkmf'
         create_makefile 'e'
       EXTCONF_RB
     end
 
-    e1 = util_spec 'e', '1', nil, 'extconf.rb' do |s|
-      s.extensions << 'extconf.rb'
+    e1 = util_spec "e", "1", nil, "extconf.rb" do |s|
+      s.extensions << "extconf.rb"
     end
-    e1_gem = File.join @tempdir, 'gems', "#{e1.full_name}.gem"
+    e1_gem = e1.cache_file
 
-    _, f1_gem = util_gem 'f', '1', 'e' => nil
+    _, f1_gem = util_gem "f", "1", "e" => nil
 
     Gem::Installer.at(e1_gem).install
     FileUtils.rm_r e1.extension_dir
@@ -455,20 +385,20 @@ class TestGemDependencyInstaller < Gem::
     Dir.chdir @tempdir
     begin
       inst = Gem::DependencyInstaller.new
-      inst.install 'f'
+      inst.install "f"
     ensure
       Dir.chdir pwd
     end
 
-    assert_equal %w[f-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[f-1], inst.installed_gems.map {|s| s.full_name }
 
-    assert_path_exists e1.extension_dir
+    assert_path_exist e1.extension_dir
   end
 
   def test_install_dependency_old
-    _, e1_gem = util_gem 'e', '1'
-    _, f1_gem = util_gem 'f', '1', 'e' => nil
-    _, f2_gem = util_gem 'f', '2'
+    _, e1_gem = util_gem "e", "1"
+    _, f1_gem = util_gem "f", "1", "e" => nil
+    _, f2_gem = util_gem "f", "2"
 
     FileUtils.mv e1_gem, @tempdir
     FileUtils.mv f1_gem, @tempdir
@@ -477,10 +407,10 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new
-      inst.install 'f'
+      inst.install "f"
     end
 
-    assert_equal %w[f-2], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[f-2], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_local
@@ -491,10 +421,10 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :domain => :local
-      inst.install 'a-1.gem'
+      inst.install "a-1.gem"
     end
 
-    assert_equal %w[a-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_local_prerelease
@@ -505,10 +435,10 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :domain => :local
-      inst.install 'a-1.a.gem'
+      inst.install "a-1.a.gem"
     end
 
-    assert_equal %w[a-1.a], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1.a], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_local_dependency
@@ -521,10 +451,10 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :domain => :local
-      inst.install 'b-1.gem'
+      inst.install "b-1.gem"
     end
 
-    assert_equal %w[a-1 b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1 b-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_local_dependency_installed
@@ -536,13 +466,13 @@ class TestGemDependencyInstaller < Gem::
     inst = nil
 
     Dir.chdir @tempdir do
-      Gem::Installer.at('a-1.gem').install
+      Gem::Installer.at("a-1.gem").install
 
       inst = Gem::DependencyInstaller.new :domain => :local
-      inst.install 'b-1.gem'
+      inst.install "b-1.gem"
     end
 
-    assert_equal %w[b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[b-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_local_subdir
@@ -552,21 +482,21 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :domain => :local
-      inst.install 'gems/a-1.gem'
+      inst.install "gems/a-1.gem"
     end
 
-    assert_equal %w[a-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_minimal_deps
     util_setup_gems
 
-    _, e1_gem = util_gem 'e', '1' do |s|
-      s.add_dependency 'b'
+    _, e1_gem = util_gem "e", "1" do |s|
+      s.add_dependency "b"
     end
 
-    _, b2_gem = util_gem 'b', '2' do |s|
-      s.add_dependency 'a'
+    _, b2_gem = util_gem "b", "2" do |s|
+      s.add_dependency "a"
     end
 
     FileUtils.mv @a1_gem, @tempdir
@@ -578,18 +508,52 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :ignore_dependencies => true
-      inst.install 'b', req('= 1')
+      inst.install "b", req("= 1")
     end
 
-    assert_equal %w[b-1], inst.installed_gems.map { |s| s.full_name },
-                 'sanity check'
+    assert_equal %w[b-1], inst.installed_gems.map {|s| s.full_name },
+                 "sanity check"
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :minimal_deps => true
-      inst.install 'e'
+      inst.install "e"
+    end
+
+    assert_equal %w[a-1 e-1], inst.installed_gems.map {|s| s.full_name }
+  end
+
+  def test_install_no_minimal_deps
+    util_setup_gems
+
+    _, e1_gem = util_gem "e", "1" do |s|
+      s.add_dependency "b"
+    end
+
+    _, b2_gem = util_gem "b", "2" do |s|
+      s.add_dependency "a"
+    end
+
+    FileUtils.mv @a1_gem, @tempdir
+    FileUtils.mv @b1_gem, @tempdir
+    FileUtils.mv  b2_gem, @tempdir
+    FileUtils.mv  e1_gem, @tempdir
+
+    inst = nil
+
+    Dir.chdir @tempdir do
+      inst = Gem::DependencyInstaller.new :ignore_dependencies => true
+      inst.install "b", req("= 1")
+    end
+
+    assert_equal %w[b-1], inst.installed_gems.map {|s| s.full_name },
+                 "sanity check"
+
+    Dir.chdir @tempdir do
+      inst = Gem::DependencyInstaller.new :minimal_deps => false
+      inst.install "e"
     end
 
-    assert_equal %w[a-1 e-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1 b-2 e-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_no_document
@@ -617,13 +581,13 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :env_shebang => true, :wrappers => true, :format_executable => false
-      inst.install 'a'
+      inst.install "a"
     end
 
     env = "/\\S+/env" unless Gem.win_platform?
 
-    assert_match %r|\A#!#{env} #{RbConfig::CONFIG['ruby_install_name']}\n|,
-                 File.read(File.join(@gemhome, 'bin', 'a_bin'))
+    assert_match %r{\A#!#{env} #{RbConfig::CONFIG['ruby_install_name']}\n},
+                 File.read(File.join(@gemhome, "bin", "a_bin"))
   end
 
   def test_install_force
@@ -631,15 +595,15 @@ class TestGemDependencyInstaller < Gem::
 
     FileUtils.mv @b1_gem, @tempdir
     si = util_setup_spec_fetcher @b1
-    @fetcher.data['http://gems.example.com/gems/yaml'] = si.to_yaml
+    @fetcher.data["http://gems.example.com/gems/yaml"] = si.to_yaml
     inst = nil
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :force => true
-      inst.install 'b'
+      inst.install "b"
     end
 
-    assert_equal %w[b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[b-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_build_args
@@ -652,7 +616,7 @@ class TestGemDependencyInstaller < Gem::
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new(
         :build_args => build_args)
-      inst.install 'a'
+      inst.install "a"
     end
 
     assert_equal build_args.join("\n"), File.read(inst.installed_gems.first.build_info_file).strip
@@ -666,10 +630,10 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :ignore_dependencies => true
-      inst.install 'b'
+      inst.install "b"
     end
 
-    assert_equal %w[b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[b-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_install_dir
@@ -681,40 +645,40 @@ class TestGemDependencyInstaller < Gem::
     inst = Gem::Installer.at @a1.file_name
     inst.install
 
-    gemhome2 = File.join @tempdir, 'gemhome2'
+    gemhome2 = File.join @tempdir, "gemhome2"
     Dir.mkdir gemhome2
     inst = nil
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :install_dir => gemhome2
-      inst.install 'b'
+      inst.install "b"
     end
 
-    assert_equal %w[a-1 b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1 b-1], inst.installed_gems.map {|s| s.full_name }
 
-    assert File.exist?(File.join(gemhome2, 'specifications', @a1.spec_name))
-    assert File.exist?(File.join(gemhome2, 'cache', @a1.file_name))
+    assert File.exist?(File.join(gemhome2, "specifications", @a1.spec_name))
+    assert File.exist?(File.join(gemhome2, "cache", @a1.file_name))
   end
 
   def test_install_domain_both
     util_setup_gems
 
     a1_data = nil
-    File.open @a1_gem, 'rb' do |fp|
+    File.open @a1_gem, "rb" do |fp|
       a1_data = fp.read
     end
 
-    @fetcher.data['http://gems.example.com/gems/a-1.gem'] = a1_data
+    @fetcher.data["http://gems.example.com/gems/a-1.gem"] = a1_data
 
     FileUtils.mv @b1_gem, @tempdir
     inst = nil
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :domain => :both
-      inst.install 'b'
+      inst.install "b"
     end
 
-    assert_equal %w[a-1 b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1 b-1], inst.installed_gems.map {|s| s.full_name }
     a1, b1 = inst.installed_gems
 
     assert_equal a1.spec_file, a1.loaded_from
@@ -735,10 +699,10 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :domain => :both
-      inst.install 'b'
+      inst.install "b"
     end
 
-    assert_equal %w[a-1 b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1 b-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_domain_local
@@ -748,32 +712,32 @@ class TestGemDependencyInstaller < Gem::
     inst = nil
 
     Dir.chdir @tempdir do
-      e = assert_raises Gem::UnsatisfiableDependencyError do
+      e = assert_raise Gem::UnsatisfiableDependencyError do
         inst = Gem::DependencyInstaller.new :domain => :local
-        inst.install 'b'
+        inst.install "b"
       end
 
       expected = "Unable to resolve dependency: 'b (>= 0)' requires 'a (>= 0)'"
       assert_equal expected, e.message
     end
 
-    assert_equal [], inst.installed_gems.map { |s| s.full_name }
+    assert_equal [], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_domain_remote
     util_setup_gems
 
     a1_data = nil
-    File.open @a1_gem, 'rb' do |fp|
+    File.open @a1_gem, "rb" do |fp|
       a1_data = fp.read
     end
 
-    @fetcher.data['http://gems.example.com/gems/a-1.gem'] = a1_data
+    @fetcher.data["http://gems.example.com/gems/a-1.gem"] = a1_data
 
     inst = Gem::DependencyInstaller.new :domain => :remote
-    inst.install 'a'
+    inst.install "a"
 
-    assert_equal %w[a-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_dual_repository
@@ -787,22 +751,22 @@ class TestGemDependencyInstaller < Gem::
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new :install_dir => gemhome2
-      inst.install 'a'
+      inst.install "a"
     end
 
-    assert_equal %w[a-1], inst.installed_gems.map { |s| s.full_name },
-                 'sanity check'
+    assert_equal %w[a-1], inst.installed_gems.map {|s| s.full_name },
+                 "sanity check"
 
-    ENV['GEM_HOME'] = @gemhome
-    ENV['GEM_PATH'] = [@gemhome, gemhome2].join File::PATH_SEPARATOR
+    ENV["GEM_HOME"] = @gemhome
+    ENV["GEM_PATH"] = [@gemhome, gemhome2].join File::PATH_SEPARATOR
     Gem.clear_paths
 
     Dir.chdir @tempdir do
       inst = Gem::DependencyInstaller.new
-      inst.install 'b'
+      inst.install "b"
     end
 
-    assert_equal %w[b-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[b-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_reinstall
@@ -813,8 +777,8 @@ class TestGemDependencyInstaller < Gem::
     inst = nil
 
     Dir.chdir @tempdir do
-      inst = Gem::DependencyInstaller.new
-      inst.install 'a'
+      inst = Gem::DependencyInstaller.new :force => true
+      inst.install "a"
     end
 
     assert_equal %w[a-1], Gem::Specification.map(&:full_name)
@@ -825,30 +789,30 @@ class TestGemDependencyInstaller < Gem::
     util_setup_gems
 
     a1_data = nil
-    File.open @a1_gem, 'rb' do |fp|
+    File.open @a1_gem, "rb" do |fp|
       a1_data = fp.read
     end
 
-    @fetcher.data['http://gems.example.com/gems/a-1.gem'] = a1_data
+    @fetcher.data["http://gems.example.com/gems/a-1.gem"] = a1_data
 
     inst = Gem::DependencyInstaller.new
 
     Dir.chdir @tempdir do
-      inst.install 'a'
+      inst.install "a"
     end
 
-    assert_equal %w[a-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_remote_dep
     util_setup_gems
 
     a1_data = nil
-    File.open @a1_gem, 'rb' do |fp|
+    File.open @a1_gem, "rb" do |fp|
       a1_data = fp.read
     end
 
-    @fetcher.data['http://gems.example.com/gems/a-1.gem'] = a1_data
+    @fetcher.data["http://gems.example.com/gems/a-1.gem"] = a1_data
 
     inst = Gem::DependencyInstaller.new
 
@@ -857,28 +821,28 @@ class TestGemDependencyInstaller < Gem::
       inst.install dep
     end
 
-    assert_equal %w[a-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_remote_platform_newer
     util_setup_gems
 
-    a2_o, a2_o_gem = util_gem 'a', '2' do |s|
+    a2_o, a2_o_gem = util_gem "a", "2" do |s|
       s.platform = Gem::Platform.new %w[cpu other_platform 1]
     end
 
     si = util_setup_spec_fetcher @a1, a2_o
 
-    @fetcher.data['http://gems.example.com/gems/yaml'] = si.to_yaml
+    @fetcher.data["http://gems.example.com/gems/yaml"] = si.to_yaml
 
     a1_data = nil
     a2_o_data = nil
 
-    File.open @a1_gem, 'rb' do |fp|
+    File.open @a1_gem, "rb" do |fp|
       a1_data = fp.read
     end
 
-    File.open a2_o_gem, 'rb' do |fp|
+    File.open a2_o_gem, "rb" do |fp|
       a2_o_data = fp.read
     end
 
@@ -888,43 +852,45 @@ class TestGemDependencyInstaller < Gem::
       a2_o_data
 
     inst = Gem::DependencyInstaller.new :domain => :remote
-    inst.install 'a'
+    inst.install "a"
 
-    assert_equal %w[a-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_platform_is_ignored_when_a_file_is_specified
-    _, a_gem = util_gem 'a', '1' do |s|
+    _, a_gem = util_gem "a", "1" do |s|
       s.platform = Gem::Platform.new %w[cpu other_platform 1]
     end
 
     inst = Gem::DependencyInstaller.new :domain => :local
     inst.install a_gem
 
-    assert_equal %w[a-1-cpu-other_platform-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[a-1-cpu-other_platform-1], inst.installed_gems.map {|s| s.full_name }
   end
 
-  if defined? OpenSSL
+  require "rubygems/openssl"
+
+  if Gem::HAVE_OPENSSL
     def test_install_security_policy
       util_setup_gems
 
-      data = File.open(@a1_gem, 'rb') { |f| f.read }
-      @fetcher.data['http://gems.example.com/gems/a-1.gem'] = data
+      data = File.open(@a1_gem, "rb") {|f| f.read }
+      @fetcher.data["http://gems.example.com/gems/a-1.gem"] = data
 
-      data = File.open(@b1_gem, 'rb') { |f| f.read }
-      @fetcher.data['http://gems.example.com/gems/b-1.gem'] = data
+      data = File.open(@b1_gem, "rb") {|f| f.read }
+      @fetcher.data["http://gems.example.com/gems/b-1.gem"] = data
 
       policy = Gem::Security::HighSecurity
       inst = Gem::DependencyInstaller.new :security_policy => policy
 
-      e = assert_raises Gem::Security::Exception do
-        inst.install 'b'
+      e = assert_raise Gem::Security::Exception do
+        inst.install "b"
       end
 
-      assert_equal 'unsigned gems are not allowed by the High Security policy',
+      assert_equal "unsigned gems are not allowed by the High Security policy",
                    e.message
 
-      assert_equal %w[], inst.installed_gems.map { |s| s.full_name }
+      assert_equal %w[], inst.installed_gems.map {|s| s.full_name }
     end
   end
 
@@ -933,139 +899,115 @@ class TestGemDependencyInstaller < Gem::
     def test_install_no_wrappers
       util_setup_gems
 
-      @fetcher.data['http://gems.example.com/gems/a-1.gem'] = read_binary(@a1_gem)
+      @fetcher.data["http://gems.example.com/gems/a-1.gem"] = read_binary(@a1_gem)
 
       inst = Gem::DependencyInstaller.new :wrappers => false, :format_executable => false
-      inst.install 'a'
+      inst.install "a"
 
-      refute_match(%r|This file was generated by RubyGems.|,
-                   File.read(File.join(@gemhome, 'bin', 'a_bin')))
+      refute_match(%r{This file was generated by RubyGems.},
+                   File.read(File.join(@gemhome, "bin", "a_bin")))
     end
   end
 
   def test_install_version
     util_setup_d
 
-    data = File.open(@d2_gem, 'rb') { |f| f.read }
-    @fetcher.data['http://gems.example.com/gems/d-2.gem'] = data
+    data = File.open(@d2_gem, "rb") {|f| f.read }
+    @fetcher.data["http://gems.example.com/gems/d-2.gem"] = data
 
-    data = File.open(@d1_gem, 'rb') { |f| f.read }
-    @fetcher.data['http://gems.example.com/gems/d-1.gem'] = data
+    data = File.open(@d1_gem, "rb") {|f| f.read }
+    @fetcher.data["http://gems.example.com/gems/d-1.gem"] = data
 
     inst = Gem::DependencyInstaller.new
 
-    inst.install 'd', '= 1'
+    inst.install "d", "= 1"
 
-    assert_equal %w[d-1], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[d-1], inst.installed_gems.map {|s| s.full_name }
   end
 
   def test_install_version_default
     util_setup_d
 
-    data = File.open(@d2_gem, 'rb') { |f| f.read }
-    @fetcher.data['http://gems.example.com/gems/d-2.gem'] = data
+    data = File.open(@d2_gem, "rb") {|f| f.read }
+    @fetcher.data["http://gems.example.com/gems/d-2.gem"] = data
 
-    data = File.open(@d1_gem, 'rb') { |f| f.read }
-    @fetcher.data['http://gems.example.com/gems/d-1.gem'] = data
+    data = File.open(@d1_gem, "rb") {|f| f.read }
+    @fetcher.data["http://gems.example.com/gems/d-1.gem"] = data
 
     inst = Gem::DependencyInstaller.new
-    inst.install 'd'
+    inst.install "d"
 
-    assert_equal %w[d-2], inst.installed_gems.map { |s| s.full_name }
+    assert_equal %w[d-2], inst.installed_gems.map {|s| s.full_name }
   end
 
-  def test_find_gems_gems_with_sources
-    util_setup_gems
-
-    inst = Gem::DependencyInstaller.new
-    dep = Gem::Dependency.new 'b', '>= 0'
-
-    Gem::Specification.reset
+  def test_install_legacy_spec_with_nil_required_ruby_version
+    path = File.expand_path "data/null-required-ruby-version.gemspec.rz", __dir__
+    spec = Marshal.load Gem.read_binary(path)
+    def spec.validate(*args); end
 
-    set = Gem::Deprecate.skip_during do
-      inst.find_gems_with_sources(dep)
-    end
+    util_build_gem spec
 
-    assert_kind_of Gem::AvailableSet, set
+    cache_file = File.join @tempdir, "gems", "#{spec.original_name}.gem"
+    FileUtils.mkdir_p File.dirname cache_file
+    FileUtils.mv spec.cache_file, cache_file
 
-    s = set.set.first
+    util_setup_spec_fetcher spec
 
-    assert_equal @b1, s.spec
-    assert_equal Gem::Source.new(@gem_repo), s.source
-  end
+    data = Gem.read_binary(cache_file)
 
-  def test_find_spec_by_name_and_version_wildcard
-    util_gem 'a', 1
-    FileUtils.mv 'gems/a-1.gem', @tempdir
+    @fetcher.data["http://gems.example.com/gems/activesupport-1.0.0.gem"] = data
 
-    FileUtils.touch 'rdoc.gem'
+    dep = Gem::Dependency.new "activesupport"
 
     inst = Gem::DependencyInstaller.new
+    inst.install dep
 
-    available = Gem::Deprecate.skip_during do
-      inst.find_spec_by_name_and_version('*.gem')
-    end
-
-    assert_equal %w[a-1], available.each_spec.map { |spec| spec.full_name }
+    assert_equal %w[activesupport-1.0.0], Gem::Specification.map(&:full_name)
   end
 
-  def test_find_spec_by_name_and_version_wildcard_bad_gem
-    FileUtils.touch 'rdoc.gem'
-
-    inst = Gem::DependencyInstaller.new
+  def test_install_legacy_spec_with_nil_required_rubygems_version
+    path = File.expand_path "data/null-required-rubygems-version.gemspec.rz", __dir__
+    spec = Marshal.load Gem.read_binary(path)
+    def spec.validate(*args); end
 
-    assert_raises Gem::Package::FormatError do
-      Gem::Deprecate.skip_during do
-        inst.find_spec_by_name_and_version '*.gem'
-      end
-    end
-  end
+    util_build_gem spec
 
-  def test_find_spec_by_name_and_version_bad_gem
-    FileUtils.touch 'rdoc.gem'
+    cache_file = File.join @tempdir, "gems", "#{spec.original_name}.gem"
+    FileUtils.mkdir_p File.dirname cache_file
+    FileUtils.mv spec.cache_file, cache_file
 
-    inst = Gem::DependencyInstaller.new
+    util_setup_spec_fetcher spec
 
-    e = assert_raises Gem::Package::FormatError do
-      Gem::Deprecate.skip_during do
-        inst.find_spec_by_name_and_version 'rdoc.gem'
-      end
-    end
+    data = Gem.read_binary(cache_file)
 
-    full_path = File.join @tempdir, 'rdoc.gem'
-    assert_equal "package metadata is missing in #{full_path}", e.message
-  end
+    @fetcher.data["http://gems.example.com/gems/activesupport-1.0.0.gem"] = data
 
-  def test_find_spec_by_name_and_version_directory
-    Dir.mkdir 'rdoc'
+    dep = Gem::Dependency.new "activesupport"
 
     inst = Gem::DependencyInstaller.new
+    inst.install dep
 
-    e = assert_raises Gem::SpecificGemNotFoundException do
-      Gem::Deprecate.skip_during do
-        inst.find_spec_by_name_and_version 'rdoc'
-      end
-    end
-
-    assert_equal "Could not find a valid gem 'rdoc' (>= 0) " +
-                 "locally or in a repository",
-                 e.message
+    assert_equal %w[activesupport-1.0.0], Gem::Specification.map(&:full_name)
   end
 
-  def test_find_spec_by_name_and_version_file
-    FileUtils.touch 'rdoc'
+  def test_find_gems_gems_with_sources
+    util_setup_gems
 
     inst = Gem::DependencyInstaller.new
+    dep = Gem::Dependency.new "b", ">= 0"
 
-    e = assert_raises Gem::SpecificGemNotFoundException do
-      Gem::Deprecate.skip_during do
-        inst.find_spec_by_name_and_version 'rdoc'
-      end
+    Gem::Specification.reset
+
+    set = Gem::Deprecate.skip_during do
+      inst.find_gems_with_sources(dep)
     end
 
-    assert_equal "Could not find a valid gem 'rdoc' (>= 0) " +
-                 "locally or in a repository",
-                 e.message
+    assert_kind_of Gem::AvailableSet, set
+
+    s = set.set.first
+
+    assert_equal @b1, s.spec
+    assert_equal Gem::Source.new(@gem_repo), s.source
   end
 
   def test_find_gems_with_sources_local
@@ -1073,7 +1015,7 @@ class TestGemDependencyInstaller < Gem::
 
     FileUtils.mv @a1_gem, @tempdir
     inst = Gem::DependencyInstaller.new
-    dep = Gem::Dependency.new 'a', '>= 0'
+    dep = Gem::Dependency.new "a", ">= 0"
     set = nil
 
     Dir.chdir @tempdir do
@@ -1088,12 +1030,12 @@ class TestGemDependencyInstaller < Gem::
 
     remote, local = gems
 
-    assert_equal 'a-1', local.spec.full_name, 'local spec'
+    assert_equal "a-1", local.spec.full_name, "local spec"
     assert_equal File.join(@tempdir, @a1.file_name),
-                 local.source.download(local.spec), 'local path'
+                 local.source.download(local.spec), "local path"
 
-    assert_equal 'a-1', remote.spec.full_name, 'remote spec'
-    assert_equal Gem::Source.new(@gem_repo), remote.source, 'remote path'
+    assert_equal "a-1", remote.spec.full_name, "remote spec"
+    assert_equal Gem::Source.new(@gem_repo), remote.source, "remote path"
   end
 
   def test_find_gems_with_sources_prerelease
@@ -1101,7 +1043,7 @@ class TestGemDependencyInstaller < Gem::
 
     installer = Gem::DependencyInstaller.new
 
-    dependency = Gem::Dependency.new('a', Gem::Requirement.default)
+    dependency = Gem::Dependency.new("a", Gem::Requirement.default)
 
     set = Gem::Deprecate.skip_during do
       installer.find_gems_with_sources(dependency)
@@ -1109,8 +1051,8 @@ class TestGemDependencyInstaller < Gem::
 
     releases = set.all_specs
 
-    assert releases.any? { |s| s.name == 'a' and s.version.to_s == '1' }
-    refute releases.any? { |s| s.name == 'a' and s.version.to_s == '1.a' }
+    assert releases.any? {|s| s.name == "a" && s.version.to_s == "1" }
+    refute releases.any? {|s| s.name == "a" && s.version.to_s == "1.a" }
 
     dependency.prerelease = true
 
@@ -1125,15 +1067,15 @@ class TestGemDependencyInstaller < Gem::
 
   def test_find_gems_with_sources_with_best_only_and_platform
     util_setup_gems
-    a1_x86_mingw32, = util_gem 'a', '1' do |s|
-      s.platform = 'x86-mingw32'
+    a1_x86_mingw32, = util_gem "a", "1" do |s|
+      s.platform = "x86-mingw32"
     end
     util_setup_spec_fetcher @a1, a1_x86_mingw32
-    Gem.platforms << Gem::Platform.new('x86-mingw32')
+    Gem.platforms << Gem::Platform.new("x86-mingw32")
 
     installer = Gem::DependencyInstaller.new
 
-    dependency = Gem::Dependency.new('a', Gem::Requirement.default)
+    dependency = Gem::Dependency.new("a", Gem::Requirement.default)
 
     set = Gem::Deprecate.skip_during do
       installer.find_gems_with_sources(dependency, true)
@@ -1149,7 +1091,7 @@ class TestGemDependencyInstaller < Gem::
 
     installer = Gem::DependencyInstaller.new
 
-    dep = Gem::Dependency.new('a')
+    dep = Gem::Dependency.new("a")
 
     out = Gem::Deprecate.skip_during do
       installer.find_gems_with_sources(dep)
@@ -1166,9 +1108,9 @@ class TestGemDependencyInstaller < Gem::
     FileUtils.mv @b1_gem, @tempdir
 
     inst = Gem::DependencyInstaller.new
-    request_set = inst.resolve_dependencies 'b', req('>= 0')
+    request_set = inst.resolve_dependencies "b", req(">= 0")
 
-    requests = request_set.sorted_requests.map { |req| req.full_name }
+    requests = request_set.sorted_requests.map {|req| req.full_name }
 
     assert_equal %w[a-1 b-1], requests
   end
@@ -1180,9 +1122,9 @@ class TestGemDependencyInstaller < Gem::
     FileUtils.mv @b1_gem, @tempdir
 
     inst = Gem::DependencyInstaller.new :ignore_dependencies => true
-    request_set = inst.resolve_dependencies 'b', req('>= 0')
+    request_set = inst.resolve_dependencies "b", req(">= 0")
 
-    requests = request_set.sorted_requests.map { |req| req.full_name }
+    requests = request_set.sorted_requests.map {|req| req.full_name }
 
     assert request_set.ignore_dependencies
 
@@ -1192,78 +1134,22 @@ class TestGemDependencyInstaller < Gem::
   def test_resolve_dependencies_local
     util_setup_gems
 
-    @a2, @a2_gem = util_gem 'a', '2'
+    @a2, @a2_gem = util_gem "a", "2"
     FileUtils.mv @a1_gem, @tempdir
     FileUtils.mv @a2_gem, @tempdir
 
     inst = Gem::DependencyInstaller.new
-    request_set = inst.resolve_dependencies 'a-1.gem', req('>= 0')
+    request_set = inst.resolve_dependencies "a-1.gem", req(">= 0")
 
-    requests = request_set.sorted_requests.map { |req| req.full_name }
+    requests = request_set.sorted_requests.map {|req| req.full_name }
 
     assert_equal %w[a-1], requests
   end
 
-  def util_write_a1_bin
-    write_file File.join('gems', 'a-1', 'bin', 'a_bin') do |fp|
-      fp.puts "#!/usr/bin/ruby"
-    end
-  end
-
-  def util_setup_c1_pre
-    @c1_pre, @c1_pre_gem = util_spec 'c', '1.a' do |s|
-      s.add_dependency 'a', '1.a'
-      s.add_dependency 'b', '1'
-    end
-
-    util_reset_gems
-  end
-
   def util_setup_d
-    @d1, @d1_gem = util_gem 'd', '1'
-    @d2, @d2_gem = util_gem 'd', '2'
+    @d1, @d1_gem = util_gem "d", "1"
+    @d2, @d2_gem = util_gem "d", "2"
 
-    util_reset_gems
+    util_setup_spec_fetcher(@d1, @d2)
   end
-
-  def util_setup_wxyz
-    @x1_m, @x1_m_gem = util_spec 'x', '1' do |s|
-      s.platform = Gem::Platform.new %w[cpu my_platform 1]
-    end
-
-    @x1_o, @x1_o_gem = util_spec 'x', '1' do |s|
-      s.platform = Gem::Platform.new %w[cpu other_platform 1]
-    end
-
-    @w1, @w1_gem = util_spec 'w', '1', 'x' => nil
-
-    @y1, @y1_gem = util_spec 'y', '1'
-    @y1_1_p, @y1_1_p_gem = util_spec 'y', '1.1' do |s|
-      s.platform = Gem::Platform.new %w[cpu my_platform 1]
-    end
-
-    @z1, @z1_gem = util_spec 'z', '1', 'y' => nil
-
-    util_reset_gems
-  end
-
-  def util_reset_gems
-    @a1     ||= nil
-    @b1     ||= nil
-    @a1_pre ||= nil
-    @c1_pre ||= nil
-    @d1     ||= nil
-    @d2     ||= nil
-    @w1     ||= nil
-    @x1_m   ||= nil
-    @x1_o   ||= nil
-    @y1     ||= nil
-    @y1_1_p ||= nil
-    @z1     ||= nil
-
-    util_setup_spec_fetcher(*[@a1, @a1_pre, @b1, @c1_pre,
-                              @d1, @d2, @x1_m, @x1_o, @w1, @y1,
-                              @y1_1_p, @z1].compact)
-  end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_dependency_list.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_dependency_list.rb
@@ -1,35 +1,34 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/dependency_list'
+require_relative "helper"
+require "rubygems/dependency_list"
 
 class TestGemDependencyList < Gem::TestCase
-
   def setup
     super
 
     @deplist = Gem::DependencyList.new
 
     # TODO: switch to util_spec
-    @a1 = util_spec 'a', '1'
-    @a2 = util_spec 'a', '2'
-    @a3 = util_spec 'a', '3'
+    @a1 = util_spec "a", "1"
+    @a2 = util_spec "a", "2"
+    @a3 = util_spec "a", "3"
 
-    @b1 = util_spec 'b', '1' do |s|
-      s.add_dependency 'a', '>= 1'
+    @b1 = util_spec "b", "1" do |s|
+      s.add_dependency "a", ">= 1"
     end
 
-    @b2 = util_spec 'b', '2' do |s|
-      s.add_dependency 'a', '>= 1'
+    @b2 = util_spec "b", "2" do |s|
+      s.add_dependency "a", ">= 1"
     end
 
-    @c1 = util_spec 'c', '1' do |s|
-      s.add_dependency 'b', '>= 1'
+    @c1 = util_spec "c", "1" do |s|
+      s.add_dependency "b", ">= 1"
     end
 
-    @c2 = util_spec 'c', '2'
+    @c2 = util_spec "c", "2"
 
-    @d1 = util_spec 'd', '1' do |s|
-      s.add_dependency 'c', '>= 1'
+    @d1 = util_spec "d", "1" do |s|
+      s.add_dependency "c", ">= 1"
     end
   end
 
@@ -53,55 +52,55 @@ class TestGemDependencyList < Gem::TestC
 
     order = @deplist.dependency_order
 
-    assert_equal %w[d-1 c-1 b-1 a-1], order.map { |s| s.full_name }
+    assert_equal %w[d-1 c-1 b-1 a-1], order.map {|s| s.full_name }
   end
 
   def test_dependency_order_circle
-    @a1.add_dependency 'c', '>= 1'
+    @a1.add_dependency "c", ">= 1"
     @deplist.add @a1, @b1, @c1
 
     order = @deplist.dependency_order
 
-    assert_equal %w[b-1 c-1 a-1], order.map { |s| s.full_name }
+    assert_equal %w[b-1 c-1 a-1], order.map {|s| s.full_name }
   end
 
   def test_dependency_order_development
-    e1 = util_spec 'e', '1'
-    f1 = util_spec 'f', '1'
-    g1 = util_spec 'g', '1'
-
-    @a1.add_dependency 'e'
-    @a1.add_dependency 'f'
-    @a1.add_dependency 'g'
-    g1.add_development_dependency 'a'
+    e1 = util_spec "e", "1"
+    f1 = util_spec "f", "1"
+    g1 = util_spec "g", "1"
+
+    @a1.add_dependency "e"
+    @a1.add_dependency "f"
+    @a1.add_dependency "g"
+    g1.add_development_dependency "a"
 
     deplist = Gem::DependencyList.new true
     deplist.add @a1, e1, f1, g1
 
     order = deplist.dependency_order
 
-    assert_equal %w[g-1 a-1 f-1 e-1], order.map { |s| s.full_name },
-                 'development on'
+    assert_equal %w[g-1 a-1 f-1 e-1], order.map {|s| s.full_name },
+                 "development on"
 
     deplist2 = Gem::DependencyList.new
     deplist2.add @a1, e1, f1, g1
 
     order = deplist2.dependency_order
 
-    assert_equal %w[a-1 g-1 f-1 e-1], order.map { |s| s.full_name },
-                 'development off'
+    assert_equal %w[a-1 g-1 f-1 e-1], order.map {|s| s.full_name },
+                 "development off"
   end
 
   def test_dependency_order_diamond
     util_diamond
-    e1 = util_spec 'e', '1'
+    e1 = util_spec "e", "1"
     @deplist.add e1
-    @a1.add_dependency 'e', '>= 1'
+    @a1.add_dependency "e", ">= 1"
 
     order = @deplist.dependency_order
 
-    assert_equal %w[d-1 c-2 b-1 a-2 e-1], order.map { |s| s.full_name },
-                 'deps of trimmed specs not included'
+    assert_equal %w[d-1 c-2 b-1 a-2 e-1], order.map {|s| s.full_name },
+                 "deps of trimmed specs not included"
   end
 
   def test_dependency_order_no_dependencies
@@ -109,7 +108,7 @@ class TestGemDependencyList < Gem::TestC
 
     order = @deplist.dependency_order
 
-    assert_equal %w[c-2 a-1], order.map { |s| s.full_name }
+    assert_equal %w[c-2 a-1], order.map {|s| s.full_name }
   end
 
   def test_find_name
@@ -122,39 +121,39 @@ class TestGemDependencyList < Gem::TestC
   end
 
   def test_ok_eh
-    assert @deplist.ok?, 'no dependencies'
+    assert @deplist.ok?, "no dependencies"
 
     @deplist.add @b2
 
-    refute @deplist.ok?, 'unsatisfied dependency'
+    refute @deplist.ok?, "unsatisfied dependency"
 
     @deplist.add @a1
 
-    assert @deplist.ok?, 'satisfied dependency'
+    assert @deplist.ok?, "satisfied dependency"
   end
 
   def test_why_not_ok_eh
-    assert_equal({},  @deplist.why_not_ok?)
+    assert_equal({}, @deplist.why_not_ok?)
 
     @deplist.add @b2
 
     exp = {
       "b" => [
-        Gem::Dependency.new("a", ">= 1")
-      ]
+        Gem::Dependency.new("a", ">= 1"),
+      ],
     }
 
     assert_equal exp, @deplist.why_not_ok?
   end
 
   def test_why_not_ok_eh_old_dependency
-    a  = util_spec 'a', '1',
-                  'b' => '~> 1.0'
+    a  = util_spec "a", "1",
+                  "b" => "~> 1.0"
 
-    b0 = util_spec 'b', '1.0',
-                  'd' => '>= 0'
+    b0 = util_spec "b", "1.0",
+                  "d" => ">= 0"
 
-    b1 = util_spec 'b', '1.1'
+    b1 = util_spec "b", "1.1"
 
     util_clear_gems
 
@@ -162,29 +161,29 @@ class TestGemDependencyList < Gem::TestC
 
     @deplist.add a, b0, b1
 
-    assert_equal({},  @deplist.why_not_ok?)
+    assert_equal({}, @deplist.why_not_ok?)
   end
 
   def test_ok_eh_mismatch
-    a1 = util_spec 'a', '1'
-    a2 = util_spec 'a', '2'
+    a1 = util_spec "a", "1"
+    a2 = util_spec "a", "2"
 
-    b = util_spec 'b', '1' do |s|
-      s.add_dependency 'a', '= 1'
+    b = util_spec "b", "1" do |s|
+      s.add_dependency "a", "= 1"
     end
 
-    c = util_spec 'c', '1' do |s|
-      s.add_dependency 'a', '= 2'
+    c = util_spec "c", "1" do |s|
+      s.add_dependency "a", "= 2"
     end
 
-    d = util_spec 'd', '1' do |s|
-      s.add_dependency 'b'
-      s.add_dependency 'c'
+    d = util_spec "d", "1" do |s|
+      s.add_dependency "b"
+      s.add_dependency "c"
     end
 
     @deplist.add a1, a2, b, c, d
 
-    assert @deplist.ok?, 'this will break on require'
+    assert @deplist.ok?, "this will break on require"
   end
 
   def test_ok_eh_redundant
@@ -257,10 +256,9 @@ class TestGemDependencyList < Gem::TestC
   # d1 -> b1 -> a1
   # d1 -> c2 -> a2
   def util_diamond
-    @c2.add_dependency 'a', '>= 2'
-    @d1.add_dependency 'b'
+    @c2.add_dependency "a", ">= 2"
+    @d1.add_dependency "b"
 
     @deplist.add @a1, @a2, @b1, @c2, @d1
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_dependency_resolution_error.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_dependency_resolution_error.rb
@@ -1,17 +1,16 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemDependencyResolutionError < Gem::TestCase
-
   def setup
     super
 
     @DR = Gem::Resolver
 
-    @spec = util_spec 'a', 2
+    @spec = util_spec "a", 2
 
-    @a1_req = @DR::DependencyRequest.new dep('a', '= 1'), nil
-    @a2_req = @DR::DependencyRequest.new dep('a', '= 2'), nil
+    @a1_req = @DR::DependencyRequest.new dep("a", "= 1"), nil
+    @a2_req = @DR::DependencyRequest.new dep("a", "= 2"), nil
 
     @activated = @DR::ActivationRequest.new @spec, @a2_req
 
@@ -21,8 +20,7 @@ class TestGemDependencyResolutionError <
   end
 
   def test_message
-    assert_match %r%^conflicting dependencies a \(= 1\) and a \(= 2\)$%,
+    assert_match %r{^conflicting dependencies a \(= 1\) and a \(= 2\)$},
                  @error.message
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_doctor.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_doctor.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/doctor'
+require_relative "helper"
+require "rubygems/doctor"
 
 class TestGemDoctor < Gem::TestCase
-
   def gem(name)
     spec = quick_gem name do |gem|
       gem.files = %W[lib/#{name}.rb Rakefile]
@@ -16,43 +15,43 @@ class TestGemDoctor < Gem::TestCase
   end
 
   def test_doctor
-    a = gem 'a'
-    b = gem 'b'
-    c = gem 'c'
+    a = gem "a"
+    b = gem "b"
+    c = gem "c"
 
     Gem.use_paths @userhome, @gemhome
 
     FileUtils.rm b.spec_file
 
-    File.open c.spec_file, 'w' do |io|
-      io.write 'this will raise an exception when evaluated.'
+    File.open c.spec_file, "w" do |io|
+      io.write "this will raise an exception when evaluated."
     end
 
-    assert_path_exists File.join(a.gem_dir, 'Rakefile')
-    assert_path_exists File.join(a.gem_dir, 'lib', 'a.rb')
+    assert_path_exist File.join(a.gem_dir, "Rakefile")
+    assert_path_exist File.join(a.gem_dir, "lib", "a.rb")
 
-    assert_path_exists b.gem_dir
-    refute_path_exists b.spec_file
+    assert_path_exist b.gem_dir
+    assert_path_not_exist b.spec_file
 
-    assert_path_exists c.gem_dir
-    assert_path_exists c.spec_file
+    assert_path_exist c.gem_dir
+    assert_path_exist c.spec_file
 
     doctor = Gem::Doctor.new @gemhome
 
-    capture_io do
+    capture_output do
       use_ui @ui do
         doctor.doctor
       end
     end
 
-    assert_path_exists File.join(a.gem_dir, 'Rakefile')
-    assert_path_exists File.join(a.gem_dir, 'lib', 'a.rb')
+    assert_path_exist File.join(a.gem_dir, "Rakefile")
+    assert_path_exist File.join(a.gem_dir, "lib", "a.rb")
 
-    refute_path_exists b.gem_dir
-    refute_path_exists b.spec_file
+    assert_path_not_exist b.gem_dir
+    assert_path_not_exist b.spec_file
 
-    refute_path_exists c.gem_dir
-    refute_path_exists c.spec_file
+    assert_path_not_exist c.gem_dir
+    assert_path_not_exist c.spec_file
 
     expected = <<-OUTPUT
 Checking #{@gemhome}
@@ -69,43 +68,43 @@ Removed directory gems/c-2
   end
 
   def test_doctor_dry_run
-    a = gem 'a'
-    b = gem 'b'
-    c = gem 'c'
+    a = gem "a"
+    b = gem "b"
+    c = gem "c"
 
     Gem.use_paths @userhome, @gemhome
 
     FileUtils.rm b.spec_file
 
-    File.open c.spec_file, 'w' do |io|
-      io.write 'this will raise an exception when evaluated.'
+    File.open c.spec_file, "w" do |io|
+      io.write "this will raise an exception when evaluated."
     end
 
-    assert_path_exists File.join(a.gem_dir, 'Rakefile')
-    assert_path_exists File.join(a.gem_dir, 'lib', 'a.rb')
+    assert_path_exist File.join(a.gem_dir, "Rakefile")
+    assert_path_exist File.join(a.gem_dir, "lib", "a.rb")
 
-    assert_path_exists b.gem_dir
-    refute_path_exists b.spec_file
+    assert_path_exist b.gem_dir
+    assert_path_not_exist b.spec_file
 
-    assert_path_exists c.gem_dir
-    assert_path_exists c.spec_file
+    assert_path_exist c.gem_dir
+    assert_path_exist c.spec_file
 
     doctor = Gem::Doctor.new @gemhome, true
 
-    capture_io do
+    capture_output do
       use_ui @ui do
         doctor.doctor
       end
     end
 
-    assert_path_exists File.join(a.gem_dir, 'Rakefile')
-    assert_path_exists File.join(a.gem_dir, 'lib', 'a.rb')
+    assert_path_exist File.join(a.gem_dir, "Rakefile")
+    assert_path_exist File.join(a.gem_dir, "lib", "a.rb")
 
-    assert_path_exists b.gem_dir
-    refute_path_exists b.spec_file
+    assert_path_exist b.gem_dir
+    assert_path_not_exist b.spec_file
 
-    assert_path_exists c.gem_dir
-    assert_path_exists c.spec_file
+    assert_path_exist c.gem_dir
+    assert_path_exist c.spec_file
 
     expected = <<-OUTPUT
 Checking #{@gemhome}
@@ -122,19 +121,19 @@ Extra directory gems/c-2
   end
 
   def test_doctor_non_gem_home
-    other_dir = File.join @tempdir, 'other', 'dir'
+    other_dir = File.join @tempdir, "other", "dir"
 
     FileUtils.mkdir_p other_dir
 
     doctor = Gem::Doctor.new @tempdir
 
-    capture_io do
+    capture_output do
       use_ui @ui do
         doctor.doctor
       end
     end
 
-    assert_path_exists other_dir
+    assert_path_exist other_dir
 
     expected = <<-OUTPUT
 Checking #{@tempdir}
@@ -148,21 +147,48 @@ This directory does not appear to be a R
   def test_doctor_child_missing
     doctor = Gem::Doctor.new @gemhome
 
-    doctor.doctor_child 'missing', ''
+    doctor.doctor_child "missing", ""
 
     assert true # count
   end
 
+  def test_doctor_badly_named_plugins
+    gem "a"
+
+    Gem.use_paths @gemhome.to_s
+
+    FileUtils.mkdir_p Gem.plugindir
+    bad_plugin = File.join(Gem.plugindir, "a_badly_named_file.rb")
+    write_file bad_plugin
+
+    doctor = Gem::Doctor.new @gemhome
+
+    capture_output do
+      use_ui @ui do
+        doctor.doctor
+      end
+    end
+
+    # assert_path_not_exist bad_plugin
+
+    expected = <<-OUTPUT
+Checking #{@gemhome}
+Removed file plugins/a_badly_named_file.rb
+
+    OUTPUT
+
+    assert_equal expected, @ui.output
+  end
+
   def test_gem_repository_eh
     doctor = Gem::Doctor.new @gemhome
 
-    refute doctor.gem_repository?, 'no gems installed'
+    refute doctor.gem_repository?, "no gems installed"
 
-    install_specs util_spec 'a'
+    install_specs util_spec "a"
 
     doctor = Gem::Doctor.new @gemhome
 
-    assert doctor.gem_repository?, 'gems installed'
+    assert doctor.gem_repository?, "gems installed"
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_ext_builder.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_builder.rb
@@ -1,39 +1,39 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/ext'
-require 'rubygems/installer'
+require_relative "helper"
+require "rubygems/ext"
+require "rubygems/installer"
 
 class TestGemExtBuilder < Gem::TestCase
-
   def setup
     super
 
-    @ext = File.join @tempdir, 'ext'
-    @dest_path = File.join @tempdir, 'prefix'
+    @ext = File.join @tempdir, "ext"
+    @dest_path = File.join @tempdir, "prefix"
 
     FileUtils.mkdir_p @ext
     FileUtils.mkdir_p @dest_path
 
-    @orig_DESTDIR = ENV['DESTDIR']
+    @orig_DESTDIR = ENV["DESTDIR"]
+    @orig_make = ENV["make"]
 
-    @spec = util_spec 'a'
+    @spec = util_spec "a"
 
-    @builder = Gem::Ext::Builder.new @spec, ''
+    @builder = Gem::Ext::Builder.new @spec, ""
   end
 
   def teardown
-    ENV['DESTDIR'] = @orig_DESTDIR
+    ENV["DESTDIR"] = @orig_DESTDIR
+    ENV["make"] = @orig_make
 
     super
   end
 
   def test_class_make
-    ENV['DESTDIR'] = 'destination'
+    ENV["DESTDIR"] = "destination"
     results = []
 
-    Dir.chdir @ext do
-      File.open 'Makefile', 'w' do |io|
-        io.puts <<-MAKEFILE
+    File.open File.join(@ext, "Makefile"), "w" do |io|
+      io.puts <<-MAKEFILE
 all:
 \t@#{Gem.ruby} -e "puts %Q{all: \#{ENV['DESTDIR']}}"
 
@@ -42,60 +42,80 @@ clean:
 
 install:
 \t@#{Gem.ruby} -e "puts %Q{install: \#{ENV['DESTDIR']}}"
-        MAKEFILE
-      end
-
-      Gem::Ext::Builder.make @dest_path, results
+      MAKEFILE
     end
 
-    results = results.join "\n"
+    Gem::Ext::Builder.make @dest_path, results, @ext
+
+    results = results.join("\n").b
 
-    assert_match %r%"DESTDIR=#{ENV['DESTDIR']}" clean$%,   results
-    assert_match %r%"DESTDIR=#{ENV['DESTDIR']}"$%,         results
-    assert_match %r%"DESTDIR=#{ENV['DESTDIR']}" install$%, results
+    assert_match %r{DESTDIR\\=#{ENV['DESTDIR']} clean$},   results
+    assert_match %r{DESTDIR\\=#{ENV['DESTDIR']}$},         results
+    assert_match %r{DESTDIR\\=#{ENV['DESTDIR']} install$}, results
 
     if /nmake/ !~ results
-      assert_match %r%^clean: destination$%,   results
-      assert_match %r%^all: destination$%,     results
-      assert_match %r%^install: destination$%, results
+      assert_match %r{^clean: destination$},   results
+      assert_match %r{^all: destination$},     results
+      assert_match %r{^install: destination$}, results
     end
   end
 
   def test_class_make_no_clean
-    ENV['DESTDIR'] = 'destination'
+    ENV["DESTDIR"] = "destination"
     results = []
 
-    Dir.chdir @ext do
-      File.open 'Makefile', 'w' do |io|
-        io.puts <<-MAKEFILE
+    File.open File.join(@ext, "Makefile"), "w" do |io|
+      io.puts <<-MAKEFILE
 all:
 \t@#{Gem.ruby} -e "puts %Q{all: \#{ENV['DESTDIR']}}"
 
 install:
 \t@#{Gem.ruby} -e "puts %Q{install: \#{ENV['DESTDIR']}}"
-        MAKEFILE
-      end
-
-      Gem::Ext::Builder.make @dest_path, results
+      MAKEFILE
     end
 
-    results = results.join "\n"
+    Gem::Ext::Builder.make @dest_path, results, @ext
+
+    results = results.join("\n").b
 
-    assert_match %r%"DESTDIR=#{ENV['DESTDIR']}" clean$%,   results
-    assert_match %r%"DESTDIR=#{ENV['DESTDIR']}"$%,         results
-    assert_match %r%"DESTDIR=#{ENV['DESTDIR']}" install$%, results
+    assert_match %r{DESTDIR\\=#{ENV['DESTDIR']} clean$},   results
+    assert_match %r{DESTDIR\\=#{ENV['DESTDIR']}$},         results
+    assert_match %r{DESTDIR\\=#{ENV['DESTDIR']} install$}, results
+  end
+
+  def test_custom_make_with_options
+    ENV["make"] = "make V=1"
+    results = []
+    File.open File.join(@ext, "Makefile"), "w" do |io|
+      io.puts <<-MAKEFILE
+all:
+\t@#{Gem.ruby} -e "puts 'all: OK'"
+
+clean:
+\t@#{Gem.ruby} -e "puts 'clean: OK'"
+
+install:
+\t@#{Gem.ruby} -e "puts 'install: OK'"
+      MAKEFILE
+    end
+    Gem::Ext::Builder.make @dest_path, results, @ext
+    results = results.join("\n").b
+    assert_match %r{clean: OK}, results
+    assert_match %r{all: OK}, results
+    assert_match %r{install: OK}, results
   end
 
   def test_build_extensions
-    @spec.extensions << 'ext/extconf.rb'
+    pend if /mswin/ =~ RUBY_PLATFORM && ENV.key?("GITHUB_ACTIONS") # not working from the beginning
+    @spec.extensions << "ext/extconf.rb"
 
-    ext_dir = File.join @spec.gem_dir, 'ext'
+    ext_dir = File.join @spec.gem_dir, "ext"
 
     FileUtils.mkdir_p ext_dir
 
-    extconf_rb = File.join ext_dir, 'extconf.rb'
+    extconf_rb = File.join ext_dir, "extconf.rb"
 
-    File.open extconf_rb, 'w' do |f|
+    File.open extconf_rb, "w" do |f|
       f.write <<-'RUBY'
         require 'mkmf'
 
@@ -103,38 +123,38 @@ install:
       RUBY
     end
 
-    ext_lib_dir = File.join ext_dir, 'lib'
+    ext_lib_dir = File.join ext_dir, "lib"
     FileUtils.mkdir ext_lib_dir
-    FileUtils.touch File.join ext_lib_dir, 'a.rb'
-    FileUtils.mkdir File.join ext_lib_dir, 'a'
-    FileUtils.touch File.join ext_lib_dir, 'a', 'b.rb'
+    FileUtils.touch File.join ext_lib_dir, "a.rb"
+    FileUtils.mkdir File.join ext_lib_dir, "a"
+    FileUtils.touch File.join ext_lib_dir, "a", "b.rb"
 
     use_ui @ui do
       @builder.build_extensions
     end
 
-    assert_path_exists @spec.extension_dir
-    assert_path_exists @spec.gem_build_complete_path
-    assert_path_exists File.join @spec.extension_dir, 'gem_make.out'
-    assert_path_exists File.join @spec.extension_dir, 'a.rb'
-    assert_path_exists File.join @spec.gem_dir, 'lib', 'a.rb'
-    assert_path_exists File.join @spec.gem_dir, 'lib', 'a', 'b.rb'
+    assert_path_exist @spec.extension_dir
+    assert_path_exist @spec.gem_build_complete_path
+    assert_path_exist File.join @spec.extension_dir, "gem_make.out"
+    assert_path_exist File.join @spec.extension_dir, "a.rb"
+    assert_path_exist File.join @spec.gem_dir, "lib", "a.rb"
+    assert_path_exist File.join @spec.gem_dir, "lib", "a", "b.rb"
   end
 
   def test_build_extensions_with_gemhome_with_space
-    new_gemhome = File.join @tempdir, 'gem home'
+    pend if /mswin/ =~ RUBY_PLATFORM && ENV.key?("GITHUB_ACTIONS") # not working from the beginning
+    new_gemhome = File.join @tempdir, "gem home"
     File.rename(@gemhome, new_gemhome)
     @gemhome = new_gemhome
     Gem.use_paths(@gemhome)
-    @spec = util_spec 'a'
-    @builder = Gem::Ext::Builder.new @spec, ''
+    @spec = util_spec "a"
+    @builder = Gem::Ext::Builder.new @spec, ""
 
     test_build_extensions
   end
 
   def test_build_extensions_install_ext_only
     class << Gem
-
       alias orig_install_extension_in_lib install_extension_in_lib
 
       remove_method :install_extension_in_lib
@@ -142,18 +162,18 @@ install:
       def Gem.install_extension_in_lib
         false
       end
-
     end
+    pend if /mswin/ =~ RUBY_PLATFORM && ENV.key?("GITHUB_ACTIONS") # not working from the beginning
 
-    @spec.extensions << 'ext/extconf.rb'
+    @spec.extensions << "ext/extconf.rb"
 
-    ext_dir = File.join @spec.gem_dir, 'ext'
+    ext_dir = File.join @spec.gem_dir, "ext"
 
     FileUtils.mkdir_p ext_dir
 
-    extconf_rb = File.join ext_dir, 'extconf.rb'
+    extconf_rb = File.join ext_dir, "extconf.rb"
 
-    File.open extconf_rb, 'w' do |f|
+    File.open extconf_rb, "w" do |f|
       f.write <<-'RUBY'
         require 'mkmf'
 
@@ -161,29 +181,27 @@ install:
       RUBY
     end
 
-    ext_lib_dir = File.join ext_dir, 'lib'
+    ext_lib_dir = File.join ext_dir, "lib"
     FileUtils.mkdir ext_lib_dir
-    FileUtils.touch File.join ext_lib_dir, 'a.rb'
-    FileUtils.mkdir File.join ext_lib_dir, 'a'
-    FileUtils.touch File.join ext_lib_dir, 'a', 'b.rb'
+    FileUtils.touch File.join ext_lib_dir, "a.rb"
+    FileUtils.mkdir File.join ext_lib_dir, "a"
+    FileUtils.touch File.join ext_lib_dir, "a", "b.rb"
 
     use_ui @ui do
       @builder.build_extensions
     end
 
-    assert_path_exists @spec.extension_dir
-    assert_path_exists @spec.gem_build_complete_path
-    assert_path_exists File.join @spec.extension_dir, 'gem_make.out'
-    assert_path_exists File.join @spec.extension_dir, 'a.rb'
-    refute_path_exists File.join @spec.gem_dir, 'lib', 'a.rb'
-    refute_path_exists File.join @spec.gem_dir, 'lib', 'a', 'b.rb'
+    assert_path_exist @spec.extension_dir
+    assert_path_exist @spec.gem_build_complete_path
+    assert_path_exist File.join @spec.extension_dir, "gem_make.out"
+    assert_path_exist File.join @spec.extension_dir, "a.rb"
+    assert_path_not_exist File.join @spec.gem_dir, "lib", "a.rb"
+    assert_path_not_exist File.join @spec.gem_dir, "lib", "a", "b.rb"
   ensure
     class << Gem
-
       remove_method :install_extension_in_lib
 
       alias install_extension_in_lib orig_install_extension_in_lib
-
     end
   end
 
@@ -192,10 +210,10 @@ install:
       @builder.build_extensions
     end
 
-    assert_equal '', @ui.output
-    assert_equal '', @ui.error
+    assert_equal "", @ui.output
+    assert_equal "", @ui.error
 
-    refute_path_exists File.join @spec.extension_dir, 'gem_make.out'
+    assert_path_not_exist File.join @spec.extension_dir, "gem_make.out"
   end
 
   def test_build_extensions_rebuild_failure
@@ -204,72 +222,61 @@ install:
 
     @spec.extensions << nil
 
-    assert_raises Gem::Ext::BuildError do
+    assert_raise Gem::Ext::BuildError do
       use_ui @ui do
         @builder.build_extensions
       end
     end
 
-    refute_path_exists @spec.gem_build_complete_path
+    assert_path_not_exist @spec.gem_build_complete_path
   end
 
   def test_build_extensions_extconf_bad
     cwd = Dir.pwd
 
-    @spec.extensions << 'extconf.rb'
+    @spec.extensions << "extconf.rb"
 
     FileUtils.mkdir_p @spec.gem_dir
 
-    e = assert_raises Gem::Ext::BuildError do
+    e = assert_raise Gem::Ext::BuildError do
       use_ui @ui do
         @builder.build_extensions
       end
     end
 
     assert_match(/\AERROR: Failed to build gem native extension.$/, e.message)
+    assert_equal "Building native extensions. This could take a while...\n", @ui.output
+    assert_equal "", @ui.error
 
-    assert_equal "Building native extensions. This could take a while...\n",
-                 @ui.output
-    assert_equal '', @ui.error
-
-    gem_make_out = File.join @spec.extension_dir, 'gem_make.out'
-
-    assert_match %r%#{Regexp.escape Gem.ruby}.* extconf\.rb%,
-                 File.read(gem_make_out)
-    assert_match %r%: No such file%,
-                 File.read(gem_make_out)
+    gem_make_out = File.join @spec.extension_dir, "gem_make.out"
+    cmd_make_out = File.read(gem_make_out)
 
-    refute_path_exists @spec.gem_build_complete_path
+    assert_match %r{#{Regexp.escape Gem.ruby} .* extconf\.rb}, cmd_make_out
+    assert_match %r{: No such file}, cmd_make_out
 
-    skip "Gem.ruby is not the name of the binary being run in the end" \
-      unless File.read(gem_make_out).include? "#{Gem.ruby}:"
-
-    assert_match %r%#{Regexp.escape Gem.ruby}: No such file%,
-                 File.read(gem_make_out)
+    assert_path_not_exist @spec.gem_build_complete_path
 
     assert_equal cwd, Dir.pwd
   end
 
   def test_build_extensions_unsupported
     FileUtils.mkdir_p @spec.gem_dir
-    gem_make_out = File.join @spec.extension_dir, 'gem_make.out'
+    gem_make_out = File.join @spec.extension_dir, "gem_make.out"
     @spec.extensions << nil
 
-    e = assert_raises Gem::Ext::BuildError do
+    e = assert_raise Gem::Ext::BuildError do
       use_ui @ui do
         @builder.build_extensions
       end
     end
 
     assert_match(/^\s*No builder for extension ''$/, e.message)
-
-    assert_equal "Building native extensions. This could take a while...\n",
-                 @ui.output
-    assert_equal '', @ui.error
+    assert_equal "Building native extensions. This could take a while...\n", @ui.output
+    assert_equal "", @ui.error
 
     assert_equal "No builder for extension ''\n", File.read(gem_make_out)
 
-    refute_path_exists @spec.gem_build_complete_path
+    assert_path_not_exist @spec.gem_build_complete_path
   ensure
     FileUtils.rm_f gem_make_out
   end
@@ -277,14 +284,14 @@ install:
   def test_build_extensions_with_build_args
     args = ["--aa", "--bb"]
     @builder.build_args = args
-    @spec.extensions << 'extconf.rb'
+    @spec.extensions << "extconf.rb"
 
     FileUtils.mkdir_p @spec.gem_dir
 
     File.open File.join(@spec.gem_dir, "extconf.rb"), "w" do |f|
       f.write <<-'RUBY'
         puts "IN EXTCONF"
-        extconf_args = File.join File.dirname(__FILE__), 'extconf_args'
+        extconf_args = File.join __dir__, 'extconf_args'
         File.open extconf_args, 'w' do |f|
           f.puts ARGV.inspect
         end
@@ -304,18 +311,18 @@ install:
     path = File.join @spec.gem_dir, "extconf_args"
 
     assert_equal args.inspect, File.read(path).strip
-    assert_path_exists @spec.extension_dir
+    assert_path_exist @spec.extension_dir
   end
 
   def test_initialize
-    build_info_dir = File.join @gemhome, 'build_info'
+    build_info_dir = File.join @gemhome, "build_info"
 
     FileUtils.mkdir_p build_info_dir
 
     build_info_file = File.join build_info_dir, "#{@spec.full_name}.info"
 
-    File.open build_info_file, 'w' do |io|
-      io.puts '--with-foo-dir=/nonexistent'
+    File.open build_info_file, "w" do |io|
+      io.puts "--with-foo-dir=/nonexistent"
     end
 
     builder = Gem::Ext::Builder.new @spec
@@ -328,5 +335,4 @@ install:
 
     assert_equal %w[--with-foo-dir=/nonexistent], builder.build_args
   end
-
 end unless Gem.java_platform?
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder.rb
@@ -0,0 +1,178 @@
+# frozen_string_literal: true
+
+require_relative "helper"
+require "rubygems/ext"
+
+class TestGemExtCargoBuilder < Gem::TestCase
+  def setup
+    super
+
+    @rust_envs = {
+      "CARGO_HOME" => ENV.fetch("CARGO_HOME", File.join(@orig_env["HOME"], ".cargo")),
+      "RUSTUP_HOME" => ENV.fetch("RUSTUP_HOME", File.join(@orig_env["HOME"], ".rustup")),
+    }
+  end
+
+  def setup_rust_gem(name)
+    @ext = File.join(@tempdir, "ext")
+    @dest_path = File.join(@tempdir, "prefix")
+    @fixture_dir = Pathname.new(File.expand_path("test_gem_ext_cargo_builder/#{name}/", __dir__))
+
+    FileUtils.mkdir_p @dest_path
+    FileUtils.cp_r(@fixture_dir.to_s, @ext)
+  end
+
+  def test_build_staticlib
+    skip_unsupported_platforms!
+    setup_rust_gem "rust_ruby_example"
+
+    content = @fixture_dir.join("Cargo.toml").read.gsub("cdylib", "staticlib")
+    File.write(File.join(@ext, "Cargo.toml"), content)
+
+    output = []
+
+    Dir.chdir @ext do
+      ENV.update(@rust_envs)
+      spec = Gem::Specification.new "rust_ruby_example", "0.1.0"
+      builder = Gem::Ext::CargoBuilder.new(spec)
+      assert_raise(Gem::Ext::CargoBuilder::DylibNotFoundError) do
+        builder.build nil, @dest_path, output
+      end
+    end
+  end
+
+  def test_build_cdylib
+    skip_unsupported_platforms!
+    setup_rust_gem "rust_ruby_example"
+
+    output = []
+
+    Dir.chdir @ext do
+      ENV.update(@rust_envs)
+      spec = Gem::Specification.new "rust_ruby_example", "0.1.0"
+      builder = Gem::Ext::CargoBuilder.new(spec)
+      builder.build nil, @dest_path, output
+    end
+
+    output = output.join "\n"
+    bundle = File.join(@dest_path, "release/rust_ruby_example.#{RbConfig::CONFIG['DLEXT']}")
+
+    assert_match "Finished release [optimized] target(s)", output
+    assert_ffi_handle bundle, "Init_rust_ruby_example"
+  rescue Exception => e
+    pp output if output
+
+    raise(e)
+  end
+
+  def test_build_dev_profile
+    skip_unsupported_platforms!
+    setup_rust_gem "rust_ruby_example"
+
+    output = []
+
+    Dir.chdir @ext do
+      ENV.update(@rust_envs)
+      spec = Gem::Specification.new "rust_ruby_example", "0.1.0"
+      builder = Gem::Ext::CargoBuilder.new(spec)
+      builder.profile = :dev
+      builder.build nil, @dest_path, output
+    end
+
+    output = output.join "\n"
+    bundle = File.join(@dest_path, "debug/rust_ruby_example.#{RbConfig::CONFIG['DLEXT']}")
+
+    assert_match "Finished dev [unoptimized + debuginfo] target(s)", output
+    assert_ffi_handle bundle, "Init_rust_ruby_example"
+  rescue Exception => e
+    pp output if output
+
+    raise(e)
+  end
+
+  def test_build_fail
+    skip_unsupported_platforms!
+    setup_rust_gem "rust_ruby_example"
+
+    output = []
+
+    FileUtils.rm(File.join(@ext, "src/lib.rs"))
+
+    error = assert_raise(Gem::InstallError) do
+      Dir.chdir @ext do
+        ENV.update(@rust_envs)
+        spec = Gem::Specification.new "rust_ruby_example", "0.1.0"
+        builder = Gem::Ext::CargoBuilder.new(spec)
+        builder.build nil, @dest_path, output
+      end
+    end
+
+    output = output.join "\n"
+
+    assert_match "cargo failed", error.message
+  end
+
+  def test_full_integration
+    skip_unsupported_platforms!
+    setup_rust_gem "rust_ruby_example"
+
+    require "open3"
+
+    Dir.chdir @ext do
+      require "tmpdir"
+
+      env_for_subprocess = @rust_envs.merge("GEM_HOME" => Gem.paths.home)
+      gem = [env_for_subprocess, *ruby_with_rubygems_in_load_path, File.expand_path("../../bin/gem", __dir__)]
+
+      Dir.mktmpdir("rust_ruby_example") do |dir|
+        built_gem = File.expand_path(File.join(dir, "rust_ruby_example.gem"))
+        Open3.capture2e(*gem, "build", "rust_ruby_example.gemspec", "--output", built_gem)
+        Open3.capture2e(*gem, "install", "--verbose", "--local", built_gem, *ARGV)
+
+        stdout_and_stderr_str, status = Open3.capture2e(env_for_subprocess, *ruby_with_rubygems_in_load_path, "-rrust_ruby_example", "-e", "puts 'Result: ' + RustRubyExample.reverse('hello world')")
+        assert status.success?, stdout_and_stderr_str
+        assert_match "Result: #{"hello world".reverse}", stdout_and_stderr_str
+      end
+    end
+  end
+
+  def test_custom_name
+    skip_unsupported_platforms!
+    setup_rust_gem "custom_name"
+
+    Dir.chdir @ext do
+      require "tmpdir"
+
+      env_for_subprocess = @rust_envs.merge("GEM_HOME" => Gem.paths.home)
+      gem = [env_for_subprocess, *ruby_with_rubygems_in_load_path, File.expand_path("../../bin/gem", __dir__)]
+
+      Dir.mktmpdir("custom_name") do |dir|
+        built_gem = File.expand_path(File.join(dir, "custom_name.gem"))
+        Open3.capture2e(*gem, "build", "custom_name.gemspec", "--output", built_gem)
+        Open3.capture2e(*gem, "install", "--verbose", "--local", built_gem, *ARGV)
+      end
+
+      stdout_and_stderr_str, status = Open3.capture2e(env_for_subprocess, *ruby_with_rubygems_in_load_path, "-rcustom_name", "-e", "puts 'Result: ' + CustomName.say_hello")
+
+      assert status.success?, stdout_and_stderr_str
+      assert_match "Result: Hello world!", stdout_and_stderr_str
+    end
+  end
+
+  private
+
+  def skip_unsupported_platforms!
+    pend "jruby not supported" if java_platform?
+    pend "truffleruby not supported (yet)" if RUBY_ENGINE == "truffleruby"
+    pend "mswin not supported (yet)" if /mswin/ =~ RUBY_PLATFORM && ENV.key?("GITHUB_ACTIONS")
+    system(@rust_envs, "cargo", "-V", out: IO::NULL, err: [:child, :out])
+    pend "cargo not present" unless $?.success?
+    pend "ruby.h is not provided by ruby repo" if ruby_repo?
+  end
+
+  def assert_ffi_handle(bundle, name)
+    require "fiddle"
+    dylib_handle = Fiddle.dlopen bundle
+    assert_nothing_raised { dylib_handle[name] }
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder/custom_name/Cargo.lock
@@ -0,0 +1,243 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 3
+
+[[package]]
+name = "aho-corasick"
+version = "0.7.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e37cfd5e7657ada45f742d6e99ca5788580b5c529dc78faf11ece6dc702656f"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "bindgen"
+version = "0.60.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "062dddbc1ba4aca46de6338e2bf87771414c335f7b2f2036e8f3e9befebf88e6"
+dependencies = [
+ "bitflags",
+ "cexpr",
+ "clang-sys",
+ "lazy_static",
+ "lazycell",
+ "peeking_take_while",
+ "proc-macro2",
+ "quote",
+ "regex",
+ "rustc-hash",
+ "shlex",
+]
+
+[[package]]
+name = "bitflags"
+version = "1.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
+
+[[package]]
+name = "cexpr"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
+dependencies = [
+ "nom",
+]
+
+[[package]]
+name = "cfg-if"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
+
+[[package]]
+name = "clang-sys"
+version = "1.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a050e2153c5be08febd6734e29298e844fdb0fa21aeddd63b4eb7baa106c69b"
+dependencies = [
+ "glob",
+ "libc",
+ "libloading",
+]
+
+[[package]]
+name = "custom-name-ext"
+version = "0.1.0"
+dependencies = [
+ "rb-sys",
+]
+
+[[package]]
+name = "glob"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574"
+
+[[package]]
+name = "lazy_static"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
+
+[[package]]
+name = "lazycell"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"
+
+[[package]]
+name = "libc"
+version = "0.2.126"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836"
+
+[[package]]
+name = "libloading"
+version = "0.7.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd"
+dependencies = [
+ "cfg-if",
+ "winapi",
+]
+
+[[package]]
+name = "linkify"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "96dd5884008358112bc66093362197c7248ece00d46624e2cf71e50029f8cff5"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "memchr"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"
+
+[[package]]
+name = "minimal-lexical"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
+
+[[package]]
+name = "nom"
+version = "7.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a8903e5a29a317527874d0402f867152a3d21c908bb0b933e416c65e301d4c36"
+dependencies = [
+ "memchr",
+ "minimal-lexical",
+]
+
+[[package]]
+name = "peeking_take_while"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19b17cddbe7ec3f8bc800887bab5e717348c95ea2ca0b1bf0837fb964dc67099"
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dd96a1e8ed2596c337f8eae5f24924ec83f5ad5ab21ea8e455d3566c69fbcaf7"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3bcdf212e9776fbcb2d23ab029360416bb1706b1aea2d1a5ba002727cbcab804"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "rb-sys"
+version = "0.9.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24b22a374fc2e92eb6f49d7efe4eb7663655c6e9455d9259ed3342cc1599da85"
+dependencies = [
+ "bindgen",
+ "linkify",
+ "rb-sys-build",
+]
+
+[[package]]
+name = "rb-sys-build"
+version = "0.9.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3cd23b6dd929b7d50ccb35a6d3aa77dec364328ab9cb304dd32c629332491671"
+dependencies = [
+ "regex",
+ "shell-words",
+]
+
+[[package]]
+name = "regex"
+version = "1.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d83f127d94bdbcda4c8cc2e50f6f84f4b611f69c902699ca385a39c3a75f9ff1"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-syntax"
+version = "0.6.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "49b3de9ec5dc0a3417da371aab17d729997c15010e7fd24ff707773a33bddb64"
+
+[[package]]
+name = "rustc-hash"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"
+
+[[package]]
+name = "shell-words"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24188a676b6ae68c3b2cb3a01be17fbf7240ce009799bb56d5b1409051e78fde"
+
+[[package]]
+name = "shlex"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "43b2853a4d09f215c24cc5489c992ce46052d359b5109343cbafbf26bc62f8a3"
+
+[[package]]
+name = "unicode-ident"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5bd2fe26506023ed7b5e1e315add59d6f584c621d037f9368fea9cfb988f368c"
+
+[[package]]
+name = "winapi"
+version = "0.3.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
+dependencies = [
+ "winapi-i686-pc-windows-gnu",
+ "winapi-x86_64-pc-windows-gnu",
+]
+
+[[package]]
+name = "winapi-i686-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
+
+[[package]]
+name = "winapi-x86_64-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder/custom_name/Cargo.toml
@@ -0,0 +1,10 @@
+[package]
+name = "custom-name-ext"
+version = "0.1.0"
+edition = "2021"
+
+[lib]
+crate-type = ["cdylib"]
+
+[dependencies]
+rb-sys = { version = "0.9.30", features = ["gem"] }
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder/custom_name/build.rb
@@ -0,0 +1,21 @@
+if ENV["RUBYOPT"] || defined? Gem
+  ENV.delete "RUBYOPT"
+
+  require "rbconfig"
+  cmd = [RbConfig.ruby, "--disable-gems", "build.rb", *ARGV]
+
+  exec(*cmd)
+end
+
+require "tmpdir"
+
+lp = File.expand_path("../../../../lib", __dir__)
+gem = ["ruby", "-I#{lp}", File.expand_path("../../../../bin/gem", __dir__)]
+gemspec = File.expand_path("custom_name.gemspec", __dir__)
+
+Dir.mktmpdir("custom_name") do |dir|
+  built_gem = File.expand_path(File.join(dir, "custom_name.gem"))
+  system(*gem, "build", gemspec, "--output", built_gem)
+  system(*gem, "install", "--verbose", "--local", built_gem, *ARGV)
+  system %q(ruby -rcustom_name -e "puts 'Result: ' + CustomName.say_hello")
+end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder/custom_name/custom_name.gemspec
@@ -0,0 +1,10 @@
+Gem::Specification.new do |s|
+  s.name          = "custom_name"
+  s.version       = "0.1.0"
+  s.summary       = "A Rust extension for Ruby"
+  s.extensions    = ["Cargo.toml"]
+  s.authors       = ["Ian Ker-Seymer"]
+  s.files         = ["Cargo.toml", "Cargo.lock", "src/lib.rs"]
+
+  s.metadata["cargo_crate_name"] = "custom-name-ext"
+end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder/custom_name/src/lib.rs
@@ -0,0 +1,27 @@
+extern crate rb_sys;
+
+use rb_sys::{rb_define_module, rb_define_module_function, rb_utf8_str_new, VALUE};
+use std::ffi::CString;
+
+#[no_mangle]
+unsafe extern "C" fn say_hello(_klass: VALUE) -> VALUE {
+    let cstr = CString::new("Hello world!").unwrap();
+
+    rb_utf8_str_new(cstr.as_ptr(), 12)
+}
+
+#[allow(non_snake_case)]
+#[no_mangle]
+pub extern "C" fn Init_custom_name() {
+    let name = CString::new("CustomName").unwrap();
+    let function_name = CString::new("say_hello").unwrap();
+    // bindgen does not properly detect the arity of the ruby callback function, so we have to transmute
+    let callback = unsafe {
+        std::mem::transmute::<unsafe extern "C" fn(VALUE) -> VALUE, unsafe extern "C" fn() -> VALUE>(
+            say_hello,
+        )
+    };
+    let klass = unsafe { rb_define_module(name.as_ptr()) };
+
+    unsafe { rb_define_module_function(klass, function_name.as_ptr(), Some(callback), 0) }
+}
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder/rust_ruby_example/Cargo.lock
@@ -0,0 +1,243 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 3
+
+[[package]]
+name = "aho-corasick"
+version = "0.7.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e37cfd5e7657ada45f742d6e99ca5788580b5c529dc78faf11ece6dc702656f"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "bindgen"
+version = "0.60.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "062dddbc1ba4aca46de6338e2bf87771414c335f7b2f2036e8f3e9befebf88e6"
+dependencies = [
+ "bitflags",
+ "cexpr",
+ "clang-sys",
+ "lazy_static",
+ "lazycell",
+ "peeking_take_while",
+ "proc-macro2",
+ "quote",
+ "regex",
+ "rustc-hash",
+ "shlex",
+]
+
+[[package]]
+name = "bitflags"
+version = "1.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
+
+[[package]]
+name = "cexpr"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
+dependencies = [
+ "nom",
+]
+
+[[package]]
+name = "cfg-if"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
+
+[[package]]
+name = "clang-sys"
+version = "1.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a050e2153c5be08febd6734e29298e844fdb0fa21aeddd63b4eb7baa106c69b"
+dependencies = [
+ "glob",
+ "libc",
+ "libloading",
+]
+
+[[package]]
+name = "glob"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574"
+
+[[package]]
+name = "lazy_static"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
+
+[[package]]
+name = "lazycell"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"
+
+[[package]]
+name = "libc"
+version = "0.2.126"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836"
+
+[[package]]
+name = "libloading"
+version = "0.7.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd"
+dependencies = [
+ "cfg-if",
+ "winapi",
+]
+
+[[package]]
+name = "linkify"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "96dd5884008358112bc66093362197c7248ece00d46624e2cf71e50029f8cff5"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "memchr"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"
+
+[[package]]
+name = "minimal-lexical"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
+
+[[package]]
+name = "nom"
+version = "7.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a8903e5a29a317527874d0402f867152a3d21c908bb0b933e416c65e301d4c36"
+dependencies = [
+ "memchr",
+ "minimal-lexical",
+]
+
+[[package]]
+name = "peeking_take_while"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19b17cddbe7ec3f8bc800887bab5e717348c95ea2ca0b1bf0837fb964dc67099"
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dd96a1e8ed2596c337f8eae5f24924ec83f5ad5ab21ea8e455d3566c69fbcaf7"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3bcdf212e9776fbcb2d23ab029360416bb1706b1aea2d1a5ba002727cbcab804"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "rb-sys"
+version = "0.9.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24b22a374fc2e92eb6f49d7efe4eb7663655c6e9455d9259ed3342cc1599da85"
+dependencies = [
+ "bindgen",
+ "linkify",
+ "rb-sys-build",
+]
+
+[[package]]
+name = "rb-sys-build"
+version = "0.9.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3cd23b6dd929b7d50ccb35a6d3aa77dec364328ab9cb304dd32c629332491671"
+dependencies = [
+ "regex",
+ "shell-words",
+]
+
+[[package]]
+name = "regex"
+version = "1.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d83f127d94bdbcda4c8cc2e50f6f84f4b611f69c902699ca385a39c3a75f9ff1"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-syntax"
+version = "0.6.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "49b3de9ec5dc0a3417da371aab17d729997c15010e7fd24ff707773a33bddb64"
+
+[[package]]
+name = "rust_ruby_example"
+version = "0.1.0"
+dependencies = [
+ "rb-sys",
+]
+
+[[package]]
+name = "rustc-hash"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"
+
+[[package]]
+name = "shell-words"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24188a676b6ae68c3b2cb3a01be17fbf7240ce009799bb56d5b1409051e78fde"
+
+[[package]]
+name = "shlex"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "43b2853a4d09f215c24cc5489c992ce46052d359b5109343cbafbf26bc62f8a3"
+
+[[package]]
+name = "unicode-ident"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5bd2fe26506023ed7b5e1e315add59d6f584c621d037f9368fea9cfb988f368c"
+
+[[package]]
+name = "winapi"
+version = "0.3.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
+dependencies = [
+ "winapi-i686-pc-windows-gnu",
+ "winapi-x86_64-pc-windows-gnu",
+]
+
+[[package]]
+name = "winapi-i686-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
+
+[[package]]
+name = "winapi-x86_64-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder/rust_ruby_example/Cargo.toml
@@ -0,0 +1,10 @@
+[package]
+name = "rust_ruby_example"
+version = "0.1.0"
+edition = "2021"
+
+[lib]
+crate-type = ["cdylib"]
+
+[dependencies]
+rb-sys = { version = "0.9.30", features = ["gem"] }
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder/rust_ruby_example/build.rb
@@ -0,0 +1,21 @@
+if ENV["RUBYOPT"] || defined? Gem
+  ENV.delete "RUBYOPT"
+
+  require "rbconfig"
+  cmd = [RbConfig.ruby, "--disable-gems", "build.rb", *ARGV]
+
+  exec(*cmd)
+end
+
+require "tmpdir"
+
+lp = File.expand_path("../../../../lib", __dir__)
+gem = ["ruby", "-I#{lp}", File.expand_path("../../../../bin/gem", __dir__)]
+gemspec = File.expand_path("rust_ruby_example.gemspec", __dir__)
+
+Dir.mktmpdir("rust_ruby_example") do |dir|
+  built_gem = File.expand_path(File.join(dir, "rust_ruby_example.gem"))
+  system(*gem, "build", gemspec, "--output", built_gem)
+  system(*gem, "install", "--verbose", "--local", built_gem, *ARGV)
+  system %q(ruby -rrust_ruby_example -e "puts 'Result: ' + RustRubyExample.reverse('hello world')")
+end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder/rust_ruby_example/rust_ruby_example.gemspec
@@ -0,0 +1,8 @@
+Gem::Specification.new do |s|
+  s.name          = "rust_ruby_example"
+  s.version       = "0.1.0"
+  s.summary       = "A Rust extension for Ruby"
+  s.extensions    = ["Cargo.toml"]
+  s.authors       = ["Ian Ker-Seymer"]
+  s.files         = ["Cargo.toml", "Cargo.lock", "src/lib.rs"]
+end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder/rust_ruby_example/src/lib.rs
@@ -0,0 +1,39 @@
+extern crate rb_sys;
+
+use rb_sys::{
+    rb_define_module, rb_define_module_function, rb_string_value_cstr, rb_utf8_str_new, VALUE,
+};
+use std::ffi::{CStr, CString};
+use std::os::raw::{c_char, c_long};
+
+#[inline]
+unsafe fn cstr_to_string(str: *const c_char) -> String {
+    CStr::from_ptr(str).to_string_lossy().into_owned()
+}
+
+#[no_mangle]
+unsafe extern "C" fn pub_reverse(_klass: VALUE, mut input: VALUE) -> VALUE {
+    let ruby_string = cstr_to_string(rb_string_value_cstr(&mut input));
+    let reversed = ruby_string.to_string().chars().rev().collect::<String>();
+    let reversed_cstring = CString::new(reversed).unwrap();
+    let size = ruby_string.len() as c_long;
+
+    rb_utf8_str_new(reversed_cstring.as_ptr(), size)
+}
+
+#[allow(non_snake_case)]
+#[no_mangle]
+pub extern "C" fn Init_rust_ruby_example() {
+    let name = CString::new("RustRubyExample").unwrap();
+    let function_name = CString::new("reverse").unwrap();
+    // bindgen does not properly detect the arity of the ruby callback function, so we have to transmute
+    let callback = unsafe {
+        std::mem::transmute::<
+            unsafe extern "C" fn(VALUE, VALUE) -> VALUE,
+            unsafe extern "C" fn() -> VALUE,
+        >(pub_reverse)
+    };
+    let klass = unsafe { rb_define_module(name.as_ptr()) };
+
+    unsafe { rb_define_module_function(klass, function_name.as_ptr(), Some(callback), 1) }
+}
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder_link_flag_converter.rb
@@ -0,0 +1,33 @@
+# frozen_string_literal: true
+require_relative "helper"
+require "rubygems/ext"
+require "rubygems/ext/cargo_builder/link_flag_converter"
+
+class TestGemExtCargoBuilderLinkFlagConverter < Gem::TestCase
+  CASES = {
+    test_search_path_basic:             ["-L/usr/local/lib", ["-L", "native=/usr/local/lib"]],
+    test_search_path_space:             ["-L /usr/local/lib", ["-L", "native=/usr/local/lib"]],
+    test_search_path_space_in_path:     ["-L/usr/local/my\ lib", ["-L", "native=/usr/local/my\ lib"]],
+    test_simple_lib:                    ["-lfoo", ["-l", "foo"]],
+    test_lib_with_nonascii:             ["-lws2_32", ["-l", "ws2_32"]],
+    test_simple_lib_space:              ["-l foo", ["-l", "foo"]],
+    test_verbose_lib_space:             ["--library=foo", ["-l", "foo"]],
+    test_libstatic_with_colon:          ["-l:libssp.a", ["-l", "static=ssp"]],
+    test_libstatic_with_colon_space:    ["-l :libssp.a", ["-l", "static=ssp"]],
+    test_unconventional_lib_with_colon: ["-l:ssp.a", ["-C", "link_arg=-l:ssp.a"]],
+    test_dylib_with_colon_space:        ["-l :libssp.dylib", ["-l", "dylib=ssp"]],
+    test_so_with_colon_space:           ["-l :libssp.so", ["-l", "dylib=ssp"]],
+    test_dll_with_colon_space:          ["-l :libssp.dll", ["-l", "dylib=ssp"]],
+    test_framework:                     ["-F/some/path", ["-l", "framework=/some/path"]],
+    test_framework_space:               ["-F /some/path", ["-l", "framework=/some/path"]],
+    test_non_lib_dash_l:                ["test_rubygems_20220413-976-lemgf9/prefix", ["-C", "link_arg=test_rubygems_20220413-976-lemgf9/prefix"]],
+  }.freeze
+
+  CASES.each do |test_name, (arg, expected)|
+    raise "duplicate test name" if instance_methods.include?(test_name)
+
+    define_method(test_name) do
+      assert_equal(expected, Gem::Ext::CargoBuilder::LinkFlagConverter.convert(arg))
+    end
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cargo_builder_unit.rb
@@ -0,0 +1,75 @@
+# frozen_string_literal: true
+
+require_relative "helper"
+require "rubygems/ext"
+
+class TestGemExtCargoBuilderUnit < Gem::TestCase
+  def test_cargo_command_passes_args
+    skip_unsupported_platforms!
+    spec = Gem::Specification.new "rust_ruby_example", "0.1.0"
+    builder = Gem::Ext::CargoBuilder.new(spec)
+    command = builder.cargo_command(Dir.pwd, @tempdir, ["--all-features"])
+
+    assert_includes command, "--all-features"
+  end
+
+  def test_cargo_command_locks_in_release_profile
+    skip_unsupported_platforms!
+    spec = Gem::Specification.new "rust_ruby_example", "0.1.0"
+    builder = Gem::Ext::CargoBuilder.new(spec)
+    builder.profile = :release
+    command = builder.cargo_command(Dir.pwd, @tempdir)
+
+    assert_includes command, "--locked"
+  end
+
+  def test_cargo_command_does_not_lock_in_dev_profile
+    skip_unsupported_platforms!
+    spec = Gem::Specification.new "rust_ruby_example", "0.1.0"
+    builder = Gem::Ext::CargoBuilder.new(spec)
+    builder.profile = :dev
+    command = builder.cargo_command(Dir.pwd, @tempdir)
+
+    assert_not_includes command, "--locked"
+  end
+
+  def test_cargo_command_passes_respects_cargo_env_var
+    skip_unsupported_platforms!
+    old_cargo = ENV["CARGO"]
+    ENV["CARGO"] = "mycargo"
+    spec = Gem::Specification.new "rust_ruby_example", "0.1.0"
+    builder = Gem::Ext::CargoBuilder.new(spec)
+    command = builder.cargo_command(Dir.pwd, @tempdir)
+
+    assert_includes command, "mycargo"
+  ensure
+    ENV["CARGO"] = old_cargo
+  end
+
+  def test_build_env_includes_rbconfig
+    skip_unsupported_platforms!
+    spec = Gem::Specification.new "rust_ruby_example", "0.1.0"
+    builder = Gem::Ext::CargoBuilder.new(spec)
+    env = builder.build_env
+
+    assert_equal env.fetch("RBCONFIG_RUBY_SO_NAME"), RbConfig::CONFIG["RUBY_SO_NAME"]
+  end
+
+  def test_cargo_command_passes_respects_cargo_build_target
+    skip_unsupported_platforms!
+    old_cargo = ENV["CARGO_BUILD_TARGET"]
+    ENV["CARGO_BUILD_TARGET"] = "x86_64-unknown-linux-gnu"
+    spec = Gem::Specification.new "rust_ruby_example", "0.1.0"
+    builder = Gem::Ext::CargoBuilder.new(spec)
+    command = builder.cargo_command(Dir.pwd, @tempdir, ["--locked"])
+
+    assert_includes command, "--target"
+    assert_includes command, "x86_64-unknown-linux-gnu"
+  ensure
+    ENV["CARGO_BUILD_TARGET"] = old_cargo
+  end
+
+  def skip_unsupported_platforms!
+    pend "jruby not supported" if java_platform?
+  end
+end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_ext_cmake_builder.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_cmake_builder.rb
@@ -1,90 +1,83 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/ext'
+require_relative "helper"
+require "rubygems/ext"
 
 class TestGemExtCmakeBuilder < Gem::TestCase
-
   def setup
     super
 
     # Details: https://github.com/rubygems/rubygems/issues/1270#issuecomment-177368340
-    skip "CmakeBuilder doesn't work on Windows." if Gem.win_platform?
-
-    skip "CmakeBuilder doesn't work on JRuby." if Gem.java_platform? && ENV["CI"]
+    pend "CmakeBuilder doesn't work on Windows." if Gem.win_platform?
 
-    system('cmake', out: IO::NULL, err: [:child, :out])
+    require "open3"
 
-    skip 'cmake not present' unless $?.success?
+    begin
+      _, status = Open3.capture2e("cmake")
+      pend "cmake not present" unless status.success?
+    rescue Errno::ENOENT
+      pend "cmake not present"
+    end
 
-    @ext = File.join @tempdir, 'ext'
-    @dest_path = File.join @tempdir, 'prefix'
+    @ext = File.join @tempdir, "ext"
+    @dest_path = File.join @tempdir, "prefix"
 
     FileUtils.mkdir_p @ext
     FileUtils.mkdir_p @dest_path
   end
 
   def test_self_build
-    File.open File.join(@ext, 'CMakeLists.txt'), 'w' do |cmakelists|
-      cmakelists.write <<-eo_cmake
+    File.open File.join(@ext, "CMakeLists.txt"), "w" do |cmakelists|
+      cmakelists.write <<-EO_CMAKE
 cmake_minimum_required(VERSION 2.6)
 project(self_build NONE)
 install (FILES test.txt DESTINATION bin)
-      eo_cmake
+      EO_CMAKE
     end
 
-    FileUtils.touch File.join(@ext, 'test.txt')
+    FileUtils.touch File.join(@ext, "test.txt")
 
     output = []
 
-    Dir.chdir @ext do
-      Gem::Ext::CmakeBuilder.build nil, @dest_path, output
-    end
+    Gem::Ext::CmakeBuilder.build nil, @dest_path, output, [], nil, @ext
 
     output = output.join "\n"
 
-    assert_match \
-      %r%^cmake \. -DCMAKE_INSTALL_PREFIX=#{Regexp.escape @dest_path}%, output
-    assert_match %r%#{Regexp.escape @ext}%, output
-    assert_contains_make_command '', output
-    assert_contains_make_command 'install', output
-    assert_match %r%test\.txt%, output
+    assert_match %r{^cmake \. -DCMAKE_INSTALL_PREFIX\\=#{Regexp.escape @dest_path}}, output
+    assert_match %r{#{Regexp.escape @ext}}, output
+    assert_contains_make_command "", output
+    assert_contains_make_command "install", output
+    assert_match %r{test\.txt}, output
   end
 
   def test_self_build_fail
     output = []
 
-    error = assert_raises Gem::InstallError do
-      Dir.chdir @ext do
-        Gem::Ext::CmakeBuilder.build nil, @dest_path, output
-      end
+    error = assert_raise Gem::InstallError do
+      Gem::Ext::CmakeBuilder.build nil, @dest_path, output, [], nil, @ext
     end
 
     output = output.join "\n"
 
     shell_error_msg = %r{(CMake Error: .*)}
-    sh_prefix_cmake = "cmake . -DCMAKE_INSTALL_PREFIX="
 
-    assert_match 'cmake failed', error.message
+    assert_match "cmake failed", error.message
 
-    assert_match %r%^#{sh_prefix_cmake}#{Regexp.escape @dest_path}%, output
-    assert_match %r%#{shell_error_msg}%, output
+    assert_match %r{^cmake . -DCMAKE_INSTALL_PREFIX\\=#{Regexp.escape @dest_path}}, output
+    assert_match %r{#{shell_error_msg}}, output
   end
 
   def test_self_build_has_makefile
-    File.open File.join(@ext, 'Makefile'), 'w' do |makefile|
+    File.open File.join(@ext, "Makefile"), "w" do |makefile|
       makefile.puts "all:\n\t@echo ok\ninstall:\n\t@echo ok"
     end
 
     output = []
 
-    Dir.chdir @ext do
-      Gem::Ext::CmakeBuilder.build nil, @dest_path, output
-    end
+    Gem::Ext::CmakeBuilder.build nil, @dest_path, output, [], nil, @ext
 
     output = output.join "\n"
 
-    assert_contains_make_command '', output
-    assert_contains_make_command 'install', output
+    assert_contains_make_command "", output
+    assert_contains_make_command "install", output
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_ext_configure_builder.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_configure_builder.rb
@@ -1,95 +1,79 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/ext'
+require_relative "helper"
+require "rubygems/ext"
 
 class TestGemExtConfigureBuilder < Gem::TestCase
-
   def setup
     super
 
     @makefile_body =
       "clean:\n\t@echo ok\nall:\n\t@echo ok\ninstall:\n\t@echo ok"
 
-    @ext = File.join @tempdir, 'ext'
-    @dest_path = File.join @tempdir, 'prefix'
+    @ext = File.join @tempdir, "ext"
+    @dest_path = File.join @tempdir, "prefix"
 
     FileUtils.mkdir_p @ext
     FileUtils.mkdir_p @dest_path
   end
 
   def test_self_build
-    if java_platform? && ENV["CI"]
-      skip("failing on jruby")
-    end
+    pend("test_self_build skipped on MS Windows (VC++)") if vc_windows?
 
-    skip("test_self_build skipped on MS Windows (VC++)") if vc_windows?
-
-    File.open File.join(@ext, './configure'), 'w' do |configure|
+    File.open File.join(@ext, "./configure"), "w" do |configure|
       configure.puts "#!/bin/sh\necho \"#{@makefile_body}\" > Makefile"
     end
 
     output = []
 
-    Dir.chdir @ext do
-      Gem::Ext::ConfigureBuilder.build nil, @dest_path, output
-    end
+    Gem::Ext::ConfigureBuilder.build nil, @dest_path, output, [], nil, @ext
 
     assert_match(/^current directory:/, output.shift)
-    assert_equal "sh ./configure --prefix=#{@dest_path}", output.shift
+    assert_equal "sh ./configure --prefix\\=#{@dest_path}", output.shift
     assert_equal "", output.shift
     assert_match(/^current directory:/, output.shift)
-    assert_contains_make_command 'clean', output.shift
+    assert_contains_make_command "clean", output.shift
     assert_match(/^ok$/m, output.shift)
     assert_match(/^current directory:/, output.shift)
-    assert_contains_make_command '', output.shift
+    assert_contains_make_command "", output.shift
     assert_match(/^ok$/m, output.shift)
     assert_match(/^current directory:/, output.shift)
-    assert_contains_make_command 'install', output.shift
+    assert_contains_make_command "install", output.shift
     assert_match(/^ok$/m, output.shift)
   end
 
   def test_self_build_fail
-    if java_platform? && ENV["CI"]
-      skip("failing on jruby")
-    end
-
-    skip("test_self_build_fail skipped on MS Windows (VC++)") if vc_windows?
+    pend("test_self_build_fail skipped on MS Windows (VC++)") if vc_windows?
     output = []
 
-    error = assert_raises Gem::InstallError do
-      Dir.chdir @ext do
-        Gem::Ext::ConfigureBuilder.build nil, @dest_path, output
-      end
+    error = assert_raise Gem::InstallError do
+      Gem::Ext::ConfigureBuilder.build nil, @dest_path, output, [], nil, @ext
     end
 
     shell_error_msg = %r{(\./configure: .*)|((?:[Cc]an't|cannot) open '?\./configure'?(?:: No such file or directory)?)}
-    sh_prefix_configure = "sh ./configure --prefix="
+    sh_prefix_configure = "sh ./configure --prefix\\="
 
-    assert_match 'configure failed', error.message
+    assert_match "configure failed", error.message
 
     assert_match(/^current directory:/, output.shift)
     assert_equal "#{sh_prefix_configure}#{@dest_path}", output.shift
-    assert_match %r(#{shell_error_msg}), output.shift
+    assert_match %r{#{shell_error_msg}}, output.shift
     assert_equal true, output.empty?
   end
 
   def test_self_build_has_makefile
     if vc_windows? && !nmake_found?
-      skip("test_self_build_has_makefile skipped - nmake not found")
+      pend("test_self_build_has_makefile skipped - nmake not found")
     end
 
-    File.open File.join(@ext, 'Makefile'), 'w' do |makefile|
+    File.open File.join(@ext, "Makefile"), "w" do |makefile|
       makefile.puts @makefile_body
     end
 
     output = []
-    Dir.chdir @ext do
-      Gem::Ext::ConfigureBuilder.build nil, @dest_path, output
-    end
+    Gem::Ext::ConfigureBuilder.build nil, @dest_path, output, [], nil, @ext
 
-    assert_contains_make_command 'clean', output[1]
-    assert_contains_make_command '', output[4]
-    assert_contains_make_command 'install', output[7]
+    assert_contains_make_command "clean", output[1]
+    assert_contains_make_command "", output[4]
+    assert_contains_make_command "install", output[7]
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_ext_ext_conf_builder.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_ext_conf_builder.rb
@@ -1,16 +1,14 @@
-# coding: UTF-8
 # frozen_string_literal: true
 
-require 'rubygems/test_case'
-require 'rubygems/ext'
+require_relative "helper"
+require "rubygems/ext"
 
 class TestGemExtExtConfBuilder < Gem::TestCase
-
   def setup
     super
 
-    @ext = File.join @tempdir, 'ext'
-    @dest_path = File.join @tempdir, 'prefix'
+    @ext = File.join @tempdir, "ext"
+    @dest_path = File.join @tempdir, "prefix"
 
     FileUtils.mkdir_p @ext
     FileUtils.mkdir_p @dest_path
@@ -18,94 +16,91 @@ class TestGemExtExtConfBuilder < Gem::Te
 
   def test_class_build
     if java_platform?
-      skip("failing on jruby")
+      pend("failing on jruby")
     end
 
     if vc_windows? && !nmake_found?
-      skip("test_class_build skipped - nmake not found")
+      pend("test_class_build skipped - nmake not found")
     end
 
-    File.open File.join(@ext, 'extconf.rb'), 'w' do |extconf|
+    File.open File.join(@ext, "extconf.rb"), "w" do |extconf|
       extconf.puts "require 'mkmf'\ncreate_makefile 'foo'"
     end
 
     output = []
 
-    Dir.chdir @ext do
-      result =
-        Gem::Ext::ExtConfBuilder.build 'extconf.rb', @dest_path, output
+    result = Gem::Ext::ExtConfBuilder.build "extconf.rb", @dest_path, output, [], nil, @ext
 
-      assert_same result, output
-    end
+    assert_same result, output
 
     assert_match(/^current directory:/, output[0])
     assert_match(/^#{Gem.ruby}.* extconf.rb/, output[1])
     assert_equal "creating Makefile\n", output[2]
     assert_match(/^current directory:/, output[3])
-    assert_contains_make_command 'clean', output[4]
-    assert_contains_make_command '', output[7]
-    assert_contains_make_command 'install', output[10]
-    assert_empty Dir.glob(File.join(@ext, 'siteconf*.rb'))
+    assert_contains_make_command "clean", output[4]
+    assert_contains_make_command "", output[7]
+    assert_contains_make_command "install", output[10]
+    assert_empty Dir.glob(File.join(@ext, "siteconf*.rb"))
+    assert_empty Dir.glob(File.join(@ext, ".gem.*"))
   end
 
   def test_class_build_rbconfig_make_prog
     if java_platform?
-      skip("failing on jruby")
+      pend("failing on jruby")
     end
 
     configure_args do
-
-      File.open File.join(@ext, 'extconf.rb'), 'w' do |extconf|
+      File.open File.join(@ext, "extconf.rb"), "w" do |extconf|
         extconf.puts "require 'mkmf'\ncreate_makefile 'foo'"
       end
 
       output = []
 
-      Dir.chdir @ext do
-        Gem::Ext::ExtConfBuilder.build 'extconf.rb', @dest_path, output
-      end
+      Gem::Ext::ExtConfBuilder.build "extconf.rb", @dest_path, output, [], nil, @ext
 
       assert_equal "creating Makefile\n", output[2]
-      assert_contains_make_command 'clean', output[4]
-      assert_contains_make_command '', output[7]
-      assert_contains_make_command 'install', output[10]
+      assert_contains_make_command "clean", output[4]
+      assert_contains_make_command "", output[7]
+      assert_contains_make_command "install", output[10]
     end
   end
 
-  def test_class_build_env_make
-    env_make = ENV.delete 'MAKE'
-    ENV['MAKE'] = 'anothermake'
+  def test_class_build_env_MAKE
+    env_make = ENV.delete "make"
+    ENV["make"] = nil
+
+    env_MAKE = ENV.delete "MAKE"
+    ENV["MAKE"] = "anothermake"
 
     if java_platform?
-      skip("failing on jruby")
+      pend("failing on jruby")
     end
 
-    configure_args '' do
-      File.open File.join(@ext, 'extconf.rb'), 'w' do |extconf|
+    configure_args "" do
+      File.open File.join(@ext, "extconf.rb"), "w" do |extconf|
         extconf.puts "require 'mkmf'\ncreate_makefile 'foo'"
       end
 
       output = []
 
-      assert_raises Gem::InstallError do
-        Dir.chdir @ext do
-          Gem::Ext::ExtConfBuilder.build 'extconf.rb', @dest_path, output
-        end
+      assert_raise Gem::InstallError do
+        Gem::Ext::ExtConfBuilder.build "extconf.rb", @dest_path, output, [], nil, @ext
       end
 
       assert_equal "creating Makefile\n",   output[2]
-      assert_contains_make_command 'clean', output[4]
+      assert_contains_make_command "clean", output[4]
     end
   ensure
-    ENV['MAKE'] = env_make
+    ENV["MAKE"] = env_MAKE
+    ENV["make"] = env_make
   end
 
   def test_class_build_extconf_fail
     if vc_windows? && !nmake_found?
-      skip("test_class_build_extconf_fail skipped - nmake not found")
+      pend("test_class_build_extconf_fail skipped - nmake not found")
     end
 
-    File.open File.join(@ext, 'extconf.rb'), 'w' do |extconf|
+    File.open File.join(@ext, "extconf.rb"), "w" do |extconf|
       extconf.puts "require 'mkmf'"
       extconf.puts "have_library 'nonexistent' or abort 'need libnonexistent'"
       extconf.puts "create_makefile 'foo'"
@@ -113,27 +108,25 @@ class TestGemExtExtConfBuilder < Gem::Te
 
     output = []
 
-    error = assert_raises Gem::InstallError do
-      Dir.chdir @ext do
-        Gem::Ext::ExtConfBuilder.build 'extconf.rb', @dest_path, output
-      end
+    error = assert_raise Gem::InstallError do
+      Gem::Ext::ExtConfBuilder.build "extconf.rb", @dest_path, output, [], nil, @ext
     end
 
-    assert_equal 'extconf failed, exit code 1', error.message
+    assert_equal "extconf failed, exit code 1", error.message
 
     assert_match(/^#{Gem.ruby}.* extconf.rb/, output[1])
-    assert_match(File.join(@dest_path, 'mkmf.log'), output[4])
+    assert_match(File.join(@dest_path, "mkmf.log"), output[4])
     assert_includes(output, "To see why this extension failed to compile, please check the mkmf.log which can be found here:\n")
 
-    assert_path_exists File.join @dest_path, 'mkmf.log'
+    assert_path_exist File.join @dest_path, "mkmf.log"
   end
 
   def test_class_build_extconf_success_without_warning
     if vc_windows? && !nmake_found?
-      skip("test_class_build_extconf_fail skipped - nmake not found")
+      pend("test_class_build_extconf_fail skipped - nmake not found")
     end
 
-    File.open File.join(@ext, 'extconf.rb'), 'w' do |extconf|
+    File.open File.join(@ext, "extconf.rb"), "w" do |extconf|
       extconf.puts "require 'mkmf'"
       extconf.puts "File.open('mkmf.log', 'w'){|f| f.write('a')}"
       extconf.puts "create_makefile 'foo'"
@@ -141,21 +134,19 @@ class TestGemExtExtConfBuilder < Gem::Te
 
     output = []
 
-    Dir.chdir @ext do
-      Gem::Ext::ExtConfBuilder.build 'extconf.rb', @dest_path, output
-    end
+    Gem::Ext::ExtConfBuilder.build "extconf.rb", @dest_path, output, [], nil, @ext
 
     refute_includes(output, "To see why this extension failed to compile, please check the mkmf.log which can be found here:\n")
 
-    assert_path_exists File.join @dest_path, 'mkmf.log'
+    assert_path_exist File.join @dest_path, "mkmf.log"
   end
 
   def test_class_build_unconventional
     if vc_windows? && !nmake_found?
-      skip("test_class_build skipped - nmake not found")
+      pend("test_class_build skipped - nmake not found")
     end
 
-    File.open File.join(@ext, 'extconf.rb'), 'w' do |extconf|
+    File.open File.join(@ext, "extconf.rb"), "w" do |extconf|
       extconf.puts <<-'EXTCONF'
 include RbConfig
 
@@ -183,24 +174,22 @@ end
 
     output = []
 
-    Dir.chdir @ext do
-      Gem::Ext::ExtConfBuilder.build 'extconf.rb', @dest_path, output
-    end
+    Gem::Ext::ExtConfBuilder.build "extconf.rb", @dest_path, output, [], nil, @ext
 
-    assert_contains_make_command 'clean', output[4]
-    assert_contains_make_command '', output[7]
-    assert_contains_make_command 'install', output[10]
-    assert_empty Dir.glob(File.join(@ext, 'siteconf*.rb'))
+    assert_contains_make_command "clean", output[4]
+    assert_contains_make_command "", output[7]
+    assert_contains_make_command "install", output[10]
+    assert_empty Dir.glob(File.join(@ext, "siteconf*.rb"))
   end
 
   def test_class_make
     if vc_windows? && !nmake_found?
-      skip("test_class_make skipped - nmake not found")
+      pend("test_class_make skipped - nmake not found")
     end
 
     output = []
-    makefile_path = File.join(@ext, 'Makefile')
-    File.open makefile_path, 'w' do |makefile|
+    makefile_path = File.join(@ext, "Makefile")
+    File.open makefile_path, "w" do |makefile|
       makefile.puts "# "
       makefile.puts "RUBYARCHDIR = $(foo)$(target_prefix)"
       makefile.puts "RUBYLIBDIR = $(bar)$(target_prefix)"
@@ -209,37 +198,32 @@ end
       makefile.puts "install:"
     end
 
-    Dir.chdir @ext do
-      Gem::Ext::ExtConfBuilder.make @ext, output
-    end
+    Gem::Ext::ExtConfBuilder.make @ext, output, @ext
 
-    assert_contains_make_command 'clean', output[1]
-    assert_contains_make_command '', output[4]
-    assert_contains_make_command 'install', output[7]
+    assert_contains_make_command "clean", output[1]
+    assert_contains_make_command "", output[4]
+    assert_contains_make_command "install", output[7]
   end
 
   def test_class_make_no_Makefile
-    error = assert_raises Gem::InstallError do
-      Dir.chdir @ext do
-        Gem::Ext::ExtConfBuilder.make @ext, ['output']
-      end
+    error = assert_raise Gem::InstallError do
+      Gem::Ext::ExtConfBuilder.make @ext, ["output"], @ext
     end
 
-    assert_equal 'Makefile not found', error.message
+    assert_equal "Makefile not found", error.message
   end
 
   def configure_args(args = nil)
-    configure_args = RbConfig::CONFIG['configure_args']
-    RbConfig::CONFIG['configure_args'] = args if args
+    configure_args = RbConfig::CONFIG["configure_args"]
+    RbConfig::CONFIG["configure_args"] = args if args
 
     yield
 
   ensure
     if configure_args
-      RbConfig::CONFIG['configure_args'] = configure_args
+      RbConfig::CONFIG["configure_args"] = configure_args
     else
-      RbConfig::CONFIG.delete 'configure_args'
+      RbConfig::CONFIG.delete "configure_args"
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_ext_rake_builder.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_ext_rake_builder.rb
@@ -1,33 +1,30 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/ext'
+require_relative "helper"
+require "rubygems/ext"
 
 class TestGemExtRakeBuilder < Gem::TestCase
-
   def setup
     super
 
-    @ext = File.join @tempdir, 'ext'
-    @dest_path = File.join @tempdir, 'prefix'
+    @ext = File.join @tempdir, "ext"
+    @dest_path = File.join @tempdir, "prefix"
 
     FileUtils.mkdir_p @ext
     FileUtils.mkdir_p @dest_path
   end
 
   def test_class_build
-    create_temp_mkrf_file('task :default')
+    create_temp_mkrf_file("task :default")
     output = []
 
     build_rake_in do |rake|
-      Dir.chdir @ext do
-        Gem::Ext::RakeBuilder.build 'mkrf_conf.rb', @dest_path, output
-      end
+      Gem::Ext::RakeBuilder.build "mkrf_conf.rb", @dest_path, output, [], nil, @ext
 
       output = output.join "\n"
 
-      refute_match %r%^rake failed:%, output
-      assert_match %r%^#{Regexp.escape @@ruby} mkrf_conf\.rb%, output
-      assert_match %r%^#{Regexp.escape rake} RUBYARCHDIR\\=#{Regexp.escape @dest_path} RUBYLIBDIR\\=#{Regexp.escape @dest_path}%, output
+      refute_match %r{^rake failed:}, output
+      assert_match %r{^#{Regexp.escape Gem.ruby} mkrf_conf\.rb}, output
+      assert_match %r{^#{Regexp.escape rake} RUBYARCHDIR\\=#{Regexp.escape @dest_path} RUBYLIBDIR\\=#{Regexp.escape @dest_path}}, output
     end
   end
 
@@ -35,35 +32,58 @@ class TestGemExtRakeBuilder < Gem::TestC
   #
   # It should not fail with a non-empty args list either
   def test_class_build_with_args
-    create_temp_mkrf_file('task :default')
+    create_temp_mkrf_file("task :default")
     output = []
 
     build_rake_in do |rake|
-      Dir.chdir @ext do
-        non_empty_args_list = ['']
-        Gem::Ext::RakeBuilder.build 'mkrf_conf.rb', @dest_path, output, non_empty_args_list
-      end
+      non_empty_args_list = [""]
+      Gem::Ext::RakeBuilder.build "mkrf_conf.rb", @dest_path, output, non_empty_args_list, nil, @ext
 
       output = output.join "\n"
 
-      refute_match %r%^rake failed:%, output
-      assert_match %r%^#{Regexp.escape @@ruby} mkrf_conf\.rb%, output
-      assert_match %r%^#{Regexp.escape rake} RUBYARCHDIR\\=#{Regexp.escape @dest_path} RUBYLIBDIR\\=#{Regexp.escape @dest_path}%, output
+      refute_match %r{^rake failed:}, output
+      assert_match %r{^#{Regexp.escape Gem.ruby} mkrf_conf\.rb}, output
+      assert_match %r{^#{Regexp.escape rake} RUBYARCHDIR\\=#{Regexp.escape @dest_path} RUBYLIBDIR\\=#{Regexp.escape @dest_path}}, output
     end
   end
 
+  def test_class_no_openssl_override
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
+
+    create_temp_mkrf_file("task :default")
+
+    rake = util_spec "rake" do |s|
+      s.executables = %w[rake]
+      s.files = %w[bin/rake]
+    end
+
+    output = []
+
+    write_file File.join(@tempdir, "bin", "rake") do |fp|
+      fp.puts "#!/usr/bin/ruby"
+      fp.puts "require 'openssl'; puts OpenSSL"
+    end
+
+    install_gem rake
+
+    Gem::Ext::RakeBuilder.build "mkrf_conf.rb", @dest_path, output, [""], nil, @ext
+
+    output = output.join "\n"
+
+    assert_match "OpenSSL", output
+    assert_match %r{^#{Regexp.escape Gem.ruby} mkrf_conf\.rb}, output
+  end
+
   def test_class_build_no_mkrf_passes_args
     output = []
 
     build_rake_in do |rake|
-      Dir.chdir @ext do
-        Gem::Ext::RakeBuilder.build "ext/Rakefile", @dest_path, output, ["test1", "test2"]
-      end
+      Gem::Ext::RakeBuilder.build "ext/Rakefile", @dest_path, output, ["test1", "test2"], nil, @ext
 
       output = output.join "\n"
 
-      refute_match %r%^rake failed:%, output
-      assert_match %r%^#{Regexp.escape rake} RUBYARCHDIR\\=#{Regexp.escape @dest_path} RUBYLIBDIR\\=#{Regexp.escape @dest_path} test1 test2%, output
+      refute_match %r{^rake failed:}, output
+      assert_match %r{^#{Regexp.escape rake} RUBYARCHDIR\\=#{Regexp.escape @dest_path} RUBYLIBDIR\\=#{Regexp.escape @dest_path} test1 test2}, output
     end
   end
 
@@ -72,18 +92,16 @@ class TestGemExtRakeBuilder < Gem::TestC
     output = []
 
     build_rake_in(false) do |rake|
-      error = assert_raises Gem::InstallError do
-        Dir.chdir @ext do
-          Gem::Ext::RakeBuilder.build "mkrf_conf.rb", @dest_path, output
-        end
+      error = assert_raise Gem::InstallError do
+        Gem::Ext::RakeBuilder.build "mkrf_conf.rb", @dest_path, output, [], nil, @ext
       end
 
-      assert_match %r%^rake failed%, error.message
+      assert_match %r{^rake failed}, error.message
     end
   end
 
   def create_temp_mkrf_file(rakefile_content)
-    File.open File.join(@ext, 'mkrf_conf.rb'), 'w' do |mkrf_conf|
+    File.open File.join(@ext, "mkrf_conf.rb"), "w" do |mkrf_conf|
       mkrf_conf.puts <<-EO_MKRF
         File.open("Rakefile","w") do |f|
           f.puts "#{rakefile_content}"
@@ -91,5 +109,4 @@ class TestGemExtRakeBuilder < Gem::TestC
       EO_MKRF
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_gem_runner.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_gem_runner.rb
@@ -1,15 +1,16 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemGemRunner < Gem::TestCase
-
   def setup
     super
 
-    require 'rubygems/command'
+    require "rubygems/command"
     @orig_args = Gem::Command.build_args
+    @orig_specific_extra_args = Gem::Command.specific_extra_args_hash.dup
+    @orig_extra_args = Gem::Command.extra_args.dup
 
-    require 'rubygems/gem_runner'
+    require "rubygems/gem_runner"
     @runner = Gem::GemRunner.new
   end
 
@@ -17,20 +18,22 @@ class TestGemGemRunner < Gem::TestCase
     super
 
     Gem::Command.build_args = @orig_args
+    Gem::Command.specific_extra_args_hash = @orig_specific_extra_args
+    Gem::Command.extra_args = @orig_extra_args
   end
 
   def test_do_configuration
     Gem.clear_paths
 
-    temp_conf = File.join @tempdir, '.gemrc'
+    temp_conf = File.join @tempdir, ".gemrc"
 
-    other_gem_path = File.join @tempdir, 'other_gem_path'
-    other_gem_home = File.join @tempdir, 'other_gem_home'
+    other_gem_path = File.join @tempdir, "other_gem_path"
+    other_gem_home = File.join @tempdir, "other_gem_home"
 
     Gem.ensure_gem_subdirectories other_gem_path
     Gem.ensure_gem_subdirectories other_gem_home
 
-    File.open temp_conf, 'w' do |fp|
+    File.open temp_conf, "w" do |fp|
       fp.puts "gem: --commands"
       fp.puts "gemhome: #{other_gem_home}"
       fp.puts "gempath:"
@@ -67,4 +70,44 @@ class TestGemGemRunner < Gem::TestCase
     assert_equal %w[--foo], args
   end
 
+  def test_query_is_deprecated
+    args = %w[query]
+
+    use_ui @ui do
+      @runner.run(args)
+    end
+
+    assert_match(/WARNING:  query command is deprecated. It will be removed in Rubygems [0-9]+/, @ui.error)
+    assert_match(/WARNING:  It is recommended that you use `gem search` or `gem list` instead/, @ui.error)
+  end
+
+  def test_info_succeeds
+    args = %w[info]
+
+    use_ui @ui do
+      @runner.run(args)
+    end
+
+    assert_empty @ui.error
+  end
+
+  def test_list_succeeds
+    args = %w[list]
+
+    use_ui @ui do
+      @runner.run(args)
+    end
+
+    assert_empty @ui.error
+  end
+
+  def test_search_succeeds
+    args = %w[search]
+
+    use_ui @ui do
+      @runner.run(args)
+    end
+
+    assert_empty @ui.error
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_gemcutter_utilities.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_gemcutter_utilities.rb
@@ -1,39 +1,43 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems'
-require 'rubygems/command'
-require 'rubygems/gemcutter_utilities'
+require_relative "helper"
+require "rubygems"
+require "rubygems/command"
+require "rubygems/gemcutter_utilities"
 
 class TestGemGemcutterUtilities < Gem::TestCase
-
   def setup
     super
+
+    credential_setup
+
     # below needed for random testing, class property
     Gem.configuration.disable_default_gem_server = nil
 
-    ENV['RUBYGEMS_HOST'] = nil
+    ENV["RUBYGEMS_HOST"] = nil
+    ENV["GEM_HOST_OTP_CODE"] = nil
     Gem.configuration.rubygems_api_key = nil
 
-    @cmd = Gem::Command.new '', 'summary'
+    @cmd = Gem::Command.new "", "summary"
     @cmd.extend Gem::GemcutterUtilities
   end
 
   def teardown
-    ENV['RUBYGEMS_HOST'] = nil
+    ENV["RUBYGEMS_HOST"] = nil
+    ENV["GEM_HOST_OTP_CODE"] = nil
     Gem.configuration.rubygems_api_key = nil
 
+    credential_teardown
+
     super
   end
 
   def test_alternate_key_alternate_host
     keys = {
-      :rubygems_api_key => 'KEY',
-      "http://rubygems.engineyard.com" => "EYKEY"
+      :rubygems_api_key => "KEY",
+      "http://rubygems.engineyard.com" => "EYKEY",
     }
 
-    FileUtils.mkdir_p File.dirname Gem.configuration.credentials_path
-
-    File.open Gem.configuration.credentials_path, 'w' do |f|
+    File.open Gem.configuration.credentials_path, "w" do |f|
       f.write keys.to_yaml
     end
 
@@ -41,27 +45,25 @@ class TestGemGemcutterUtilities < Gem::T
 
     Gem.configuration.load_api_keys
 
-    assert_equal 'EYKEY', @cmd.api_key
+    assert_equal "EYKEY", @cmd.api_key
   end
 
   def test_api_key
-    keys = { :rubygems_api_key => 'KEY' }
-    FileUtils.mkdir_p File.dirname Gem.configuration.credentials_path
+    keys = { :rubygems_api_key => "KEY" }
 
-    File.open Gem.configuration.credentials_path, 'w' do |f|
+    File.open Gem.configuration.credentials_path, "w" do |f|
       f.write keys.to_yaml
     end
 
     Gem.configuration.load_api_keys
 
-    assert_equal 'KEY', @cmd.api_key
+    assert_equal "KEY", @cmd.api_key
   end
 
   def test_api_key_override
-    keys = { :rubygems_api_key => 'KEY', :other => 'OTHER' }
-    FileUtils.mkdir_p File.dirname Gem.configuration.credentials_path
+    keys = { :rubygems_api_key => "KEY", :other => "OTHER" }
 
-    File.open Gem.configuration.credentials_path, 'w' do |f|
+    File.open Gem.configuration.credentials_path, "w" do |f|
       f.write keys.to_yaml
     end
 
@@ -70,166 +72,177 @@ class TestGemGemcutterUtilities < Gem::T
     @cmd.add_key_option
     @cmd.handle_options %w[--key other]
 
-    assert_equal 'OTHER', @cmd.api_key
+    assert_equal "OTHER", @cmd.api_key
   end
 
   def test_host
-    assert_equal 'https://rubygems.org', @cmd.host
+    assert_equal "https://rubygems.org", @cmd.host
   end
 
   def test_host_RUBYGEMS_HOST
-    ENV['RUBYGEMS_HOST'] = 'https://other.example'
+    ENV["RUBYGEMS_HOST"] = "https://other.example"
 
-    assert_equal 'https://other.example', @cmd.host
+    assert_equal "https://other.example", @cmd.host
   end
 
   def test_host_RUBYGEMS_HOST_empty
-    ENV['RUBYGEMS_HOST'] = ''
+    ENV["RUBYGEMS_HOST"] = ""
 
-    assert_equal 'https://rubygems.org', @cmd.host
+    assert_equal "https://rubygems.org", @cmd.host
   end
 
   def test_sign_in
-    api_key = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
-    util_sign_in [api_key, 200, 'OK']
+    api_key = "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
+    util_sign_in [api_key, 200, "OK"]
 
     assert_match %r{Enter your RubyGems.org credentials.}, @sign_in_ui.output
     assert @fetcher.last_request["authorization"]
     assert_match %r{Signed in.}, @sign_in_ui.output
 
-    credentials = YAML.load_file Gem.configuration.credentials_path
+    credentials = load_yaml_file Gem.configuration.credentials_path
     assert_equal api_key, credentials[:rubygems_api_key]
   end
 
   def test_sign_in_with_host
-    api_key = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
+    api_key = "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
 
-    util_sign_in [api_key, 200, 'OK'], 'http://example.com', ['http://example.com']
+    util_sign_in [api_key, 200, "OK"], "http://example.com", ["http://example.com"]
 
     assert_match "Enter your http://example.com credentials.",
                  @sign_in_ui.output
     assert @fetcher.last_request["authorization"]
     assert_match %r{Signed in.}, @sign_in_ui.output
 
-    credentials = YAML.load_file Gem.configuration.credentials_path
-    assert_equal api_key, credentials['http://example.com']
+    credentials = load_yaml_file Gem.configuration.credentials_path
+    assert_equal api_key, credentials["http://example.com"]
   end
 
   def test_sign_in_with_host_nil
-    api_key = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
+    api_key = "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
 
-    util_sign_in [api_key, 200, 'OK'], nil, [nil]
+    util_sign_in [api_key, 200, "OK"], nil, [nil]
 
     assert_match "Enter your RubyGems.org credentials.",
                  @sign_in_ui.output
     assert @fetcher.last_request["authorization"]
     assert_match %r{Signed in.}, @sign_in_ui.output
 
-    credentials = YAML.load_file Gem.configuration.credentials_path
+    credentials = load_yaml_file Gem.configuration.credentials_path
     assert_equal api_key, credentials[:rubygems_api_key]
   end
 
   def test_sign_in_with_host_ENV
-    api_key = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
-    util_sign_in [api_key, 200, 'OK'], 'http://example.com'
+    api_key = "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
+    util_sign_in [api_key, 200, "OK"], "http://example.com"
 
     assert_match "Enter your http://example.com credentials.",
                  @sign_in_ui.output
     assert @fetcher.last_request["authorization"]
     assert_match %r{Signed in.}, @sign_in_ui.output
 
-    credentials = YAML.load_file Gem.configuration.credentials_path
-    assert_equal api_key, credentials['http://example.com']
+    credentials = load_yaml_file Gem.configuration.credentials_path
+    assert_equal api_key, credentials["http://example.com"]
   end
 
   def test_sign_in_skips_with_existing_credentials
-    api_key = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
+    api_key = "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
     Gem.configuration.rubygems_api_key = api_key
 
-    util_sign_in [api_key, 200, 'OK']
+    util_sign_in [api_key, 200, "OK"]
 
     assert_equal "", @sign_in_ui.output
   end
 
   def test_sign_in_skips_with_key_override
-    api_key = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
-    Gem.configuration.api_keys[:KEY] = 'other'
+    api_key = "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
+    Gem.configuration.api_keys[:KEY] = "other"
     @cmd.options[:key] = :KEY
-    util_sign_in [api_key, 200, 'OK']
+    util_sign_in [api_key, 200, "OK"]
 
     assert_equal "", @sign_in_ui.output
   end
 
   def test_sign_in_with_other_credentials_doesnt_overwrite_other_keys
-    api_key       = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
-    other_api_key = 'f46dbb18bb6a9c97cdc61b5b85c186a17403cdcbf'
+    api_key       = "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
+    other_api_key = "f46dbb18bb6a9c97cdc61b5b85c186a17403cdcbf"
 
-    FileUtils.mkdir_p File.dirname(Gem.configuration.credentials_path)
-    File.open Gem.configuration.credentials_path, 'w' do |f|
+    File.open Gem.configuration.credentials_path, "w" do |f|
       f.write Hash[:other_api_key, other_api_key].to_yaml
     end
-    util_sign_in [api_key, 200, 'OK']
+    util_sign_in [api_key, 200, "OK"]
 
     assert_match %r{Enter your RubyGems.org credentials.}, @sign_in_ui.output
     assert_match %r{Signed in.}, @sign_in_ui.output
 
-    credentials = YAML.load_file Gem.configuration.credentials_path
+    credentials = load_yaml_file Gem.configuration.credentials_path
     assert_equal api_key, credentials[:rubygems_api_key]
     assert_equal other_api_key, credentials[:other_api_key]
   end
 
   def test_sign_in_with_bad_credentials
-    assert_raises Gem::MockGemUi::TermError do
-      util_sign_in ['Access Denied.', 403, 'Forbidden']
+    assert_raise Gem::MockGemUi::TermError do
+      util_sign_in ["Access Denied.", 403, "Forbidden"]
     end
 
     assert_match %r{Enter your RubyGems.org credentials.}, @sign_in_ui.output
     assert_match %r{Access Denied.}, @sign_in_ui.output
   end
 
+  def test_signin_with_env_otp_code
+    ENV["GEM_HOST_OTP_CODE"] = "111111"
+    api_key = "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
+
+    util_sign_in [api_key, 200, "OK"]
+
+    assert_match "Signed in with API key:", @sign_in_ui.output
+    assert_equal "111111", @fetcher.last_request["OTP"]
+  end
+
   def test_sign_in_with_correct_otp_code
-    api_key       = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
+    api_key       = "a5fdbb6ba150cbb83aad2bb2fede64cf040453903"
     response_fail = "You have enabled multifactor authentication but your request doesn't have the correct OTP code. Please check it and retry."
 
     util_sign_in(proc do
       @call_count ||= 0
-      (@call_count += 1).odd? ? [response_fail, 401, 'Unauthorized'] : [api_key, 200, 'OK']
+      (@call_count += 1).odd? ? [response_fail, 401, "Unauthorized"] : [api_key, 200, "OK"]
     end, nil, [], "111111\n")
 
-    assert_match 'You have enabled multi-factor authentication. Please enter OTP code.', @sign_in_ui.output
-    assert_match 'Code: ', @sign_in_ui.output
-    assert_match 'Signed in.', @sign_in_ui.output
-    assert_equal '111111', @fetcher.last_request['OTP']
+    assert_match "You have enabled multi-factor authentication. Please enter OTP code.", @sign_in_ui.output
+    assert_match "Code: ", @sign_in_ui.output
+    assert_match "Signed in with API key:", @sign_in_ui.output
+    assert_equal "111111", @fetcher.last_request["OTP"]
   end
 
   def test_sign_in_with_incorrect_otp_code
     response = "You have enabled multifactor authentication but your request doesn't have the correct OTP code. Please check it and retry."
 
-    assert_raises Gem::MockGemUi::TermError do
-      util_sign_in [response, 401, 'Unauthorized'], nil, [], "111111\n"
+    assert_raise Gem::MockGemUi::TermError do
+      util_sign_in [response, 401, "Unauthorized"], nil, [], "111111\n"
     end
 
-    assert_match 'You have enabled multi-factor authentication. Please enter OTP code.', @sign_in_ui.output
-    assert_match 'Code: ', @sign_in_ui.output
+    assert_match "You have enabled multi-factor authentication. Please enter OTP code.", @sign_in_ui.output
+    assert_match "Code: ", @sign_in_ui.output
     assert_match response, @sign_in_ui.output
-    assert_equal '111111', @fetcher.last_request['OTP']
+    assert_equal "111111", @fetcher.last_request["OTP"]
   end
 
-  def util_sign_in(response, host = nil, args = [], extra_input = '')
-    email    = 'you@example.com'
-    password = 'secret'
+  def util_sign_in(response, host = nil, args = [], extra_input = "")
+    email            = "you@example.com"
+    password         = "secret"
+    profile_response = [ "mfa: disabled\n" , 200, "OK"]
 
     if host
-      ENV['RUBYGEMS_HOST'] = host
+      ENV["RUBYGEMS_HOST"] = host
     else
       host = Gem.host
     end
 
     @fetcher = Gem::FakeFetcher.new
     @fetcher.data["#{host}/api/v1/api_key"] = response
+    @fetcher.data["#{host}/api/v1/profile/me.yaml"] = profile_response
     Gem::RemoteFetcher.fetcher = @fetcher
 
-    @sign_in_ui = Gem::MockGemUi.new("#{email}\n#{password}\n" + extra_input)
+    @sign_in_ui = Gem::MockGemUi.new("#{email}\n#{password}\n\n\n\n\n\n\n\n\n" + extra_input)
 
     use_ui @sign_in_ui do
       if args.length > 0
@@ -241,21 +254,19 @@ class TestGemGemcutterUtilities < Gem::T
   end
 
   def test_verify_api_key
-    keys = {:other => 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'}
-    FileUtils.mkdir_p File.dirname(Gem.configuration.credentials_path)
-    File.open Gem.configuration.credentials_path, 'w' do |f|
+    keys = { :other => "a5fdbb6ba150cbb83aad2bb2fede64cf040453903" }
+    File.open Gem.configuration.credentials_path, "w" do |f|
       f.write keys.to_yaml
     end
     Gem.configuration.load_api_keys
 
-    assert_equal 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903',
+    assert_equal "a5fdbb6ba150cbb83aad2bb2fede64cf040453903",
                  @cmd.verify_api_key(:other)
   end
 
   def test_verify_missing_api_key
-    assert_raises Gem::MockGemUi::TermError do
+    assert_raise Gem::MockGemUi::TermError do
       @cmd.verify_api_key :missing
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_impossible_dependencies_error.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_impossible_dependencies_error.rb
@@ -1,10 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemImpossibleDependenciesError < Gem::TestCase
-
   def test_message_conflict
-    request = dependency_request dep('net-ssh', '>= 2.0.13'), 'rye', '0.9.8'
+    request = dependency_request dep("net-ssh", ">= 2.0.13"), "rye", "0.9.8"
 
     conflicts = []
 
@@ -12,9 +11,9 @@ class TestGemImpossibleDependenciesError
     # requested-by entries, but they are suitable for testing the message.
     # See #485 to construct a correct conflict.
     net_ssh_2_2_2 =
-      dependency_request dep('net-ssh', '>= 2.6.5'), 'net-ssh', '2.2.2', request
+      dependency_request dep("net-ssh", ">= 2.6.5"), "net-ssh", "2.2.2", request
     net_ssh_2_6_5 =
-      dependency_request dep('net-ssh', '~> 2.2.2'), 'net-ssh', '2.6.5', request
+      dependency_request dep("net-ssh", "~> 2.2.2"), "net-ssh", "2.6.5", request
 
     conflict1 = Gem::Resolver::Conflict.new \
       net_ssh_2_6_5, net_ssh_2_6_5.requester
@@ -57,5 +56,4 @@ rye-0.9.8 requires net-ssh (>= 2.0.13) b
 
     assert_equal expected, error.message
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_indexer.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_indexer.rb
@@ -1,37 +1,32 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/indexer'
-
-unless defined?(Builder::XChar)
-  warn "Gem::Indexer tests are being skipped.  Install builder gem."
-end
+require_relative "helper"
+require "rubygems/indexer"
 
 class TestGemIndexer < Gem::TestCase
-
   def setup
     super
 
     util_make_gems
 
-    @d2_0 = util_spec 'd', '2.0' do |s|
+    @d2_0 = util_spec "d", "2.0" do |s|
       s.date = Gem::Specification::TODAY - 86400 * 3
     end
     util_build_gem @d2_0
 
-    @d2_0_a = util_spec 'd', '2.0.a'
+    @d2_0_a = util_spec "d", "2.0.a"
     util_build_gem @d2_0_a
 
-    @d2_0_b = util_spec 'd', '2.0.b'
+    @d2_0_b = util_spec "d", "2.0.b"
     util_build_gem @d2_0_b
 
-    @default = new_default_spec 'default', 2
+    @default = new_default_spec "default", 2
     install_default_gems @default
 
-    @indexerdir = File.join(@tempdir, 'indexer')
+    @indexerdir = File.join(@tempdir, "indexer")
 
-    gems = File.join(@indexerdir, 'gems')
+    gems = File.join(@indexerdir, "gems")
     FileUtils.mkdir_p gems
-    FileUtils.mv Dir[File.join(@gemhome, "cache", '*.gem')], gems
+    FileUtils.mv Dir[File.join(@gemhome, "cache", "*.gem")], gems
 
     @indexer = Gem::Indexer.new(@indexerdir)
   end
@@ -84,7 +79,7 @@ class TestGemIndexer < Gem::TestCase
                 ["pl",     Gem::Version.new("1"),   "i386-linux"],
                 ["x",      Gem::Version.new("1"),   "ruby"]]
 
-    assert_equal expected, latest_specs, 'latest_specs'
+    assert_equal expected, latest_specs, "latest_specs"
   end
 
   def test_generate_index
@@ -92,7 +87,7 @@ class TestGemIndexer < Gem::TestCase
       @indexer.generate_index
     end
 
-    quickdir = File.join @indexerdir, 'quick'
+    quickdir = File.join @indexerdir, "quick"
     marshal_quickdir = File.join quickdir, "Marshal.#{@marshal_version}"
 
     assert_directory_exists quickdir
@@ -108,6 +103,8 @@ class TestGemIndexer < Gem::TestCase
 
     assert_indexed @indexerdir, "latest_specs.#{@marshal_version}"
     assert_indexed @indexerdir, "latest_specs.#{@marshal_version}.gz"
+
+    refute_directory_exists @indexer.directory
   end
 
   def test_generate_index_modern
@@ -117,15 +114,15 @@ class TestGemIndexer < Gem::TestCase
       @indexer.generate_index
     end
 
-    refute_indexed @indexerdir, 'yaml'
-    refute_indexed @indexerdir, 'yaml.Z'
+    refute_indexed @indexerdir, "yaml"
+    refute_indexed @indexerdir, "yaml.Z"
     refute_indexed @indexerdir, "Marshal.#{@marshal_version}"
     refute_indexed @indexerdir, "Marshal.#{@marshal_version}.Z"
 
-    quickdir = File.join @indexerdir, 'quick'
+    quickdir = File.join @indexerdir, "quick"
     marshal_quickdir = File.join quickdir, "Marshal.#{@marshal_version}"
 
-    assert_directory_exists quickdir, 'quickdir should be directory'
+    assert_directory_exists quickdir, "quickdir should be directory"
     assert_directory_exists marshal_quickdir
 
     refute_indexed quickdir, "index"
@@ -168,7 +165,7 @@ class TestGemIndexer < Gem::TestCase
     use_ui @ui do
       @indexer.generate_index
     end
-    quickdir = File.join @indexerdir, 'quick'
+    quickdir = File.join @indexerdir, "quick"
     marshal_quickdir = File.join quickdir, "Marshal.#{@marshal_version}"
 
     assert_directory_exists quickdir
@@ -189,17 +186,17 @@ class TestGemIndexer < Gem::TestCase
       @indexer.generate_index
     end
 
-    assert_match %r%^\.\.\.\.\.\.\.\.\.\.\.\.$%, @ui.output
-    assert_match %r%^Generating Marshal quick index gemspecs for 12 gems$%,
+    assert_match %r{^\.\.\.\.\.\.\.\.\.\.\.\.$}, @ui.output
+    assert_match %r{^Generating Marshal quick index gemspecs for 12 gems$},
                  @ui.output
-    assert_match %r%^Complete$%, @ui.output
-    assert_match %r%^Generating specs index$%, @ui.output
-    assert_match %r%^Generating latest specs index$%, @ui.output
-    assert_match %r%^Generating prerelease specs index$%, @ui.output
-    assert_match %r%^Complete$%, @ui.output
-    assert_match %r%^Compressing indices$%, @ui.output
+    assert_match %r{^Complete$}, @ui.output
+    assert_match %r{^Generating specs index$}, @ui.output
+    assert_match %r{^Generating latest specs index$}, @ui.output
+    assert_match %r{^Generating prerelease specs index$}, @ui.output
+    assert_match %r{^Complete$}, @ui.output
+    assert_match %r{^Compressing indices$}, @ui.output
 
-    assert_equal '', @ui.error
+    assert_equal "", @ui.error
   end
 
   def test_generate_index_specs
@@ -213,30 +210,30 @@ class TestGemIndexer < Gem::TestCase
     specs = Marshal.load specs_dump
 
     expected = [
-      ['a',      Gem::Version.new(1),     'ruby'],
-      ['a',      Gem::Version.new(2),     'ruby'],
-      ['a_evil', Gem::Version.new(9),     'ruby'],
-      ['b',      Gem::Version.new(2),     'ruby'],
-      ['c',      Gem::Version.new('1.2'), 'ruby'],
-      ['d',      Gem::Version.new('2.0'), 'ruby'],
-      ['dep_x',  Gem::Version.new(1),     'ruby'],
-      ['pl',     Gem::Version.new(1),     'i386-linux'],
-      ['x',      Gem::Version.new(1),     'ruby'],
+      ["a",      Gem::Version.new(1),     "ruby"],
+      ["a",      Gem::Version.new(2),     "ruby"],
+      ["a_evil", Gem::Version.new(9),     "ruby"],
+      ["b",      Gem::Version.new(2),     "ruby"],
+      ["c",      Gem::Version.new("1.2"), "ruby"],
+      ["d",      Gem::Version.new("2.0"), "ruby"],
+      ["dep_x",  Gem::Version.new(1),     "ruby"],
+      ["pl",     Gem::Version.new(1),     "i386-linux"],
+      ["x",      Gem::Version.new(1),     "ruby"],
     ]
 
     assert_equal expected, specs
 
     assert_same specs[0].first, specs[1].first,
-                'identical names not identical'
+                "identical names not identical"
 
     assert_same specs[0][1],    specs[-1][1],
-                'identical versions not identical'
+                "identical versions not identical"
 
     assert_same specs[0].last, specs[1].last,
-                'identical platforms not identical'
+                "identical platforms not identical"
 
     refute_same specs[1][1], specs[5][1],
-                'different versions not different'
+                "different versions not different"
   end
 
   def test_generate_index_latest_specs
@@ -250,23 +247,23 @@ class TestGemIndexer < Gem::TestCase
     latest_specs = Marshal.load latest_specs_dump
 
     expected = [
-      ['a',      Gem::Version.new(2),     'ruby'],
-      ['a_evil', Gem::Version.new(9),     'ruby'],
-      ['b',      Gem::Version.new(2),     'ruby'],
-      ['c',      Gem::Version.new('1.2'), 'ruby'],
-      ['d',      Gem::Version.new('2.0'), 'ruby'],
-      ['dep_x',  Gem::Version.new(1),     'ruby'],
-      ['pl',     Gem::Version.new(1),     'i386-linux'],
-      ['x',      Gem::Version.new(1),     'ruby'],
+      ["a",      Gem::Version.new(2),     "ruby"],
+      ["a_evil", Gem::Version.new(9),     "ruby"],
+      ["b",      Gem::Version.new(2),     "ruby"],
+      ["c",      Gem::Version.new("1.2"), "ruby"],
+      ["d",      Gem::Version.new("2.0"), "ruby"],
+      ["dep_x",  Gem::Version.new(1),     "ruby"],
+      ["pl",     Gem::Version.new(1),     "i386-linux"],
+      ["x",      Gem::Version.new(1),     "ruby"],
     ]
 
     assert_equal expected, latest_specs
 
     assert_same latest_specs[0][1],   latest_specs[2][1],
-                'identical versions not identical'
+                "identical versions not identical"
 
     assert_same latest_specs[0].last, latest_specs[1].last,
-                'identical platforms not identical'
+                "identical platforms not identical"
   end
 
   def test_generate_index_prerelease_specs
@@ -279,9 +276,9 @@ class TestGemIndexer < Gem::TestCase
     prerelease_specs_dump = Gem.read_binary prerelease_specs_path
     prerelease_specs = Marshal.load prerelease_specs_dump
 
-    assert_equal [['a', Gem::Version.new('3.a'),   'ruby'],
-                  ['d', Gem::Version.new('2.0.a'), 'ruby'],
-                  ['d', Gem::Version.new('2.0.b'), 'ruby']],
+    assert_equal [["a", Gem::Version.new("3.a"),   "ruby"],
+                  ["d", Gem::Version.new("2.0.a"), "ruby"],
+                  ["d", Gem::Version.new("2.0.b"), "ruby"]],
                  prerelease_specs
   end
 
@@ -291,7 +288,7 @@ class TestGemIndexer < Gem::TestCase
   def with_system_gems
     Gem::Specification.reset
 
-    sys_gem = util_spec 'systemgem', '1.0'
+    sys_gem = util_spec "systemgem", "1.0"
     util_build_gem sys_gem
     install_default_gems sys_gem
     yield
@@ -303,21 +300,21 @@ class TestGemIndexer < Gem::TestCase
       @indexer.generate_index
     end
 
-    quickdir = File.join @indexerdir, 'quick'
+    quickdir = File.join @indexerdir, "quick"
     marshal_quickdir = File.join quickdir, "Marshal.#{@marshal_version}"
 
     assert_directory_exists quickdir
     assert_directory_exists marshal_quickdir
 
-    @d2_1 = util_spec 'd', '2.1'
+    @d2_1 = util_spec "d", "2.1"
     util_build_gem @d2_1
     @d2_1_tuple = [@d2_1.name, @d2_1.version, @d2_1.original_platform]
 
-    @d2_1_a = util_spec 'd', '2.2.a'
+    @d2_1_a = util_spec "d", "2.2.a"
     util_build_gem @d2_1_a
     @d2_1_a_tuple = [@d2_1_a.name, @d2_1_a.version, @d2_1_a.original_platform]
 
-    gems = File.join @indexerdir, 'gems'
+    gems = File.join @indexerdir, "gems"
 
     FileUtils.mv @d2_1.cache_file, gems
     FileUtils.mv @d2_1_a.cache_file, gems
@@ -347,6 +344,8 @@ class TestGemIndexer < Gem::TestCase
 
       assert_includes pre_specs_index, @d2_1_a_tuple
       refute_includes pre_specs_index, @d2_1_tuple
+
+      refute_directory_exists @indexer.directory
     end
   end
 
@@ -359,5 +358,4 @@ class TestGemIndexer < Gem::TestCase
     file = File.join dir, name
     refute File.exist?(file), "#{file} exists"
   end
-
-end if defined?(Builder::XChar)
+end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_install_update_options.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_install_update_options.rb
@@ -1,15 +1,14 @@
 # frozen_string_literal: true
-require 'rubygems/installer_test_case'
-require 'rubygems/install_update_options'
-require 'rubygems/command'
-require 'rubygems/dependency_installer'
+require_relative "installer_test_case"
+require "rubygems/install_update_options"
+require "rubygems/command"
+require "rubygems/dependency_installer"
 
 class TestGemInstallUpdateOptions < Gem::InstallerTestCase
-
   def setup
     super
 
-    @cmd = Gem::Command.new 'dummy', 'dummy',
+    @cmd = Gem::Command.new "dummy", "dummy",
                             Gem::DependencyInstaller::DEFAULT_OPTIONS
     @cmd.extend Gem::InstallUpdateOptions
     @cmd.add_install_update_options
@@ -31,7 +30,7 @@ class TestGemInstallUpdateOptions < Gem:
 
     args.concat %w[--vendor] unless Gem.java_platform?
 
-    args.concat %w[-P HighSecurity] if defined?(OpenSSL::SSL)
+    args.concat %w[-P HighSecurity] if Gem::HAVE_OPENSSL
 
     assert @cmd.handles?(args)
   end
@@ -39,7 +38,7 @@ class TestGemInstallUpdateOptions < Gem:
   def test_build_root
     @cmd.handle_options %w[--build-root build_root]
 
-    assert_equal File.expand_path('build_root'), @cmd.options[:build_root]
+    assert_equal File.expand_path("build_root"), @cmd.options[:build_root]
   end
 
   def test_doc
@@ -93,7 +92,7 @@ class TestGemInstallUpdateOptions < Gem:
   end
 
   def test_security_policy
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
     @cmd.handle_options %w[-P HighSecurity]
 
@@ -101,18 +100,18 @@ class TestGemInstallUpdateOptions < Gem:
   end
 
   def test_security_policy_unknown
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
     @cmd.add_install_update_options
 
-    e = assert_raises OptionParser::InvalidArgument do
+    e = assert_raise Gem::OptionParser::InvalidArgument do
       @cmd.handle_options %w[-P UnknownSecurity]
     end
     assert_includes e.message, "UnknownSecurity"
   end
 
   def test_user_install_enabled
-    @spec = quick_gem 'a' do |spec|
+    @spec = quick_gem "a" do |spec|
       util_make_exec spec
     end
 
@@ -125,12 +124,12 @@ class TestGemInstallUpdateOptions < Gem:
 
     @installer = Gem::Installer.at @gem, @cmd.options
     @installer.install
-    assert_path_exists File.join(Gem.user_dir, 'gems')
-    assert_path_exists File.join(Gem.user_dir, 'gems', @spec.full_name)
+    assert_path_exist File.join(Gem.user_dir, "gems")
+    assert_path_exist File.join(Gem.user_dir, "gems", @spec.full_name)
   end
 
   def test_user_install_disabled_read_only
-    @spec = quick_gem 'a' do |spec|
+    @spec = quick_gem "a" do |spec|
       util_make_exec spec
     end
 
@@ -138,9 +137,9 @@ class TestGemInstallUpdateOptions < Gem:
     @gem = @spec.cache_file
 
     if win_platform?
-      skip('test_user_install_disabled_read_only test skipped on MS Windows')
+      pend("test_user_install_disabled_read_only test skipped on MS Windows")
     elsif Process.uid.zero?
-      skip('test_user_install_disabled_read_only test skipped in root privilege')
+      pend("test_user_install_disabled_read_only test skipped in root privilege")
     else
       @cmd.handle_options %w[--no-user-install]
 
@@ -151,7 +150,7 @@ class TestGemInstallUpdateOptions < Gem:
 
       Gem.use_paths @gemhome, @userhome
 
-      assert_raises(Gem::FilePermissionError) do
+      assert_raise(Gem::FilePermissionError) do
         Gem::Installer.at(@gem, @cmd.options).install
       end
     end
@@ -160,7 +159,7 @@ class TestGemInstallUpdateOptions < Gem:
   end
 
   def test_vendor
-    vendordir(File.join(@tempdir, 'vendor')) do
+    vendordir(File.join(@tempdir, "vendor")) do
       @cmd.handle_options %w[--vendor]
 
       assert @cmd.options[:vendor]
@@ -170,11 +169,11 @@ class TestGemInstallUpdateOptions < Gem:
 
   def test_vendor_missing
     vendordir(nil) do
-      e = assert_raises OptionParser::InvalidOption do
+      e = assert_raise Gem::OptionParser::InvalidOption do
         @cmd.handle_options %w[--vendor]
       end
 
-      assert_equal 'invalid option: --vendor your platform is not supported',
+      assert_equal "invalid option: --vendor your platform is not supported",
                    e.message
 
       refute @cmd.options[:vendor]
@@ -194,4 +193,15 @@ class TestGemInstallUpdateOptions < Gem:
     assert_equal true, @cmd.options[:post_install_message]
   end
 
+  def test_minimal_deps_no
+    @cmd.handle_options %w[--no-minimal-deps]
+
+    assert_equal false, @cmd.options[:minimal_deps]
+  end
+
+  def test_minimal_deps
+    @cmd.handle_options %w[--minimal-deps]
+
+    assert_equal true, @cmd.options[:minimal_deps]
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_installer.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_installer.rb
@@ -1,26 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/installer_test_case'
+require_relative "installer_test_case"
 
 class TestGemInstaller < Gem::InstallerTestCase
-
-  @@symlink_supported = nil
-
-  # Our CI does not currently hit the "symlink not supported" case, but this is
-  # needed for Windows developers without symlink support enabled (the default
-  # for non admin) to be able to run the tests successfully
-  def symlink_supported?
-    if @@symlink_supported.nil?
-      begin
-        File.symlink("", "")
-      rescue Errno::ENOENT, Errno::EEXIST
-        @@symlink_supported = true
-      rescue NotImplementedError, SystemCallError
-        @@symlink_supported = false
-      end
-    end
-    @@symlink_supported
-  end
-
   def setup
     super
     common_installer_setup
@@ -37,11 +18,12 @@ class TestGemInstaller < Gem::InstallerT
   end
 
   def test_app_script_text
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, ''
+      util_make_exec @spec, ""
 
-    expected = <<-EOF
+      expected = <<-EOF
 #!#{Gem.ruby}
 #
 # This file was generated by RubyGems.
@@ -52,6 +34,8 @@ class TestGemInstaller < Gem::InstallerT
 
 require 'rubygems'
 
+Gem.use_gemdeps
+
 version = \">= 0.a\"
 
 str = ARGV.first
@@ -69,10 +53,11 @@ else
 gem "a", version
 load Gem.bin_path("a", "executable", version)
 end
-    EOF
+      EOF
 
-    wrapper = installer.app_script_text 'executable'
-    assert_equal expected, wrapper
+      wrapper = installer.app_script_text "executable"
+      assert_equal expected, wrapper
+    end
   end
 
   def test_check_executable_overwrite
@@ -81,12 +66,12 @@ end
     installer.generate_bin
 
     @spec = Gem::Specification.new do |s|
-      s.files = ['lib/code.rb']
+      s.files = ["lib/code.rb"]
       s.name = "a"
       s.version = "3"
       s.summary = "summary"
       s.description = "desc"
-      s.require_path = 'lib'
+      s.require_path = "lib"
     end
 
     util_make_exec
@@ -94,27 +79,27 @@ end
     installer.wrappers = true
     installer.generate_bin
 
-    installed_exec = File.join util_inst_bindir, 'executable'
-    assert_path_exists installed_exec
+    installed_exec = File.join util_inst_bindir, "executable"
+    assert_path_exist installed_exec
 
     wrapper = File.read installed_exec
-    assert_match %r|generated by RubyGems|, wrapper
+    assert_match %r{generated by RubyGems}, wrapper
   end
 
   def test_check_executable_overwrite_default_bin_dir
-    installer = setup_base_installer
+    installer = setup_base_installer(false)
 
     bindir(Gem.bindir) do
       util_conflict_executable false
 
       ui = Gem::MockGemUi.new "n\n"
       use_ui ui do
-        e = assert_raises Gem::InstallError do
+        e = assert_raise Gem::InstallError do
           installer.generate_bin
         end
 
-        conflicted = File.join @gemhome, 'bin', 'executable'
-        assert_match %r%\A"executable" from a conflicts with (?:#{Regexp.quote(conflicted)}|installed executable from conflict)\z%,
+        conflicted = File.join @gemhome, "bin", "executable"
+        assert_match %r{\A"executable" from a conflicts with (?:#{Regexp.quote(conflicted)}|installed executable from conflict)\z},
                      e.message
       end
     end
@@ -126,15 +111,15 @@ end
     installer.generate_bin
 
     @spec = Gem::Specification.new do |s|
-      s.files = ['lib/code.rb']
+      s.files = ["lib/code.rb"]
       s.name = "a"
       s.version = "3"
       s.summary = "summary"
       s.description = "desc"
-      s.require_path = 'lib'
+      s.require_path = "lib"
     end
 
-    File.open File.join(util_inst_bindir, 'executable'), 'w' do |io|
+    File.open File.join(util_inst_bindir, "executable"), "w" do |io|
       io.write <<-EXEC
 #!/usr/local/bin/ruby
 #
@@ -145,31 +130,31 @@ gem 'other', version
     end
 
     util_make_exec
-    Gem::Installer.exec_format = 'foo-%s-bar'
+    Gem::Installer.exec_format = "foo-%s-bar"
     installer.gem_dir = @spec.gem_dir
     installer.wrappers = true
     installer.format_executable = true
 
     installer.generate_bin # should not raise
 
-    installed_exec = File.join util_inst_bindir, 'foo-executable-bar'
-    assert_path_exists installed_exec
+    installed_exec = File.join util_inst_bindir, "foo-executable-bar"
+    assert_path_exist installed_exec
 
     wrapper = File.read installed_exec
-    assert_match %r|generated by RubyGems|, wrapper
+    assert_match %r{generated by RubyGems}, wrapper
   ensure
     Gem::Installer.exec_format = nil
   end
 
   def test_check_executable_overwrite_other_gem
-    installer = setup_base_installer
+    installer = setup_base_installer(false)
 
     util_conflict_executable true
 
     ui = Gem::MockGemUi.new "n\n"
 
     use_ui ui do
-      e = assert_raises Gem::InstallError do
+      e = assert_raise Gem::InstallError do
         installer.generate_bin
       end
 
@@ -187,11 +172,11 @@ gem 'other', version
 
     installer.generate_bin
 
-    installed_exec = File.join util_inst_bindir, 'executable'
-    assert_path_exists installed_exec
+    installed_exec = File.join util_inst_bindir, "executable"
+    assert_path_exist installed_exec
 
     wrapper = File.read installed_exec
-    assert_match %r|generated by RubyGems|, wrapper
+    assert_match %r{generated by RubyGems}, wrapper
   end
 
   def test_check_executable_overwrite_other_non_gem
@@ -202,11 +187,11 @@ gem 'other', version
 
     installer.generate_bin
 
-    installed_exec = File.join util_inst_bindir, 'executable'
-    assert_path_exists installed_exec
+    installed_exec = File.join util_inst_bindir, "executable"
+    assert_path_exist installed_exec
 
     wrapper = File.read installed_exec
-    assert_match %r|generated by RubyGems|, wrapper
+    assert_match %r{generated by RubyGems}, wrapper
   end unless Gem.win_platform?
 
   def test_check_that_user_bin_dir_is_in_path
@@ -215,11 +200,21 @@ gem 'other', version
     bin_dir = installer.bin_dir
 
     if Gem.win_platform?
-      bin_dir = bin_dir.downcase.gsub(File::SEPARATOR, File::ALT_SEPARATOR)
+      bin_dir = bin_dir.downcase
+    end
+
+    orig_PATH, ENV["PATH"] =
+      ENV["PATH"], [ENV["PATH"], bin_dir].join(File::PATH_SEPARATOR)
+
+    use_ui @ui do
+      installer.check_that_user_bin_dir_is_in_path
     end
 
-    orig_PATH, ENV['PATH'] =
-      ENV['PATH'], [ENV['PATH'], bin_dir].join(File::PATH_SEPARATOR)
+    assert_empty @ui.error
+
+    return unless win_platform?
+
+    ENV["PATH"] = [orig_PATH, bin_dir.tr(File::SEPARATOR, File::ALT_SEPARATOR)].join(File::PATH_SEPARATOR)
 
     use_ui @ui do
       installer.check_that_user_bin_dir_is_in_path
@@ -227,17 +222,17 @@ gem 'other', version
 
     assert_empty @ui.error
   ensure
-    ENV['PATH'] = orig_PATH
+    ENV["PATH"] = orig_PATH
   end
 
   def test_check_that_user_bin_dir_is_in_path_tilde
-    skip "Tilde is PATH is not supported under MS Windows" if win_platform?
+    pend "Tilde is PATH is not supported under MS Windows" if win_platform?
 
-    orig_PATH, ENV['PATH'] =
-      ENV['PATH'], [ENV['PATH'], '~/bin'].join(File::PATH_SEPARATOR)
+    orig_PATH, ENV["PATH"] =
+      ENV["PATH"], [ENV["PATH"], "~/bin"].join(File::PATH_SEPARATOR)
 
     installer = setup_base_installer
-    installer.bin_dir.replace File.join @userhome, 'bin'
+    installer.bin_dir.replace File.join @userhome, "bin"
 
     use_ui @ui do
       installer.check_that_user_bin_dir_is_in_path
@@ -245,7 +240,7 @@ gem 'other', version
 
     assert_empty @ui.error
   ensure
-    ENV['PATH'] = orig_PATH unless win_platform?
+    ENV["PATH"] = orig_PATH unless win_platform?
   end
 
   def test_check_that_user_bin_dir_is_in_path_not_in_path
@@ -258,7 +253,7 @@ gem 'other', version
     expected = installer.bin_dir
 
     if Gem.win_platform?
-      expected = expected.downcase.gsub(File::SEPARATOR, File::ALT_SEPARATOR)
+      expected = expected.downcase
     end
 
     assert_match expected, @ui.error
@@ -267,27 +262,27 @@ gem 'other', version
   def test_ensure_dependency
     installer = setup_base_installer
 
-    util_spec 'a'
+    util_spec "a"
 
-    dep = Gem::Dependency.new 'a', '>= 2'
+    dep = Gem::Dependency.new "a", ">= 2"
     assert installer.ensure_dependency(@spec, dep)
 
-    dep = Gem::Dependency.new 'b', '> 2'
-    e = assert_raises Gem::InstallError do
+    dep = Gem::Dependency.new "b", "> 2"
+    e = assert_raise Gem::InstallError do
       installer.ensure_dependency @spec, dep
     end
 
-    assert_equal 'a requires b (> 2)', e.message
+    assert_equal "a requires b (> 2)", e.message
   end
 
   def test_ensure_loadable_spec
-    a, a_gem = util_gem 'a', 2 do |s|
-      s.add_dependency 'garbage ~> 5'
+    a, a_gem = util_gem "a", 2 do |s|
+      s.add_dependency "garbage ~> 5"
     end
 
     installer = Gem::Installer.at a_gem
 
-    e = assert_raises Gem::InstallError do
+    e = assert_raise Gem::InstallError do
       installer.ensure_loadable_spec
     end
 
@@ -296,16 +291,16 @@ gem 'other', version
   end
 
   def test_ensure_loadable_spec_security_policy
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
-    _, a_gem = util_gem 'a', 2 do |s|
-      s.add_dependency 'garbage ~> 5'
+    _, a_gem = util_gem "a", 2 do |s|
+      s.add_dependency "garbage ~> 5"
     end
 
     policy = Gem::Security::HighSecurity
     installer = Gem::Installer.at a_gem, :security_policy => policy
 
-    assert_raises Gem::Security::Exception do
+    assert_raise Gem::Security::Exception do
       installer.ensure_loadable_spec
     end
   end
@@ -315,7 +310,7 @@ gem 'other', version
 
     installer.extract_files
 
-    assert_path_exists File.join @spec.gem_dir, 'bin/executable'
+    assert_path_exist File.join @spec.gem_dir, "bin/executable"
   end
 
   def test_generate_bin_bindir
@@ -324,12 +319,12 @@ gem 'other', version
     installer.wrappers = true
 
     @spec.executables = %w[executable]
-    @spec.bindir = 'bin'
+    @spec.bindir = "bin"
 
-    exec_file = installer.formatted_program_filename 'executable'
+    exec_file = installer.formatted_program_filename "executable"
     exec_path = File.join @spec.gem_dir, exec_file
-    File.open exec_path, 'w' do |f|
-      f.puts '#!/usr/bin/ruby'
+    File.open exec_path, "w" do |f|
+      f.puts "#!/usr/bin/ruby"
     end
 
     installer.gem_dir = @spec.gem_dir
@@ -337,12 +332,12 @@ gem 'other', version
     installer.generate_bin
 
     assert_directory_exists util_inst_bindir
-    installed_exec = File.join(util_inst_bindir, 'executable')
-    assert_path_exists installed_exec
+    installed_exec = File.join(util_inst_bindir, "executable")
+    assert_path_exist installed_exec
     assert_equal mask, File.stat(installed_exec).mode unless win_platform?
 
     wrapper = File.read installed_exec
-    assert_match %r|generated by RubyGems|, wrapper
+    assert_match %r{generated by RubyGems}, wrapper
   end
 
   def test_generate_bin_bindir_with_user_install_warning
@@ -354,10 +349,10 @@ gem 'other', version
 
     options = {
       :bin_dir => bin_dir,
-      :install_dir => "/non/existent"
+      :install_dir => "/non/existent",
     }
 
-    inst = Gem::Installer.at '', options
+    inst = Gem::Installer.at "", options
 
     Gem::Installer.path_warning = false
 
@@ -380,12 +375,12 @@ gem 'other', version
 
     installer.generate_bin
     assert_directory_exists util_inst_bindir
-    installed_exec = File.join util_inst_bindir, 'executable'
-    assert_path_exists installed_exec
+    installed_exec = File.join util_inst_bindir, "executable"
+    assert_path_exist installed_exec
     assert_equal mask, File.stat(installed_exec).mode unless win_platform?
 
     wrapper = File.read installed_exec
-    assert_match %r|generated by RubyGems|, wrapper
+    assert_match %r{generated by RubyGems}, wrapper
   end
 
   def test_generate_bin_script_format
@@ -396,11 +391,11 @@ gem 'other', version
     util_make_exec
     installer.gem_dir = @spec.gem_dir
 
-    Gem::Installer.exec_format = 'foo-%s-bar'
+    Gem::Installer.exec_format = "foo-%s-bar"
     installer.generate_bin
     assert_directory_exists util_inst_bindir
-    installed_exec = File.join util_inst_bindir, 'foo-executable-bar'
-    assert_path_exists installed_exec
+    installed_exec = File.join util_inst_bindir, "foo-executable-bar"
+    assert_path_exist installed_exec
   ensure
     Gem::Installer.exec_format = nil
   end
@@ -412,11 +407,11 @@ gem 'other', version
     util_make_exec
     installer.gem_dir = @spec.gem_dir
 
-    Gem::Installer.exec_format = 'foo-%s-bar'
+    Gem::Installer.exec_format = "foo-%s-bar"
     installer.generate_bin
     assert_directory_exists util_inst_bindir
-    installed_exec = File.join util_inst_bindir, 'executable'
-    assert_path_exists installed_exec
+    installed_exec = File.join util_inst_bindir, "executable"
+    assert_path_exist installed_exec
   ensure
     Gem::Installer.exec_format = nil
   end
@@ -427,24 +422,24 @@ gem 'other', version
     installer.wrappers = true
 
     gem_dir = File.join("#{@gemhome}2", "gems", @spec.full_name)
-    gem_bindir = File.join gem_dir, 'bin'
+    gem_bindir = File.join gem_dir, "bin"
     FileUtils.mkdir_p gem_bindir
-    File.open File.join(gem_bindir, 'executable'), 'w' do |f|
+    File.open File.join(gem_bindir, "executable"), "w" do |f|
       f.puts "#!/bin/ruby"
     end
 
     installer.gem_home = "#{@gemhome}2"
     installer.gem_dir = gem_dir
-    installer.bin_dir = File.join "#{@gemhome}2", 'bin'
+    installer.bin_dir = File.join "#{@gemhome}2", "bin"
 
     installer.generate_bin
 
-    installed_exec = File.join("#{@gemhome}2", "bin", 'executable')
-    assert_path_exists installed_exec
+    installed_exec = File.join("#{@gemhome}2", "bin", "executable")
+    assert_path_exist installed_exec
     assert_equal mask, File.stat(installed_exec).mode unless win_platform?
 
     wrapper = File.read installed_exec
-    assert_match %r|generated by RubyGems|, wrapper
+    assert_match %r{generated by RubyGems}, wrapper
   end
 
   def test_generate_bin_script_no_execs
@@ -455,7 +450,7 @@ gem 'other', version
     installer.wrappers = true
     installer.generate_bin
 
-    refute_path_exists util_inst_bindir, 'bin dir was created when not needed'
+    assert_path_not_exist util_inst_bindir, "bin dir was created when not needed"
   end
 
   def test_generate_bin_script_no_perms
@@ -467,18 +462,18 @@ gem 'other', version
     Dir.mkdir util_inst_bindir
 
     if win_platform?
-      skip('test_generate_bin_script_no_perms skipped on MS Windows')
+      pend("test_generate_bin_script_no_perms skipped on MS Windows")
     elsif Process.uid.zero?
-      skip('test_generate_bin_script_no_perms skipped in root privilege')
+      pend("test_generate_bin_script_no_perms skipped in root privilege")
     else
       FileUtils.chmod 0000, util_inst_bindir
 
-      assert_raises Gem::FilePermissionError do
+      assert_raise Gem::FilePermissionError do
         installer.generate_bin
       end
     end
   ensure
-    FileUtils.chmod 0755, util_inst_bindir unless ($DEBUG or win_platform?)
+    FileUtils.chmod 0755, util_inst_bindir unless ($DEBUG || win_platform?)
   end
 
   def test_generate_bin_script_no_shebang
@@ -487,21 +482,21 @@ gem 'other', version
     installer.wrappers = true
     @spec.executables = %w[executable]
 
-    gem_dir = File.join @gemhome, 'gems', @spec.full_name
-    gem_bindir = File.join gem_dir, 'bin'
+    gem_dir = File.join @gemhome, "gems", @spec.full_name
+    gem_bindir = File.join gem_dir, "bin"
     FileUtils.mkdir_p gem_bindir
-    File.open File.join(gem_bindir, 'executable'), 'w' do |f|
+    File.open File.join(gem_bindir, "executable"), "w" do |f|
       f.puts "blah blah blah"
     end
 
     installer.generate_bin
 
-    installed_exec = File.join @gemhome, 'bin', 'executable'
-    assert_path_exists installed_exec
+    installed_exec = File.join @gemhome, "bin", "executable"
+    assert_path_exist installed_exec
     assert_equal mask, File.stat(installed_exec).mode unless win_platform?
 
     wrapper = File.read installed_exec
-    assert_match %r|generated by RubyGems|, wrapper
+    assert_match %r{generated by RubyGems}, wrapper
     # HACK some gems don't have #! in their executables, restore 2008/06
     #assert_no_match %r|generated by RubyGems|, wrapper
   end
@@ -512,9 +507,9 @@ gem 'other', version
     installer.wrappers = true
     util_make_exec
     installer.gem_dir = @spec.gem_dir
-    installed_exec = File.join(util_inst_bindir, 'executable')
+    installed_exec = File.join(util_inst_bindir, "executable")
 
-    real_exec = File.join @spec.gem_dir, 'bin', 'executable'
+    real_exec = File.join @spec.gem_dir, "bin", "executable"
 
     # fake --no-wrappers for previous install
     unless Gem.win_platform?
@@ -524,17 +519,17 @@ gem 'other', version
 
     installer.generate_bin
     assert_directory_exists util_inst_bindir
-    assert_path_exists installed_exec
+    assert_path_exist installed_exec
     assert_equal mask, File.stat(installed_exec).mode unless win_platform?
 
-    assert_match %r|generated by RubyGems|, File.read(installed_exec)
+    assert_match %r{generated by RubyGems}, File.read(installed_exec)
 
-    refute_match %r|generated by RubyGems|, File.read(real_exec),
-                 'real executable overwritten'
+    refute_match %r{generated by RubyGems}, File.read(real_exec),
+                 "real executable overwritten"
   end
 
   def test_generate_bin_symlink
-    skip "Symlinks not supported or not enabled" unless symlink_supported?
+    pend "Symlinks not supported or not enabled" unless symlink_supported?
 
     installer = setup_base_installer
 
@@ -544,9 +539,9 @@ gem 'other', version
 
     installer.generate_bin
     assert_directory_exists util_inst_bindir
-    installed_exec = File.join util_inst_bindir, 'executable'
+    installed_exec = File.join util_inst_bindir, "executable"
     assert_equal true, File.symlink?(installed_exec)
-    assert_equal(File.join(@spec.gem_dir, 'bin', 'executable'),
+    assert_equal(File.join(@spec.gem_dir, "bin", "executable"),
                  File.readlink(installed_exec))
   end
 
@@ -558,7 +553,7 @@ gem 'other', version
     installer.wrappers = false
     installer.generate_bin
 
-    refute_path_exists util_inst_bindir
+    assert_path_not_exist util_inst_bindir
   end
 
   def test_generate_bin_symlink_no_perms
@@ -571,22 +566,22 @@ gem 'other', version
     Dir.mkdir util_inst_bindir
 
     if win_platform?
-      skip('test_generate_bin_symlink_no_perms skipped on MS Windows')
+      pend("test_generate_bin_symlink_no_perms skipped on MS Windows")
     elsif Process.uid.zero?
-      skip('test_user_install_disabled_read_only test skipped in root privilege')
+      pend("test_user_install_disabled_read_only test skipped in root privilege")
     else
       FileUtils.chmod 0000, util_inst_bindir
 
-      assert_raises Gem::FilePermissionError do
+      assert_raise Gem::FilePermissionError do
         installer.generate_bin
       end
     end
   ensure
-    FileUtils.chmod 0755, util_inst_bindir unless ($DEBUG or win_platform?)
+    FileUtils.chmod 0755, util_inst_bindir unless ($DEBUG || win_platform?)
   end
 
   def test_generate_bin_symlink_update_newer
-    skip "Symlinks not supported or not enabled" unless symlink_supported?
+    pend "Symlinks not supported or not enabled" unless symlink_supported?
 
     installer = setup_base_installer
 
@@ -595,30 +590,30 @@ gem 'other', version
     installer.gem_dir = @spec.gem_dir
 
     installer.generate_bin
-    installed_exec = File.join(util_inst_bindir, 'executable')
-    assert_equal(File.join(@spec.gem_dir, 'bin', 'executable'),
+    installed_exec = File.join(util_inst_bindir, "executable")
+    assert_equal(File.join(@spec.gem_dir, "bin", "executable"),
                  File.readlink(installed_exec))
 
     @spec = Gem::Specification.new do |s|
-      s.files = ['lib/code.rb']
+      s.files = ["lib/code.rb"]
       s.name = "a"
       s.version = "3"
       s.summary = "summary"
       s.description = "desc"
-      s.require_path = 'lib'
+      s.require_path = "lib"
     end
 
     util_make_exec
     installer.gem_dir = @spec.gem_dir
     installer.generate_bin
-    installed_exec = File.join(util_inst_bindir, 'executable')
-    assert_equal(@spec.bin_file('executable'),
+    installed_exec = File.join(util_inst_bindir, "executable")
+    assert_equal(@spec.bin_file("executable"),
                  File.readlink(installed_exec),
                  "Ensure symlink moved to latest version")
   end
 
   def test_generate_bin_symlink_update_older
-    skip "Symlinks not supported or not enabled" unless symlink_supported?
+    pend "Symlinks not supported or not enabled" unless symlink_supported?
 
     installer = setup_base_installer
 
@@ -627,17 +622,17 @@ gem 'other', version
     installer.gem_dir = @spec.gem_dir
 
     installer.generate_bin
-    installed_exec = File.join(util_inst_bindir, 'executable')
-    assert_equal(File.join(@spec.gem_dir, 'bin', 'executable'),
+    installed_exec = File.join(util_inst_bindir, "executable")
+    assert_equal(File.join(@spec.gem_dir, "bin", "executable"),
                  File.readlink(installed_exec))
 
     spec = Gem::Specification.new do |s|
-      s.files = ['lib/code.rb']
+      s.files = ["lib/code.rb"]
       s.name = "a"
       s.version = "1"
       s.summary = "summary"
       s.description = "desc"
-      s.require_path = 'lib'
+      s.require_path = "lib"
     end
 
     util_make_exec
@@ -648,15 +643,15 @@ gem 'other', version
 
     installer.generate_bin
 
-    installed_exec = File.join util_inst_bindir, 'executable'
-    expected = File.join @spec.gem_dir, 'bin', 'executable'
+    installed_exec = File.join util_inst_bindir, "executable"
+    expected = File.join @spec.gem_dir, "bin", "executable"
     assert_equal(expected,
                  File.readlink(installed_exec),
                  "Ensure symlink not moved")
   end
 
   def test_generate_bin_symlink_update_remove_wrapper
-    skip "Symlinks not supported or not enabled" unless symlink_supported?
+    pend "Symlinks not supported or not enabled" unless symlink_supported?
 
     installer = setup_base_installer
 
@@ -666,16 +661,16 @@ gem 'other', version
 
     installer.generate_bin
 
-    installed_exec = File.join util_inst_bindir, 'executable'
-    assert_path_exists installed_exec
+    installed_exec = File.join util_inst_bindir, "executable"
+    assert_path_exist installed_exec
 
     @spec = Gem::Specification.new do |s|
-      s.files = ['lib/code.rb']
+      s.files = ["lib/code.rb"]
       s.name = "a"
       s.version = "3"
       s.summary = "summary"
       s.description = "desc"
-      s.require_path = 'lib'
+      s.require_path = "lib"
     end
     util_make_exec
 
@@ -685,8 +680,8 @@ gem 'other', version
 
     installer.generate_bin
 
-    installed_exec = File.join util_inst_bindir, 'executable'
-    assert_equal(@spec.bin_file('executable'),
+    installed_exec = File.join util_inst_bindir, "executable"
+    assert_equal(@spec.bin_file("executable"),
                  File.readlink(installed_exec),
                  "Ensure symlink moved to latest version")
   end
@@ -696,7 +691,7 @@ gem 'other', version
     Gem.win_platform = true
     old_alt_separator = File::ALT_SEPARATOR
     File.__send__(:remove_const, :ALT_SEPARATOR)
-    File.const_set(:ALT_SEPARATOR, '\\')
+    File.const_set(:ALT_SEPARATOR, "\\")
 
     installer = setup_base_installer
 
@@ -709,8 +704,8 @@ gem 'other', version
     end
 
     assert_directory_exists util_inst_bindir
-    installed_exec = File.join(util_inst_bindir, 'executable')
-    assert_path_exists installed_exec
+    installed_exec = File.join(util_inst_bindir, "executable")
+    assert_path_exist installed_exec
 
     if symlink_supported?
       assert File.symlink?(installed_exec)
@@ -729,24 +724,191 @@ gem 'other', version
   end
 
   def test_generate_bin_uses_default_shebang
-    skip "Symlinks not supported or not enabled" unless symlink_supported?
+    pend "Symlinks not supported or not enabled" unless symlink_supported?
 
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    installer.wrappers = true
-    util_make_exec
+      installer.wrappers = true
+      util_make_exec
 
-    installer.generate_bin
+      installer.generate_bin
+
+      default_shebang = Gem.ruby
+      shebang_line = File.open("#{@gemhome}/bin/executable") {|f| f.readlines.first }
+      assert_match(/\A#!/, shebang_line)
+      assert_match(/#{default_shebang}/, shebang_line)
+    end
+  end
+
+  def test_generate_bin_with_dangling_symlink
+    gem_with_dangling_symlink = File.expand_path("packages/ascii_binder-0.1.10.1.gem", __dir__)
+
+    installer = Gem::Installer.at(
+      gem_with_dangling_symlink,
+      :user_install => false,
+      :force => true
+    )
+
+    build_rake_in do
+      use_ui @ui do
+        installer.install
+      end
+    end
+
+    errors = @ui.error.split("\n")
+    assert_equal "WARNING:  ascii_binder-0.1.10.1 ships with a dangling symlink named bin/ascii_binder pointing to missing bin/asciibinder file. Ignoring", errors.shift
+    assert_empty errors
+
+    assert_empty @ui.output
+  end
+
+  def test_generate_plugins
+    installer = util_setup_installer do |spec|
+      write_file File.join(@tempdir, "lib", "rubygems_plugin.rb") do |io|
+        io.write "puts __FILE__"
+      end
+
+      spec.files += %w[lib/rubygems_plugin.rb]
+    end
+
+    build_rake_in do
+      installer.install
+    end
+
+    plugin_path = File.join Gem.plugindir, "a_plugin.rb"
+
+    FileUtils.rm plugin_path
+
+    installer.generate_plugins
+
+    assert File.exist?(plugin_path), "plugin not written"
+  end
+
+  def test_generate_plugins_with_install_dir
+    spec = quick_gem "a" do |s|
+      write_file File.join(@tempdir, "lib", "rubygems_plugin.rb") do |io|
+        io.write "puts __FILE__"
+      end
+
+      s.files += %w[lib/rubygems_plugin.rb]
+    end
+
+    util_build_gem spec
+
+    plugin_path = File.join "#{@gemhome}2", "plugins", "a_plugin.rb"
+    installer = util_installer spec, "#{@gemhome}2"
+
+    assert_equal spec, installer.install
+
+    assert File.exist?(plugin_path), "plugin not written to install_dir"
+  end
+
+  def test_generate_plugins_with_user_install
+    spec = quick_gem "a" do |s|
+      write_file File.join(@tempdir, "lib", "rubygems_plugin.rb") do |io|
+        io.write "puts __FILE__"
+      end
+
+      s.files += %w[lib/rubygems_plugin.rb]
+    end
+
+    util_build_gem spec
 
-    default_shebang = Gem.ruby
-    shebang_line = open("#{@gemhome}/bin/executable") { |f| f.readlines.first }
-    assert_match(/\A#!/, shebang_line)
-    assert_match(/#{default_shebang}/, shebang_line)
+    File.chmod(0555, Gem.plugindir)
+    system_path = File.join(Gem.plugindir, "a_plugin.rb")
+    user_path = File.join(Gem.plugindir(Gem.user_dir), "a_plugin.rb")
+    installer = util_installer spec, Gem.dir, :user
+
+    assert_equal spec, installer.install
+
+    assert !File.exist?(system_path), "plugin incorrectly written to system plugins_dir"
+    assert File.exist?(user_path), "plugin not written to user plugins_dir"
+  end
+
+  def test_generate_plugins_with_build_root
+    spec = quick_gem "a" do |s|
+      write_file File.join(@tempdir, "lib", "rubygems_plugin.rb") do |io|
+        io.write "puts __FILE__"
+      end
+
+      s.files += %w[lib/rubygems_plugin.rb]
+    end
+
+    util_build_gem spec
+
+    File.chmod(0555, Gem.plugindir)
+    system_path = File.join(Gem.plugindir, "a_plugin.rb")
+
+    build_root = File.join(@tempdir, "build_root")
+    build_root_path = File.join(build_root, Gem.plugindir.gsub(/^[a-zA-Z]:/, ""), "a_plugin.rb")
+
+    installer = Gem::Installer.at spec.cache_file, :build_root => build_root
+
+    assert_equal spec, installer.install
+
+    assert !File.exist?(system_path), "plugin written incorrect written to system plugins_dir"
+    assert File.exist?(build_root_path), "plugin not written to build_root"
+
+    refute_includes File.read(build_root_path), build_root
+  end
+
+  def test_keeps_plugins_up_to_date
+    # NOTE: version a-2 is already installed by setup hooks
+
+    write_file File.join(@tempdir, "lib", "rubygems_plugin.rb") do |io|
+      io.write "puts __FILE__"
+    end
+
+    build_rake_in do
+      util_setup_installer do |spec|
+        spec.version = "1"
+        spec.files += %w[lib/rubygems_plugin.rb]
+      end.install
+
+      plugin_path = File.join Gem.plugindir, "a_plugin.rb"
+      refute File.exist?(plugin_path), "old version installed while newer version without plugin also installed, but plugin written"
+
+      util_setup_installer do |spec|
+        spec.version = "2"
+        spec.files += %w[lib/rubygems_plugin.rb]
+      end.install
+
+      plugin_path = File.join Gem.plugindir, "a_plugin.rb"
+      assert File.exist?(plugin_path), "latest version reinstalled, but plugin not written"
+      assert_match %r{\Arequire.*a-2/lib/rubygems_plugin\.rb}, File.read(plugin_path), "written plugin has incorrect content"
+
+      util_setup_installer do |spec|
+        spec.version = "3"
+        spec.files += %w[lib/rubygems_plugin.rb]
+      end.install
+
+      plugin_path = File.join Gem.plugindir, "a_plugin.rb"
+      assert File.exist?(plugin_path), "latest version installed, but plugin removed"
+      assert_match %r{\Arequire.*a-3/lib/rubygems_plugin\.rb}, File.read(plugin_path), "written plugin has incorrect content"
+
+      util_setup_installer do |spec|
+        spec.version = "4"
+      end.install
+
+      refute File.exist?(plugin_path), "new version installed without a plugin while older version with a plugin installed, but plugin not removed"
+    end
+  end
+
+  def test_generates_plugins_dir_under_install_dir_if_not_there
+    Gem.use_paths "#{@gemhome}2" # Set GEM_HOME to an uninitialized repo
+
+    @spec = util_spec "a"
+
+    path = Gem::Package.build @spec
+
+    installer = Gem::Installer.at path, :install_dir => "#{@gemhome}3"
+    assert_equal @spec, installer.install
   end
 
   def test_initialize
-    spec = util_spec 'a' do |s|
-      s.platform = Gem::Platform.new 'mswin32'
+    spec = util_spec "a" do |s|
+      s.platform = Gem::Platform.new "mswin32"
     end
 
     gem = File.join @tempdir, spec.file_name
@@ -757,8 +919,8 @@ gem 'other', version
 
     installer = Gem::Installer.at gem
 
-    assert_equal File.join(@gemhome, 'gems', spec.full_name), installer.gem_dir
-    assert_equal File.join(@gemhome, 'bin'), installer.bin_dir
+    assert_equal File.join(@gemhome, "gems", spec.full_name), installer.gem_dir
+    assert_equal File.join(@gemhome, "bin"), installer.bin_dir
   end
 
   def test_initialize_user_install
@@ -766,7 +928,7 @@ gem 'other', version
 
     installer = Gem::Installer.at @gem, :user_install => true
 
-    assert_equal File.join(Gem.user_dir, 'gems', @spec.full_name),
+    assert_equal File.join(Gem.user_dir, "gems", @spec.full_name),
                  installer.gem_dir
     assert_equal Gem.bindir(Gem.user_dir), installer.bin_dir
   end
@@ -777,7 +939,7 @@ gem 'other', version
     installer =
       Gem::Installer.at @gem, :user_install => true, :bin_dir => @tempdir
 
-    assert_equal File.join(Gem.user_dir, 'gems', @spec.full_name),
+    assert_equal File.join(Gem.user_dir, "gems", @spec.full_name),
                  installer.gem_dir
     assert_equal @tempdir, installer.bin_dir
   end
@@ -785,29 +947,26 @@ gem 'other', version
   def test_install
     installer = util_setup_installer
 
-    gemdir     = File.join @gemhome, 'gems', @spec.full_name
-    cache_file = File.join @gemhome, 'cache', @spec.file_name
-    stub_exe   = File.join @gemhome, 'bin', 'executable'
-    rakefile   = File.join gemdir, 'ext', 'a', 'Rakefile'
-    spec_file  = File.join @gemhome, 'specifications', @spec.spec_name
+    gemdir     = File.join @gemhome, "gems", @spec.full_name
+    cache_file = File.join @gemhome, "cache", @spec.file_name
+    stub_exe   = File.join @gemhome, "bin", "executable"
+    rakefile   = File.join gemdir, "ext", "a", "Rakefile"
+    spec_file  = File.join @gemhome, "specifications", @spec.spec_name
 
     Gem.pre_install do
-      refute_path_exists cache_file, 'cache file must not exist yet'
-      refute_path_exists spec_file,  'spec file must not exist yet'
+      assert_path_not_exist cache_file, "cache file must not exist yet"
       true
     end
 
     Gem.post_build do
-      assert_path_exists gemdir, 'gem install dir must exist'
-      assert_path_exists rakefile, 'gem executable must exist'
-      refute_path_exists stub_exe, 'gem executable must not exist'
-      refute_path_exists spec_file, 'spec file must not exist yet'
+      assert_path_exist gemdir, "gem install dir must exist"
+      assert_path_exist rakefile, "gem executable must exist"
+      assert_path_not_exist stub_exe, "gem executable must not exist"
       true
     end
 
     Gem.post_install do
-      assert_path_exists cache_file, 'cache file must exist'
-      assert_path_exists spec_file,  'spec file must exist'
+      assert_path_exist cache_file, "cache file must exist"
     end
 
     @newspec = nil
@@ -818,21 +977,21 @@ gem 'other', version
     end
 
     assert_equal @spec, @newspec
-    assert_path_exists gemdir
-    assert_path_exists stub_exe, 'gem executable must exist'
+    assert_path_exist gemdir
+    assert_path_exist stub_exe, "gem executable must exist"
 
-    exe = File.join gemdir, 'bin', 'executable'
-    assert_path_exists exe
+    exe = File.join gemdir, "bin", "executable"
+    assert_path_exist exe
 
     exe_mode = File.stat(exe).mode & 0111
     assert_equal 0111, exe_mode, "0%o" % exe_mode unless win_platform?
 
-    assert_path_exists File.join gemdir, 'lib', 'code.rb'
+    assert_path_exist File.join gemdir, "lib", "code.rb"
 
-    assert_path_exists rakefile
+    assert_path_exist rakefile
 
     assert_equal spec_file, @newspec.loaded_from
-    assert_path_exists spec_file
+    assert_path_exist spec_file
 
     assert_same installer, @post_build_hook_arg
     assert_same installer, @post_install_hook_arg
@@ -844,7 +1003,7 @@ gem 'other', version
 
     installer.wrappers = true
 
-    gemdir = File.join @gemhome, 'gems', @spec.full_name
+    gemdir = File.join @gemhome, "gems", @spec.full_name
 
     @newspec = nil
     build_rake_in do
@@ -853,9 +1012,9 @@ gem 'other', version
       end
     end
 
-    exe = File.join gemdir, 'bin', 'executable'
+    exe = File.join gemdir, "bin", "executable"
 
-    e = assert_raises RuntimeError do
+    e = assert_raise RuntimeError do
       instance_eval File.read(exe)
     end
 
@@ -867,10 +1026,10 @@ gem 'other', version
 
     # build old version that has a bin file
     installer = util_setup_gem do |spec|
-      File.open File.join('bin', 'executable'), 'w' do |f|
+      File.open File.join("bin", "executable"), "w" do |f|
         f.puts "require 'code'"
       end
-      File.open File.join('lib', 'code.rb'), 'w' do |f|
+      File.open File.join("lib", "code.rb"), "w" do |f|
         f.puts 'raise "I have an executable"'
       end
     end
@@ -882,15 +1041,15 @@ gem 'other', version
       end
     end
 
-    old_bin_file = File.join installer.bin_dir, 'executable'
+    old_bin_file = File.join installer.bin_dir, "executable"
 
     # build new version that doesn't have a bin file
     installer = util_setup_gem do |spec|
-      FileUtils.rm File.join('bin', 'executable')
-      spec.files.delete File.join('bin', 'executable')
-      spec.executables.delete 'executable'
+      FileUtils.rm File.join("bin", "executable")
+      spec.files.delete File.join("bin", "executable")
+      spec.executables.delete "executable"
       spec.version = @spec.version.bump
-      File.open File.join('lib', 'code.rb'), 'w' do |f|
+      File.open File.join("lib", "code.rb"), "w" do |f|
         f.puts 'raise "I do not have an executable"'
       end
     end
@@ -901,13 +1060,13 @@ gem 'other', version
       end
     end
 
-    e = assert_raises RuntimeError do
+    e = assert_raise RuntimeError do
       instance_eval File.read(old_bin_file)
     end
 
     # We expect the bin stub to activate the version that actually contains
     # the binstub.
-    assert_match('I have an executable', e.message)
+    assert_match("I have an executable", e.message)
   end
 
   def test_install_creates_binstub_that_understand_version
@@ -922,14 +1081,14 @@ gem 'other', version
       end
     end
 
-    exe = File.join @gemhome, 'bin', 'executable'
+    exe = File.join @gemhome, "bin", "executable"
 
     ARGV.unshift "_3.0_"
 
     begin
       Gem::Specification.reset
 
-      e = assert_raises Gem::GemNotFoundException do
+      e = assert_raise Gem::GemNotFoundException do
         instance_eval File.read(exe)
       end
     ensure
@@ -940,11 +1099,17 @@ gem 'other', version
   end
 
   def test_install_creates_binstub_that_prefers_user_installed_gem_to_default
-    install_default_gems new_default_spec('default', '2')
+    default_spec = new_default_spec("default", "2", nil, "exe/executable")
+    default_spec.executables = "executable"
+    install_default_gems default_spec
+
+    exe = File.join @gemhome, "bin", "executable"
+
+    assert_path_exist exe, "default gem's executable not installed"
 
     installer = util_setup_installer do |spec|
-      spec.name = 'default'
-      spec.version = '2'
+      spec.name = "default"
+      spec.version = "2"
     end
 
     util_clear_gems
@@ -958,9 +1123,7 @@ gem 'other', version
       end
     end
 
-    exe = File.join @gemhome, 'bin', 'executable'
-
-    e = assert_raises RuntimeError do
+    e = assert_raise RuntimeError do
       instance_eval File.read(exe)
     end
 
@@ -979,7 +1142,7 @@ gem 'other', version
       end
     end
 
-    exe = File.join @gemhome, 'bin', 'executable'
+    exe = File.join @gemhome, "bin", "executable"
 
     extra_arg = "\xE4pfel".dup.force_encoding("UTF-8")
     ARGV.unshift extra_arg
@@ -987,7 +1150,7 @@ gem 'other', version
     begin
       Gem::Specification.reset
 
-      e = assert_raises RuntimeError do
+      e = assert_raise RuntimeError do
         instance_eval File.read(exe)
       end
     ensure
@@ -1006,16 +1169,16 @@ gem 'other', version
       end
     end
 
-    gemdir = File.join(@gemhome, 'gems', @spec.full_name)
-    assert_path_exists File.join gemdir, 'lib', 'code.rb'
+    gemdir = File.join(@gemhome, "gems", @spec.full_name)
+    assert_path_exist File.join gemdir, "lib", "code.rb"
 
     installer = util_setup_installer
 
     # Morph spec to have lib/other.rb instead of code.rb and recreate
-    @spec.files = File.join('lib', 'other.rb')
+    @spec.files = File.join("lib", "other.rb")
     Dir.chdir @tempdir do
-      File.open File.join('lib', 'other.rb'), 'w' do |f|
-        f.puts '1'
+      File.open File.join("lib", "other.rb"), "w" do |f|
+        f.puts "1"
       end
 
       use_ui ui do
@@ -1023,56 +1186,71 @@ gem 'other', version
         Gem::Package.build @spec
       end
     end
-    installer = Gem::Installer.at @gem
+    installer = Gem::Installer.at @gem, :force => true
     build_rake_in do
       use_ui @ui do
         assert_equal @spec, installer.install
       end
     end
 
-    assert_path_exists File.join gemdir, 'lib', 'other.rb'
-    refute_path_exists File.join gemdir, 'lib', 'code.rb',
+    assert_path_exist File.join gemdir, "lib", "other.rb"
+    assert_path_not_exist File.join gemdir, "lib", "code.rb",
            "code.rb from prior install of same gem shouldn't remain here"
   end
 
   def test_install_force
+    _, missing_dep_gem = util_gem "missing_dep", "1" do |s|
+      s.add_dependency "doesnt_exist", "1"
+    end
+
     use_ui @ui do
-      installer = Gem::Installer.at old_ruby_required('= 1.4.6'), :force => true
+      installer = Gem::Installer.at missing_dep_gem, :force => true
       installer.install
     end
 
-    gem_dir = File.join(@gemhome, 'gems', 'old_ruby_required-1')
-    assert_path_exists gem_dir
+    gem_dir = File.join(@gemhome, "gems", "missing_dep-1")
+    assert_path_exist gem_dir
+  end
+
+  def test_install_build_root
+    build_root = File.join(@tempdir, "build_root")
+
+    @gem = setup_base_gem
+    installer = Gem::Installer.at @gem, :build_root => build_root
+
+    assert_equal @spec, installer.install
   end
 
   def test_install_missing_dirs
     installer = setup_base_installer
 
-    FileUtils.rm_f File.join(Gem.dir, 'cache')
-    FileUtils.rm_f File.join(Gem.dir, 'doc')
-    FileUtils.rm_f File.join(Gem.dir, 'specifications')
+    FileUtils.rm_rf File.join(Gem.dir, "doc")
+    FileUtils.rm_rf File.join(Gem.dir, "specifications")
 
     use_ui @ui do
       installer.install
     end
 
-    assert_directory_exists File.join(Gem.dir, 'cache')
-    assert_directory_exists File.join(Gem.dir, 'doc')
-    assert_directory_exists File.join(Gem.dir, 'specifications')
+    assert_directory_exists File.join(Gem.dir, "doc")
+    assert_directory_exists File.join(Gem.dir, "specifications")
 
-    assert_path_exists File.join @gemhome, 'cache', @spec.file_name
-    assert_path_exists File.join @gemhome, 'specifications', @spec.spec_name
+    assert_path_exist File.join @gemhome, "cache", @spec.file_name
+    assert_path_exist File.join @gemhome, "specifications", @spec.spec_name
   end
 
   def test_install_post_build_false
-    installer = setup_base_installer
+    @spec = util_spec "a"
+
+    util_build_gem @spec
+
+    installer = util_installer @spec, @gemhome
 
     Gem.post_build do
       false
     end
 
     use_ui @ui do
-      e = assert_raises Gem::InstallError do
+      e = assert_raise Gem::InstallError do
         installer.install
       end
 
@@ -1081,11 +1259,11 @@ gem 'other', version
       assert_equal "post-build hook at #{location} failed for a-2", e.message
     end
 
-    spec_file = File.join @gemhome, 'specifications', @spec.spec_name
-    refute_path_exists spec_file
+    spec_file = File.join @gemhome, "specifications", @spec.spec_name
+    assert_path_not_exist spec_file
 
-    gem_dir = File.join @gemhome, 'gems', @spec.full_name
-    refute_path_exists gem_dir
+    gem_dir = File.join @gemhome, "gems", @spec.full_name
+    assert_path_not_exist gem_dir
   end
 
   def test_install_post_build_nil
@@ -1099,22 +1277,26 @@ gem 'other', version
       installer.install
     end
 
-    spec_file = File.join @gemhome, 'specifications', @spec.spec_name
-    assert_path_exists spec_file
+    spec_file = File.join @gemhome, "specifications", @spec.spec_name
+    assert_path_exist spec_file
 
-    gem_dir = File.join @gemhome, 'gems', @spec.full_name
-    assert_path_exists gem_dir
+    gem_dir = File.join @gemhome, "gems", @spec.full_name
+    assert_path_exist gem_dir
   end
 
   def test_install_pre_install_false
-    installer = setup_base_installer
+    @spec = util_spec "a"
+
+    util_build_gem @spec
+
+    installer = util_installer @spec, @gemhome
 
     Gem.pre_install do
       false
     end
 
     use_ui @ui do
-      e = assert_raises Gem::InstallError do
+      e = assert_raise Gem::InstallError do
         installer.install
       end
 
@@ -1123,8 +1305,8 @@ gem 'other', version
       assert_equal "pre-install hook at #{location} failed for a-2", e.message
     end
 
-    spec_file = File.join @gemhome, 'specifications', @spec.spec_name
-    refute_path_exists spec_file
+    spec_file = File.join @gemhome, "specifications", @spec.spec_name
+    assert_path_not_exist spec_file
   end
 
   def test_install_pre_install_nil
@@ -1138,13 +1320,13 @@ gem 'other', version
       installer.install
     end
 
-    spec_file = File.join @gemhome, 'specifications', @spec.spec_name
-    assert_path_exists spec_file
+    spec_file = File.join @gemhome, "specifications", @spec.spec_name
+    assert_path_exist spec_file
   end
 
   def test_install_with_message
     @spec = setup_base_spec
-    @spec.post_install_message = 'I am a shiny gem!'
+    @spec.post_install_message = "I am a shiny gem!"
 
     use_ui @ui do
       path = Gem::Package.build @spec
@@ -1153,12 +1335,12 @@ gem 'other', version
       installer.install
     end
 
-    assert_match %r|I am a shiny gem!|, @ui.output
+    assert_match %r{I am a shiny gem!}, @ui.output
   end
 
   def test_install_with_skipped_message
     @spec = setup_base_spec
-    @spec.post_install_message = 'I am a shiny gem!'
+    @spec.post_install_message = "I am a shiny gem!"
 
     use_ui @ui do
       path = Gem::Package.build @spec
@@ -1167,7 +1349,7 @@ gem 'other', version
       installer.install
     end
 
-    refute_match %r|I am a shiny gem!|, @ui.output
+    refute_match %r{I am a shiny gem!}, @ui.output
   end
 
   def test_install_extension_dir
@@ -1191,9 +1373,9 @@ gem 'other', version
       installer.install
     end
 
-    expected_makefile = File.join gemhome2, 'gems', @spec.full_name, 'Makefile'
+    expected_makefile = File.join gemhome2, "gems", @spec.full_name, "Makefile"
 
-    assert_path_exists expected_makefile
+    assert_path_exist expected_makefile
   end
 
   def test_install_extension_dir_is_removed_on_reinstall
@@ -1222,15 +1404,15 @@ gem 'other', version
     write_file should_be_removed do |io|
       io.write "DELETE ME ON REINSTALL"
     end
-    assert_path_exists should_be_removed
+    assert_path_exist should_be_removed
 
     # reinstall the gem, this is also the same as pristine
     use_ui @ui do
-      installer = Gem::Installer.at path
+      installer = Gem::Installer.at path, :force => true
       installer.install
     end
 
-    refute_path_exists should_be_removed
+    assert_path_not_exist should_be_removed
   end
 
   def test_install_user_extension_dir
@@ -1256,15 +1438,15 @@ gem 'other', version
       installer.install
     end
 
-    expected_makefile = File.join Gem.user_dir, 'gems', @spec.full_name, 'Makefile'
+    expected_makefile = File.join Gem.user_dir, "gems", @spec.full_name, "Makefile"
 
-    assert_path_exists expected_makefile
-    assert_path_exists expected_extension_dir
-    refute_path_exists File.join expected_extension_dir, 'gem_make.out'
+    assert_path_exist expected_makefile
+    assert_path_exist expected_extension_dir
+    assert_path_not_exist File.join expected_extension_dir, "gem_make.out"
   end
 
   def test_find_lib_file_after_install
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
 
     @spec = setup_base_spec
     @spec.extensions << "extconf.rb"
@@ -1290,7 +1472,7 @@ gem 'other', version
     end
 
     Dir.mkdir File.join(@tempdir, "lib")
-    write_file File.join(@tempdir, 'lib', "b.rb") do |io|
+    write_file File.join(@tempdir, "lib", "b.rb") do |io|
       io.write "# b.rb"
     end
 
@@ -1303,14 +1485,15 @@ gem 'other', version
       installer.install
     end
 
-    expected = File.join @spec.full_require_paths.find { |path|
-      File.exist? File.join path, 'b.rb'
-    }, 'b.rb'
-    assert_equal expected, @spec.matches_for_glob('b.rb').first
+    expected = File.join @spec.full_require_paths.find {|path|
+      File.exist? File.join path, "b.rb"
+    }, "b.rb"
+    assert_equal expected, @spec.matches_for_glob("b.rb").first
   end
 
   def test_install_extension_and_script
-    skip "Makefile creation crashes on jruby" if Gem.java_platform?
+    pend "Makefile creation crashes on jruby" if Gem.java_platform?
+    pend if /mswin/ =~ RUBY_PLATFORM && ENV.key?("GITHUB_ACTIONS") # not working from the beginning
 
     @spec = setup_base_spec
     @spec.extensions << "extconf.rb"
@@ -1338,76 +1521,78 @@ gem 'other', version
       RUBY
     end
 
-    refute_path_exists File.join @spec.gem_dir, rb
-    refute_path_exists File.join @spec.gem_dir, rb2
+    assert_path_not_exist File.join @spec.gem_dir, rb
+    assert_path_not_exist File.join @spec.gem_dir, rb2
     use_ui @ui do
       path = Gem::Package.build @spec
 
       installer = Gem::Installer.at path
       installer.install
     end
-    assert_path_exists File.join @spec.gem_dir, rb
-    assert_path_exists File.join @spec.gem_dir, rb2
+    assert_path_exist File.join @spec.gem_dir, rb
+    assert_path_exist File.join @spec.gem_dir, rb2
   end
 
   def test_install_extension_flat
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
 
-    @spec = setup_base_spec
-    @spec.require_paths = ["."]
+    begin
+      @spec = setup_base_spec
+      @spec.require_paths = ["."]
 
-    @spec.extensions << "extconf.rb"
+      @spec.extensions << "extconf.rb"
 
-    write_file File.join(@tempdir, "extconf.rb") do |io|
-      io.write <<-RUBY
-        require "mkmf"
+      write_file File.join(@tempdir, "extconf.rb") do |io|
+        io.write <<-RUBY
+          require "mkmf"
 
-        CONFIG['CC'] = '$(TOUCH) $@ ||'
-        CONFIG['LDSHARED'] = '$(TOUCH) $@ ||'
-        $ruby = '#{Gem.ruby}'
+          CONFIG['CC'] = '$(TOUCH) $@ ||'
+          CONFIG['LDSHARED'] = '$(TOUCH) $@ ||'
+          $ruby = '#{Gem.ruby}'
 
-        create_makefile("#{@spec.name}")
-      RUBY
-    end
+          create_makefile("#{@spec.name}")
+        RUBY
+      end
 
-    # empty depend file for no auto dependencies
-    @spec.files += %W"depend #{@spec.name}.c".each do |file|
-      write_file File.join(@tempdir, file)
-    end
+      # empty depend file for no auto dependencies
+      @spec.files += %W[depend #{@spec.name}.c].each do |file|
+        write_file File.join(@tempdir, file)
+      end
 
-    so = File.join(@spec.gem_dir, "#{@spec.name}.#{RbConfig::CONFIG["DLEXT"]}")
-    refute_path_exists so
-    use_ui @ui do
-      path = Gem::Package.build @spec
+      so = File.join(@spec.gem_dir, "#{@spec.name}.#{RbConfig::CONFIG["DLEXT"]}")
+      assert_path_not_exist so
+      use_ui @ui do
+        path = Gem::Package.build @spec
 
-      installer = Gem::Installer.at path
-      installer.install
-    end
-    assert_path_exists so
-  rescue
-    puts '-' * 78
-    puts File.read File.join(@gemhome, 'gems', 'a-2', 'Makefile')
-    puts '-' * 78
+        installer = Gem::Installer.at path
+        installer.install
+      end
+      assert_path_exist so
+    rescue
+      puts "-" * 78
+      puts File.read File.join(@gemhome, "gems", "a-2", "Makefile")
+      puts "-" * 78
 
-    path = File.join(@gemhome, 'gems', 'a-2', 'gem_make.out')
+      path = File.join(@gemhome, "gems", "a-2", "gem_make.out")
 
-    if File.exist?(path)
-      puts File.read(path)
-      puts '-' * 78
-    end
+      if File.exist?(path)
+        puts File.read(path)
+        puts "-" * 78
+      end
 
-    raise
+      raise
+    end
   end
 
   def test_installation_satisfies_dependency_eh
     installer = setup_base_installer
 
-    util_spec 'a'
+    util_spec "a"
 
-    dep = Gem::Dependency.new 'a', '>= 2'
+    dep = Gem::Dependency.new "a", ">= 2"
     assert installer.installation_satisfies_dependency?(dep)
 
-    dep = Gem::Dependency.new 'a', '> 2'
+    dep = Gem::Dependency.new "a", "> 2"
     refute installer.installation_satisfies_dependency?(dep)
   end
 
@@ -1416,19 +1601,20 @@ gem 'other', version
     installer.options[:development] = true
     installer.options[:dev_shallow] = true
 
-    util_spec 'a'
+    util_spec "a"
 
-    dep = Gem::Dependency.new 'a', :development
+    dep = Gem::Dependency.new "a", :development
     assert installer.installation_satisfies_dependency?(dep)
   end
 
   def test_pre_install_checks_dependencies
     installer = setup_base_installer
-    @spec.add_dependency 'b', '> 5'
+    @spec.add_dependency "b", "> 5"
     installer = util_setup_gem
+    installer.force = false
 
     use_ui @ui do
-      assert_raises Gem::InstallError do
+      assert_raise Gem::InstallError do
         installer.install
       end
     end
@@ -1436,7 +1622,7 @@ gem 'other', version
 
   def test_pre_install_checks_dependencies_ignore
     installer = util_setup_installer
-    @spec.add_dependency 'b', '> 5'
+    @spec.add_dependency "b", "> 5"
     installer.ignore_dependencies = true
 
     build_rake_in do
@@ -1450,16 +1636,16 @@ gem 'other', version
     gemhome2 = "#{@gemhome}2"
 
     @gem = setup_base_gem
-    @spec.add_dependency 'd'
+    @spec.add_dependency "d"
 
-    quick_gem 'd', 2
+    quick_gem "d", 2
 
     gem = File.join @gemhome, @spec.file_name
 
     FileUtils.mv @gemhome, gemhome2
     FileUtils.mkdir @gemhome
 
-    FileUtils.mv File.join(gemhome2, 'cache', @spec.file_name), gem
+    FileUtils.mv File.join(gemhome2, "cache", @spec.file_name), gem
 
     # Don't leak any already activated gems into the installer, require
     # that it work everything out on it's own.
@@ -1474,56 +1660,8 @@ gem 'other', version
     end
   end
 
-  def test_pre_install_checks_ruby_version
-    use_ui @ui do
-      installer = Gem::Installer.at old_ruby_required('= 1.4.6')
-      e = assert_raises Gem::RuntimeRequirementNotMetError do
-        installer.pre_install_checks
-      end
-      rv = Gem.ruby_version
-      assert_equal "old_ruby_required requires Ruby version = 1.4.6. The current ruby version is #{rv}.",
-                   e.message
-    end
-  end
-
-  def test_pre_install_checks_ruby_version_with_prereleases
-    util_set_RUBY_VERSION '2.6.0', -1, '63539', 'ruby 2.6.0preview2 (2018-05-31 trunk 63539) [x86_64-linux]'
-
-    installer = Gem::Installer.at old_ruby_required('>= 2.6.0.preview2')
-    assert installer.pre_install_checks
-
-    installer = Gem::Installer.at old_ruby_required('> 2.6.0.preview2')
-    e = assert_raises Gem::RuntimeRequirementNotMetError do
-      assert installer.pre_install_checks
-    end
-    assert_equal "old_ruby_required requires Ruby version > 2.6.0.preview2. The current ruby version is 2.6.0.preview2.",
-                 e.message
-  ensure
-    util_restore_RUBY_VERSION
-  end
-
-  def test_pre_install_checks_wrong_rubygems_version
-    spec = util_spec 'old_rubygems_required', '1' do |s|
-      s.required_rubygems_version = '< 0'
-    end
-
-    util_build_gem spec
-
-    gem = File.join(@gemhome, 'cache', spec.file_name)
-
-    use_ui @ui do
-      installer = Gem::Installer.at gem
-      e = assert_raises Gem::RuntimeRequirementNotMetError do
-        installer.pre_install_checks
-      end
-      rgv = Gem::VERSION
-      assert_equal "old_rubygems_required requires RubyGems version < 0. The current RubyGems version is #{rgv}. " +
-        "Try 'gem update --system' to update RubyGems itself.", e.message
-    end
-  end
-
   def test_pre_install_checks_malicious_name
-    spec = util_spec '../malicious', '1'
+    spec = util_spec "../malicious", "1"
     def spec.full_name # so the spec is buildable
       "malicious-1"
     end
@@ -1531,19 +1669,19 @@ gem 'other', version
 
     util_build_gem spec
 
-    gem = File.join(@gemhome, 'cache', spec.file_name)
+    gem = File.join(@gemhome, "cache", spec.file_name)
 
     use_ui @ui do
       installer = Gem::Installer.at gem
-      e = assert_raises Gem::InstallError do
+      e = assert_raise Gem::InstallError do
         installer.pre_install_checks
       end
-      assert_equal '#<Gem::Specification name=../malicious version=1> has an invalid name', e.message
+      assert_equal "#<Gem::Specification name=../malicious version=1> has an invalid name", e.message
     end
   end
 
   def test_pre_install_checks_malicious_name_before_eval
-    spec = util_spec "malicious\n::Object.const_set(:FROM_EVAL, true)#", '1'
+    spec = util_spec "malicious\n::Object.const_set(:FROM_EVAL, true)#", "1"
     def spec.full_name # so the spec is buildable
       "malicious-1"
     end
@@ -1551,11 +1689,11 @@ gem 'other', version
 
     util_build_gem spec
 
-    gem = File.join(@gemhome, 'cache', spec.file_name)
+    gem = File.join(@gemhome, "cache", spec.file_name)
 
     use_ui @ui do
       installer = Gem::Installer.at gem
-      e = assert_raises Gem::InstallError do
+      e = assert_raise Gem::InstallError do
         installer.pre_install_checks
       end
       assert_equal "#<Gem::Specification name=malicious\n::Object.const_set(:FROM_EVAL, true)# version=1> has an invalid name", e.message
@@ -1564,7 +1702,7 @@ gem 'other', version
   end
 
   def test_pre_install_checks_malicious_require_paths_before_eval
-    spec = util_spec "malicious", '1'
+    spec = util_spec "malicious", "1"
     def spec.full_name # so the spec is buildable
       "malicious-1"
     end
@@ -1573,11 +1711,11 @@ gem 'other', version
 
     util_build_gem spec
 
-    gem = File.join(@gemhome, 'cache', spec.file_name)
+    gem = File.join(@gemhome, "cache", spec.file_name)
 
     use_ui @ui do
       installer = Gem::Installer.at gem
-      e = assert_raises Gem::InstallError do
+      e = assert_raise Gem::InstallError do
         installer.pre_install_checks
       end
       assert_equal "#<Gem::Specification name=malicious version=1> has an invalid require_paths", e.message
@@ -1585,9 +1723,9 @@ gem 'other', version
   end
 
   def test_pre_install_checks_malicious_extensions_before_eval
-    skip "mswin environment disallow to create file contained the carriage return code." if Gem.win_platform?
+    pend "mswin environment disallow to create file contained the carriage return code." if Gem.win_platform?
 
-    spec = util_spec "malicious", '1'
+    spec = util_spec "malicious", "1"
     def spec.full_name # so the spec is buildable
       "malicious-1"
     end
@@ -1596,11 +1734,11 @@ gem 'other', version
 
     util_build_gem spec
 
-    gem = File.join(@gemhome, 'cache', spec.file_name)
+    gem = File.join(@gemhome, "cache", spec.file_name)
 
     use_ui @ui do
       installer = Gem::Installer.at gem
-      e = assert_raises Gem::InstallError do
+      e = assert_raise Gem::InstallError do
         installer.pre_install_checks
       end
       assert_equal "#<Gem::Specification name=malicious version=1> has an invalid extensions", e.message
@@ -1608,7 +1746,7 @@ gem 'other', version
   end
 
   def test_pre_install_checks_malicious_specification_version_before_eval
-    spec = util_spec "malicious", '1'
+    spec = util_spec "malicious", "1"
     def spec.full_name # so the spec is buildable
       "malicious-1"
     end
@@ -1617,11 +1755,11 @@ gem 'other', version
 
     util_build_gem spec
 
-    gem = File.join(@gemhome, 'cache', spec.file_name)
+    gem = File.join(@gemhome, "cache", spec.file_name)
 
     use_ui @ui do
       installer = Gem::Installer.at gem
-      e = assert_raises Gem::InstallError do
+      e = assert_raise Gem::InstallError do
         installer.pre_install_checks
       end
       assert_equal "#<Gem::Specification name=malicious version=1> has an invalid specification_version", e.message
@@ -1629,196 +1767,332 @@ gem 'other', version
   end
 
   def test_pre_install_checks_malicious_dependencies_before_eval
-    spec = util_spec "malicious", '1'
+    spec = util_spec "malicious", "1"
     def spec.full_name # so the spec is buildable
       "malicious-1"
     end
     def spec.validate(*args); end
-    spec.add_dependency "b\nfoo", '> 5'
+    spec.add_dependency "b\nfoo", "> 5"
 
     util_build_gem spec
 
-    gem = File.join(@gemhome, 'cache', spec.file_name)
+    gem = File.join(@gemhome, "cache", spec.file_name)
 
     use_ui @ui do
       installer = Gem::Installer.at gem
       installer.ignore_dependencies = true
-      e = assert_raises Gem::InstallError do
+      e = assert_raise Gem::InstallError do
         installer.pre_install_checks
       end
       assert_equal "#<Gem::Specification name=malicious version=1> has an invalid dependencies", e.message
     end
   end
 
+  def test_pre_install_checks_malicious_platform_before_eval
+    gem_with_ill_formated_platform = File.expand_path("packages/ill-formatted-platform-1.0.0.10.gem", __dir__)
+
+    installer = Gem::Installer.at(
+      gem_with_ill_formated_platform,
+      :install_dir => @gem_home,
+      :user_install => false,
+      :force => true
+    )
+
+    use_ui @ui do
+      e = assert_raise Gem::InstallError do
+        installer.pre_install_checks
+      end
+
+      assert_equal "x86-mswin32\n system('id > /tmp/nyangawa')# is an invalid platform", e.message
+      assert_empty @ui.output
+    end
+  end
+
   def test_shebang
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, "#!/usr/bin/ruby"
+      util_make_exec @spec, "#!/usr/bin/ruby"
 
-    shebang = installer.shebang 'executable'
+      shebang = installer.shebang "executable"
 
-    assert_equal "#!#{Gem.ruby}", shebang
+      assert_equal "#!#{Gem.ruby}", shebang
+    end
   end
 
   def test_process_options
     installer = setup_base_installer
 
     assert_nil installer.build_root
-    assert_equal File.join(@gemhome, 'bin'), installer.bin_dir
+    assert_equal File.join(@gemhome, "bin"), installer.bin_dir
     assert_equal @gemhome, installer.gem_home
   end
 
   def test_process_options_build_root
-    build_root = File.join @tempdir, 'build_root'
+    build_root = File.join @tempdir, "build_root"
+    bin_dir = File.join(build_root, @gemhome.gsub(/^[a-zA-Z]:/, ""), "bin")
+    gem_home = File.join(build_root, @gemhome.gsub(/^[a-zA-Z]:/, ""))
+    plugins_dir = File.join(build_root, @gemhome.gsub(/^[a-zA-Z]:/, ""), "plugins")
 
     @gem = setup_base_gem
-    installer = Gem::Installer.at @gem, :build_root => build_root
+    installer = use_ui(@ui) { Gem::Installer.at @gem, :build_root => build_root }
 
-    assert_equal Pathname(build_root), installer.build_root
-    assert_equal File.join(build_root, @gemhome, 'bin'), installer.bin_dir
-    assert_equal File.join(build_root, @gemhome), installer.gem_home
+    assert_equal build_root, installer.build_root
+    assert_equal bin_dir, installer.bin_dir
+    assert_equal gem_home, installer.gem_home
+
+    errors = @ui.error.split("\n")
+
+    assert_equal "WARNING:  You build with buildroot.", errors.shift
+    assert_equal "  Build root: #{build_root}", errors.shift
+    assert_equal "  Bin dir: #{bin_dir}", errors.shift
+    assert_equal "  Gem home: #{gem_home}", errors.shift
+    assert_equal "  Plugins dir: #{plugins_dir}", errors.shift
   end
 
   def test_shebang_arguments
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, "#!/usr/bin/ruby -ws"
+      util_make_exec @spec, "#!/usr/bin/ruby -ws"
 
-    shebang = installer.shebang 'executable'
+      shebang = installer.shebang "executable"
 
-    assert_equal "#!#{Gem.ruby} -ws", shebang
+      assert_equal "#!#{Gem.ruby} -ws", shebang
+    end
+  end
+
+  def test_shebang_arguments_with_load_relative
+    load_relative "yes" do
+      installer = setup_base_installer
+
+      util_make_exec @spec, "#!/usr/bin/ruby -ws"
+
+      shebang = installer.shebang "executable"
+
+      shebang_lines = shebang.split "\n"
+
+      assert_equal "#!/bin/sh", shebang_lines.shift
+      assert_includes shebang_lines, "#!#{Gem.ruby} -ws"
+    end
   end
 
   def test_shebang_empty
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, ''
+      util_make_exec @spec, ""
 
-    shebang = installer.shebang 'executable'
-    assert_equal "#!#{Gem.ruby}", shebang
+      shebang = installer.shebang "executable"
+      assert_equal "#!#{Gem.ruby}", shebang
+    end
   end
 
   def test_shebang_env
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, "#!/usr/bin/env ruby"
+      util_make_exec @spec, "#!/usr/bin/env ruby"
 
-    shebang = installer.shebang 'executable'
+      shebang = installer.shebang "executable"
 
-    assert_equal "#!#{Gem.ruby}", shebang
+      assert_equal "#!#{Gem.ruby}", shebang
+    end
   end
 
   def test_shebang_env_arguments
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, "#!/usr/bin/env ruby -ws"
+      util_make_exec @spec, "#!/usr/bin/env ruby -ws"
 
-    shebang = installer.shebang 'executable'
+      shebang = installer.shebang "executable"
 
-    assert_equal "#!#{Gem.ruby} -ws", shebang
+      assert_equal "#!#{Gem.ruby} -ws", shebang
+    end
+  end
+
+  def test_shebang_env_arguments_with_load_relative
+    load_relative "yes" do
+      installer = setup_base_installer
+
+      util_make_exec @spec, "#!/usr/bin/env ruby -ws"
+
+      shebang = installer.shebang "executable"
+
+      shebang_lines = shebang.split "\n"
+
+      assert_equal "#!/bin/sh", shebang_lines.shift
+      assert_includes shebang_lines, "#!#{Gem.ruby} -ws"
+    end
   end
 
   def test_shebang_env_shebang
     installer = setup_base_installer
 
-    util_make_exec @spec, ''
+    util_make_exec @spec, ""
     installer.env_shebang = true
 
-    shebang = installer.shebang 'executable'
+    shebang = installer.shebang "executable"
 
-    env_shebang = "/usr/bin/env" unless Gem.win_platform?
+    bin_env = get_bin_env
 
-    assert_equal("#!#{env_shebang} #{RbConfig::CONFIG['ruby_install_name']}",
+    assert_equal("#!#{bin_env} #{RbConfig::CONFIG['ruby_install_name']}",
                  shebang)
   end
 
   def test_shebang_nested
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, "#!/opt/local/ruby/bin/ruby"
+      util_make_exec @spec, "#!/opt/local/ruby/bin/ruby"
 
-    shebang = installer.shebang 'executable'
+      shebang = installer.shebang "executable"
 
-    assert_equal "#!#{Gem.ruby}", shebang
+      assert_equal "#!#{Gem.ruby}", shebang
+    end
   end
 
   def test_shebang_nested_arguments
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
+
+      util_make_exec @spec, "#!/opt/local/ruby/bin/ruby -ws"
+
+      shebang = installer.shebang "executable"
+
+      assert_equal "#!#{Gem.ruby} -ws", shebang
+    end
+  end
+
+  def test_shebang_nested_arguments_with_load_relative
+    load_relative "yes" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, "#!/opt/local/ruby/bin/ruby -ws"
+      util_make_exec @spec, "#!/opt/local/ruby/bin/ruby -ws"
 
-    shebang = installer.shebang 'executable'
+      shebang = installer.shebang "executable"
 
-    assert_equal "#!#{Gem.ruby} -ws", shebang
+      shebang_lines = shebang.split "\n"
+
+      assert_equal "#!/bin/sh", shebang_lines.shift
+      assert_includes shebang_lines, "#!#{Gem.ruby} -ws"
+    end
   end
 
   def test_shebang_version
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, "#!/usr/bin/ruby18"
+      util_make_exec @spec, "#!/usr/bin/ruby18"
 
-    shebang = installer.shebang 'executable'
+      shebang = installer.shebang "executable"
 
-    assert_equal "#!#{Gem.ruby}", shebang
+      assert_equal "#!#{Gem.ruby}", shebang
+    end
   end
 
   def test_shebang_version_arguments
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, "#!/usr/bin/ruby18 -ws"
+      util_make_exec @spec, "#!/usr/bin/ruby18 -ws"
 
-    shebang = installer.shebang 'executable'
+      shebang = installer.shebang "executable"
 
-    assert_equal "#!#{Gem.ruby} -ws", shebang
+      assert_equal "#!#{Gem.ruby} -ws", shebang
+    end
+  end
+
+  def test_shebang_version_arguments_with_load_relative
+    load_relative "yes" do
+      installer = setup_base_installer
+
+      util_make_exec @spec, "#!/usr/bin/ruby18 -ws"
+
+      shebang = installer.shebang "executable"
+
+      shebang_lines = shebang.split "\n"
+
+      assert_equal "#!/bin/sh", shebang_lines.shift
+      assert_includes shebang_lines, "#!#{Gem.ruby} -ws"
+    end
   end
 
   def test_shebang_version_env
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, "#!/usr/bin/env ruby18"
+      util_make_exec @spec, "#!/usr/bin/env ruby18"
 
-    shebang = installer.shebang 'executable'
+      shebang = installer.shebang "executable"
 
-    assert_equal "#!#{Gem.ruby}", shebang
+      assert_equal "#!#{Gem.ruby}", shebang
+    end
   end
 
   def test_shebang_version_env_arguments
-    installer = setup_base_installer
+    load_relative "no" do
+      installer = setup_base_installer
 
-    util_make_exec @spec, "#!/usr/bin/env ruby18 -ws"
+      util_make_exec @spec, "#!/usr/bin/env ruby18 -ws"
 
-    shebang = installer.shebang 'executable'
+      shebang = installer.shebang "executable"
 
-    assert_equal "#!#{Gem.ruby} -ws", shebang
+      assert_equal "#!#{Gem.ruby} -ws", shebang
+    end
+  end
+
+  def test_shebang_version_env_arguments_with_load_relative
+    load_relative "yes" do
+      installer = setup_base_installer
+
+      util_make_exec @spec, "#!/usr/bin/env ruby18 -ws"
+
+      shebang = installer.shebang "executable"
+
+      shebang_lines = shebang.split "\n"
+
+      assert_equal "#!/bin/sh", shebang_lines.shift
+      assert_includes shebang_lines, "#!#{Gem.ruby} -ws"
+    end
   end
 
   def test_shebang_custom
     installer = setup_base_installer
 
     conf = Gem::ConfigFile.new []
-    conf[:custom_shebang] = 'test'
+    conf[:custom_shebang] = "test"
 
     Gem.configuration = conf
 
     util_make_exec @spec, "#!/usr/bin/ruby"
 
-    shebang = installer.shebang 'executable'
+    shebang = installer.shebang "executable"
 
     assert_equal "#!test", shebang
   end
 
+  def get_bin_env
+    if win_platform?
+      ""
+    else
+      %w[/usr/bin/env /bin/env].find {|f| File.executable?(f) }
+    end
+  end
+
   def test_shebang_custom_with_expands
     installer = setup_base_installer
 
-    bin_env = win_platform? ? '' : '/usr/bin/env'
+    bin_env = get_bin_env
     conf = Gem::ConfigFile.new []
-    conf[:custom_shebang] = '1 $env 2 $ruby 3 $exec 4 $name'
+    conf[:custom_shebang] = "1 $env 2 $ruby 3 $exec 4 $name"
 
     Gem.configuration = conf
 
     util_make_exec @spec, "#!/usr/bin/ruby"
 
-    shebang = installer.shebang 'executable'
+    shebang = installer.shebang "executable"
 
     assert_equal "#!1 #{bin_env} 2 #{Gem.ruby} 3 executable 4 a", shebang
   end
@@ -1826,15 +2100,15 @@ gem 'other', version
   def test_shebang_custom_with_expands_and_arguments
     installer = setup_base_installer
 
-    bin_env = win_platform? ? '' : '/usr/bin/env'
+    bin_env = get_bin_env
     conf = Gem::ConfigFile.new []
-    conf[:custom_shebang] = '1 $env 2 $ruby 3 $exec'
+    conf[:custom_shebang] = "1 $env 2 $ruby 3 $exec"
 
     Gem.configuration = conf
 
     util_make_exec @spec, "#!/usr/bin/ruby -ws"
 
-    shebang = installer.shebang 'executable'
+    shebang = installer.shebang "executable"
 
     assert_equal "#!1 #{bin_env} 2 #{Gem.ruby} -ws 3 executable", shebang
   end
@@ -1842,20 +2116,20 @@ gem 'other', version
   def test_unpack
     installer = util_setup_installer
 
-    dest = File.join @gemhome, 'gems', @spec.full_name
+    dest = File.join @gemhome, "gems", @spec.full_name
 
     Gem::Deprecate.skip_during do
       installer.unpack dest
     end
 
-    assert_path_exists File.join dest, 'lib', 'code.rb'
-    assert_path_exists File.join dest, 'bin', 'executable'
+    assert_path_exist File.join dest, "lib", "code.rb"
+    assert_path_exist File.join dest, "bin", "executable"
   end
 
   def test_write_build_info_file
     installer = setup_base_installer
 
-    refute_path_exists @spec.build_info_file
+    assert_path_not_exist @spec.build_info_file
 
     installer.build_args = %w[
       --with-libyaml-dir /usr/local/Cellar/libyaml/0.1.4
@@ -1863,7 +2137,7 @@ gem 'other', version
 
     installer.write_build_info_file
 
-    assert_path_exists @spec.build_info_file
+    assert_path_exist @spec.build_info_file
 
     expected = "--with-libyaml-dir\n/usr/local/Cellar/libyaml/0.1.4\n"
 
@@ -1873,11 +2147,11 @@ gem 'other', version
   def test_write_build_info_file_empty
     installer = setup_base_installer
 
-    refute_path_exists @spec.build_info_file
+    assert_path_not_exist @spec.build_info_file
 
     installer.write_build_info_file
 
-    refute_path_exists @spec.build_info_file
+    assert_path_not_exist @spec.build_info_file
   end
 
   def test_write_build_info_file_install_dir
@@ -1890,38 +2164,38 @@ gem 'other', version
 
     installer.write_build_info_file
 
-    refute_path_exists @spec.build_info_file
-    assert_path_exists \
-      File.join("#{@gemhome}2", 'build_info', "#{@spec.full_name}.info")
+    assert_path_not_exist @spec.build_info_file
+    assert_path_exist \
+      File.join("#{@gemhome}2", "build_info", "#{@spec.full_name}.info")
   end
 
   def test_write_cache_file
     @gem = setup_base_gem
-    cache_file = File.join @gemhome, 'cache', @spec.file_name
+    cache_file = File.join @gemhome, "cache", @spec.file_name
     gem = File.join @gemhome, @spec.file_name
 
     FileUtils.mv cache_file, gem
-    refute_path_exists cache_file
+    assert_path_not_exist cache_file
 
     installer = Gem::Installer.at gem
     installer.gem_home = @gemhome
 
     installer.write_cache_file
 
-    assert_path_exists cache_file
+    assert_path_exist cache_file
   end
 
   def test_write_spec
     @spec = setup_base_spec
     FileUtils.rm @spec.spec_file
-    refute_path_exists @spec.spec_file
+    assert_path_not_exist @spec.spec_file
 
     installer = Gem::Installer.for_spec @spec
     installer.gem_home = @gemhome
 
     installer.write_spec
 
-    assert_path_exists @spec.spec_file
+    assert_path_exist @spec.spec_file
 
     loaded = Gem::Specification.load @spec.spec_file
 
@@ -1933,7 +2207,7 @@ gem 'other', version
   def test_write_spec_writes_cached_spec
     @spec = setup_base_spec
     FileUtils.rm @spec.spec_file
-    refute_path_exists @spec.spec_file
+    assert_path_not_exist @spec.spec_file
 
     @spec.files = %w[a.rb b.rb c.rb]
 
@@ -1951,11 +2225,11 @@ gem 'other', version
   def test_dir
     installer = setup_base_installer
 
-    assert_match %r!/gemhome/gems/a-2$!, installer.dir
+    assert_match %r{/gemhome/gems/a-2$}, installer.dir
   end
 
   def test_default_gem_loaded_from
-    spec = util_spec 'a'
+    spec = util_spec "a"
     installer = Gem::Installer.for_spec spec, :install_as_default => true
     installer.install
     assert_predicate spec, :default_gem?
@@ -1964,7 +2238,7 @@ gem 'other', version
   def test_default_gem_without_wrappers
     installer = setup_base_installer
 
-    FileUtils.rm_f File.join(Gem.dir, 'specifications')
+    FileUtils.rm_rf File.join(Gem.default_dir, "specifications")
 
     installer.wrappers = false
     installer.options[:install_as_default] = true
@@ -1974,24 +2248,30 @@ gem 'other', version
       installer.install
     end
 
-    assert_directory_exists File.join(@spec.gem_dir, 'bin')
-    installed_exec = File.join @spec.gem_dir, 'bin', 'executable'
-    assert_path_exists installed_exec
+    assert_directory_exists File.join(@spec.gem_dir, "bin")
+    installed_exec = File.join @spec.gem_dir, "bin", "executable"
+    assert_path_exist installed_exec
 
-    assert_directory_exists File.join(Gem.default_dir, 'specifications')
-    assert_directory_exists File.join(Gem.default_dir, 'specifications', 'default')
+    assert_directory_exists File.join(Gem.default_dir, "specifications")
+    assert_directory_exists File.join(Gem.default_dir, "specifications", "default")
 
-    default_spec = eval File.read File.join(Gem.default_dir, 'specifications', 'default', 'a-2.gemspec')
+    default_spec = eval File.read File.join(Gem.default_dir, "specifications", "default", "a-2.gemspec")
     assert_equal Gem::Version.new("2"), default_spec.version
-    assert_equal ['bin/executable'], default_spec.files
+    assert_equal ["bin/executable"], default_spec.files
 
     assert_directory_exists util_inst_bindir
 
-    installed_exec = File.join util_inst_bindir, 'executable'
-    assert_path_exists installed_exec
+    installed_exec = File.join util_inst_bindir, "executable"
+    assert_path_exist installed_exec
 
     wrapper = File.read installed_exec
-    refute_match %r|generated by RubyGems|, wrapper
+
+    if symlink_supported?
+      refute_match %r{generated by RubyGems}, wrapper
+    else # when symlink not supported, it warns and fallbacks back to installing wrapper
+      assert_match %r{Unable to use symlinks, installing wrapper}, @ui.error
+      assert_match %r{generated by RubyGems}, wrapper
+    end
   end
 
   def test_default_gem_with_wrappers
@@ -2007,16 +2287,16 @@ gem 'other', version
 
     assert_directory_exists util_inst_bindir
 
-    installed_exec = File.join util_inst_bindir, 'executable'
-    assert_path_exists installed_exec
+    installed_exec = File.join util_inst_bindir, "executable"
+    assert_path_exist installed_exec
 
     wrapper = File.read installed_exec
-    assert_match %r|generated by RubyGems|, wrapper
+    assert_match %r{generated by RubyGems}, wrapper
   end
 
   def test_default_gem_with_exe_as_bindir
-    @spec = quick_gem 'c' do |spec|
-      util_make_exec spec, '#!/usr/bin/ruby', 'exe'
+    @spec = quick_gem "c" do |spec|
+      util_make_exec spec, "#!/usr/bin/ruby", "exe"
     end
 
     util_build_gem @spec
@@ -2032,21 +2312,38 @@ gem 'other', version
       installer.install
     end
 
-    assert_directory_exists File.join(@spec.gem_dir, 'exe')
-    installed_exec = File.join @spec.gem_dir, 'exe', 'executable'
-    assert_path_exists installed_exec
+    assert_directory_exists File.join(@spec.gem_dir, "exe")
+    installed_exec = File.join @spec.gem_dir, "exe", "executable"
+    assert_path_exist installed_exec
 
-    assert_directory_exists File.join(Gem.default_dir, 'specifications')
-    assert_directory_exists File.join(Gem.default_dir, 'specifications', 'default')
+    assert_directory_exists File.join(Gem.default_dir, "specifications")
+    assert_directory_exists File.join(Gem.default_dir, "specifications", "default")
 
-    default_spec = eval File.read File.join(Gem.default_dir, 'specifications', 'default', 'c-2.gemspec')
+    default_spec = eval File.read File.join(Gem.default_dir, "specifications", "default", "c-2.gemspec")
     assert_equal Gem::Version.new("2"), default_spec.version
-    assert_equal ['exe/executable'], default_spec.files
+    assert_equal ["exe/executable"], default_spec.files
+  end
+
+  def test_default_gem_to_specific_install_dir
+    @gem = setup_base_gem
+    installer = util_installer @spec, "#{@gemhome}2"
+    installer.options[:install_as_default] = true
+
+    use_ui @ui do
+      installer.install
+    end
+
+    assert_directory_exists File.join("#{@gemhome}2", "specifications")
+    assert_directory_exists File.join("#{@gemhome}2", "specifications", "default")
+
+    default_spec = eval File.read File.join("#{@gemhome}2", "specifications", "default", "a-2.gemspec")
+    assert_equal Gem::Version.new("2"), default_spec.version
+    assert_equal ["bin/executable"], default_spec.files
   end
 
   def test_package_attribute
-    gem = quick_gem 'c' do |spec|
-      util_make_exec spec, '#!/usr/bin/ruby', 'exe'
+    gem = quick_gem "c" do |spec|
+      util_make_exec spec, "#!/usr/bin/ruby", "exe"
     end
 
     installer = util_installer(gem, @gemhome)
@@ -2054,25 +2351,27 @@ gem 'other', version
     assert_kind_of(Gem::Package, installer.package)
   end
 
-  def old_ruby_required(requirement)
-    spec = util_spec 'old_ruby_required', '1' do |s|
-      s.required_ruby_version = requirement
+  def test_gem_attribute
+    gem = quick_gem "c" do |spec|
+      util_make_exec spec, "#!/usr/bin/ruby", "exe"
     end
 
-    util_build_gem spec
-
-    spec.cache_file
+    installer = util_installer(gem, @gemhome)
+    assert_respond_to(installer, :gem)
+    assert_kind_of(String, installer.gem)
   end
 
+  private
+
   def util_execless
-    @spec = util_spec 'z'
+    @spec = util_spec "z"
     util_build_gem @spec
 
     util_installer @spec, @gemhome
   end
 
   def util_conflict_executable(wrappers)
-    conflict = quick_gem 'conflict' do |spec|
+    conflict = quick_gem "conflict" do |spec|
       util_make_exec spec
     end
 
@@ -2084,7 +2383,15 @@ gem 'other', version
   end
 
   def mask
-    0100755 & (~File.umask)
+    0100755
   end
 
+  def load_relative(value)
+    orig_LIBRUBY_RELATIVE = RbConfig::CONFIG["LIBRUBY_RELATIVE"]
+    RbConfig::CONFIG["LIBRUBY_RELATIVE"] = value
+
+    yield
+  ensure
+    RbConfig::CONFIG["LIBRUBY_RELATIVE"] = orig_LIBRUBY_RELATIVE
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_local_remote_options.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_local_remote_options.rb
@@ -1,14 +1,13 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/local_remote_options'
-require 'rubygems/command'
+require_relative "helper"
+require "rubygems/local_remote_options"
+require "rubygems/command"
 
 class TestGemLocalRemoteOptions < Gem::TestCase
-
   def setup
     super
 
-    @cmd = Gem::Command.new 'dummy', 'dummy'
+    @cmd = Gem::Command.new "dummy", "dummy"
     @cmd.extend Gem::LocalRemoteOptions
   end
 
@@ -76,10 +75,10 @@ class TestGemLocalRemoteOptions < Gem::T
   def test_source_option
     @cmd.add_source_option
 
-    s1 = URI.parse 'http://more-gems.example.com/'
-    s2 = URI.parse 'http://even-more-gems.example.com/'
-    s3 = URI.parse 'http://other-gems.example.com/some_subdir'
-    s4 = URI.parse 'http://more-gems.example.com/' # Intentional duplicate
+    s1 = URI.parse "http://more-gems.example.com/"
+    s2 = URI.parse "http://even-more-gems.example.com/"
+    s3 = URI.parse "http://other-gems.example.com/some_subdir"
+    s4 = URI.parse "http://more-gems.example.com/" # Intentional duplicate
 
     original_sources = Gem.sources.dup
 
@@ -97,7 +96,7 @@ class TestGemLocalRemoteOptions < Gem::T
 
     original_sources = Gem.sources.dup
 
-    source = URI.parse 'http://more-gems.example.com/'
+    source = URI.parse "http://more-gems.example.com/"
     @cmd.handle_options %W[-s #{source}]
 
     original_sources << source
@@ -122,13 +121,12 @@ class TestGemLocalRemoteOptions < Gem::T
   def test_source_option_bad
     @cmd.add_source_option
 
-    s1 = 'htp://more-gems.example.com'
+    s1 = "htp://more-gems.example.com"
 
-    assert_raises ArgumentError do
+    assert_raise ArgumentError do
       @cmd.handle_options %W[--source #{s1}]
     end
 
     assert_equal [@gem_repo], Gem.sources
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_name_tuple.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_name_tuple.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/name_tuple'
+require_relative "helper"
+require "rubygems/name_tuple"
 
 class TestGemNameTuple < Gem::TestCase
-
   def test_full_name
     n = Gem::NameTuple.new "a", Gem::Version.new(0), "ruby"
     assert_equal "a-0", n.full_name
@@ -35,10 +34,9 @@ class TestGemNameTuple < Gem::TestCase
   end
 
   def test_spaceship
-    a   = Gem::NameTuple.new 'a', Gem::Version.new(0), Gem::Platform::RUBY
-    a_p = Gem::NameTuple.new 'a', Gem::Version.new(0), Gem::Platform.local
+    a   = Gem::NameTuple.new "a", Gem::Version.new(0), Gem::Platform::RUBY
+    a_p = Gem::NameTuple.new "a", Gem::Version.new(0), Gem::Platform.local
 
     assert_equal 1, a_p.<=>(a)
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_package.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_package.rb
@@ -1,16 +1,14 @@
-# coding: utf-8
 # frozen_string_literal: true
 
-require 'rubygems/package/tar_test_case'
-require 'digest'
+require_relative "package/tar_test_case"
+require "rubygems/openssl"
 
 class TestGemPackage < Gem::Package::TarTestCase
-
   def setup
     super
 
-    @spec = quick_gem 'a' do |s|
-      s.description = ''
+    @spec = quick_gem "a" do |s|
+      s.description = ""
       s.files = %w[lib/code.rb]
     end
 
@@ -18,19 +16,19 @@ class TestGemPackage < Gem::Package::Tar
 
     @gem = @spec.cache_file
 
-    @destination = File.join @tempdir, 'extract'
+    @destination = File.join @tempdir, "extract"
 
     FileUtils.mkdir_p @destination
   end
 
   def test_class_new_old_format
-    skip "jruby can't require the simple_gem file" if Gem.java_platform?
+    pend "jruby can't require the simple_gem file" if Gem.java_platform?
     require_relative "simple_gem"
-    File.open 'old_format.gem', 'wb' do |io|
+    File.open "old_format.gem", "wb" do |io|
       io.write SIMPLE_GEM
     end
 
-    package = Gem::Package.new 'old_format.gem'
+    package = Gem::Package.new "old_format.gem"
 
     assert package.spec
   end
@@ -38,17 +36,17 @@ class TestGemPackage < Gem::Package::Tar
   def test_add_checksums
     gem_io = StringIO.new
 
-    spec = Gem::Specification.new 'build', '1'
-    spec.summary = 'build'
-    spec.authors = 'build'
-    spec.files = ['lib/code.rb']
+    spec = Gem::Specification.new "build", "1"
+    spec.summary = "build"
+    spec.authors = "build"
+    spec.files = ["lib/code.rb"]
     spec.date = Time.at 0
-    spec.rubygems_version = Gem::Version.new '0'
+    spec.rubygems_version = Gem::Version.new "0"
 
-    FileUtils.mkdir 'lib'
+    FileUtils.mkdir "lib"
 
-    File.open 'lib/code.rb', 'w' do |io|
-      io.write '# lib/code.rb'
+    File.open "lib/code.rb", "w" do |io|
+      io.write "# lib/code.rb"
     end
 
     package = Gem::Package.new spec.file_name
@@ -71,11 +69,11 @@ class TestGemPackage < Gem::Package::Tar
 
     reader.each_entry do |entry|
       case entry.full_name
-      when 'checksums.yaml.gz' then
+      when "checksums.yaml.gz" then
         Zlib::GzipReader.wrap entry do |io|
           checksums = io.read
         end
-      when 'data.tar.gz' then
+      when "data.tar.gz" then
         tar = entry.read
       end
     end
@@ -86,36 +84,33 @@ class TestGemPackage < Gem::Package::Tar
       io.write spec.to_yaml
     end
 
-    metadata_sha256 = Digest::SHA256.hexdigest s.string
-    metadata_sha512 = Digest::SHA512.hexdigest s.string
+    metadata_sha256 = OpenSSL::Digest::SHA256.hexdigest s.string
+    metadata_sha512 = OpenSSL::Digest::SHA512.hexdigest s.string
 
     expected = {
-      'SHA512' => {
-        'metadata.gz' => metadata_sha512,
-        'data.tar.gz' => Digest::SHA512.hexdigest(tar),
-      }
+      "SHA512" => {
+        "metadata.gz" => metadata_sha512,
+        "data.tar.gz" => OpenSSL::Digest::SHA512.hexdigest(tar),
+      },
+      "SHA256" => {
+        "metadata.gz" => metadata_sha256,
+        "data.tar.gz" => OpenSSL::Digest::SHA256.hexdigest(tar),
+      },
     }
 
-    if defined?(OpenSSL::Digest)
-      expected['SHA256'] = {
-        'metadata.gz' => metadata_sha256,
-        'data.tar.gz' => Digest::SHA256.hexdigest(tar),
-      }
-    end
-
-    assert_equal expected, YAML.load(checksums)
+    assert_equal expected, load_yaml(checksums)
   end
 
   def test_build_time_uses_source_date_epoch
     epoch = ENV["SOURCE_DATE_EPOCH"]
     ENV["SOURCE_DATE_EPOCH"] = "123456789"
 
-    spec = Gem::Specification.new 'build', '1'
-    spec.summary = 'build'
-    spec.authors = 'build'
-    spec.files = ['lib/code.rb']
+    spec = Gem::Specification.new "build", "1"
+    spec.summary = "build"
+    spec.authors = "build"
+    spec.files = ["lib/code.rb"]
     spec.date = Time.at 0
-    spec.rubygems_version = Gem::Version.new '0'
+    spec.rubygems_version = Gem::Version.new "0"
 
     package = Gem::Package.new spec.file_name
 
@@ -128,11 +123,11 @@ class TestGemPackage < Gem::Package::Tar
     epoch = ENV["SOURCE_DATE_EPOCH"]
     ENV["SOURCE_DATE_EPOCH"] = nil
 
-    spec = Gem::Specification.new 'build', '1'
-    spec.summary = 'build'
-    spec.authors = 'build'
-    spec.files = ['lib/code.rb']
-    spec.rubygems_version = Gem::Version.new '0'
+    spec = Gem::Specification.new "build", "1"
+    spec.summary = "build"
+    spec.authors = "build"
+    spec.files = ["lib/code.rb"]
+    spec.rubygems_version = Gem::Version.new "0"
 
     package = Gem::Package.new spec.file_name
 
@@ -149,17 +144,17 @@ class TestGemPackage < Gem::Package::Tar
     spec = Gem::Specification.new
     spec.files = %w[lib/code.rb lib/empty]
 
-    FileUtils.mkdir_p 'lib/empty'
+    FileUtils.mkdir_p "lib/empty"
 
-    File.open 'lib/code.rb',  'w' do |io|
-      io.write '# lib/code.rb'
+    File.open "lib/code.rb", "w" do |io|
+      io.write "# lib/code.rb"
     end
 
-    File.open 'lib/extra.rb', 'w' do |io|
-      io.write '# lib/extra.rb'
+    File.open "lib/extra.rb", "w" do |io|
+      io.write "# lib/extra.rb"
     end
 
-    package = Gem::Package.new 'bogus.gem'
+    package = Gem::Package.new "bogus.gem"
     package.spec = spec
 
     tar = util_tar do |tar_io|
@@ -183,25 +178,25 @@ class TestGemPackage < Gem::Package::Tar
     spec = Gem::Specification.new
     spec.files = %w[lib/code.rb lib/code_sym.rb lib/code_sym2.rb]
 
-    FileUtils.mkdir_p 'lib'
+    FileUtils.mkdir_p "lib"
 
-    File.open 'lib/code.rb',  'w' do |io|
-      io.write '# lib/code.rb'
+    File.open "lib/code.rb", "w" do |io|
+      io.write "# lib/code.rb"
     end
 
     # NOTE: 'code.rb' is correct, because it's relative to lib/code_sym.rb
     begin
-      File.symlink('code.rb', 'lib/code_sym.rb')
-      File.symlink('../lib/code.rb', 'lib/code_sym2.rb')
+      File.symlink("code.rb", "lib/code_sym.rb")
+      File.symlink("../lib/code.rb", "lib/code_sym2.rb")
     rescue Errno::EACCES => e
       if win_platform?
-        skip "symlink - must be admin with no UAC on Windows"
+        pend "symlink - must be admin with no UAC on Windows"
       else
         raise e
       end
     end
 
-    package = Gem::Package.new 'bogus.gem'
+    package = Gem::Package.new "bogus.gem"
     package.spec = spec
 
     tar = util_tar do |tar_io|
@@ -223,20 +218,20 @@ class TestGemPackage < Gem::Package::Tar
     end
 
     assert_equal %w[lib/code.rb], files
-    assert_equal [{'lib/code_sym.rb' => 'lib/code.rb'}, {'lib/code_sym2.rb' => '../lib/code.rb'}], symlinks
+    assert_equal [{ "lib/code_sym.rb" => "code.rb" }, { "lib/code_sym2.rb" => "../lib/code.rb" }], symlinks
   end
 
   def test_build
-    spec = Gem::Specification.new 'build', '1'
-    spec.summary = 'build'
-    spec.authors = 'build'
-    spec.files = ['lib/code.rb']
+    spec = Gem::Specification.new "build", "1"
+    spec.summary = "build"
+    spec.authors = "build"
+    spec.files = ["lib/code.rb"]
     spec.rubygems_version = :junk
 
-    FileUtils.mkdir 'lib'
+    FileUtils.mkdir "lib"
 
-    File.open 'lib/code.rb', 'w' do |io|
-      io.write '# lib/code.rb'
+    File.open "lib/code.rb", "w" do |io|
+      io.write "# lib/code.rb"
     end
 
     package = Gem::Package.new spec.file_name
@@ -245,7 +240,7 @@ class TestGemPackage < Gem::Package::Tar
     package.build
 
     assert_equal Gem::VERSION, spec.rubygems_version
-    assert_path_exists spec.file_name
+    assert_path_exist spec.file_name
 
     reader = Gem::Package.new spec.file_name
     assert_equal spec, reader.spec
@@ -257,25 +252,25 @@ class TestGemPackage < Gem::Package::Tar
   end
 
   def test_build_auto_signed
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
-    FileUtils.mkdir_p File.join(Gem.user_home, '.gem')
+    FileUtils.mkdir_p File.join(Gem.user_home, ".gem")
 
-    private_key_path = File.join Gem.user_home, '.gem', 'gem-private_key.pem'
+    private_key_path = File.join Gem.user_home, ".gem", "gem-private_key.pem"
     Gem::Security.write PRIVATE_KEY, private_key_path
 
-    public_cert_path = File.join Gem.user_home, '.gem', 'gem-public_cert.pem'
+    public_cert_path = File.join Gem.user_home, ".gem", "gem-public_cert.pem"
     FileUtils.cp PUBLIC_CERT_PATH, public_cert_path
 
-    spec = Gem::Specification.new 'build', '1'
-    spec.summary = 'build'
-    spec.authors = 'build'
-    spec.files = ['lib/code.rb']
+    spec = Gem::Specification.new "build", "1"
+    spec.summary = "build"
+    spec.authors = "build"
+    spec.files = ["lib/code.rb"]
 
-    FileUtils.mkdir 'lib'
+    FileUtils.mkdir "lib"
 
-    File.open 'lib/code.rb', 'w' do |io|
-      io.write '# lib/code.rb'
+    File.open "lib/code.rb", "w" do |io|
+      io.write "# lib/code.rb"
     end
 
     package = Gem::Package.new spec.file_name
@@ -284,7 +279,7 @@ class TestGemPackage < Gem::Package::Tar
     package.build
 
     assert_equal Gem::VERSION, spec.rubygems_version
-    assert_path_exists spec.file_name
+    assert_path_exist spec.file_name
 
     reader = Gem::Package.new spec.file_name
     assert reader.verify
@@ -300,25 +295,25 @@ class TestGemPackage < Gem::Package::Tar
   end
 
   def test_build_auto_signed_encrypted_key
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
-    FileUtils.mkdir_p File.join(Gem.user_home, '.gem')
+    FileUtils.mkdir_p File.join(Gem.user_home, ".gem")
 
-    private_key_path = File.join Gem.user_home, '.gem', 'gem-private_key.pem'
+    private_key_path = File.join Gem.user_home, ".gem", "gem-private_key.pem"
     FileUtils.cp ENCRYPTED_PRIVATE_KEY_PATH, private_key_path
 
-    public_cert_path = File.join Gem.user_home, '.gem', 'gem-public_cert.pem'
+    public_cert_path = File.join Gem.user_home, ".gem", "gem-public_cert.pem"
     Gem::Security.write PUBLIC_CERT, public_cert_path
 
-    spec = Gem::Specification.new 'build', '1'
-    spec.summary = 'build'
-    spec.authors = 'build'
-    spec.files = ['lib/code.rb']
+    spec = Gem::Specification.new "build", "1"
+    spec.summary = "build"
+    spec.authors = "build"
+    spec.files = ["lib/code.rb"]
 
-    FileUtils.mkdir 'lib'
+    FileUtils.mkdir "lib"
 
-    File.open 'lib/code.rb', 'w' do |io|
-      io.write '# lib/code.rb'
+    File.open "lib/code.rb", "w" do |io|
+      io.write "# lib/code.rb"
     end
 
     package = Gem::Package.new spec.file_name
@@ -327,7 +322,7 @@ class TestGemPackage < Gem::Package::Tar
     package.build
 
     assert_equal Gem::VERSION, spec.rubygems_version
-    assert_path_exists spec.file_name
+    assert_path_exist spec.file_name
 
     reader = Gem::Package.new spec.file_name
     assert reader.verify
@@ -343,25 +338,25 @@ class TestGemPackage < Gem::Package::Tar
   end
 
   def test_build_invalid
-    spec = Gem::Specification.new 'build', '1'
+    spec = Gem::Specification.new "build", "1"
 
     package = Gem::Package.new spec.file_name
     package.spec = spec
 
-    e = assert_raises Gem::InvalidSpecificationException do
+    e = assert_raise Gem::InvalidSpecificationException do
       package.build
     end
 
-    assert_equal 'missing value for attribute summary', e.message
+    assert_equal "missing value for attribute summary", e.message
   end
 
   def test_build_invalid_arguments
-    spec = Gem::Specification.new 'build', '1'
+    spec = Gem::Specification.new "build", "1"
 
     package = Gem::Package.new spec.file_name
     package.spec = spec
 
-    e = assert_raises ArgumentError do
+    e = assert_raise ArgumentError do
       package.build true, true
     end
 
@@ -369,19 +364,19 @@ class TestGemPackage < Gem::Package::Tar
   end
 
   def test_build_signed
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
-    spec = Gem::Specification.new 'build', '1'
-    spec.summary = 'build'
-    spec.authors = 'build'
-    spec.files = ['lib/code.rb']
+    spec = Gem::Specification.new "build", "1"
+    spec.summary = "build"
+    spec.authors = "build"
+    spec.files = ["lib/code.rb"]
     spec.cert_chain = [PUBLIC_CERT.to_pem]
     spec.signing_key = PRIVATE_KEY
 
-    FileUtils.mkdir 'lib'
+    FileUtils.mkdir "lib"
 
-    File.open 'lib/code.rb', 'w' do |io|
-      io.write '# lib/code.rb'
+    File.open "lib/code.rb", "w" do |io|
+      io.write "# lib/code.rb"
     end
 
     package = Gem::Package.new spec.file_name
@@ -390,7 +385,7 @@ class TestGemPackage < Gem::Package::Tar
     package.build
 
     assert_equal Gem::VERSION, spec.rubygems_version
-    assert_path_exists spec.file_name
+    assert_path_exist spec.file_name
 
     reader = Gem::Package.new spec.file_name
     assert reader.verify
@@ -406,19 +401,19 @@ class TestGemPackage < Gem::Package::Tar
   end
 
   def test_build_signed_encrypted_key
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
-    spec = Gem::Specification.new 'build', '1'
-    spec.summary = 'build'
-    spec.authors = 'build'
-    spec.files = ['lib/code.rb']
+    spec = Gem::Specification.new "build", "1"
+    spec.summary = "build"
+    spec.authors = "build"
+    spec.files = ["lib/code.rb"]
     spec.cert_chain = [PUBLIC_CERT.to_pem]
     spec.signing_key = ENCRYPTED_PRIVATE_KEY
 
-    FileUtils.mkdir 'lib'
+    FileUtils.mkdir "lib"
 
-    File.open 'lib/code.rb', 'w' do |io|
-      io.write '# lib/code.rb'
+    File.open "lib/code.rb", "w" do |io|
+      io.write "# lib/code.rb"
     end
 
     package = Gem::Package.new spec.file_name
@@ -427,7 +422,7 @@ class TestGemPackage < Gem::Package::Tar
     package.build
 
     assert_equal Gem::VERSION, spec.rubygems_version
-    assert_path_exists spec.file_name
+    assert_path_exist spec.file_name
 
     reader = Gem::Package.new spec.file_name
     assert reader.verify
@@ -443,14 +438,14 @@ class TestGemPackage < Gem::Package::Tar
   end
 
   def test_raw_spec
-    data_tgz = util_tar_gz { }
+    data_tgz = util_tar_gz {}
 
     gem = util_tar do |tar|
-      tar.add_file 'data.tar.gz', 0644 do |io|
+      tar.add_file "data.tar.gz", 0644 do |io|
         io.write data_tgz.string
       end
 
-      tar.add_file 'metadata.gz', 0644 do |io|
+      tar.add_file "metadata.gz", 0644 do |io|
         Zlib::GzipWriter.wrap io do |gzio|
           gzio.write @spec.to_yaml
         end
@@ -480,8 +475,8 @@ class TestGemPackage < Gem::Package::Tar
 
     package.extract_files @destination
 
-    extracted = File.join @destination, 'lib/code.rb'
-    assert_path_exists extracted
+    extracted = File.join @destination, "lib/code.rb"
+    assert_path_exist extracted
 
     mask = 0100666 & (~File.umask)
 
@@ -490,41 +485,41 @@ class TestGemPackage < Gem::Package::Tar
   end
 
   def test_extract_files_empty
-    data_tgz = util_tar_gz { }
+    data_tgz = util_tar_gz {}
 
     gem = util_tar do |tar|
-      tar.add_file 'data.tar.gz', 0644 do |io|
+      tar.add_file "data.tar.gz", 0644 do |io|
         io.write data_tgz.string
       end
 
-      tar.add_file 'metadata.gz', 0644 do |io|
+      tar.add_file "metadata.gz", 0644 do |io|
         Zlib::GzipWriter.wrap io do |gzio|
           gzio.write @spec.to_yaml
         end
       end
     end
 
-    File.open 'empty.gem', 'wb' do |io|
+    File.open "empty.gem", "wb" do |io|
       io.write gem.string
     end
 
-    package = Gem::Package.new 'empty.gem'
+    package = Gem::Package.new "empty.gem"
 
     package.extract_files @destination
 
-    assert_path_exists @destination
+    assert_path_exist @destination
   end
 
   def test_extract_tar_gz_absolute
     package = Gem::Package.new @gem
 
     tgz_io = util_tar_gz do |tar|
-      tar.add_file '/absolute.rb', 0644 do |io|
-        io.write 'hi'
+      tar.add_file "/absolute.rb", 0644 do |io|
+        io.write "hi"
       end
     end
 
-    e = assert_raises Gem::Package::PathError do
+    e = assert_raise Gem::Package::PathError do
       package.extract_tar_gz tgz_io, @destination
     end
 
@@ -534,63 +529,86 @@ class TestGemPackage < Gem::Package::Tar
 
   def test_extract_tar_gz_symlink_relative_path
     package = Gem::Package.new @gem
+    package.verify
 
     tgz_io = util_tar_gz do |tar|
-      tar.add_file    'relative.rb', 0644 do |io|
-        io.write 'hi'
+      tar.add_file "relative.rb", 0644 do |io|
+        io.write "hi"
       end
 
-      tar.mkdir       'lib',         0755
-      tar.add_symlink 'lib/foo.rb', '../relative.rb', 0644
+      tar.mkdir       "lib", 0755
+      tar.add_symlink "lib/foo.rb", "../relative.rb", 0644
     end
 
     begin
       package.extract_tar_gz tgz_io, @destination
     rescue Errno::EACCES => e
       if win_platform?
-        skip "symlink - must be admin with no UAC on Windows"
+        pend "symlink - must be admin with no UAC on Windows"
       else
         raise e
       end
     end
 
-    extracted = File.join @destination, 'lib/foo.rb'
-    assert_path_exists extracted
-    assert_equal '../relative.rb',
+    extracted = File.join @destination, "lib/foo.rb"
+    assert_path_exist extracted
+    assert_equal "../relative.rb",
                  File.readlink(extracted)
-    assert_equal 'hi',
+    assert_equal "hi",
                  File.read(extracted)
   end
 
+  def test_extract_tar_gz_symlink_broken_relative_path
+    package = Gem::Package.new @gem
+    package.verify
+
+    tgz_io = util_tar_gz do |tar|
+      tar.mkdir       "lib", 0755
+      tar.add_symlink "lib/foo.rb", "../broken.rb", 0644
+    end
+
+    ui = Gem::MockGemUi.new
+
+    use_ui ui do
+      package.extract_tar_gz tgz_io, @destination
+    end
+
+    assert_equal "WARNING:  a-2 ships with a dangling symlink named lib/foo.rb pointing to missing ../broken.rb file. Ignoring\n", ui.error
+
+    extracted = File.join @destination, "lib/foo.rb"
+    assert_path_not_exist extracted
+  end
+
   def test_extract_symlink_parent
     package = Gem::Package.new @gem
 
     tgz_io = util_tar_gz do |tar|
-      tar.mkdir       'lib',               0755
-      tar.add_symlink 'lib/link', '../..', 0644
-      tar.add_file    'lib/link/outside.txt', 0644 do |io|
-        io.write 'hi'
+      tar.mkdir       "lib",               0755
+      tar.add_symlink "lib/link", "../..", 0644
+      tar.add_file    "lib/link/outside.txt", 0644 do |io|
+        io.write "hi"
       end
     end
 
     # Extract into a subdirectory of @destination; if this test fails it writes
     # a file outside destination_subdir, but we want the file to remain inside
     # @destination so it will be cleaned up.
-    destination_subdir = File.join @destination, 'subdir'
+    destination_subdir = File.join @destination, "subdir"
     FileUtils.mkdir_p destination_subdir
 
-    e = assert_raises(Gem::Package::PathError, Errno::EACCES) do
+    expected_exceptions = win_platform? ? [Gem::Package::SymlinkError, Errno::EACCES] : [Gem::Package::SymlinkError]
+
+    e = assert_raise(*expected_exceptions) do
       package.extract_tar_gz tgz_io, destination_subdir
     end
 
-    if Gem::Package::PathError === e
-      assert_equal("installing into parent path lib/link/outside.txt of " +
-                  "#{destination_subdir} is not allowed", e.message)
-    elsif win_platform?
-      skip "symlink - must be admin with no UAC on Windows"
-    else
-      raise e
-    end
+    pend "symlink - must be admin with no UAC on Windows" if Errno::EACCES === e
+
+    assert_equal("installing symlink 'lib/link' pointing to parent path #{@destination} of " +
+                "#{destination_subdir} is not allowed", e.message)
+
+    assert_path_not_exist File.join(@destination, "outside.txt")
+    assert_path_not_exist File.join(destination_subdir, "lib/link")
   end
 
   def test_extract_symlink_parent_doesnt_delete_user_dir
@@ -599,82 +617,84 @@ class TestGemPackage < Gem::Package::Tar
     # Extract into a subdirectory of @destination; if this test fails it writes
     # a file outside destination_subdir, but we want the file to remain inside
     # @destination so it will be cleaned up.
-    destination_subdir = File.join @destination, 'subdir'
+    destination_subdir = File.join @destination, "subdir"
     FileUtils.mkdir_p destination_subdir
 
-    destination_user_dir = File.join @destination, 'user'
-    destination_user_subdir = File.join destination_user_dir, 'dir'
+    destination_user_dir = File.join @destination, "user"
+    destination_user_subdir = File.join destination_user_dir, "dir"
     FileUtils.mkdir_p destination_user_subdir
 
+    pend "TMPDIR seems too long to add it as symlink into tar" if destination_user_dir.size > 90
+
     tgz_io = util_tar_gz do |tar|
-      tar.add_symlink 'link', destination_user_dir, 16877
-      tar.add_symlink 'link/dir', '.', 16877
+      tar.add_symlink "link", destination_user_dir, 16877
+      tar.add_symlink "link/dir", ".", 16877
     end
 
-    e = assert_raises(Gem::Package::PathError, Errno::EACCES) do
+    expected_exceptions = win_platform? ? [Gem::Package::SymlinkError, Errno::EACCES] : [Gem::Package::SymlinkError]
+
+    e = assert_raise(*expected_exceptions) do
       package.extract_tar_gz tgz_io, destination_subdir
     end
 
-    assert_path_exists destination_user_subdir
+    pend "symlink - must be admin with no UAC on Windows" if Errno::EACCES === e
 
-    if Gem::Package::PathError === e
-      assert_equal("installing into parent path #{destination_user_subdir} of " +
-                  "#{destination_subdir} is not allowed", e.message)
-    elsif win_platform?
-      skip "symlink - must be admin with no UAC on Windows"
-    else
-      raise e
-    end
+    assert_equal("installing symlink 'link' pointing to parent path #{destination_user_dir} of " +
+                "#{destination_subdir} is not allowed", e.message)
+
+    assert_path_exist destination_user_subdir
+    assert_path_not_exist File.join(destination_subdir, "link/dir")
+    assert_path_not_exist File.join(destination_subdir, "link")
   end
 
   def test_extract_tar_gz_directory
     package = Gem::Package.new @gem
 
     tgz_io = util_tar_gz do |tar|
-      tar.mkdir    'lib',        0755
-      tar.add_file 'lib/foo.rb', 0644 do |io|
-        io.write 'hi'
+      tar.mkdir    "lib",        0755
+      tar.add_file "lib/foo.rb", 0644 do |io|
+        io.write "hi"
       end
-      tar.mkdir    'lib/foo',    0755
+      tar.mkdir    "lib/foo", 0755
     end
 
     package.extract_tar_gz tgz_io, @destination
 
-    extracted = File.join @destination, 'lib/foo.rb'
-    assert_path_exists extracted
+    extracted = File.join @destination, "lib/foo.rb"
+    assert_path_exist extracted
 
-    extracted = File.join @destination, 'lib/foo'
-    assert_path_exists extracted
+    extracted = File.join @destination, "lib/foo"
+    assert_path_exist extracted
   end
 
   def test_extract_tar_gz_dot_slash
     package = Gem::Package.new @gem
 
     tgz_io = util_tar_gz do |tar|
-      tar.add_file './dot_slash.rb', 0644 do |io|
-        io.write 'hi'
+      tar.add_file "./dot_slash.rb", 0644 do |io|
+        io.write "hi"
       end
     end
 
     package.extract_tar_gz tgz_io, @destination
 
-    extracted = File.join @destination, 'dot_slash.rb'
-    assert_path_exists extracted
+    extracted = File.join @destination, "dot_slash.rb"
+    assert_path_exist extracted
   end
 
   def test_extract_tar_gz_dot_file
     package = Gem::Package.new @gem
 
     tgz_io = util_tar_gz do |tar|
-      tar.add_file '.dot_file.rb', 0644 do |io|
-        io.write 'hi'
+      tar.add_file ".dot_file.rb", 0644 do |io|
+        io.write "hi"
       end
     end
 
     package.extract_tar_gz tgz_io, @destination
 
-    extracted = File.join @destination, '.dot_file.rb'
-    assert_path_exists extracted
+    extracted = File.join @destination, ".dot_file.rb"
+    assert_path_exist extracted
   end
 
   if Gem.win_platform?
@@ -682,35 +702,35 @@ class TestGemPackage < Gem::Package::Tar
       package = Gem::Package.new @gem
 
       tgz_io = util_tar_gz do |tar|
-        tar.add_file 'foo/file.rb', 0644 do |io|
-          io.write 'hi'
+        tar.add_file "foo/file.rb", 0644 do |io|
+          io.write "hi"
         end
       end
 
       package.extract_tar_gz tgz_io, @destination.upcase
 
-      extracted = File.join @destination, 'foo/file.rb'
-      assert_path_exists extracted
+      extracted = File.join @destination, "foo/file.rb"
+      assert_path_exist extracted
     end
   end
 
   def test_install_location
     package = Gem::Package.new @gem
 
-    file = 'file.rb'.dup
-    file.taint if RUBY_VERSION < '2.7'
+    file = "file.rb".dup
+    file.taint if RUBY_VERSION < "2.7"
 
     destination = package.install_location file, @destination
 
-    assert_equal File.join(@destination, 'file.rb'), destination
-    refute destination.tainted? if RUBY_VERSION < '2.7'
+    assert_equal File.join(@destination, "file.rb"), destination
+    refute destination.tainted? if RUBY_VERSION < "2.7"
   end
 
   def test_install_location_absolute
     package = Gem::Package.new @gem
 
-    e = assert_raises Gem::Package::PathError do
-      package.install_location '/absolute.rb', @destination
+    e = assert_raise Gem::Package::PathError do
+      package.install_location "/absolute.rb", @destination
     end
 
     assert_equal("installing into parent path /absolute.rb of " +
@@ -720,38 +740,36 @@ class TestGemPackage < Gem::Package::Tar
   def test_install_location_dots
     package = Gem::Package.new @gem
 
-    file = 'file.rb'
+    file = "file.rb"
 
-    destination = File.join @destination, 'foo', '..', 'bar'
+    destination = File.join @destination, "foo", "..", "bar"
 
-    FileUtils.mkdir_p File.join @destination, 'foo'
+    FileUtils.mkdir_p File.join @destination, "foo"
     FileUtils.mkdir_p File.expand_path destination
 
     destination = package.install_location file, destination
 
     # this test only fails on ruby missing File.realpath
-    assert_equal File.join(@destination, 'bar', 'file.rb'), destination
+    assert_equal File.join(@destination, "bar", "file.rb"), destination
   end
 
   def test_install_location_extra_slash
     package = Gem::Package.new @gem
 
-    file = 'foo//file.rb'.dup
-    file.taint if RUBY_VERSION < '2.7'
+    file = "foo//file.rb".dup
+    file.taint if RUBY_VERSION < "2.7"
 
-    destination = @destination.sub '/', '//'
-
-    destination = package.install_location file, destination
+    destination = package.install_location file, @destination
 
-    assert_equal File.join(@destination, 'foo', 'file.rb'), destination
-    refute destination.tainted? if RUBY_VERSION < '2.7'
+    assert_equal File.join(@destination, "foo", "file.rb"), destination
+    refute destination.tainted? if RUBY_VERSION < "2.7"
   end
 
   def test_install_location_relative
     package = Gem::Package.new @gem
 
-    e = assert_raises Gem::Package::PathError do
-      package.install_location '../relative.rb', @destination
+    e = assert_raise Gem::Package::PathError do
+      package.install_location "../relative.rb", @destination
     end
 
     parent = File.expand_path File.join @destination, "../relative.rb"
@@ -765,7 +783,7 @@ class TestGemPackage < Gem::Package::Tar
 
     filename = "../#{File.basename(@destination)}suffix.rb"
 
-    e = assert_raises Gem::Package::PathError do
+    e = assert_raise Gem::Package::PathError do
       package.install_location filename, @destination
     end
 
@@ -777,9 +795,9 @@ class TestGemPackage < Gem::Package::Tar
 
   def test_load_spec
     entry = StringIO.new Gem::Util.gzip @spec.to_yaml
-    def entry.full_name() 'metadata.gz' end
+    def entry.full_name() "metadata.gz" end
 
-    package = Gem::Package.new 'nonexistent.gem'
+    package = Gem::Package.new "nonexistent.gem"
 
     spec = package.load_spec entry
 
@@ -798,8 +816,8 @@ class TestGemPackage < Gem::Package::Tar
 
   def test_verify_checksum_bad
     data_tgz = util_tar_gz do |tar|
-      tar.add_file 'lib/code.rb', 0444 do |io|
-        io.write '# lib/code.rb'
+      tar.add_file "lib/code.rb", 0444 do |io|
+        io.write "# lib/code.rb"
       end
     end
 
@@ -808,45 +826,45 @@ class TestGemPackage < Gem::Package::Tar
     gem = util_tar do |tar|
       metadata_gz = Gem::Util.gzip @spec.to_yaml
 
-      tar.add_file 'metadata.gz', 0444 do |io|
+      tar.add_file "metadata.gz", 0444 do |io|
         io.write metadata_gz
       end
 
-      tar.add_file 'data.tar.gz', 0444 do |io|
+      tar.add_file "data.tar.gz", 0444 do |io|
         io.write data_tgz
       end
 
       bogus_checksums = {
-        'SHA1' => {
-          'data.tar.gz' => 'bogus',
-          'metadata.gz' => 'bogus',
+        "SHA1" => {
+          "data.tar.gz" => "bogus",
+          "metadata.gz" => "bogus",
         },
       }
-      tar.add_file 'checksums.yaml.gz', 0444 do |io|
+      tar.add_file "checksums.yaml.gz", 0444 do |io|
         Zlib::GzipWriter.wrap io do |gz_io|
-          gz_io.write YAML.dump bogus_checksums
+          gz_io.write Psych.dump bogus_checksums
         end
       end
     end
 
-    File.open 'mismatch.gem', 'wb' do |io|
+    File.open "mismatch.gem", "wb" do |io|
       io.write gem.string
     end
 
-    package = Gem::Package.new 'mismatch.gem'
+    package = Gem::Package.new "mismatch.gem"
 
-    e = assert_raises Gem::Package::FormatError do
+    e = assert_raise Gem::Package::FormatError do
       package.verify
     end
 
-    assert_equal 'SHA1 checksum mismatch for data.tar.gz in mismatch.gem',
+    assert_equal "SHA1 checksum mismatch for data.tar.gz in mismatch.gem",
                  e.message
   end
 
   def test_verify_checksum_missing
     data_tgz = util_tar_gz do |tar|
-      tar.add_file 'lib/code.rb', 0444 do |io|
-        io.write '# lib/code.rb'
+      tar.add_file "lib/code.rb", 0444 do |io|
+        io.write "# lib/code.rb"
       end
     end
 
@@ -855,51 +873,51 @@ class TestGemPackage < Gem::Package::Tar
     gem = util_tar do |tar|
       metadata_gz = Gem::Util.gzip @spec.to_yaml
 
-      tar.add_file 'metadata.gz', 0444 do |io|
+      tar.add_file "metadata.gz", 0444 do |io|
         io.write metadata_gz
       end
 
-      digest = Digest::SHA1.new
+      digest = OpenSSL::Digest::SHA1.new
       digest << metadata_gz
 
       checksums = {
-        'SHA1' => {
-          'metadata.gz' => digest.hexdigest,
+        "SHA1" => {
+          "metadata.gz" => digest.hexdigest,
         },
       }
 
-      tar.add_file 'checksums.yaml.gz', 0444 do |io|
+      tar.add_file "checksums.yaml.gz", 0444 do |io|
         Zlib::GzipWriter.wrap io do |gz_io|
-          gz_io.write YAML.dump checksums
+          gz_io.write Psych.dump checksums
         end
       end
 
-      tar.add_file 'data.tar.gz', 0444 do |io|
+      tar.add_file "data.tar.gz", 0444 do |io|
         io.write data_tgz
       end
     end
 
-    File.open 'data_checksum_missing.gem', 'wb' do |io|
+    File.open "data_checksum_missing.gem", "wb" do |io|
       io.write gem.string
     end
 
-    package = Gem::Package.new 'data_checksum_missing.gem'
+    package = Gem::Package.new "data_checksum_missing.gem"
 
     assert package.verify
   end
 
   def test_verify_corrupt
-    skip "jruby strips the null byte and does not think it's corrupt" if Gem.java_platform?
-    tf = Tempfile.open 'corrupt' do |io|
-      data = Gem::Util.gzip 'a' * 10
+    pend "jruby strips the null byte and does not think it's corrupt" if Gem.java_platform?
+    tf = Tempfile.open "corrupt" do |io|
+      data = Gem::Util.gzip "a" * 10
       io.write \
-        tar_file_header('metadata.gz', "\000x", 0644, data.length, Time.now)
+        tar_file_header("metadata.gz", "\000x", 0644, data.length, Time.now)
       io.write data
       io.rewind
 
       package = Gem::Package.new io.path
 
-      e = assert_raises Gem::Package::FormatError do
+      e = assert_raise Gem::Package::FormatError do
         package.verify
       end
 
@@ -911,48 +929,48 @@ class TestGemPackage < Gem::Package::Tar
   end
 
   def test_verify_empty
-    FileUtils.touch 'empty.gem'
+    FileUtils.touch "empty.gem"
 
-    package = Gem::Package.new 'empty.gem'
+    package = Gem::Package.new "empty.gem"
 
-    e = assert_raises Gem::Package::FormatError do
+    e = assert_raise Gem::Package::FormatError do
       package.verify
     end
 
-    assert_equal 'package metadata is missing in empty.gem', e.message
+    assert_equal "package metadata is missing in empty.gem", e.message
   end
 
   def test_verify_nonexistent
-    package = Gem::Package.new 'nonexistent.gem'
+    package = Gem::Package.new "nonexistent.gem"
 
-    e = assert_raises Gem::Package::FormatError do
+    e = assert_raise Gem::Package::FormatError do
       package.verify
     end
 
-    assert_match %r%^No such file or directory%, e.message
-    assert_match %r%nonexistent.gem$%,           e.message
+    assert_match %r{^No such file or directory}, e.message
+    assert_match %r{nonexistent.gem$},           e.message
   end
 
   def test_verify_duplicate_file
-    FileUtils.mkdir_p 'lib'
-    FileUtils.touch 'lib/code.rb'
+    FileUtils.mkdir_p "lib"
+    FileUtils.touch "lib/code.rb"
 
     build = Gem::Package.new @gem
     build.spec = @spec
     build.setup_signer
-    open @gem, 'wb' do |gem_io|
+    File.open @gem, "wb" do |gem_io|
       Gem::Package::TarWriter.new gem_io do |gem|
         build.add_metadata gem
         build.add_contents gem
 
-        gem.add_file_simple 'a.sig', 0444, 0
-        gem.add_file_simple 'a.sig', 0444, 0
+        gem.add_file_simple "a.sig", 0444, 0
+        gem.add_file_simple "a.sig", 0444, 0
       end
     end
 
     package = Gem::Package.new @gem
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       package.verify
     end
 
@@ -960,30 +978,30 @@ class TestGemPackage < Gem::Package::Tar
   end
 
   def test_verify_security_policy
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
     package = Gem::Package.new @gem
     package.security_policy = Gem::Security::HighSecurity
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       package.verify
     end
 
-    assert_equal 'unsigned gems are not allowed by the High Security policy',
+    assert_equal "unsigned gems are not allowed by the High Security policy",
                  e.message
 
-    refute package.instance_variable_get(:@spec), '@spec must not be loaded'
-    assert_empty package.instance_variable_get(:@files), '@files must empty'
+    refute package.instance_variable_get(:@spec), "@spec must not be loaded"
+    assert_empty package.instance_variable_get(:@files), "@files must empty"
   end
 
   def test_verify_security_policy_low_security
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
     @spec.cert_chain = [PUBLIC_CERT.to_pem]
     @spec.signing_key = PRIVATE_KEY
 
-    FileUtils.mkdir_p 'lib'
-    FileUtils.touch 'lib/code.rb'
+    FileUtils.mkdir_p "lib"
+    FileUtils.touch "lib/code.rb"
 
     build = Gem::Package.new @gem
     build.spec = @spec
@@ -997,7 +1015,7 @@ class TestGemPackage < Gem::Package::Tar
   end
 
   def test_verify_security_policy_checksum_missing
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
     @spec.cert_chain = [PUBLIC_CERT.to_pem]
     @spec.signing_key = PRIVATE_KEY
@@ -1006,23 +1024,23 @@ class TestGemPackage < Gem::Package::Tar
     build.spec = @spec
     build.setup_signer
 
-    FileUtils.mkdir 'lib'
-    FileUtils.touch 'lib/code.rb'
+    FileUtils.mkdir "lib"
+    FileUtils.touch "lib/code.rb"
 
-    File.open @gem, 'wb' do |gem_io|
+    File.open @gem, "wb" do |gem_io|
       Gem::Package::TarWriter.new gem_io do |gem|
         build.add_metadata gem
         build.add_contents gem
 
         # write bogus data.tar.gz to foil signature
-        bogus_data = Gem::Util.gzip 'hello'
+        bogus_data = Gem::Util.gzip "hello"
         fake_signer = Class.new do
-          def digest_name; 'SHA512'; end
-          def digest_algorithm; Digest(:SHA512); end
-          def key; 'key'; end
-          def sign(*); 'fake_sig'; end
+          def digest_name; "SHA512"; end
+          def digest_algorithm; OpenSSL::Digest(:SHA512).new; end
+          def key; "key"; end
+          def sign(*); "fake_sig"; end
         end
-        gem.add_file_signed 'data2.tar.gz', 0444, fake_signer.new do |io|
+        gem.add_file_signed "data2.tar.gz", 0444, fake_signer.new do |io|
           io.write bogus_data
         end
 
@@ -1035,28 +1053,28 @@ class TestGemPackage < Gem::Package::Tar
     package = Gem::Package.new @gem
     package.security_policy = Gem::Security::HighSecurity
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       package.verify
     end
 
-    assert_equal 'invalid signature', e.message
+    assert_equal "invalid signature", e.message
 
-    refute package.instance_variable_get(:@spec), '@spec must not be loaded'
-    assert_empty package.instance_variable_get(:@files), '@files must empty'
+    refute package.instance_variable_get(:@spec), "@spec must not be loaded"
+    assert_empty package.instance_variable_get(:@files), "@files must empty"
   end
 
   def test_verify_truncate
-    File.open 'bad.gem', 'wb' do |io|
+    File.open "bad.gem", "wb" do |io|
       io.write File.read(@gem, 1024) # don't care about newlines
     end
 
-    package = Gem::Package.new 'bad.gem'
+    package = Gem::Package.new "bad.gem"
 
-    e = assert_raises Gem::Package::FormatError do
+    e = assert_raise Gem::Package::FormatError do
       package.verify
     end
 
-    assert_equal 'package content (data.tar.gz) is missing in bad.gem',
+    assert_equal "package content (data.tar.gz) is missing in bad.gem",
                  e.message
   end
 
@@ -1064,15 +1082,26 @@ class TestGemPackage < Gem::Package::Tar
 
   def test_verify_entry
     entry = Object.new
-    def entry.full_name() raise ArgumentError, 'whatever' end
+    def entry.full_name() raise ArgumentError, "whatever" end
 
     package = Gem::Package.new @gem
 
-    e = assert_raises Gem::Package::FormatError do
-      package.verify_entry entry
+    _, err = use_ui @ui do
+      e = nil
+
+      out_err = capture_output do
+        e = assert_raise ArgumentError do
+          package.verify_entry entry
+        end
+      end
+
+      assert_equal "whatever", e.message
+      assert_equal "full_name", e.backtrace_locations.first.label
+
+      out_err
     end
 
-    assert_equal "package is corrupt, exception while verifying: whatever (ArgumentError) in #{@gem}", e.message
+    assert_equal "Exception while verifying #{@gem}\n", err
 
     valid_metadata = ["metadata", "metadata.gz"]
     valid_metadata.each do |vm|
@@ -1097,7 +1126,7 @@ class TestGemPackage < Gem::Package::Tar
       $bad_name = vm
 
       entry = Object.new
-      def entry.full_name() $bad_name  end
+      def entry.full_name() $bad_name end
 
       package = Gem::Package.new(@gem)
       package.instance_variable_set(:@files, [])
@@ -1132,11 +1161,18 @@ class TestGemPackage < Gem::Package::Tar
   def test_spec_from_io_raises_gem_error_for_io_not_at_start
     io = StringIO.new Gem.read_binary @gem
     io.read(1)
-    assert_raises(Gem::Package::Error) do
+    assert_raise(Gem::Package::Error) do
       Gem::Package.new io
     end
   end
 
+  def test_contents_from_io
+    io = StringIO.new Gem.read_binary @gem
+    package = Gem::Package.new io
+
+    assert_equal %w[lib/code.rb], package.contents
+  end
+
   def util_tar
     tar_io = StringIO.new
 
@@ -1161,5 +1197,4 @@ class TestGemPackage < Gem::Package::Tar
 
     StringIO.new tgz_io.string
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_package_old.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_package_old.rb
@@ -1,20 +1,19 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 unless Gem.java_platform? # jruby can't require the simple_gem file
-  require 'rubygems/simple_gem'
+  require "rubygems/simple_gem"
 
   class TestGemPackageOld < Gem::TestCase
-
     def setup
       super
 
-      File.open 'old_format.gem', 'wb' do |io|
+      File.open "old_format.gem", "wb" do |io|
         io.write SIMPLE_GEM
       end
 
-      @package = Gem::Package::Old.new 'old_format.gem'
-      @destination = File.join @tempdir, 'extract'
+      @package = Gem::Package::Old.new "old_format.gem"
+      @destination = File.join @tempdir, "extract"
 
       FileUtils.mkdir_p @destination
     end
@@ -24,11 +23,11 @@ unless Gem.java_platform? # jruby can't 
     end
 
     def test_contents_security_policy
-      skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+      pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
       @package.security_policy = Gem::Security::AlmostNoSecurity
 
-      assert_raises Gem::Security::Exception do
+      assert_raise Gem::Security::Exception do
         @package.contents
       end
     end
@@ -36,8 +35,8 @@ unless Gem.java_platform? # jruby can't 
     def test_extract_files
       @package.extract_files @destination
 
-      extracted = File.join @destination, 'lib/foo.rb'
-      assert_path_exists extracted
+      extracted = File.join @destination, "lib/foo.rb"
+      assert_path_exist extracted
 
       mask = 0100644 & (~File.umask)
 
@@ -45,31 +44,31 @@ unless Gem.java_platform? # jruby can't 
     end
 
     def test_extract_files_security_policy
-      skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+      pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
       @package.security_policy = Gem::Security::AlmostNoSecurity
 
-      assert_raises Gem::Security::Exception do
+      assert_raise Gem::Security::Exception do
         @package.extract_files @destination
       end
     end
 
     def test_spec
-      assert_equal 'testing', @package.spec.name
+      assert_equal "testing", @package.spec.name
     end
 
     def test_spec_security_policy
-      skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+      pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
       @package.security_policy = Gem::Security::AlmostNoSecurity
 
-      assert_raises Gem::Security::Exception do
+      assert_raise Gem::Security::Exception do
         @package.spec
       end
     end
 
     def test_verify
-      skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+      pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
       assert @package.verify
 
@@ -79,14 +78,13 @@ unless Gem.java_platform? # jruby can't 
 
       @package.security_policy = Gem::Security::AlmostNoSecurity
 
-      e = assert_raises Gem::Security::Exception do
+      e = assert_raise Gem::Security::Exception do
         @package.verify
       end
 
-      assert_equal 'old format gems do not contain signatures ' +
-                   'and cannot be verified',
+      assert_equal "old format gems do not contain signatures " +
+                   "and cannot be verified",
                    e.message
     end
-
   end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_package_tar_header.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_package_tar_header.rb
@@ -1,26 +1,25 @@
 # frozen_string_literal: true
-require 'rubygems/package/tar_test_case'
-require 'rubygems/package'
+require_relative "package/tar_test_case"
+require "rubygems/package"
 
 class TestGemPackageTarHeader < Gem::Package::TarTestCase
-
   def setup
     super
 
     header = {
-      :name     => 'x',
+      :name     => "x",
       :mode     => 0644,
       :uid      => 1000,
       :gid      => 10000,
       :size     => 100,
       :mtime    => 12345,
-      :typeflag => '0',
-      :linkname => 'link',
-      :uname    => 'user',
-      :gname    => 'group',
+      :typeflag => "0",
+      :linkname => "link",
+      :uname    => "user",
+      :gname    => "group",
       :devmajor => 1,
       :devminor => 2,
-      :prefix   => 'y',
+      :prefix   => "y",
     }
 
     @tar_header = Gem::Package::TarHeader.new header
@@ -37,62 +36,62 @@ class TestGemPackageTarHeader < Gem::Pac
   end
 
   def test_initialize
-    assert_equal '',      @tar_header.checksum, 'checksum'
-    assert_equal 1,       @tar_header.devmajor, 'devmajor'
-    assert_equal 2,       @tar_header.devminor, 'devminor'
-    assert_equal 10000,   @tar_header.gid,      'gid'
-    assert_equal 'group', @tar_header.gname,    'gname'
-    assert_equal 'link',  @tar_header.linkname, 'linkname'
-    assert_equal 'ustar', @tar_header.magic,    'magic'
-    assert_equal 0644,    @tar_header.mode,     'mode'
-    assert_equal 12345,   @tar_header.mtime,    'mtime'
-    assert_equal 'x',     @tar_header.name,     'name'
-    assert_equal 'y',     @tar_header.prefix,   'prefix'
-    assert_equal 100,     @tar_header.size,     'size'
-    assert_equal '0',     @tar_header.typeflag, 'typeflag'
-    assert_equal 1000,    @tar_header.uid,      'uid'
-    assert_equal 'user',  @tar_header.uname,    'uname'
-    assert_equal '00',    @tar_header.version,  'version'
+    assert_equal "",      @tar_header.checksum, "checksum"
+    assert_equal 1,       @tar_header.devmajor, "devmajor"
+    assert_equal 2,       @tar_header.devminor, "devminor"
+    assert_equal 10000,   @tar_header.gid,      "gid"
+    assert_equal "group", @tar_header.gname,    "gname"
+    assert_equal "link",  @tar_header.linkname, "linkname"
+    assert_equal "ustar", @tar_header.magic,    "magic"
+    assert_equal 0644,    @tar_header.mode,     "mode"
+    assert_equal 12345,   @tar_header.mtime,    "mtime"
+    assert_equal "x",     @tar_header.name,     "name"
+    assert_equal "y",     @tar_header.prefix,   "prefix"
+    assert_equal 100,     @tar_header.size,     "size"
+    assert_equal "0",     @tar_header.typeflag, "typeflag"
+    assert_equal 1000,    @tar_header.uid,      "uid"
+    assert_equal "user",  @tar_header.uname,    "uname"
+    assert_equal "00",    @tar_header.version,  "version"
 
-    refute_empty @tar_header, 'empty'
+    refute_empty @tar_header, "empty"
   end
 
   def test_initialize_bad
-    assert_raises ArgumentError do
-      Gem::Package::TarHeader.new :name => '', :size => '', :mode => ''
+    assert_raise ArgumentError do
+      Gem::Package::TarHeader.new :name => "", :size => "", :mode => ""
     end
 
-    assert_raises ArgumentError do
-      Gem::Package::TarHeader.new :name => '', :size => '', :prefix => ''
+    assert_raise ArgumentError do
+      Gem::Package::TarHeader.new :name => "", :size => "", :prefix => ""
     end
 
-    assert_raises ArgumentError do
-      Gem::Package::TarHeader.new :name => '', :prefix => '', :mode => ''
+    assert_raise ArgumentError do
+      Gem::Package::TarHeader.new :name => "", :prefix => "", :mode => ""
     end
 
-    assert_raises ArgumentError do
-      Gem::Package::TarHeader.new :prefix => '', :size => '', :mode => ''
+    assert_raise ArgumentError do
+      Gem::Package::TarHeader.new :prefix => "", :size => "", :mode => ""
     end
   end
 
   def test_initialize_typeflag
     header = {
-      :mode     => '',
-      :name     => '',
-      :prefix   => '',
-      :size     => '',
-      :typeflag => '',
+      :mode     => "",
+      :name     => "",
+      :prefix   => "",
+      :size     => "",
+      :typeflag => "",
     }
 
     tar_header = Gem::Package::TarHeader.new header
 
-    assert_equal '0', tar_header.typeflag
+    assert_equal "0", tar_header.typeflag
   end
 
   def test_empty_eh
     refute_empty @tar_header
 
-    @tar_header = Gem::Package::TarHeader.new :name => 'x', :prefix => '',
+    @tar_header = Gem::Package::TarHeader.new :name => "x", :prefix => "",
                                               :mode => 0, :size => 0,
                                               :empty => true
 
@@ -136,11 +135,11 @@ group\000\000\000\000\000\000\000\000\00
   end
 
   def test_update_checksum
-    assert_equal '', @tar_header.checksum
+    assert_equal "", @tar_header.checksum
 
     @tar_header.update_checksum
 
-    assert_equal '012467', @tar_header.checksum
+    assert_equal "012467", @tar_header.checksum
   end
 
   def test_from_bad_octal
@@ -157,7 +156,7 @@ group\000\000\000\000\000\000\000\000\00
       # overwrite the size field
       header_s[124, 12] = val
       io = TempIO.new header_s
-      assert_raises ArgumentError do
+      assert_raise ArgumentError do
         Gem::Package::TarHeader.from io
       end
       io.close!
@@ -166,7 +165,7 @@ group\000\000\000\000\000\000\000\000\00
 
   def test_big_uid_gid
     stream = StringIO.new(
-      <<-EOF.dup.force_encoding('binary').split("\n").join
+      <<-EOF.dup.force_encoding("binary").split("\n").join
 GeoIP2-City_20190528/
 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
@@ -198,11 +197,29 @@ tjmather\x00\x00\x00\x00\x00\x00\x00\x00
     assert_equal 1991400094, tar_header.uid
     assert_equal 1991400094, tar_header.gid
 
-    assert_equal 'GeoIP2-City_20190528/', tar_header.name
+    assert_equal "GeoIP2-City_20190528/", tar_header.name
     assert_equal 0755, tar_header.mode
     assert_equal 0, tar_header.size
     assert_equal 1559064640, tar_header.mtime
     assert_equal 6932, tar_header.checksum
   end
 
+  def test_spaces_in_headers
+    stream = StringIO.new(
+      <<-EOF.dup.force_encoding("binary").split("\n").join
+Access_Points_09202018.csv
+\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
+\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
+\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
+\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
+\x00\x00100777 \x00     0 \x00     0 \x00       4357 13545040367  104501
+\x000
+      EOF
+    )
+
+    tar_header = Gem::Package::TarHeader.from stream
+
+    assert_equal 0, tar_header.uid
+    assert_equal 0, tar_header.gid
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_package_tar_reader.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_package_tar_reader.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/package/tar_test_case'
-require 'rubygems/package'
+require_relative "package/tar_test_case"
+require "rubygems/package"
 
 class TestGemPackageTarReader < Gem::Package::TarTestCase
-
   def test_each_entry
     tar = tar_dir_header "foo", "bar", 0, Time.now
     tar << tar_file_header("bar", "baz", 0, 0, Time.now)
@@ -26,11 +25,11 @@ class TestGemPackageTarReader < Gem::Pac
   end
 
   def test_rewind
-    content = ('a'..'z').to_a.join(" ")
+    content = ("a".."z").to_a.join(" ")
 
     str =
       tar_file_header("lib/foo", "", 010644, content.size, Time.now) +
-        content + "\0" * (512 - content.size)
+      content + "\0" * (512 - content.size)
     str << "\0" * 1024
 
     io = TempIO.new(str)
@@ -57,10 +56,10 @@ class TestGemPackageTarReader < Gem::Pac
     io = TempIO.new tar
 
     Gem::Package::TarReader.new io do |tar_reader|
-      tar_reader.seek 'baz/bar' do |entry|
+      tar_reader.seek "baz/bar" do |entry|
         assert_kind_of Gem::Package::TarReader::Entry, entry
 
-        assert_equal 'baz/bar', entry.full_name
+        assert_equal "baz/bar", entry.full_name
       end
 
       assert_equal 0, io.pos
@@ -76,8 +75,8 @@ class TestGemPackageTarReader < Gem::Pac
     io = TempIO.new tar
 
     Gem::Package::TarReader.new io do |tar_reader|
-      tar_reader.seek 'nonexistent' do |entry|
-        flunk 'entry missing but entry-found block was run'
+      tar_reader.seek "nonexistent" do |entry|
+        flunk "entry missing but entry-found block was run"
       end
 
       assert_equal 0, io.pos
@@ -85,5 +84,4 @@ class TestGemPackageTarReader < Gem::Pac
   ensure
     io.close!
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_package_tar_reader_entry.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_package_tar_reader_entry.rb
@@ -1,13 +1,12 @@
 # frozen_string_literal: true
-require 'rubygems/package/tar_test_case'
-require 'rubygems/package'
+require_relative "package/tar_test_case"
+require "rubygems/package"
 
 class TestGemPackageTarReaderEntry < Gem::Package::TarTestCase
-
   def setup
     super
 
-    @contents = ('a'..'z').to_a.join * 100
+    @contents = ("a".."z").to_a.join * 100
 
     @tar = String.new
     @tar << tar_file_header("lib/foo", "", 0, @contents.size, Time.now)
@@ -43,20 +42,20 @@ class TestGemPackageTarReaderEntry < Gem
 
     assert @entry.bytes_read
 
-    e = assert_raises(IOError) { @entry.eof? }
-    assert_equal 'closed Gem::Package::TarReader::Entry', e.message
+    e = assert_raise(IOError) { @entry.eof? }
+    assert_equal "closed Gem::Package::TarReader::Entry", e.message
 
-    e = assert_raises(IOError) { @entry.getc }
-    assert_equal 'closed Gem::Package::TarReader::Entry', e.message
+    e = assert_raise(IOError) { @entry.getc }
+    assert_equal "closed Gem::Package::TarReader::Entry", e.message
 
-    e = assert_raises(IOError) { @entry.pos }
-    assert_equal 'closed Gem::Package::TarReader::Entry', e.message
+    e = assert_raise(IOError) { @entry.pos }
+    assert_equal "closed Gem::Package::TarReader::Entry", e.message
 
-    e = assert_raises(IOError) { @entry.read }
-    assert_equal 'closed Gem::Package::TarReader::Entry', e.message
+    e = assert_raise(IOError) { @entry.read }
+    assert_equal "closed Gem::Package::TarReader::Entry", e.message
 
-    e = assert_raises(IOError) { @entry.rewind }
-    assert_equal 'closed Gem::Package::TarReader::Entry', e.message
+    e = assert_raise(IOError) { @entry.rewind }
+    assert_equal "closed Gem::Package::TarReader::Entry", e.message
   end
 
   def test_closed_eh
@@ -72,18 +71,18 @@ class TestGemPackageTarReaderEntry < Gem
   end
 
   def test_full_name
-    assert_equal 'lib/foo', @entry.full_name
+    assert_equal "lib/foo", @entry.full_name
   end
 
   def test_full_name_null
-    skip "jruby strips the null byte and does not think it's corrupt" if Gem.java_platform?
+    pend "jruby strips the null byte and does not think it's corrupt" if Gem.java_platform?
     @entry.header.prefix << "\000"
 
-    e = assert_raises Gem::Package::TarInvalidError do
+    e = assert_raise Gem::Package::TarInvalidError do
       @entry.full_name
     end
 
-    assert_equal 'tar is corrupt, name contains null byte', e.message
+    assert_equal "tar is corrupt, name contains null byte", e.message
   end
 
   def test_getc
@@ -135,7 +134,7 @@ class TestGemPackageTarReaderEntry < Gem
   end
 
   def test_readpartial
-    assert_raises(EOFError) do
+    assert_raise(EOFError) do
       @entry.read(@contents.size)
       @entry.readpartial(1)
     end
@@ -150,5 +149,4 @@ class TestGemPackageTarReaderEntry < Gem
 
     assert_equal char, @entry.getc
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_package_tar_writer.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_package_tar_writer.rb
@@ -1,10 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/package/tar_test_case'
-require 'rubygems/package/tar_writer'
-require 'minitest/mock'
+require_relative "package/tar_test_case"
+require "rubygems/package/tar_writer"
 
 class TestGemPackageTarWriter < Gem::Package::TarTestCase
-
   def setup
     super
 
@@ -13,7 +11,7 @@ class TestGemPackageTarWriter < Gem::Pac
     # is not set.
     Gem.instance_variable_set(:'@default_source_date_epoch', nil)
 
-    @data = 'abcde12345'
+    @data = "abcde12345"
     @io = TempIO.new
     @tar_writer = Gem::Package::TarWriter.new @io
     @epoch = ENV["SOURCE_DATE_EPOCH"]
@@ -30,11 +28,11 @@ class TestGemPackageTarWriter < Gem::Pac
 
   def test_add_file
     Time.stub :now, Time.at(1458518157) do
-      @tar_writer.add_file 'x', 0644 do |f|
-        f.write 'a' * 10
+      @tar_writer.add_file "x", 0644 do |f|
+        f.write "a" * 10
       end
 
-      assert_headers_equal(tar_file_header('x', '', 0644, 10, Time.now),
+      assert_headers_equal(tar_file_header("x", "", 0644, 10, Time.now),
                          @io.string[0, 512])
     end
     assert_equal "aaaaaaaaaa#{"\0" * 502}", @io.string[512, 512]
@@ -44,18 +42,18 @@ class TestGemPackageTarWriter < Gem::Pac
   def test_add_file_source_date_epoch
     ENV["SOURCE_DATE_EPOCH"] = "123456789"
     Time.stub :now, Time.at(1458518157) do
-      @tar_writer.mkdir 'foo', 0644
+      @tar_writer.mkdir "foo", 0644
 
-      assert_headers_equal tar_dir_header('foo', '', 0644, Time.at(ENV["SOURCE_DATE_EPOCH"].to_i).utc),
+      assert_headers_equal tar_dir_header("foo", "", 0644, Time.at(ENV["SOURCE_DATE_EPOCH"].to_i).utc),
                            @io.string[0, 512]
     end
   end
 
   def test_add_symlink
     Time.stub :now, Time.at(1458518157) do
-      @tar_writer.add_symlink 'x', 'y', 0644
+      @tar_writer.add_symlink "x", "y", 0644
 
-      assert_headers_equal(tar_symlink_header('x', '', 0644, Time.now, 'y'),
+      assert_headers_equal(tar_symlink_header("x", "", 0644, Time.now, "y"),
                          @io.string[0, 512])
     end
     assert_equal 512, @io.pos
@@ -64,30 +62,30 @@ class TestGemPackageTarWriter < Gem::Pac
   def test_add_symlink_source_date_epoch
     ENV["SOURCE_DATE_EPOCH"] = "123456789"
     Time.stub :now, Time.at(1458518157) do
-      @tar_writer.add_symlink 'x', 'y', 0644
+      @tar_writer.add_symlink "x", "y", 0644
 
-      assert_headers_equal(tar_symlink_header('x', '', 0644, Time.at(ENV["SOURCE_DATE_EPOCH"].to_i).utc, 'y'),
+      assert_headers_equal(tar_symlink_header("x", "", 0644, Time.at(ENV["SOURCE_DATE_EPOCH"].to_i).utc, "y"),
                          @io.string[0, 512])
     end
   end
 
   def test_add_file_digest
-    digest_algorithms = Digest::SHA1, Digest::SHA512
+    digest_algorithms = Digest::SHA1.new, Digest::SHA512.new
 
     Time.stub :now, Time.at(1458518157) do
-      digests = @tar_writer.add_file_digest 'x', 0644, digest_algorithms do |io|
-        io.write 'a' * 10
+      digests = @tar_writer.add_file_digest "x", 0644, digest_algorithms do |io|
+        io.write "a" * 10
       end
 
-      assert_equal '3495ff69d34671d1e15b33a63c1379fdedd3a32a',
-                   digests['SHA1'].hexdigest
-      assert_equal '4714870aff6c97ca09d135834fdb58a6389a50c1' \
-                   '1fef8ec4afef466fb60a23ac6b7a9c92658f14df' \
-                   '4993d6b40a4e4d8424196afc347e97640d68de61' \
-                   'e1cf14b0',
-                   digests['SHA512'].hexdigest
+      assert_equal "3495ff69d34671d1e15b33a63c1379fdedd3a32a",
+                   digests["SHA1"].hexdigest
+      assert_equal "4714870aff6c97ca09d135834fdb58a6389a50c1" \
+                   "1fef8ec4afef466fb60a23ac6b7a9c92658f14df" \
+                   "4993d6b40a4e4d8424196afc347e97640d68de61" \
+                   "e1cf14b0",
+                   digests["SHA512"].hexdigest
 
-      assert_headers_equal(tar_file_header('x', '', 0644, 10, Time.now),
+      assert_headers_equal(tar_file_header("x", "", 0644, 10, Time.now),
                          @io.string[0, 512])
     end
     assert_equal "aaaaaaaaaa#{"\0" * 502}", @io.string[512, 512]
@@ -95,22 +93,22 @@ class TestGemPackageTarWriter < Gem::Pac
   end
 
   def test_add_file_digest_multiple
-    digest_algorithms = [Digest::SHA1, Digest::SHA512]
+    digest_algorithms = [Digest::SHA1.new, Digest::SHA512.new]
 
     Time.stub :now, Time.at(1458518157) do
-      digests = @tar_writer.add_file_digest 'x', 0644, digest_algorithms do |io|
-        io.write 'a' * 10
+      digests = @tar_writer.add_file_digest "x", 0644, digest_algorithms do |io|
+        io.write "a" * 10
       end
 
-      assert_equal '3495ff69d34671d1e15b33a63c1379fdedd3a32a',
-                   digests['SHA1'].hexdigest
-      assert_equal '4714870aff6c97ca09d135834fdb58a6389a50c1' \
-                   '1fef8ec4afef466fb60a23ac6b7a9c92658f14df' \
-                   '4993d6b40a4e4d8424196afc347e97640d68de61' \
-                   'e1cf14b0',
-                   digests['SHA512'].hexdigest
+      assert_equal "3495ff69d34671d1e15b33a63c1379fdedd3a32a",
+                   digests["SHA1"].hexdigest
+      assert_equal "4714870aff6c97ca09d135834fdb58a6389a50c1" \
+                   "1fef8ec4afef466fb60a23ac6b7a9c92658f14df" \
+                   "4993d6b40a4e4d8424196afc347e97640d68de61" \
+                   "e1cf14b0",
+                   digests["SHA512"].hexdigest
 
-      assert_headers_equal(tar_file_header('x', '', 0644, 10, Time.now),
+      assert_headers_equal(tar_file_header("x", "", 0644, 10, Time.now),
                            @io.string[0, 512])
     end
     assert_equal "aaaaaaaaaa#{"\0" * 502}", @io.string[512, 512]
@@ -118,26 +116,26 @@ class TestGemPackageTarWriter < Gem::Pac
   end
 
   def test_add_file_signer
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
+    pend "openssl is missing" unless Gem::HAVE_OPENSSL
 
     signer = Gem::Security::Signer.new PRIVATE_KEY, [PUBLIC_CERT]
 
     Time.stub :now, Time.at(1458518157) do
-      @tar_writer.add_file_signed 'x', 0644, signer do |io|
-        io.write 'a' * 10
+      @tar_writer.add_file_signed "x", 0644, signer do |io|
+        io.write "a" * 10
       end
 
-      assert_headers_equal(tar_file_header('x', '', 0644, 10, Time.now),
+      assert_headers_equal(tar_file_header("x", "", 0644, 10, Time.now),
                            @io.string[0, 512])
 
       assert_equal "aaaaaaaaaa#{"\0" * 502}", @io.string[512, 512]
 
       digest = signer.digest_algorithm.new
-      digest.update 'a' * 10
+      digest.update "a" * 10
 
       signature = signer.sign digest.digest
 
-      assert_headers_equal(tar_file_header('x.sig', '', 0444, signature.length,
+      assert_headers_equal(tar_file_header("x.sig", "", 0444, signature.length,
                                            Time.now),
                            @io.string[1024, 512])
       assert_equal "#{signature}#{"\0" * (512 - signature.length)}",
@@ -151,13 +149,12 @@ class TestGemPackageTarWriter < Gem::Pac
     signer = Gem::Security::Signer.new nil, nil
 
     Time.stub :now, Time.at(1458518157) do
-
-      @tar_writer.add_file_signed 'x', 0644, signer do |io|
-        io.write 'a' * 10
+      @tar_writer.add_file_signed "x", 0644, signer do |io|
+        io.write "a" * 10
       end
 
-      assert_headers_equal(tar_file_header('x', '', 0644, 10, Time.now),
-                         @io.string[0, 512])
+      assert_headers_equal(tar_file_header("x", "", 0644, 10, Time.now),
+                           @io.string[0, 512])
     end
     assert_equal "aaaaaaaaaa#{"\0" * 502}", @io.string[512, 512]
 
@@ -166,43 +163,43 @@ class TestGemPackageTarWriter < Gem::Pac
 
   def test_add_file_simple
     Time.stub :now, Time.at(1458518157) do
-      @tar_writer.add_file_simple 'x', 0644, 10 do |io|
+      @tar_writer.add_file_simple "x", 0644, 10 do |io|
         io.write "a" * 10
       end
 
-      assert_headers_equal(tar_file_header('x', '', 0644, 10, Time.now),
-                         @io.string[0, 512])
-    end
+      assert_headers_equal(tar_file_header("x", "", 0644, 10, Time.now),
+                           @io.string[0, 512])
 
-    assert_equal "aaaaaaaaaa#{"\0" * 502}", @io.string[512, 512]
-    assert_equal 1024, @io.pos
+      assert_equal "aaaaaaaaaa#{"\0" * 502}", @io.string[512, 512]
+      assert_equal 1024, @io.pos
+    end
   end
 
   def test_add_file_simple_source_date_epoch
     ENV["SOURCE_DATE_EPOCH"] = "123456789"
     Time.stub :now, Time.at(1458518157) do
-      @tar_writer.add_file_simple 'x', 0644, 10 do |io|
+      @tar_writer.add_file_simple "x", 0644, 10 do |io|
         io.write "a" * 10
       end
 
-      assert_headers_equal(tar_file_header('x', '', 0644, 10, Time.at(ENV["SOURCE_DATE_EPOCH"].to_i).utc),
-                         @io.string[0, 512])
+      assert_headers_equal(tar_file_header("x", "", 0644, 10, Time.at(ENV["SOURCE_DATE_EPOCH"].to_i).utc),
+                           @io.string[0, 512])
     end
   end
 
   def test_add_file_simple_padding
     Time.stub :now, Time.at(1458518157) do
-      @tar_writer.add_file_simple 'x', 0, 100
+      @tar_writer.add_file_simple "x", 0, 100
 
-      assert_headers_equal tar_file_header('x', '', 0, 100, Time.now),
-                         @io.string[0, 512]
+      assert_headers_equal tar_file_header("x", "", 0, 100, Time.now),
+        @io.string[0, 512]
     end
 
     assert_equal "\0" * 512, @io.string[512, 512]
   end
 
   def test_add_file_simple_data
-    @tar_writer.add_file_simple("lib/foo/bar", 0, 10) { |f| f.write @data }
+    @tar_writer.add_file_simple("lib/foo/bar", 0, 10) {|f| f.write @data }
     @tar_writer.flush
 
     assert_equal @data + ("\0" * (512 - @data.size)),
@@ -210,7 +207,7 @@ class TestGemPackageTarWriter < Gem::Pac
   end
 
   def test_add_file_simple_size
-    assert_raises Gem::Package::TarWriter::FileOverflow do
+    assert_raise Gem::Package::TarWriter::FileOverflow do
       @tar_writer.add_file_simple("lib/foo/bar", 0, 10) do |io|
         io.write "1" * 11
       end
@@ -222,37 +219,37 @@ class TestGemPackageTarWriter < Gem::Pac
 
     assert_equal "\0" * 1024, @io.string
 
-    e = assert_raises IOError do
+    e = assert_raise IOError do
       @tar_writer.close
     end
-    assert_equal 'closed Gem::Package::TarWriter', e.message
+    assert_equal "closed Gem::Package::TarWriter", e.message
 
-    e = assert_raises IOError do
+    e = assert_raise IOError do
       @tar_writer.flush
     end
-    assert_equal 'closed Gem::Package::TarWriter', e.message
+    assert_equal "closed Gem::Package::TarWriter", e.message
 
-    e = assert_raises IOError do
-      @tar_writer.add_file 'x', 0
+    e = assert_raise IOError do
+      @tar_writer.add_file "x", 0
     end
-    assert_equal 'closed Gem::Package::TarWriter', e.message
+    assert_equal "closed Gem::Package::TarWriter", e.message
 
-    e = assert_raises IOError do
-      @tar_writer.add_file_simple 'x', 0, 0
+    e = assert_raise IOError do
+      @tar_writer.add_file_simple "x", 0, 0
     end
-    assert_equal 'closed Gem::Package::TarWriter', e.message
+    assert_equal "closed Gem::Package::TarWriter", e.message
 
-    e = assert_raises IOError do
-      @tar_writer.mkdir 'x', 0
+    e = assert_raise IOError do
+      @tar_writer.mkdir "x", 0
     end
-    assert_equal 'closed Gem::Package::TarWriter', e.message
+    assert_equal "closed Gem::Package::TarWriter", e.message
   end
 
   def test_mkdir
     Time.stub :now, Time.at(1458518157) do
-      @tar_writer.mkdir 'foo', 0644
+      @tar_writer.mkdir "foo", 0644
 
-      assert_headers_equal tar_dir_header('foo', '', 0644, Time.now),
+      assert_headers_equal tar_dir_header("foo", "", 0644, Time.now),
                            @io.string[0, 512]
 
       assert_equal 512, @io.pos
@@ -262,73 +259,72 @@ class TestGemPackageTarWriter < Gem::Pac
   def test_mkdir_source_date_epoch
     ENV["SOURCE_DATE_EPOCH"] = "123456789"
     Time.stub :now, Time.at(1458518157) do
-      @tar_writer.mkdir 'foo', 0644
+      @tar_writer.mkdir "foo", 0644
 
-      assert_headers_equal tar_dir_header('foo', '', 0644, Time.at(ENV["SOURCE_DATE_EPOCH"].to_i).utc),
+      assert_headers_equal tar_dir_header("foo", "", 0644, Time.at(ENV["SOURCE_DATE_EPOCH"].to_i).utc),
                            @io.string[0, 512]
     end
   end
 
   def test_split_name
-    assert_equal ['b' * 100, 'a' * 155],
+    assert_equal ["b" * 100, "a" * 155],
                  @tar_writer.split_name("#{'a' * 155}/#{'b' * 100}")
 
-    assert_equal ["#{'qwer/' * 19}bla", 'a' * 151],
+    assert_equal ["#{'qwer/' * 19}bla", "a" * 151],
                  @tar_writer.split_name("#{'a' * 151}/#{'qwer/' * 19}bla")
     names = [
-      ([''] + ['123456789'] * 9 + ['1234567890']).join('/'),  # 101 bytes (several pieces)
-      (['123456789'] * 9 + ['1234567890'] + ['']).join('/'),  # 101 bytes (several pieces)
-      '/' * 99,
-      '/' * 100,
-      '/' * 101,
-      '/' * 102,
+      ([""] + ["123456789"] * 9 + ["1234567890"]).join("/"),  # 101 bytes (several pieces)
+      (["123456789"] * 9 + ["1234567890"] + [""]).join("/"),  # 101 bytes (several pieces)
+      "/" * 99,
+      "/" * 100,
+      "/" * 101,
+      "/" * 102,
     ]
     names.each do |name|
       newname, prefix = @tar_writer.split_name(name)
       assert(!(newname.empty?), "split_name() returned empty name")
       assert(newname.bytesize <= 100, "split_name() returned name longer than 100 bytes: '#{newname}' for '#{name}'")
       assert(prefix.bytesize <= 155, "split_name() returned prefix longer than 155 bytes: '#{prefix}' for '#{name}'")
-      newname = [prefix, newname].join('/') unless prefix.empty?
+      newname = [prefix, newname].join("/") unless prefix.empty?
       assert_equal name, newname
     end
   end
 
   def test_split_name_too_long_name
-    name = File.join 'a', 'b' * 100
-    assert_equal ['b' * 100, 'a'], @tar_writer.split_name(name)
+    name = File.join "a", "b" * 100
+    assert_equal ["b" * 100, "a"], @tar_writer.split_name(name)
 
-    name = File.join 'a', 'b' * 101
-    exception = assert_raises Gem::Package::TooLongFileName do
+    name = File.join "a", "b" * 101
+    exception = assert_raise Gem::Package::TooLongFileName do
       @tar_writer.split_name name
     end
     assert_includes exception.message, name
 
     # note, GNU tar 1.28 is unable to handle this case too,
     # tested with "tar --format=ustar -cPf /tmp/foo.tartar -- /aaaaaa....a"
-    name = '/' + 'a' * 100
-    exception = assert_raises Gem::Package::TooLongFileName do
+    name = "/" + "a" * 100
+    exception = assert_raise Gem::Package::TooLongFileName do
       @tar_writer.split_name name
     end
     assert_includes exception.message, name
   end
 
   def test_split_name_too_long_prefix
-    name = File.join 'a' * 155, 'b'
-    assert_equal ['b', 'a' * 155], @tar_writer.split_name(name)
+    name = File.join "a" * 155, "b"
+    assert_equal ["b", "a" * 155], @tar_writer.split_name(name)
 
-    name = File.join 'a' * 156, 'b'
-    exception = assert_raises Gem::Package::TooLongFileName do
+    name = File.join "a" * 156, "b"
+    exception = assert_raise Gem::Package::TooLongFileName do
       @tar_writer.split_name name
     end
     assert_includes exception.message, name
   end
 
   def test_split_name_too_long_total
-    name = 'a' * 257
-    exception = assert_raises Gem::Package::TooLongFileName do
+    name = "a" * 257
+    exception = assert_raise Gem::Package::TooLongFileName do
       @tar_writer.split_name name
     end
     assert_includes exception.message, name
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_package_task.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_package_task.rb
@@ -1,45 +1,79 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems'
-require 'bundler/errors'
+require_relative "helper"
+require "rubygems"
+
 begin
-  require 'rubygems/package_task'
-rescue LoadError, Bundler::GemfileNotFound
+  require "rubygems/package_task"
+rescue LoadError => e
+  raise unless e.path == "rake/packagetask"
 end
 
-class TestGemPackageTask < Gem::TestCase
-
-  def setup
-    super
+unless defined?(Rake::PackageTask)
+  warn "Skipping Gem::PackageTask tests.  rake not found."
+end
 
-    Rake.application = Rake::Application.new
+class TestGemPackageTask < Gem::TestCase
+  def test_gem_package
+    original_rake_fileutils_verbosity = RakeFileUtils.verbose_flag
     RakeFileUtils.verbose_flag = false
-  end
 
-  def test_gem_package
     gem = Gem::Specification.new do |g|
       g.name = "pkgr"
       g.version = "1.2.3"
 
       g.authors = %w[author]
       g.files = %w[x]
-      g.summary = 'summary'
+      g.summary = "summary"
     end
 
-    pkg = Gem::PackageTask.new(gem)  do |p|
+    Rake.application = Rake::Application.new
+
+    pkg = Gem::PackageTask.new(gem) do |p|
       p.package_files << "y"
     end
 
     assert_equal %w[x y], pkg.package_files
 
     Dir.chdir @tempdir do
-      FileUtils.touch 'x'
-      FileUtils.touch 'y'
+      FileUtils.touch "x"
+      FileUtils.touch "y"
+
+      Rake.application["package"].invoke
+
+      assert_path_exist "pkg/pkgr-1.2.3.gem"
+    end
+  ensure
+    RakeFileUtils.verbose_flag = original_rake_fileutils_verbosity
+  end
+
+  def test_gem_package_prints_to_stdout_by_default
+    gem = Gem::Specification.new do |g|
+      g.name = "pkgr"
+      g.version = "1.2.3"
+
+      g.authors = %w[author]
+      g.files = %w[x]
+      g.summary = "summary"
+    end
+
+    _, err = capture_output do
+      Rake.application = Rake::Application.new
+
+      pkg = Gem::PackageTask.new(gem) do |p|
+        p.package_files << "y"
+      end
 
-      Rake.application['package'].invoke
+      assert_equal %w[x y], pkg.package_files
 
-      assert_path_exists 'pkg/pkgr-1.2.3.gem'
+      Dir.chdir @tempdir do
+        FileUtils.touch "x"
+        FileUtils.touch "y"
+
+        Rake.application["package"].invoke
+      end
     end
+
+    assert_empty err
   end
 
   def test_gem_package_with_current_platform
@@ -49,7 +83,7 @@ class TestGemPackageTask < Gem::TestCase
       g.files = Rake::FileList["x"].resolve
       g.platform = Gem::Platform::CURRENT
     end
-    pkg = Gem::PackageTask.new(gem)  do |p|
+    pkg = Gem::PackageTask.new(gem) do |p|
       p.package_files << "y"
     end
     assert_equal ["x", "y"], pkg.package_files
@@ -62,7 +96,7 @@ class TestGemPackageTask < Gem::TestCase
       g.files = Rake::FileList["x"].resolve
       g.platform = Gem::Platform::RUBY
     end
-    pkg = Gem::PackageTask.new(gem)  do |p|
+    pkg = Gem::PackageTask.new(gem) do |p|
       p.package_files << "y"
     end
     assert_equal ["x", "y"], pkg.package_files
@@ -70,15 +104,14 @@ class TestGemPackageTask < Gem::TestCase
 
   def test_package_dir_path
     gem = Gem::Specification.new do |g|
-      g.name = 'nokogiri'
-      g.version = '1.5.0'
-      g.platform = 'java'
+      g.name = "nokogiri"
+      g.version = "1.5.0"
+      g.platform = "java"
     end
 
     pkg = Gem::PackageTask.new gem
     pkg.define
 
-    assert_equal 'pkg/nokogiri-1.5.0-java', pkg.package_dir_path
+    assert_equal "pkg/nokogiri-1.5.0-java", pkg.package_dir_path
   end
-
 end if defined?(Rake::PackageTask)
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_path_support.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_path_support.rb
@@ -1,10 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems'
-require 'fileutils'
+require_relative "helper"
+require "rubygems"
+require "fileutils"
 
 class TestGemPathSupport < Gem::TestCase
-
   def setup
     super
 
@@ -17,7 +16,7 @@ class TestGemPathSupport < Gem::TestCase
 
     assert_equal ENV["GEM_HOME"], ps.home
 
-    expected = util_path
+    expected = ENV["GEM_PATH"].split(File::PATH_SEPARATOR)
     assert_equal expected, ps.path, "defaults to GEM_PATH"
   end
 
@@ -26,7 +25,7 @@ class TestGemPathSupport < Gem::TestCase
 
     assert_equal File.join(@tempdir, "foo"), ps.home
 
-    expected = util_path + [File.join(@tempdir, 'foo')]
+    expected = ENV["GEM_PATH"].split(File::PATH_SEPARATOR) + [File.join(@tempdir, "foo")]
     assert_equal expected, ps.path
   end
 
@@ -46,8 +45,8 @@ class TestGemPathSupport < Gem::TestCase
       assert_equal ENV["GEM_HOME"], ps.home
 
       expected = [
-        File.join(@tempdir, 'foo'),
-        File.join(@tempdir, 'bar'),
+        File.join(@tempdir, "foo"),
+        File.join(@tempdir, "bar"),
         ENV["GEM_HOME"],
       ]
 
@@ -66,8 +65,8 @@ class TestGemPathSupport < Gem::TestCase
       assert_equal ENV["GEM_HOME"], ps.home
 
       expected = [
-        File.join(@tempdir, 'foo'),
-        File.join(@tempdir, 'bar'),
+        File.join(@tempdir, "foo"),
+        File.join(@tempdir, "bar"),
       ] + Gem.default_path << ENV["GEM_HOME"]
 
       assert_equal expected, ps.path
@@ -84,8 +83,8 @@ class TestGemPathSupport < Gem::TestCase
     assert_equal ENV["GEM_HOME"], ps.home
 
     expected = [
-      File.join(@tempdir, 'foo'),
-      File.join(@tempdir, 'bar'),
+      File.join(@tempdir, "foo"),
+      File.join(@tempdir, "bar"),
     ] + Gem.default_path << ENV["GEM_HOME"]
 
     assert_equal expected, ps.path
@@ -98,27 +97,23 @@ class TestGemPathSupport < Gem::TestCase
 
       assert_equal File.join(@tempdir, "foo"), ps.home
 
-      expected = [File.join(@tempdir, 'foo'), File.join(@tempdir, 'bar')]
+      expected = [File.join(@tempdir, "foo"), File.join(@tempdir, "bar")]
       assert_equal expected, ps.path
     end
   end
 
-  def util_path
-    ENV["GEM_PATH"].split(File::PATH_SEPARATOR)
-  end
-
   def test_initialize_spec
     ENV["GEM_SPEC_CACHE"] = nil
 
     ps = Gem::PathSupport.new ENV
     assert_equal Gem.default_spec_cache_dir, ps.spec_cache_dir
 
-    ENV["GEM_SPEC_CACHE"] = 'bar'
+    ENV["GEM_SPEC_CACHE"] = "bar"
 
     ps = Gem::PathSupport.new ENV
     assert_equal ENV["GEM_SPEC_CACHE"], ps.spec_cache_dir
 
-    ENV["GEM_SPEC_CACHE"] = File.join @tempdir, 'spec_cache'
+    ENV["GEM_SPEC_CACHE"] = File.join @tempdir, "spec_cache"
 
     ps = Gem::PathSupport.new "GEM_SPEC_CACHE" => "foo"
     assert_equal "foo", ps.spec_cache_dir
@@ -131,7 +126,7 @@ class TestGemPathSupport < Gem::TestCase
     begin
       File.symlink(dir, symlink)
     rescue NotImplementedError, SystemCallError
-      skip 'symlinks not supported'
+      pend "symlinks not supported"
     end
     not_existing = "#{@tempdir}/does_not_exist"
     path = "#{symlink}#{File::PATH_SEPARATOR}#{not_existing}"
@@ -140,5 +135,4 @@ class TestGemPathSupport < Gem::TestCase
     assert_equal dir, ps.home
     assert_equal [dir, not_existing], ps.path
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_platform.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_platform.rb
@@ -1,155 +1,221 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/platform'
-require 'rbconfig'
+require_relative "helper"
+require "rubygems/platform"
+require "rbconfig"
 
 class TestGemPlatform < Gem::TestCase
-
   def test_self_local
-    util_set_arch 'i686-darwin8.10.1'
+    util_set_arch "i686-darwin8.10.1"
 
     assert_equal Gem::Platform.new(%w[x86 darwin 8]), Gem::Platform.local
   end
 
   def test_self_match
-    assert Gem::Platform.match(nil), 'nil == ruby'
-    assert Gem::Platform.match(Gem::Platform.local), 'exact match'
-    assert Gem::Platform.match(Gem::Platform.local.to_s), '=~ match'
-    assert Gem::Platform.match(Gem::Platform::RUBY), 'ruby'
+    Gem::Deprecate.skip_during do
+      assert Gem::Platform.match(nil), "nil == ruby"
+      assert Gem::Platform.match(Gem::Platform.local), "exact match"
+      assert Gem::Platform.match(Gem::Platform.local.to_s), "=~ match"
+      assert Gem::Platform.match(Gem::Platform::RUBY), "ruby"
+    end
+  end
+
+  def test_self_match_gem?
+    assert Gem::Platform.match_gem?(nil, "json"), "nil == ruby"
+    assert Gem::Platform.match_gem?(Gem::Platform.local, "json"), "exact match"
+    assert Gem::Platform.match_gem?(Gem::Platform.local.to_s, "json"), "=~ match"
+    assert Gem::Platform.match_gem?(Gem::Platform::RUBY, "json"), "ruby"
+  end
+
+  def test_self_match_spec?
+    make_spec = -> platform do
+      util_spec "mygem-for-platform-match_spec", "1" do |s|
+        s.platform = platform
+      end
+    end
+
+    assert Gem::Platform.match_spec?(make_spec.call(nil)), "nil == ruby"
+    assert Gem::Platform.match_spec?(make_spec.call(Gem::Platform.local)), "exact match"
+    assert Gem::Platform.match_spec?(make_spec.call(Gem::Platform.local.to_s)), "=~ match"
+    assert Gem::Platform.match_spec?(make_spec.call(Gem::Platform::RUBY)), "ruby"
+  end
+
+  def test_self_match_spec_with_match_gem_override
+    make_spec = -> name, platform do
+      util_spec name, "1" do |s|
+        s.platform = platform
+      end
+    end
+
+    class << Gem::Platform
+      alias_method :original_match_gem?, :match_gem?
+      def match_gem?(platform, gem_name)
+        # e.g., sassc and libv8 are such gems, their native extensions do not use the Ruby C API
+        if gem_name == "gem-with-ruby-impl-independent-precompiled-ext"
+          match_platforms?(platform, [Gem::Platform::RUBY, Gem::Platform.local])
+        else
+          match_platforms?(platform, Gem.platforms)
+        end
+      end
+    end
+
+    platforms = Gem.platforms
+    Gem.platforms = [Gem::Platform::RUBY]
+    begin
+      assert_equal true,  Gem::Platform.match_spec?(make_spec.call("mygem", Gem::Platform::RUBY))
+      assert_equal false, Gem::Platform.match_spec?(make_spec.call("mygem", Gem::Platform.local))
+
+      name = "gem-with-ruby-impl-independent-precompiled-ext"
+      assert_equal true, Gem::Platform.match_spec?(make_spec.call(name, Gem::Platform.local))
+    ensure
+      Gem.platforms = platforms
+      class << Gem::Platform
+        remove_method :match_gem?
+        alias_method :match_gem?, :original_match_gem? # rubocop:disable Lint/DuplicateMethods
+        remove_method :original_match_gem?
+      end
+    end
   end
 
   def test_self_new
     assert_equal Gem::Platform.local, Gem::Platform.new(Gem::Platform::CURRENT)
     assert_equal Gem::Platform::RUBY, Gem::Platform.new(Gem::Platform::RUBY)
     assert_equal Gem::Platform::RUBY, Gem::Platform.new(nil)
-    assert_equal Gem::Platform::RUBY, Gem::Platform.new('')
+    assert_equal Gem::Platform::RUBY, Gem::Platform.new("")
   end
 
   def test_initialize
     test_cases = {
-      'amd64-freebsd6'         => ['amd64',     'freebsd',   '6'],
-      'hppa2.0w-hpux11.31'     => ['hppa2.0w',  'hpux',      '11'],
-      'java'                   => [nil,         'java',      nil],
-      'jruby'                  => [nil,         'java',      nil],
-      'universal-dotnet'       => ['universal', 'dotnet',    nil],
-      'universal-dotnet2.0'    => ['universal', 'dotnet',  '2.0'],
-      'universal-dotnet4.0'    => ['universal', 'dotnet',  '4.0'],
-      'powerpc-aix5.3.0.0'     => ['powerpc',   'aix',       '5'],
-      'powerpc-darwin7'        => ['powerpc',   'darwin',    '7'],
-      'powerpc-darwin8'        => ['powerpc',   'darwin',    '8'],
-      'powerpc-linux'          => ['powerpc',   'linux',     nil],
-      'powerpc64-linux'        => ['powerpc64', 'linux',     nil],
-      'sparc-solaris2.10'      => ['sparc',     'solaris',   '2.10'],
-      'sparc-solaris2.8'       => ['sparc',     'solaris',   '2.8'],
-      'sparc-solaris2.9'       => ['sparc',     'solaris',   '2.9'],
-      'universal-darwin8'      => ['universal', 'darwin',    '8'],
-      'universal-darwin9'      => ['universal', 'darwin',    '9'],
-      'universal-macruby'      => ['universal', 'macruby',   nil],
-      'i386-cygwin'            => ['x86',       'cygwin',    nil],
-      'i686-darwin'            => ['x86',       'darwin',    nil],
-      'i686-darwin8.4.1'       => ['x86',       'darwin',    '8'],
-      'i386-freebsd4.11'       => ['x86',       'freebsd',   '4'],
-      'i386-freebsd5'          => ['x86',       'freebsd',   '5'],
-      'i386-freebsd6'          => ['x86',       'freebsd',   '6'],
-      'i386-freebsd7'          => ['x86',       'freebsd',   '7'],
-      'i386-freebsd'           => ['x86',       'freebsd',   nil],
-      'universal-freebsd'      => ['universal', 'freebsd',   nil],
-      'i386-java1.5'           => ['x86',       'java',      '1.5'],
-      'x86-java1.6'            => ['x86',       'java',      '1.6'],
-      'i386-java1.6'           => ['x86',       'java',      '1.6'],
-      'i686-linux'             => ['x86',       'linux',     nil],
-      'i586-linux'             => ['x86',       'linux',     nil],
-      'i486-linux'             => ['x86',       'linux',     nil],
-      'i386-linux'             => ['x86',       'linux',     nil],
-      'i586-linux-gnu'         => ['x86',       'linux',     nil],
-      'i386-linux-gnu'         => ['x86',       'linux',     nil],
-      'i386-mingw32'           => ['x86',       'mingw32',   nil],
-      'i386-mswin32'           => ['x86',       'mswin32',   nil],
-      'i386-mswin32_80'        => ['x86',       'mswin32',   '80'],
-      'i386-mswin32-80'        => ['x86',       'mswin32',   '80'],
-      'x86-mswin32'            => ['x86',       'mswin32',   nil],
-      'x86-mswin32_60'         => ['x86',       'mswin32',   '60'],
-      'x86-mswin32-60'         => ['x86',       'mswin32',   '60'],
-      'i386-netbsdelf'         => ['x86',       'netbsdelf', nil],
-      'i386-openbsd4.0'        => ['x86',       'openbsd',   '4.0'],
-      'i386-solaris2.10'       => ['x86',       'solaris',   '2.10'],
-      'i386-solaris2.8'        => ['x86',       'solaris',   '2.8'],
-      'mswin32'                => ['x86',       'mswin32',   nil],
-      'x86_64-linux'           => ['x86_64',    'linux',     nil],
-      'x86_64-linux-musl'      => ['x86_64',    'linux',     'musl'],
-      'x86_64-openbsd3.9'      => ['x86_64',    'openbsd',   '3.9'],
-      'x86_64-openbsd4.0'      => ['x86_64',    'openbsd',   '4.0'],
-      'x86_64-openbsd'         => ['x86_64',    'openbsd',   nil],
+      "amd64-freebsd6"         => ["amd64",     "freebsd",   "6"],
+      "hppa2.0w-hpux11.31"     => ["hppa2.0w",  "hpux",      "11"],
+      "java"                   => [nil,         "java",      nil],
+      "jruby"                  => [nil,         "java",      nil],
+      "universal-dotnet"       => ["universal", "dotnet",    nil],
+      "universal-dotnet2.0"    => ["universal", "dotnet",  "2.0"],
+      "universal-dotnet4.0"    => ["universal", "dotnet",  "4.0"],
+      "powerpc-aix5.3.0.0"     => ["powerpc",   "aix",       "5"],
+      "powerpc-darwin7"        => ["powerpc",   "darwin",    "7"],
+      "powerpc-darwin8"        => ["powerpc",   "darwin",    "8"],
+      "powerpc-linux"          => ["powerpc",   "linux",     nil],
+      "powerpc64-linux"        => ["powerpc64", "linux",     nil],
+      "sparc-solaris2.10"      => ["sparc",     "solaris",   "2.10"],
+      "sparc-solaris2.8"       => ["sparc",     "solaris",   "2.8"],
+      "sparc-solaris2.9"       => ["sparc",     "solaris",   "2.9"],
+      "universal-darwin8"      => ["universal", "darwin",    "8"],
+      "universal-darwin9"      => ["universal", "darwin",    "9"],
+      "universal-macruby"      => ["universal", "macruby",   nil],
+      "i386-cygwin"            => ["x86",       "cygwin",    nil],
+      "i686-darwin"            => ["x86",       "darwin",    nil],
+      "i686-darwin8.4.1"       => ["x86",       "darwin",    "8"],
+      "i386-freebsd4.11"       => ["x86",       "freebsd",   "4"],
+      "i386-freebsd5"          => ["x86",       "freebsd",   "5"],
+      "i386-freebsd6"          => ["x86",       "freebsd",   "6"],
+      "i386-freebsd7"          => ["x86",       "freebsd",   "7"],
+      "i386-freebsd"           => ["x86",       "freebsd",   nil],
+      "universal-freebsd"      => ["universal", "freebsd",   nil],
+      "i386-java1.5"           => ["x86",       "java",      "1.5"],
+      "x86-java1.6"            => ["x86",       "java",      "1.6"],
+      "i386-java1.6"           => ["x86",       "java",      "1.6"],
+      "i686-linux"             => ["x86",       "linux",     nil],
+      "i586-linux"             => ["x86",       "linux",     nil],
+      "i486-linux"             => ["x86",       "linux",     nil],
+      "i386-linux"             => ["x86",       "linux",     nil],
+      "i586-linux-gnu"         => ["x86",       "linux",     "gnu"],
+      "i386-linux-gnu"         => ["x86",       "linux",     "gnu"],
+      "i386-mingw32"           => ["x86",       "mingw32",   nil],
+      "x64-mingw-ucrt"         => ["x64",       "mingw",     "ucrt"],
+      "i386-mswin32"           => ["x86",       "mswin32",   nil],
+      "i386-mswin32_80"        => ["x86",       "mswin32",   "80"],
+      "i386-mswin32-80"        => ["x86",       "mswin32",   "80"],
+      "x86-mswin32"            => ["x86",       "mswin32",   nil],
+      "x86-mswin32_60"         => ["x86",       "mswin32",   "60"],
+      "x86-mswin32-60"         => ["x86",       "mswin32",   "60"],
+      "i386-netbsdelf"         => ["x86",       "netbsdelf", nil],
+      "i386-openbsd4.0"        => ["x86",       "openbsd",   "4.0"],
+      "i386-solaris2.10"       => ["x86",       "solaris",   "2.10"],
+      "i386-solaris2.8"        => ["x86",       "solaris",   "2.8"],
+      "mswin32"                => ["x86",       "mswin32",   nil],
+      "x86_64-linux"           => ["x86_64",    "linux",     nil],
+      "x86_64-linux-gnu"       => ["x86_64",    "linux",     "gnu"],
+      "x86_64-linux-musl"      => ["x86_64",    "linux",     "musl"],
+      "x86_64-linux-uclibc"    => ["x86_64",    "linux",     "uclibc"],
+      "arm-linux-eabi"         => ["arm",       "linux",     "eabi"],
+      "arm-linux-gnueabi"      => ["arm",       "linux",     "gnueabi"],
+      "arm-linux-musleabi"     => ["arm",       "linux",     "musleabi"],
+      "arm-linux-uclibceabi"   => ["arm",       "linux",     "uclibceabi"],
+      "x86_64-openbsd3.9"      => ["x86_64",    "openbsd",   "3.9"],
+      "x86_64-openbsd4.0"      => ["x86_64",    "openbsd",   "4.0"],
+      "x86_64-openbsd"         => ["x86_64",    "openbsd",   nil],
     }
 
     test_cases.each do |arch, expected|
       platform = Gem::Platform.new arch
       assert_equal expected, platform.to_a, arch.inspect
+      assert_equal expected, Gem::Platform.new(platform.to_s).to_a, arch.inspect
     end
   end
 
   def test_initialize_command_line
-    expected = ['x86', 'mswin32', nil]
+    expected = ["x86", "mswin32", nil]
 
-    platform = Gem::Platform.new 'i386-mswin32'
+    platform = Gem::Platform.new "i386-mswin32"
 
-    assert_equal expected, platform.to_a, 'i386-mswin32'
+    assert_equal expected, platform.to_a, "i386-mswin32"
 
-    expected = ['x86', 'mswin32', '80']
+    expected = ["x86", "mswin32", "80"]
 
-    platform = Gem::Platform.new 'i386-mswin32-80'
+    platform = Gem::Platform.new "i386-mswin32-80"
 
-    assert_equal expected, platform.to_a, 'i386-mswin32-80'
+    assert_equal expected, platform.to_a, "i386-mswin32-80"
 
-    expected = ['x86', 'solaris', '2.10']
+    expected = ["x86", "solaris", "2.10"]
 
-    platform = Gem::Platform.new 'i386-solaris-2.10'
+    platform = Gem::Platform.new "i386-solaris-2.10"
 
-    assert_equal expected, platform.to_a, 'i386-solaris-2.10'
+    assert_equal expected, platform.to_a, "i386-solaris-2.10"
   end
 
   def test_initialize_mswin32_vc6
-    orig_RUBY_SO_NAME = RbConfig::CONFIG['RUBY_SO_NAME']
-    RbConfig::CONFIG['RUBY_SO_NAME'] = 'msvcrt-ruby18'
+    orig_RUBY_SO_NAME = RbConfig::CONFIG["RUBY_SO_NAME"]
+    RbConfig::CONFIG["RUBY_SO_NAME"] = "msvcrt-ruby18"
 
-    expected = ['x86', 'mswin32', nil]
+    expected = ["x86", "mswin32", nil]
 
-    platform = Gem::Platform.new 'i386-mswin32'
+    platform = Gem::Platform.new "i386-mswin32"
 
-    assert_equal expected, platform.to_a, 'i386-mswin32 VC6'
+    assert_equal expected, platform.to_a, "i386-mswin32 VC6"
   ensure
     if orig_RUBY_SO_NAME
-      RbConfig::CONFIG['RUBY_SO_NAME'] = orig_RUBY_SO_NAME
+      RbConfig::CONFIG["RUBY_SO_NAME"] = orig_RUBY_SO_NAME
     else
-      RbConfig::CONFIG.delete 'RUBY_SO_NAME'
+      RbConfig::CONFIG.delete "RUBY_SO_NAME"
     end
   end
 
   def test_initialize_platform
-    platform = Gem::Platform.new 'cpu-my_platform1'
+    platform = Gem::Platform.new "cpu-my_platform1"
 
-    assert_equal 'cpu', platform.cpu
-    assert_equal 'my_platform', platform.os
-    assert_equal '1', platform.version
+    assert_equal "cpu", platform.cpu
+    assert_equal "my_platform", platform.os
+    assert_equal "1", platform.version
   end
 
   def test_initialize_test
-    platform = Gem::Platform.new 'cpu-my_platform1'
-    assert_equal 'cpu', platform.cpu
-    assert_equal 'my_platform', platform.os
-    assert_equal '1', platform.version
-
-    platform = Gem::Platform.new 'cpu-other_platform1'
-    assert_equal 'cpu', platform.cpu
-    assert_equal 'other_platform', platform.os
-    assert_equal '1', platform.version
+    platform = Gem::Platform.new "cpu-my_platform1"
+    assert_equal "cpu", platform.cpu
+    assert_equal "my_platform", platform.os
+    assert_equal "1", platform.version
+
+    platform = Gem::Platform.new "cpu-other_platform1"
+    assert_equal "cpu", platform.cpu
+    assert_equal "other_platform", platform.os
+    assert_equal "1", platform.version
   end
 
   def test_to_s
     if win_platform?
-      assert_equal 'x86-mswin32-60', Gem::Platform.local.to_s
+      assert_equal "x86-mswin32-60", Gem::Platform.local.to_s
     else
-      assert_equal 'x86-darwin-8', Gem::Platform.local.to_s
+      assert_equal "x86-darwin-8", Gem::Platform.local.to_s
     end
   end
 
@@ -172,130 +238,218 @@ class TestGemPlatform < Gem::TestCase
   end
 
   def test_equals3_cpu
-    ppc_darwin8 = Gem::Platform.new 'powerpc-darwin8.0'
-    uni_darwin8 = Gem::Platform.new 'universal-darwin8.0'
-    x86_darwin8 = Gem::Platform.new 'i686-darwin8.0'
-
-    util_set_arch 'powerpc-darwin8'
-    assert((ppc_darwin8 === Gem::Platform.local), 'powerpc =~ universal')
-    assert((uni_darwin8 === Gem::Platform.local), 'powerpc =~ universal')
-    refute((x86_darwin8 === Gem::Platform.local), 'powerpc =~ universal')
-
-    util_set_arch 'i686-darwin8'
-    refute((ppc_darwin8 === Gem::Platform.local), 'powerpc =~ universal')
-    assert((uni_darwin8 === Gem::Platform.local), 'x86 =~ universal')
-    assert((x86_darwin8 === Gem::Platform.local), 'powerpc =~ universal')
-
-    util_set_arch 'universal-darwin8'
-    assert((ppc_darwin8 === Gem::Platform.local), 'universal =~ ppc')
-    assert((uni_darwin8 === Gem::Platform.local), 'universal =~ universal')
-    assert((x86_darwin8 === Gem::Platform.local), 'universal =~ x86')
+    ppc_darwin8 = Gem::Platform.new "powerpc-darwin8.0"
+    uni_darwin8 = Gem::Platform.new "universal-darwin8.0"
+    x86_darwin8 = Gem::Platform.new "i686-darwin8.0"
+
+    util_set_arch "powerpc-darwin8"
+    assert((ppc_darwin8 === Gem::Platform.local), "powerpc =~ universal")
+    assert((uni_darwin8 === Gem::Platform.local), "powerpc =~ universal")
+    refute((x86_darwin8 === Gem::Platform.local), "powerpc =~ universal")
+
+    util_set_arch "i686-darwin8"
+    refute((ppc_darwin8 === Gem::Platform.local), "powerpc =~ universal")
+    assert((uni_darwin8 === Gem::Platform.local), "x86 =~ universal")
+    assert((x86_darwin8 === Gem::Platform.local), "powerpc =~ universal")
+
+    util_set_arch "universal-darwin8"
+    assert((ppc_darwin8 === Gem::Platform.local), "universal =~ ppc")
+    assert((uni_darwin8 === Gem::Platform.local), "universal =~ universal")
+    assert((x86_darwin8 === Gem::Platform.local), "universal =~ x86")
   end
 
   def test_nil_cpu_arch_is_treated_as_universal
-    with_nil_arch = Gem::Platform.new [nil, 'mingw32']
-    with_uni_arch = Gem::Platform.new ['universal', 'mingw32']
-    with_x86_arch = Gem::Platform.new ['x86', 'mingw32']
-
-    assert((with_nil_arch === with_uni_arch), 'nil =~ universal')
-    assert((with_uni_arch === with_nil_arch), 'universal =~ nil')
-    assert((with_nil_arch === with_x86_arch), 'nil =~ x86')
-    assert((with_x86_arch === with_nil_arch), 'x86 =~ nil')
+    with_nil_arch = Gem::Platform.new [nil, "mingw32"]
+    with_uni_arch = Gem::Platform.new ["universal", "mingw32"]
+    with_x86_arch = Gem::Platform.new ["x86", "mingw32"]
+
+    assert((with_nil_arch === with_uni_arch), "nil =~ universal")
+    assert((with_uni_arch === with_nil_arch), "universal =~ nil")
+    assert((with_nil_arch === with_x86_arch), "nil =~ x86")
+    assert((with_x86_arch === with_nil_arch), "x86 =~ nil")
+  end
+
+  def test_nil_version_is_treated_as_any_version
+    x86_darwin_8 = Gem::Platform.new "i686-darwin8.0"
+    x86_darwin_nil = Gem::Platform.new "i686-darwin"
+
+    assert((x86_darwin_8 === x86_darwin_nil), "8.0 =~ nil")
+    assert((x86_darwin_nil === x86_darwin_8), "nil =~ 8.0")
+  end
+
+  def test_nil_version_is_stricter_for_linux_os
+    x86_linux = Gem::Platform.new "i686-linux"
+    x86_linux_gnu = Gem::Platform.new "i686-linux-gnu"
+    x86_linux_musl = Gem::Platform.new "i686-linux-musl"
+    x86_linux_uclibc = Gem::Platform.new "i686-linux-uclibc"
+
+    # a naked linux runtime is implicit gnu, as it represents the common glibc-linked runtime
+    assert(x86_linux === x86_linux_gnu, "linux =~ linux-gnu")
+    assert(x86_linux_gnu === x86_linux, "linux-gnu =~ linux")
+
+    # musl and explicit gnu should differ
+    refute(x86_linux_gnu === x86_linux_musl, "linux-gnu =~ linux-musl")
+    refute(x86_linux_musl === x86_linux_gnu, "linux-musl =~ linux-gnu")
+
+    # explicit libc differ
+    refute(x86_linux_uclibc === x86_linux_musl, "linux-uclibc =~ linux-musl")
+    refute(x86_linux_musl === x86_linux_uclibc, "linux-musl =~ linux-uclibc")
+
+    # musl host runtime accepts libc-generic or statically linked gems...
+    assert(x86_linux === x86_linux_musl, "linux =~ linux-musl")
+    # ...but implicit gnu runtime generally does not accept musl-specific gems
+    refute(x86_linux_musl === x86_linux, "linux-musl =~ linux")
+
+    # other libc are not glibc compatible
+    refute(x86_linux === x86_linux_uclibc, "linux =~ linux-uclibc")
+    refute(x86_linux_uclibc === x86_linux, "linux-uclibc =~ linux")
+  end
+
+  def test_eabi_version_is_stricter_for_linux_os
+    arm_linux_eabi = Gem::Platform.new "arm-linux-eabi"
+    arm_linux_gnueabi = Gem::Platform.new "arm-linux-gnueabi"
+    arm_linux_musleabi = Gem::Platform.new "arm-linux-musleabi"
+    arm_linux_uclibceabi = Gem::Platform.new "arm-linux-uclibceabi"
+
+    # a naked linux runtime is implicit gnu, as it represents the common glibc-linked runtime
+    assert(arm_linux_eabi === arm_linux_gnueabi, "linux-eabi =~ linux-gnueabi")
+    assert(arm_linux_gnueabi === arm_linux_eabi, "linux-gnueabi =~ linux-eabi")
+
+    # musl and explicit gnu should differ
+    refute(arm_linux_gnueabi === arm_linux_musleabi, "linux-gnueabi =~ linux-musleabi")
+    refute(arm_linux_musleabi === arm_linux_gnueabi, "linux-musleabi =~ linux-gnueabi")
+
+    # explicit libc differ
+    refute(arm_linux_uclibceabi === arm_linux_musleabi, "linux-uclibceabi =~ linux-musleabi")
+    refute(arm_linux_musleabi === arm_linux_uclibceabi, "linux-musleabi =~ linux-uclibceabi")
+
+    # musl host runtime accepts libc-generic or statically linked gems...
+    assert(arm_linux_eabi === arm_linux_musleabi, "linux-eabi =~ linux-musleabi")
+    # ...but implicit gnu runtime generally does not accept musl-specific gems
+    refute(arm_linux_musleabi === arm_linux_eabi, "linux-musleabi =~ linux-eabi")
+
+    # other libc are not glibc compatible
+    refute(arm_linux_eabi === arm_linux_uclibceabi, "linux-eabi =~ linux-uclibceabi")
+    refute(arm_linux_uclibceabi === arm_linux_eabi, "linux-uclibceabi =~ linux-eabi")
   end
 
   def test_equals3_cpu_arm
-    arm   = Gem::Platform.new 'arm-linux'
-    armv5 = Gem::Platform.new 'armv5-linux'
-    armv7 = Gem::Platform.new 'armv7-linux'
-
-    util_set_arch 'armv5-linux'
-    assert((arm   === Gem::Platform.local), 'arm   === armv5')
-    assert((armv5 === Gem::Platform.local), 'armv5 === armv5')
-    refute((armv7 === Gem::Platform.local), 'armv7 === armv5')
-    refute((Gem::Platform.local === arm), 'armv5 === arm')
-
-    util_set_arch 'armv7-linux'
-    assert((arm   === Gem::Platform.local), 'arm   === armv7')
-    refute((armv5 === Gem::Platform.local), 'armv5 === armv7')
-    assert((armv7 === Gem::Platform.local), 'armv7 === armv7')
-    refute((Gem::Platform.local === arm), 'armv7 === arm')
+    arm   = Gem::Platform.new "arm-linux"
+    armv5 = Gem::Platform.new "armv5-linux"
+    armv7 = Gem::Platform.new "armv7-linux"
+
+    util_set_arch "armv5-linux"
+    assert((arm   === Gem::Platform.local), "arm   === armv5")
+    assert((armv5 === Gem::Platform.local), "armv5 === armv5")
+    refute((armv7 === Gem::Platform.local), "armv7 === armv5")
+    refute((Gem::Platform.local === arm), "armv5 === arm")
+
+    util_set_arch "armv7-linux"
+    assert((arm   === Gem::Platform.local), "arm   === armv7")
+    refute((armv5 === Gem::Platform.local), "armv5 === armv7")
+    assert((armv7 === Gem::Platform.local), "armv7 === armv7")
+    refute((Gem::Platform.local === arm), "armv7 === arm")
+  end
+
+  def test_equals3_universal_mingw
+    uni_mingw  = Gem::Platform.new "universal-mingw"
+    mingw32    = Gem::Platform.new "x64-mingw32"
+    mingw_ucrt = Gem::Platform.new "x64-mingw-ucrt"
+
+    util_set_arch "x64-mingw32"
+    assert((uni_mingw === Gem::Platform.local), "uni_mingw === mingw32")
+    assert((mingw32 === Gem::Platform.local), "mingw32 === mingw32")
+    refute((mingw_ucrt === Gem::Platform.local), "mingw32 === mingw_ucrt")
+
+    util_set_arch "x64-mingw-ucrt"
+    assert((uni_mingw === Gem::Platform.local), "uni_mingw === mingw32")
+    assert((mingw_ucrt === Gem::Platform.local), "mingw_ucrt === mingw_ucrt")
+    refute((mingw32 === Gem::Platform.local), "mingw32 === mingw_ucrt")
   end
 
   def test_equals3_version
-    util_set_arch 'i686-darwin8'
+    util_set_arch "i686-darwin8"
 
-    x86_darwin = Gem::Platform.new ['x86', 'darwin', nil]
-    x86_darwin7 = Gem::Platform.new ['x86', 'darwin', '7']
-    x86_darwin8 = Gem::Platform.new ['x86', 'darwin', '8']
-    x86_darwin9 = Gem::Platform.new ['x86', 'darwin', '9']
+    x86_darwin = Gem::Platform.new ["x86", "darwin", nil]
+    x86_darwin7 = Gem::Platform.new ["x86", "darwin", "7"]
+    x86_darwin8 = Gem::Platform.new ["x86", "darwin", "8"]
+    x86_darwin9 = Gem::Platform.new ["x86", "darwin", "9"]
 
-    assert((x86_darwin  === Gem::Platform.local), 'x86_darwin === x86_darwin8')
-    assert((x86_darwin8 === Gem::Platform.local), 'x86_darwin8 === x86_darwin8')
+    assert((x86_darwin  === Gem::Platform.local), "x86_darwin === x86_darwin8")
+    assert((x86_darwin8 === Gem::Platform.local), "x86_darwin8 === x86_darwin8")
 
-    refute((x86_darwin7 === Gem::Platform.local), 'x86_darwin7 === x86_darwin8')
-    refute((x86_darwin9 === Gem::Platform.local), 'x86_darwin9 === x86_darwin8')
+    refute((x86_darwin7 === Gem::Platform.local), "x86_darwin7 === x86_darwin8")
+    refute((x86_darwin9 === Gem::Platform.local), "x86_darwin9 === x86_darwin8")
   end
 
   def test_equals_tilde
-    util_set_arch 'i386-mswin32'
+    util_set_arch "i386-mswin32"
 
-    assert_local_match 'mswin32'
-    assert_local_match 'i386-mswin32'
+    assert_local_match "mswin32"
+    assert_local_match "i386-mswin32"
 
     # oddballs
-    assert_local_match 'i386-mswin32-mq5.3'
-    assert_local_match 'i386-mswin32-mq6'
-    refute_local_match 'win32-1.8.2-VC7'
-    refute_local_match 'win32-1.8.4-VC6'
-    refute_local_match 'win32-source'
-    refute_local_match 'windows'
-
-    util_set_arch 'i686-linux'
-    assert_local_match 'i486-linux'
-    assert_local_match 'i586-linux'
-    assert_local_match 'i686-linux'
-
-    util_set_arch 'i686-darwin8'
-    assert_local_match 'i686-darwin8.4.1'
-    assert_local_match 'i686-darwin8.8.2'
-
-    util_set_arch 'java'
-    assert_local_match 'java'
-    assert_local_match 'jruby'
-
-    util_set_arch 'universal-dotnet2.0'
-    assert_local_match 'universal-dotnet'
-    assert_local_match 'universal-dotnet-2.0'
-    refute_local_match 'universal-dotnet-4.0'
-    assert_local_match 'dotnet'
-    assert_local_match 'dotnet-2.0'
-    refute_local_match 'dotnet-4.0'
-
-    util_set_arch 'universal-dotnet4.0'
-    assert_local_match 'universal-dotnet'
-    refute_local_match 'universal-dotnet-2.0'
-    assert_local_match 'universal-dotnet-4.0'
-    assert_local_match 'dotnet'
-    refute_local_match 'dotnet-2.0'
-    assert_local_match 'dotnet-4.0'
-
-    util_set_arch 'universal-macruby-1.0'
-    assert_local_match 'universal-macruby'
-    assert_local_match 'macruby'
-    refute_local_match 'universal-macruby-0.10'
-    assert_local_match 'universal-macruby-1.0'
-
-    util_set_arch 'powerpc-darwin'
-    assert_local_match 'powerpc-darwin'
-
-    util_set_arch 'powerpc-darwin7'
-    assert_local_match 'powerpc-darwin7.9.0'
-
-    util_set_arch 'powerpc-darwin8'
-    assert_local_match 'powerpc-darwin8.10.0'
-
-    util_set_arch 'sparc-solaris2.8'
-    assert_local_match 'sparc-solaris2.8-mq5.3'
+    assert_local_match "i386-mswin32-mq5.3"
+    assert_local_match "i386-mswin32-mq6"
+    refute_local_match "win32-1.8.2-VC7"
+    refute_local_match "win32-1.8.4-VC6"
+    refute_local_match "win32-source"
+    refute_local_match "windows"
+
+    util_set_arch "i686-linux"
+    assert_local_match "i486-linux"
+    assert_local_match "i586-linux"
+    assert_local_match "i686-linux"
+
+    util_set_arch "i686-darwin8"
+    assert_local_match "i686-darwin8.4.1"
+    assert_local_match "i686-darwin8.8.2"
+
+    util_set_arch "java"
+    assert_local_match "java"
+    assert_local_match "jruby"
+
+    util_set_arch "universal-dotnet2.0"
+    assert_local_match "universal-dotnet"
+    assert_local_match "universal-dotnet-2.0"
+    refute_local_match "universal-dotnet-4.0"
+    assert_local_match "dotnet"
+    assert_local_match "dotnet-2.0"
+    refute_local_match "dotnet-4.0"
+
+    util_set_arch "universal-dotnet4.0"
+    assert_local_match "universal-dotnet"
+    refute_local_match "universal-dotnet-2.0"
+    assert_local_match "universal-dotnet-4.0"
+    assert_local_match "dotnet"
+    refute_local_match "dotnet-2.0"
+    assert_local_match "dotnet-4.0"
+
+    util_set_arch "universal-macruby-1.0"
+    assert_local_match "universal-macruby"
+    assert_local_match "macruby"
+    refute_local_match "universal-macruby-0.10"
+    assert_local_match "universal-macruby-1.0"
+
+    util_set_arch "powerpc-darwin"
+    assert_local_match "powerpc-darwin"
+
+    util_set_arch "powerpc-darwin7"
+    assert_local_match "powerpc-darwin7.9.0"
+
+    util_set_arch "powerpc-darwin8"
+    assert_local_match "powerpc-darwin8.10.0"
+
+    util_set_arch "sparc-solaris2.8"
+    assert_local_match "sparc-solaris2.8-mq5.3"
+  end
+
+  def test_inspect
+    result = Gem::Platform.new("universal-java11").inspect
+
+    assert_equal 1, result.scan(/@cpu=/).size
+    assert_equal 1, result.scan(/@os=/).size
+    assert_equal 1, result.scan(/@version=/).size
   end
 
   def assert_local_match(name)
@@ -305,5 +459,4 @@ class TestGemPlatform < Gem::TestCase
   def refute_local_match(name)
     refute_match Gem::Platform.local, name
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_rdoc.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_rdoc.rb
@@ -1,22 +1,21 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/test_case'
-require 'rubygems/rdoc'
+require "rubygems"
+require_relative "helper"
+require "rubygems/rdoc"
 
 class TestGemRDoc < Gem::TestCase
-
   Gem::RDoc.load_rdoc
 
   def setup
     super
 
-    @a = util_spec 'a' do |s|
+    @a = util_spec "a" do |s|
       s.rdoc_options = %w[--main MyTitle]
       s.extra_rdoc_files = %w[README]
     end
 
-    write_file File.join(@tempdir, 'lib', 'a.rb')
-    write_file File.join(@tempdir, 'README')
+    write_file File.join(@tempdir, "lib", "a.rb")
+    write_file File.join(@tempdir, "README")
 
     install_gem @a
 
@@ -25,7 +24,7 @@ class TestGemRDoc < Gem::TestCase
     begin
       Gem::RDoc.load_rdoc
     rescue Gem::DocumentError => e
-      skip e.message
+      pend e.message
     end
 
     Gem.configuration[:rdoc] = nil
@@ -71,30 +70,30 @@ class TestGemRDoc < Gem::TestCase
   def test_rdoc_installed?
     refute @hook.rdoc_installed?
 
-    FileUtils.mkdir_p @a.doc_dir 'rdoc'
+    FileUtils.mkdir_p @a.doc_dir "rdoc"
 
     assert @hook.rdoc_installed?
   end
 
   def test_remove
-    FileUtils.mkdir_p @a.doc_dir 'rdoc'
-    FileUtils.mkdir_p @a.doc_dir 'ri'
+    FileUtils.mkdir_p @a.doc_dir "rdoc"
+    FileUtils.mkdir_p @a.doc_dir "ri"
 
     @hook.remove
 
     refute @hook.rdoc_installed?
     refute @hook.ri_installed?
 
-    assert_path_exists @a.doc_dir
+    assert_path_exist @a.doc_dir
   end
 
   def test_remove_unwritable
-    skip 'chmod not supported' if Gem.win_platform?
-    skip 'skipped in root privilege' if Process.uid.zero?
+    pend "chmod not supported" if Gem.win_platform?
+    pend "skipped in root privilege" if Process.uid.zero?
     FileUtils.mkdir_p @a.base_dir
     FileUtils.chmod 0, @a.base_dir
 
-    e = assert_raises Gem::FilePermissionError do
+    e = assert_raise Gem::FilePermissionError do
       @hook.remove
     end
 
@@ -106,7 +105,7 @@ class TestGemRDoc < Gem::TestCase
   def test_ri_installed?
     refute @hook.ri_installed?
 
-    FileUtils.mkdir_p @a.doc_dir 'ri'
+    FileUtils.mkdir_p @a.doc_dir "ri"
 
     assert @hook.ri_installed?
   end
@@ -114,16 +113,16 @@ class TestGemRDoc < Gem::TestCase
   def test_setup
     @hook.setup
 
-    assert_path_exists @a.doc_dir
+    assert_path_exist @a.doc_dir
   end
 
   def test_setup_unwritable
-    skip 'chmod not supported' if Gem.win_platform?
-    skip 'skipped in root privilege' if Process.uid.zero?
+    pend "chmod not supported" if Gem.win_platform?
+    pend "skipped in root privilege" if Process.uid.zero?
     FileUtils.mkdir_p @a.doc_dir
     FileUtils.chmod 0, @a.doc_dir
 
-    e = assert_raises Gem::FilePermissionError do
+    e = assert_raise Gem::FilePermissionError do
       @hook.setup
     end
 
@@ -134,5 +133,4 @@ class TestGemRDoc < Gem::TestCase
       FileUtils.rm_r @a.doc_dir
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_remote_fetcher.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_remote_fetcher.rb
@@ -1,21 +1,15 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
-require 'webrick'
-begin
-  require 'webrick/https'
-rescue LoadError => e
-  raise unless (e.respond_to?(:path) && e.path == 'openssl') ||
-               e.message =~ / -- openssl$/
-end
+require "webrick"
+require "webrick/https" if Gem::HAVE_OPENSSL
 
-unless defined?(OpenSSL::SSL)
-  warn 'Skipping Gem::Request tests.  openssl not found.'
+unless Gem::HAVE_OPENSSL
+  warn "Skipping Gem::RemoteFetcher tests.  openssl not found."
 end
 
-require 'rubygems/remote_fetcher'
-require 'rubygems/package'
-require 'minitest/mock'
+require "rubygems/remote_fetcher"
+require "rubygems/package"
 
 # = Testing Proxy Settings
 #
@@ -32,7 +26,6 @@ require 'minitest/mock'
 # proxy is configured.
 
 class TestGemRemoteFetcher < Gem::TestCase
-
   include Gem::DefaultUserInteraction
 
   SERVER_DATA = <<-EOY.freeze
@@ -76,14 +69,12 @@ gems:
     dependencies: []
   EOY
 
-  PROXY_DATA = SERVER_DATA.gsub(/0.4.11/, '0.4.2')
-
-  DIR = File.expand_path(File.dirname(__FILE__))
+  PROXY_DATA = SERVER_DATA.gsub(/0.4.11/, "0.4.2")
 
   # Generated via:
   #   x = OpenSSL::PKey::DH.new(2048) # wait a while...
   #   x.to_s => pem
-  TEST_KEY_DH2048 = OpenSSL::PKey::DH.new <<-_end_of_pem_
+  TEST_KEY_DH2048 = OpenSSL::PKey::DH.new <<-_END_OF_PEM_
 -----BEGIN DH PARAMETERS-----
 MIIBCAKCAQEA3Ze2EHSfYkZLUn557torAmjBgPsqzbodaRaGZtgK1gEU+9nNJaFV
 G1JKhmGUiEDyIW7idsBpe4sX/Wqjnp48Lr8IeI/SlEzLdoGpf05iRYXC8Cm9o8aM
@@ -92,7 +83,7 @@ cfmVgoSEAo9YLBpzoji2jHkO7Q5IPt4zxbTdlmmG
 NP0fuvVAIB158VnQ0liHSwcl6+9vE1mL0Jo/qEXQxl0+UdKDjaGfTsn6HIrwTnmJ
 PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 -----END DH PARAMETERS-----
-    _end_of_pem_
+    _END_OF_PEM_
 
   def setup
     @proxies = %w[https_proxy http_proxy HTTP_PROXY http_proxy_user HTTP_PROXY_USER http_proxy_pass HTTP_PROXY_PASS no_proxy NO_PROXY]
@@ -100,27 +91,24 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
     @proxies.each {|k| ENV[k] = nil }
 
     super
-    self.class.start_servers
-    self.class.enable_yaml = true
-    self.class.enable_zip = false
+    start_servers
+    self.enable_yaml = true
+    self.enable_zip = false
 
-    base_server_uri = "http://localhost:#{self.class.normal_server_port}"
-    @proxy_uri = "http://localhost:#{self.class.proxy_server_port}"
+    base_server_uri = "http://localhost:#{normal_server_port}"
+    @proxy_uri = "http://localhost:#{proxy_server_port}"
 
     @server_uri = base_server_uri + "/yaml"
     @server_z_uri = base_server_uri + "/yaml.Z"
 
-    # REFACTOR: copied from test_gem_dependency_installer.rb
-    @gems_dir = File.join @tempdir, 'gems'
     @cache_dir = File.join @gemhome, "cache"
-    FileUtils.mkdir @gems_dir
 
     # TODO: why does the remote fetcher need it written to disk?
-    @a1, @a1_gem = util_gem 'a', '1' do |s|
-      s.executables << 'a_bin'
+    @a1, @a1_gem = util_gem "a", "1" do |s|
+      s.executables << "a_bin"
     end
 
-    @a1.loaded_from = File.join(@gemhome, 'specifications', @a1.full_name)
+    @a1.loaded_from = File.join(@gemhome, "specifications", @a1.full_name)
 
     Gem::RemoteFetcher.fetcher = nil
     @stub_ui = Gem::MockGemUi.new
@@ -129,7 +117,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def teardown
     @fetcher.close_all
-    self.class.stop_servers
+    stop_servers
     super
     Gem.configuration[:http_proxy] = nil
     @proxies.each_with_index {|k, i| ENV[k] = @old_proxies[i] }
@@ -142,7 +130,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   end
 
   def test_self_fetcher_with_proxy
-    proxy_uri = 'http://proxy.example.com'
+    proxy_uri = "http://proxy.example.com"
     Gem.configuration[:http_proxy] = proxy_uri
     Gem::RemoteFetcher.fetcher = nil
 
@@ -153,69 +141,64 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
     assert_equal proxy_uri, fetcher.instance_variable_get(:@proxy).to_s
   end
 
-  def test_fetch_size_bad_uri
-    fetcher = Gem::RemoteFetcher.new nil
-    @fetcher = fetcher
-
-    e = assert_raises ArgumentError do
-      Gem::Deprecate.skip_during do
-        fetcher.fetch_size 'gems.example.com/yaml'
-      end
-    end
-
-    assert_equal 'uri scheme is invalid: nil', e.message
-  end
-
-  def test_fetch_size_socket_error
+  def test_fetch_path_bad_uri
     fetcher = Gem::RemoteFetcher.new nil
     @fetcher = fetcher
-    def fetcher.request(uri, request_class, last_modified = nil)
-      raise SocketError, "oops"
-    end
 
-    uri = 'http://gems.example.com/yaml'
-    e = assert_raises Gem::RemoteFetcher::FetchError do
-      Gem::Deprecate.skip_during do
-        fetcher.fetch_size uri
-      end
+    e = assert_raise ArgumentError do
+      @fetcher.fetch_path("gems.example.com/yaml", nil, true)
     end
 
-    assert_equal "SocketError: oops (#{uri})", e.message
+    assert_equal "uri scheme is invalid: nil", e.message
   end
 
   def test_no_proxy
     use_ui @stub_ui do
       assert_data_from_server @fetcher.fetch_path(@server_uri)
-      Gem::Deprecate.skip_during do
-        assert_equal SERVER_DATA.size, @fetcher.fetch_size(@server_uri)
-      end
+      response = @fetcher.fetch_path(@server_uri, nil, true)
+      assert_equal SERVER_DATA.size, response["content-length"].to_i
     end
   end
 
   def test_cache_update_path
-    uri = URI 'http://example/file'
-    path = File.join @tempdir, 'file'
+    uri = URI "http://example/file"
+    path = File.join @tempdir, "file"
 
-    fetcher = util_fuck_with_fetcher 'hello'
+    fetcher = util_fuck_with_fetcher "hello"
 
     data = fetcher.cache_update_path uri, path
 
-    assert_equal 'hello', data
+    assert_equal "hello", data
+
+    assert_equal "hello", File.read(path)
+  end
+
+  def test_cache_update_path_with_utf8_internal_encoding
+    with_internal_encoding("UTF-8") do
+      uri = URI "http://example/file"
+      path = File.join @tempdir, "file"
+      data = String.new("\xC8").force_encoding(Encoding::BINARY)
 
-    assert_equal 'hello', File.read(path)
+      fetcher = util_fuck_with_fetcher data
+
+      written_data = fetcher.cache_update_path uri, path
+
+      assert_equal data, written_data
+      assert_equal data, File.binread(path)
+    end
   end
 
   def test_cache_update_path_no_update
-    uri = URI 'http://example/file'
-    path = File.join @tempdir, 'file'
+    uri = URI "http://example/file"
+    path = File.join @tempdir, "file"
 
-    fetcher = util_fuck_with_fetcher 'hello'
+    fetcher = util_fuck_with_fetcher "hello"
 
     data = fetcher.cache_update_path uri, path, false
 
-    assert_equal 'hello', data
+    assert_equal "hello", data
 
-    refute_path_exists path
+    assert_path_not_exist path
   end
 
   def util_fuck_with_fetcher(data, blow = false)
@@ -236,7 +219,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
           @test_data
         end
 
-        raise Gem::RemoteFetcher::FetchError.new("haha!", nil)
+        raise Gem::RemoteFetcher::FetchError.new("haha!", "")
       end
     end
 
@@ -245,14 +228,14 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def test_download
     a1_data = nil
-    File.open @a1_gem, 'rb' do |fp|
+    File.open @a1_gem, "rb" do |fp|
       a1_data = fp.read
     end
 
     fetcher = util_fuck_with_fetcher a1_data
 
     a1_cache_gem = @a1.cache_file
-    assert_equal a1_cache_gem, fetcher.download(@a1, 'http://gems.example.com')
+    assert_equal a1_cache_gem, fetcher.download(@a1, "http://gems.example.com")
     assert_equal("http://gems.example.com/gems/a-1.gem",
                  fetcher.instance_variable_get(:@test_arg).to_s)
     assert File.exist?(a1_cache_gem)
@@ -260,29 +243,59 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def test_download_with_auth
     a1_data = nil
-    File.open @a1_gem, 'rb' do |fp|
+    File.open @a1_gem, "rb" do |fp|
       a1_data = fp.read
     end
 
     fetcher = util_fuck_with_fetcher a1_data
 
     a1_cache_gem = @a1.cache_file
-    assert_equal a1_cache_gem, fetcher.download(@a1, 'http://user:password@gems.example.com')
+    assert_equal a1_cache_gem, fetcher.download(@a1, "http://user:password@gems.example.com")
     assert_equal("http://user:password@gems.example.com/gems/a-1.gem",
                  fetcher.instance_variable_get(:@test_arg).to_s)
     assert File.exist?(a1_cache_gem)
   end
 
+  def test_download_with_token
+    a1_data = nil
+    File.open @a1_gem, "rb" do |fp|
+      a1_data = fp.read
+    end
+
+    fetcher = util_fuck_with_fetcher a1_data
+
+    a1_cache_gem = @a1.cache_file
+    assert_equal a1_cache_gem, fetcher.download(@a1, "http://token@gems.example.com")
+    assert_equal("http://token@gems.example.com/gems/a-1.gem",
+                 fetcher.instance_variable_get(:@test_arg).to_s)
+    assert File.exist?(a1_cache_gem)
+  end
+
+  def test_download_with_x_oauth_basic
+    a1_data = nil
+    File.open @a1_gem, "rb" do |fp|
+      a1_data = fp.read
+    end
+
+    fetcher = util_fuck_with_fetcher a1_data
+
+    a1_cache_gem = @a1.cache_file
+    assert_equal a1_cache_gem, fetcher.download(@a1, "http://token:x-oauth-basic@gems.example.com")
+    assert_equal("http://token:x-oauth-basic@gems.example.com/gems/a-1.gem",
+                 fetcher.instance_variable_get(:@test_arg).to_s)
+    assert File.exist?(a1_cache_gem)
+  end
+
   def test_download_with_encoded_auth
     a1_data = nil
-    File.open @a1_gem, 'rb' do |fp|
+    File.open @a1_gem, "rb" do |fp|
       a1_data = fp.read
     end
 
     fetcher = util_fuck_with_fetcher a1_data
 
     a1_cache_gem = @a1.cache_file
-    assert_equal a1_cache_gem, fetcher.download(@a1, 'http://user:%25pas%25sword@gems.example.com')
+    assert_equal a1_cache_gem, fetcher.download(@a1, "http://user:%25pas%25sword@gems.example.com")
     assert_equal("http://user:%25pas%25sword@gems.example.com/gems/a-1.gem",
                  fetcher.instance_variable_get(:@test_arg).to_s)
     assert File.exist?(a1_cache_gem)
@@ -293,7 +306,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
     inst = Gem::RemoteFetcher.fetcher
 
-    assert_equal @a1.cache_file, inst.download(@a1, 'http://gems.example.com')
+    assert_equal @a1.cache_file, inst.download(@a1, "http://gems.example.com")
   end
 
   def test_download_local
@@ -309,7 +322,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   end
 
   def test_download_local_space
-    space_path = File.join @tempdir, 'space path'
+    space_path = File.join @tempdir, "space path"
     FileUtils.mkdir space_path
     FileUtils.mv @a1_gem, space_path
     local_path = File.join space_path, @a1.file_name
@@ -323,17 +336,17 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   end
 
   def test_download_install_dir
-    a1_data = File.open @a1_gem, 'rb' do |fp|
+    a1_data = File.open @a1_gem, "rb" do |fp|
       fp.read
     end
 
     fetcher = util_fuck_with_fetcher a1_data
 
-    install_dir = File.join @tempdir, 'more_gems'
+    install_dir = File.join @tempdir, "more_gems"
 
     a1_cache_gem = File.join install_dir, "cache", @a1.file_name
     FileUtils.mkdir_p(File.dirname(a1_cache_gem))
-    actual = fetcher.download(@a1, 'http://gems.example.com', install_dir)
+    actual = fetcher.download(@a1, "http://gems.example.com", install_dir)
 
     assert_equal a1_cache_gem, actual
     assert_equal("http://gems.example.com/gems/a-1.gem",
@@ -348,6 +361,8 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
       local_path = File.join @tempdir, @a1.file_name
       inst = nil
       FileUtils.chmod 0555, @a1.cache_dir
+      FileUtils.mkdir_p File.join(Gem.user_dir, "cache") rescue nil
+      FileUtils.chmod 0555, File.join(Gem.user_dir, "cache")
 
       Dir.chdir @tempdir do
         inst = Gem::RemoteFetcher.fetcher
@@ -356,6 +371,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
       assert_equal(File.join(@tempdir, @a1.file_name),
                    inst.download(@a1, local_path))
     ensure
+      FileUtils.chmod 0755, File.join(Gem.user_dir, "cache")
       FileUtils.chmod 0755, @a1.cache_dir
     end
 
@@ -364,7 +380,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
       FileUtils.chmod 0555, @gemhome
 
       fetcher = util_fuck_with_fetcher File.read(@a1_gem)
-      fetcher.download(@a1, 'http://gems.example.com')
+      fetcher.download(@a1, "http://gems.example.com")
       a1_cache_gem = File.join Gem.user_dir, "cache", @a1.file_name
       assert File.exist? a1_cache_gem
     ensure
@@ -374,16 +390,16 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   end
 
   def test_download_platform_legacy
-    original_platform = 'old-platform'
+    original_platform = "old-platform"
 
-    e1, e1_gem = util_gem 'e', '1' do |s|
+    e1, e1_gem = util_gem "e", "1" do |s|
       s.platform = Gem::Platform::CURRENT
       s.instance_variable_set :@original_platform, original_platform
     end
-    e1.loaded_from = File.join(@gemhome, 'specifications', e1.full_name)
+    e1.loaded_from = File.join(@gemhome, "specifications", e1.full_name)
 
     e1_data = nil
-    File.open e1_gem, 'rb' do |fp|
+    File.open e1_gem, "rb" do |fp|
       e1_data = fp.read
     end
 
@@ -391,7 +407,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
     e1_cache_gem = e1.cache_file
 
-    assert_equal e1_cache_gem, fetcher.download(e1, 'http://gems.example.com')
+    assert_equal e1_cache_gem, fetcher.download(e1, "http://gems.example.com")
 
     assert_equal("http://gems.example.com/gems/#{e1.original_name}.gem",
                  fetcher.instance_variable_get(:@test_arg).to_s)
@@ -418,15 +434,15 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   def test_download_unsupported
     inst = Gem::RemoteFetcher.fetcher
 
-    e = assert_raises ArgumentError do
-      inst.download @a1, 'ftp://gems.rubyforge.org'
+    e = assert_raise ArgumentError do
+      inst.download @a1, "ftp://gems.rubyforge.org"
     end
 
-    assert_equal 'unsupported URI scheme ftp', e.message
+    assert_equal "unsupported URI scheme ftp", e.message
   end
 
   def test_download_to_cache
-    @a2, @a2_gem = util_gem 'a', '2'
+    @a2, @a2_gem = util_gem "a", "2"
 
     util_setup_spec_fetcher @a1, @a2
     @fetcher.instance_variable_set :@a1, @a1
@@ -442,7 +458,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
       end
     end
 
-    gem = Gem::RemoteFetcher.fetcher.download_to_cache dep 'a'
+    gem = Gem::RemoteFetcher.fetcher.download_to_cache dep "a"
 
     assert_equal @a2.file_name, File.basename(gem)
   end
@@ -452,10 +468,10 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
     @fetcher = fetcher
 
     def fetcher.fetch_http(uri, mtime, head = nil)
-      Gem::Util.gzip 'foo'
+      Gem::Util.gzip "foo"
     end
 
-    assert_equal 'foo', fetcher.fetch_path(@uri + 'foo.gz')
+    assert_equal "foo", fetcher.fetch_path(@uri + "foo.gz")
   end
 
   def test_fetch_path_gzip_unmodified
@@ -466,7 +482,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
       nil
     end
 
-    assert_nil fetcher.fetch_path(@uri + 'foo.gz', Time.at(0))
+    assert_nil fetcher.fetch_path(@uri + "foo.gz", Time.at(0))
   end
 
   def test_fetch_path_io_error
@@ -477,9 +493,9 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
       raise EOFError
     end
 
-    url = 'http://example.com/uri'
+    url = "http://example.com/uri"
 
-    e = assert_raises Gem::RemoteFetcher::FetchError do
+    e = assert_raise Gem::RemoteFetcher::FetchError do
       fetcher.fetch_path url
     end
 
@@ -495,9 +511,9 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
       raise SocketError
     end
 
-    url = 'http://example.com/uri'
+    url = "http://example.com/uri"
 
-    e = assert_raises Gem::RemoteFetcher::FetchError do
+    e = assert_raise Gem::RemoteFetcher::FetchError do
       fetcher.fetch_path url
     end
 
@@ -510,16 +526,54 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
     @fetcher = fetcher
 
     def fetcher.fetch_http(uri, mtime = nil, head = nil)
-      raise Errno::ECONNREFUSED, 'connect(2)'
+      raise Errno::ECONNREFUSED, "connect(2)"
+    end
+
+    url = "http://example.com/uri"
+
+    e = assert_raise Gem::RemoteFetcher::FetchError do
+      fetcher.fetch_path url
+    end
+
+    assert_match %r{ECONNREFUSED:.*connect\(2\) \(#{Regexp.escape url}\)\z},
+                 e.message
+    assert_equal url, e.uri
+  end
+
+  def test_fetch_path_timeout_error
+    fetcher = Gem::RemoteFetcher.new nil
+    @fetcher = fetcher
+
+    def fetcher.fetch_http(uri, mtime = nil, head = nil)
+      raise Timeout::Error, "timed out"
     end
 
-    url = 'http://example.com/uri'
+    url = "http://example.com/uri"
 
-    e = assert_raises Gem::RemoteFetcher::FetchError do
+    e = assert_raise Gem::RemoteFetcher::FetchError do
       fetcher.fetch_path url
     end
 
-    assert_match %r|ECONNREFUSED:.*connect\(2\) \(#{Regexp.escape url}\)\z|,
+    assert_match %r{Timeout::Error: timed out \(#{Regexp.escape url}\)\z},
+                 e.message
+    assert_equal url, e.uri
+  end
+
+  def test_fetch_path_getaddrinfo_error
+    fetcher = Gem::RemoteFetcher.new nil
+    @fetcher = fetcher
+
+    def fetcher.fetch_http(uri, mtime = nil, head = nil)
+      raise SocketError, "getaddrinfo: nodename nor servname provided"
+    end
+
+    url = "http://example.com/uri"
+
+    e = assert_raise Gem::RemoteFetcher::FetchError do
+      fetcher.fetch_path url
+    end
+
+    assert_match %r{SocketError: getaddrinfo: nodename nor servname provided \(#{Regexp.escape url}\)\z},
                  e.message
     assert_equal url, e.uri
   end
@@ -532,9 +586,9 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
       raise OpenSSL::SSL::SSLError
     end
 
-    url = 'http://example.com/uri'
+    url = "http://example.com/uri"
 
-    e = assert_raises Gem::RemoteFetcher::FetchError do
+    e = assert_raise Gem::RemoteFetcher::FetchError do
       fetcher.fetch_path url
     end
 
@@ -555,7 +609,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def test_implicit_no_proxy
     use_ui @stub_ui do
-      ENV['http_proxy'] = 'http://fakeurl:12345'
+      ENV["http_proxy"] = "http://fakeurl:12345"
       fetcher = Gem::RemoteFetcher.new :no_proxy
       @fetcher = fetcher
       assert_data_from_server fetcher.fetch_path(@server_uri)
@@ -564,7 +618,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def test_implicit_proxy
     use_ui @stub_ui do
-      ENV['http_proxy'] = @proxy_uri
+      ENV["http_proxy"] = @proxy_uri
       fetcher = Gem::RemoteFetcher.new nil
       @fetcher = fetcher
       assert_data_from_proxy fetcher.fetch_path(@server_uri)
@@ -573,7 +627,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def test_implicit_upper_case_proxy
     use_ui @stub_ui do
-      ENV['HTTP_PROXY'] = @proxy_uri
+      ENV["HTTP_PROXY"] = @proxy_uri
       fetcher = Gem::RemoteFetcher.new nil
       @fetcher = fetcher
       assert_data_from_proxy fetcher.fetch_path(@server_uri)
@@ -591,40 +645,40 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   def test_fetch_http
     fetcher = Gem::RemoteFetcher.new nil
     @fetcher = fetcher
-    url = 'http://gems.example.com/redirect'
+    url = "http://gems.example.com/redirect"
 
     def fetcher.request(uri, request_class, last_modified = nil)
-      url = 'http://gems.example.com/redirect'
+      url = "http://gems.example.com/redirect"
       unless defined? @requested
         @requested = true
         res = Net::HTTPMovedPermanently.new nil, 301, nil
-        res.add_field 'Location', url
+        res.add_field "Location", url
         res
       else
         res = Net::HTTPOK.new nil, 200, nil
-        def res.body() 'real_path' end
+        def res.body() "real_path" end
         res
       end
     end
 
     data = fetcher.fetch_http URI.parse(url)
 
-    assert_equal 'real_path', data
+    assert_equal "real_path", data
   end
 
   def test_fetch_http_redirects
     fetcher = Gem::RemoteFetcher.new nil
     @fetcher = fetcher
-    url = 'http://gems.example.com/redirect'
+    url = "http://gems.example.com/redirect"
 
     def fetcher.request(uri, request_class, last_modified = nil)
-      url = 'http://gems.example.com/redirect'
+      url = "http://gems.example.com/redirect"
       res = Net::HTTPMovedPermanently.new nil, 301, nil
-      res.add_field 'Location', url
+      res.add_field "Location", url
       res
     end
 
-    e = assert_raises Gem::RemoteFetcher::FetchError do
+    e = assert_raise Gem::RemoteFetcher::FetchError do
       fetcher.fetch_http URI.parse(url)
     end
 
@@ -634,14 +688,14 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   def test_fetch_http_redirects_without_location
     fetcher = Gem::RemoteFetcher.new nil
     @fetcher = fetcher
-    url = 'http://gems.example.com/redirect'
+    url = "http://gems.example.com/redirect"
 
     def fetcher.request(uri, request_class, last_modified = nil)
       res = Net::HTTPMovedPermanently.new nil, 301, nil
       res
     end
 
-    e = assert_raises Gem::RemoteFetcher::FetchError do
+    e = assert_raise Gem::RemoteFetcher::FetchError do
       fetcher.fetch_http URI.parse(url)
     end
 
@@ -651,12 +705,12 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   def test_fetch_http_with_additional_headers
     ENV["http_proxy"] = @proxy_uri
     ENV["no_proxy"] = URI::parse(@server_uri).host
-    fetcher = Gem::RemoteFetcher.new nil, nil, {"X-Captain" => "murphy"}
+    fetcher = Gem::RemoteFetcher.new nil, nil, { "X-Captain" => "murphy" }
     @fetcher = fetcher
     assert_equal "murphy", fetcher.fetch_path(@server_uri)
   end
 
-  def assert_fetch_s3(url, signature, token=nil, region='us-east-1', instance_profile_json=nil)
+  def assert_fetch_s3(url, signature, token=nil, region="us-east-1", instance_profile_json=nil)
     fetcher = Gem::RemoteFetcher.new nil
     @fetcher = fetcher
     $fetched_uri = nil
@@ -665,12 +719,12 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
     def fetcher.request(uri, request_class, last_modified = nil)
       $fetched_uri = uri
       res = Net::HTTPOK.new nil, 200, nil
-      def res.body() 'success' end
+      def res.body() "success" end
       res
     end
 
     def fetcher.s3_uri_signer(uri)
-      require 'json'
+      require "json"
       s3_uri_signer = Gem::S3URISigner.new(uri)
       def s3_uri_signer.ec2_metadata_credentials_json
         JSON.parse($instance_profile)
@@ -684,18 +738,18 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
     data = fetcher.fetch_s3 URI.parse(url)
 
     assert_equal "https://my-bucket.s3.#{region}.amazonaws.com/gems/specs.4.8.gz?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=testuser%2F20190624%2F#{region}%2Fs3%2Faws4_request&X-Amz-Date=20190624T050641Z&X-Amz-Expires=86400#{token ? "&X-Amz-Security-Token=" + token : ""}&X-Amz-SignedHeaders=host&X-Amz-Signature=#{signature}", $fetched_uri.to_s
-    assert_equal 'success', data
+    assert_equal "success", data
   ensure
     $fetched_uri = nil
   end
 
   def test_fetch_s3_config_creds
     Gem.configuration[:s3_source] = {
-      'my-bucket' => {:id => 'testuser', :secret => 'testpass'}
+      "my-bucket" => { :id => "testuser", :secret => "testpass" },
     }
-    url = 's3://my-bucket/gems/specs.4.8.gz'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
     Time.stub :now, Time.at(1561353581) do
-      assert_fetch_s3 url, '20f974027db2f3cd6193565327a7c73457a138efb1a63ea248d185ce6827d41b'
+      assert_fetch_s3 url, "20f974027db2f3cd6193565327a7c73457a138efb1a63ea248d185ce6827d41b"
     end
   ensure
     Gem.configuration[:s3_source] = nil
@@ -703,11 +757,11 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def test_fetch_s3_config_creds_with_region
     Gem.configuration[:s3_source] = {
-      'my-bucket' => {:id => 'testuser', :secret => 'testpass', :region => 'us-west-2'}
+      "my-bucket" => { :id => "testuser", :secret => "testpass", :region => "us-west-2" },
     }
-    url = 's3://my-bucket/gems/specs.4.8.gz'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
     Time.stub :now, Time.at(1561353581) do
-      assert_fetch_s3 url, '4afc3010757f1fd143e769f1d1dabd406476a4fc7c120e9884fd02acbb8f26c9', nil, 'us-west-2'
+      assert_fetch_s3 url, "4afc3010757f1fd143e769f1d1dabd406476a4fc7c120e9884fd02acbb8f26c9", nil, "us-west-2"
     end
   ensure
     Gem.configuration[:s3_source] = nil
@@ -715,79 +769,79 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def test_fetch_s3_config_creds_with_token
     Gem.configuration[:s3_source] = {
-      'my-bucket' => {:id => 'testuser', :secret => 'testpass', :security_token => 'testtoken'}
+      "my-bucket" => { :id => "testuser", :secret => "testpass", :security_token => "testtoken" },
     }
-    url = 's3://my-bucket/gems/specs.4.8.gz'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
     Time.stub :now, Time.at(1561353581) do
-      assert_fetch_s3 url, '935160a427ef97e7630f799232b8f208c4a4e49aad07d0540572a2ad5fe9f93c', 'testtoken'
+      assert_fetch_s3 url, "935160a427ef97e7630f799232b8f208c4a4e49aad07d0540572a2ad5fe9f93c", "testtoken"
     end
   ensure
     Gem.configuration[:s3_source] = nil
   end
 
   def test_fetch_s3_env_creds
-    ENV['AWS_ACCESS_KEY_ID'] = 'testuser'
-    ENV['AWS_SECRET_ACCESS_KEY'] = 'testpass'
-    ENV['AWS_SESSION_TOKEN'] = nil
+    ENV["AWS_ACCESS_KEY_ID"] = "testuser"
+    ENV["AWS_SECRET_ACCESS_KEY"] = "testpass"
+    ENV["AWS_SESSION_TOKEN"] = nil
     Gem.configuration[:s3_source] = {
-      'my-bucket' => {:provider => 'env'}
+      "my-bucket" => { :provider => "env" },
     }
-    url = 's3://my-bucket/gems/specs.4.8.gz'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
     Time.stub :now, Time.at(1561353581) do
-      assert_fetch_s3 url, '20f974027db2f3cd6193565327a7c73457a138efb1a63ea248d185ce6827d41b'
+      assert_fetch_s3 url, "20f974027db2f3cd6193565327a7c73457a138efb1a63ea248d185ce6827d41b"
     end
   ensure
-    ENV.each_key {|key| ENV.delete(key) if key.start_with?('AWS')}
+    ENV.each_key {|key| ENV.delete(key) if key.start_with?("AWS") }
     Gem.configuration[:s3_source] = nil
   end
 
   def test_fetch_s3_env_creds_with_region
-    ENV['AWS_ACCESS_KEY_ID'] = 'testuser'
-    ENV['AWS_SECRET_ACCESS_KEY'] = 'testpass'
-    ENV['AWS_SESSION_TOKEN'] = nil
+    ENV["AWS_ACCESS_KEY_ID"] = "testuser"
+    ENV["AWS_SECRET_ACCESS_KEY"] = "testpass"
+    ENV["AWS_SESSION_TOKEN"] = nil
     Gem.configuration[:s3_source] = {
-      'my-bucket' => {:provider => 'env', :region => 'us-west-2'}
+      "my-bucket" => { :provider => "env", :region => "us-west-2" },
     }
-    url = 's3://my-bucket/gems/specs.4.8.gz'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
     Time.stub :now, Time.at(1561353581) do
-      assert_fetch_s3 url, '4afc3010757f1fd143e769f1d1dabd406476a4fc7c120e9884fd02acbb8f26c9', nil, 'us-west-2'
+      assert_fetch_s3 url, "4afc3010757f1fd143e769f1d1dabd406476a4fc7c120e9884fd02acbb8f26c9", nil, "us-west-2"
     end
   ensure
-    ENV.each_key {|key| ENV.delete(key) if key.start_with?('AWS')}
+    ENV.each_key {|key| ENV.delete(key) if key.start_with?("AWS") }
     Gem.configuration[:s3_source] = nil
   end
 
   def test_fetch_s3_env_creds_with_token
-    ENV['AWS_ACCESS_KEY_ID'] = 'testuser'
-    ENV['AWS_SECRET_ACCESS_KEY'] = 'testpass'
-    ENV['AWS_SESSION_TOKEN'] = 'testtoken'
+    ENV["AWS_ACCESS_KEY_ID"] = "testuser"
+    ENV["AWS_SECRET_ACCESS_KEY"] = "testpass"
+    ENV["AWS_SESSION_TOKEN"] = "testtoken"
     Gem.configuration[:s3_source] = {
-      'my-bucket' => {:provider => 'env'}
+      "my-bucket" => { :provider => "env" },
     }
-    url = 's3://my-bucket/gems/specs.4.8.gz'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
     Time.stub :now, Time.at(1561353581) do
-      assert_fetch_s3 url, '935160a427ef97e7630f799232b8f208c4a4e49aad07d0540572a2ad5fe9f93c', 'testtoken'
+      assert_fetch_s3 url, "935160a427ef97e7630f799232b8f208c4a4e49aad07d0540572a2ad5fe9f93c", "testtoken"
     end
   ensure
-    ENV.each_key {|key| ENV.delete(key) if key.start_with?('AWS')}
+    ENV.each_key {|key| ENV.delete(key) if key.start_with?("AWS") }
     Gem.configuration[:s3_source] = nil
   end
 
   def test_fetch_s3_url_creds
-    url = 's3://testuser:testpass@my-bucket/gems/specs.4.8.gz'
+    url = "s3://testuser:testpass@my-bucket/gems/specs.4.8.gz"
     Time.stub :now, Time.at(1561353581) do
-      assert_fetch_s3 url, '20f974027db2f3cd6193565327a7c73457a138efb1a63ea248d185ce6827d41b'
+      assert_fetch_s3 url, "20f974027db2f3cd6193565327a7c73457a138efb1a63ea248d185ce6827d41b"
     end
   end
 
   def test_fetch_s3_instance_profile_creds
     Gem.configuration[:s3_source] = {
-      'my-bucket' => {:provider => 'instance_profile'}
+      "my-bucket" => { :provider => "instance_profile" },
     }
 
-    url = 's3://my-bucket/gems/specs.4.8.gz'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
     Time.stub :now, Time.at(1561353581) do
-      assert_fetch_s3 url, '20f974027db2f3cd6193565327a7c73457a138efb1a63ea248d185ce6827d41b', nil, 'us-east-1',
+      assert_fetch_s3 url, "20f974027db2f3cd6193565327a7c73457a138efb1a63ea248d185ce6827d41b", nil, "us-east-1",
                       '{"AccessKeyId": "testuser", "SecretAccessKey": "testpass"}'
     end
   ensure
@@ -796,12 +850,12 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def test_fetch_s3_instance_profile_creds_with_region
     Gem.configuration[:s3_source] = {
-      'my-bucket' => {:provider => 'instance_profile', :region => 'us-west-2'}
+      "my-bucket" => { :provider => "instance_profile", :region => "us-west-2" },
     }
 
-    url = 's3://my-bucket/gems/specs.4.8.gz'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
     Time.stub :now, Time.at(1561353581) do
-      assert_fetch_s3 url, '4afc3010757f1fd143e769f1d1dabd406476a4fc7c120e9884fd02acbb8f26c9', nil, 'us-west-2',
+      assert_fetch_s3 url, "4afc3010757f1fd143e769f1d1dabd406476a4fc7c120e9884fd02acbb8f26c9", nil, "us-west-2",
                       '{"AccessKeyId": "testuser", "SecretAccessKey": "testpass"}'
     end
   ensure
@@ -810,12 +864,12 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def test_fetch_s3_instance_profile_creds_with_token
     Gem.configuration[:s3_source] = {
-      'my-bucket' => {:provider => 'instance_profile'}
+      "my-bucket" => { :provider => "instance_profile" },
     }
 
-    url = 's3://my-bucket/gems/specs.4.8.gz'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
     Time.stub :now, Time.at(1561353581) do
-      assert_fetch_s3 url, '935160a427ef97e7630f799232b8f208c4a4e49aad07d0540572a2ad5fe9f93c', 'testtoken', 'us-east-1',
+      assert_fetch_s3 url, "935160a427ef97e7630f799232b8f208c4a4e49aad07d0540572a2ad5fe9f93c", "testtoken", "us-east-1",
                       '{"AccessKeyId": "testuser", "SecretAccessKey": "testpass", "Token": "testtoken"}'
     end
   ensure
@@ -826,7 +880,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
     fetcher = Gem::RemoteFetcher.new nil
     @fetcher = fetcher
 
-    e = assert_raises Gem::RemoteFetcher::FetchError do
+    e = assert_raise Gem::RemoteFetcher::FetchError do
       fetcher.fetch_s3 URI.parse(url)
     end
 
@@ -834,35 +888,35 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   end
 
   def test_fetch_s3_no_source_key
-    url = 's3://my-bucket/gems/specs.4.8.gz'
-    refute_fetch_s3 url, 'no s3_source key exists in .gemrc'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
+    refute_fetch_s3 url, "no s3_source key exists in .gemrc"
   end
 
   def test_fetch_s3_no_host
     Gem.configuration[:s3_source] = {
-      'my-bucket' => {:id => 'testuser', :secret => 'testpass'}
+      "my-bucket" => { :id => "testuser", :secret => "testpass" },
     }
 
-    url = 's3://other-bucket/gems/specs.4.8.gz'
-    refute_fetch_s3 url, 'no key for host other-bucket in s3_source in .gemrc'
+    url = "s3://other-bucket/gems/specs.4.8.gz"
+    refute_fetch_s3 url, "no key for host other-bucket in s3_source in .gemrc"
   ensure
     Gem.configuration[:s3_source] = nil
   end
 
   def test_fetch_s3_no_id
-    Gem.configuration[:s3_source] = { 'my-bucket' => {:secret => 'testpass'} }
+    Gem.configuration[:s3_source] = { "my-bucket" => { :secret => "testpass" } }
 
-    url = 's3://my-bucket/gems/specs.4.8.gz'
-    refute_fetch_s3 url, 's3_source for my-bucket missing id or secret'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
+    refute_fetch_s3 url, "s3_source for my-bucket missing id or secret"
   ensure
     Gem.configuration[:s3_source] = nil
   end
 
   def test_fetch_s3_no_secret
-    Gem.configuration[:s3_source] = { 'my-bucket' => {:id => 'testuser'} }
+    Gem.configuration[:s3_source] = { "my-bucket" => { :id => "testuser" } }
 
-    url = 's3://my-bucket/gems/specs.4.8.gz'
-    refute_fetch_s3 url, 's3_source for my-bucket missing id or secret'
+    url = "s3://my-bucket/gems/specs.4.8.gz"
+    refute_fetch_s3 url, "s3_source for my-bucket missing id or secret"
   ensure
     Gem.configuration[:s3_source] = nil
   end
@@ -892,7 +946,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
     @fetcher = fetcher
 
     assert_throws :block_called do
-      fetcher.request URI('http://example'), Net::HTTP::Get do |req|
+      fetcher.request URI("http://example"), Net::HTTP::Get do |req|
         assert_kind_of Net::HTTPGenericRequest, req
         throw :block_called
       end
@@ -901,7 +955,7 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def test_yaml_error_on_size
     use_ui @stub_ui do
-      self.class.enable_yaml = false
+      self.enable_yaml = false
       fetcher = Gem::RemoteFetcher.new nil
       @fetcher = fetcher
       assert_error { fetcher.size }
@@ -909,23 +963,20 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   end
 
   def test_ssl_connection
-    ssl_server = self.class.start_ssl_server
-    temp_ca_cert = File.join(DIR, 'ca_cert.pem')
+    ssl_server = start_ssl_server
+    temp_ca_cert = File.join(__dir__, "ca_cert.pem")
     with_configured_fetcher(":ssl_ca_cert: #{temp_ca_cert}") do |fetcher|
       fetcher.fetch_path("https://localhost:#{ssl_server.config[:Port]}/yaml")
     end
   end
 
   def test_ssl_client_cert_auth_connection
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
-    skip 'openssl in jruby fails' if java_platform?
-
-    ssl_server = self.class.start_ssl_server({
+    ssl_server = start_ssl_server({
       :SSLVerifyClient =>
-        OpenSSL::SSL::VERIFY_PEER | OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT})
+        OpenSSL::SSL::VERIFY_PEER | OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT })
 
-    temp_ca_cert = File.join(DIR, 'ca_cert.pem')
-    temp_client_cert = File.join(DIR, 'client.pem')
+    temp_ca_cert = File.join(__dir__, "ca_cert.pem")
+    temp_client_cert = File.join(__dir__, "client.pem")
 
     with_configured_fetcher(
       ":ssl_ca_cert: #{temp_ca_cert}\n" +
@@ -935,48 +986,46 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   end
 
   def test_do_not_allow_invalid_client_cert_auth_connection
-    skip 'openssl is missing' unless defined?(OpenSSL::SSL)
-
-    ssl_server = self.class.start_ssl_server({
+    ssl_server = start_ssl_server({
       :SSLVerifyClient =>
-        OpenSSL::SSL::VERIFY_PEER | OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT})
+        OpenSSL::SSL::VERIFY_PEER | OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT })
 
-    temp_ca_cert = File.join(DIR, 'ca_cert.pem')
-    temp_client_cert = File.join(DIR, 'invalid_client.pem')
+    temp_ca_cert = File.join(__dir__, "ca_cert.pem")
+    temp_client_cert = File.join(__dir__, "invalid_client.pem")
 
     with_configured_fetcher(
       ":ssl_ca_cert: #{temp_ca_cert}\n" +
       ":ssl_client_cert: #{temp_client_cert}\n") do |fetcher|
-      assert_raises Gem::RemoteFetcher::FetchError do
+      assert_raise Gem::RemoteFetcher::FetchError do
         fetcher.fetch_path("https://localhost:#{ssl_server.config[:Port]}/yaml")
       end
     end
   end
 
   def test_do_not_allow_insecure_ssl_connection_by_default
-    ssl_server = self.class.start_ssl_server
+    ssl_server = start_ssl_server
     with_configured_fetcher do |fetcher|
-      assert_raises Gem::RemoteFetcher::FetchError do
+      assert_raise Gem::RemoteFetcher::FetchError do
         fetcher.fetch_path("https://localhost:#{ssl_server.config[:Port]}/yaml")
       end
     end
   end
 
   def test_ssl_connection_allow_verify_none
-    ssl_server = self.class.start_ssl_server
+    ssl_server = start_ssl_server
     with_configured_fetcher(":ssl_verify_mode: 0") do |fetcher|
       fetcher.fetch_path("https://localhost:#{ssl_server.config[:Port]}/yaml")
     end
   end
 
   def test_do_not_follow_insecure_redirect
-    ssl_server = self.class.start_ssl_server
-    temp_ca_cert = File.join(DIR, 'ca_cert.pem')
+    ssl_server = start_ssl_server
+    temp_ca_cert = File.join(__dir__, "ca_cert.pem")
     expected_error_message =
       "redirecting to non-https resource: #{@server_uri} (https://localhost:#{ssl_server.config[:Port]}/insecure_redirect?to=#{@server_uri})"
 
     with_configured_fetcher(":ssl_ca_cert: #{temp_ca_cert}") do |fetcher|
-      err = assert_raises Gem::RemoteFetcher::FetchError do
+      err = assert_raise Gem::RemoteFetcher::FetchError do
         fetcher.fetch_path("https://localhost:#{ssl_server.config[:Port]}/insecure_redirect?to=#{@server_uri}")
       end
 
@@ -985,11 +1034,11 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   end
 
   def test_nil_ca_cert
-    ssl_server = self.class.start_ssl_server
+    ssl_server = start_ssl_server
     temp_ca_cert = nil
 
     with_configured_fetcher(":ssl_ca_cert: #{temp_ca_cert}") do |fetcher|
-      assert_raises Gem::RemoteFetcher::FetchError do
+      assert_raise Gem::RemoteFetcher::FetchError do
         fetcher.fetch_path("https://localhost:#{ssl_server.config[:Port]}")
       end
     end
@@ -997,8 +1046,8 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
 
   def with_configured_fetcher(config_str = nil, &block)
     if config_str
-      temp_conf = File.join @tempdir, '.gemrc'
-      File.open temp_conf, 'w' do |fp|
+      temp_conf = File.join @tempdir, ".gemrc"
+      File.open temp_conf, "w" do |fp|
         fp.puts config_str
       end
       Gem.configuration = Gem::ConfigFile.new %W[--config-file #{temp_conf}]
@@ -1031,157 +1080,147 @@ PeIQQkFng2VVot/WAQbv3ePqWq07g1BBcwIBAg==
   end
 
   class NilLog < WEBrick::Log
-
     def log(level, data) #Do nothing
     end
-
   end
 
-  class << self
+  private
 
-    attr_reader :normal_server, :proxy_server
-    attr_accessor :enable_zip, :enable_yaml
+  attr_reader :normal_server, :proxy_server
+  attr_accessor :enable_zip, :enable_yaml
 
-    def start_servers
-      @normal_server ||= start_server(SERVER_DATA)
-      @proxy_server  ||= start_server(PROXY_DATA)
-      @enable_yaml = true
-      @enable_zip = false
+  def start_servers
+    @normal_server ||= start_server(SERVER_DATA)
+    @proxy_server  ||= start_server(PROXY_DATA)
+    @enable_yaml = true
+    @enable_zip = false
+    @ssl_server = nil
+    @ssl_server_thread = nil
+  end
+
+  def stop_servers
+    if @normal_server
+      @normal_server.kill.join
+      @normal_server = nil
+    end
+    if @proxy_server
+      @proxy_server.kill.join
+      @proxy_server = nil
+    end
+    if @ssl_server
+      @ssl_server.stop
       @ssl_server = nil
-      @ssl_server_thread = nil
     end
-
-    def stop_servers
-      if @normal_server
-        @normal_server.kill.join
-        @normal_server = nil
-      end
-      if @proxy_server
-        @proxy_server.kill.join
-        @proxy_server = nil
-      end
-      if @ssl_server
-        @ssl_server.stop
-        @ssl_server = nil
-      end
-      if @ssl_server_thread
-        @ssl_server_thread.kill.join
-        @ssl_server_thread = nil
-      end
-      utils = WEBrick::Utils    # TimeoutHandler is since 1.9
-      utils::TimeoutHandler.terminate if defined?(utils::TimeoutHandler.terminate)
+    if @ssl_server_thread
+      @ssl_server_thread.kill.join
+      @ssl_server_thread = nil
     end
+    utils = WEBrick::Utils # TimeoutHandler is since 1.9
+    utils::TimeoutHandler.terminate if defined?(utils::TimeoutHandler.terminate)
+  end
 
-    def normal_server_port
-      @normal_server[:server].config[:Port]
-    end
+  def normal_server_port
+    @normal_server[:server].config[:Port]
+  end
 
-    def proxy_server_port
-      @proxy_server[:server].config[:Port]
-    end
-
-    DIR = File.expand_path(File.dirname(__FILE__))
-
-    def start_ssl_server(config = {})
-      raise MiniTest::Skip, 'openssl not installed' unless
-        defined?(OpenSSL::SSL)
-
-      null_logger = NilLog.new
-      server = WEBrick::HTTPServer.new({
-        :Port => 0,
-        :Logger => null_logger,
-        :AccessLog => [],
-        :SSLEnable => true,
-        :SSLCACertificateFile => File.join(DIR, 'ca_cert.pem'),
-        :SSLCertificate => cert('ssl_cert.pem'),
-        :SSLPrivateKey => key('ssl_key.pem'),
-        :SSLVerifyClient => nil,
-        :SSLCertName => nil
-      }.merge(config))
-      server.mount_proc("/yaml") do |req, res|
-        res.body = "--- true\n"
-      end
-      server.mount_proc("/insecure_redirect") do |req, res|
-        res.set_redirect(WEBrick::HTTPStatus::MovedPermanently, req.query['to'])
-      end
-      server.ssl_context.tmp_dh_callback = proc { TEST_KEY_DH2048 }
-      t = Thread.new do
-        begin
-          server.start
-        rescue Exception => ex
-          abort ex.message
-          puts "ERROR during server thread: #{ex.message}"
-        ensure
-          server.shutdown
-        end
-      end
-      while server.status != :Running
-        sleep 0.1
-        unless t.alive?
-          t.join
-          raise
-        end
-      end
-      @ssl_server = server
-      @ssl_server_thread = t
-      server
-    end
-
-    private
-
-    def start_server(data)
-      null_logger = NilLog.new
-      s = WEBrick::HTTPServer.new(
-        :Port            => 0,
-        :DocumentRoot    => nil,
-        :Logger          => null_logger,
-        :AccessLog       => null_logger
-      )
-      s.mount_proc("/kill") { |req, res| s.shutdown }
-      s.mount_proc("/yaml") do |req, res|
-        if req["X-Captain"]
-          res.body = req["X-Captain"]
-        elsif @enable_yaml
-          res.body = data
-          res['Content-Type'] = 'text/plain'
-          res['content-length'] = data.size
-        else
-          res.status = "404"
-          res.body = "<h1>NOT FOUND</h1>"
-          res['Content-Type'] = 'text/html'
-        end
-      end
-      s.mount_proc("/yaml.Z") do |req, res|
-        if @enable_zip
-          res.body = Zlib::Deflate.deflate(data)
-          res['Content-Type'] = 'text/plain'
-        else
-          res.status = "404"
-          res.body = "<h1>NOT FOUND</h1>"
-          res['Content-Type'] = 'text/html'
-        end
-      end
-      th = Thread.new do
-        begin
-          s.start
-        rescue Exception => ex
-          abort "ERROR during server thread: #{ex.message}"
-        ensure
-          s.shutdown
-        end
+  def proxy_server_port
+    @proxy_server[:server].config[:Port]
+  end
+
+  def start_ssl_server(config = {})
+    pend "starting this test server fails randomly on jruby" if Gem.java_platform?
+
+    null_logger = NilLog.new
+    server = WEBrick::HTTPServer.new({
+      :Port => 0,
+      :Logger => null_logger,
+      :AccessLog => [],
+      :SSLEnable => true,
+      :SSLCACertificateFile => File.join(__dir__, "ca_cert.pem"),
+      :SSLCertificate => cert("ssl_cert.pem"),
+      :SSLPrivateKey => key("ssl_key.pem"),
+      :SSLVerifyClient => nil,
+      :SSLCertName => nil,
+    }.merge(config))
+    server.mount_proc("/yaml") do |req, res|
+      res.body = "--- true\n"
+    end
+    server.mount_proc("/insecure_redirect") do |req, res|
+      res.set_redirect(WEBrick::HTTPStatus::MovedPermanently, req.query["to"])
+    end
+    server.ssl_context.tmp_dh_callback = proc { TEST_KEY_DH2048 }
+    t = Thread.new do
+      begin
+        server.start
+      rescue Exception => ex
+        puts "ERROR during server thread: #{ex.message}"
+        raise
+      ensure
+        server.shutdown
+      end
+    end
+    while server.status != :Running
+      sleep 0.1
+      unless t.alive?
+        t.join
+        raise
+      end
+    end
+    @ssl_server = server
+    @ssl_server_thread = t
+    server
+  end
+
+  def start_server(data)
+    null_logger = NilLog.new
+    s = WEBrick::HTTPServer.new(
+      :Port            => 0,
+      :DocumentRoot    => nil,
+      :Logger          => null_logger,
+      :AccessLog       => null_logger
+    )
+    s.mount_proc("/kill") {|req, res| s.shutdown }
+    s.mount_proc("/yaml") do |req, res|
+      if req["X-Captain"]
+        res.body = req["X-Captain"]
+      elsif @enable_yaml
+        res.body = data
+        res["Content-Type"] = "text/plain"
+        res["content-length"] = data.size
+      else
+        res.status = "404"
+        res.body = "<h1>NOT FOUND</h1>"
+        res["Content-Type"] = "text/html"
       end
-      th[:server] = s
-      th
     end
-
-    def cert(filename)
-      OpenSSL::X509::Certificate.new(File.read(File.join(DIR, filename)))
+    s.mount_proc("/yaml.Z") do |req, res|
+      if @enable_zip
+        res.body = Zlib::Deflate.deflate(data)
+        res["Content-Type"] = "text/plain"
+      else
+        res.status = "404"
+        res.body = "<h1>NOT FOUND</h1>"
+        res["Content-Type"] = "text/html"
+      end
     end
-
-    def key(filename)
-      OpenSSL::PKey::RSA.new(File.read(File.join(DIR, filename)))
+    th = Thread.new do
+      begin
+        s.start
+      rescue Exception => ex
+        abort "ERROR during server thread: #{ex.message}"
+      ensure
+        s.shutdown
+      end
     end
+    th[:server] = s
+    th
+  end
 
+  def cert(filename)
+    OpenSSL::X509::Certificate.new(File.read(File.join(__dir__, filename)))
   end
 
-end if defined?(OpenSSL::SSL)
+  def key(filename)
+    OpenSSL::PKey::RSA.new(File.read(File.join(__dir__, filename)))
+  end
+end if Gem::HAVE_OPENSSL
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_request.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_request.rb
@@ -1,21 +1,20 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/request'
-require 'ostruct'
-require 'base64'
+require_relative "helper"
+require "rubygems/request"
+require "ostruct"
+require "base64"
 
-unless defined?(OpenSSL::SSL)
-  warn 'Skipping Gem::Request tests.  openssl not found.'
+unless Gem::HAVE_OPENSSL
+  warn "Skipping Gem::Request tests.  openssl not found."
 end
 
 class TestGemRequest < Gem::TestCase
-
-  CA_CERT_FILE     = cert_path 'ca'
-  CHILD_CERT       = load_cert 'child'
-  EXPIRED_CERT     = load_cert 'expired'
-  PUBLIC_CERT      = load_cert 'public'
-  PUBLIC_CERT_FILE = cert_path 'public'
-  SSL_CERT         = load_cert 'ssl'
+  CA_CERT_FILE     = cert_path "ca"
+  CHILD_CERT       = load_cert "child"
+  EXPIRED_CERT     = load_cert "expired"
+  PUBLIC_CERT      = load_cert "public"
+  PUBLIC_CERT_FILE = cert_path "public"
+  SSL_CERT         = load_cert "ssl"
 
   def make_request(uri, request_class, last_modified, proxy)
     Gem::Request.create_with_proxy uri, request_class, last_modified, proxy
@@ -29,7 +28,7 @@ class TestGemRequest < Gem::TestCase
     super
 
     @proxy_uri = "http://localhost:1234"
-    @uri = URI('http://example')
+    @uri = URI("http://example")
 
     @request = make_request @uri, nil, nil, nil
   end
@@ -41,7 +40,7 @@ class TestGemRequest < Gem::TestCase
   end
 
   def test_initialize_proxy
-    proxy_uri = 'http://proxy.example.com'
+    proxy_uri = "http://proxy.example.com"
 
     request = make_request @uri, nil, nil, proxy_uri
 
@@ -49,7 +48,7 @@ class TestGemRequest < Gem::TestCase
   end
 
   def test_initialize_proxy_URI
-    proxy_uri = 'http://proxy.example.com'
+    proxy_uri = "http://proxy.example.com"
 
     request = make_request @uri, nil, nil, URI(proxy_uri)
 
@@ -57,22 +56,22 @@ class TestGemRequest < Gem::TestCase
   end
 
   def test_initialize_proxy_ENV
-    ENV['http_proxy'] = @proxy_uri
-    ENV['http_proxy_user'] = 'foo'
-    ENV['http_proxy_pass'] = 'bar'
+    ENV["http_proxy"] = @proxy_uri
+    ENV["http_proxy_user"] = "foo"
+    ENV["http_proxy_pass"] = "bar"
 
     request = make_request @uri, nil, nil, nil
 
     proxy = request.proxy_uri
 
-    assert_equal 'foo', proxy.user
-    assert_equal 'bar', proxy.password
+    assert_equal "foo", proxy.user
+    assert_equal "bar", proxy.password
   end
 
   def test_initialize_proxy_ENV_https
-    ENV['https_proxy'] = @proxy_uri
+    ENV["https_proxy"] = @proxy_uri
 
-    request = make_request URI('https://example'), nil, nil, nil
+    request = make_request URI("https://example"), nil, nil, nil
 
     proxy = request.proxy_uri
 
@@ -80,10 +79,10 @@ class TestGemRequest < Gem::TestCase
   end
 
   def test_proxy_ENV
-    ENV['http_proxy'] = "http://proxy"
-    ENV['https_proxy'] = ""
+    ENV["http_proxy"] = "http://proxy"
+    ENV["https_proxy"] = ""
 
-    request = make_request URI('https://example'), nil, nil, nil
+    request = make_request URI("https://example"), nil, nil, nil
 
     proxy = request.proxy_uri
 
@@ -91,13 +90,13 @@ class TestGemRequest < Gem::TestCase
   end
 
   def test_configure_connection_for_https
-    connection = Net::HTTP.new 'localhost', 443
+    connection = Net::HTTP.new "localhost", 443
 
     request = Class.new(Gem::Request) do
       def self.get_cert_files
         [TestGemRequest::PUBLIC_CERT_FILE]
       end
-    end.create_with_proxy URI('https://example'), nil, nil, nil
+    end.create_with_proxy URI("https://example"), nil, nil, nil
 
     Gem::Request.configure_connection_for_https connection, request.cert_files
 
@@ -110,13 +109,13 @@ class TestGemRequest < Gem::TestCase
     ssl_ca_cert, Gem.configuration.ssl_ca_cert =
       Gem.configuration.ssl_ca_cert, CA_CERT_FILE
 
-    connection = Net::HTTP.new 'localhost', 443
+    connection = Net::HTTP.new "localhost", 443
 
     request = Class.new(Gem::Request) do
       def self.get_cert_files
         [TestGemRequest::PUBLIC_CERT_FILE]
       end
-    end.create_with_proxy URI('https://example'), nil, nil, nil
+    end.create_with_proxy URI("https://example"), nil, nil, nil
 
     Gem::Request.configure_connection_for_https connection, request.cert_files
 
@@ -129,7 +128,7 @@ class TestGemRequest < Gem::TestCase
   end
 
   def test_get_proxy_from_env_fallback
-    ENV['http_proxy'] = @proxy_uri
+    ENV["http_proxy"] = @proxy_uri
     request = make_request @uri, nil, nil, nil
     proxy = request.proxy_uri
 
@@ -137,8 +136,8 @@ class TestGemRequest < Gem::TestCase
   end
 
   def test_get_proxy_from_env_https
-    ENV['https_proxy'] = @proxy_uri
-    uri = URI('https://example')
+    ENV["https_proxy"] = @proxy_uri
+    uri = URI("https://example")
     request = make_request uri, nil, nil, nil
 
     proxy = request.proxy_uri
@@ -147,46 +146,46 @@ class TestGemRequest < Gem::TestCase
   end
 
   def test_get_proxy_from_env_domain
-    ENV['http_proxy'] = @proxy_uri
-    ENV['http_proxy_user'] = 'foo\user'
-    ENV['http_proxy_pass'] = 'my bar'
+    ENV["http_proxy"] = @proxy_uri
+    ENV["http_proxy_user"] = 'foo\user'
+    ENV["http_proxy_pass"] = "my bar"
     request = make_request @uri, nil, nil, nil
 
     proxy = request.proxy_uri
 
     assert_equal 'foo\user', Gem::UriFormatter.new(proxy.user).unescape
-    assert_equal 'my bar', Gem::UriFormatter.new(proxy.password).unescape
+    assert_equal "my bar", Gem::UriFormatter.new(proxy.password).unescape
   end
 
   def test_get_proxy_from_env_escape
-    ENV['http_proxy'] = @proxy_uri
-    ENV['http_proxy_user'] = 'foo@user'
-    ENV['http_proxy_pass'] = 'my@bar'
+    ENV["http_proxy"] = @proxy_uri
+    ENV["http_proxy_user"] = "foo@user"
+    ENV["http_proxy_pass"] = "my@bar"
     request = make_request @uri, nil, nil, nil
 
     proxy = request.proxy_uri
 
-    assert_equal 'foo%40user', proxy.user
-    assert_equal 'my%40bar',   proxy.password
+    assert_equal "foo%40user", proxy.user
+    assert_equal "my%40bar",   proxy.password
   end
 
   def test_get_proxy_from_env_normalize
-    ENV['HTTP_PROXY'] = 'fakeurl:12345'
+    ENV["HTTP_PROXY"] = "fakeurl:12345"
     request = make_request @uri, nil, nil, nil
 
-    assert_equal 'http://fakeurl:12345', request.proxy_uri.to_s
+    assert_equal "http://fakeurl:12345", request.proxy_uri.to_s
   end
 
   def test_get_proxy_from_env_empty
-    ENV['HTTP_PROXY'] = ''
-    ENV.delete 'http_proxy'
+    ENV["HTTP_PROXY"] = ""
+    ENV.delete "http_proxy"
     request = make_request @uri, nil, nil, nil
 
     assert_nil request.proxy_uri
   end
 
   def test_fetch
-    uri = URI.parse "#{@gem_repo}/specs.#{Gem.marshal_version}"
+    uri = Gem::Uri.new(URI.parse "#{@gem_repo}/specs.#{Gem.marshal_version}")
     response = util_stub_net_http(:body => :junk, :code => 200) do
       @request = make_request(uri, Net::HTTP::Get, nil, nil)
 
@@ -198,75 +197,101 @@ class TestGemRequest < Gem::TestCase
   end
 
   def test_fetch_basic_auth
-    uri = URI.parse "https://user:pass@example.rubygems/specs.#{Gem.marshal_version}"
+    Gem.configuration.verbose = :really
+    uri = Gem::Uri.new(URI.parse "https://user:pass@example.rubygems/specs.#{Gem.marshal_version}")
     conn = util_stub_net_http(:body => :junk, :code => 200) do |c|
-      @request = make_request(uri, Net::HTTP::Get, nil, nil)
-      @request.fetch
+      use_ui @ui do
+        @request = make_request(uri, Net::HTTP::Get, nil, nil)
+        @request.fetch
+      end
       c
     end
 
-    auth_header = conn.payload['Authorization']
+    auth_header = conn.payload["Authorization"]
     assert_equal "Basic #{Base64.encode64('user:pass')}".strip, auth_header
+    assert_includes @ui.output, "GET https://user:REDACTED@example.rubygems/specs.#{Gem.marshal_version}"
   end
 
   def test_fetch_basic_auth_encoded
-    uri = URI.parse "https://user:%7BDEScede%7Dpass@example.rubygems/specs.#{Gem.marshal_version}"
+    Gem.configuration.verbose = :really
+    uri = Gem::Uri.new(URI.parse "https://user:%7BDEScede%7Dpass@example.rubygems/specs.#{Gem.marshal_version}")
+
     conn = util_stub_net_http(:body => :junk, :code => 200) do |c|
-      @request = make_request(uri, Net::HTTP::Get, nil, nil)
-      @request.fetch
+      use_ui @ui do
+        @request = make_request(uri, Net::HTTP::Get, nil, nil)
+        @request.fetch
+      end
       c
     end
 
-    auth_header = conn.payload['Authorization']
+    auth_header = conn.payload["Authorization"]
     assert_equal "Basic #{Base64.encode64('user:{DEScede}pass')}".strip, auth_header
+    assert_includes @ui.output, "GET https://user:REDACTED@example.rubygems/specs.#{Gem.marshal_version}"
+  end
+
+  def test_fetch_basic_oauth_encoded
+    Gem.configuration.verbose = :really
+    uri = Gem::Uri.new(URI.parse "https://%7BDEScede%7Dpass:x-oauth-basic@example.rubygems/specs.#{Gem.marshal_version}")
+
+    conn = util_stub_net_http(:body => :junk, :code => 200) do |c|
+      use_ui @ui do
+        @request = make_request(uri, Net::HTTP::Get, nil, nil)
+        @request.fetch
+      end
+      c
+    end
+
+    auth_header = conn.payload["Authorization"]
+    assert_equal "Basic #{Base64.encode64('{DEScede}pass:x-oauth-basic')}".strip, auth_header
+    assert_includes @ui.output, "GET https://REDACTED:x-oauth-basic@example.rubygems/specs.#{Gem.marshal_version}"
   end
 
   def test_fetch_head
-    uri = URI.parse "#{@gem_repo}/specs.#{Gem.marshal_version}"
-    response = util_stub_net_http(:body => '', :code => 200) do |conn|
+    uri = Gem::Uri.new(URI.parse "#{@gem_repo}/specs.#{Gem.marshal_version}")
+    response = util_stub_net_http(:body => "", :code => 200) do |conn|
       @request = make_request(uri, Net::HTTP::Get, nil, nil)
       @request.fetch
     end
 
     assert_equal 200, response.code
-    assert_equal '', response.body
+    assert_equal "", response.body
   end
 
   def test_fetch_unmodified
-    uri = URI.parse "#{@gem_repo}/specs.#{Gem.marshal_version}"
+    uri = Gem::Uri.new(URI.parse "#{@gem_repo}/specs.#{Gem.marshal_version}")
     t = Time.utc(2013, 1, 2, 3, 4, 5)
-    conn, response = util_stub_net_http(:body => '', :code => 304) do |c|
+    conn, response = util_stub_net_http(:body => "", :code => 304) do |c|
       @request = make_request(uri, Net::HTTP::Get, t, nil)
       [c, @request.fetch]
     end
 
     assert_equal 304, response.code
-    assert_equal '', response.body
+    assert_equal "", response.body
 
-    modified_header = conn.payload['if-modified-since']
+    modified_header = conn.payload["if-modified-since"]
 
-    assert_equal 'Wed, 02 Jan 2013 03:04:05 GMT', modified_header
+    assert_equal "Wed, 02 Jan 2013 03:04:05 GMT", modified_header
   end
 
   def test_user_agent
     ua = make_request(@uri, nil, nil, nil).user_agent
 
-    assert_match %r%^RubyGems/\S+ \S+ Ruby/\S+ \(.*?\)%,          ua
-    assert_match %r%RubyGems/#{Regexp.escape Gem::VERSION}%,      ua
-    assert_match %r% #{Regexp.escape Gem::Platform.local.to_s} %, ua
-    assert_match %r%Ruby/#{Regexp.escape RUBY_VERSION}%,          ua
-    assert_match %r%\(#{Regexp.escape RUBY_RELEASE_DATE} %,       ua
+    assert_match %r{^RubyGems/\S+ \S+ Ruby/\S+ \(.*?\)},          ua
+    assert_match %r{RubyGems/#{Regexp.escape Gem::VERSION}},      ua
+    assert_match %r{ #{Regexp.escape Gem::Platform.local.to_s} }, ua
+    assert_match %r{Ruby/#{Regexp.escape RUBY_VERSION}},          ua
+    assert_match %r{\(#{Regexp.escape RUBY_RELEASE_DATE} },       ua
   end
 
   def test_user_agent_engine
     util_save_version
 
     Object.send :remove_const, :RUBY_ENGINE
-    Object.send :const_set,    :RUBY_ENGINE, 'vroom'
+    Object.send :const_set,    :RUBY_ENGINE, "vroom"
 
     ua = make_request(@uri, nil, nil, nil).user_agent
 
-    assert_match %r%\) vroom%, ua
+    assert_match %r{\) vroom}, ua
   ensure
     util_restore_version
   end
@@ -275,11 +300,11 @@ class TestGemRequest < Gem::TestCase
     util_save_version
 
     Object.send :remove_const, :RUBY_ENGINE
-    Object.send :const_set,    :RUBY_ENGINE, 'ruby'
+    Object.send :const_set,    :RUBY_ENGINE, "ruby"
 
     ua = make_request(@uri, nil, nil, nil).user_agent
 
-    assert_match %r%\)%, ua
+    assert_match %r{\)}, ua
   ensure
     util_restore_version
   end
@@ -292,7 +317,7 @@ class TestGemRequest < Gem::TestCase
 
     ua = make_request(@uri, nil, nil, nil).user_agent
 
-    assert_match %r% patchlevel 5\)%, ua
+    assert_match %r{ patchlevel 5\)}, ua
   ensure
     util_restore_version
   end
@@ -307,8 +332,8 @@ class TestGemRequest < Gem::TestCase
 
     ua = make_request(@uri, nil, nil, nil).user_agent
 
-    assert_match %r% revision 6\)%, ua
-    assert_match %r%Ruby/#{Regexp.escape RUBY_VERSION}dev%, ua
+    assert_match %r{ revision 6\)}, ua
+    assert_match %r{Ruby/#{Regexp.escape RUBY_VERSION}dev}, ua
   ensure
     util_restore_version
   end
@@ -322,37 +347,43 @@ class TestGemRequest < Gem::TestCase
 
     ua = make_request(@uri, nil, nil, nil).user_agent
 
-    assert_match %r%\(#{Regexp.escape RUBY_RELEASE_DATE}\)%, ua
+    assert_match %r{\(#{Regexp.escape RUBY_RELEASE_DATE}\)}, ua
   ensure
     util_restore_version
   end
 
   def test_verify_certificate
-    skip if Gem.java_platform?
+    pend if Gem.java_platform?
+
+    error_number = OpenSSL::X509::V_ERR_OUT_OF_MEM
+
     store = OpenSSL::X509::Store.new
     context = OpenSSL::X509::StoreContext.new store
-    context.error = OpenSSL::X509::V_ERR_OUT_OF_MEM
+    context.error = error_number
 
     use_ui @ui do
       Gem::Request.verify_certificate context
     end
 
-    assert_equal "ERROR:  SSL verification error at depth 0: out of memory (17)\n",
+    assert_equal "ERROR:  SSL verification error at depth 0: out of memory (#{error_number})\n",
                  @ui.error
   end
 
   def test_verify_certificate_extra_message
-    skip if Gem.java_platform?
+    pend if Gem.java_platform?
+
+    error_number = OpenSSL::X509::V_ERR_INVALID_CA
+
     store = OpenSSL::X509::Store.new
     context = OpenSSL::X509::StoreContext.new store
-    context.error = OpenSSL::X509::V_ERR_INVALID_CA
+    context.error = error_number
 
     use_ui @ui do
       Gem::Request.verify_certificate context
     end
 
     expected = <<-ERROR
-ERROR:  SSL verification error at depth 0: invalid CA certificate (24)
+ERROR:  SSL verification error at depth 0: invalid CA certificate (#{error_number})
 ERROR:  Certificate  is an invalid CA certificate
     ERROR
 
@@ -488,7 +519,6 @@ ERROR:  Certificate  is an invalid CA ce
   end
 
   class Conn
-
     attr_accessor :payload
 
     def new(*args); self; end
@@ -507,7 +537,5 @@ ERROR:  Certificate  is an invalid CA ce
       self.payload = req
       @response
     end
-
   end
-
-end if defined?(OpenSSL::SSL)
+end if Gem::HAVE_OPENSSL
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_request_connection_pools.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_request_connection_pools.rb
@@ -1,18 +1,15 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/request'
-require 'timeout'
+require_relative "helper"
+require "rubygems/request"
+require "timeout"
 
 class TestGemRequestConnectionPool < Gem::TestCase
-
   class FakeHttp
-
     def initialize(*args)
     end
 
     def start
     end
-
   end
 
   def setup
@@ -20,7 +17,7 @@ class TestGemRequestConnectionPool < Gem
     @old_client = Gem::Request::ConnectionPools.client
     Gem::Request::ConnectionPools.client = FakeHttp
 
-    @proxy = URI 'http://proxy.example'
+    @proxy = URI "http://proxy.example"
   end
 
   def teardown
@@ -35,9 +32,9 @@ class TestGemRequestConnectionPool < Gem
       ems.example
     ]
 
-    no_proxy = pools.send :no_proxy?, 'rubygems.example', env_no_proxy
+    no_proxy = pools.send :no_proxy?, "rubygems.example", env_no_proxy
 
-    refute no_proxy, 'mismatch'
+    refute no_proxy, "mismatch"
   end
 
   def test_to_proxy_empty_string
@@ -45,13 +42,13 @@ class TestGemRequestConnectionPool < Gem
 
     env_no_proxy = [""]
 
-    no_proxy = pools.send :no_proxy?, 'ems.example', env_no_proxy
+    no_proxy = pools.send :no_proxy?, "ems.example", env_no_proxy
 
-    refute no_proxy, 'mismatch'
+    refute no_proxy, "mismatch"
   end
 
   def test_checkout_same_connection
-    uri = URI.parse('http://example/some_endpoint')
+    uri = URI.parse("http://example/some_endpoint")
 
     pools = Gem::Request::ConnectionPools.new nil, []
     pool = pools.pool_for uri
@@ -69,13 +66,13 @@ class TestGemRequestConnectionPool < Gem
       2.no-proxy.example
     ]
 
-    no_proxy = pools.send :no_proxy?, '2.no-proxy.example', env_no_proxy
+    no_proxy = pools.send :no_proxy?, "2.no-proxy.example", env_no_proxy
 
-    assert no_proxy, 'match'
+    assert no_proxy, "match"
 
-    no_proxy = pools.send :no_proxy?, 'proxy.example', env_no_proxy
+    no_proxy = pools.send :no_proxy?, "proxy.example", env_no_proxy
 
-    refute no_proxy, 'mismatch'
+    refute no_proxy, "mismatch"
   end
 
   def test_to_proxy_eh_wildcard
@@ -85,31 +82,31 @@ class TestGemRequestConnectionPool < Gem
       .no-proxy.example
     ]
 
-    no_proxy = pools.send :no_proxy?, '2.no-proxy.example', env_no_proxy
+    no_proxy = pools.send :no_proxy?, "2.no-proxy.example", env_no_proxy
 
-    assert no_proxy, 'wildcard matching subdomain'
+    assert no_proxy, "wildcard matching subdomain"
 
-    no_proxy = pools.send :no_proxy?, 'no-proxy.example', env_no_proxy
+    no_proxy = pools.send :no_proxy?, "no-proxy.example", env_no_proxy
 
-    assert no_proxy, 'wildcard matching dotless domain'
+    assert no_proxy, "wildcard matching dotless domain"
 
-    no_proxy = pools.send :no_proxy?, 'proxy.example', env_no_proxy
+    no_proxy = pools.send :no_proxy?, "proxy.example", env_no_proxy
 
-    refute no_proxy, 'wildcard mismatch'
+    refute no_proxy, "wildcard mismatch"
   end
 
   def test_net_http_args
     pools = Gem::Request::ConnectionPools.new nil, []
 
-    net_http_args = pools.send :net_http_args, URI('http://example'), nil
+    net_http_args = pools.send :net_http_args, URI("http://example"), nil
 
-    assert_equal ['example', 80], net_http_args
+    assert_equal ["example", 80], net_http_args
   end
 
   def test_net_http_args_ipv6
     pools = Gem::Request::ConnectionPools.new nil, []
 
-    net_http_args = pools.send :net_http_args, URI('http://[::1]'), nil
+    net_http_args = pools.send :net_http_args, URI("http://[::1]"), nil
 
     assert_equal ["::1", 80], net_http_args
   end
@@ -117,38 +114,37 @@ class TestGemRequestConnectionPool < Gem
   def test_net_http_args_proxy
     pools = Gem::Request::ConnectionPools.new nil, []
 
-    net_http_args = pools.send :net_http_args, URI('http://example'), @proxy
+    net_http_args = pools.send :net_http_args, URI("http://example"), @proxy
 
-    assert_equal ['example', 80, 'proxy.example', 80, nil, nil], net_http_args
+    assert_equal ["example", 80, "proxy.example", 80, nil, nil], net_http_args
   end
 
   def test_net_http_args_no_proxy
-    orig_no_proxy, ENV['no_proxy'] = ENV['no_proxy'], 'example'
+    orig_no_proxy, ENV["no_proxy"] = ENV["no_proxy"], "example"
 
     pools = Gem::Request::ConnectionPools.new nil, []
 
-    net_http_args = pools.send :net_http_args, URI('http://example'), @proxy
+    net_http_args = pools.send :net_http_args, URI("http://example"), @proxy
 
-    assert_equal ['example', 80, nil, nil], net_http_args
+    assert_equal ["example", 80, nil, nil], net_http_args
 
   ensure
-    ENV['no_proxy'] = orig_no_proxy
+    ENV["no_proxy"] = orig_no_proxy
   end
 
   def test_thread_waits_for_connection
-    uri = URI.parse('http://example/some_endpoint')
+    uri = URI.parse("http://example/some_endpoint")
     pools = Gem::Request::ConnectionPools.new nil, []
     pool  = pools.pool_for uri
 
     pool.checkout
 
     Thread.new do
-      assert_raises(Timeout::Error) do
+      assert_raise(Timeout::Error) do
         Timeout.timeout(1) do
           pool.checkout
         end
       end
     end.join
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_request_set.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_request_set.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/request_set'
+require_relative "helper"
+require "rubygems/request_set"
 
 class TestGemRequestSet < Gem::TestCase
-
   def setup
     super
 
@@ -24,24 +23,24 @@ class TestGemRequestSet < Gem::TestCase
   def test_gem_duplicate
     rs = Gem::RequestSet.new
 
-    rs.gem 'a', '1'
-    rs.gem 'a', '2'
+    rs.gem "a", "1"
+    rs.gem "a", "2"
 
-    assert_equal [dep('a', '= 1', '= 2')], rs.dependencies
+    assert_equal [dep("a", "= 1", "= 2")], rs.dependencies
   end
 
   def test_import
     rs = Gem::RequestSet.new
-    rs.gem 'a'
+    rs.gem "a"
 
-    rs.import [dep('b')]
+    rs.import [dep("b")]
 
-    assert_equal [dep('a'), dep('b')], rs.dependencies
+    assert_equal [dep("a"), dep("b")], rs.dependencies
   end
 
   def test_install_from_gemdeps
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     done_installing_ran = false
@@ -53,7 +52,7 @@ class TestGemRequestSet < Gem::TestCase
     rs = Gem::RequestSet.new
     installed = []
 
-    File.open 'gem.deps.rb', 'w' do |io|
+    File.open "gem.deps.rb", "w" do |io|
       io.puts 'gem "a"'
       io.flush
 
@@ -64,9 +63,9 @@ class TestGemRequestSet < Gem::TestCase
       assert_kind_of Array, result # what is supposed to be in here?
     end
 
-    assert_includes installed, 'a-2'
-    assert_path_exists File.join @gemhome, 'gems', 'a-2'
-    assert_path_exists 'gem.deps.rb.lock'
+    assert_includes installed, "a-2"
+    assert_path_exist File.join @gemhome, "gems", "a-2"
+    assert_path_exist "gem.deps.rb.lock"
 
     assert rs.remote
     refute done_installing_ran
@@ -74,12 +73,12 @@ class TestGemRequestSet < Gem::TestCase
 
   def test_install_from_gemdeps_explain
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     rs = Gem::RequestSet.new
 
-    File.open 'gem.deps.rb', 'w' do |io|
+    File.open "gem.deps.rb", "w" do |io|
       io.puts 'gem "a"'
       io.flush
 
@@ -88,29 +87,30 @@ Gems to install:
   a-2
       EXPECTED
 
-      assert_output expected do
+      actual, _ = capture_output do
         rs.install_from_gemdeps :gemdeps => io.path, :explain => true
       end
+      assert_equal(expected, actual)
     end
   end
 
   def test_install_from_gemdeps_install_dir
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     util_clear_gems
-    refute_path_exists File.join Gem.dir, 'gems', 'a-2'
+    assert_path_not_exist File.join Gem.dir, "gems", "a-2"
 
     rs = Gem::RequestSet.new
     installed = []
 
-    File.open 'gem.deps.rb', 'w' do |io|
+    File.open "gem.deps.rb", "w" do |io|
       io.puts 'gem "a"'
     end
 
     options = {
-      :gemdeps     => 'gem.deps.rb',
+      :gemdeps     => "gem.deps.rb",
       :install_dir => "#{@gemhome}2",
     }
 
@@ -118,22 +118,22 @@ Gems to install:
       installed << req.full_name
     end
 
-    assert_includes installed, 'a-2'
-    refute_path_exists File.join Gem.dir, 'gems', 'a-2'
+    assert_includes installed, "a-2"
+    assert_path_not_exist File.join Gem.dir, "gems", "a-2"
   end
 
   def test_install_from_gemdeps_local
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     rs = Gem::RequestSet.new
 
-    File.open 'gem.deps.rb', 'w' do |io|
+    File.open "gem.deps.rb", "w" do |io|
       io.puts 'gem "a"'
       io.flush
 
-      assert_raises Gem::UnsatisfiableDependencyError do
+      assert_raise Gem::UnsatisfiableDependencyError do
         rs.install_from_gemdeps :gemdeps => io.path, :domain => :local
       end
     end
@@ -143,15 +143,15 @@ Gems to install:
 
   def test_install_from_gemdeps_lockfile
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 1
-      fetcher.download 'a', 2
-      fetcher.download 'b', 1, 'a' => '>= 0'
+      fetcher.download "a", 1
+      fetcher.download "a", 2
+      fetcher.download "b", 1, "a" => ">= 0"
     end
 
     rs = Gem::RequestSet.new
     installed = []
 
-    File.open 'gem.deps.rb.lock', 'w' do |io|
+    File.open "gem.deps.rb.lock", "w" do |io|
       io.puts <<-LOCKFILE
 GEM
   remote: #{@gem_repo}
@@ -168,19 +168,19 @@ DEPENDENCIES
       LOCKFILE
     end
 
-    File.open 'gem.deps.rb', 'w' do |io|
+    File.open "gem.deps.rb", "w" do |io|
       io.puts 'gem "b"'
     end
 
-    rs.install_from_gemdeps :gemdeps => 'gem.deps.rb' do |req, installer|
+    rs.install_from_gemdeps :gemdeps => "gem.deps.rb" do |req, installer|
       installed << req.full_name
     end
 
-    assert_includes installed, 'b-1'
-    assert_includes installed, 'a-1'
+    assert_includes installed, "b-1"
+    assert_includes installed, "a-1"
 
-    assert_path_exists File.join @gemhome, 'specifications', 'a-1.gemspec'
-    assert_path_exists File.join @gemhome, 'specifications', 'b-1.gemspec'
+    assert_path_exist File.join @gemhome, "specifications", "a-1.gemspec"
+    assert_path_exist File.join @gemhome, "specifications", "b-1.gemspec"
   end
 
   def test_install_from_gemdeps_complex_dependencies
@@ -197,7 +197,7 @@ DEPENDENCIES
     rs = Gem::RequestSet.new
     installed = []
 
-    File.open 'Gemfile.lock', 'w' do |io|
+    File.open "Gemfile.lock", "w" do |io|
       io.puts <<-LOCKFILE
 GEM
   remote: #{@gem_repo}
@@ -212,7 +212,7 @@ DEPENDENCIES
       LOCKFILE
     end
 
-    File.open 'testo.gemspec', 'w' do |io|
+    File.open "testo.gemspec", "w" do |io|
       io.puts <<-LOCKFILE
 Gem::Specification.new do |spec|
   spec.name = 'testo'
@@ -222,28 +222,28 @@ end
       LOCKFILE
     end
 
-    File.open 'Gemfile', 'w' do |io|
+    File.open "Gemfile", "w" do |io|
       io.puts("gemspec")
     end
 
-    rs.install_from_gemdeps :gemdeps => 'Gemfile' do |req, installer|
+    rs.install_from_gemdeps :gemdeps => "Gemfile" do |req, installer|
       installed << req.full_name
     end
 
-    assert_includes installed, 'z-1.0.3'
+    assert_includes installed, "z-1.0.3"
 
-    assert_path_exists File.join @gemhome, 'specifications', 'z-1.0.3.gemspec'
+    assert_path_exist File.join @gemhome, "specifications", "z-1.0.3.gemspec"
   end
 
   def test_install_from_gemdeps_version_mismatch
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     rs = Gem::RequestSet.new
     installed = []
 
-    File.open 'gem.deps.rb', 'w' do |io|
+    File.open "gem.deps.rb", "w" do |io|
       io.puts <<-GEM_DEPS
 gem "a"
 ruby "0"
@@ -256,13 +256,13 @@ ruby "0"
       end
     end
 
-    assert_includes installed, 'a-2'
+    assert_includes installed, "a-2"
   end
 
   def test_load_gemdeps
     rs = Gem::RequestSet.new
 
-    tf = Tempfile.open 'gem.deps.rb' do |io|
+    tf = Tempfile.open "gem.deps.rb" do |io|
       io.puts 'gem "a"'
       io.flush
 
@@ -273,7 +273,7 @@ ruby "0"
     end
     tf.close!
 
-    assert_equal [dep('a')], rs.dependencies
+    assert_equal [dep("a")], rs.dependencies
 
     assert rs.git_set
     assert rs.vendor_set
@@ -282,7 +282,7 @@ ruby "0"
   def test_load_gemdeps_installing
     rs = Gem::RequestSet.new
 
-    tf = Tempfile.open 'gem.deps.rb' do |io|
+    tf = Tempfile.open "gem.deps.rb" do |io|
       io.puts 'ruby "0"'
       io.puts 'gem "a"'
       io.flush
@@ -294,13 +294,13 @@ ruby "0"
     end
     tf.close!
 
-    assert_equal [dep('a')], rs.dependencies
+    assert_equal [dep("a")], rs.dependencies
   end
 
   def test_load_gemdeps_without_groups
     rs = Gem::RequestSet.new
 
-    tf = Tempfile.open 'gem.deps.rb' do |io|
+    tf = Tempfile.open "gem.deps.rb" do |io|
       io.puts 'gem "a", :group => :test'
       io.flush
 
@@ -324,7 +324,7 @@ ruby "0"
     res = rs.resolve StaticSet.new([a, b])
     assert_equal 2, res.size
 
-    names = res.map { |s| s.full_name }.sort
+    names = res.map {|s| s.full_name }.sort
 
     assert_equal ["a-2", "b-2"], names
 
@@ -332,28 +332,28 @@ ruby "0"
   end
 
   def test_bug_bug_990
-    a = util_spec 'a', '1.b',  'b' => '~> 1.a'
-    b = util_spec 'b', '1.b',  'c' => '>= 1'
-    c = util_spec 'c', '1.1.b'
+    a = util_spec "a", "1.b",  "b" => "~> 1.a"
+    b = util_spec "b", "1.b",  "c" => ">= 1"
+    c = util_spec "c", "1.1.b"
 
     rs = Gem::RequestSet.new
-    rs.gem 'a'
+    rs.gem "a"
     rs.prerelease = true
 
     res = rs.resolve StaticSet.new([a, b, c])
     assert_equal 3, res.size
 
-    names = res.map { |s| s.full_name }.sort
+    names = res.map {|s| s.full_name }.sort
 
     assert_equal %w[a-1.b b-1.b c-1.1.b], names
   end
 
   def test_resolve_development
-    a = util_spec 'a', 1
+    a = util_spec "a", 1
     spec = Gem::Resolver::SpecSpecification.new nil, a
 
     rs = Gem::RequestSet.new
-    rs.gem 'a'
+    rs.gem "a"
     rs.development = true
 
     res = rs.resolve StaticSet.new [spec]
@@ -364,22 +364,22 @@ ruby "0"
   end
 
   def test_resolve_development_shallow
-    a = util_spec 'a', 1 do |s|
-      s.add_development_dependency 'b'
+    a = util_spec "a", 1 do |s|
+      s.add_development_dependency "b"
     end
 
-    b = util_spec 'b', 1 do |s|
-      s.add_development_dependency 'c'
+    b = util_spec "b", 1 do |s|
+      s.add_development_dependency "c"
     end
 
-    c = util_spec 'c', 1
+    c = util_spec "c", 1
 
     a_spec = Gem::Resolver::SpecSpecification.new nil, a
     b_spec = Gem::Resolver::SpecSpecification.new nil, b
     c_spec = Gem::Resolver::SpecSpecification.new nil, c
 
     rs = Gem::RequestSet.new
-    rs.gem 'a'
+    rs.gem "a"
     rs.development = true
     rs.development_shallow = true
 
@@ -395,10 +395,10 @@ ruby "0"
 
     rs = Gem::RequestSet.new
 
-    tf = Tempfile.open 'gem.deps.rb' do |io|
-      io.puts <<-gems_deps_rb
+    tf = Tempfile.open "gem.deps.rb" do |io|
+      io.puts <<-GEMS_DEPS_RB
         gem "#{name}", :git => "#{repository}"
-      gems_deps_rb
+      GEMS_DEPS_RB
 
       io.flush
 
@@ -410,12 +410,12 @@ ruby "0"
     res = rs.resolve
     assert_equal 1, res.size
 
-    names = res.map { |s| s.full_name }.sort
+    names = res.map {|s| s.full_name }.sort
 
     assert_equal %w[a-1], names
 
     assert_equal [@DR::BestSet, @DR::GitSet, @DR::VendorSet, @DR::SourceSet],
-                 rs.sets.map { |set| set.class }
+                 rs.sets.map {|set| set.class }
   end
 
   def test_resolve_ignore_dependencies
@@ -429,40 +429,40 @@ ruby "0"
     res = rs.resolve StaticSet.new([a, b])
     assert_equal 1, res.size
 
-    names = res.map { |s| s.full_name }.sort
+    names = res.map {|s| s.full_name }.sort
 
     assert_equal %w[a-2], names
   end
 
   def test_resolve_incompatible
-    a1 = util_spec 'a', 1
-    a2 = util_spec 'a', 2
+    a1 = util_spec "a", 1
+    a2 = util_spec "a", 2
 
     rs = Gem::RequestSet.new
-    rs.gem 'a', '= 1'
-    rs.gem 'a', '= 2'
+    rs.gem "a", "= 1"
+    rs.gem "a", "= 2"
 
     set = StaticSet.new [a1, a2]
 
-    assert_raises Gem::UnsatisfiableDependencyError do
+    assert_raise Gem::UnsatisfiableDependencyError do
       rs.resolve set
     end
   end
 
   def test_resolve_vendor
-    a_name, _, a_directory = vendor_gem 'a', 1 do |s|
-      s.add_dependency 'b', '~> 2.0'
+    a_name, _, a_directory = vendor_gem "a", 1 do |s|
+      s.add_dependency "b", "~> 2.0"
     end
 
-    b_name, _, b_directory = vendor_gem 'b', 2
+    b_name, _, b_directory = vendor_gem "b", 2
 
     rs = Gem::RequestSet.new
 
-    tf = Tempfile.open 'gem.deps.rb' do |io|
-      io.puts <<-gems_deps_rb
+    tf = Tempfile.open "gem.deps.rb" do |io|
+      io.puts <<-GEMS_DEPS_RB
         gem "#{a_name}", :path => "#{a_directory}"
         gem "#{b_name}", :path => "#{b_directory}"
-      gems_deps_rb
+      GEMS_DEPS_RB
 
       io.flush
 
@@ -474,12 +474,12 @@ ruby "0"
     res = rs.resolve
     assert_equal 2, res.size
 
-    names = res.map { |s| s.full_name }.sort
+    names = res.map {|s| s.full_name }.sort
 
     assert_equal ["a-1", "b-2"], names
 
     assert_equal [@DR::BestSet, @DR::GitSet, @DR::VendorSet, @DR::SourceSet],
-                 rs.sets.map { |set| set.class }
+                 rs.sets.map {|set| set.class }
   end
 
   def test_sorted_requests
@@ -492,8 +492,8 @@ ruby "0"
 
     rs.resolve StaticSet.new([a, b, c])
 
-    names = rs.sorted_requests.map { |s| s.full_name }
-    assert_equal %w!c-2 b-2 a-2!, names
+    names = rs.sorted_requests.map {|s| s.full_name }
+    assert_equal %w[c-2 b-2 a-2], names
   end
 
   def test_install
@@ -509,7 +509,7 @@ ruby "0"
     end
 
     rs = Gem::RequestSet.new
-    rs.gem 'a'
+    rs.gem "a"
 
     rs.resolve
 
@@ -521,14 +521,14 @@ ruby "0"
       installers << installer
     end
 
-    assert_equal %w[b-1 a-1], reqs.map { |req| req.full_name }
+    assert_equal %w[b-1 a-1], reqs.map {|req| req.full_name }
     assert_equal %w[b-1 a-1],
-                 installers.map { |installer| installer.spec.full_name }
+                 installers.map {|installer| installer.spec.full_name }
 
-    assert_path_exists File.join @gemhome, 'specifications', 'a-1.gemspec'
-    assert_path_exists File.join @gemhome, 'specifications', 'b-1.gemspec'
+    assert_path_exist File.join @gemhome, "specifications", "a-1.gemspec"
+    assert_path_exist File.join @gemhome, "specifications", "b-1.gemspec"
 
-    assert_equal %w[b-1 a-1], installed.map { |s| s.full_name }
+    assert_equal %w[b-1 a-1], installed.map {|s| s.full_name }
 
     assert done_installing_ran
   end
@@ -545,32 +545,32 @@ ruby "0"
     rs.resolve
 
     installed = rs.install_into @tempdir do
-      assert_equal @tempdir, ENV['GEM_HOME']
+      assert_equal @tempdir, ENV["GEM_HOME"]
     end
 
-    assert_path_exists File.join @tempdir, 'specifications', 'a-1.gemspec'
-    assert_path_exists File.join @tempdir, 'specifications', 'b-1.gemspec'
+    assert_path_exist File.join @tempdir, "specifications", "a-1.gemspec"
+    assert_path_exist File.join @tempdir, "specifications", "b-1.gemspec"
 
-    assert_equal %w!b-1 a-1!, installed.map { |s| s.full_name }
+    assert_equal %w[b-1 a-1], installed.map {|s| s.full_name }
   end
 
   def test_install_into_development_shallow
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', '1' do |s|
-        s.add_development_dependency 'b', '= 1'
+      fetcher.gem "a", "1" do |s|
+        s.add_development_dependency "b", "= 1"
       end
 
-      fetcher.gem 'b', '1' do |s|
-        s.add_development_dependency 'c', '= 1'
+      fetcher.gem "b", "1" do |s|
+        s.add_development_dependency "c", "= 1"
       end
 
-      fetcher.spec 'c', '1'
+      fetcher.spec "c", "1"
     end
 
     rs = Gem::RequestSet.new
     rs.development         = true
     rs.development_shallow = true
-    rs.gem 'a'
+    rs.gem "a"
 
     rs.resolve
 
@@ -580,25 +580,25 @@ ruby "0"
     }
 
     installed = rs.install_into @tempdir, true, options do
-      assert_equal @tempdir, ENV['GEM_HOME']
+      assert_equal @tempdir, ENV["GEM_HOME"]
     end
 
-    assert_equal %w[a-1 b-1], installed.map { |s| s.full_name }.sort
+    assert_equal %w[a-1 b-1], installed.map {|s| s.full_name }.sort
   end
 
   def test_sorted_requests_development_shallow
-    a = util_spec 'a', 1 do |s|
-      s.add_development_dependency 'b'
+    a = util_spec "a", 1 do |s|
+      s.add_development_dependency "b"
     end
 
-    b = util_spec 'b', 1 do |s|
-      s.add_development_dependency 'c'
+    b = util_spec "b", 1 do |s|
+      s.add_development_dependency "c"
     end
 
-    c = util_spec 'c', 1
+    c = util_spec "c", 1
 
     rs = Gem::RequestSet.new
-    rs.gem 'a'
+    rs.gem "a"
     rs.development = true
     rs.development_shallow = true
 
@@ -608,22 +608,22 @@ ruby "0"
 
     rs.resolve StaticSet.new [a_spec, b_spec, c_spec]
 
-    assert_equal %w[b-1 a-1], rs.sorted_requests.map { |req| req.full_name }
+    assert_equal %w[b-1 a-1], rs.sorted_requests.map {|req| req.full_name }
   end
 
   def test_tsort_each_child_development
-    a = util_spec 'a', 1 do |s|
-      s.add_development_dependency 'b'
+    a = util_spec "a", 1 do |s|
+      s.add_development_dependency "b"
     end
 
-    b = util_spec 'b', 1 do |s|
-      s.add_development_dependency 'c'
+    b = util_spec "b", 1 do |s|
+      s.add_development_dependency "c"
     end
 
-    c = util_spec 'c', 1
+    c = util_spec "c", 1
 
     rs = Gem::RequestSet.new
-    rs.gem 'a'
+    rs.gem "a"
     rs.development = true
     rs.development_shallow = true
 
@@ -637,22 +637,22 @@ ruby "0"
 
     deps = rs.enum_for(:tsort_each_child, a_req).to_a
 
-    assert_equal %w[b], deps.map { |dep| dep.name }
+    assert_equal %w[b], deps.map {|dep| dep.name }
   end
 
   def test_tsort_each_child_development_shallow
-    a = util_spec 'a', 1 do |s|
-      s.add_development_dependency 'b'
+    a = util_spec "a", 1 do |s|
+      s.add_development_dependency "b"
     end
 
-    b = util_spec 'b', 1 do |s|
-      s.add_development_dependency 'c'
+    b = util_spec "b", 1 do |s|
+      s.add_development_dependency "c"
     end
 
-    c = util_spec 'c', 1
+    c = util_spec "c", 1
 
     rs = Gem::RequestSet.new
-    rs.gem 'a'
+    rs.gem "a"
     rs.development = true
     rs.development_shallow = true
 
@@ -668,5 +668,4 @@ ruby "0"
 
     assert_empty deps
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_request_set_gem_dependency_api.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_request_set_gem_dependency_api.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/request_set'
+require_relative "helper"
+require "rubygems/request_set"
 
 class TestGemRequestSetGemDependencyAPI < Gem::TestCase
-
   def setup
     super
 
@@ -14,7 +13,7 @@ class TestGemRequestSetGemDependencyAPI 
     @git_set    = Gem::Resolver::GitSet.new
     @vendor_set = Gem::Resolver::VendorSet.new
 
-    @gda = @GDA.new @set, 'gem.deps.rb'
+    @gda = @GDA.new @set, "gem.deps.rb"
     @gda.instance_variable_set :@git_set,    @git_set
     @gda.instance_variable_set :@vendor_set, @vendor_set
   end
@@ -45,45 +44,45 @@ class TestGemRequestSetGemDependencyAPI 
   end
 
   def test_gempspec_with_multiple_runtime_deps
-    save_gemspec 'foo', '1.0' do |s|
-      s.add_runtime_dependency 'bar', '>= 1.6.0', '< 1.6.4'
+    save_gemspec "foo", "1.0" do |s|
+      s.add_runtime_dependency "bar", ">= 1.6.0", "< 1.6.4"
     end
     @gda.gemspec
-    assert_equal %w{ foo bar }.sort, @set.dependencies.map(&:name).sort
-    bar = @set.dependencies.find { |d| d.name == 'bar' }
-    assert_equal [["<", Gem::Version.create('1.6.4')],
-                  [">=", Gem::Version.create('1.6.0')]], bar.requirement.requirements.sort
+    assert_equal %w[ foo bar ].sort, @set.dependencies.map(&:name).sort
+    bar = @set.dependencies.find {|d| d.name == "bar" }
+    assert_equal [["<", Gem::Version.create("1.6.4")],
+                  [">=", Gem::Version.create("1.6.0")]], bar.requirement.requirements.sort
   end
 
   def test_gemspec_without_group
-    @gda.send :add_dependencies, [:development], [dep('a', '= 1')]
+    @gda.send :add_dependencies, [:development], [dep("a", "= 1")]
 
-    assert_equal [dep('a', '= 1')], @set.dependencies
+    assert_equal [dep("a", "= 1")], @set.dependencies
 
     @gda.without_groups << :development
 
-    @gda.send :add_dependencies, [:development], [dep('b', '= 2')]
+    @gda.send :add_dependencies, [:development], [dep("b", "= 2")]
 
-    assert_equal [dep('a', '= 1')], @set.dependencies
+    assert_equal [dep("a", "= 1")], @set.dependencies
   end
 
   def test_gem
-    @gda.gem 'a'
+    @gda.gem "a"
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
-    assert_equal %w[a], @gda.requires['a']
+    assert_equal %w[a], @gda.requires["a"]
 
-    expected = { 'a' => Gem::Requirement.default }
+    expected = { "a" => Gem::Requirement.default }
 
     assert_equal expected, @gda.dependencies
   end
 
   def test_gem_duplicate
-    @gda.gem 'a'
+    @gda.gem "a"
 
-    _, err = capture_io do
-      @gda.gem 'a'
+    _, err = capture_output do
+      @gda.gem "a"
     end
 
     expected = "Gem dependencies file gem.deps.rb requires a more than once."
@@ -92,141 +91,141 @@ class TestGemRequestSetGemDependencyAPI 
   end
 
   def test_gem_git
-    @gda.gem 'a', :git => 'git/a'
+    @gda.gem "a", :git => "git/a"
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
-    assert_equal %w[git/a master], @git_set.repositories['a']
+    assert_equal %w[git/a master], @git_set.repositories["a"]
 
-    expected = { 'a' => Gem::Requirement.create('!') }
+    expected = { "a" => Gem::Requirement.create("!") }
 
     assert_equal expected, @gda.dependencies
   end
 
   def test_gem_bitbucket
-    @gda.gem 'a', :bitbucket => 'example/repository'
+    @gda.gem "a", :bitbucket => "example/repository"
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
     assert_equal %w[https://example@bitbucket.org/example/repository.git master],
-                 @git_set.repositories['a']
+                 @git_set.repositories["a"]
 
-    expected = { 'a' => Gem::Requirement.create('!') }
+    expected = { "a" => Gem::Requirement.create("!") }
 
     assert_equal expected, @gda.dependencies
   end
 
   def test_gem_bitbucket_expand_path
-    @gda.gem 'a', :bitbucket => 'example'
+    @gda.gem "a", :bitbucket => "example"
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
     assert_equal %w[https://example@bitbucket.org/example/example.git master],
-                 @git_set.repositories['a']
+                 @git_set.repositories["a"]
 
-    expected = { 'a' => Gem::Requirement.create('!') }
+    expected = { "a" => Gem::Requirement.create("!") }
 
     assert_equal expected, @gda.dependencies
   end
 
   def test_gem_git_branch
-    _, err = capture_io do
-      @gda.gem 'a', :git => 'git/a', :branch => 'other', :tag => 'v1'
+    _, err = capture_output do
+      @gda.gem "a", :git => "git/a", :branch => "other", :tag => "v1"
     end
     expected = "Gem dependencies file gem.deps.rb includes git reference for both ref/branch and tag but only ref/branch is used."
     assert_match expected, err
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
-    assert_equal %w[git/a other], @git_set.repositories['a']
+    assert_equal %w[git/a other], @git_set.repositories["a"]
   end
 
   def test_gem_git_gist
-    @gda.gem 'a', :gist => 'a'
+    @gda.gem "a", :gist => "a"
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
     assert_equal %w[https://gist.github.com/a.git master],
-                 @git_set.repositories['a']
+                 @git_set.repositories["a"]
   end
 
   def test_gem_git_ref
-    _, err = capture_io do
-      @gda.gem 'a', :git => 'git/a', :ref => 'abcd123', :branch => 'other'
+    _, err = capture_output do
+      @gda.gem "a", :git => "git/a", :ref => "abcd123", :branch => "other"
     end
     expected = "Gem dependencies file gem.deps.rb includes git reference for both ref and branch but only ref is used."
     assert_match expected, err
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
-    assert_equal %w[git/a abcd123], @git_set.repositories['a']
+    assert_equal %w[git/a abcd123], @git_set.repositories["a"]
   end
 
   def test_gem_git_submodules
-    @gda.gem 'a', :git => 'git/a', :submodules => true
+    @gda.gem "a", :git => "git/a", :submodules => true
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
-    assert_equal %w[git/a master], @git_set.repositories['a']
+    assert_equal %w[git/a master], @git_set.repositories["a"]
     assert_equal %w[git/a], @git_set.need_submodules.keys
   end
 
   def test_gem_git_tag
-    @gda.gem 'a', :git => 'git/a', :tag => 'v1'
+    @gda.gem "a", :git => "git/a", :tag => "v1"
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
-    assert_equal %w[git/a v1], @git_set.repositories['a']
+    assert_equal %w[git/a v1], @git_set.repositories["a"]
   end
 
   def test_gem_github
-    @gda.gem 'a', :github => 'example/repository'
+    @gda.gem "a", :github => "example/repository"
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
     assert_equal %w[git://github.com/example/repository.git master],
-                 @git_set.repositories['a']
+                 @git_set.repositories["a"]
 
-    expected = { 'a' => Gem::Requirement.create('!') }
+    expected = { "a" => Gem::Requirement.create("!") }
 
     assert_equal expected, @gda.dependencies
   end
 
   def test_gem_github_expand_path
-    @gda.gem 'a', :github => 'example'
+    @gda.gem "a", :github => "example"
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
     assert_equal %w[git://github.com/example/example.git master],
-                 @git_set.repositories['a']
+                 @git_set.repositories["a"]
 
-    expected = { 'a' => Gem::Requirement.create('!') }
+    expected = { "a" => Gem::Requirement.create("!") }
 
     assert_equal expected, @gda.dependencies
   end
 
   def test_gem_group
-    @gda.gem 'a', :group => :test
+    @gda.gem "a", :group => :test
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
   end
 
   def test_gem_group_without
     @gda.without_groups << :test
 
-    @gda.gem 'a', :group => :test
+    @gda.gem "a", :group => :test
 
     assert_empty @set.dependencies
 
-    expected = { 'a' => Gem::Requirement.default }
+    expected = { "a" => Gem::Requirement.default }
 
     assert_equal expected, @gda.dependencies
   end
 
   def test_gem_groups
-    @gda.gem 'a', :groups => [:test, :development]
+    @gda.gem "a", :groups => [:test, :development]
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
   end
 
   def test_gem_path
@@ -240,7 +239,7 @@ class TestGemRequestSetGemDependencyAPI 
 
     assert_equal "#{name}-#{version}", loaded.full_name
 
-    expected = { name => Gem::Requirement.create('!') }
+    expected = { name => Gem::Requirement.create("!") }
 
     assert_equal expected, @gda.dependencies
   end
@@ -248,8 +247,8 @@ class TestGemRequestSetGemDependencyAPI 
   def test_gem_platforms
     win_platform, Gem.win_platform = Gem.win_platform?, false
 
-    with_engine_version 'ruby', '2.0.0' do
-      @gda.gem 'a', :platforms => :ruby
+    with_engine_version "ruby", "2.0.0" do
+      @gda.gem "a", :platforms => :ruby
 
       refute_empty @set.dependencies
     end
@@ -260,44 +259,44 @@ class TestGemRequestSetGemDependencyAPI 
   def test_gem_platforms_bundler_ruby
     win_platform, Gem.win_platform = Gem.win_platform?, false
 
-    with_engine_version 'ruby', '2.0.0' do
+    with_engine_version "ruby", "2.0.0" do
       set = Gem::RequestSet.new
-      gda = @GDA.new set, 'gem.deps.rb'
-      gda.gem 'a', :platforms => :ruby
+      gda = @GDA.new set, "gem.deps.rb"
+      gda.gem "a", :platforms => :ruby
 
       refute_empty set.dependencies
     end
 
-    with_engine_version 'rbx', '2.0.0' do
+    with_engine_version "rbx", "2.0.0" do
       set = Gem::RequestSet.new
-      gda = @GDA.new set, 'gem.deps.rb'
-      gda.gem 'a', :platforms => :ruby
+      gda = @GDA.new set, "gem.deps.rb"
+      gda.gem "a", :platforms => :ruby
 
       refute_empty set.dependencies
     end
 
-    with_engine_version 'truffleruby', '2.0.0' do
+    with_engine_version "truffleruby", "2.0.0" do
       set = Gem::RequestSet.new
-      gda = @GDA.new set, 'gem.deps.rb'
-      gda.gem 'a', :platforms => :ruby
+      gda = @GDA.new set, "gem.deps.rb"
+      gda.gem "a", :platforms => :ruby
 
       refute_empty set.dependencies
     end
 
-    with_engine_version 'jruby', '1.7.6' do
+    with_engine_version "jruby", "1.7.6" do
       set = Gem::RequestSet.new
-      gda = @GDA.new set, 'gem.deps.rb'
-      gda.gem 'a', :platforms => :ruby
+      gda = @GDA.new set, "gem.deps.rb"
+      gda.gem "a", :platforms => :ruby
 
       assert_empty set.dependencies
     end
 
     Gem.win_platform = true
 
-    with_engine_version 'ruby', '2.0.0' do
+    with_engine_version "ruby", "2.0.0" do
       set = Gem::RequestSet.new
-      gda = @GDA.new set, 'gem.deps.rb'
-      gda.gem 'a', :platforms => :ruby
+      gda = @GDA.new set, "gem.deps.rb"
+      gda.gem "a", :platforms => :ruby
 
       assert_empty set.dependencies
     end
@@ -306,14 +305,14 @@ class TestGemRequestSetGemDependencyAPI 
   end
 
   def test_gem_platforms_engine
-    with_engine_version 'jruby', '1.7.6' do
-      @gda.gem 'a', :platforms => :mri
+    with_engine_version "jruby", "1.7.6" do
+      @gda.gem "a", :platforms => :mri
 
       assert_empty @set.dependencies
     end
 
-    with_engine_version 'truffleruby', '1.2.3' do
-      @gda.gem 'a', :platforms => :mri
+    with_engine_version "truffleruby", "1.2.3" do
+      @gda.gem "a", :platforms => :mri
 
       assert_empty @set.dependencies
     end
@@ -322,16 +321,16 @@ class TestGemRequestSetGemDependencyAPI 
   def test_gem_platforms_maglev
     win_platform, Gem.win_platform = Gem.win_platform?, false
 
-    with_engine_version 'maglev', '1.0.0' do
+    with_engine_version "maglev", "1.0.0" do
       set = Gem::RequestSet.new
-      gda = @GDA.new set, 'gem.deps.rb'
-      gda.gem 'a', :platforms => :ruby
+      gda = @GDA.new set, "gem.deps.rb"
+      gda.gem "a", :platforms => :ruby
 
       refute_empty set.dependencies
 
       set = Gem::RequestSet.new
-      gda = @GDA.new set, 'gem.deps.rb'
-      gda.gem 'a', :platforms => :maglev
+      gda = @GDA.new set, "gem.deps.rb"
+      gda.gem "a", :platforms => :maglev
 
       refute_empty set.dependencies
     end
@@ -340,16 +339,16 @@ class TestGemRequestSetGemDependencyAPI 
   end
 
   def test_gem_platforms_truffleruby
-    with_engine_version 'truffleruby', '1.0.0' do
+    with_engine_version "truffleruby", "1.0.0" do
       set = Gem::RequestSet.new
-      gda = @GDA.new set, 'gem.deps.rb'
-      gda.gem 'a', :platforms => :truffleruby
+      gda = @GDA.new set, "gem.deps.rb"
+      gda.gem "a", :platforms => :truffleruby
 
       refute_empty set.dependencies
 
       set = Gem::RequestSet.new
-      gda = @GDA.new set, 'gem.deps.rb'
-      gda.gem 'a', :platforms => :maglev
+      gda = @GDA.new set, "gem.deps.rb"
+      gda.gem "a", :platforms => :maglev
 
       assert_empty set.dependencies
     end
@@ -358,8 +357,8 @@ class TestGemRequestSetGemDependencyAPI 
   def test_gem_platforms_multiple
     win_platform, Gem.win_platform = Gem.win_platform?, false
 
-    with_engine_version 'ruby', '2.0.0' do
-      @gda.gem 'a', :platforms => [:mswin, :jruby]
+    with_engine_version "ruby", "2.0.0" do
+      @gda.gem "a", :platforms => [:mswin, :jruby]
 
       assert_empty @set.dependencies
     end
@@ -371,8 +370,8 @@ class TestGemRequestSetGemDependencyAPI 
   def test_gem_platforms_platform
     win_platform, Gem.win_platform = Gem.win_platform?, false
 
-    with_engine_version 'ruby', '2.0.0' do
-      @gda.gem 'a', :platforms => :jruby, :platform => :ruby
+    with_engine_version "ruby", "2.0.0" do
+      @gda.gem "a", :platforms => :jruby, :platform => :ruby
 
       refute_empty @set.dependencies
     end
@@ -381,35 +380,35 @@ class TestGemRequestSetGemDependencyAPI 
   end
 
   def test_gem_platforms_version
-    with_engine_version 'ruby', '2.0.0' do
-      @gda.gem 'a', :platforms => :ruby_18
+    with_engine_version "ruby", "2.0.0" do
+      @gda.gem "a", :platforms => :ruby_18
 
       assert_empty @set.dependencies
     end
   end
 
   def test_gem_platforms_unknown
-    e = assert_raises ArgumentError do
-      @gda.gem 'a', :platforms => :unknown
+    e = assert_raise ArgumentError do
+      @gda.gem "a", :platforms => :unknown
     end
 
-    assert_equal 'unknown platform :unknown', e.message
+    assert_equal "unknown platform :unknown", e.message
   end
 
   def test_gem_requires
-    @gda.gem 'a', :require => %w[b c]
-    @gda.gem 'd', :require => 'e'
+    @gda.gem "a", :require => %w[b c]
+    @gda.gem "d", :require => "e"
 
-    assert_equal [dep('a'), dep('d')], @set.dependencies
+    assert_equal [dep("a"), dep("d")], @set.dependencies
 
-    assert_equal %w[b c], @gda.requires['a']
-    assert_equal %w[e],   @gda.requires['d']
+    assert_equal %w[b c], @gda.requires["a"]
+    assert_equal %w[e],   @gda.requires["d"]
   end
 
   def test_gem_requires_false
-    @gda.gem 'a', :require => false
+    @gda.gem "a", :require => false
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
     assert_empty @gda.requires
   end
@@ -417,37 +416,37 @@ class TestGemRequestSetGemDependencyAPI 
   def test_gem_requires_without_group
     @gda.without_groups << :test
 
-    @gda.gem 'a', :group => :test
+    @gda.gem "a", :group => :test
 
     assert_empty @set.dependencies
 
-    assert_empty @gda.requires['a']
+    assert_empty @gda.requires["a"]
   end
 
   def test_gem_requirement
-    @gda.gem 'a', '~> 1.0'
+    @gda.gem "a", "~> 1.0"
 
-    assert_equal [dep('a', '~> 1.0')], @set.dependencies
+    assert_equal [dep("a", "~> 1.0")], @set.dependencies
 
-    expected = { 'a' => Gem::Requirement.create(['~> 1.0']) }
+    expected = { "a" => Gem::Requirement.create(["~> 1.0"]) }
 
     assert_equal expected, @gda.dependencies
   end
 
   def test_gem_requirements
-    @gda.gem 'b', '~> 1.0', '>= 1.0.2'
+    @gda.gem "b", "~> 1.0", ">= 1.0.2"
 
-    assert_equal [dep('b', '~> 1.0', '>= 1.0.2')], @set.dependencies
+    assert_equal [dep("b", "~> 1.0", ">= 1.0.2")], @set.dependencies
 
-    expected = { 'b' => Gem::Requirement.create(['~> 1.0', '>= 1.0.2']) }
+    expected = { "b" => Gem::Requirement.create(["~> 1.0", ">= 1.0.2"]) }
 
     assert_equal expected, @gda.dependencies
   end
 
   def test_gem_requirements_options
-    @gda.gem 'c', :git => 'https://example/c.git'
+    @gda.gem "c", :git => "https://example/c.git"
 
-    assert_equal [dep('c')], @set.dependencies
+    assert_equal [dep("c")], @set.dependencies
   end
 
   def test_gem_source_mismatch
@@ -456,7 +455,7 @@ class TestGemRequestSetGemDependencyAPI 
     gda = @GDA.new @set, nil
     gda.gem name
 
-    e = assert_raises ArgumentError do
+    e = assert_raise ArgumentError do
       gda.gem name, :path => directory
     end
 
@@ -467,7 +466,7 @@ class TestGemRequestSetGemDependencyAPI 
     gda.instance_variable_set :@vendor_set, @vendor_set
     gda.gem name, :path => directory
 
-    e = assert_raises ArgumentError do
+    e = assert_raise ArgumentError do
       gda.gem name
     end
 
@@ -476,82 +475,82 @@ class TestGemRequestSetGemDependencyAPI 
   end
 
   def test_gem_deps_file
-    assert_equal 'gem.deps.rb', @gda.gem_deps_file
+    assert_equal "gem.deps.rb", @gda.gem_deps_file
 
-    gda = @GDA.new @set, 'foo/Gemfile'
+    gda = @GDA.new @set, "foo/Gemfile"
 
-    assert_equal 'Gemfile', gda.gem_deps_file
+    assert_equal "Gemfile", gda.gem_deps_file
   end
 
   def test_gem_group_method
     groups = []
 
     @gda.group :a do
-      groups = @gda.send :gem_group, 'a', :group => :b, :groups => [:c, :d]
+      groups = @gda.send :gem_group, "a", :group => :b, :groups => [:c, :d]
     end
 
-    assert_equal [:a, :b, :c, :d], groups.sort_by { |group| group.to_s }
+    assert_equal [:a, :b, :c, :d], groups.sort_by {|group| group.to_s }
   end
 
   def test_gemspec
-    save_gemspec 'a', 1 do |s|
-      s.add_dependency 'b', 2
-      s.add_development_dependency 'c', 3
+    save_gemspec "a", 1 do |s|
+      s.add_dependency "b", 2
+      s.add_development_dependency "c", 3
     end
 
     @gda.gemspec
 
-    assert_equal [dep('a', '= 1'), dep('b', '= 2'), dep('c', '=3')],
+    assert_equal [dep("a", "= 1"), dep("b", "= 2"), dep("c", "=3")],
                  @set.dependencies
 
-    assert_equal %w[a], @gda.requires['a']
+    assert_equal %w[a], @gda.requires["a"]
 
     expected = {
-      'a' => Gem::Requirement.create('!'),
-      'b' => req('= 2'),
-      'c' => req('= 3'),
+      "a" => Gem::Requirement.create("!"),
+      "b" => req("= 2"),
+      "c" => req("= 3"),
     }
 
     assert_equal expected, @gda.dependencies
   end
 
   def test_gemspec_bad
-    FileUtils.touch 'a.gemspec'
+    FileUtils.touch "a.gemspec"
 
-    e = assert_raises ArgumentError do
-      capture_io do
+    e = assert_raise ArgumentError do
+      capture_output do
         @gda.gemspec
       end
     end
 
-    assert_equal 'invalid gemspec ./a.gemspec', e.message
+    assert_equal "invalid gemspec ./a.gemspec", e.message
   end
 
   def test_gemspec_development_group
-    save_gemspec 'a', 1 do |s|
-      s.add_dependency 'b', 2
-      s.add_development_dependency 'c', 3
+    save_gemspec "a", 1 do |s|
+      s.add_dependency "b", 2
+      s.add_development_dependency "c", 3
     end
 
     @gda.without_groups << :other
 
     @gda.gemspec :development_group => :other
 
-    assert_equal [dep('a', '= 1'), dep('b', '= 2')], @set.dependencies
+    assert_equal [dep("a", "= 1"), dep("b", "= 2")], @set.dependencies
 
-    assert_equal %w[a], @gda.requires['a']
+    assert_equal %w[a], @gda.requires["a"]
   end
 
   def test_gemspec_multiple
-    save_gemspec 'a', 1 do |s|
-      s.add_dependency 'b', 2
+    save_gemspec "a", 1 do |s|
+      s.add_dependency "b", 2
     end
 
-    save_gemspec 'b', 2 do |s|
-      s.add_dependency 'c', 3
+    save_gemspec "b", 2 do |s|
+      s.add_dependency "c", 3
     end
 
-    e = assert_raises ArgumentError do
+    e = assert_raise ArgumentError do
       @gda.gemspec
     end
 
@@ -559,31 +558,31 @@ class TestGemRequestSetGemDependencyAPI 
   end
 
   def test_gemspec_name
-    save_gemspec 'a', 1 do |s|
-      s.add_dependency 'b', 2
+    save_gemspec "a", 1 do |s|
+      s.add_dependency "b", 2
     end
 
-    save_gemspec 'b', 2 do |s|
-      s.add_dependency 'c', 3
+    save_gemspec "b", 2 do |s|
+      s.add_dependency "c", 3
     end
 
-    @gda.gemspec :name => 'b'
+    @gda.gemspec :name => "b"
 
-    assert_equal [dep('b', '= 2'), dep('c', '= 3')], @set.dependencies
+    assert_equal [dep("b", "= 2"), dep("c", "= 3")], @set.dependencies
   end
 
   def test_gemspec_named
-    save_gemspec 'a', 1 do |s|
-      s.add_dependency 'b', 2
+    save_gemspec "a", 1 do |s|
+      s.add_dependency "b", 2
     end
 
     @gda.gemspec
 
-    assert_equal [dep('a', '= 1'), dep('b', '= 2')], @set.dependencies
+    assert_equal [dep("a", "= 1"), dep("b", "= 2")], @set.dependencies
   end
 
   def test_gemspec_none
-    e = assert_raises ArgumentError do
+    e = assert_raise ArgumentError do
       @gda.gemspec
     end
 
@@ -591,27 +590,27 @@ class TestGemRequestSetGemDependencyAPI 
   end
 
   def test_gemspec_path
-    FileUtils.mkdir 'other'
+    FileUtils.mkdir "other"
 
-    save_gemspec 'a', 1, 'other' do |s|
-      s.add_dependency 'b', 2
+    save_gemspec "a", 1, "other" do |s|
+      s.add_dependency "b", 2
     end
 
-    @gda.gemspec :path => 'other'
+    @gda.gemspec :path => "other"
 
-    assert_equal [dep('a', '= 1'), dep('b', '= 2')], @set.dependencies
+    assert_equal [dep("a", "= 1"), dep("b", "= 2")], @set.dependencies
   end
 
   def test_git
-    @gda.git 'git://example/repo.git' do
-      @gda.gem 'a'
-      @gda.gem 'b'
+    @gda.git "git://example/repo.git" do
+      @gda.gem "a"
+      @gda.gem "b"
     end
 
-    assert_equal [dep('a'), dep('b')], @set.dependencies
+    assert_equal [dep("a"), dep("b")], @set.dependencies
 
-    assert_equal %w[git://example/repo.git master], @git_set.repositories['a']
-    assert_equal %w[git://example/repo.git master], @git_set.repositories['b']
+    assert_equal %w[git://example/repo.git master], @git_set.repositories["a"]
+    assert_equal %w[git://example/repo.git master], @git_set.repositories["b"]
   end
 
   def test_git_source
@@ -619,21 +618,21 @@ class TestGemRequestSetGemDependencyAPI 
       "git://example/#{repo_name}.git"
     end
 
-    @gda.gem 'a', :example => 'repo'
+    @gda.gem "a", :example => "repo"
 
-    assert_equal %w[git://example/repo.git master], @git_set.repositories['a']
+    assert_equal %w[git://example/repo.git master], @git_set.repositories["a"]
   end
 
   def test_group
     @gda.group :test do
-      @gda.gem 'a'
+      @gda.gem "a"
     end
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
   end
 
   def test_load
-    tf = Tempfile.open 'gem.deps.rb' do |io|
+    tf = Tempfile.open "gem.deps.rb" do |io|
       io.write <<-GEM_DEPS
 gem 'a'
 
@@ -647,7 +646,7 @@ end
 
       assert_equal gda, gda.load
 
-      assert_equal [dep('a'), dep('b')], @set.dependencies
+      assert_equal [dep("a"), dep("b")], @set.dependencies
       io
     end
     tf.close!
@@ -656,18 +655,18 @@ end
   def test_pin_gem_source
     gda = @GDA.new @set, nil
 
-    gda.send :pin_gem_source, 'a'
-    gda.send :pin_gem_source, 'a'
+    gda.send :pin_gem_source, "a"
+    gda.send :pin_gem_source, "a"
 
-    e = assert_raises ArgumentError do
-      gda.send :pin_gem_source, 'a', :path, 'vendor/a'
+    e = assert_raise ArgumentError do
+      gda.send :pin_gem_source, "a", :path, "vendor/a"
     end
 
     assert_equal "duplicate source path: vendor/a for gem a",
                  e.message
 
-    e = assert_raises ArgumentError do
-      gda.send :pin_gem_source, 'a', :git, 'git://example/repo.git'
+    e = assert_raise ArgumentError do
+      gda.send :pin_gem_source, "a", :git, "git://example/repo.git"
     end
 
     assert_equal "duplicate source git: git://example/repo.git for gem a",
@@ -676,18 +675,18 @@ end
 
   def test_platform_mswin
     if win_platform?
-      util_set_arch 'x86-mswin32-60' do
+      util_set_arch "x86-mswin32-60" do
         @gda.platform :mswin do
-          @gda.gem 'a'
+          @gda.gem "a"
         end
 
-        assert_equal [dep('a')], @set.dependencies
+        assert_equal [dep("a")], @set.dependencies
         refute_empty @set.dependencies
       end
     else
-      util_set_arch 'i686-darwin8.10.1' do
+      util_set_arch "i686-darwin8.10.1" do
         @gda.platform :mswin do
-          @gda.gem 'a'
+          @gda.gem "a"
         end
 
         assert_empty @set.dependencies
@@ -700,9 +699,9 @@ end
 
     gda = @GDA.new @set, nil
 
-    with_engine_version 'ruby', '1.8.7' do
+    with_engine_version "ruby", "1.8.7" do
       gda.platform :mri_19, :mri_20 do
-        gda.gem 'a'
+        gda.gem "a"
       end
     end
 
@@ -710,9 +709,9 @@ end
 
     gda = @GDA.new @set, nil
 
-    with_engine_version 'ruby', '2.0.0' do
+    with_engine_version "ruby", "2.0.0" do
       gda.platform :mri_19, :mri_20 do
-        gda.gem 'a'
+        gda.gem "a"
       end
     end
 
@@ -725,28 +724,28 @@ end
     win_platform, Gem.win_platform = Gem.win_platform?, false
 
     @gda.platform :ruby do
-      @gda.gem 'a'
+      @gda.gem "a"
     end
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
   ensure
     Gem.win_platform = win_platform
   end
 
   def test_platforms
     unless win_platform?
-      util_set_arch 'i686-darwin8.10.1' do
+      util_set_arch "i686-darwin8.10.1" do
         @gda.platforms :ruby do
-          @gda.gem 'a'
+          @gda.gem "a"
         end
 
-        assert_equal [dep('a')], @set.dependencies
+        assert_equal [dep("a")], @set.dependencies
 
         @gda.platforms :mswin do
-          @gda.gem 'b'
+          @gda.gem "b"
         end
 
-        assert_equal [dep('a')], @set.dependencies
+        assert_equal [dep("a")], @set.dependencies
       end
     end
   end
@@ -756,53 +755,51 @@ end
   end
 
   def test_ruby_engine
-    with_engine_version 'jruby', '1.7.6' do
+    with_engine_version "jruby", "1.7.6" do
       assert @gda.ruby RUBY_VERSION,
-               :engine => 'jruby', :engine_version => '1.7.6'
-
+               :engine => "jruby", :engine_version => "1.7.6"
     end
 
-    with_engine_version 'truffleruby', '1.0.0-rc11' do
+    with_engine_version "truffleruby", "1.0.0-rc11" do
       assert @gda.ruby RUBY_VERSION,
-               :engine => 'truffleruby', :engine_version => '1.0.0-rc11'
-
+               :engine => "truffleruby", :engine_version => "1.0.0-rc11"
     end
   end
 
   def test_ruby_engine_mismatch_engine
-    with_engine_version 'ruby', '2.0.0' do
-      e = assert_raises Gem::RubyVersionMismatch do
-        @gda.ruby RUBY_VERSION, :engine => 'jruby', :engine_version => '1.7.4'
+    with_engine_version "ruby", "2.0.0" do
+      e = assert_raise Gem::RubyVersionMismatch do
+        @gda.ruby RUBY_VERSION, :engine => "jruby", :engine_version => "1.7.4"
       end
 
-      assert_equal 'Your Ruby engine is ruby, but your gem.deps.rb requires jruby',
+      assert_equal "Your Ruby engine is ruby, but your gem.deps.rb requires jruby",
                    e.message
     end
   end
 
   def test_ruby_engine_mismatch_version
-    with_engine_version 'jruby', '1.7.6' do
-      e = assert_raises Gem::RubyVersionMismatch do
-        @gda.ruby RUBY_VERSION, :engine => 'jruby', :engine_version => '1.7.4'
+    with_engine_version "jruby", "1.7.6" do
+      e = assert_raise Gem::RubyVersionMismatch do
+        @gda.ruby RUBY_VERSION, :engine => "jruby", :engine_version => "1.7.4"
       end
 
-      assert_equal 'Your Ruby engine version is jruby 1.7.6, but your gem.deps.rb requires jruby 1.7.4',
+      assert_equal "Your Ruby engine version is jruby 1.7.6, but your gem.deps.rb requires jruby 1.7.4",
                    e.message
     end
   end
 
   def test_ruby_engine_no_engine_version
-    e = assert_raises ArgumentError do
-      @gda.ruby RUBY_VERSION, :engine => 'jruby'
+    e = assert_raise ArgumentError do
+      @gda.ruby RUBY_VERSION, :engine => "jruby"
     end
 
-    assert_equal 'You must specify engine_version along with the Ruby engine',
+    assert_equal "You must specify engine_version along with the Ruby engine",
                  e.message
   end
 
   def test_ruby_mismatch
-    e = assert_raises Gem::RubyVersionMismatch do
-      @gda.ruby '1.8.0'
+    e = assert_raise Gem::RubyVersionMismatch do
+      @gda.ruby "1.8.0"
     end
 
     assert_equal "Your Ruby version is #{RUBY_VERSION}, but your gem.deps.rb requires 1.8.0", e.message
@@ -811,19 +808,19 @@ end
   def test_ruby_mismatch_installing
     @gda.installing = true
 
-    assert @gda.ruby '1.8.0'
+    assert @gda.ruby "1.8.0"
   end
 
   def test_source
     sources = Gem.sources
 
-    @gda.source 'http://first.example'
+    @gda.source "http://first.example"
 
     assert_equal %w[http://first.example], Gem.sources
 
     assert_same sources, Gem.sources
 
-    @gda.source 'http://second.example'
+    @gda.source "http://second.example"
 
     assert_equal %w[http://first.example http://second.example], Gem.sources
   end
@@ -833,9 +830,9 @@ end
     engine = Gem.ruby_engine
     engine_version = RUBY_ENGINE_VERSION
 
-    with_engine_version 'other', '1.2.3' do
-      assert_equal 'other', Gem.ruby_engine
-      assert_equal '1.2.3', RUBY_ENGINE_VERSION
+    with_engine_version "other", "1.2.3" do
+      assert_equal "other", Gem.ruby_engine
+      assert_equal "1.2.3", RUBY_ENGINE_VERSION
 
       assert_equal version, RUBY_VERSION
     end
@@ -845,5 +842,4 @@ end
 
     assert_equal engine_version, RUBY_ENGINE_VERSION if engine
   end
-
 end unless Gem.java_platform?
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_request_set_lockfile.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_request_set_lockfile.rb
@@ -1,16 +1,15 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/request_set'
-require 'rubygems/request_set/lockfile'
+require_relative "helper"
+require "rubygems/request_set"
+require "rubygems/request_set/lockfile"
 
 class TestGemRequestSetLockfile < Gem::TestCase
-
   def setup
     super
 
     Gem::RemoteFetcher.fetcher = @fetcher = Gem::FakeFetcher.new
 
-    util_set_arch 'i686-darwin8.10.1'
+    util_set_arch "i686-darwin8.10.1"
 
     @set = Gem::RequestSet.new
 
@@ -20,7 +19,7 @@ class TestGemRequestSetLockfile < Gem::T
     @set.instance_variable_set :@git_set,    @git_set
     @set.instance_variable_set :@vendor_set, @vendor_set
 
-    @gem_deps_file = 'gem.deps.rb'
+    @gem_deps_file = "gem.deps.rb"
   end
 
   def lockfile
@@ -30,19 +29,19 @@ class TestGemRequestSetLockfile < Gem::T
   def write_lockfile(lockfile)
     @lock_file = File.expand_path "#{@gem_deps_file}.lock"
 
-    File.open @lock_file, 'w' do |io|
+    File.open @lock_file, "w" do |io|
       io.write lockfile
     end
   end
 
   def test_add_DEPENDENCIES
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2 do |s|
-        s.add_development_dependency 'b'
+      fetcher.spec "a", 2 do |s|
+        s.add_development_dependency "b"
       end
     end
 
-    @set.gem 'a'
+    @set.gem "a"
     @set.resolve
 
     out = []
@@ -50,9 +49,9 @@ class TestGemRequestSetLockfile < Gem::T
     lockfile.add_DEPENDENCIES out
 
     expected = [
-      'DEPENDENCIES',
-      '  a',
-      nil
+      "DEPENDENCIES",
+      "  a",
+      nil,
     ]
 
     assert_equal expected, out
@@ -60,14 +59,14 @@ class TestGemRequestSetLockfile < Gem::T
 
   def test_add_DEPENDENCIES_from_gem_deps
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2 do |s|
-        s.add_development_dependency 'b'
+      fetcher.spec "a", 2 do |s|
+        s.add_development_dependency "b"
       end
     end
 
-    dependencies = { 'a' => Gem::Requirement.new('~> 2.0') }
+    dependencies = { "a" => Gem::Requirement.new("~> 2.0") }
 
-    @set.gem 'a'
+    @set.gem "a"
     @set.resolve
     @lockfile =
       Gem::RequestSet::Lockfile.new @set, @gem_deps_file, dependencies
@@ -77,9 +76,9 @@ class TestGemRequestSetLockfile < Gem::T
     @lockfile.add_DEPENDENCIES out
 
     expected = [
-      'DEPENDENCIES',
-      '  a (~> 2.0)',
-      nil
+      "DEPENDENCIES",
+      "  a (~> 2.0)",
+      nil,
     ]
 
     assert_equal expected, out
@@ -87,18 +86,18 @@ class TestGemRequestSetLockfile < Gem::T
 
   def test_add_GEM
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2 do |s|
-        s.add_dependency 'b'
-        s.add_development_dependency 'c'
+      fetcher.spec "a", 2 do |s|
+        s.add_dependency "b"
+        s.add_development_dependency "c"
       end
 
-      fetcher.spec 'b', 2
+      fetcher.spec "b", 2
 
-      fetcher.spec 'bundler', 1
+      fetcher.spec "bundler", 1
     end
 
-    @set.gem 'a'
-    @set.gem 'bundler'
+    @set.gem "a"
+    @set.gem "bundler"
     @set.resolve
 
     out = []
@@ -106,13 +105,13 @@ class TestGemRequestSetLockfile < Gem::T
     lockfile.add_GEM out, lockfile.spec_groups
 
     expected = [
-      'GEM',
-      '  remote: http://gems.example.com/',
-      '  specs:',
-      '    a (2)',
-      '      b',
-      '    b (2)',
-      nil
+      "GEM",
+      "  remote: http://gems.example.com/",
+      "  specs:",
+      "    a (2)",
+      "      b",
+      "    b (2)",
+      nil,
     ]
 
     assert_equal expected, out
@@ -120,16 +119,16 @@ class TestGemRequestSetLockfile < Gem::T
 
   def test_add_PLATFORMS
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2 do |s|
-        s.add_dependency 'b'
+      fetcher.spec "a", 2 do |s|
+        s.add_dependency "b"
       end
 
-      fetcher.spec 'b', 2 do |s|
+      fetcher.spec "b", 2 do |s|
         s.platform = Gem::Platform::CURRENT
       end
     end
 
-    @set.gem 'a'
+    @set.gem "a"
     @set.resolve
 
     out = []
@@ -137,31 +136,31 @@ class TestGemRequestSetLockfile < Gem::T
     lockfile.add_PLATFORMS out
 
     expected = [
-      'PLATFORMS',
-      '  ruby',
-      '  x86-darwin-8',
-      nil
+      "PLATFORMS",
+      "  ruby",
+      "  x86-darwin-8",
+      nil,
     ]
 
     assert_equal expected, out
   end
 
   def test_relative_path_from
-    path = lockfile.relative_path_from '/foo', '/foo/bar'
+    path = lockfile.relative_path_from "/foo", "/foo/bar"
 
-    assert_equal File.expand_path('/foo'), path
+    assert_equal File.expand_path("/foo"), path
 
-    path = lockfile.relative_path_from '/foo', '/foo'
+    path = lockfile.relative_path_from "/foo", "/foo"
 
-    assert_equal '.', path
+    assert_equal ".", path
   end
 
   def test_to_s_gem
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2
+      fetcher.spec "a", 2
     end
 
-    @set.gem 'a'
+    @set.gem "a"
 
     expected = <<-LOCKFILE
 GEM
@@ -181,12 +180,12 @@ DEPENDENCIES
 
   def test_to_s_gem_dependency
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2, 'c' => '>= 0', 'b' => '>= 0'
-      fetcher.spec 'b', 2
-      fetcher.spec 'c', 2
+      fetcher.spec "a", 2, "c" => ">= 0", "b" => ">= 0"
+      fetcher.spec "b", 2
+      fetcher.spec "c", 2
     end
 
-    @set.gem 'a'
+    @set.gem "a"
 
     expected = <<-LOCKFILE
 GEM
@@ -212,12 +211,12 @@ DEPENDENCIES
 
   def test_to_s_gem_dependency_non_default
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2, 'b' => '>= 1'
-      fetcher.spec 'b', 2
+      fetcher.spec "a", 2, "b" => ">= 1"
+      fetcher.spec "b", 2
     end
 
-    @set.gem 'b'
-    @set.gem 'a'
+    @set.gem "b"
+    @set.gem "a"
 
     expected = <<-LOCKFILE
 GEM
@@ -240,11 +239,11 @@ DEPENDENCIES
 
   def test_to_s_gem_dependency_requirement
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2, 'b' => '>= 0'
-      fetcher.spec 'b', 2
+      fetcher.spec "a", 2, "b" => ">= 0"
+      fetcher.spec "b", 2
     end
 
-    @set.gem 'a', '>= 1'
+    @set.gem "a", ">= 1"
 
     expected = <<-LOCKFILE
 GEM
@@ -270,7 +269,7 @@ DEPENDENCIES
 
     @vendor_set.add_vendor_gem name, directory
 
-    @set.gem 'a'
+    @set.gem "a"
 
     expected = <<-LOCKFILE
 PATH
@@ -293,7 +292,7 @@ DEPENDENCIES
 
     @vendor_set.add_vendor_gem name, File.expand_path(directory)
 
-    @set.gem 'a'
+    @set.gem "a"
 
     expected = <<-LOCKFILE
 PATH
@@ -313,12 +312,12 @@ DEPENDENCIES
 
   def test_to_s_gem_platform
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2 do |spec|
+      fetcher.spec "a", 2 do |spec|
         spec.platform = Gem::Platform.local
       end
     end
 
-    @set.gem 'a'
+    @set.gem "a"
 
     expected = <<-LOCKFILE
 GEM
@@ -338,17 +337,17 @@ DEPENDENCIES
 
   def test_to_s_gem_source
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
+      fetcher.download "a", 2
     end
 
-    spec_fetcher 'http://other.example/' do |fetcher|
-      fetcher.download 'b', 2
+    spec_fetcher "http://other.example/" do |fetcher|
+      fetcher.download "b", 2
     end
 
-    Gem.sources << 'http://other.example/'
+    Gem.sources << "http://other.example/"
 
-    @set.gem 'a'
-    @set.gem 'b'
+    @set.gem "a"
+    @set.gem "b"
 
     expected = <<-LOCKFILE
 GEM
@@ -378,43 +377,43 @@ DEPENDENCIES
     head = nil
 
     Dir.chdir repository do
-      FileUtils.mkdir 'b'
+      FileUtils.mkdir "b"
 
-      Dir.chdir 'b' do
-        b = Gem::Specification.new 'b', 1 do |s|
-          s.add_dependency 'a', '~> 1.0'
-          s.add_dependency 'c', '~> 1.0'
+      Dir.chdir "b" do
+        b = Gem::Specification.new "b", 1 do |s|
+          s.add_dependency "a", "~> 1.0"
+          s.add_dependency "c", "~> 1.0"
         end
 
-        File.open 'b.gemspec', 'w' do |io|
+        File.open "b.gemspec", "w" do |io|
           io.write b.to_ruby
         end
 
-        system @git, 'add', 'b.gemspec'
-        system @git, 'commit', '--quiet', '-m', 'add b/b.gemspec'
+        system @git, "add", "b.gemspec"
+        system @git, "commit", "--quiet", "-m", "add b/b.gemspec"
       end
 
-      FileUtils.mkdir 'c'
+      FileUtils.mkdir "c"
 
-      Dir.chdir 'c' do
-        c = Gem::Specification.new 'c', 1
+      Dir.chdir "c" do
+        c = Gem::Specification.new "c", 1
 
-        File.open 'c.gemspec', 'w' do |io|
+        File.open "c.gemspec", "w" do |io|
           io.write c.to_ruby
         end
 
-        system @git, 'add', 'c.gemspec'
-        system @git, 'commit', '--quiet', '-m', 'add c/c.gemspec'
+        system @git, "add", "c.gemspec"
+        system @git, "commit", "--quiet", "-m", "add c/c.gemspec"
       end
 
       head = `#{@git} rev-parse HEAD`.strip
     end
 
-    @git_set.add_git_gem 'a', repository, 'HEAD', true
-    @git_set.add_git_gem 'b', repository, 'HEAD', true
-    @git_set.add_git_gem 'c', repository, 'HEAD', true
+    @git_set.add_git_gem "a", repository, "HEAD", true
+    @git_set.add_git_gem "b", repository, "HEAD", true
+    @git_set.add_git_gem "c", repository, "HEAD", true
 
-    @set.gem 'b'
+    @set.gem "b"
 
     expected = <<-LOCKFILE
 GIT
@@ -444,27 +443,26 @@ DEPENDENCIES
 
     gem_deps_lock_file = "#{@gem_deps_file}.lock"
 
-    assert_path_exists gem_deps_lock_file
+    assert_path_exist gem_deps_lock_file
 
     refute_empty File.read gem_deps_lock_file
   end
 
   def test_write_error
-    @set.gem 'nonexistent'
+    @set.gem "nonexistent"
 
     gem_deps_lock_file = "#{@gem_deps_file}.lock"
 
-    File.open gem_deps_lock_file, 'w' do |io|
-      io.write 'hello'
+    File.open gem_deps_lock_file, "w" do |io|
+      io.write "hello"
     end
 
-    assert_raises Gem::UnsatisfiableDependencyError do
+    assert_raise Gem::UnsatisfiableDependencyError do
       lockfile.write
     end
 
-    assert_path_exists gem_deps_lock_file
+    assert_path_exist gem_deps_lock_file
 
-    assert_equal 'hello', File.read(gem_deps_lock_file)
+    assert_equal "hello", File.read(gem_deps_lock_file)
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_request_set_lockfile_parser.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_request_set_lockfile_parser.rb
@@ -1,15 +1,14 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/request_set'
-require 'rubygems/request_set/lockfile'
-require 'rubygems/request_set/lockfile/tokenizer'
-require 'rubygems/request_set/lockfile/parser'
+require_relative "helper"
+require "rubygems/request_set"
+require "rubygems/request_set/lockfile"
+require "rubygems/request_set/lockfile/tokenizer"
+require "rubygems/request_set/lockfile/parser"
 
 class TestGemRequestSetLockfileParser < Gem::TestCase
-
   def setup
     super
-    @gem_deps_file = 'gem.deps.rb'
+    @gem_deps_file = "gem.deps.rb"
     @lock_file = File.expand_path "#{@gem_deps_file}.lock"
     @set = Gem::RequestSet.new
   end
@@ -26,7 +25,7 @@ class TestGemRequestSetLockfileParser < 
     tokenizer = Gem::RequestSet::Lockfile::Tokenizer.new "foo", filename, 1, 0
     parser = tokenizer.make_parser nil, nil
 
-    e = assert_raises Gem::RequestSet::Lockfile::ParseError do
+    e = assert_raise Gem::RequestSet::Lockfile::ParseError do
       parser.get :section
     end
 
@@ -53,8 +52,8 @@ class TestGemRequestSetLockfileParser < 
     tokenizer = Gem::RequestSet::Lockfile::Tokenizer.new "x", filename, 1
     parser = tokenizer.make_parser nil, nil
 
-    e = assert_raises Gem::RequestSet::Lockfile::ParseError do
-      parser.get :text, 'y'
+    e = assert_raise Gem::RequestSet::Lockfile::ParseError do
+      parser.get :text, "y"
     end
 
     expected =
@@ -84,7 +83,7 @@ DEPENDENCIES
     platforms = []
     parse_lockfile @set, platforms
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
     assert_equal [Gem::Platform::RUBY], platforms
 
@@ -92,9 +91,9 @@ DEPENDENCIES
       Gem::Resolver::LockSet === set
     end
 
-    assert lockfile_set, 'could not find a LockSet'
+    assert lockfile_set, "could not find a LockSet"
 
-    assert_equal %w[a-2], lockfile_set.specs.map { |tuple| tuple.full_name }
+    assert_equal %w[a-2], lockfile_set.specs.map {|tuple| tuple.full_name }
   end
 
   def test_parse_dependencies
@@ -114,7 +113,7 @@ DEPENDENCIES
     platforms = []
     parse_lockfile @set, platforms
 
-    assert_equal [dep('a', '>= 1', '<= 2')], @set.dependencies
+    assert_equal [dep("a", ">= 1", "<= 2")], @set.dependencies
 
     assert_equal [Gem::Platform::RUBY], platforms
 
@@ -122,9 +121,9 @@ DEPENDENCIES
       Gem::Resolver::LockSet === set
     end
 
-    assert lockfile_set, 'could not find a LockSet'
+    assert lockfile_set, "could not find a LockSet"
 
-    assert_equal %w[a-2], lockfile_set.specs.map { |tuple| tuple.full_name }
+    assert_equal %w[a-2], lockfile_set.specs.map {|tuple| tuple.full_name }
   end
 
   def test_parse_DEPENDENCIES_git
@@ -160,8 +159,8 @@ DEPENDENCIES
     parse_lockfile @set, []
 
     expected = [
-      dep('i18n-active_record', '= 0.0.2'),
-      dep('rails-footnotes',    '= 3.7.9'),
+      dep("i18n-active_record", "= 0.0.2"),
+      dep("rails-footnotes",    "= 3.7.9"),
     ]
 
     assert_equal expected, @set.dependencies
@@ -189,7 +188,7 @@ DEPENDENCIES
     parse_lockfile @set, []
 
     expected = [
-      dep('jwt', '= 1.1'),
+      dep("jwt", "= 1.1"),
     ]
 
     assert_equal expected, @set.dependencies
@@ -210,15 +209,15 @@ DEPENDENCIES
 
     parse_lockfile @set, []
 
-    assert_equal [dep('a', '>= 0')], @set.dependencies
+    assert_equal [dep("a", ">= 0")], @set.dependencies
 
     lockfile_set = @set.sets.find do |set|
       Gem::Resolver::LockSet === set
     end
 
-    assert lockfile_set, 'found a LockSet'
+    assert lockfile_set, "found a LockSet"
 
-    assert_equal %w[a-2], lockfile_set.specs.map { |s| s.full_name }
+    assert_equal %w[a-2], lockfile_set.specs.map {|s| s.full_name }
   end
 
   def test_parse_GEM_remote_multiple
@@ -238,22 +237,22 @@ DEPENDENCIES
 
     parse_lockfile @set, []
 
-    assert_equal [dep('a', '>= 0')], @set.dependencies
+    assert_equal [dep("a", ">= 0")], @set.dependencies
 
     lockfile_set = @set.sets.find do |set|
       Gem::Resolver::LockSet === set
     end
 
-    assert lockfile_set, 'found a LockSet'
+    assert lockfile_set, "found a LockSet"
 
-    assert_equal %w[a-2], lockfile_set.specs.map { |s| s.full_name }
+    assert_equal %w[a-2], lockfile_set.specs.map {|s| s.full_name }
 
     assert_equal %w[https://gems.example/ https://other.example/],
-                 lockfile_set.specs.flat_map { |s| s.sources.map{ |src| src.uri.to_s } }
+                 lockfile_set.specs.flat_map {|s| s.sources.map {|src| src.uri.to_s } }
   end
 
   def test_parse_GIT
-    @set.instance_variable_set :@install_dir, 'install_dir'
+    @set.instance_variable_set :@install_dir, "install_dir"
 
     write_lockfile <<-LOCKFILE
 GIT
@@ -270,31 +269,31 @@ DEPENDENCIES
 
     parse_lockfile @set, []
 
-    assert_equal [dep('a', '= 2')], @set.dependencies
+    assert_equal [dep("a", "= 2")], @set.dependencies
 
     lockfile_set = @set.sets.find do |set|
       Gem::Resolver::LockSet === set
     end
 
-    refute lockfile_set, 'fount a LockSet'
+    refute lockfile_set, "fount a LockSet"
 
     git_set = @set.sets.find do |set|
       Gem::Resolver::GitSet === set
     end
 
-    assert git_set, 'could not find a GitSet'
+    assert git_set, "could not find a GitSet"
 
-    assert_equal %w[a-2], git_set.specs.values.map { |s| s.full_name }
+    assert_equal %w[a-2], git_set.specs.values.map {|s| s.full_name }
 
-    assert_equal [dep('b', '>= 3'), dep('c')],
+    assert_equal [dep("b", ">= 3"), dep("c")],
                  git_set.specs.values.first.dependencies
 
     expected = {
-      'a' => %w[git://example/a.git master],
+      "a" => %w[git://example/a.git master],
     }
 
     assert_equal expected, git_set.repositories
-    assert_equal 'install_dir', git_set.root_dir
+    assert_equal "install_dir", git_set.root_dir
   end
 
   def test_parse_GIT_branch
@@ -313,22 +312,22 @@ DEPENDENCIES
 
     parse_lockfile @set, []
 
-    assert_equal [dep('a', '= 2')], @set.dependencies
+    assert_equal [dep("a", "= 2")], @set.dependencies
 
     lockfile_set = @set.sets.find do |set|
       Gem::Resolver::LockSet === set
     end
 
-    refute lockfile_set, 'fount a LockSet'
+    refute lockfile_set, "fount a LockSet"
 
     git_set = @set.sets.find do |set|
       Gem::Resolver::GitSet === set
     end
 
-    assert git_set, 'could not find a GitSet'
+    assert git_set, "could not find a GitSet"
 
     expected = {
-      'a' => %w[git://example/a.git 1234abc],
+      "a" => %w[git://example/a.git 1234abc],
     }
 
     assert_equal expected, git_set.repositories
@@ -350,22 +349,22 @@ DEPENDENCIES
 
     parse_lockfile @set, []
 
-    assert_equal [dep('a', '= 2')], @set.dependencies
+    assert_equal [dep("a", "= 2")], @set.dependencies
 
     lockfile_set = @set.sets.find do |set|
       Gem::Resolver::LockSet === set
     end
 
-    refute lockfile_set, 'fount a LockSet'
+    refute lockfile_set, "fount a LockSet"
 
     git_set = @set.sets.find do |set|
       Gem::Resolver::GitSet === set
     end
 
-    assert git_set, 'could not find a GitSet'
+    assert git_set, "could not find a GitSet"
 
     expected = {
-      'a' => %w[git://example/a.git 1234abc],
+      "a" => %w[git://example/a.git 1234abc],
     }
 
     assert_equal expected, git_set.repositories
@@ -387,22 +386,22 @@ DEPENDENCIES
 
     parse_lockfile @set, []
 
-    assert_equal [dep('a', '= 2')], @set.dependencies
+    assert_equal [dep("a", "= 2")], @set.dependencies
 
     lockfile_set = @set.sets.find do |set|
       Gem::Resolver::LockSet === set
     end
 
-    refute lockfile_set, 'fount a LockSet'
+    refute lockfile_set, "fount a LockSet"
 
     git_set = @set.sets.find do |set|
       Gem::Resolver::GitSet === set
     end
 
-    assert git_set, 'could not find a GitSet'
+    assert git_set, "could not find a GitSet"
 
     expected = {
-      'a' => %w[git://example/a.git 1234abc],
+      "a" => %w[git://example/a.git 1234abc],
     }
 
     assert_equal expected, git_set.repositories
@@ -424,45 +423,45 @@ DEPENDENCIES
 
     parse_lockfile @set, []
 
-    assert_equal [dep('a', '= 1')], @set.dependencies
+    assert_equal [dep("a", "= 1")], @set.dependencies
 
     lockfile_set = @set.sets.find do |set|
       Gem::Resolver::LockSet === set
     end
 
-    refute lockfile_set, 'found a LockSet'
+    refute lockfile_set, "found a LockSet"
 
     vendor_set = @set.sets.find do |set|
       Gem::Resolver::VendorSet === set
     end
 
-    assert vendor_set, 'could not find a VendorSet'
+    assert vendor_set, "could not find a VendorSet"
 
-    assert_equal %w[a-1], vendor_set.specs.values.map { |s| s.full_name }
+    assert_equal %w[a-1], vendor_set.specs.values.map {|s| s.full_name }
 
-    spec = vendor_set.load_spec 'a', nil, nil, nil
+    spec = vendor_set.load_spec "a", nil, nil, nil
 
-    assert_equal [dep('b', '= 2')], spec.dependencies
+    assert_equal [dep("b", "= 2")], spec.dependencies
   end
 
   def test_parse_dependency
-    write_lockfile ' 1)'
+    write_lockfile " 1)"
 
     tokenizer = Gem::RequestSet::Lockfile::Tokenizer.from_file @lock_file
     parser = tokenizer.make_parser nil, nil
 
-    parsed = parser.parse_dependency 'a', '='
+    parsed = parser.parse_dependency "a", "="
 
-    assert_equal dep('a', '= 1'), parsed
+    assert_equal dep("a", "= 1"), parsed
 
-    write_lockfile ')'
+    write_lockfile ")"
 
     tokenizer = Gem::RequestSet::Lockfile::Tokenizer.from_file @lock_file
     parser = tokenizer.make_parser nil, nil
 
-    parsed = parser.parse_dependency 'a', '2'
+    parsed = parser.parse_dependency "a", "2"
 
-    assert_equal dep('a', '= 2'), parsed
+    assert_equal dep("a", "= 2"), parsed
   end
 
   def test_parse_gem_specs_dependency
@@ -487,7 +486,7 @@ DEPENDENCIES
     platforms = []
     parse_lockfile @set, platforms
 
-    assert_equal [dep('a')], @set.dependencies
+    assert_equal [dep("a")], @set.dependencies
 
     assert_equal [Gem::Platform::RUBY], platforms
 
@@ -495,31 +494,31 @@ DEPENDENCIES
       Gem::Resolver::LockSet === set
     end
 
-    assert lockfile_set, 'could not find a LockSet'
+    assert lockfile_set, "could not find a LockSet"
 
-    assert_equal %w[a-2 b-3], lockfile_set.specs.map { |tuple| tuple.full_name }
+    assert_equal %w[a-2 b-3], lockfile_set.specs.map {|tuple| tuple.full_name }
 
     expected = [
       Gem::Platform::RUBY,
-      Gem::Platform.new('x86_64-linux'),
+      Gem::Platform.new("x86_64-linux"),
     ]
 
-    assert_equal expected, lockfile_set.specs.map { |tuple| tuple.platform }
+    assert_equal expected, lockfile_set.specs.map {|tuple| tuple.platform }
 
     spec = lockfile_set.specs.first
 
     expected = [
-      dep('b', '= 3'),
-      dep('c', '~> 4'),
-      dep('d'),
-      dep('e', '~> 5.0', '>= 5.0.1'),
+      dep("b", "= 3"),
+      dep("c", "~> 4"),
+      dep("d"),
+      dep("e", "~> 5.0", ">= 5.0.1"),
     ]
 
     assert_equal expected, spec.dependencies
   end
 
   def test_parse_missing
-    assert_raises(Errno::ENOENT) do
+    assert_raise(Errno::ENOENT) do
       parse_lockfile @set, []
     end
 
@@ -531,7 +530,7 @@ DEPENDENCIES
   end
 
   def write_lockfile(lockfile)
-    File.open @lock_file, 'w' do |io|
+    File.open @lock_file, "w" do |io|
       io.write lockfile
     end
   end
@@ -541,5 +540,4 @@ DEPENDENCIES
     parser = tokenizer.make_parser set, platforms
     parser.parse
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_request_set_lockfile_tokenizer.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_request_set_lockfile_tokenizer.rb
@@ -1,16 +1,15 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/request_set'
-require 'rubygems/request_set/lockfile'
-require 'rubygems/request_set/lockfile/tokenizer'
-require 'rubygems/request_set/lockfile/parser'
+require_relative "helper"
+require "rubygems/request_set"
+require "rubygems/request_set/lockfile"
+require "rubygems/request_set/lockfile/tokenizer"
+require "rubygems/request_set/lockfile/parser"
 
 class TestGemRequestSetLockfileTokenizer < Gem::TestCase
-
   def setup
     super
 
-    @gem_deps_file = 'gem.deps.rb'
+    @gem_deps_file = "gem.deps.rb"
     @lock_file = File.expand_path "#{@gem_deps_file}.lock"
   end
 
@@ -35,10 +34,10 @@ class TestGemRequestSetLockfileTokenizer
   end
 
   def test_token_pos
-    tokenizer = Gem::RequestSet::Lockfile::Tokenizer.new ''
+    tokenizer = Gem::RequestSet::Lockfile::Tokenizer.new ""
     assert_equal [5, 0], tokenizer.token_pos(5)
 
-    tokenizer = Gem::RequestSet::Lockfile::Tokenizer.new '', nil, 1, 2
+    tokenizer = Gem::RequestSet::Lockfile::Tokenizer.new "", nil, 1, 2
     assert_equal [3, 1], tokenizer.token_pos(5)
   end
 
@@ -64,86 +63,86 @@ DEPENDENCIES
     LOCKFILE
 
     expected = [
-      [:section,     'GEM',                0,  0],
-      [:newline,     nil,                  3,  0],
+      [:section,     "GEM",               0,  0],
+      [:newline,     nil,                 3,  0],
 
-      [:entry,       'remote',             2,  1],
-      [:text,        @gem_repo,           10,  1],
-      [:newline,     nil,                 34,  1],
-
-      [:entry,       'specs',              2,  2],
-      [:newline,     nil,                  8,  2],
-
-      [:text,        'a',                  4,  3],
-      [:l_paren,     nil,                  6,  3],
-      [:text,        '2',                  7,  3],
-      [:r_paren,     nil,                  8,  3],
-      [:newline,     nil,                  9,  3],
-
-      [:text,        'b',                  6,  4],
-      [:l_paren,     nil,                  8,  4],
-      [:requirement, '=',                  9,  4],
-      [:text,        '2',                 11,  4],
-      [:r_paren,     nil,                 12,  4],
-      [:newline,     nil,                 13,  4],
-
-      [:text,        'c',                  6,  5],
-      [:l_paren,     nil,                  8,  5],
-      [:requirement, '!=',                 9,  5],
-      [:text,        '3',                 12,  5],
-      [:r_paren,     nil,                 13,  5],
-      [:newline,     nil,                 14,  5],
-
-      [:text,        'd',                  6,  6],
-      [:l_paren,     nil,                  8,  6],
-      [:requirement, '>',                  9,  6],
-      [:text,        '4',                 11,  6],
-      [:r_paren,     nil,                 12,  6],
-      [:newline,     nil,                 13,  6],
-
-      [:text,        'e',                  6,  7],
-      [:l_paren,     nil,                  8,  7],
-      [:requirement, '<',                  9,  7],
-      [:text,        '5',                 11,  7],
-      [:r_paren,     nil,                 12,  7],
-      [:newline,     nil,                 13,  7],
-
-      [:text,        'f',                  6,  8],
-      [:l_paren,     nil,                  8,  8],
-      [:requirement, '>=',                 9,  8],
-      [:text,        '6',                 12,  8],
-      [:r_paren,     nil,                 13,  8],
-      [:newline,     nil,                 14,  8],
-
-      [:text,        'g',                  6,  9],
-      [:l_paren,     nil,                  8,  9],
-      [:requirement, '<=',                 9,  9],
-      [:text,        '7',                 12,  9],
-      [:r_paren,     nil,                 13,  9],
-      [:newline,     nil,                 14,  9],
-
-      [:text,        'h',                  6, 10],
-      [:l_paren,     nil,                  8, 10],
-      [:requirement, '~>',                 9, 10],
-      [:text,        '8',                 12, 10],
+      [:entry,       "remote",            2,  1],
+      [:text,        @gem_repo,           10, 1],
+      [:newline,     nil,                 34, 1],
+
+      [:entry,       "specs",             2,  2],
+      [:newline,     nil,                 8,  2],
+
+      [:text,        "a",                 4,  3],
+      [:l_paren,     nil,                 6,  3],
+      [:text,        "2",                 7,  3],
+      [:r_paren,     nil,                 8,  3],
+      [:newline,     nil,                 9,  3],
+
+      [:text,        "b",                 6,  4],
+      [:l_paren,     nil,                 8,  4],
+      [:requirement, "=",                 9,  4],
+      [:text,        "2",                 11, 4],
+      [:r_paren,     nil,                 12, 4],
+      [:newline,     nil,                 13, 4],
+
+      [:text,        "c",                 6,  5],
+      [:l_paren,     nil,                 8,  5],
+      [:requirement, "!=",                9,  5],
+      [:text,        "3",                 12, 5],
+      [:r_paren,     nil,                 13, 5],
+      [:newline,     nil,                 14, 5],
+
+      [:text,        "d",                 6,  6],
+      [:l_paren,     nil,                 8,  6],
+      [:requirement, ">",                 9,  6],
+      [:text,        "4",                 11, 6],
+      [:r_paren,     nil,                 12, 6],
+      [:newline,     nil,                 13, 6],
+
+      [:text,        "e",                 6,  7],
+      [:l_paren,     nil,                 8,  7],
+      [:requirement, "<",                 9,  7],
+      [:text,        "5",                 11, 7],
+      [:r_paren,     nil,                 12, 7],
+      [:newline,     nil,                 13, 7],
+
+      [:text,        "f",                 6,  8],
+      [:l_paren,     nil,                 8,  8],
+      [:requirement, ">=",                9,  8],
+      [:text,        "6",                 12, 8],
+      [:r_paren,     nil,                 13, 8],
+      [:newline,     nil,                 14, 8],
+
+      [:text,        "g",                 6,  9],
+      [:l_paren,     nil,                 8,  9],
+      [:requirement, "<=",                9,  9],
+      [:text,        "7",                 12, 9],
+      [:r_paren,     nil,                 13, 9],
+      [:newline,     nil,                 14, 9],
+
+      [:text,        "h",                 6,  10],
+      [:l_paren,     nil,                 8,  10],
+      [:requirement, "~>",                9,  10],
+      [:text,        "8",                 12, 10],
       [:r_paren,     nil,                 13, 10],
       [:newline,     nil,                 14, 10],
 
-      [:newline,     nil,                  0, 11],
+      [:newline,     nil,                 0,  11],
 
-      [:section,     'PLATFORMS',          0, 12],
-      [:newline,     nil,                  9, 12],
+      [:section,     "PLATFORMS",         0,  12],
+      [:newline,     nil,                 9,  12],
 
-      [:text,        Gem::Platform::RUBY,  2, 13],
-      [:newline,     nil,                  6, 13],
+      [:text,        Gem::Platform::RUBY, 2,  13],
+      [:newline,     nil,                 6,  13],
 
-      [:newline,     nil,                  0, 14],
+      [:newline,     nil,                 0,  14],
 
-      [:section,     'DEPENDENCIES',       0, 15],
+      [:section,     "DEPENDENCIES",      0,  15],
       [:newline,     nil,                 12, 15],
 
-      [:text,        'a',                  2, 16],
-      [:newline,     nil,                  3, 16],
+      [:text,        "a",                 2,  16],
+      [:newline,     nil,                 3,  16],
     ]
 
     assert_equal expected, tokenize_lockfile
@@ -164,64 +163,64 @@ DEPENDENCIES
     LOCKFILE
 
     expected = [
-      [:section, 'GEM',                0, 0],
-      [:newline, nil,                  3, 0],
-      [:entry,   'remote',             2, 1],
+      [:section, "GEM",               0,  0],
+      [:newline, nil,                 3,  0],
+      [:entry,   "remote",            2,  1],
       [:text,    @gem_repo,           10, 1],
       [:newline, nil,                 34, 1],
-      [:entry,   'specs',              2, 2],
-      [:newline, nil,                  8, 2],
-      [:text,    'Ab',                 4, 3],
-      [:l_paren, nil,                  7, 3],
-      [:text,    '2',                  8, 3],
-      [:r_paren, nil,                  9, 3],
+      [:entry,   "specs",             2,  2],
+      [:newline, nil,                 8,  2],
+      [:text,    "Ab",                4,  3],
+      [:l_paren, nil,                 7,  3],
+      [:text,    "2",                 8,  3],
+      [:r_paren, nil,                 9,  3],
       [:newline, nil,                 10, 3],
-      [:newline, nil,                  0, 4],
-      [:section, 'PLATFORMS',          0, 5],
-      [:newline, nil,                  9, 5],
-      [:text,    Gem::Platform::RUBY,  2, 6],
-      [:newline, nil,                  6, 6],
-      [:newline, nil,                  0, 7],
-      [:section, 'DEPENDENCIES',       0, 8],
+      [:newline, nil,                 0,  4],
+      [:section, "PLATFORMS",         0,  5],
+      [:newline, nil,                 9,  5],
+      [:text,    Gem::Platform::RUBY, 2,  6],
+      [:newline, nil,                 6,  6],
+      [:newline, nil,                 0,  7],
+      [:section, "DEPENDENCIES",      0,  8],
       [:newline, nil,                 12, 8],
-      [:text,    'Ab',                 2, 9],
-      [:newline, nil,                  4, 9],
+      [:text,    "Ab",                2,  9],
+      [:newline, nil,                 4,  9],
     ]
 
     assert_equal expected, tokenize_lockfile
   end
 
   def test_tokenize_conflict_markers
-    write_lockfile '<<<<<<<'
+    write_lockfile "<<<<<<<"
 
-    e = assert_raises Gem::RequestSet::Lockfile::ParseError do
+    e = assert_raise Gem::RequestSet::Lockfile::ParseError do
       tokenize_lockfile
     end
 
     assert_equal "your #{@lock_file} contains merge conflict markers (at line 0 column 0)",
                  e.message
 
-    write_lockfile '|||||||'
+    write_lockfile "|||||||"
 
-    e = assert_raises Gem::RequestSet::Lockfile::ParseError do
+    e = assert_raise Gem::RequestSet::Lockfile::ParseError do
       tokenize_lockfile
     end
 
     assert_equal "your #{@lock_file} contains merge conflict markers (at line 0 column 0)",
                  e.message
 
-    write_lockfile '======='
+    write_lockfile "======="
 
-    e = assert_raises Gem::RequestSet::Lockfile::ParseError do
+    e = assert_raise Gem::RequestSet::Lockfile::ParseError do
       tokenize_lockfile
     end
 
     assert_equal "your #{@lock_file} contains merge conflict markers (at line 0 column 0)",
                  e.message
 
-    write_lockfile '>>>>>>>'
+    write_lockfile ">>>>>>>"
 
-    e = assert_raises Gem::RequestSet::Lockfile::ParseError do
+    e = assert_raise Gem::RequestSet::Lockfile::ParseError do
       tokenize_lockfile
     end
 
@@ -236,12 +235,12 @@ DEPENDENCIES
     LOCKFILE
 
     expected = [
-      [:section, 'DEPENDENCIES',  0,  0],
-      [:newline, nil,            12,  0],
+      [:section, "DEPENDENCIES", 0,  0],
+      [:newline, nil,            12, 0],
 
-      [:text,    'a',             2,  1],
-      [:bang,    nil,             3,  1],
-      [:newline, nil,             4,  1],
+      [:text,    "a",            2,  1],
+      [:bang,    nil,            3,  1],
+      [:newline, nil,            4,  1],
     ]
 
     assert_equal expected, tokenize_lockfile
@@ -257,31 +256,31 @@ GEM
     LOCKFILE
 
     expected = [
-      [:section,     'GEM',      0,  0],
-      [:newline,     nil,        3,  0],
+      [:section,     "GEM",     0,  0],
+      [:newline,     nil,       3,  0],
 
-      [:entry,       'remote',   2,  1],
-      [:text,        @gem_repo, 10,  1],
-      [:newline,     nil,       34,  1],
-
-      [:entry,       'specs',    2,  2],
-      [:newline,     nil,        8,  2],
-
-      [:text,        'a',        4,  3],
-      [:l_paren,     nil,        6,  3],
-      [:text,        '2',        7,  3],
-      [:r_paren,     nil,        8,  3],
-      [:newline,     nil,        9,  3],
-
-      [:text,        'b',        6,  4],
-      [:l_paren,     nil,        8,  4],
-      [:requirement, '~>',       9,  4],
-      [:text,        '3.0',     12,  4],
-      [:comma,       nil,       15,  4],
-      [:requirement, '>=',      17,  4],
-      [:text,        '3.0.1',   20,  4],
-      [:r_paren,     nil,       25,  4],
-      [:newline,     nil,       26,  4],
+      [:entry,       "remote",  2,  1],
+      [:text,        @gem_repo, 10, 1],
+      [:newline,     nil,       34, 1],
+
+      [:entry,       "specs",   2,  2],
+      [:newline,     nil,       8,  2],
+
+      [:text,        "a",       4,  3],
+      [:l_paren,     nil,       6,  3],
+      [:text,        "2",       7,  3],
+      [:r_paren,     nil,       8,  3],
+      [:newline,     nil,       9,  3],
+
+      [:text,        "b",       6,  4],
+      [:l_paren,     nil,       8,  4],
+      [:requirement, "~>",      9,  4],
+      [:text,        "3.0",     12, 4],
+      [:comma,       nil,       15, 4],
+      [:requirement, ">=",      17, 4],
+      [:text,        "3.0.1",   20, 4],
+      [:r_paren,     nil,       25, 4],
+      [:newline,     nil,       26, 4],
     ]
 
     assert_equal expected, tokenize_lockfile
@@ -296,7 +295,7 @@ GEM
   end
 
   def write_lockfile(lockfile)
-    File.open @lock_file, 'w' do |io|
+    File.open @lock_file, "w" do |io|
       io.write lockfile
     end
   end
@@ -304,5 +303,4 @@ GEM
   def tokenize_lockfile
     Gem::RequestSet::Lockfile::Tokenizer.from_file(@lock_file).to_a
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_requirement.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_requirement.rb
@@ -1,15 +1,14 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 require "rubygems/requirement"
 
 class TestGemRequirement < Gem::TestCase
-
   def test_concat
-    r = req '>= 1'
+    r = req ">= 1"
 
-    r.concat ['< 2']
+    r.concat ["< 2"]
 
-    assert_equal [['>=', v(1)], ['<', v(2)]], r.requirements
+    assert_equal [[">=", v(1)], ["<", v(2)]], r.requirements
   end
 
   def test_equals2
@@ -23,6 +22,8 @@ class TestGemRequirement < Gem::TestCase
     refute_requirement_equal "~> 1.3", "~> 1.3.0"
     refute_requirement_equal "~> 1.3.0", "~> 1.3"
 
+    assert_requirement_equal ["> 2", "~> 1.3", "~> 1.3.1"], ["~> 1.3.1", "~> 1.3", "> 2"]
+
     assert_requirement_equal ["> 2", "~> 1.3"], ["> 2.0", "~> 1.3"]
     assert_requirement_equal ["> 2.0", "~> 1.3"], ["> 2", "~> 1.3"]
 
@@ -59,38 +60,44 @@ class TestGemRequirement < Gem::TestCase
   end
 
   def test_for_lockfile
-    assert_equal ' (~> 1.0)', req('~> 1.0').for_lockfile
+    assert_equal " (~> 1.0)", req("~> 1.0").for_lockfile
 
-    assert_equal ' (~> 1.0, >= 1.0.1)', req('>= 1.0.1', '~> 1.0').for_lockfile
+    assert_equal " (~> 1.0, >= 1.0.1)", req(">= 1.0.1", "~> 1.0").for_lockfile
 
-    duped = req '= 1.0'
-    duped.requirements << ['=', v('1.0')]
+    duped = req "= 1.0"
+    duped.requirements << ["=", v("1.0")]
 
-    assert_equal ' (= 1.0)', duped.for_lockfile
+    assert_equal " (= 1.0)", duped.for_lockfile
 
     assert_nil Gem::Requirement.default.for_lockfile
   end
 
   def test_parse
-    assert_equal ['=', Gem::Version.new(1)], Gem::Requirement.parse('  1')
-    assert_equal ['=', Gem::Version.new(1)], Gem::Requirement.parse('= 1')
-    assert_equal ['>', Gem::Version.new(1)], Gem::Requirement.parse('> 1')
-    assert_equal ['=', Gem::Version.new(1)], Gem::Requirement.parse("=\n1")
-    assert_equal ['=', Gem::Version.new(1)], Gem::Requirement.parse('1.0')
+    assert_equal ["=", Gem::Version.new(1)], Gem::Requirement.parse("  1")
+    assert_equal ["=", Gem::Version.new(1)], Gem::Requirement.parse("= 1")
+    assert_equal [">", Gem::Version.new(1)], Gem::Requirement.parse("> 1")
+    assert_equal ["=", Gem::Version.new(1)], Gem::Requirement.parse("=\n1")
+    assert_equal ["=", Gem::Version.new(1)], Gem::Requirement.parse("1.0")
+
+    assert_equal ["=", Gem::Version.new(2)],
+      Gem::Requirement.parse(Gem::Version.new("2"))
+  end
 
-    assert_equal ['=', Gem::Version.new(2)],
-      Gem::Requirement.parse(Gem::Version.new('2'))
+  if RUBY_VERSION >= "2.5" && !(Gem.java_platform? && ENV["JRUBY_OPTS"] =~ /--debug/)
+    def test_parse_deduplication
+      assert_same "~>", Gem::Requirement.parse("~> 1").first
+    end
   end
 
   def test_parse_bad
     [
       nil,
-      '',
-      '! 1',
-      '= junk',
-      '1..2',
+      "",
+      "! 1",
+      "= junk",
+      "1..2",
     ].each do |bad|
-      e = assert_raises Gem::Requirement::BadRequirementError do
+      e = assert_raise Gem::Requirement::BadRequirementError do
         Gem::Requirement.parse bad
       end
 
@@ -101,28 +108,30 @@ class TestGemRequirement < Gem::TestCase
   end
 
   def test_prerelease_eh
-    r = req '= 1'
+    r = req "= 1"
 
     refute r.prerelease?
 
-    r = req '= 1.a'
+    r = req "= 1.a"
 
     assert r.prerelease?
 
-    r = req '> 1.a', '< 2'
+    r = req "> 1.a", "< 2"
 
     assert r.prerelease?
   end
 
   def test_satisfied_by_eh_bang_equal
-    r = req '!= 1.2'
+    r = req "!= 1.2"
 
     assert_satisfied_by "1.1", r
     refute_satisfied_by "1.2", r
     assert_satisfied_by "1.3", r
 
-    assert_raises ArgumentError do
-      assert_satisfied_by nil, r
+    assert_raise ArgumentError do
+      Gem::Deprecate.skip_during do
+        assert_satisfied_by nil, r
+      end
     end
   end
 
@@ -133,8 +142,10 @@ class TestGemRequirement < Gem::TestCase
     assert_satisfied_by "1.2", r
     refute_satisfied_by "1.3", r
 
-    assert_raises ArgumentError do
-      assert_satisfied_by nil, r
+    assert_raise ArgumentError do
+      Gem::Deprecate.skip_during do
+        assert_satisfied_by nil, r
+      end
     end
   end
 
@@ -145,8 +156,10 @@ class TestGemRequirement < Gem::TestCase
     assert_satisfied_by "1.2", r
     refute_satisfied_by "1.3", r
 
-    assert_raises ArgumentError do
-      assert_satisfied_by nil, r
+    assert_raise ArgumentError do
+      Gem::Deprecate.skip_during do
+        assert_satisfied_by nil, r
+      end
     end
   end
 
@@ -157,7 +170,7 @@ class TestGemRequirement < Gem::TestCase
     refute_satisfied_by "1.2", r
     assert_satisfied_by "1.3", r
 
-    assert_raises ArgumentError do
+    assert_raise ArgumentError do
       r.satisfied_by? nil
     end
   end
@@ -169,7 +182,7 @@ class TestGemRequirement < Gem::TestCase
     assert_satisfied_by "1.2", r
     assert_satisfied_by "1.3", r
 
-    assert_raises ArgumentError do
+    assert_raise ArgumentError do
       r.satisfied_by? nil
     end
   end
@@ -181,7 +194,7 @@ class TestGemRequirement < Gem::TestCase
     assert_satisfied_by "1.2", r
     refute_satisfied_by "1.3", r
 
-    assert_raises ArgumentError do
+    assert_raise ArgumentError do
       r.satisfied_by? nil
     end
   end
@@ -193,7 +206,7 @@ class TestGemRequirement < Gem::TestCase
     refute_satisfied_by "1.2", r
     refute_satisfied_by "1.3", r
 
-    assert_raises ArgumentError do
+    assert_raise ArgumentError do
       r.satisfied_by? nil
     end
   end
@@ -205,7 +218,7 @@ class TestGemRequirement < Gem::TestCase
     assert_satisfied_by "1.2", r
     refute_satisfied_by "1.3", r
 
-    assert_raises ArgumentError do
+    assert_raise ArgumentError do
       r.satisfied_by? nil
     end
   end
@@ -217,7 +230,7 @@ class TestGemRequirement < Gem::TestCase
     assert_satisfied_by "1.2", r
     assert_satisfied_by "1.3", r
 
-    assert_raises ArgumentError do
+    assert_raise ArgumentError do
       r.satisfied_by? nil
     end
   end
@@ -246,7 +259,6 @@ class TestGemRequirement < Gem::TestCase
     assert_satisfied_by "1.0.0.0",     "= 1.0"
     assert_satisfied_by "10.3.2",      "!= 9.3.4"
     assert_satisfied_by "10.3.2",      "> 9.3.2"
-    assert_satisfied_by "10.3.2",      "> 9.3.2"
     assert_satisfied_by " 9.3.2",      ">= 9.3.2"
     assert_satisfied_by "9.3.2 ",      ">= 9.3.2"
     assert_satisfied_by "",            "= 0"
@@ -275,18 +287,18 @@ class TestGemRequirement < Gem::TestCase
 
   def test_illformed_requirements
     [ ">>> 1.3.5", "> blah" ].each do |rq|
-      assert_raises Gem::Requirement::BadRequirementError, "req [#{rq}] should fail" do
+      assert_raise Gem::Requirement::BadRequirementError, "req [#{rq}] should fail" do
         Gem::Requirement.new rq
       end
     end
   end
 
   def test_satisfied_by_eh_non_versions
-    assert_raises ArgumentError do
+    assert_raise ArgumentError do
       req(">= 0").satisfied_by? Object.new
     end
 
-    assert_raises ArgumentError do
+    assert_raise ArgumentError do
       req(">= 0").satisfied_by? Gem::Requirement.default
     end
   end
@@ -356,16 +368,16 @@ class TestGemRequirement < Gem::TestCase
   end
 
   def test_specific
-    refute req('> 1') .specific?
-    refute req('>= 1').specific?
+    refute req("> 1") .specific?
+    refute req(">= 1").specific?
 
-    assert req('!= 1').specific?
-    assert req('< 1') .specific?
-    assert req('<= 1').specific?
-    assert req('= 1') .specific?
-    assert req('~> 1').specific?
+    assert req("!= 1").specific?
+    assert req("< 1") .specific?
+    assert req("<= 1").specific?
+    assert req("= 1") .specific?
+    assert req("~> 1").specific?
 
-    assert req('> 1', '> 2').specific? # GIGO
+    assert req("> 1", "> 2").specific? # GIGO
   end
 
   def test_bad
@@ -386,15 +398,70 @@ class TestGemRequirement < Gem::TestCase
   end
 
   def test_hash_with_multiple_versions
-    r1 = req('1.0', '2.0')
-    r2 = req('2.0', '1.0')
+    r1 = req("1.0", "2.0")
+    r2 = req("2.0", "1.0")
     assert_equal r1.hash, r2.hash
 
-    r1 = req('1.0', '2.0').tap { |r| r.concat(['3.0']) }
-    r2 = req('3.0', '1.0').tap { |r| r.concat(['2.0']) }
+    r1 = req("1.0", "2.0").tap {|r| r.concat(["3.0"]) }
+    r2 = req("3.0", "1.0").tap {|r| r.concat(["2.0"]) }
     assert_equal r1.hash, r2.hash
   end
 
+  def test_hash_returns_equal_hashes_for_equivalent_requirements
+    refute_requirement_hash_equal "= 1.2", "= 1.3"
+    refute_requirement_hash_equal "= 1.3", "= 1.2"
+
+    refute_requirement_hash_equal "~> 1.3", "~> 1.3.0"
+    refute_requirement_hash_equal "~> 1.3.0", "~> 1.3"
+
+    assert_requirement_hash_equal ["> 2", "~> 1.3", "~> 1.3.1"], ["~> 1.3.1", "~> 1.3", "> 2"]
+
+    assert_requirement_hash_equal ["> 2", "~> 1.3"], ["> 2.0", "~> 1.3"]
+    assert_requirement_hash_equal ["> 2.0", "~> 1.3"], ["> 2", "~> 1.3"]
+
+    assert_requirement_hash_equal "= 1.0", "= 1.0.0"
+    assert_requirement_hash_equal "= 1.1", "= 1.1.0"
+    assert_requirement_hash_equal "= 1", "= 1.0.0"
+
+    assert_requirement_hash_equal "1.0", "1.0.0"
+    assert_requirement_hash_equal "1.1", "1.1.0"
+    assert_requirement_hash_equal "1", "1.0.0"
+  end
+
+  class Exploit < RuntimeError
+  end
+
+  def self.exploit(arg)
+    raise Exploit, "arg = #{arg}"
+  end
+
+  def test_marshal_load_attack
+    wa = Net::WriteAdapter.allocate
+    wa.instance_variable_set(:@socket, self.class)
+    wa.instance_variable_set(:@method_id, :exploit)
+    request_set = Gem::RequestSet.allocate
+    request_set.instance_variable_set(:@git_set, "id")
+    request_set.instance_variable_set(:@sets, wa)
+    wa = Net::WriteAdapter.allocate
+    wa.instance_variable_set(:@socket, request_set)
+    wa.instance_variable_set(:@method_id, :resolve)
+    ent = Gem::Package::TarReader::Entry.allocate
+    ent.instance_variable_set(:@read, 0)
+    ent.instance_variable_set(:@header, "aaa")
+    io = Net::BufferedIO.allocate
+    io.instance_variable_set(:@io, ent)
+    io.instance_variable_set(:@debug_output, wa)
+    reader = Gem::Package::TarReader.allocate
+    reader.instance_variable_set(:@io, io)
+    requirement = Gem::Requirement.allocate
+    requirement.instance_variable_set(:@requirements, reader)
+    m = [Gem::SpecFetcher, Gem::Installer, requirement]
+    e = assert_raise(TypeError) do
+      Marshal.load(Marshal.dump(m))
+    end
+    assert_equal(e.message, "wrong @requirements")
+  end
+
   # Assert that two requirements are equal. Handles Gem::Requirements,
   # strings, arrays, numbers, and versions.
 
@@ -409,6 +476,13 @@ class TestGemRequirement < Gem::TestCase
       "#{requirement} is satisfied by #{version}"
   end
 
+  # Assert that two requirement hashes are equal. Handles Gem::Requirements,
+  # strings, arrays, numbers, and versions.
+
+  def assert_requirement_hash_equal(expected, actual)
+    assert_equal req(expected).hash, req(actual).hash
+  end
+
   # Refute the assumption that two requirements are equal.
 
   def refute_requirement_equal(unexpected, actual)
@@ -422,4 +496,9 @@ class TestGemRequirement < Gem::TestCase
       "#{requirement} is not satisfied by #{version}"
   end
 
+  # Refute the assumption that two requirements hashes are equal.
+
+  def refute_requirement_hash_equal(unexpected, actual)
+    refute_equal req(unexpected).hash, req(actual).hash
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolver < Gem::TestCase
-
   def setup
     super
 
@@ -26,10 +25,10 @@ class TestGemResolver < Gem::TestCase
   def assert_resolves_to(expected, resolver)
     actual = resolver.resolve
 
-    exp = expected.sort_by { |s| s.full_name }
-    act = actual.map { |a| a.spec.spec }.sort_by { |s| s.full_name }
+    exp = expected.sort_by {|s| s.full_name }
+    act = actual.map {|a| a.spec.spec }.sort_by {|s| s.full_name }
 
-    msg = "Set of gems was not the same: #{exp.map { |x| x.full_name}.inspect} != #{act.map { |x| x.full_name}.inspect}"
+    msg = "Set of gems was not the same: #{exp.map {|x| x.full_name }.inspect} != #{act.map {|x| x.full_name }.inspect}"
 
     assert_equal exp, act, msg
   rescue Gem::DependencyResolutionError => e
@@ -77,11 +76,11 @@ class TestGemResolver < Gem::TestCase
 
     assert_same index_set, composed
 
-    e = assert_raises ArgumentError do
+    e = assert_raise ArgumentError do
       @DR.compose_sets nil
     end
 
-    assert_equal 'one set in the composition must be non-nil', e.message
+    assert_equal "one set in the composition must be non-nil", e.message
   end
 
   def test_self_compose_sets_single
@@ -93,9 +92,9 @@ class TestGemResolver < Gem::TestCase
   end
 
   def test_requests
-    a1 = util_spec 'a', 1, 'b' => 2
+    a1 = util_spec "a", 1, "b" => 2
 
-    r1 = Gem::Resolver::DependencyRequest.new dep('a', '= 1'), nil
+    r1 = Gem::Resolver::DependencyRequest.new dep("a", "= 1"), nil
 
     act = Gem::Resolver::ActivationRequest.new a1, r1
 
@@ -105,18 +104,18 @@ class TestGemResolver < Gem::TestCase
 
     res.requests a1, act, reqs
 
-    assert_equal ['b (= 2)'], reqs.map { |req| req.to_s }
+    assert_equal ["b (= 2)"], reqs.map {|req| req.to_s }
   end
 
   def test_requests_development
-    a1 = util_spec 'a', 1, 'b' => 2
+    a1 = util_spec "a", 1, "b" => 2
 
     spec = Gem::Resolver::SpecSpecification.new nil, a1
     def spec.fetch_development_dependencies
       @called = true
     end
 
-    r1 = Gem::Resolver::DependencyRequest.new dep('a', '= 1'), nil
+    r1 = Gem::Resolver::DependencyRequest.new dep("a", "= 1"), nil
 
     act = Gem::Resolver::ActivationRequest.new spec, r1
 
@@ -127,15 +126,15 @@ class TestGemResolver < Gem::TestCase
 
     res.requests spec, act, reqs
 
-    assert_equal ['b (= 2)'], reqs.map { |req| req.to_s }
+    assert_equal ["b (= 2)"], reqs.map {|req| req.to_s }
 
     assert spec.instance_variable_defined? :@called
   end
 
   def test_requests_ignore_dependencies
-    a1 = util_spec 'a', 1, 'b' => 2
+    a1 = util_spec "a", 1, "b" => 2
 
-    r1 = Gem::Resolver::DependencyRequest.new dep('a', '= 1'), nil
+    r1 = Gem::Resolver::DependencyRequest.new dep("a", "= 1"), nil
 
     act = Gem::Resolver::ActivationRequest.new a1, r1
 
@@ -150,37 +149,37 @@ class TestGemResolver < Gem::TestCase
   end
 
   def test_resolve_conservative
-    a1_spec = util_spec 'a', 1
+    a1_spec = util_spec "a", 1
 
-    a2_spec = util_spec 'a', 2 do |s|
-      s.add_dependency 'b', 2
-      s.add_dependency 'c'
+    a2_spec = util_spec "a", 2 do |s|
+      s.add_dependency "b", 2
+      s.add_dependency "c"
     end
 
-    b1_spec = util_spec 'b', 1
-    b2_spec = util_spec 'b', 2
+    b1_spec = util_spec "b", 1
+    b2_spec = util_spec "b", 2
 
-    c1_spec = util_spec 'c', 1 do |s|
-      s.add_dependency 'd', 2
+    c1_spec = util_spec "c", 1 do |s|
+      s.add_dependency "d", 2
     end
 
-    c2_spec = util_spec 'c', 2 do |s|
-      s.add_dependency 'd', 2
+    c2_spec = util_spec "c", 2 do |s|
+      s.add_dependency "d", 2
     end
 
-    d1_spec = util_spec 'd', 1 do |s|
-      s.add_dependency 'e'
+    d1_spec = util_spec "d", 1 do |s|
+      s.add_dependency "e"
     end
 
-    d2_spec = util_spec 'd', 2 do |s|
-      s.add_dependency 'e'
+    d2_spec = util_spec "d", 2 do |s|
+      s.add_dependency "e"
     end
 
-    e1_spec = util_spec 'e', 1
-    e2_spec = util_spec 'e', 2
+    e1_spec = util_spec "e", 1
+    e2_spec = util_spec "e", 2
 
-    a_dep = make_dep 'a', '= 2'
-    e_dep = make_dep 'e'
+    a_dep = make_dep "a", "= 2"
+    e_dep = make_dep "e"
 
     # When requesting to install:
     # a-2, e
@@ -192,7 +191,7 @@ class TestGemResolver < Gem::TestCase
 
     # With the following gems already installed:
     # a-1, b-1, c-1, e-1
-    res.skip_gems = {'a' => [a1_spec], 'b' => [b1_spec], 'c' => [c1_spec], 'e' => [e1_spec]}
+    res.skip_gems = { "a" => [a1_spec], "b" => [b1_spec], "c" => [c1_spec], "e" => [e1_spec] }
 
     # Make sure the following gems end up getting used/installed/upgraded:
     # a-2 (upgraded)
@@ -204,17 +203,17 @@ class TestGemResolver < Gem::TestCase
   end
 
   def test_resolve_development
-    a_spec = util_spec 'a', 1 do |s|
-      s.add_development_dependency 'b'
+    a_spec = util_spec "a", 1 do |s|
+      s.add_development_dependency "b"
     end
 
-    b_spec = util_spec 'b', 1 do
-      |s| s.add_development_dependency 'c'
+    b_spec = util_spec "b", 1 do
+      |s| s.add_development_dependency "c"
     end
 
-    c_spec = util_spec 'c', 1
+    c_spec = util_spec "c", 1
 
-    a_dep = make_dep 'a', '= 1'
+    a_dep = make_dep "a", "= 1"
 
     deps = [a_dep]
 
@@ -228,24 +227,24 @@ class TestGemResolver < Gem::TestCase
   end
 
   def test_resolve_development_shallow
-    a_spec = util_spec 'a', 1 do |s|
-      s.add_development_dependency 'b'
-      s.add_runtime_dependency 'd'
+    a_spec = util_spec "a", 1 do |s|
+      s.add_development_dependency "b"
+      s.add_runtime_dependency "d"
     end
 
-    b_spec = util_spec 'b', 1 do |s|
-      s.add_development_dependency 'c'
+    b_spec = util_spec "b", 1 do |s|
+      s.add_development_dependency "c"
     end
 
-    c_spec = util_spec 'c', 1
+    c_spec = util_spec "c", 1
 
-    d_spec = util_spec 'd', 1 do |s|
-      s.add_development_dependency 'e'
+    d_spec = util_spec "d", 1 do |s|
+      s.add_development_dependency "e"
     end
 
-    e_spec = util_spec 'e', 1
+    e_spec = util_spec "e", 1
 
-    a_dep = make_dep 'a', '= 1'
+    a_dep = make_dep "a", "= 1"
 
     deps = [a_dep]
 
@@ -263,19 +262,19 @@ class TestGemResolver < Gem::TestCase
     @fetcher = Gem::FakeFetcher.new
     Gem::RemoteFetcher.fetcher = @fetcher
 
-    a_dep = make_dep 'a', '= 1'
+    a_dep = make_dep "a", "= 1"
 
     res = Gem::Resolver.new [a_dep], Gem::Resolver::IndexSet.new
 
-    e = assert_raises Gem::UnsatisfiableDepedencyError do
+    e = assert_raise Gem::UnsatisfiableDependencyError do
       res.resolve
     end
 
     refute_empty e.errors
   end
 
-  def test_no_overlap_specificly
-    a = util_spec "a", '1'
+  def test_no_overlap_specifically
+    a = util_spec "a", "1"
     b = util_spec "b", "1"
 
     ad = make_dep "a", "= 1"
@@ -291,7 +290,7 @@ class TestGemResolver < Gem::TestCase
   end
 
   def test_pulls_in_dependencies
-    a = util_spec "a", '1'
+    a = util_spec "a", "1"
     b = util_spec "b", "1", "c" => "= 1"
     c = util_spec "c", "1"
 
@@ -308,8 +307,8 @@ class TestGemResolver < Gem::TestCase
   end
 
   def test_picks_highest_version
-    a1 = util_spec "a", '1'
-    a2 = util_spec "a", '2'
+    a1 = util_spec "a", "1"
+    a2 = util_spec "a", "2"
 
     s = set(a1, a2)
 
@@ -322,17 +321,16 @@ class TestGemResolver < Gem::TestCase
 
   def test_picks_best_platform
     is      = Gem::Resolver::IndexSpecification
-    unknown = Gem::Platform.new 'unknown'
-    a2_p1   = a3_p2 = nil
+    unknown = Gem::Platform.new "unknown"
 
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2
+      fetcher.spec "a", 2
 
-      a2_p1 = fetcher.spec 'a', 2 do |s|
+      fetcher.spec "a", 2 do |s|
         s.platform = Gem::Platform.local
       end
 
-      a3_p2 = fetcher.spec 'a', 3 do |s|
+      fetcher.spec "a", 3 do |s|
         s.platform = unknown
       end
     end
@@ -343,9 +341,9 @@ class TestGemResolver < Gem::TestCase
 
     s = set
 
-    a2    = is.new s, 'a', v2, source, Gem::Platform::RUBY
-    a2_p1 = is.new s, 'a', v2, source, Gem::Platform.local.to_s
-    a3_p2 = is.new s, 'a', v3, source, unknown
+    a2    = is.new s, "a", v2, source, Gem::Platform::RUBY
+    a2_p1 = is.new s, "a", v2, source, Gem::Platform.local.to_s
+    a3_p2 = is.new s, "a", v3, source, unknown
 
     s.add a3_p2
     s.add a2_p1
@@ -358,6 +356,41 @@ class TestGemResolver < Gem::TestCase
     assert_resolves_to [a2_p1.spec], res
   end
 
+  def test_does_not_pick_musl_variants_on_non_musl_linux
+    util_set_arch "aarch64-linux" do
+      is = Gem::Resolver::IndexSpecification
+
+      linux_musl = Gem::Platform.new("aarch64-linux-musl")
+
+      spec_fetcher do |fetcher|
+        fetcher.spec "libv8-node", "15.14.0.1" do |s|
+          s.platform = Gem::Platform.local
+        end
+
+        fetcher.spec "libv8-node", "15.14.0.1" do |s|
+          s.platform = linux_musl
+        end
+      end
+
+      v15 = v("15.14.0.1")
+      source = Gem::Source.new @gem_repo
+
+      s = set
+
+      v15_linux = is.new s, "libv8-node", v15, source, Gem::Platform.local.to_s
+      v15_linux_musl = is.new s, "libv8-node", v15, source, linux_musl.to_s
+
+      s.add v15_linux
+      s.add v15_linux_musl
+
+      ad = make_dep "libv8-node", "= 15.14.0.1"
+
+      res = Gem::Resolver.new([ad], s)
+
+      assert_resolves_to [v15_linux.spec], res
+    end
+  end
+
   def test_only_returns_spec_once
     a1 = util_spec "a", "1", "c" => "= 1"
     b1 = util_spec "b", "1", "c" => "= 1"
@@ -446,7 +479,7 @@ class TestGemResolver < Gem::TestCase
 
     r = Gem::Resolver.new([ad, bd], s)
 
-    e = assert_raises Gem::DependencyResolutionError do
+    e = assert_raise Gem::DependencyResolutionError do
       r.resolve
     end
 
@@ -470,7 +503,7 @@ class TestGemResolver < Gem::TestCase
 
     r = Gem::Resolver.new([ad], set)
 
-    e = assert_raises Gem::UnsatisfiableDepedencyError do
+    e = assert_raise Gem::UnsatisfiableDependencyError do
       r.resolve
     end
 
@@ -487,7 +520,7 @@ class TestGemResolver < Gem::TestCase
 
     r = Gem::Resolver.new([ad], set(a1))
 
-    e = assert_raises Gem::UnsatisfiableDepedencyError do
+    e = assert_raise Gem::UnsatisfiableDependencyError do
       r.resolve
     end
 
@@ -500,7 +533,7 @@ class TestGemResolver < Gem::TestCase
 
     r = Gem::Resolver.new([ad], set(a1))
 
-    e = assert_raises Gem::UnsatisfiableDepedencyError do
+    e = assert_raise Gem::UnsatisfiableDependencyError do
       r.resolve
     end
 
@@ -510,14 +543,14 @@ class TestGemResolver < Gem::TestCase
 
   def test_raises_and_reports_an_implicit_request_properly
     a1 = util_spec "a", "1" do |s|
-      s.add_runtime_dependency 'b', '= 2'
+      s.add_runtime_dependency "b", "= 2"
     end
 
     ad = make_dep "a", "= 1"
 
     r = Gem::Resolver.new([ad], set(a1))
 
-    e = assert_raises Gem::UnsatisfiableDepedencyError do
+    e = assert_raise Gem::UnsatisfiableDependencyError do
       r.resolve
     end
 
@@ -540,21 +573,21 @@ class TestGemResolver < Gem::TestCase
 
     r = Gem::Resolver.new([ad, bd], s)
 
-    e = assert_raises Gem::DependencyResolutionError do
+    e = assert_raise Gem::DependencyResolutionError do
       r.resolve
     end
 
     dependency = e.conflict.dependency
 
-    assert_includes %w(a b), dependency.name
-    assert_equal req('>= 0'), dependency.requirement
+    assert_includes %w[a b], dependency.name
+    assert_equal req(">= 0"), dependency.requirement
 
     activated = e.conflict.activated
-    assert_equal 'c-1', activated.full_name
+    assert_equal "c-1", activated.full_name
 
-    assert_equal dep('c', '= 1'), activated.request.dependency
+    assert_equal dep("c", "= 1"), activated.request.dependency
 
-    assert_equal [dep('c', '>= 2'), dep('c', '= 1')],
+    assert_equal [dep("c", ">= 2"), dep("c", "= 1")],
                  e.conflict.conflicting_dependencies
   end
 
@@ -612,42 +645,42 @@ class TestGemResolver < Gem::TestCase
 
     r = Gem::Resolver.new([d1, d2, d3], s)
 
-    assert_raises Gem::DependencyResolutionError do
+    assert_raise Gem::DependencyResolutionError do
       r.resolve
     end
   end
 
   def test_resolve_conflict
-    a1 = util_spec 'a', 1
-    a2 = util_spec 'a', 2
+    a1 = util_spec "a", 1
+    a2 = util_spec "a", 2
 
-    b2 = util_spec 'b', 2, 'a' => '~> 2.0'
+    b2 = util_spec "b", 2, "a" => "~> 2.0"
 
     s = set a1, a2, b2
 
-    a_dep = dep 'a', '~> 1.0'
-    b_dep = dep 'b'
+    a_dep = dep "a", "~> 1.0"
+    b_dep = dep "b"
 
     r = Gem::Resolver.new [a_dep, b_dep], s
 
-    assert_raises Gem::DependencyResolutionError do
+    assert_raise Gem::DependencyResolutionError do
       r.resolve
     end
   end
 
   def test_resolve_bug_699
-    a1 = util_spec 'a', '1', 'b' => '= 2',
-                             'c' => '~> 1.0.3'
+    a1 = util_spec "a", "1", "b" => "= 2",
+                             "c" => "~> 1.0.3"
 
-    b1 = util_spec 'b', '2', 'c' => '~> 1.0'
+    b1 = util_spec "b", "2", "c" => "~> 1.0"
 
-    c1 = util_spec 'c', '1.0.9'
-    c2 = util_spec 'c', '1.1.0'
-    c3 = util_spec 'c', '1.2.0'
+    c1 = util_spec "c", "1.0.9"
+    c2 = util_spec "c", "1.1.0"
+    c3 = util_spec "c", "1.2.0"
 
     s = set a1, b1, c1, c2, c3
 
-    a_dep = dep 'a', '= 1'
+    a_dep = dep "a", "= 1"
 
     r = Gem::Resolver.new [a_dep], s
 
@@ -655,16 +688,16 @@ class TestGemResolver < Gem::TestCase
   end
 
   def test_resolve_rollback
-    a1 = util_spec 'a', 1
-    a2 = util_spec 'a', 2
+    a1 = util_spec "a", 1
+    a2 = util_spec "a", 2
 
-    b1 = util_spec 'b', 1, 'a' => '~> 1.0'
-    b2 = util_spec 'b', 2, 'a' => '~> 2.0'
+    b1 = util_spec "b", 1, "a" => "~> 1.0"
+    b2 = util_spec "b", 2, "a" => "~> 2.0"
 
     s = set a1, a2, b1, b2
 
-    a_dep = dep 'a', '~> 1.0'
-    b_dep = dep 'b'
+    a_dep = dep "a", "~> 1.0"
+    b_dep = dep "b"
 
     r = Gem::Resolver.new [a_dep, b_dep], s
 
@@ -712,15 +745,15 @@ class TestGemResolver < Gem::TestCase
   end
 
   def test_sorts_by_source_then_version
-    sourceA = Gem::Source.new 'http://example.com/a'
-    sourceB = Gem::Source.new 'http://example.com/b'
-    sourceC = Gem::Source.new 'http://example.com/c'
-
-    spec_A_1 = util_spec 'some-dep', '0.0.1'
-    spec_A_2 = util_spec 'some-dep', '1.0.0'
-    spec_B_1 = util_spec 'some-dep', '0.0.1'
-    spec_B_2 = util_spec 'some-dep', '0.0.2'
-    spec_C_1 = util_spec 'some-dep', '0.1.0'
+    sourceA = Gem::Source.new "http://example.com/a"
+    sourceB = Gem::Source.new "http://example.com/b"
+    sourceC = Gem::Source.new "http://example.com/c"
+
+    spec_A_1 = util_spec "some-dep", "0.0.1"
+    spec_A_2 = util_spec "some-dep", "1.0.0"
+    spec_B_1 = util_spec "some-dep", "0.0.1"
+    spec_B_2 = util_spec "some-dep", "0.0.2"
+    spec_C_1 = util_spec "some-dep", "0.1.0"
 
     set = StaticSet.new [
       Gem::Resolver::SpecSpecification.new(nil, spec_B_1, sourceB),
@@ -730,7 +763,7 @@ class TestGemResolver < Gem::TestCase
       Gem::Resolver::SpecSpecification.new(nil, spec_A_1, sourceA),
     ]
 
-    dependency = make_dep 'some-dep', '> 0'
+    dependency = make_dep "some-dep", "> 0"
 
     resolver = Gem::Resolver.new [dependency], set
 
@@ -740,14 +773,14 @@ class TestGemResolver < Gem::TestCase
   def test_select_local_platforms
     r = Gem::Resolver.new nil, nil
 
-    a1 = util_spec 'a', 1
+    a1 = util_spec "a", 1
 
-    a1_p1 = util_spec 'a', 1 do |s|
+    a1_p1 = util_spec "a", 1 do |s|
       s.platform = Gem::Platform.local
     end
 
-    a1_p2 = util_spec 'a', 1 do |s|
-      s.platform = 'unknown'
+    a1_p2 = util_spec "a", 1 do |s|
+      s.platform = "unknown"
     end
 
     selected = r.select_local_platforms [a1, a1_p1, a1_p2]
@@ -756,18 +789,18 @@ class TestGemResolver < Gem::TestCase
   end
 
   def test_search_for_local_platform_partial_string_match
-    a1 = util_spec 'a', 1
+    a1 = util_spec "a", 1
 
-    a1_p1 = util_spec 'a', 1 do |s|
+    a1_p1 = util_spec "a", 1 do |s|
       s.platform = Gem::Platform.local.os
     end
 
-    a1_p2 = util_spec 'a', 1 do |s|
-      s.platform = 'unknown'
+    a1_p2 = util_spec "a", 1 do |s|
+      s.platform = "unknown"
     end
 
     s = set(a1_p1, a1_p2, a1)
-    d = [make_dep('a')]
+    d = [make_dep("a")]
     r = Gem::Resolver.new(d, s)
 
     assert_resolves_to [a1_p1], r
@@ -782,12 +815,11 @@ class TestGemResolver < Gem::TestCase
 
     r = Gem::Resolver.new([ad], set(a1))
 
-    e = assert_raises Gem::UnsatisfiableDepedencyError do
+    e = assert_raise Gem::UnsatisfiableDependencyError do
       r.resolve
     end
 
     assert_match "No match for 'a (= 1)' on this platform. Found: c-p-1",
                  e.message
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_activation_request.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_activation_request.rb
@@ -1,19 +1,18 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverActivationRequest < Gem::TestCase
-
   def setup
     super
 
     @DR = Gem::Resolver
 
-    @dep = @DR::DependencyRequest.new dep('a', '>= 0'), nil
+    @dep = @DR::DependencyRequest.new dep("a", ">= 0"), nil
 
     source   = Gem::Source::Local.new
     platform = Gem::Platform::RUBY
 
-    @a3 = @DR::IndexSpecification.new nil, 'a', v(3), source, platform
+    @a3 = @DR::IndexSpecification.new nil, "a", v(3), source, platform
 
     @req = @DR::ActivationRequest.new @a3, @dep
   end
@@ -21,7 +20,7 @@ class TestGemResolverActivationRequest <
   def test_development_eh
     refute @req.development?
 
-    dep_req = @DR::DependencyRequest.new dep('a', '>= 0', :development), nil
+    dep_req = @DR::DependencyRequest.new dep("a", ">= 0", :development), nil
 
     act_req = @DR::ActivationRequest.new @a3, dep_req
 
@@ -29,8 +28,8 @@ class TestGemResolverActivationRequest <
   end
 
   def test_inspect
-    assert_match 'a-3',                         @req.inspect
-    assert_match 'from a (>= 0)',               @req.inspect
+    assert_match "a-3",                         @req.inspect
+    assert_match "from a (>= 0)",               @req.inspect
   end
 
   def test_installed_eh
@@ -40,5 +39,4 @@ class TestGemResolverActivationRequest <
 
     assert @req.installed?
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_api_set.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_api_set.rb
@@ -1,56 +1,84 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverAPISet < Gem::TestCase
-
   def setup
     super
 
     @DR = Gem::Resolver
-    @dep_uri = URI "#{@gem_repo}api/v1/dependencies"
+    @dep_uri = URI "#{@gem_repo}info/"
   end
 
   def test_initialize
     set = @DR::APISet.new
 
-    assert_equal URI('https://rubygems.org/api/v1/dependencies'), set.dep_uri
-    assert_equal URI('https://rubygems.org'),                     set.uri
-    assert_equal Gem::Source.new(URI('https://rubygems.org')),    set.source
+    assert_equal URI("https://index.rubygems.org/info/"),            set.dep_uri
+    assert_equal URI("https://index.rubygems.org/"),                 set.uri
+    assert_equal Gem::Source.new(URI("https://index.rubygems.org")), set.source
   end
 
   def test_initialize_deeper_uri
-    set = @DR::APISet.new 'https://rubygemsserver.com/mygems/api/v1/dependencies'
+    set = @DR::APISet.new "https://rubygemsserver.com/mygems/info"
 
-    assert_equal URI('https://rubygemsserver.com/mygems/api/v1/dependencies'), set.dep_uri
-    assert_equal URI('https://rubygemsserver.com/mygems/'),                    set.uri
-    assert_equal Gem::Source.new(URI('https://rubygemsserver.com/mygems/')),    set.source
+    assert_equal URI("https://rubygemsserver.com/mygems/info"),       set.dep_uri
+    assert_equal URI("https://rubygemsserver.com/"),                  set.uri
+    assert_equal Gem::Source.new(URI("https://rubygemsserver.com/")), set.source
   end
 
   def test_initialize_uri
     set = @DR::APISet.new @dep_uri
 
-    assert_equal URI("#{@gem_repo}api/v1/dependencies"), set.dep_uri
-    assert_equal URI("#{@gem_repo}"),                     set.uri
+    assert_equal URI("#{@gem_repo}info/"), set.dep_uri
+    assert_equal URI("#{@gem_repo}"), set.uri
   end
 
   def test_find_all
     spec_fetcher
 
     data = [
-      { :name         => 'a',
-        :number       => '1',
-        :platform     => 'ruby',
-        :dependencies => [], },
+      { :name         => "a",
+        :number       => "1",
+        :platform     => "ruby",
+        :dependencies => [] },
     ]
 
-    @fetcher.data["#{@dep_uri}?gems=a"] = Marshal.dump data
+    @fetcher.data["#{@dep_uri}a"] = "---\n1  "
 
     set = @DR::APISet.new @dep_uri
 
-    a_dep = @DR::DependencyRequest.new dep('a'), nil
+    a_dep = @DR::DependencyRequest.new dep("a"), nil
 
     expected = [
-      @DR::APISpecification.new(set, data.first)
+      @DR::APISpecification.new(set, data.first),
+    ]
+
+    assert_equal expected, set.find_all(a_dep)
+  end
+
+  def test_find_all_prereleases
+    spec_fetcher
+
+    data = [
+      { :name         => "a",
+        :number       => "1",
+        :platform     => "ruby",
+        :dependencies => [] },
+      { :name         => "a",
+        :number       => "2.a",
+        :platform     => "ruby",
+        :dependencies => [] },
+    ]
+
+    @fetcher.data["#{@dep_uri}a"] = "---\n1\n2.a"
+
+    set = @DR::APISet.new @dep_uri
+    set.prerelease = true
+
+    a_dep = @DR::DependencyRequest.new dep("a"), nil
+
+    expected = [
+      @DR::APISpecification.new(set, data.first),
+      @DR::APISpecification.new(set, data.last),
     ]
 
     assert_equal expected, set.find_all(a_dep)
@@ -60,34 +88,34 @@ class TestGemResolverAPISet < Gem::TestC
     spec_fetcher
 
     data = [
-      { :name         => 'a',
-        :number       => '1',
-        :platform     => 'ruby',
-        :dependencies => [], },
+      { :name         => "a",
+        :number       => "1",
+        :platform     => "ruby",
+        :dependencies => [] },
     ]
 
-    @fetcher.data["#{@dep_uri}?gems=a"] = Marshal.dump data
+    @fetcher.data["#{@dep_uri}a"] = "---\n1  "
 
     set = @DR::APISet.new @dep_uri
 
-    a_dep = @DR::DependencyRequest.new dep('a'), nil
+    a_dep = @DR::DependencyRequest.new dep("a"), nil
 
     set.prefetch [a_dep]
 
     expected = [
-      @DR::APISpecification.new(set, data.first)
+      @DR::APISpecification.new(set, data.first),
     ]
 
     assert_equal expected, set.find_all(a_dep)
 
-    @fetcher.data.delete "#{@dep_uri}?gems=a"
+    @fetcher.data.delete "#{@dep_uri}a"
   end
 
   def test_find_all_local
     set = @DR::APISet.new @dep_uri
     set.remote = false
 
-    a_dep = @DR::DependencyRequest.new dep('a'), nil
+    a_dep = @DR::DependencyRequest.new dep("a"), nil
 
     assert_empty set.find_all(a_dep)
   end
@@ -95,15 +123,15 @@ class TestGemResolverAPISet < Gem::TestC
   def test_find_all_missing
     spec_fetcher
 
-    @fetcher.data["#{@dep_uri}?gems=a"] = Marshal.dump []
+    @fetcher.data["#{@dep_uri}a"] = "---"
 
     set = @DR::APISet.new @dep_uri
 
-    a_dep = @DR::DependencyRequest.new dep('a'), nil
+    a_dep = @DR::DependencyRequest.new dep("a"), nil
 
     assert_empty set.find_all(a_dep)
 
-    @fetcher.data.delete "#{@dep_uri}?gems=a"
+    @fetcher.data.delete "#{@dep_uri}a"
 
     assert_empty set.find_all(a_dep)
   end
@@ -111,48 +139,34 @@ class TestGemResolverAPISet < Gem::TestC
   def test_prefetch
     spec_fetcher
 
-    data = [
-      { :name         => 'a',
-        :number       => '1',
-        :platform     => 'ruby',
-        :dependencies => [], },
-    ]
-
-    @fetcher.data["#{@dep_uri}?gems=a,b"] = Marshal.dump data
-    @fetcher.data["#{@dep_uri}?gems=b"]   = Marshal.dump []
+    @fetcher.data["#{@dep_uri}a"] = "---\n1  \n"
+    @fetcher.data["#{@dep_uri}b"] = "---"
 
     set = @DR::APISet.new @dep_uri
 
-    a_dep = @DR::DependencyRequest.new dep('a'), nil
-    b_dep = @DR::DependencyRequest.new dep('b'), nil
+    a_dep = @DR::DependencyRequest.new dep("a"), nil
+    b_dep = @DR::DependencyRequest.new dep("b"), nil
 
     set.prefetch [a_dep, b_dep]
 
-    assert_equal %w[a-1], set.find_all(a_dep).map { |s| s.full_name }
+    assert_equal %w[a-1], set.find_all(a_dep).map {|s| s.full_name }
     assert_empty          set.find_all(b_dep)
   end
 
   def test_prefetch_cache
     spec_fetcher
 
-    data = [
-      { :name         => 'a',
-        :number       => '1',
-        :platform     => 'ruby',
-        :dependencies => [], },
-    ]
-
-    @fetcher.data["#{@dep_uri}?gems=a"] = Marshal.dump data
+    @fetcher.data["#{@dep_uri}a"] = "---\n1  \n"
 
     set = @DR::APISet.new @dep_uri
 
-    a_dep = @DR::DependencyRequest.new dep('a'), nil
-    b_dep = @DR::DependencyRequest.new dep('b'), nil
+    a_dep = @DR::DependencyRequest.new dep("a"), nil
+    b_dep = @DR::DependencyRequest.new dep("b"), nil
 
     set.prefetch [a_dep]
 
-    @fetcher.data.delete "#{@dep_uri}?gems=a"
-    @fetcher.data["#{@dep_uri}?gems=b"]   = Marshal.dump []
+    @fetcher.data.delete "#{@dep_uri}a"
+    @fetcher.data["#{@dep_uri}?b"] = "---"
 
     set.prefetch [a_dep, b_dep]
   end
@@ -160,23 +174,18 @@ class TestGemResolverAPISet < Gem::TestC
   def test_prefetch_cache_missing
     spec_fetcher
 
-    data = [
-      { :name         => 'a',
-        :number       => '1',
-        :platform     => 'ruby',
-        :dependencies => [], },
-    ]
-
-    @fetcher.data["#{@dep_uri}?gems=a,b"] = Marshal.dump data
+    @fetcher.data["#{@dep_uri}a"] = "---\n1  \n"
+    @fetcher.data["#{@dep_uri}b"] = "---"
 
     set = @DR::APISet.new @dep_uri
 
-    a_dep = @DR::DependencyRequest.new dep('a'), nil
-    b_dep = @DR::DependencyRequest.new dep('b'), nil
+    a_dep = @DR::DependencyRequest.new dep("a"), nil
+    b_dep = @DR::DependencyRequest.new dep("b"), nil
 
     set.prefetch [a_dep, b_dep]
 
-    @fetcher.data.delete "#{@dep_uri}?gems=a,b"
+    @fetcher.data.delete "#{@dep_uri}a"
+    @fetcher.data.delete "#{@dep_uri}b"
 
     set.prefetch [a_dep, b_dep]
   end
@@ -184,25 +193,17 @@ class TestGemResolverAPISet < Gem::TestC
   def test_prefetch_local
     spec_fetcher
 
-    data = [
-      { :name         => 'a',
-        :number       => '1',
-        :platform     => 'ruby',
-        :dependencies => [], },
-    ]
-
-    @fetcher.data["#{@dep_uri}?gems=a,b"] = Marshal.dump data
-    @fetcher.data["#{@dep_uri}?gems=b"]   = Marshal.dump []
+    @fetcher.data["#{@dep_uri}a"] = "---\n1  \n"
+    @fetcher.data["#{@dep_uri}b"] = "---"
 
     set = @DR::APISet.new @dep_uri
     set.remote = false
 
-    a_dep = @DR::DependencyRequest.new dep('a'), nil
-    b_dep = @DR::DependencyRequest.new dep('b'), nil
+    a_dep = @DR::DependencyRequest.new dep("a"), nil
+    b_dep = @DR::DependencyRequest.new dep("b"), nil
 
     set.prefetch [a_dep, b_dep]
 
     assert_empty set.instance_variable_get :@data
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_api_specification.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_api_specification.rb
@@ -1,29 +1,28 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverAPISpecification < Gem::TestCase
-
   def test_initialize
     set = Gem::Resolver::APISet.new
     data = {
-      :name     => 'rails',
-      :number   => '3.0.3',
+      :name     => "rails",
+      :number   => "3.0.3",
       :platform => Gem::Platform.local.to_s,
       :dependencies => [
-        ['bundler',  '~> 1.0'],
-        ['railties', '= 3.0.3'],
+        ["bundler",  "~> 1.0"],
+        ["railties", "= 3.0.3"],
       ],
     }
 
     spec = Gem::Resolver::APISpecification.new set, data
 
-    assert_equal 'rails',                   spec.name
-    assert_equal Gem::Version.new('3.0.3'), spec.version
+    assert_equal "rails",                   spec.name
+    assert_equal Gem::Version.new("3.0.3"), spec.version
     assert_equal Gem::Platform.local,       spec.platform
 
     expected = [
-      Gem::Dependency.new('bundler',  '~> 1.0'),
-      Gem::Dependency.new('railties', '= 3.0.3'),
+      Gem::Dependency.new("bundler",  "~> 1.0"),
+      Gem::Dependency.new("railties", "= 3.0.3"),
     ]
 
     assert_equal expected, spec.dependencies
@@ -31,26 +30,26 @@ class TestGemResolverAPISpecification < 
 
   def test_fetch_development_dependencies
     specs = spec_fetcher do |fetcher|
-      fetcher.spec 'rails', '3.0.3' do |s|
-        s.add_runtime_dependency 'bundler',  '~> 1.0'
-        s.add_runtime_dependency 'railties', '= 3.0.3'
-        s.add_development_dependency 'a',    '= 1'
+      fetcher.spec "rails", "3.0.3" do |s|
+        s.add_runtime_dependency "bundler",  "~> 1.0"
+        s.add_runtime_dependency "railties", "= 3.0.3"
+        s.add_development_dependency "a",    "= 1"
       end
     end
 
-    rails = specs['rails-3.0.3']
+    rails = specs["rails-3.0.3"]
 
-    repo = @gem_repo + 'api/v1/dependencies'
+    repo = @gem_repo + "info"
 
     set = Gem::Resolver::APISet.new repo
 
     data = {
-      :name     => 'rails',
-      :number   => '3.0.3',
-      :platform => 'ruby',
+      :name     => "rails",
+      :number   => "3.0.3",
+      :platform => "ruby",
       :dependencies => [
-        ['bundler',  '~> 1.0'],
-        ['railties', '= 3.0.3'],
+        ["bundler",  "~> 1.0"],
+        ["railties", "= 3.0.3"],
       ],
     }
 
@@ -61,9 +60,9 @@ class TestGemResolverAPISpecification < 
     spec.fetch_development_dependencies
 
     expected = [
-      Gem::Dependency.new('bundler',  '~> 1.0'),
-      Gem::Dependency.new('railties', '= 3.0.3'),
-      Gem::Dependency.new('a',        '= 1', :development),
+      Gem::Dependency.new("bundler",  "~> 1.0"),
+      Gem::Dependency.new("railties", "= 3.0.3"),
+      Gem::Dependency.new("a",        "= 1", :development),
     ]
 
     assert_equal expected, spec.dependencies
@@ -72,9 +71,9 @@ class TestGemResolverAPISpecification < 
   def test_installable_platform_eh
     set = Gem::Resolver::APISet.new
     data = {
-      :name     => 'a',
-      :number   => '1',
-      :platform => 'ruby',
+      :name     => "a",
+      :number   => "1",
+      :platform => "ruby",
       :dependencies => [],
     }
 
@@ -83,9 +82,9 @@ class TestGemResolverAPISpecification < 
     assert a_spec.installable_platform?
 
     data = {
-      :name     => 'b',
-      :number   => '1',
-      :platform => 'cpu-other_platform-1',
+      :name     => "b",
+      :number   => "1",
+      :platform => "cpu-other_platform-1",
       :dependencies => [],
     }
 
@@ -94,8 +93,8 @@ class TestGemResolverAPISpecification < 
     refute b_spec.installable_platform?
 
     data = {
-      :name     => 'c',
-      :number   => '1',
+      :name     => "c",
+      :number   => "1",
       :platform => Gem::Platform.local.to_s,
       :dependencies => [],
     }
@@ -108,9 +107,9 @@ class TestGemResolverAPISpecification < 
   def test_source
     set = Gem::Resolver::APISet.new
     data = {
-      :name         => 'a',
-      :number       => '1',
-      :platform     => 'ruby',
+      :name         => "a",
+      :number       => "1",
+      :platform     => "ruby",
       :dependencies => [],
     }
 
@@ -121,15 +120,15 @@ class TestGemResolverAPISpecification < 
 
   def test_spec
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
-    dep_uri = URI(@gem_repo) + 'api/v1/dependencies'
+    dep_uri = URI(@gem_repo) + "info"
     set = Gem::Resolver::APISet.new dep_uri
     data = {
-      :name         => 'a',
-      :number       => '1',
-      :platform     => 'ruby',
+      :name         => "a",
+      :number       => "1",
+      :platform     => "ruby",
       :dependencies => [],
     }
 
@@ -138,22 +137,22 @@ class TestGemResolverAPISpecification < 
     spec = api_spec.spec
 
     assert_kind_of Gem::Specification, spec
-    assert_equal 'a-1', spec.full_name
+    assert_equal "a-1", spec.full_name
   end
 
   def test_spec_jruby_platform
     spec_fetcher do |fetcher|
-      fetcher.gem 'j', 1 do |spec|
-        spec.platform = 'jruby'
+      fetcher.gem "j", 1 do |spec|
+        spec.platform = "jruby"
       end
     end
 
-    dep_uri = URI(@gem_repo) + 'api/v1/dependencies'
+    dep_uri = URI(@gem_repo) + "info"
     set = Gem::Resolver::APISet.new dep_uri
     data = {
-      :name         => 'j',
-      :number       => '1',
-      :platform     => 'jruby',
+      :name         => "j",
+      :number       => "1",
+      :platform     => "jruby",
       :dependencies => [],
     }
 
@@ -162,7 +161,6 @@ class TestGemResolverAPISpecification < 
     spec = api_spec.spec
 
     assert_kind_of Gem::Specification, spec
-    assert_equal 'j-1-java', spec.full_name
+    assert_equal "j-1-java", spec.full_name
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_best_set.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_best_set.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverBestSet < Gem::TestCase
-
   def setup
     super
 
@@ -17,53 +16,53 @@ class TestGemResolverBestSet < Gem::Test
 
   def test_find_all_index
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', 2
-      fetcher.spec 'b', 1
+      fetcher.spec "a", 1
+      fetcher.spec "a", 2
+      fetcher.spec "b", 1
     end
 
     set = @DR::BestSet.new
 
-    dependency = dep 'a', '~> 1'
+    dependency = dep "a", "~> 1"
 
     req = @DR::DependencyRequest.new dependency, nil
 
     found = set.find_all req
 
-    assert_equal %w[a-1], found.map { |s| s.full_name }
+    assert_equal %w[a-1], found.map {|s| s.full_name }
   end
 
   def test_find_all_fallback
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
     set = @DR::BestSet.new
 
-    api_uri = URI(@gem_repo) + './api/v1/dependencies'
+    api_uri = URI(@gem_repo)
 
     set.sets << Gem::Resolver::APISet.new(api_uri)
 
-    dependency = dep 'a', '~> 1'
+    dependency = dep "a", "~> 1"
 
     req = @DR::DependencyRequest.new dependency, nil
 
     found = set.find_all req
 
-    assert_equal %w[a-1], found.map { |s| s.full_name }
+    assert_equal %w[a-1], found.map {|s| s.full_name }
   end
 
   def test_find_all_local
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', 2
-      fetcher.spec 'b', 1
+      fetcher.spec "a", 1
+      fetcher.spec "a", 2
+      fetcher.spec "b", 1
     end
 
     set = @DR::BestSet.new
     set.remote = false
 
-    dependency = dep 'a', '~> 1'
+    dependency = dep "a", "~> 1"
 
     req = @DR::DependencyRequest.new dependency, nil
 
@@ -74,7 +73,7 @@ class TestGemResolverBestSet < Gem::Test
 
   def test_prefetch
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
     set = @DR::BestSet.new
@@ -86,7 +85,7 @@ class TestGemResolverBestSet < Gem::Test
 
   def test_prefetch_local
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
     set = @DR::BestSet.new
@@ -100,14 +99,14 @@ class TestGemResolverBestSet < Gem::Test
   def test_replace_failed_api_set
     set = @DR::BestSet.new
 
-    api_uri = URI(@gem_repo) + './api/v1/dependencies'
+    api_uri = URI(@gem_repo) + "./info/"
     api_set = Gem::Resolver::APISet.new api_uri
 
     set.sets << api_set
 
-    error_uri = api_uri + '?gems=a'
+    error_uri = api_uri + "a"
 
-    error = Gem::RemoteFetcher::FetchError.new 'bogus', error_uri
+    error = Gem::RemoteFetcher::FetchError.new "bogus", error_uri
 
     set.replace_failed_api_set error
 
@@ -125,13 +124,35 @@ class TestGemResolverBestSet < Gem::Test
 
     set.sets << index_set
 
-    error = Gem::RemoteFetcher::FetchError.new 'bogus', @gem_repo
+    error = Gem::RemoteFetcher::FetchError.new "bogus", @gem_repo
 
-    e = assert_raises Gem::RemoteFetcher::FetchError do
+    e = assert_raise Gem::RemoteFetcher::FetchError do
       set.replace_failed_api_set error
     end
 
     assert_equal error, e
   end
 
+  def test_replace_failed_api_set_uri_with_credentials
+    set = @DR::BestSet.new
+
+    api_uri = URI(@gem_repo) + "./info/"
+    api_uri.user = "user"
+    api_uri.password = "pass"
+    api_set = Gem::Resolver::APISet.new api_uri
+
+    set.sets << api_set
+
+    error_uri = api_uri + "a"
+
+    error = Gem::RemoteFetcher::FetchError.new "bogus", error_uri
+
+    set.replace_failed_api_set error
+
+    assert_equal 1, set.sets.size
+
+    refute_includes set.sets, api_set
+
+    assert_kind_of Gem::Resolver::IndexSet, set.sets.first
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_composed_set.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_composed_set.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverComposedSet < Gem::TestCase
-
   def test_errors
     index_set   = Gem::Resolver::IndexSet.new
     current_set = Gem::Resolver::CurrentSet.new
@@ -41,5 +40,4 @@ class TestGemResolverComposedSet < Gem::
     refute best_set.remote?
     refute current_set.remote?
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_conflict.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_conflict.rb
@@ -1,17 +1,16 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverConflict < Gem::TestCase
-
   def test_explanation
     root  =
-      dependency_request dep('net-ssh', '>= 2.0.13'), 'rye', '0.9.8'
+      dependency_request dep("net-ssh", ">= 2.0.13"), "rye", "0.9.8"
     child =
-      dependency_request dep('net-ssh', '>= 2.6.5'), 'net-ssh', '2.2.2', root
+      dependency_request dep("net-ssh", ">= 2.6.5"), "net-ssh", "2.2.2", root
 
-    dep = Gem::Resolver::DependencyRequest.new dep('net-ssh', '>= 2.0.13'), nil
+    dep = Gem::Resolver::DependencyRequest.new dep("net-ssh", ">= 2.0.13"), nil
 
-    spec = util_spec 'net-ssh', '2.2.2'
+    spec = util_spec "net-ssh", "2.2.2"
     active =
       Gem::Resolver::ActivationRequest.new spec, dep
 
@@ -38,10 +37,10 @@ class TestGemResolverConflict < Gem::Tes
   def test_explanation_user_request
     @DR = Gem::Resolver
 
-    spec = util_spec 'a', 2
+    spec = util_spec "a", 2
 
-    a1_req = @DR::DependencyRequest.new dep('a', '= 1'), nil
-    a2_req = @DR::DependencyRequest.new dep('a', '= 2'), nil
+    a1_req = @DR::DependencyRequest.new dep("a", "= 1"), nil
+    a2_req = @DR::DependencyRequest.new dep("a", "= 2"), nil
 
     activated = @DR::ActivationRequest.new spec, a2_req
 
@@ -64,20 +63,19 @@ class TestGemResolverConflict < Gem::Tes
 
   def test_request_path
     root  =
-      dependency_request dep('net-ssh', '>= 2.0.13'), 'rye', '0.9.8'
+      dependency_request dep("net-ssh", ">= 2.0.13"), "rye", "0.9.8"
 
     child =
-      dependency_request dep('other', '>= 1.0'), 'net-ssh', '2.2.2', root
+      dependency_request dep("other", ">= 1.0"), "net-ssh", "2.2.2", root
 
     conflict =
       Gem::Resolver::Conflict.new nil, nil
 
     expected = [
-      'net-ssh (>= 2.0.13), 2.2.2 activated',
-      'rye (= 0.9.8), 0.9.8 activated'
+      "net-ssh (>= 2.0.13), 2.2.2 activated",
+      "rye (= 0.9.8), 0.9.8 activated",
     ]
 
     assert_equal expected, conflict.request_path(child.requester)
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_dependency_request.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_dependency_request.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverDependencyRequest < Gem::TestCase
-
   def setup
     super
 
@@ -10,13 +9,13 @@ class TestGemResolverDependencyRequest <
   end
 
   def test_development_eh
-    a_dep = dep 'a', '>= 1'
+    a_dep = dep "a", ">= 1"
 
     a_dep_req = @DR.new a_dep, nil
 
     refute a_dep_req.development?
 
-    b_dep = dep 'b', '>= 1', :development
+    b_dep = dep "b", ">= 1", :development
 
     b_dep_req = @DR.new b_dep, nil
 
@@ -24,8 +23,8 @@ class TestGemResolverDependencyRequest <
   end
 
   def test_match_eh
-    spec = util_spec 'a', 1
-    dependency = dep 'a', '>= 1'
+    spec = util_spec "a", 1
+    dependency = dep "a", ">= 1"
 
     dr = @DR.new dependency, nil
 
@@ -33,31 +32,31 @@ class TestGemResolverDependencyRequest <
   end
 
   def test_match_eh_prerelease
-    spec = util_spec 'a', '1.a'
+    spec = util_spec "a", "1.a"
 
-    a_dep = dep 'a', '>= 1'
+    a_dep = dep "a", ">= 1"
     a_dr = @DR.new a_dep, nil
 
     refute a_dr.match? spec
 
-    a_pre_dep = dep 'a', '>= 1.a'
+    a_pre_dep = dep "a", ">= 1.a"
     a_pre_dr = @DR.new a_pre_dep, nil
 
     assert a_pre_dr.match? spec
   end
 
   def test_match_eh_prerelease_allow_prerelease
-    spec = util_spec 'a', '2.a'
+    spec = util_spec "a", "2.a"
 
-    a_dep = dep 'a', '>= 1'
+    a_dep = dep "a", ">= 1"
     a_dr = @DR.new a_dep, nil
 
     assert a_dr.match? spec, true
   end
 
   def test_matches_spec_eh
-    spec = util_spec 'a', 1
-    dependency = dep 'a', '>= 1'
+    spec = util_spec "a", 1
+    dependency = dep "a", ">= 1"
 
     dr = @DR.new dependency, nil
 
@@ -65,20 +64,19 @@ class TestGemResolverDependencyRequest <
   end
 
   def test_matches_spec_eh_prerelease
-    spec = util_spec 'a', '1.a'
+    spec = util_spec "a", "1.a"
 
-    dependency = dep 'a', '>= 0'
+    dependency = dep "a", ">= 0"
     dr = @DR.new dependency, nil
 
     assert dr.matches_spec? spec
   end
 
   def test_requirement
-    dependency = dep 'a', '>= 1'
+    dependency = dep "a", ">= 1"
 
     dr = @DR.new dependency, nil
 
     assert_equal dependency, dr.dependency
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_git_set.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_git_set.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverGitSet < Gem::TestCase
-
   def setup
     super
 
@@ -14,9 +13,9 @@ class TestGemResolverGitSet < Gem::TestC
   def test_add_git_gem
     name, version, repository, = git_gem
 
-    @set.add_git_gem name, repository, 'master', false
+    @set.add_git_gem name, repository, "master", false
 
-    dependency = dep 'a'
+    dependency = dep "a"
 
     specs = @set.find_all dependency
 
@@ -28,9 +27,9 @@ class TestGemResolverGitSet < Gem::TestC
   def test_add_git_gem_submodules
     name, _, repository, = git_gem
 
-    @set.add_git_gem name, repository, 'master', true
+    @set.add_git_gem name, repository, "master", true
 
-    dependency = dep 'a'
+    dependency = dep "a"
 
     refute_empty @set.find_all dependency
 
@@ -42,7 +41,7 @@ class TestGemResolverGitSet < Gem::TestC
 
     @set.add_git_spec name, version, repository, revision, true
 
-    dependency = dep 'a'
+    dependency = dep "a"
 
     specs = @set.find_all dependency
 
@@ -52,15 +51,15 @@ class TestGemResolverGitSet < Gem::TestC
 
     assert @set.need_submodules[repository]
 
-    refute_path_exists spec.source.repo_cache_dir
+    assert_path_not_exist spec.source.repo_cache_dir
   end
 
   def test_find_all
     name, _, repository, = git_gem
 
-    @set.add_git_gem name, repository, 'master', false
+    @set.add_git_gem name, repository, "master", false
 
-    dependency = dep 'a', '~> 1.0'
+    dependency = dep "a", "~> 1.0"
     req = Gem::Resolver::DependencyRequest.new dependency, nil
     @reqs.add req
 
@@ -68,16 +67,16 @@ class TestGemResolverGitSet < Gem::TestC
 
     found = @set.find_all dependency
 
-    assert_equal [@set.specs['a']], found
+    assert_equal [@set.specs["a"]], found
   end
 
   def test_find_all_local
     name, _, repository, = git_gem
 
-    @set.add_git_gem name, repository, 'master', false
+    @set.add_git_gem name, repository, "master", false
     @set.remote = false
 
-    dependency = dep 'a', '~> 1.0'
+    dependency = dep "a", "~> 1.0"
     req = Gem::Resolver::DependencyRequest.new dependency, nil
     @reqs.add req
 
@@ -87,11 +86,11 @@ class TestGemResolverGitSet < Gem::TestC
   end
 
   def test_find_all_prerelease
-    name, _, repository, = git_gem 'a', '1.a'
+    name, _, repository, = git_gem "a", "1.a"
 
-    @set.add_git_gem name, repository, 'master', false
+    @set.add_git_gem name, repository, "master", false
 
-    dependency = dep 'a', '>= 0'
+    dependency = dep "a", ">= 0"
     req = Gem::Resolver::DependencyRequest.new dependency, nil
     @reqs.add req
 
@@ -101,7 +100,7 @@ class TestGemResolverGitSet < Gem::TestC
 
     assert_empty found
 
-    dependency = dep 'a', '>= 0.a'
+    dependency = dep "a", ">= 0.a"
     req = Gem::Resolver::DependencyRequest.new dependency, nil
     @reqs.add req
 
@@ -123,7 +122,7 @@ class TestGemResolverGitSet < Gem::TestC
   def test_prefetch
     name, _, repository, = git_gem
 
-    @set.add_git_gem name, repository, 'master', false
+    @set.add_git_gem name, repository, "master", false
 
     dependency = dep name
     req = Gem::Resolver::DependencyRequest.new dependency, nil
@@ -137,7 +136,7 @@ class TestGemResolverGitSet < Gem::TestC
   def test_prefetch_cache
     name, _, repository, = git_gem
 
-    @set.add_git_gem name, repository, 'master', false
+    @set.add_git_gem name, repository, "master", false
 
     dependency = dep name
     req = Gem::Resolver::DependencyRequest.new dependency, nil
@@ -155,21 +154,21 @@ class TestGemResolverGitSet < Gem::TestC
   def test_prefetch_filter
     name, _, repository, = git_gem
 
-    @set.add_git_gem name, repository, 'master', false
+    @set.add_git_gem name, repository, "master", false
 
-    dependency = dep 'b'
+    dependency = dep "b"
     req = Gem::Resolver::DependencyRequest.new dependency, nil
     @reqs.add req
 
     @set.prefetch @reqs
 
-    refute_empty @set.specs, 'the git source does not filter'
+    refute_empty @set.specs, "the git source does not filter"
   end
 
   def test_prefetch_root_dir
     name, _, repository, = git_gem
 
-    @set.add_git_gem name, repository, 'master', false
+    @set.add_git_gem name, repository, "master", false
 
     dependency = dep name
     req = Gem::Resolver::DependencyRequest.new dependency, nil
@@ -185,5 +184,4 @@ class TestGemResolverGitSet < Gem::TestC
 
     assert_equal "#{@gemhome}2", spec.source.root_dir
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_git_specification.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_git_specification.rb
@@ -1,14 +1,13 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/installer'
+require_relative "helper"
+require "rubygems/installer"
 
 class TestGemResolverGitSpecification < Gem::TestCase
-
   def setup
     super
 
     @set  = Gem::Resolver::GitSet.new
-    @spec = Gem::Specification.new 'a', 1
+    @spec = Gem::Specification.new "a", 1
   end
 
   def test_equals2
@@ -16,7 +15,7 @@ class TestGemResolverGitSpecification < 
 
     assert_equal g_spec_a, g_spec_a
 
-    spec_b = Gem::Specification.new 'b', 1
+    spec_b = Gem::Specification.new "b", 1
     g_spec_b = Gem::Resolver::GitSpecification.new @set, spec_b
 
     refute_equal g_spec_a, g_spec_b
@@ -29,17 +28,17 @@ class TestGemResolverGitSpecification < 
     i_set  = Gem::Resolver::IndexSet.new
     source = Gem::Source.new @gem_repo
     i_spec = Gem::Resolver::IndexSpecification.new(
-      i_set, 'a', v(1), source, Gem::Platform::RUBY)
+      i_set, "a", v(1), source, Gem::Platform::RUBY)
 
     refute_equal g_spec_a, i_spec
   end
 
   def test_add_dependency
-    git_gem 'a', 1
+    git_gem "a", 1
 
     git_spec = Gem::Resolver::GitSpecification.new @set, @spec
 
-    b_dep = dep 'b'
+    b_dep = dep "b"
 
     git_spec.add_dependency b_dep
 
@@ -47,7 +46,7 @@ class TestGemResolverGitSpecification < 
   end
 
   def test_install
-    git_gem 'a', 1
+    git_gem "a", 1
 
     git_spec = Gem::Resolver::GitSpecification.new @set, @spec
 
@@ -63,28 +62,29 @@ class TestGemResolverGitSpecification < 
   # functional test for Gem::Ext::Builder
 
   def test_install_extension
-    skip if Gem.java_platform?
-    name, _, repository, = git_gem 'a', 1 do |s|
-      s.extensions << 'ext/extconf.rb'
+    pend if Gem.java_platform?
+    pend if /mswin/ =~ RUBY_PLATFORM && ENV.key?("GITHUB_ACTIONS") # not working from the beginning
+    name, _, repository, = git_gem "a", 1 do |s|
+      s.extensions << "ext/extconf.rb"
     end
 
-    Dir.chdir 'git/a' do
-      FileUtils.mkdir_p 'ext/lib'
+    Dir.chdir "git/a" do
+      FileUtils.mkdir_p "ext/lib"
 
-      File.open 'ext/extconf.rb', 'w' do |io|
+      File.open "ext/extconf.rb", "w" do |io|
         io.puts 'require "mkmf"'
         io.puts 'create_makefile "a"'
       end
 
-      FileUtils.touch 'ext/lib/b.rb'
+      FileUtils.touch "ext/lib/b.rb"
 
-      system @git, 'add', 'ext/extconf.rb'
-      system @git, 'add', 'ext/lib/b.rb'
+      system @git, "add", "ext/extconf.rb"
+      system @git, "add", "ext/lib/b.rb"
 
-      system @git, 'commit', '--quiet', '-m', 'Add extension files'
+      system @git, "commit", "--quiet", "-m", "Add extension files"
     end
 
-    source = Gem::Source::Git.new name, repository, 'master', true
+    source = Gem::Source::Git.new name, repository, "master", true
 
     spec = source.specs.first
 
@@ -92,11 +92,11 @@ class TestGemResolverGitSpecification < 
 
     git_spec.install({})
 
-    assert_path_exists File.join git_spec.spec.extension_dir, 'b.rb'
+    assert_path_exist File.join git_spec.spec.extension_dir, "b.rb"
   end
 
   def test_install_installed
-    git_gem 'a', 1
+    git_gem "a", 1
 
     git_spec = Gem::Resolver::GitSpecification.new @set, @spec
 
@@ -110,5 +110,4 @@ class TestGemResolverGitSpecification < 
 
     assert called
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_index_set.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_index_set.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverIndexSet < Gem::TestCase
-
   def setup
     super
 
@@ -18,7 +17,7 @@ class TestGemResolverIndexSet < Gem::Tes
   end
 
   def test_initialize_source
-    set = @DR::IndexSet.new 'http://alternate.example'
+    set = @DR::IndexSet.new "http://alternate.example"
 
     fetcher = set.instance_variable_get :@f
 
@@ -29,33 +28,33 @@ class TestGemResolverIndexSet < Gem::Tes
 
   def test_find_all
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', 2
-      fetcher.spec 'b', 1
+      fetcher.spec "a", 1
+      fetcher.spec "a", 2
+      fetcher.spec "b", 1
     end
 
     set = @DR::IndexSet.new
 
-    dependency = dep 'a', '~> 1'
+    dependency = dep "a", "~> 1"
 
     req = @DR::DependencyRequest.new dependency, nil
 
     found = set.find_all req
 
-    assert_equal %w[a-1], found.map { |s| s.full_name }
+    assert_equal %w[a-1], found.map {|s| s.full_name }
   end
 
   def test_find_all_local
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', 2
-      fetcher.spec 'b', 1
+      fetcher.spec "a", 1
+      fetcher.spec "a", 2
+      fetcher.spec "b", 1
     end
 
     set = @DR::IndexSet.new
     set.remote = false
 
-    dependency = dep 'a', '~> 1'
+    dependency = dep "a", "~> 1"
 
     req = @DR::DependencyRequest.new dependency, nil
 
@@ -64,12 +63,12 @@ class TestGemResolverIndexSet < Gem::Tes
 
   def test_find_all_prerelease
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', '1.a'
+      fetcher.spec "a", "1.a"
     end
 
     set = @DR::IndexSet.new
 
-    dependency = dep 'a'
+    dependency = dep "a"
 
     req = @DR::DependencyRequest.new dependency, nil
 
@@ -83,7 +82,6 @@ class TestGemResolverIndexSet < Gem::Tes
 
     found = set.find_all req
 
-    assert_equal %w[a-1.a], found.map { |s| s.full_name }
+    assert_equal %w[a-1.a], found.map {|s| s.full_name }
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_index_specification.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_index_specification.rb
@@ -1,18 +1,17 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/available_set'
+require_relative "helper"
+require "rubygems/available_set"
 
 class TestGemResolverIndexSpecification < Gem::TestCase
-
   def test_initialize
     set     = Gem::Resolver::IndexSet.new
     source  = Gem::Source.new @gem_repo
-    version = Gem::Version.new '3.0.3'
+    version = Gem::Version.new "3.0.3"
 
     spec = Gem::Resolver::IndexSpecification.new(
-      set, 'rails', version, source, Gem::Platform::RUBY)
+      set, "rails", version, source, Gem::Platform::RUBY)
 
-    assert_equal 'rails',             spec.name
+    assert_equal "rails",             spec.name
     assert_equal version,             spec.version
     assert_equal Gem::Platform::RUBY, spec.platform
 
@@ -22,24 +21,24 @@ class TestGemResolverIndexSpecification 
   def test_initialize_platform
     set     = Gem::Resolver::IndexSet.new
     source  = Gem::Source::Local.new
-    version = Gem::Version.new '3.0.3'
+    version = Gem::Version.new "3.0.3"
 
     spec = Gem::Resolver::IndexSpecification.new(
-      set, 'rails', version, source, Gem::Platform.local)
+      set, "rails", version, source, Gem::Platform.local)
 
-    assert_equal Gem::Platform.local.to_s, spec.platform
+    assert_equal Gem::Platform.local, spec.platform
   end
 
   def test_install
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
     set    = Gem::Resolver::IndexSet.new
     source = Gem::Source.new @gem_repo
 
     spec = Gem::Resolver::IndexSpecification.new(
-      set, 'a', v(2), source, Gem::Platform::RUBY)
+      set, "a", v(2), source, Gem::Platform::RUBY)
 
     called = false
 
@@ -47,15 +46,15 @@ class TestGemResolverIndexSpecification 
       called = installer
     end
 
-    assert_path_exists File.join @gemhome, 'specifications', 'a-2.gemspec'
+    assert_path_exist File.join @gemhome, "specifications", "a-2.gemspec"
 
     assert_kind_of Gem::Installer, called
   end
 
   def test_spec
     specs = spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2
-      fetcher.spec 'a', 2 do |s|
+      fetcher.spec "a", 2
+      fetcher.spec "a", 2 do |s|
         s.platform = Gem::Platform.local
       end
     end
@@ -65,7 +64,7 @@ class TestGemResolverIndexSpecification 
 
     set = Gem::Resolver::IndexSet.new
     i_spec = Gem::Resolver::IndexSpecification.new \
-      set, 'a', version, source, Gem::Platform.local
+      set, "a", version, source, Gem::Platform.local
 
     spec = i_spec.spec
 
@@ -73,7 +72,7 @@ class TestGemResolverIndexSpecification 
   end
 
   def test_spec_local
-    a_2_p = util_spec 'a', 2 do |s|
+    a_2_p = util_spec "a", 2 do |s|
       s.platform = Gem::Platform.local
     end
 
@@ -84,11 +83,10 @@ class TestGemResolverIndexSpecification 
     set.always_install << a_2_p
 
     i_spec = Gem::Resolver::IndexSpecification.new \
-      set, 'a', v(2), source, Gem::Platform.local
+      set, "a", v(2), source, Gem::Platform.local
 
     spec = i_spec.spec
 
     assert_equal a_2_p.full_name, spec.full_name
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_installed_specification.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_installed_specification.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverInstalledSpecification < Gem::TestCase
-
   def setup
     super
 
@@ -10,17 +9,17 @@ class TestGemResolverInstalledSpecificat
   end
 
   def test_initialize
-    source_spec = util_spec 'a'
+    source_spec = util_spec "a"
 
     spec = Gem::Resolver::InstalledSpecification.new @set, source_spec
 
-    assert_equal 'a',                 spec.name
+    assert_equal "a",                 spec.name
     assert_equal Gem::Version.new(2), spec.version
     assert_equal Gem::Platform::RUBY, spec.platform
   end
 
   def test_install
-    a = util_spec 'a'
+    a = util_spec "a"
 
     spec = Gem::Resolver::InstalledSpecification.new @set, a
 
@@ -34,7 +33,7 @@ class TestGemResolverInstalledSpecificat
   end
 
   def test_installable_platform_eh
-    b, b_gem = util_gem 'a', 1 do |s|
+    b, b_gem = util_gem "a", 1 do |s|
       s.platform = Gem::Platform.new %w[cpu other_platform 1]
     end
 
@@ -44,5 +43,4 @@ class TestGemResolverInstalledSpecificat
 
     assert b_spec.installable_platform?
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_installer_set.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_installer_set.rb
@@ -1,27 +1,26 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverInstallerSet < Gem::TestCase
-
   def test_add_always_install
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 1
-      fetcher.download 'a', 2
+      fetcher.download "a", 1
+      fetcher.download "a", 2
     end
 
-    util_gem 'a', 1
+    util_gem "a", 1
 
     set = Gem::Resolver::InstallerSet.new :both
 
-    set.add_always_install dep('a')
+    set.add_always_install dep("a")
 
-    assert_equal %w[a-2], set.always_install.map { |s| s.full_name }
+    assert_equal %w[a-2], set.always_install.map {|s| s.full_name }
 
-    e = assert_raises Gem::UnsatisfiableDependencyError do
-      set.add_always_install dep('b')
+    e = assert_raise Gem::UnsatisfiableDependencyError do
+      set.add_always_install dep("b")
     end
 
-    assert_equal dep('b'), e.dependency.dependency
+    assert_equal dep("b"), e.dependency.dependency
   end
 
   def test_add_always_install_errors
@@ -30,8 +29,8 @@ class TestGemResolverInstallerSet < Gem:
 
     set = Gem::Resolver::InstallerSet.new :both
 
-    e = assert_raises Gem::UnsatisfiableDependencyError do
-      set.add_always_install dep 'a'
+    e = assert_raise Gem::UnsatisfiableDependencyError do
+      set.add_always_install dep "a"
     end
 
     refute_empty e.errors
@@ -39,46 +38,96 @@ class TestGemResolverInstallerSet < Gem:
 
   def test_add_always_install_platform
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 1
-      fetcher.download 'a', 2 do |s|
-        s.platform = Gem::Platform.new 'x86-freebsd-9'
+      fetcher.download "a", 1
+      fetcher.download "a", 2 do |s|
+        s.platform = Gem::Platform.new "x86-freebsd-9"
+      end
+    end
+
+    set = Gem::Resolver::InstallerSet.new :both
+
+    set.add_always_install dep("a")
+
+    assert_equal %w[a-1], set.always_install.map {|s| s.full_name }
+  end
+
+  def test_add_always_install_platform_if_gem_platforms_modified_by_platform_flag
+    freebsd = Gem::Platform.new "x86-freebsd-9"
+
+    spec_fetcher do |fetcher|
+      fetcher.download "a", 1
+      fetcher.download "a", 1 do |s|
+        s.platform = freebsd
       end
     end
 
+    # equivalent to --platform=x86-freebsd-9
+    Gem.platforms << freebsd
     set = Gem::Resolver::InstallerSet.new :both
 
-    set.add_always_install dep('a')
+    set.add_always_install dep("a")
+
+    assert_equal %w[a-1-x86-freebsd-9], set.always_install.map {|s| s.full_name }
+  end
+
+  def test_add_always_install_index_spec_platform
+    _, a_1_local_gem = util_gem "a", 1 do |s|
+      s.platform = Gem::Platform.local
+    end
+
+    FileUtils.mv a_1_local_gem, @tempdir
+
+    set = Gem::Resolver::InstallerSet.new :both
+    set.add_always_install dep("a")
 
-    assert_equal %w[a-1], set.always_install.map { |s| s.full_name }
+    assert_equal [Gem::Platform.local], set.always_install.map {|s| s.platform }
   end
 
   def test_add_always_install_prerelease
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
-      fetcher.gem 'a', '3.a'
+      fetcher.gem "a", 1
+      fetcher.gem "a", "3.a"
     end
 
     set = Gem::Resolver::InstallerSet.new :both
 
-    set.add_always_install dep('a')
+    set.add_always_install dep("a")
 
-    assert_equal %w[a-1], set.always_install.map { |s| s.full_name }
+    assert_equal %w[a-1], set.always_install.map {|s| s.full_name }
+  end
+
+  def test_add_always_install_prerelease_github_problem
+    spec_fetcher do |fetcher|
+      fetcher.gem "a", 1
+    end
+
+    # Github has an issue in which it will generate a misleading prerelease output in its RubyGems server API and
+    # returns a 0 version for the gem while it doesn't exist.
+    @fetcher.data["#{@gem_repo}prerelease_specs.#{Gem.marshal_version}.gz"] = util_gzip(Marshal.dump([
+      Gem::NameTuple.new("a", Gem::Version.new(0), "ruby"),
+    ]))
+
+    set = Gem::Resolver::InstallerSet.new :both
+
+    set.add_always_install dep("a")
+
+    assert_equal %w[a-1], set.always_install.map {|s| s.full_name }
   end
 
   def test_add_always_install_prerelease_only
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', '3.a'
+      fetcher.gem "a", "3.a"
     end
 
     set = Gem::Resolver::InstallerSet.new :both
 
-    assert_raises Gem::UnsatisfiableDependencyError do
-      set.add_always_install dep('a')
+    assert_raise Gem::UnsatisfiableDependencyError do
+      set.add_always_install dep("a")
     end
   end
 
   def test_add_local
-    a_1, a_1_gem = util_gem 'a', 1
+    a_1, a_1_gem = util_gem "a", 1
 
     a_1_source = Gem::Source::SpecificFile.new a_1_gem
 
@@ -91,9 +140,9 @@ class TestGemResolverInstallerSet < Gem:
     FileUtils.rm a_1_gem
     util_clear_gems
 
-    req = Gem::Resolver::DependencyRequest.new dep('a'), nil
+    req = Gem::Resolver::DependencyRequest.new dep("a"), nil
 
-    assert_equal %w[a-1], set.find_all(req).map { |spec| spec.full_name }
+    assert_equal %w[a-1], set.find_all(req).map {|spec| spec.full_name }
   end
 
   def test_consider_local_eh
@@ -129,7 +178,7 @@ class TestGemResolverInstallerSet < Gem:
 
     set.instance_variable_get(:@errors) << :a
 
-    req = Gem::Resolver::DependencyRequest.new dep('a'), nil
+    req = Gem::Resolver::DependencyRequest.new dep("a"), nil
 
     set.find_all req
 
@@ -138,42 +187,54 @@ class TestGemResolverInstallerSet < Gem:
 
   def test_find_all_always_install
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
+      fetcher.download "a", 2
     end
 
-    util_gem 'a', 1
+    util_gem "a", 1
 
     set = Gem::Resolver::InstallerSet.new :both
 
-    set.add_always_install dep 'a'
+    set.add_always_install dep "a"
 
-    req = Gem::Resolver::DependencyRequest.new dep('a'), nil
+    req = Gem::Resolver::DependencyRequest.new dep("a"), nil
 
-    assert_equal %w[a-2], set.find_all(req).map { |spec| spec.full_name }
+    assert_equal %w[a-2], set.find_all(req).map {|spec| spec.full_name }
   end
 
   def test_find_all_prerelease
     spec_fetcher do |fetcher|
-      fetcher.download 'a', '1'
-      fetcher.download 'a', '1.a'
+      fetcher.download "a", "1"
+      fetcher.download "a", "1.a"
     end
 
     set = Gem::Resolver::InstallerSet.new :both
 
-    req = Gem::Resolver::DependencyRequest.new dep('a'), nil
+    req = Gem::Resolver::DependencyRequest.new dep("a"), nil
 
-    assert_equal %w[a-1], set.find_all(req).map { |spec| spec.full_name }
+    assert_equal %w[a-1], set.find_all(req).map {|spec| spec.full_name }
 
-    req = Gem::Resolver::DependencyRequest.new dep('a', '>= 0.a'), nil
+    req = Gem::Resolver::DependencyRequest.new dep("a", ">= 0.a"), nil
 
     assert_equal %w[a-1 a-1.a],
-                 set.find_all(req).map { |spec| spec.full_name }.sort
+                 set.find_all(req).map {|spec| spec.full_name }.sort
+  end
+
+  def test_find_all_prerelease_dependencies_with_add_local
+    activesupport_7_1_0_alpha = util_spec "activesupport", "7.1.0.alpha"
+
+    install_gem activesupport_7_1_0_alpha
+
+    set = Gem::Resolver::InstallerSet.new :both
+
+    req = Gem::Resolver::DependencyRequest.new dep("activesupport", ">= 4.2.0"), nil
+
+    assert_equal %w[activesupport-7.1.0.alpha], set.find_all(req).map {|spec| spec.full_name }
   end
 
   def test_load_spec
     specs = spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2
-      fetcher.spec 'a', 2 do |s|
+      fetcher.spec "a", 2
+      fetcher.spec "a", 2 do |s|
         s.platform = Gem::Platform.local
       end
     end
@@ -183,7 +244,7 @@ class TestGemResolverInstallerSet < Gem:
 
     set = Gem::Resolver::InstallerSet.new :remote
 
-    spec = set.load_spec 'a', version, Gem::Platform.local, source
+    spec = set.load_spec "a", version, Gem::Platform.local, source
 
     assert_equal specs["a-2-#{Gem::Platform.local}"].full_name, spec.full_name
   end
@@ -193,7 +254,7 @@ class TestGemResolverInstallerSet < Gem:
     def (set.remote_set).prefetch(_)
       raise "called"
     end
-    assert_raises(RuntimeError){ set.prefetch(nil) }
+    assert_raise(RuntimeError) { set.prefetch(nil) }
 
     set = Gem::Resolver::InstallerSet.new :local
     def (set.remote_set).prefetch(_)
@@ -255,5 +316,4 @@ class TestGemResolverInstallerSet < Gem:
     refute set.consider_local?
     refute set.consider_remote?
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_local_specification.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_local_specification.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/available_set'
+require_relative "helper"
+require "rubygems/available_set"
 
 class TestGemResolverLocalSpecification < Gem::TestCase
-
   def setup
     super
 
@@ -12,12 +11,12 @@ class TestGemResolverLocalSpecification 
 
   def test_install
     specs = spec_fetcher do |fetcher|
-      fetcher.gem 'a', 2
+      fetcher.gem "a", 2
     end
 
-    source = Gem::Source::SpecificFile.new 'gems/a-2.gem'
+    source = Gem::Source::SpecificFile.new "gems/a-2.gem"
 
-    spec = Gem::Resolver::LocalSpecification.new @set, specs['a-2'], source
+    spec = Gem::Resolver::LocalSpecification.new @set, specs["a-2"], source
 
     called = false
 
@@ -25,13 +24,13 @@ class TestGemResolverLocalSpecification 
       called = installer
     end
 
-    assert_path_exists File.join @gemhome, 'specifications', 'a-2.gemspec'
+    assert_path_exist File.join @gemhome, "specifications", "a-2.gemspec"
 
     assert_kind_of Gem::Installer, called
   end
 
   def test_installable_platform_eh
-    b, b_gem = util_gem 'a', 1 do |s|
+    b, b_gem = util_gem "a", 1 do |s|
       s.platform = Gem::Platform.new %w[cpu other_platform 1]
     end
 
@@ -41,5 +40,4 @@ class TestGemResolverLocalSpecification 
 
     assert b_spec.installable_platform?
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_lock_set.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_lock_set.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverLockSet < Gem::TestCase
-
   def setup
     super
 
@@ -13,51 +12,50 @@ class TestGemResolverLockSet < Gem::Test
   end
 
   def test_add
-    specs = @set.add 'a', '2', Gem::Platform::RUBY
+    specs = @set.add "a", "2", Gem::Platform::RUBY
     spec = specs.first
 
-    assert_equal %w[a-2], @set.specs.map { |t| t.full_name }
+    assert_equal %w[a-2], @set.specs.map {|t| t.full_name }
 
     assert_kind_of Gem::Resolver::LockSpecification, spec
 
     assert_equal @set,                spec.set
-    assert_equal 'a',                 spec.name
+    assert_equal "a",                 spec.name
     assert_equal v(2),                spec.version
     assert_equal Gem::Platform::RUBY, spec.platform
     assert_equal @lock_source,        spec.source
   end
 
   def test_find_all
-    @set.add 'a', '1.a', Gem::Platform::RUBY
-    @set.add 'a', '2',   Gem::Platform::RUBY
-    @set.add 'b', '2',   Gem::Platform::RUBY
+    @set.add "a", "1.a", Gem::Platform::RUBY
+    @set.add "a", "2",   Gem::Platform::RUBY
+    @set.add "b", "2",   Gem::Platform::RUBY
 
-    found = @set.find_all dep 'a'
+    found = @set.find_all dep "a"
 
-    assert_equal %w[a-2], found.map { |s| s.full_name }
+    assert_equal %w[a-2], found.map {|s| s.full_name }
 
-    found = @set.find_all dep 'a', '>= 0.a'
+    found = @set.find_all dep "a", ">= 0.a"
 
-    assert_equal %w[a-1.a a-2], found.map { |s| s.full_name }
+    assert_equal %w[a-1.a a-2], found.map {|s| s.full_name }
   end
 
   def test_load_spec
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 2
+      fetcher.spec "a", 2
     end
 
     version = v(2)
-    @set.add 'a', version, Gem::Platform::RUBY
+    @set.add "a", version, Gem::Platform::RUBY
 
-    loaded = @set.load_spec 'a', version, Gem::Platform::RUBY, nil
+    loaded = @set.load_spec "a", version, Gem::Platform::RUBY, nil
 
     assert_kind_of Gem::Specification, loaded
 
-    assert_equal 'a-2', loaded.full_name
+    assert_equal "a-2", loaded.full_name
   end
 
   def test_prefetch
     assert_respond_to @set, :prefetch
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_lock_specification.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_lock_specification.rb
@@ -1,10 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/installer'
-require 'rubygems/resolver'
+require_relative "helper"
+require "rubygems/installer"
+require "rubygems/resolver"
 
 class TestGemResolverLockSpecification < Gem::TestCase
-
   def setup
     super
 
@@ -15,9 +14,9 @@ class TestGemResolverLockSpecification <
   end
 
   def test_initialize
-    spec = @LS.new @set, 'a', v(2), [@source], Gem::Platform::RUBY
+    spec = @LS.new @set, "a", v(2), [@source], Gem::Platform::RUBY
 
-    assert_equal 'a',                 spec.name
+    assert_equal "a",                 spec.name
     assert_equal v(2),                spec.version
     assert_equal Gem::Platform::RUBY, spec.platform
 
@@ -25,9 +24,9 @@ class TestGemResolverLockSpecification <
   end
 
   def test_add_dependency
-    l_spec = @LS.new @set, 'a', v(2), [@source], Gem::Platform::RUBY
+    l_spec = @LS.new @set, "a", v(2), [@source], Gem::Platform::RUBY
 
-    b_dep = dep('b', '>= 0')
+    b_dep = dep("b", ">= 0")
 
     l_spec.add_dependency b_dep
 
@@ -36,10 +35,10 @@ class TestGemResolverLockSpecification <
 
   def test_install
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 2
+      fetcher.download "a", 2
     end
 
-    spec = @LS.new @set, 'a', v(2), [@source], Gem::Platform::RUBY
+    spec = @LS.new @set, "a", v(2), [@source], Gem::Platform::RUBY
 
     called = false
 
@@ -51,9 +50,9 @@ class TestGemResolverLockSpecification <
   end
 
   def test_install_installed
-    spec = @LS.new @set, 'a', v(2), [@source], Gem::Platform::RUBY
+    spec = @LS.new @set, "a", v(2), [@source], Gem::Platform::RUBY
 
-    FileUtils.touch File.join(@gemhome, 'specifications', spec.spec.spec_name)
+    FileUtils.touch File.join(@gemhome, "specifications", spec.spec.spec_name)
 
     called = false
 
@@ -67,17 +66,17 @@ class TestGemResolverLockSpecification <
   def test_spec
     version = v(2)
 
-    l_spec = @LS.new @set, 'a', version, [@source], Gem::Platform::RUBY
+    l_spec = @LS.new @set, "a", version, [@source], Gem::Platform::RUBY
 
-    b_dep = dep 'b', '>= 0'
-    c_dep = dep 'c', '~> 1'
+    b_dep = dep "b", ">= 0"
+    c_dep = dep "c", "~> 1"
 
     l_spec.add_dependency b_dep
     l_spec.add_dependency c_dep
 
     spec = l_spec.spec
 
-    assert_equal 'a',                 spec.name
+    assert_equal "a",                 spec.name
     assert_equal version,             spec.version
     assert_equal Gem::Platform::RUBY, spec.platform
 
@@ -85,15 +84,14 @@ class TestGemResolverLockSpecification <
   end
 
   def test_spec_loaded
-    real_spec = util_spec 'a', 2
+    real_spec = util_spec "a", 2
     install_specs real_spec
     real_spec.activate
 
     version = v(2)
 
-    l_spec = @LS.new @set, 'a', version, [@source], Gem::Platform::RUBY
+    l_spec = @LS.new @set, "a", version, [@source], Gem::Platform::RUBY
 
     assert_same real_spec, l_spec.spec
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_requirement_list.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_requirement_list.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverRequirementList < Gem::TestCase
-
   def setup
     super
 
@@ -16,5 +15,4 @@ class TestGemResolverRequirementList < G
 
     assert_equal [req], @list.each.to_a
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_specification.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_specification.rb
@@ -1,10 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverSpecification < Gem::TestCase
-
   class TestSpec < Gem::Resolver::Specification
-
     attr_writer :source
     attr_reader :spec
 
@@ -13,37 +11,36 @@ class TestGemResolverSpecification < Gem
 
       @spec = spec
     end
-
   end
 
   def test_install
     gemhome = "#{@gemhome}2"
     spec_fetcher do |fetcher|
-      fetcher.gem 'a', 1
+      fetcher.gem "a", 1
     end
 
-    a = util_spec 'a', 1
+    a = util_spec "a", 1
 
     a_spec = TestSpec.new a
     a_spec.source = Gem::Source.new @gem_repo
 
     a_spec.install :install_dir => gemhome
 
-    assert_path_exists File.join gemhome, 'gems', a.full_name
+    assert_path_exist File.join gemhome, "gems", a.full_name
 
-    expected = File.join gemhome, 'specifications', a.spec_name
+    expected = File.join gemhome, "specifications", a.spec_name
 
     assert_equal expected, a_spec.spec.loaded_from
   end
 
   def test_installable_platform_eh
-    a = util_spec 'a', 1
+    a = util_spec "a", 1
 
     a_spec = TestSpec.new a
 
     assert a_spec.installable_platform?
 
-    b = util_spec 'a', 1 do |s|
+    b = util_spec "a", 1 do |s|
       s.platform = Gem::Platform.new %w[cpu other_platform 1]
     end
 
@@ -53,7 +50,7 @@ class TestGemResolverSpecification < Gem
   end
 
   def test_source
-    a = util_spec 'a', 1
+    a = util_spec "a", 1
 
     source = Gem::Source.new @gem_repo
 
@@ -62,5 +59,4 @@ class TestGemResolverSpecification < Gem
 
     assert_equal source, a_spec.source
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_vendor_set.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_vendor_set.rb
@@ -1,8 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverVendorSet < Gem::TestCase
-
   def setup
     super
 
@@ -28,7 +27,7 @@ class TestGemResolverVendorSet < Gem::Te
 
     FileUtils.rm_r directory
 
-    e = assert_raises Gem::GemNotFoundException do
+    e = assert_raise Gem::GemNotFoundException do
       @set.add_vendor_gem name, directory
     end
 
@@ -41,7 +40,7 @@ class TestGemResolverVendorSet < Gem::Te
 
     @set.add_vendor_gem name, directory
 
-    dependency = dep 'a', '~> 1'
+    dependency = dep "a", "~> 1"
 
     req = Gem::Resolver::DependencyRequest.new dependency, nil
 
@@ -52,22 +51,22 @@ class TestGemResolverVendorSet < Gem::Te
     source = Gem::Source::Vendor.new directory
 
     expected = [
-      Gem::Resolver::VendorSpecification.new(@set, spec, source)
+      Gem::Resolver::VendorSpecification.new(@set, spec, source),
     ]
 
     assert_equal expected, found
   end
 
   def test_find_all_prerelease
-    name, _, directory = vendor_gem 'a', '1.a'
+    name, _, directory = vendor_gem "a", "1.a"
 
     @set.add_vendor_gem name, directory
 
-    req = Gem::Resolver::DependencyRequest.new dep('a'), nil
+    req = Gem::Resolver::DependencyRequest.new dep("a"), nil
 
     assert_empty @set.find_all req
 
-    req = Gem::Resolver::DependencyRequest.new dep('a', '>= 0.a'), nil
+    req = Gem::Resolver::DependencyRequest.new dep("a", ">= 0.a"), nil
 
     refute_empty @set.find_all req
   end
@@ -75,9 +74,8 @@ class TestGemResolverVendorSet < Gem::Te
   def test_load_spec
     error = Object.const_defined?(:KeyError) ? KeyError : IndexError
 
-    assert_raises error do
-      @set.load_spec 'b', v(1), Gem::Platform::RUBY, nil
+    assert_raise error do
+      @set.load_spec "b", v(1), Gem::Platform::RUBY, nil
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_resolver_vendor_specification.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_resolver_vendor_specification.rb
@@ -1,13 +1,12 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemResolverVendorSpecification < Gem::TestCase
-
   def setup
     super
 
     @set  = Gem::Resolver::VendorSet.new
-    @spec = Gem::Specification.new 'a', 1
+    @spec = Gem::Specification.new "a", 1
   end
 
   def test_equals2
@@ -15,7 +14,7 @@ class TestGemResolverVendorSpecification
 
     assert_equal v_spec_a, v_spec_a
 
-    spec_b = Gem::Specification.new 'b', 1
+    spec_b = Gem::Specification.new "b", 1
     v_spec_b = Gem::Resolver::VendorSpecification.new @set, spec_b
 
     refute_equal v_spec_a, v_spec_b
@@ -28,24 +27,24 @@ class TestGemResolverVendorSpecification
     i_set  = Gem::Resolver::IndexSet.new
     source = Gem::Source.new @gem_repo
     i_spec = Gem::Resolver::IndexSpecification.new(
-      i_set, 'a', v(1), source, Gem::Platform::RUBY)
+      i_set, "a", v(1), source, Gem::Platform::RUBY)
 
     refute_equal v_spec_a, i_spec
   end
 
   def test_dependencies
-    @spec.add_dependency 'b'
-    @spec.add_dependency 'c'
+    @spec.add_dependency "b"
+    @spec.add_dependency "c"
 
     v_spec = Gem::Resolver::VendorSpecification.new @set, @spec
 
-    assert_equal [dep('b'), dep('c')], v_spec.dependencies
+    assert_equal [dep("b"), dep("c")], v_spec.dependencies
   end
 
   def test_full_name
     v_spec = Gem::Resolver::VendorSpecification.new @set, @spec
 
-    assert_equal 'a-1', v_spec.full_name
+    assert_equal "a-1", v_spec.full_name
   end
 
   def test_install
@@ -63,7 +62,7 @@ class TestGemResolverVendorSpecification
   def test_name
     v_spec = Gem::Resolver::VendorSpecification.new @set, @spec
 
-    assert_equal 'a', v_spec.name
+    assert_equal "a", v_spec.name
   end
 
   def test_platform
@@ -73,11 +72,10 @@ class TestGemResolverVendorSpecification
   end
 
   def test_version
-    spec = Gem::Specification.new 'a', 1
+    spec = Gem::Specification.new "a", 1
 
     v_spec = Gem::Resolver::VendorSpecification.new @set, spec
 
     assert_equal v(1), v_spec.version
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_security.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_security.rb
@@ -1,22 +1,22 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/security'
+require_relative "helper"
+require "rubygems/security"
 
-unless defined?(OpenSSL::SSL)
-  warn 'Skipping Gem::Security tests.  openssl not found.'
+unless Gem::HAVE_OPENSSL
+  warn "Skipping Gem::Security tests.  openssl not found."
 end
 
 if Gem.java_platform?
-  warn 'Skipping Gem::Security tests on jruby.'
+  warn "Skipping Gem::Security tests on jruby."
 end
 
 class TestGemSecurity < Gem::TestCase
+  CHILD_KEY = load_key "child"
+  EC_KEY = load_key "private_ec", "Foo bar"
 
-  CHILD_KEY = load_key 'child'
-
-  ALTERNATE_CERT = load_cert 'child'
-  CHILD_CERT     = load_cert 'child'
-  EXPIRED_CERT   = load_cert 'expired'
+  ALTERNATE_CERT = load_cert "child"
+  CHILD_CERT     = load_cert "child"
+  EXPIRED_CERT   = load_cert "expired"
 
   def setup
     super
@@ -40,21 +40,21 @@ class TestGemSecurity < Gem::TestCase
     assert_equal    name.to_s,             cert.subject.to_s
 
     assert_equal 3, cert.extensions.length,
-                 cert.extensions.map { |e| e.to_a.first }
+                 cert.extensions.map {|e| e.to_a.first }
 
-    constraints = cert.extensions.find { |ext| ext.oid == 'basicConstraints' }
-    assert_equal 'CA:FALSE', constraints.value
+    constraints = cert.extensions.find {|ext| ext.oid == "basicConstraints" }
+    assert_equal "CA:FALSE", constraints.value
 
-    key_usage = cert.extensions.find { |ext| ext.oid == 'keyUsage' }
-    assert_equal 'Digital Signature, Key Encipherment, Data Encipherment',
+    key_usage = cert.extensions.find {|ext| ext.oid == "keyUsage" }
+    assert_equal "Digital Signature, Key Encipherment, Data Encipherment",
                  key_usage.value
 
-    key_ident = cert.extensions.find { |ext| ext.oid == 'subjectKeyIdentifier' }
+    key_ident = cert.extensions.find {|ext| ext.oid == "subjectKeyIdentifier" }
     assert_equal 59, key_ident.value.length
-    assert_equal '5F:43:6E:F6:9A:8E:45:25:E9:22:E3:7D:37:5E:A4:D5:36:02:85:1B',
+    assert_equal "5F:43:6E:F6:9A:8E:45:25:E9:22:E3:7D:37:5E:A4:D5:36:02:85:1B",
                  key_ident.value
 
-    assert_equal '', cert.issuer.to_s
+    assert_equal "", cert.issuer.to_s
     assert_equal name.to_s, cert.subject.to_s
   end
 
@@ -63,12 +63,12 @@ class TestGemSecurity < Gem::TestCase
 
     cert = @SEC.create_cert_self_signed subject, PRIVATE_KEY, 60
 
-    assert_equal '/CN=nobody/DC=example', cert.issuer.to_s
+    assert_equal "/CN=nobody/DC=example", cert.issuer.to_s
     assert_equal "sha256WithRSAEncryption", cert.signature_algorithm
   end
 
   def test_class_create_cert_email
-    email = 'nobody@example'
+    email = "nobody@example"
     name = PUBLIC_CERT.subject
     key = PRIVATE_KEY
 
@@ -85,42 +85,69 @@ class TestGemSecurity < Gem::TestCase
     assert_equal    name.to_s,             cert.issuer.to_s
 
     assert_equal 5, cert.extensions.length,
-                 cert.extensions.map { |e| e.to_a.first }
+                 cert.extensions.map {|e| e.to_a.first }
 
-    constraints = cert.extensions.find { |ext| ext.oid == 'subjectAltName' }
-    assert_equal 'email:nobody@example', constraints.value
+    constraints = cert.extensions.find {|ext| ext.oid == "subjectAltName" }
+    assert_equal "email:nobody@example", constraints.value
 
-    constraints = cert.extensions.find { |ext| ext.oid == 'basicConstraints' }
-    assert_equal 'CA:FALSE', constraints.value
+    constraints = cert.extensions.find {|ext| ext.oid == "basicConstraints" }
+    assert_equal "CA:FALSE", constraints.value
 
-    key_usage = cert.extensions.find { |ext| ext.oid == 'keyUsage' }
-    assert_equal 'Digital Signature, Key Encipherment, Data Encipherment',
+    key_usage = cert.extensions.find {|ext| ext.oid == "keyUsage" }
+    assert_equal "Digital Signature, Key Encipherment, Data Encipherment",
                  key_usage.value
 
-    key_ident = cert.extensions.find { |ext| ext.oid == 'subjectKeyIdentifier' }
+    key_ident = cert.extensions.find {|ext| ext.oid == "subjectKeyIdentifier" }
     assert_equal 59, key_ident.value.length
-    assert_equal '5F:43:6E:F6:9A:8E:45:25:E9:22:E3:7D:37:5E:A4:D5:36:02:85:1B',
+    assert_equal "5F:43:6E:F6:9A:8E:45:25:E9:22:E3:7D:37:5E:A4:D5:36:02:85:1B",
                  key_ident.value
   end
 
   def test_class_create_key
-    key = @SEC.create_key 1024
+    key = @SEC.create_key "rsa"
 
     assert_kind_of OpenSSL::PKey::RSA, key
   end
 
+  def test_class_create_key_downcases
+    key = @SEC.create_key "DSA"
+
+    assert_kind_of OpenSSL::PKey::DSA, key
+  end
+
+  def test_class_create_key_raises_unknown_algorithm
+    e = assert_raise Gem::Security::Exception do
+      @SEC.create_key "NOT_RSA"
+    end
+
+    assert_equal "NOT_RSA algorithm not found. RSA, DSA, and EC algorithms are supported.",
+                 e.message
+  end
+
+  def test_class_get_public_key_rsa
+    pkey_pem = PRIVATE_KEY.public_key.to_pem
+
+    assert_equal pkey_pem, @SEC.get_public_key(PRIVATE_KEY).to_pem
+  end
+
+  def test_class_get_public_key_ec
+    pkey = @SEC.get_public_key(EC_KEY)
+
+    assert_respond_to pkey, :to_pem
+  end
+
   def test_class_email_to_name
-    assert_equal '/CN=nobody/DC=example',
-                 @SEC.email_to_name('nobody@example').to_s
+    assert_equal "/CN=nobody/DC=example",
+                 @SEC.email_to_name("nobody@example").to_s
 
-    assert_equal '/CN=nobody/DC=example/DC=com',
-                 @SEC.email_to_name('nobody@example.com').to_s
+    assert_equal "/CN=nobody/DC=example/DC=com",
+                 @SEC.email_to_name("nobody@example.com").to_s
 
-    assert_equal '/CN=no.body/DC=example',
-                 @SEC.email_to_name('no.body@example').to_s
+    assert_equal "/CN=no.body/DC=example",
+                 @SEC.email_to_name("no.body@example").to_s
 
-    assert_equal '/CN=no_body/DC=example',
-                 @SEC.email_to_name('no+body@example').to_s
+    assert_equal "/CN=no_body/DC=example",
+                 @SEC.email_to_name("no+body@example").to_s
   end
 
   def test_class_re_sign
@@ -136,12 +163,12 @@ class TestGemSecurity < Gem::TestCase
   end
 
   def test_class_re_sign_not_self_signed
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       Gem::Security.re_sign CHILD_CERT, CHILD_KEY
     end
 
     child_alt_name = CHILD_CERT.extensions.find do |extension|
-      extension.oid == 'subjectAltName'
+      extension.oid == "subjectAltName"
     end
 
     assert_equal "#{child_alt_name.value} is not self-signed, contact " +
@@ -150,7 +177,7 @@ class TestGemSecurity < Gem::TestCase
   end
 
   def test_class_re_sign_wrong_key
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       Gem::Security.re_sign ALTERNATE_CERT, PRIVATE_KEY
     end
 
@@ -169,7 +196,7 @@ class TestGemSecurity < Gem::TestCase
 
   def test_class_sign
     issuer = PUBLIC_CERT.subject
-    signee = OpenSSL::X509::Name.parse "/CN=signee/DC=example"
+    signee = OpenSSL::X509::Name.new([["CN", "signee"], ["DC", "example"]])
 
     key  = PRIVATE_KEY
     cert = OpenSSL::X509::Certificate.new
@@ -188,22 +215,22 @@ class TestGemSecurity < Gem::TestCase
     assert_in_delta Time.now + 60,         signed.not_after, 10
 
     assert_equal 4, signed.extensions.length,
-                 signed.extensions.map { |e| e.to_a.first }
+                 signed.extensions.map {|e| e.to_a.first }
 
-    constraints = signed.extensions.find { |ext| ext.oid == 'issuerAltName' }
-    assert_equal 'email:nobody@example', constraints.value, 'issuerAltName'
+    constraints = signed.extensions.find {|ext| ext.oid == "issuerAltName" }
+    assert_equal "email:nobody@example", constraints.value, "issuerAltName"
 
-    constraints = signed.extensions.find { |ext| ext.oid == 'basicConstraints' }
-    assert_equal 'CA:FALSE', constraints.value
+    constraints = signed.extensions.find {|ext| ext.oid == "basicConstraints" }
+    assert_equal "CA:FALSE", constraints.value
 
-    key_usage = signed.extensions.find { |ext| ext.oid == 'keyUsage' }
-    assert_equal 'Digital Signature, Key Encipherment, Data Encipherment',
+    key_usage = signed.extensions.find {|ext| ext.oid == "keyUsage" }
+    assert_equal "Digital Signature, Key Encipherment, Data Encipherment",
                  key_usage.value
 
     key_ident =
-      signed.extensions.find { |ext| ext.oid == 'subjectKeyIdentifier' }
+      signed.extensions.find {|ext| ext.oid == "subjectKeyIdentifier" }
     assert_equal 59, key_ident.value.length
-    assert_equal '5F:43:6E:F6:9A:8E:45:25:E9:22:E3:7D:37:5E:A4:D5:36:02:85:1B',
+    assert_equal "5F:43:6E:F6:9A:8E:45:25:E9:22:E3:7D:37:5E:A4:D5:36:02:85:1B",
                  key_ident.value
 
     assert signed.verify key
@@ -213,7 +240,7 @@ class TestGemSecurity < Gem::TestCase
     issuer = PUBLIC_CERT.subject
     signee = OpenSSL::X509::Name.parse "/CN=signee/DC=example"
 
-    cert = @SEC.create_cert_email 'signee@example', PRIVATE_KEY
+    cert = @SEC.create_cert_email "signee@example", PRIVATE_KEY
 
     signed = @SEC.sign cert, PRIVATE_KEY, PUBLIC_CERT, 60
 
@@ -227,25 +254,25 @@ class TestGemSecurity < Gem::TestCase
     assert_equal "sha256WithRSAEncryption", signed.signature_algorithm
 
     assert_equal 5, signed.extensions.length,
-                 signed.extensions.map { |e| e.to_a.first }
+                 signed.extensions.map {|e| e.to_a.first }
 
-    constraints = signed.extensions.find { |ext| ext.oid == 'issuerAltName' }
-    assert_equal 'email:nobody@example', constraints.value, 'issuerAltName'
+    constraints = signed.extensions.find {|ext| ext.oid == "issuerAltName" }
+    assert_equal "email:nobody@example", constraints.value, "issuerAltName"
 
-    constraints = signed.extensions.find { |ext| ext.oid == 'subjectAltName' }
-    assert_equal 'email:signee@example', constraints.value, 'subjectAltName'
+    constraints = signed.extensions.find {|ext| ext.oid == "subjectAltName" }
+    assert_equal "email:signee@example", constraints.value, "subjectAltName"
 
-    constraints = signed.extensions.find { |ext| ext.oid == 'basicConstraints' }
-    assert_equal 'CA:FALSE', constraints.value
+    constraints = signed.extensions.find {|ext| ext.oid == "basicConstraints" }
+    assert_equal "CA:FALSE", constraints.value
 
-    key_usage = signed.extensions.find { |ext| ext.oid == 'keyUsage' }
-    assert_equal 'Digital Signature, Key Encipherment, Data Encipherment',
+    key_usage = signed.extensions.find {|ext| ext.oid == "keyUsage" }
+    assert_equal "Digital Signature, Key Encipherment, Data Encipherment",
                  key_usage.value
 
     key_ident =
-      signed.extensions.find { |ext| ext.oid == 'subjectKeyIdentifier' }
+      signed.extensions.find {|ext| ext.oid == "subjectKeyIdentifier" }
     assert_equal 59, key_ident.value.length
-    assert_equal '5F:43:6E:F6:9A:8E:45:25:E9:22:E3:7D:37:5E:A4:D5:36:02:85:1B',
+    assert_equal "5F:43:6E:F6:9A:8E:45:25:E9:22:E3:7D:37:5E:A4:D5:36:02:85:1B",
                  key_ident.value
 
     assert signed.verify PUBLIC_KEY
@@ -254,19 +281,19 @@ class TestGemSecurity < Gem::TestCase
   def test_class_trust_dir
     trust_dir = @SEC.trust_dir
 
-    expected = File.join Gem.user_home, '.gem/trust'
+    expected = File.join Gem.user_home, ".gem/trust"
 
     assert_equal expected, trust_dir.dir
   end
 
   def test_class_write
-    key = @SEC.create_key 1024
+    key = @SEC.create_key "rsa"
 
-    path = File.join @tempdir, 'test-private_key.pem'
+    path = File.join @tempdir, "test-private_key.pem"
 
     @SEC.write key, path
 
-    assert_path_exists path
+    assert_path_exist path
 
     key_from_file = File.read path
 
@@ -274,15 +301,15 @@ class TestGemSecurity < Gem::TestCase
   end
 
   def test_class_write_encrypted
-    key = @SEC.create_key 1024
+    key = @SEC.create_key "rsa"
 
-    path = File.join @tempdir, 'test-private_encrypted_key.pem'
+    path = File.join @tempdir, "test-private_encrypted_key.pem"
 
-    passphrase = 'It should be long.'
+    passphrase = "It should be long."
 
     @SEC.write key, path, 0600, passphrase
 
-    assert_path_exists path
+    assert_path_exist path
 
     key_from_file = OpenSSL::PKey::RSA.new File.read(path), passphrase
 
@@ -290,17 +317,17 @@ class TestGemSecurity < Gem::TestCase
   end
 
   def test_class_write_encrypted_cipher
-    key = @SEC.create_key 1024
+    key = @SEC.create_key "rsa"
 
-    path = File.join @tempdir, 'test-private_encrypted__with_non_default_cipher_key.pem'
+    path = File.join @tempdir, "test-private_encrypted__with_non_default_cipher_key.pem"
 
-    passphrase = 'It should be long.'
+    passphrase = "It should be long."
 
-    cipher = OpenSSL::Cipher.new 'AES-192-CBC'
+    cipher = OpenSSL::Cipher.new "AES-192-CBC"
 
     @SEC.write key, path, 0600, passphrase, cipher
 
-    assert_path_exists path
+    assert_path_exist path
 
     key_file_contents = File.read(path)
 
@@ -310,5 +337,4 @@ class TestGemSecurity < Gem::TestCase
 
     assert_equal key.to_pem, key_from_file.to_pem
   end
-
-end if defined?(OpenSSL::SSL) && !Gem.java_platform?
+end if Gem::HAVE_OPENSSL && !Gem.java_platform?
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_security_policy.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_security_policy.rb
@@ -1,40 +1,38 @@
-# coding: utf-8
 # frozen_string_literal: true
 
-require 'rubygems/test_case'
+require_relative "helper"
 
-unless defined?(OpenSSL::SSL)
-  warn 'Skipping Gem::Security::Policy tests.  openssl not found.'
+unless Gem::HAVE_OPENSSL
+  warn "Skipping Gem::Security::Policy tests.  openssl not found."
 end
 
 class TestGemSecurityPolicy < Gem::TestCase
-
-  ALTERNATE_KEY    = load_key 'alternate'
-  INVALID_KEY      = load_key 'invalid'
-  CHILD_KEY        = load_key 'child'
-  GRANDCHILD_KEY   = load_key 'grandchild'
-  INVALIDCHILD_KEY = load_key 'invalidchild'
-
-  ALTERNATE_CERT      = load_cert 'alternate'
-  CA_CERT             = load_cert 'ca'
-  CHILD_CERT          = load_cert 'child'
-  EXPIRED_CERT        = load_cert 'expired'
-  FUTURE_CERT         = load_cert 'future'
-  GRANDCHILD_CERT     = load_cert 'grandchild'
-  INVALIDCHILD_CERT   = load_cert 'invalidchild'
-  INVALID_ISSUER_CERT = load_cert 'invalid_issuer'
-  INVALID_SIGNER_CERT = load_cert 'invalid_signer'
-  WRONG_KEY_CERT      = load_cert 'wrong_key'
+  ALTERNATE_KEY    = load_key "alternate"
+  INVALID_KEY      = load_key "invalid"
+  CHILD_KEY        = load_key "child"
+  GRANDCHILD_KEY   = load_key "grandchild"
+  INVALIDCHILD_KEY = load_key "invalidchild"
+
+  ALTERNATE_CERT      = load_cert "alternate"
+  CA_CERT             = load_cert "ca"
+  CHILD_CERT          = load_cert "child"
+  EXPIRED_CERT        = load_cert "expired"
+  FUTURE_CERT         = load_cert "future"
+  GRANDCHILD_CERT     = load_cert "grandchild"
+  INVALIDCHILD_CERT   = load_cert "invalidchild"
+  INVALID_ISSUER_CERT = load_cert "invalid_issuer"
+  INVALID_SIGNER_CERT = load_cert "invalid_signer"
+  WRONG_KEY_CERT      = load_cert "wrong_key"
 
   def setup
     super
 
-    @spec = quick_gem 'a' do |s|
-      s.description = ''
+    @spec = quick_gem "a" do |s|
+      s.description = ""
       s.files = %w[lib/code.rb]
     end
 
-    @digest = Gem::Security::DIGEST_ALGORITHM
+    @digest = OpenSSL::Digest.new Gem::Security::DIGEST_NAME
     @trust_dir = Gem::Security.trust_dir.dir # HACK use the object
 
     @no        = Gem::Security::NoSecurity
@@ -44,7 +42,7 @@ class TestGemSecurityPolicy < Gem::TestC
     @high      = Gem::Security::HighSecurity
 
     @chain = Gem::Security::Policy.new(
-      'Chain',
+      "Chain",
       :verify_data   => true,
       :verify_signer => true,
       :verify_chain  => true,
@@ -54,7 +52,7 @@ class TestGemSecurityPolicy < Gem::TestC
     )
 
     @root = Gem::Security::Policy.new(
-      'Root',
+      "Root",
       :verify_data   => true,
       :verify_signer => true,
       :verify_chain  => true,
@@ -65,7 +63,7 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_data
-    data = digest 'hello'
+    data = digest "hello"
 
     signature = sign data
 
@@ -73,17 +71,17 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_data_invalid
-    data = digest 'hello'
+    data = digest "hello"
 
     signature = sign data
 
-    invalid = digest 'hello!'
+    invalid = digest "hello!"
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @almost_no.check_data PUBLIC_KEY, @digest, signature, invalid
     end
 
-    assert_equal 'invalid signature', e.message
+    assert_equal "invalid signature", e.message
   end
 
   def test_check_chain
@@ -93,17 +91,17 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_chain_empty_chain
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @chain.check_chain [], Time.now
     end
 
-    assert_equal 'empty signing chain', e.message
+    assert_equal "empty signing chain", e.message
   end
 
   def test_check_chain_invalid
     chain = [PUBLIC_CERT, CHILD_CERT, INVALIDCHILD_CERT]
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @chain.check_chain chain, Time.now
     end
 
@@ -113,11 +111,11 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_chain_no_chain
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @chain.check_chain nil, Time.now
     end
 
-    assert_equal 'missing signing chain', e.message
+    assert_equal "missing signing chain", e.message
   end
 
   def test_check_cert
@@ -125,7 +123,7 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_cert_expired
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @low.check_cert EXPIRED_CERT, nil, Time.now
     end
 
@@ -135,7 +133,7 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_cert_future
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @low.check_cert FUTURE_CERT, nil, Time.now
     end
 
@@ -145,7 +143,7 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_cert_invalid_issuer
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @low.check_cert INVALID_ISSUER_CERT, PUBLIC_CERT, Time.now
     end
 
@@ -159,11 +157,11 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_cert_no_signer
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @high.check_cert(nil, nil, Time.now)
     end
 
-    assert_equal 'missing signing certificate', e.message
+    assert_equal "missing signing certificate", e.message
   end
 
   def test_check_key
@@ -173,15 +171,15 @@ class TestGemSecurityPolicy < Gem::TestC
   def test_check_key_no_signer
     assert @almost_no.check_key(nil, nil)
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @high.check_key(nil, nil)
     end
 
-    assert_equal 'missing key or signature', e.message
+    assert_equal "missing key or signature", e.message
   end
 
   def test_check_key_wrong_key
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @almost_no.check_key(PUBLIC_CERT, ALTERNATE_KEY)
     end
 
@@ -196,17 +194,17 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_root_empty_chain
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @chain.check_root [], Time.now
     end
 
-    assert_equal 'missing root certificate', e.message
+    assert_equal "missing root certificate", e.message
   end
 
   def test_check_root_invalid_signer
     chain = [INVALID_SIGNER_CERT]
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @chain.check_root chain, Time.now
     end
 
@@ -218,7 +216,7 @@ class TestGemSecurityPolicy < Gem::TestC
   def test_check_root_not_self_signed
     chain = [INVALID_ISSUER_CERT]
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @chain.check_root chain, Time.now
     end
 
@@ -228,11 +226,11 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_root_no_chain
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @chain.check_root nil, Time.now
     end
 
-    assert_equal 'missing signing chain', e.message
+    assert_equal "missing signing chain", e.message
   end
 
   def test_check_trust
@@ -248,17 +246,17 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_trust_empty_chain
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @chain.check_trust [], @digest, @trust_dir
     end
 
-    assert_equal 'missing root certificate', e.message
+    assert_equal "missing root certificate", e.message
   end
 
   def test_check_trust_mismatch
     Gem::Security.trust_dir.trust_cert PUBLIC_CERT
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @high.check_trust [WRONG_KEY_CERT], @digest, @trust_dir
     end
 
@@ -267,15 +265,15 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_trust_no_chain
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @chain.check_trust nil, @digest, @trust_dir
     end
 
-    assert_equal 'missing signing chain', e.message
+    assert_equal "missing signing chain", e.message
   end
 
   def test_check_trust_no_trust
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @high.check_trust [PUBLIC_CERT], @digest, @trust_dir
     end
 
@@ -283,7 +281,7 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_check_trust_no_trust_child
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @high.check_trust [PUBLIC_CERT, CHILD_CERT], @digest, @trust_dir
     end
 
@@ -292,8 +290,8 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def test_subject
-    assert_equal 'email:nobody@example', @no.subject(PUBLIC_CERT)
-    assert_equal '/C=JP/ST=Tokyo/O=RubyGemsTest/CN=CA', @no.subject(CA_CERT)
+    assert_equal "email:nobody@example", @no.subject(PUBLIC_CERT)
+    assert_equal "/C=JP/ST=Tokyo/O=RubyGemsTest/CN=CA", @no.subject(CA_CERT)
   end
 
   def test_verify
@@ -317,11 +315,11 @@ class TestGemSecurityPolicy < Gem::TestC
 
     _, signatures = dummy_signatures
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @almost_no.verify [PUBLIC_CERT], nil, {}, signatures
     end
 
-    assert_equal 'no digests provided (probable bug)', e.message
+    assert_equal "no digests provided (probable bug)", e.message
   end
 
   def test_verify_no_digests_no_security
@@ -329,11 +327,11 @@ class TestGemSecurityPolicy < Gem::TestC
 
     _, signatures = dummy_signatures
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @no.verify [PUBLIC_CERT], nil, {}, signatures
     end
 
-    assert_equal 'missing digest for 0', e.message
+    assert_equal "missing digest for 0", e.message
   end
 
   def test_verify_no_signatures
@@ -342,12 +340,12 @@ class TestGemSecurityPolicy < Gem::TestC
     digests, = dummy_signatures
 
     use_ui @ui do
-      @no.verify [PUBLIC_CERT], nil, digests, {}, 'some_gem'
+      @no.verify [PUBLIC_CERT], nil, digests, {}, "some_gem"
     end
 
     assert_match "WARNING:  some_gem is not signed\n", @ui.error
 
-    assert_raises Gem::Security::Exception do
+    assert_raise Gem::Security::Exception do
       @high.verify [PUBLIC_CERT], nil, digests, {}
     end
   end
@@ -356,7 +354,7 @@ class TestGemSecurityPolicy < Gem::TestC
     Gem::Security.trust_dir.trust_cert PUBLIC_CERT
 
     use_ui @ui do
-      @no.verify [PUBLIC_CERT], nil, {}, {}, 'some_gem'
+      @no.verify [PUBLIC_CERT], nil, {}, {}, "some_gem"
     end
 
     assert_empty @ui.output
@@ -368,28 +366,28 @@ class TestGemSecurityPolicy < Gem::TestC
 
     digests, signatures = dummy_signatures
 
-    data = digest 'goodbye'
+    data = digest "goodbye"
 
     signatures[1] = PRIVATE_KEY.sign @digest.new, data.digest
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @almost_no.verify [PUBLIC_CERT], nil, digests, signatures
     end
 
-    assert_equal 'missing digest for 1', e.message
+    assert_equal "missing digest for 1", e.message
   end
 
   def test_verify_no_trust
     digests, signatures = dummy_signatures
 
     use_ui @ui do
-      @low.verify [PUBLIC_CERT], nil, digests, signatures, 'some_gem'
+      @low.verify [PUBLIC_CERT], nil, digests, signatures, "some_gem"
     end
 
     assert_equal "WARNING:  email:nobody@example is not trusted for some_gem\n",
                  @ui.error
 
-    assert_raises Gem::Security::Exception do
+    assert_raise Gem::Security::Exception do
       @medium.verify [PUBLIC_CERT], nil, digests, signatures
     end
   end
@@ -397,20 +395,18 @@ class TestGemSecurityPolicy < Gem::TestC
   def test_verify_wrong_digest_type
     Gem::Security.trust_dir.trust_cert PUBLIC_CERT
 
-    sha512 = OpenSSL::Digest::SHA512
-
-    data = sha512.new
-    data << 'hello'
+    data = OpenSSL::Digest.new("SHA512")
+    data << "hello"
 
-    digests    = { 'SHA512' => { 0 => data } }
-    signature  = PRIVATE_KEY.sign sha512.new, data.digest
+    digests    = { "SHA512" => { 0 => data } }
+    signature  = PRIVATE_KEY.sign "sha512", data.digest
     signatures = { 0 => signature }
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @almost_no.verify [PUBLIC_CERT], nil, digests, signatures
     end
 
-    assert_equal 'no digests provided (probable bug)', e.message
+    assert_equal "no digests provided (probable bug)", e.message
   end
 
   def test_verify_signatures_chain
@@ -452,17 +448,17 @@ class TestGemSecurityPolicy < Gem::TestC
 
     metadata_gz = Gem::Util.gzip @spec.to_yaml
 
-    package = Gem::Package.new 'nonexistent.gem'
+    package = Gem::Package.new "nonexistent.gem"
     package.checksums[Gem::Security::DIGEST_NAME] = {}
 
     s = StringIO.new metadata_gz
-    def s.full_name() 'metadata.gz' end
+    def s.full_name() "metadata.gz" end
 
     digests = package.digest s
-    metadata_gz_digest = digests[Gem::Security::DIGEST_NAME]['metadata.gz']
+    metadata_gz_digest = digests[Gem::Security::DIGEST_NAME]["metadata.gz"]
 
     signatures = {}
-    signatures['metadata.gz'] =
+    signatures["metadata.gz"] =
       PRIVATE_KEY.sign @digest.new, metadata_gz_digest.digest
 
     assert @high.verify_signatures @spec, digests, signatures
@@ -475,26 +471,26 @@ class TestGemSecurityPolicy < Gem::TestC
 
     metadata_gz = Gem::Util.gzip @spec.to_yaml
 
-    package = Gem::Package.new 'nonexistent.gem'
+    package = Gem::Package.new "nonexistent.gem"
     package.checksums[Gem::Security::DIGEST_NAME] = {}
 
     s = StringIO.new metadata_gz
-    def s.full_name() 'metadata.gz' end
+    def s.full_name() "metadata.gz" end
 
     digests = package.digest s
-    digests[Gem::Security::DIGEST_NAME]['data.tar.gz'] = @digest.new 'hello'
+    digests[Gem::Security::DIGEST_NAME]["data.tar.gz"] = @digest.hexdigest "hello"
 
-    metadata_gz_digest = digests[Gem::Security::DIGEST_NAME]['metadata.gz']
+    metadata_gz_digest = digests[Gem::Security::DIGEST_NAME]["metadata.gz"]
 
     signatures = {}
-    signatures['metadata.gz'] =
+    signatures["metadata.gz"] =
       PRIVATE_KEY.sign @digest.new, metadata_gz_digest.digest
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @high.verify_signatures @spec, digests, signatures
     end
 
-    assert_equal 'missing signature for data.tar.gz', e.message
+    assert_equal "missing signature for data.tar.gz", e.message
   end
 
   def test_verify_signatures_none
@@ -504,16 +500,16 @@ class TestGemSecurityPolicy < Gem::TestC
 
     metadata_gz = Gem::Util.gzip @spec.to_yaml
 
-    package = Gem::Package.new 'nonexistent.gem'
+    package = Gem::Package.new "nonexistent.gem"
     package.checksums[Gem::Security::DIGEST_NAME] = {}
 
     s = StringIO.new metadata_gz
-    def s.full_name() 'metadata.gz' end
+    def s.full_name() "metadata.gz" end
 
     digests = package.digest s
-    digests[Gem::Security::DIGEST_NAME]['data.tar.gz'] = @digest.new 'hello'
+    digests[Gem::Security::DIGEST_NAME]["data.tar.gz"] = @digest.hexdigest "hello"
 
-    assert_raises Gem::Security::Exception do
+    assert_raise Gem::Security::Exception do
       @high.verify_signatures @spec, digests, {}
     end
   end
@@ -529,12 +525,11 @@ class TestGemSecurityPolicy < Gem::TestC
   end
 
   def dummy_signatures(key = PRIVATE_KEY)
-    data = digest 'hello'
+    data = digest "hello"
 
     digests    = { Gem::Security::DIGEST_NAME => { 0 => data } }
     signatures = { 0 => sign(data, key) }
 
     return digests, signatures
   end
-
-end if defined?(OpenSSL::SSL)
+end if Gem::HAVE_OPENSSL
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_security_signer.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_security_signer.rb
@@ -1,19 +1,18 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
-unless defined?(OpenSSL::SSL)
-  warn 'Skipping Gem::Security::Signer tests.  openssl not found.'
+unless Gem::HAVE_OPENSSL
+  warn "Skipping Gem::Security::Signer tests.  openssl not found."
 end
 
 class TestGemSecuritySigner < Gem::TestCase
-
-  ALTERNATE_KEY  = load_key 'alternate'
-  CHILD_KEY      = load_key 'child'
-  GRANDCHILD_KEY = load_key 'grandchild'
-
-  CHILD_CERT      = load_cert 'child'
-  GRANDCHILD_CERT = load_cert 'grandchild'
-  EXPIRED_CERT    = load_cert 'expired'
+  ALTERNATE_KEY  = load_key "alternate"
+  CHILD_KEY      = load_key "child"
+  GRANDCHILD_KEY = load_key "grandchild"
+
+  CHILD_CERT      = load_cert "child"
+  GRANDCHILD_CERT = load_cert "grandchild"
+  EXPIRED_CERT    = load_cert "expired"
 
   def setup
     super
@@ -37,36 +36,36 @@ class TestGemSecuritySigner < Gem::TestC
   def test_initialize_cert_chain_mixed
     signer = Gem::Security::Signer.new nil, [@cert_file, CHILD_CERT]
 
-    assert_equal [PUBLIC_CERT, CHILD_CERT].map { |c| c.to_pem },
-                 signer.cert_chain.map { |c| c.to_pem }
+    assert_equal [PUBLIC_CERT, CHILD_CERT].map {|c| c.to_pem },
+                 signer.cert_chain.map {|c| c.to_pem }
   end
 
   def test_initialize_cert_chain_invalid
-    assert_raises OpenSSL::X509::CertificateError do
-      Gem::Security::Signer.new nil, ['garbage']
+    assert_raise OpenSSL::X509::CertificateError do
+      Gem::Security::Signer.new nil, ["garbage"]
     end
   end
 
   def test_initialize_cert_chain_path
     signer = Gem::Security::Signer.new nil, [@cert_file]
 
-    assert_equal [PUBLIC_CERT].map { |c| c.to_pem },
-                 signer.cert_chain.map { |c| c.to_pem }
+    assert_equal [PUBLIC_CERT].map {|c| c.to_pem },
+                 signer.cert_chain.map {|c| c.to_pem }
   end
 
   def test_initialize_default
-    FileUtils.mkdir_p File.join(Gem.user_home, '.gem')
+    FileUtils.mkdir_p File.join(Gem.user_home, ".gem")
 
-    private_key_path = File.join Gem.user_home, '.gem', 'gem-private_key.pem'
+    private_key_path = File.join Gem.user_home, ".gem", "gem-private_key.pem"
     Gem::Security.write PRIVATE_KEY, private_key_path
 
-    public_cert_path = File.join Gem.user_home, '.gem', 'gem-public_cert.pem'
+    public_cert_path = File.join Gem.user_home, ".gem", "gem-public_cert.pem"
     Gem::Security.write PUBLIC_CERT, public_cert_path
 
     signer = Gem::Security::Signer.new nil, nil
 
     assert_equal PRIVATE_KEY.to_pem, signer.key.to_pem
-    assert_equal [PUBLIC_CERT.to_pem], signer.cert_chain.map { |c| c.to_pem }
+    assert_equal [PUBLIC_CERT.to_pem], signer.cert_chain.map {|c| c.to_pem }
   end
 
   def test_initialize_key_path
@@ -88,7 +87,7 @@ class TestGemSecuritySigner < Gem::TestC
   def test_extract_name
     signer = Gem::Security::Signer.new nil, nil
 
-    assert_equal 'child@example', signer.extract_name(CHILD_CERT)
+    assert_equal "child@example", signer.extract_name(CHILD_CERT)
   end
 
   def test_load_cert_chain
@@ -100,7 +99,7 @@ class TestGemSecuritySigner < Gem::TestC
     signer.load_cert_chain
 
     assert_equal [PUBLIC_CERT.to_pem, CHILD_CERT.to_pem],
-                 signer.cert_chain.map { |c| c.to_pem }
+                 signer.cert_chain.map {|c| c.to_pem }
   end
 
   def test_load_cert_chain_broken
@@ -112,13 +111,13 @@ class TestGemSecuritySigner < Gem::TestC
     signer.load_cert_chain
 
     assert_equal [CHILD_CERT.to_pem, GRANDCHILD_CERT.to_pem],
-                 signer.cert_chain.map { |c| c.to_pem }
+                 signer.cert_chain.map {|c| c.to_pem }
   end
 
   def test_sign
     signer = Gem::Security::Signer.new PRIVATE_KEY, [PUBLIC_CERT]
 
-    signature = signer.sign 'hello'
+    signature = signer.sign "hello"
 
     expected = <<-EXPECTED
 cHze2sEfRysoUMCfGVAx/7o8jxj5liJJ2ptNxe2jf3l+EZvyjdqpXo9Ndzxx
@@ -129,32 +128,32 @@ qhlqFP4jR6zXFeyBCOr0KpTiWBNuxBFXDsxmhGyt
 toqvglr0kdbknSRRjBVLK6tsgr07aLT9gNP7mTW2PA==
     EXPECTED
 
-    assert_equal expected, [signature].pack('m')
+    assert_equal expected, [signature].pack("m")
   end
 
   def test_sign_expired
     signer = Gem::Security::Signer.new PRIVATE_KEY, [EXPIRED_CERT]
 
-    e = assert_raises Gem::Security::Exception do
-      signer.sign 'hello'
+    e = assert_raise Gem::Security::Exception do
+      signer.sign "hello"
     end
 
     assert_match "certificate /CN=nobody/DC=example not valid after 1970-01-01 00:00:00 UTC", e.message
   end
 
   def test_sign_expired_auto_update
-    skip if Gem.java_platform?
-    FileUtils.mkdir_p File.join(Gem.user_home, '.gem'), :mode => 0700
+    pend if Gem.java_platform?
+    FileUtils.mkdir_p File.join(Gem.user_home, ".gem"), :mode => 0700
 
-    private_key_path = File.join(Gem.user_home, '.gem', 'gem-private_key.pem')
+    private_key_path = File.join(Gem.user_home, ".gem", "gem-private_key.pem")
     Gem::Security.write PRIVATE_KEY, private_key_path
 
-    cert_path = File.join Gem.user_home, '.gem', 'gem-public_cert.pem'
+    cert_path = File.join Gem.user_home, ".gem", "gem-public_cert.pem"
     Gem::Security.write EXPIRED_CERT, cert_path
 
     signer = Gem::Security::Signer.new PRIVATE_KEY, [EXPIRED_CERT]
 
-    signer.sign 'hello'
+    signer.sign "hello"
 
     cert = OpenSSL::X509::Certificate.new File.read cert_path
 
@@ -164,14 +163,14 @@ toqvglr0kdbknSRRjBVLK6tsgr07aLT9gNP7mTW2
     expiry = EXPIRED_CERT.not_after.strftime "%Y%m%d%H%M%S"
 
     expired_path =
-      File.join Gem.user_home, '.gem', "gem-public_cert.pem.expired.#{expiry}"
+      File.join Gem.user_home, ".gem", "gem-public_cert.pem.expired.#{expiry}"
 
-    assert_path_exists expired_path
+    assert_path_exist expired_path
     assert_equal EXPIRED_CERT.to_pem, File.read(expired_path)
   end
 
   def test_sign_expired_auto_update_exists
-    FileUtils.mkdir_p File.join(Gem.user_home, '.gem'), :mode => 0700
+    FileUtils.mkdir_p File.join(Gem.user_home, ".gem"), :mode => 0700
 
     expiry = EXPIRED_CERT.not_after.strftime "%Y%m%d%H%M%S"
     expired_path =
@@ -179,41 +178,40 @@ toqvglr0kdbknSRRjBVLK6tsgr07aLT9gNP7mTW2
 
     Gem::Security.write EXPIRED_CERT, expired_path
 
-    private_key_path = File.join(Gem.user_home, 'gem-private_key.pem')
+    private_key_path = File.join(Gem.user_home, "gem-private_key.pem")
     Gem::Security.write PRIVATE_KEY, private_key_path
 
-    cert_path = File.join Gem.user_home, 'gem-public_cert.pem'
+    cert_path = File.join Gem.user_home, "gem-public_cert.pem"
     Gem::Security.write EXPIRED_CERT, cert_path
 
     signer = Gem::Security::Signer.new PRIVATE_KEY, [EXPIRED_CERT]
 
-    e = assert_raises Gem::Security::Exception do
-      signer.sign 'hello'
+    e = assert_raise Gem::Security::Exception do
+      signer.sign "hello"
     end
 
-    assert_match %r%certificate /CN=nobody/DC=example not valid%, e.message
+    assert_match %r{certificate /CN=nobody/DC=example not valid}, e.message
   end
 
   def test_sign_no_key
     signer = Gem::Security::Signer.new nil, nil
 
-    assert_nil signer.sign 'stuff'
+    assert_nil signer.sign "stuff"
   end
 
   def test_sign_wrong_key
     signer = Gem::Security::Signer.new ALTERNATE_KEY, [PUBLIC_CERT]
 
-    assert_raises Gem::Security::Exception do
-      signer.sign 'hello'
+    assert_raise Gem::Security::Exception do
+      signer.sign "hello"
     end
   end
 
   def test_sign_no_certs
     signer = Gem::Security::Signer.new ALTERNATE_KEY, []
 
-    assert_raises Gem::Security::Exception do
-      signer.sign 'hello'
+    assert_raise Gem::Security::Exception do
+      signer.sign "hello"
     end
   end
-
-end if defined?(OpenSSL::SSL)
+end if Gem::HAVE_OPENSSL
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_security_trust_dir.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_security_trust_dir.rb
@@ -1,24 +1,23 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
-unless defined?(OpenSSL::SSL)
-  warn 'Skipping Gem::Security::TrustDir tests.  openssl not found.'
+unless Gem::HAVE_OPENSSL
+  warn "Skipping Gem::Security::TrustDir tests.  openssl not found."
 end
 
 class TestGemSecurityTrustDir < Gem::TestCase
-
-  CHILD_CERT = load_cert 'child'
+  CHILD_CERT = load_cert "child"
 
   def setup
     super
 
-    @dest_dir = File.join @tempdir, 'trust'
+    @dest_dir = File.join @tempdir, "trust"
 
     @trust_dir = Gem::Security::TrustDir.new @dest_dir
   end
 
   def test_cert_path
-    digest = Gem::Security::DIGEST_ALGORITHM.hexdigest PUBLIC_CERT.subject.to_s
+    digest = OpenSSL::Digest.hexdigest Gem::Security::DIGEST_NAME, PUBLIC_CERT.subject.to_s
 
     expected = File.join @dest_dir, "cert-#{digest}.pem"
 
@@ -42,7 +41,7 @@ class TestGemSecurityTrustDir < Gem::Tes
   end
 
   def test_name_path
-    digest = Gem::Security::DIGEST_ALGORITHM.hexdigest PUBLIC_CERT.subject.to_s
+    digest = OpenSSL::Digest.hexdigest Gem::Security::DIGEST_NAME, PUBLIC_CERT.subject.to_s
 
     expected = File.join @dest_dir, "cert-#{digest}.pem"
 
@@ -54,7 +53,7 @@ class TestGemSecurityTrustDir < Gem::Tes
 
     trusted = @trust_dir.cert_path PUBLIC_CERT
 
-    assert_path_exists trusted
+    assert_path_exist trusted
 
     mask = 0100600 & (~File.umask)
 
@@ -64,11 +63,11 @@ class TestGemSecurityTrustDir < Gem::Tes
   end
 
   def test_verify
-    refute_path_exists @dest_dir
+    assert_path_not_exist @dest_dir
 
     @trust_dir.verify
 
-    assert_path_exists @dest_dir
+    assert_path_exist @dest_dir
 
     mask = 040700 & (~File.umask)
     mask |= 0200000 if /aix/ =~ RUBY_PLATFORM
@@ -79,7 +78,7 @@ class TestGemSecurityTrustDir < Gem::Tes
   def test_verify_file
     FileUtils.touch @dest_dir
 
-    e = assert_raises Gem::Security::Exception do
+    e = assert_raise Gem::Security::Exception do
       @trust_dir.verify
     end
 
@@ -96,5 +95,4 @@ class TestGemSecurityTrustDir < Gem::Tes
 
     assert_equal mask, File.stat(@dest_dir).mode unless win_platform?
   end
-
-end if defined?(OpenSSL::SSL)
+end if Gem::HAVE_OPENSSL
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_server.rb
+++ /dev/null
@@ -1,612 +0,0 @@
-# frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/server'
-require 'stringio'
-
-class Gem::Server
-
-  attr_reader :server
-
-end
-
-class TestGemServer < Gem::TestCase
-
-  def process_based_port
-    0
-  end
-
-  def setup
-    super
-
-    @a1   = quick_gem 'a', '1'
-    @a2   = quick_gem 'a', '2'
-    @a3_p = quick_gem 'a', '3.a'
-
-    @server = Gem::Server.new Gem.dir, process_based_port, false
-    @req = WEBrick::HTTPRequest.new :Logger => nil
-    @res = WEBrick::HTTPResponse.new :HTTPVersion => '1.0'
-  end
-
-  def test_doc_root_3
-    orig_rdoc_version = Gem::RDoc.rdoc_version
-    Gem::RDoc.instance_variable_set :@rdoc_version, Gem::Version.new('3.12')
-
-    assert_equal '/doc_root/X-1/rdoc/index.html', @server.doc_root('X-1')
-
-  ensure
-    Gem::RDoc.instance_variable_set :@rdoc_version, orig_rdoc_version
-  end
-
-  def test_doc_root_4
-    orig_rdoc_version = Gem::RDoc.rdoc_version
-    Gem::RDoc.instance_variable_set :@rdoc_version, Gem::Version.new('4.0')
-
-    assert_equal '/doc_root/X-1/', @server.doc_root('X-1')
-
-  ensure
-    Gem::RDoc.instance_variable_set :@rdoc_version, orig_rdoc_version
-  end
-
-  def test_have_rdoc_4_plus_eh
-    orig_rdoc_version = Gem::RDoc.rdoc_version
-    Gem::RDoc.instance_variable_set(:@rdoc_version, Gem::Version.new('4.0'))
-
-    server = Gem::Server.new Gem.dir, 0, false
-    assert server.have_rdoc_4_plus?
-
-    Gem::RDoc.instance_variable_set :@rdoc_version, Gem::Version.new('3.12')
-
-    server = Gem::Server.new Gem.dir, 0, false
-    refute server.have_rdoc_4_plus?
-
-    Gem::RDoc.instance_variable_set(:@rdoc_version,
-                                    Gem::Version.new('4.0.0.preview2'))
-
-    server = Gem::Server.new Gem.dir, 0, false
-    assert server.have_rdoc_4_plus?
-  ensure
-    Gem::RDoc.instance_variable_set :@rdoc_version, orig_rdoc_version
-  end
-
-  def test_spec_dirs
-    s = Gem::Server.new Gem.dir, process_based_port, false
-
-    assert_equal [File.join(Gem.dir, 'specifications')], s.spec_dirs
-
-    s = Gem::Server.new [Gem.dir, Gem.dir], process_based_port, false
-
-    assert_equal [File.join(Gem.dir, 'specifications'),
-                  File.join(Gem.dir, 'specifications')], s.spec_dirs
-  end
-
-  def test_latest_specs
-    data = StringIO.new "GET /latest_specs.#{Gem.marshal_version} HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    Gem::Deprecate.skip_during do
-      @server.latest_specs @req, @res
-    end
-
-    assert_equal 200, @res.status, @res.body
-    assert_match %r| \d\d:\d\d:\d\d |, @res['date']
-    assert_equal 'application/octet-stream', @res['content-type']
-    assert_equal [['a', Gem::Version.new(2), Gem::Platform::RUBY]],
-    Marshal.load(@res.body)
-  end
-
-  def test_latest_specs_gemdirs
-    data = StringIO.new "GET /latest_specs.#{Gem.marshal_version} HTTP/1.0\r\n\r\n"
-    dir = "#{@gemhome}2"
-
-    spec = util_spec 'z', 9
-
-    specs_dir = File.join dir, 'specifications'
-    FileUtils.mkdir_p specs_dir
-
-    File.open File.join(specs_dir, spec.spec_name), 'w' do |io|
-      io.write spec.to_ruby
-    end
-
-    server = Gem::Server.new dir, process_based_port, false
-
-    @req.parse data
-
-    server.latest_specs @req, @res
-
-    assert_equal 200, @res.status
-
-    assert_equal [['z', v(9), Gem::Platform::RUBY]], Marshal.load(@res.body)
-  end
-
-  def test_latest_specs_gz
-    data = StringIO.new "GET /latest_specs.#{Gem.marshal_version}.gz HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    Gem::Deprecate.skip_during do
-      @server.latest_specs @req, @res
-    end
-
-    assert_equal 200, @res.status, @res.body
-    assert_match %r| \d\d:\d\d:\d\d |, @res['date']
-    assert_equal 'application/x-gzip', @res['content-type']
-    assert_equal [['a', Gem::Version.new(2), Gem::Platform::RUBY]],
-                 Marshal.load(Gem::Util.gunzip(@res.body))
-  end
-
-  def test_listen
-    util_listen
-
-    capture_io do
-      @server.listen
-    end
-
-    assert_equal 1, @server.server.listeners.length
-  end
-
-  def test_listen_addresses
-    util_listen
-
-    capture_io do
-      @server.listen %w[a b]
-    end
-
-    assert_equal 2, @server.server.listeners.length
-  end
-
-  def test_prerelease_specs
-    data = StringIO.new "GET /prerelease_specs.#{Gem.marshal_version} HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    Gem::Deprecate.skip_during do
-      @server.prerelease_specs @req, @res
-    end
-
-    assert_equal 200, @res.status, @res.body
-    assert_match %r| \d\d:\d\d:\d\d |, @res['date']
-    assert_equal 'application/octet-stream', @res['content-type']
-    assert_equal [['a', v('3.a'), Gem::Platform::RUBY]],
-                 Marshal.load(@res.body)
-  end
-
-  def test_prerelease_specs_gz
-    data = StringIO.new "GET /prerelease_specs.#{Gem.marshal_version}.gz HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    Gem::Deprecate.skip_during do
-      @server.prerelease_specs @req, @res
-    end
-
-    assert_equal 200, @res.status, @res.body
-    assert_match %r| \d\d:\d\d:\d\d |, @res['date']
-    assert_equal 'application/x-gzip', @res['content-type']
-    assert_equal [['a', v('3.a'), Gem::Platform::RUBY]],
-                 Marshal.load(Gem::Util.gunzip(@res.body))
-  end
-
-  def test_quick_gemdirs
-    data = StringIO.new "GET /quick/Marshal.4.8/z-9.gemspec.rz HTTP/1.0\r\n\r\n"
-    dir = "#{@gemhome}2"
-
-    server = Gem::Server.new dir, process_based_port, false
-
-    @req.parse data
-
-    server.quick @req, @res
-
-    assert_equal 404, @res.status
-
-    spec = util_spec 'z', 9
-
-    specs_dir = File.join dir, 'specifications'
-
-    FileUtils.mkdir_p specs_dir
-
-    File.open File.join(specs_dir, spec.spec_name), 'w' do |io|
-      io.write spec.to_ruby
-    end
-
-    data.rewind
-
-    req = WEBrick::HTTPRequest.new :Logger => nil
-    res = WEBrick::HTTPResponse.new :HTTPVersion => '1.0'
-    req.parse data
-
-    server.quick req, res
-
-    assert_equal 200, res.status
-  end
-
-  def test_quick_missing
-    data = StringIO.new "GET /quick/Marshal.4.8/z-9.gemspec.rz HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    @server.quick @req, @res
-
-    assert_equal 404, @res.status, @res.body
-    assert_match %r| \d\d:\d\d:\d\d |, @res['date']
-    assert_equal 'text/plain', @res['content-type']
-    assert_equal 'No gems found matching "z-9"', @res.body
-    assert_equal 404, @res.status
-  end
-
-  def test_quick_marshal_a_1_gemspec_rz
-    data = StringIO.new "GET /quick/Marshal.#{Gem.marshal_version}/a-1.gemspec.rz HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    @server.quick @req, @res
-
-    assert_equal 200, @res.status, @res.body
-    assert @res['date']
-    assert_equal 'application/x-deflate', @res['content-type']
-
-    spec = Marshal.load Gem::Util.inflate(@res.body)
-    assert_equal 'a', spec.name
-    assert_equal Gem::Version.new(1), spec.version
-  end
-
-  def test_quick_marshal_a_1_mswin32_gemspec_rz
-    quick_gem 'a', '1' do |s|
-      s.platform = Gem::Platform.local
-    end
-
-    data = StringIO.new "GET /quick/Marshal.#{Gem.marshal_version}/a-1-#{Gem::Platform.local}.gemspec.rz HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    @server.quick @req, @res
-
-    assert_equal 200, @res.status, @res.body
-    assert @res['date']
-    assert_equal 'application/x-deflate', @res['content-type']
-
-    spec = Marshal.load Gem::Util.inflate(@res.body)
-    assert_equal 'a', spec.name
-    assert_equal Gem::Version.new(1), spec.version
-    assert_equal Gem::Platform.local, spec.platform
-  end
-
-  def test_quick_marshal_a_3_a_gemspec_rz
-    data = StringIO.new "GET /quick/Marshal.#{Gem.marshal_version}/a-3.a.gemspec.rz HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    @server.quick @req, @res
-
-    assert_equal 200, @res.status, @res.body
-    assert @res['date']
-    assert_equal 'application/x-deflate', @res['content-type']
-
-    spec = Marshal.load Gem::Util.inflate(@res.body)
-    assert_equal 'a', spec.name
-    assert_equal v('3.a'), spec.version
-  end
-
-  def test_quick_marshal_a_b_3_a_gemspec_rz
-    quick_gem 'a-b', '3.a'
-
-    data = StringIO.new "GET /quick/Marshal.#{Gem.marshal_version}/a-b-3.a.gemspec.rz HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    @server.quick @req, @res
-
-    assert_equal 200, @res.status, @res.body
-    assert @res['date']
-    assert_equal 'application/x-deflate', @res['content-type']
-
-    spec = Marshal.load Gem::Util.inflate(@res.body)
-    assert_equal 'a-b', spec.name
-    assert_equal v('3.a'), spec.version
-  end
-
-  def test_quick_marshal_a_b_1_3_a_gemspec_rz
-    quick_gem 'a-b-1', '3.a'
-
-    data = StringIO.new "GET /quick/Marshal.#{Gem.marshal_version}/a-b-1-3.a.gemspec.rz HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    @server.quick @req, @res
-
-    assert_equal 200, @res.status, @res.body
-    assert @res['date']
-    assert_equal 'application/x-deflate', @res['content-type']
-
-    spec = Marshal.load Gem::Util.inflate(@res.body)
-    assert_equal 'a-b-1', spec.name
-    assert_equal v('3.a'), spec.version
-  end
-
-  def test_rdoc
-    data = StringIO.new "GET /rdoc?q=a HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    @server.rdoc @req, @res
-
-    assert_equal 200, @res.status, @res.body
-    assert_match %r|No documentation found|, @res.body
-    assert_equal 'text/html', @res['content-type']
-  end
-
-  def test_root
-    data = StringIO.new "GET / HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    @server.root @req, @res
-
-    assert_equal 200, @res.status, @res.body
-    assert_match %r| \d\d:\d\d:\d\d |, @res['date']
-    assert_equal 'text/html', @res['content-type']
-  end
-
-  def test_root_gemdirs
-    data = StringIO.new "GET / HTTP/1.0\r\n\r\n"
-    dir = "#{@gemhome}2"
-
-    spec = util_spec 'z', 9
-
-    specs_dir = File.join dir, 'specifications'
-    FileUtils.mkdir_p specs_dir
-
-    File.open File.join(specs_dir, spec.spec_name), 'w' do |io|
-      io.write spec.to_ruby
-    end
-
-    server = Gem::Server.new dir, process_based_port, false
-
-    @req.parse data
-
-    server.root @req, @res
-
-    assert_equal 200, @res.status
-    assert_match 'z 9', @res.body
-  end
-
-  def test_xss_homepage_fix_289313
-    data = StringIO.new "GET / HTTP/1.0\r\n\r\n"
-    dir = "#{@gemhome}2"
-
-    spec = util_spec 'xsshomepagegem', 1
-    spec.homepage = "javascript:confirm(document.domain)"
-
-    specs_dir = File.join dir, 'specifications'
-    FileUtils.mkdir_p specs_dir
-
-    open File.join(specs_dir, spec.spec_name), 'w' do |io|
-      io.write spec.to_ruby
-    end
-
-    server = Gem::Server.new dir, process_based_port, false
-
-    @req.parse data
-
-    server.root @req, @res
-
-    assert_equal 200, @res.status
-    assert_match 'xsshomepagegem 1', @res.body
-
-    # This verifies that the homepage for this spec is not displayed and is set to ".", because it's not a
-    # valid HTTP/HTTPS URL and could be unsafe in an HTML context.  We would prefer to throw an exception here,
-    # but spec.homepage is currently free form and not currently required to be a URL, this behavior may be
-    # validated in future versions of Gem::Specification.
-    #
-    # There are two variant we're checking here, one where rdoc is not present, and one where rdoc is present in the same regex:
-    #
-    # Variant #1 - rdoc not installed
-    #
-    #   <b>xsshomepagegem 1</b>
-    #
-    #
-    #  <span title="rdoc not installed">[rdoc]</span>
-    #
-    #
-    #
-    #  <a href="." title=".">[www]</a>
-    #
-    # Variant #2 - rdoc installed
-    #
-    #   <b>xsshomepagegem 1</b>
-    #
-    #
-    #  <a href="\/doc_root\/xsshomepagegem-1\/">\[rdoc\]<\/a>
-    #
-    #
-    #
-    #  <a href="." title=".">[www]</a>
-    regex_match = /xsshomepagegem 1<\/b>\s+(<span title="rdoc not installed">\[rdoc\]<\/span>|<a href="\/doc_root\/xsshomepagegem-1\/">\[rdoc\]<\/a>)\s+<a href="\." title="\.">\[www\]<\/a>/
-    assert_match regex_match, @res.body
-  end
-
-  def test_invalid_homepage
-    data = StringIO.new "GET / HTTP/1.0\r\n\r\n"
-    dir = "#{@gemhome}2"
-
-    spec = util_spec 'invalidhomepagegem', 1
-    spec.homepage = "notavalidhomepageurl"
-
-    specs_dir = File.join dir, 'specifications'
-    FileUtils.mkdir_p specs_dir
-
-    open File.join(specs_dir, spec.spec_name), 'w' do |io|
-      io.write spec.to_ruby
-    end
-
-    server = Gem::Server.new dir, process_based_port, false
-
-    @req.parse data
-
-    server.root @req, @res
-
-    assert_equal 200, @res.status
-    assert_match 'invalidhomepagegem 1', @res.body
-
-    # This verifies that the homepage for this spec is not displayed and is set to ".", because it's not a
-    # valid HTTP/HTTPS URL and could be unsafe in an HTML context.  We would prefer to throw an exception here,
-    # but spec.homepage is currently free form and not currently required to be a URL, this behavior may be
-    # validated in future versions of Gem::Specification.
-    #
-    # There are two variant we're checking here, one where rdoc is not present, and one where rdoc is present in the same regex:
-    #
-    # Variant #1 - rdoc not installed
-    #
-    #   <b>invalidhomepagegem 1</b>
-    #
-    #
-    #  <span title="rdoc not installed">[rdoc]</span>
-    #
-    #
-    #
-    #  <a href="." title=".">[www]</a>
-    #
-    # Variant #2 - rdoc installed
-    #
-    #   <b>invalidhomepagegem 1</b>
-    #
-    #
-    #  <a href="\/doc_root\/invalidhomepagegem-1\/">\[rdoc\]<\/a>
-    #
-    #
-    #
-    #  <a href="." title=".">[www]</a>
-    regex_match = /invalidhomepagegem 1<\/b>\s+(<span title="rdoc not installed">\[rdoc\]<\/span>|<a href="\/doc_root\/invalidhomepagegem-1\/">\[rdoc\]<\/a>)\s+<a href="\." title="\.">\[www\]<\/a>/
-    assert_match regex_match, @res.body
-  end
-
-  def test_valid_homepage_http
-    data = StringIO.new "GET / HTTP/1.0\r\n\r\n"
-    dir = "#{@gemhome}2"
-
-    spec = util_spec 'validhomepagegemhttp', 1
-    spec.homepage = "http://rubygems.org"
-
-    specs_dir = File.join dir, 'specifications'
-    FileUtils.mkdir_p specs_dir
-
-    open File.join(specs_dir, spec.spec_name), 'w' do |io|
-      io.write spec.to_ruby
-    end
-
-    server = Gem::Server.new dir, process_based_port, false
-
-    @req.parse data
-
-    server.root @req, @res
-
-    assert_equal 200, @res.status
-    assert_match 'validhomepagegemhttp 1', @res.body
-
-    regex_match = /validhomepagegemhttp 1<\/b>\s+(<span title="rdoc not installed">\[rdoc\]<\/span>|<a href="\/doc_root\/validhomepagegemhttp-1\/">\[rdoc\]<\/a>)\s+<a href="http:\/\/rubygems\.org" title="http:\/\/rubygems\.org">\[www\]<\/a>/
-    assert_match regex_match, @res.body
-  end
-
-  def test_valid_homepage_https
-    data = StringIO.new "GET / HTTP/1.0\r\n\r\n"
-    dir = "#{@gemhome}2"
-
-    spec = util_spec 'validhomepagegemhttps', 1
-    spec.homepage = "https://rubygems.org"
-
-    specs_dir = File.join dir, 'specifications'
-    FileUtils.mkdir_p specs_dir
-
-    open File.join(specs_dir, spec.spec_name), 'w' do |io|
-      io.write spec.to_ruby
-    end
-
-    server = Gem::Server.new dir, process_based_port, false
-
-    @req.parse data
-
-    server.root @req, @res
-
-    assert_equal 200, @res.status
-    assert_match 'validhomepagegemhttps 1', @res.body
-
-    regex_match = /validhomepagegemhttps 1<\/b>\s+(<span title="rdoc not installed">\[rdoc\]<\/span>|<a href="\/doc_root\/validhomepagegemhttps-1\/">\[rdoc\]<\/a>)\s+<a href="https:\/\/rubygems\.org" title="https:\/\/rubygems\.org">\[www\]<\/a>/
-    assert_match regex_match, @res.body
-  end
-
-  def test_specs
-    data = StringIO.new "GET /specs.#{Gem.marshal_version} HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    @server.specs @req, @res
-
-    assert_equal 200, @res.status, @res.body
-    assert_match %r| \d\d:\d\d:\d\d |, @res['date']
-    assert_equal 'application/octet-stream', @res['content-type']
-
-    assert_equal [['a', Gem::Version.new(1), Gem::Platform::RUBY],
-                  ['a', Gem::Version.new(2), Gem::Platform::RUBY],
-                  ['a', v('3.a'), Gem::Platform::RUBY]],
-                 Marshal.load(@res.body)
-  end
-
-  def test_specs_gemdirs
-    data = StringIO.new "GET /specs.#{Gem.marshal_version} HTTP/1.0\r\n\r\n"
-    dir = "#{@gemhome}2"
-
-    spec = util_spec 'z', 9
-
-    specs_dir = File.join dir, 'specifications'
-    FileUtils.mkdir_p specs_dir
-
-    File.open File.join(specs_dir, spec.spec_name), 'w' do |io|
-      io.write spec.to_ruby
-    end
-
-    server = Gem::Server.new dir, process_based_port, false
-
-    @req.parse data
-
-    server.specs @req, @res
-
-    assert_equal 200, @res.status
-
-    assert_equal [['z', v(9), Gem::Platform::RUBY]], Marshal.load(@res.body)
-  end
-
-  def test_specs_gz
-    data = StringIO.new "GET /specs.#{Gem.marshal_version}.gz HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    @server.specs @req, @res
-
-    assert_equal 200, @res.status, @res.body
-    assert_match %r| \d\d:\d\d:\d\d |, @res['date']
-    assert_equal 'application/x-gzip', @res['content-type']
-
-    assert_equal [['a', Gem::Version.new(1), Gem::Platform::RUBY],
-                  ['a', Gem::Version.new(2), Gem::Platform::RUBY],
-                  ['a', v('3.a'), Gem::Platform::RUBY]],
-                 Marshal.load(Gem::Util.gunzip(@res.body))
-  end
-
-  def test_uri_encode
-    url_safe = @server.uri_encode 'http://rubyonrails.org/">malicious_content</a>'
-    assert_equal url_safe, 'http://rubyonrails.org/%22%3Emalicious_content%3C/a%3E'
-  end
-
-  # Regression test for issue #1793: incorrect URL encoding.
-  # Checking that no URLs have had '://' incorrectly encoded
-  def test_regression_1793
-    data = StringIO.new "GET / HTTP/1.0\r\n\r\n"
-    @req.parse data
-
-    @server.root @req, @res
-
-    refute_match %r|%3A%2F%2F|, @res.body
-  end
-
-  def util_listen
-    webrick = Object.new
-    webrick.instance_variable_set :@listeners, []
-    def webrick.listeners() @listeners end
-    def webrick.listen(host, port)
-      socket = Object.new
-      socket.instance_variable_set :@host, host
-      socket.instance_variable_set :@port, port
-      def socket.addr() [nil, @port, @host] end
-      @listeners << socket
-    end
-
-    @server.instance_variable_set :@server, webrick
-  end
-
-end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_silent_ui.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_silent_ui.rb
@@ -1,10 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/user_interaction'
-require 'timeout'
+require_relative "helper"
+require "rubygems/user_interaction"
+require "timeout"
 
 class TestGemSilentUI < Gem::TestCase
-
   def setup
     super
     @sui = Gem::SilentUI.new
@@ -17,102 +16,107 @@ class TestGemSilentUI < Gem::TestCase
 
   def test_ask
     value = nil
-    out, err = capture_io do
+    out, err = capture_output do
       use_ui @sui do
-        value = @sui.ask 'Problem?'
+        value = @sui.ask "Problem?"
       end
     end
 
-    assert_empty out, 'No output'
-    assert_empty err, 'No output'
+    assert_empty out, "No output"
+    assert_empty err, "No output"
 
-    assert_nil value, 'No value'
+    assert_nil value, "No value"
   end
 
   def test_ask_for_password
     value = nil
-    out, err = capture_io do
+    out, err = capture_output do
       use_ui @sui do
-        value = @sui.ask_for_password 'Problem?'
+        value = @sui.ask_for_password "Problem?"
       end
     end
 
-    assert_empty out, 'No output'
-    assert_empty err, 'No output'
+    assert_empty out, "No output"
+    assert_empty err, "No output"
 
-    assert_nil value, 'No value'
+    assert_nil value, "No value"
   end
 
   def test_ask_yes_no
     value = nil
-    out, err = capture_io do
+    out, err = capture_output do
       use_ui @sui do
-        assert_raises(Gem::OperationNotSupportedError) do
-          @sui.ask_yes_no 'Problem?'
+        assert_raise(Gem::OperationNotSupportedError) do
+          @sui.ask_yes_no "Problem?"
         end
       end
     end
 
-    assert_empty out, 'No output'
-    assert_empty err, 'No output'
+    assert_empty out, "No output"
+    assert_empty err, "No output"
 
-    out, err = capture_io do
+    out, err = capture_output do
       use_ui @sui do
-        value = @sui.ask_yes_no 'Problem?', true
+        value = @sui.ask_yes_no "Problem?", true
       end
     end
 
-    assert_empty out, 'No output'
-    assert_empty err, 'No output'
+    assert_empty out, "No output"
+    assert_empty err, "No output"
 
-    assert value, 'Value is true'
+    assert value, "Value is true"
 
-    out, err = capture_io do
+    out, err = capture_output do
       use_ui @sui do
-        value = @sui.ask_yes_no 'Problem?', false
+        value = @sui.ask_yes_no "Problem?", false
       end
     end
 
-    assert_empty out, 'No output'
-    assert_empty err, 'No output'
+    assert_empty out, "No output"
+    assert_empty err, "No output"
 
-    assert_equal value, false, 'Value is false'
+    assert_equal value, false, "Value is false"
   end
 
   def test_choose_from_list
     value = nil
-    out, err = capture_io do
+    out, err = capture_output do
       use_ui @sui do
-        value = @sui.choose_from_list 'Problem?', %w[yes no]
+        value = @sui.choose_from_list "Problem?", %w[yes no]
       end
     end
 
-    assert_empty out, 'No output'
-    assert_empty err, 'No output'
+    assert_empty out, "No output"
+    assert_empty err, "No output"
 
-    assert_equal [nil, nil], value, 'Value is nil!'
+    assert_equal [nil, nil], value, "Value is nil!"
   end
 
   def test_progress_reporter
-    out, err = capture_io do
+    out, err = capture_output do
       use_ui @sui do
-        @sui.progress_reporter 10, 'hi'
+        @sui.progress_reporter 10, "hi"
       end
     end
 
-    assert_empty out, 'No output'
-    assert_empty err, 'No output'
+    assert_empty out, "No output"
+    assert_empty err, "No output"
   end
 
   def test_download_reporter
-    out, err = capture_io do
+    out, err = capture_output do
       use_ui @sui do
-        @sui.download_reporter.fetch 'a.gem', 1024
+        @sui.download_reporter.fetch "a.gem", 1024
       end
     end
 
-    assert_empty out, 'No output'
-    assert_empty err, 'No output'
+    assert_empty out, "No output"
+    assert_empty err, "No output"
   end
 
+  def test_new_without_dev_null
+    File.stub(:open, ->(path, mode) { raise Errno::ENOTCAPABLE if path == IO::NULL }) do
+      Gem::SilentUI.new
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_source.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_source.rb
@@ -1,10 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/source'
-require 'rubygems/indexer'
+require_relative "helper"
+require "rubygems/source"
+require "rubygems/indexer"
 
 class TestGemSource < Gem::TestCase
-
   def tuple(*args)
     Gem::NameTuple.new(*args)
   end
@@ -13,25 +12,25 @@ class TestGemSource < Gem::TestCase
     super
 
     @specs = spec_fetcher do |fetcher|
-      fetcher.spec 'a', '1.a'
-      fetcher.gem  'a', 1
-      fetcher.spec 'a', 2
-      fetcher.spec 'b', 2
+      fetcher.spec "a", "1.a"
+      fetcher.gem  "a", 1
+      fetcher.spec "a", 2
+      fetcher.spec "b", 2
     end
 
     @source = Gem::Source.new(@gem_repo)
   end
 
   def test_initialize_invalid_uri
-    assert_raises URI::InvalidURIError do
-      Gem::Source.new 'git@example:a.git'
+    assert_raise URI::InvalidURIError do
+      Gem::Source.new "git@example:a.git"
     end
   end
 
   def test_initialize_git
-    repository = 'git@example:a.git'
+    repository = "git@example:a.git"
 
-    source = Gem::Source::Git.new 'a', repository, 'master', false
+    source = Gem::Source::Git.new "a", repository, "master", false
 
     assert_equal repository, source.uri
   end
@@ -39,15 +38,15 @@ class TestGemSource < Gem::TestCase
   def test_cache_dir_escapes_windows_paths
     uri = URI.parse("file:///C:/WINDOWS/Temp/gem_repo")
     root = Gem.spec_cache_dir
-    cache_dir = @source.cache_dir(uri).gsub(root, '')
+    cache_dir = @source.cache_dir(uri).gsub(root, "")
     assert cache_dir !~ /:/, "#{cache_dir} should not contain a :"
   end
 
   def test_dependency_resolver_set_bundler_api
-    response = Net::HTTPResponse.new '1.1', 200, 'OK'
-    response.uri = URI('http://example') if response.respond_to? :uri
+    response = Net::HTTPResponse.new "1.1", 200, "OK"
+    response.uri = URI("http://example")
 
-    @fetcher.data["#{@gem_repo}api/v1/dependencies"] = response
+    @fetcher.data[@gem_repo] = response
 
     set = @source.dependency_resolver_set
 
@@ -55,8 +54,6 @@ class TestGemSource < Gem::TestCase
   end
 
   def test_dependency_resolver_set_file_uri
-    skip 'install builder gem' unless defined? Builder::XChar
-
     Gem::Indexer.new(@tempdir).generate_index
 
     source = Gem::Source.new "file://#{@tempdir}/"
@@ -73,11 +70,11 @@ class TestGemSource < Gem::TestCase
   end
 
   def test_fetch_spec
-    a1 = @specs['a-1']
+    a1 = @specs["a-1"]
 
     spec_uri = "#{@gem_repo}#{Gem::MARSHAL_SPEC_DIR}#{a1.spec_name}"
 
-    spec = @source.fetch_spec tuple('a', Gem::Version.new(1), 'ruby')
+    spec = @source.fetch_spec tuple("a", Gem::Version.new(1), "ruby")
     assert_equal a1.full_name, spec.full_name
 
     cache_dir = @source.cache_dir URI.parse(spec_uri)
@@ -88,7 +85,7 @@ class TestGemSource < Gem::TestCase
   end
 
   def test_fetch_spec_cached
-    a1 = @specs['a-1']
+    a1 = @specs["a-1"]
 
     spec_uri = "#{@gem_repo}/#{Gem::MARSHAL_SPEC_DIR}#{a1.spec_name}"
     @fetcher.data["#{spec_uri}.rz"] = nil
@@ -98,11 +95,11 @@ class TestGemSource < Gem::TestCase
 
     cache_file = File.join cache_dir, a1.spec_name
 
-    File.open cache_file, 'wb' do |io|
+    File.open cache_file, "wb" do |io|
       Marshal.dump a1, io
     end
 
-    spec = @source.fetch_spec tuple('a', Gem::Version.new(1), 'ruby')
+    spec = @source.fetch_spec tuple("a", Gem::Version.new(1), "ruby")
     assert_equal a1.full_name, spec.full_name
   end
 
@@ -111,24 +108,24 @@ class TestGemSource < Gem::TestCase
       fetcher.legacy_platform
     end
 
-    spec = @source.fetch_spec tuple('pl', Gem::Version.new(1), 'i386-linux')
+    spec = @source.fetch_spec tuple("pl", Gem::Version.new(1), "i386-linux")
 
-    assert_equal specs['pl-1-x86-linux'].full_name, spec.full_name
+    assert_equal specs["pl-1-x86-linux"].full_name, spec.full_name
   end
 
   def test_fetch_spec_platform_ruby
-    spec = @source.fetch_spec tuple('a', Gem::Version.new(1), nil)
-    assert_equal @specs['a-1'].full_name, spec.full_name
+    spec = @source.fetch_spec tuple("a", Gem::Version.new(1), nil)
+    assert_equal @specs["a-1"].full_name, spec.full_name
 
-    spec = @source.fetch_spec tuple('a', Gem::Version.new(1), '')
-    assert_equal @specs['a-1'].full_name, spec.full_name
+    spec = @source.fetch_spec tuple("a", Gem::Version.new(1), "")
+    assert_equal @specs["a-1"].full_name, spec.full_name
   end
 
   def test_load_specs
-    released = @source.load_specs(:released).map { |spec| spec.full_name }
+    released = @source.load_specs(:released).map {|spec| spec.full_name }
     assert_equal %W[a-2 a-1 b-2], released
 
-    cache_dir = File.join Gem.spec_cache_dir, 'gems.example.com%80'
+    cache_dir = File.join Gem.spec_cache_dir, "gems.example.com%80"
     assert File.exist?(cache_dir), "#{cache_dir} does not exist"
 
     cache_file = File.join cache_dir, "specs.#{Gem.marshal_version}"
@@ -139,19 +136,19 @@ class TestGemSource < Gem::TestCase
     latest_specs = @source.load_specs :latest
 
     # Make sure the cached version is actually different:
-    latest_specs << Gem::NameTuple.new('cached', Gem::Version.new('1.0.0'), 'ruby')
+    latest_specs << Gem::NameTuple.new("cached", Gem::Version.new("1.0.0"), "ruby")
 
     @fetcher.data["#{@gem_repo}latest_specs.#{Gem.marshal_version}.gz"] = nil
     @fetcher.data["#{@gem_repo}latest_specs.#{Gem.marshal_version}"] =
-      ' ' * Marshal.dump(latest_specs).length
+      " " * Marshal.dump(latest_specs).length
 
-    cache_dir = File.join Gem.spec_cache_dir, 'gems.example.com%80'
+    cache_dir = File.join Gem.spec_cache_dir, "gems.example.com%80"
 
     FileUtils.mkdir_p cache_dir
 
     cache_file = File.join cache_dir, "latest_specs.#{Gem.marshal_version}"
 
-    File.open cache_file, 'wb' do |io|
+    File.open cache_file, "wb" do |io|
       Marshal.dump latest_specs, io
     end
 
@@ -164,18 +161,18 @@ class TestGemSource < Gem::TestCase
     latest_specs = @source.load_specs :latest
 
     # Make sure the cached version is actually different:
-    latest_specs << Gem::NameTuple.new('fixed', Gem::Version.new('1.0.0'), 'ruby')
+    latest_specs << Gem::NameTuple.new("fixed", Gem::Version.new("1.0.0"), "ruby")
     # Setup valid data on the 'remote'
     @fetcher.data["#{@gem_repo}latest_specs.#{Gem.marshal_version}.gz"] =
           util_gzip(Marshal.dump(latest_specs))
 
-    cache_dir = File.join Gem.spec_cache_dir, 'gems.example.com%80'
+    cache_dir = File.join Gem.spec_cache_dir, "gems.example.com%80"
 
     FileUtils.mkdir_p cache_dir
 
     cache_file = File.join cache_dir, "latest_specs.#{Gem.marshal_version}"
 
-    File.open cache_file, 'wb' do |io|
+    File.open cache_file, "wb" do |io|
       # Setup invalid data in the cache:
       io.write Marshal.dump(latest_specs)[0, 10]
     end
@@ -188,41 +185,41 @@ class TestGemSource < Gem::TestCase
   def test_load_specs_from_unavailable_uri
     src = Gem::Source.new("http://not-there.nothing")
 
-    assert_raises Gem::RemoteFetcher::FetchError do
+    assert_raise Gem::RemoteFetcher::FetchError do
       src.load_specs :latest
     end
   end
 
   def test_spaceship
     remote    = @source
-    specific  = Gem::Source::SpecificFile.new @specs['a-1'].cache_file
+    specific  = Gem::Source::SpecificFile.new @specs["a-1"].cache_file
     installed = Gem::Source::Installed.new
     local     = Gem::Source::Local.new
 
-    assert_equal(0, remote.   <=>(remote),    'remote    <=> remote')
+    assert_equal(0, remote.<=>(remote), "remote <=> remote")
 
-    assert_equal(-1, remote.   <=>(specific),  'remote    <=> specific')
-    assert_equal(1, specific. <=>(remote),    'specific  <=> remote')
+    assert_equal(-1, remote.<=>(specific), "remote <=> specific")
+    assert_equal(1, specific.<=>(remote), "specific <=> remote")
 
-    assert_equal(-1, remote.   <=>(local),     'remote    <=> local')
-    assert_equal(1, local.    <=>(remote),    'local     <=> remote')
+    assert_equal(-1, remote.<=>(local), "remote <=> local")
+    assert_equal(1, local.<=>(remote), "local <=> remote")
 
-    assert_equal(-1, remote.   <=>(installed), 'remote    <=> installed')
-    assert_equal(1, installed.<=>(remote),    'installed <=> remote')
+    assert_equal(-1, remote.<=>(installed), "remote <=> installed")
+    assert_equal(1, installed.<=>(remote), "installed <=> remote")
 
     no_uri = @source.dup
     no_uri.instance_variable_set :@uri, nil
 
-    assert_equal(-1, remote.   <=>(no_uri),    'remote <=> no_uri')
+    assert_equal(-1, remote.<=>(no_uri), "remote <=> no_uri")
   end
 
   def test_spaceship_order_is_preserved_when_uri_differs
     sourceA = Gem::Source.new "http://example.com/a"
     sourceB = Gem::Source.new "http://example.com/b"
 
-    assert_equal(0, sourceA. <=>(sourceA), 'sourceA <=> sourceA')
-    assert_equal(1, sourceA. <=>(sourceB), 'sourceA <=> sourceB')
-    assert_equal(1, sourceB. <=>(sourceA), 'sourceB <=> sourceA')
+    assert_equal(0, sourceA.<=>(sourceA), "sourceA <=> sourceA")
+    assert_equal(1, sourceA.<=>(sourceB), "sourceA <=> sourceB")
+    assert_equal(1, sourceB.<=>(sourceA), "sourceB <=> sourceA")
   end
 
   def test_update_cache_eh
@@ -243,10 +240,14 @@ class TestGemSource < Gem::TestCase
     refute rubygems_source.typo_squatting?("rubysertgems.org")
   end
 
+  def test_typo_squatting_false_positive
+    rubygems_source = Gem::Source.new("https://rubygems.org")
+    refute rubygems_source.typo_squatting?("rubygems.org")
+  end
+
   def test_typo_squatting_custom_distance_threshold
     rubygems_source = Gem::Source.new("https://rubgems.org")
     distance_threshold = 5
     assert rubygems_source.typo_squatting?("rubysertgems.org", distance_threshold)
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_source_fetch_problem.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_source_fetch_problem.rb
@@ -1,28 +1,36 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemSourceFetchProblem < Gem::TestCase
-
   def test_exception
     source = Gem::Source.new @gem_repo
-    error  = RuntimeError.new 'test'
+    error  = RuntimeError.new "test"
 
     sf = Gem::SourceFetchProblem.new source, error
 
-    e = assert_raises RuntimeError do
+    e = assert_raise RuntimeError do
       raise sf
     end
 
-    assert_equal 'test', e.message
+    assert_equal "test", e.message
   end
 
   def test_password_redacted
-    source = Gem::Source.new 'https://username:secret@gemsource.com'
-    error  = RuntimeError.new 'test'
+    source = Gem::Source.new "https://username:secret@gemsource.com"
+    error  = RuntimeError.new "test"
 
     sf = Gem::SourceFetchProblem.new source, error
 
-    refute_match sf.wordy, 'secret'
+    refute_match sf.wordy, "secret"
   end
 
+  def test_source_password_no_redacted
+    source = Gem::Source.new "https://username:secret@gemsource.com"
+    error  = RuntimeError.new "test"
+
+    sf = Gem::SourceFetchProblem.new source, error
+    sf.wordy
+
+    assert_match "secret", source.uri.to_s
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_source_git.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_source_git.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/source'
+require_relative "helper"
+require "rubygems/source"
 
 class TestGemSourceGit < Gem::TestCase
-
   def setup
     super
 
@@ -11,36 +10,36 @@ class TestGemSourceGit < Gem::TestCase
 
     @hash = Digest::SHA1.hexdigest @repository
 
-    @source = Gem::Source::Git.new @name, @repository, 'master', false
+    @source = Gem::Source::Git.new @name, @repository, "master", false
   end
 
   def test_base_dir
-    assert_equal File.join(Gem.dir, 'bundler'), @source.base_dir
+    assert_equal File.join(Gem.dir, "bundler"), @source.base_dir
 
     @source.root_dir = "#{@gemhome}2"
 
-    assert_equal File.join("#{@gemhome}2", 'bundler'), @source.base_dir
+    assert_equal File.join("#{@gemhome}2", "bundler"), @source.base_dir
   end
 
   def test_checkout
     @source.checkout
 
-    assert_path_exists File.join @source.install_dir, 'a.gemspec'
+    assert_path_exist File.join @source.install_dir, "a.gemspec"
   end
 
   def test_checkout_master
     Dir.chdir @repository do
-      system @git, 'checkout', '-q', '-b', 'other'
-      system @git, 'mv',             'a.gemspec', 'b.gemspec'
-      system @git, 'commit',   '-q', '-a', '-m', 'rename gemspec'
-      system @git, 'checkout', '-q', 'master'
+      system @git, "checkout", "-q", "-b", "other"
+      system @git, "mv",             "a.gemspec", "b.gemspec"
+      system @git, "commit",   "-q", "-a", "-m", "rename gemspec"
+      system @git, "checkout", "-q", "master"
     end
 
-    @source = Gem::Source::Git.new @name, @repository, 'other', false
+    @source = Gem::Source::Git.new @name, @repository, "other", false
 
     @source.checkout
 
-    assert_path_exists File.join @source.install_dir, 'b.gemspec'
+    assert_path_exist File.join @source.install_dir, "b.gemspec"
   end
 
   def test_checkout_local
@@ -48,9 +47,9 @@ class TestGemSourceGit < Gem::TestCase
 
     @source.checkout
 
-    install_dir = File.join Gem.dir, 'bundler', 'gems', "a-#{@head[0..11]}"
+    install_dir = File.join Gem.dir, "bundler", "gems", "a-#{@head[0..11]}"
 
-    refute_path_exists File.join install_dir, 'a.gemspec'
+    assert_path_not_exist File.join install_dir, "a.gemspec"
   end
 
   def test_checkout_local_cached
@@ -60,33 +59,35 @@ class TestGemSourceGit < Gem::TestCase
 
     @source.checkout
 
-    assert_path_exists File.join @source.install_dir, 'a.gemspec'
+    assert_path_exist File.join @source.install_dir, "a.gemspec"
   end
 
   def test_checkout_submodules
-    source = Gem::Source::Git.new @name, @repository, 'master', true
+    source = Gem::Source::Git.new @name, @repository, "master", true
+
+    git_gem "b"
 
-    git_gem 'b'
+    Dir.chdir "git/a" do
+      require "open3"
+      output, status = Open3.capture2e(@git, "submodule", "--quiet", "add", File.expand_path("../b"), "b")
+      assert status.success?, output
 
-    Dir.chdir 'git/a' do
-      Gem::Util.silent_system @git, 'submodule', '--quiet',
-                              'add', File.expand_path('../b'), 'b'
-      system @git, 'commit', '--quiet', '-m', 'add submodule b'
+      system @git, "commit", "--quiet", "-m", "add submodule b"
     end
 
     source.checkout
 
-    assert_path_exists File.join source.install_dir, 'a.gemspec'
-    assert_path_exists File.join source.install_dir, 'b/b.gemspec'
+    assert_path_exist File.join source.install_dir, "a.gemspec"
+    assert_path_exist File.join source.install_dir, "b/b.gemspec"
   end
 
   def test_cache
     assert @source.cache
 
-    assert_path_exists @source.repo_cache_dir
+    assert_path_exist @source.repo_cache_dir
 
     Dir.chdir @source.repo_cache_dir do
-      assert_equal @head, Gem::Util.popen(@git, 'rev-parse', 'master').strip
+      assert_equal @head, Gem::Util.popen(@git, "rev-parse", "master").strip
     end
   end
 
@@ -95,7 +96,7 @@ class TestGemSourceGit < Gem::TestCase
 
     @source.cache
 
-    refute_path_exists @source.repo_cache_dir
+    assert_path_not_exist @source.repo_cache_dir
   end
 
   def test_dir_shortref
@@ -114,17 +115,17 @@ class TestGemSourceGit < Gem::TestCase
     assert_equal @source, @source.dup
 
     source =
-      Gem::Source::Git.new @source.name, @source.repository, 'other', false
+      Gem::Source::Git.new @source.name, @source.repository, "other", false
 
     refute_equal @source, source
 
     source =
-      Gem::Source::Git.new @source.name, 'repo/other', @source.reference, false
+      Gem::Source::Git.new @source.name, "repo/other", @source.reference, false
 
     refute_equal @source, source
 
     source =
-      Gem::Source::Git.new 'b', @source.repository, @source.reference, false
+      Gem::Source::Git.new "b", @source.repository, @source.reference, false
 
     refute_equal @source, source
 
@@ -138,7 +139,7 @@ class TestGemSourceGit < Gem::TestCase
   def test_install_dir
     @source.cache
 
-    expected = File.join Gem.dir, 'bundler', 'gems', "a-#{@head[0..11]}"
+    expected = File.join Gem.dir, "bundler", "gems", "a-#{@head[0..11]}"
 
     assert_equal expected, @source.install_dir
   end
@@ -151,14 +152,14 @@ class TestGemSourceGit < Gem::TestCase
 
   def test_repo_cache_dir
     expected =
-      File.join Gem.dir, 'cache', 'bundler', 'git', "a-#{@hash}"
+      File.join Gem.dir, "cache", "bundler", "git", "a-#{@hash}"
 
     assert_equal expected, @source.repo_cache_dir
 
     @source.root_dir = "#{@gemhome}2"
 
     expected =
-      File.join "#{@gemhome}2", 'cache', 'bundler', 'git', "a-#{@hash}"
+      File.join "#{@gemhome}2", "cache", "bundler", "git", "a-#{@hash}"
 
     assert_equal expected, @source.repo_cache_dir
   end
@@ -169,25 +170,25 @@ class TestGemSourceGit < Gem::TestCase
     assert_equal @head, @source.rev_parse
 
     Dir.chdir @repository do
-      system @git, 'checkout', '--quiet', '-b', 'other'
+      system @git, "checkout", "--quiet", "-b", "other"
     end
 
     master_head = @head
 
-    git_gem 'a', 2
+    git_gem "a", 2
 
-    source = Gem::Source::Git.new @name, @repository, 'other', false
+    source = Gem::Source::Git.new @name, @repository, "other", false
 
     source.cache
 
     refute_equal master_head, source.rev_parse
 
-    source = Gem::Source::Git.new @name, @repository, 'nonexistent', false
+    source = Gem::Source::Git.new @name, @repository, "nonexistent", false
 
     source.cache
 
-    e = assert_raises Gem::Exception do
-      capture_subprocess_io {source.rev_parse}
+    e = assert_raise Gem::Exception do
+      capture_subprocess_io { source.rev_parse }
     end
 
     assert_equal "unable to find reference nonexistent in #{@repository}",
@@ -203,59 +204,59 @@ class TestGemSourceGit < Gem::TestCase
   end
 
   def test_spaceship
-    git       = Gem::Source::Git.new 'a', 'git/a', 'master', false
+    git       = Gem::Source::Git.new "a", "git/a", "master", false
     remote    = Gem::Source.new @gem_repo
     installed = Gem::Source::Installed.new
-    vendor    = Gem::Source::Vendor.new 'vendor/foo'
+    vendor    = Gem::Source::Vendor.new "vendor/foo"
 
-    assert_equal(0, git.      <=>(git),       'git    <=> git')
+    assert_equal(0, git.<=>(git),       "git <=> git")
 
-    assert_equal(1, git.      <=>(remote),    'git    <=> remote')
-    assert_equal(-1, remote.   <=>(git),       'remote <=> git')
+    assert_equal(1, git.<=>(remote),    "git <=> remote")
+    assert_equal(-1, remote.<=>(git), "remote <=> git")
 
-    assert_equal(1, git.      <=>(installed), 'git       <=> installed')
-    assert_equal(-1, installed.<=>(git),       'installed <=> git')
+    assert_equal(1, git.<=>(installed), "git <=> installed")
+    assert_equal(-1, installed.<=>(git), "installed <=> git")
 
-    assert_equal(-1, git.      <=>(vendor),    'git       <=> vendor')
-    assert_equal(1, vendor.   <=>(git),       'vendor    <=> git')
+    assert_equal(-1, git.<=>(vendor), "git <=> vendor")
+    assert_equal(1, vendor.<=>(git), "vendor <=> git")
   end
 
   def test_specs
-    source = Gem::Source::Git.new @name, @repository, 'master', true
+    source = Gem::Source::Git.new @name, @repository, "master", true
 
-    Dir.chdir 'git/a' do
-      FileUtils.mkdir 'b'
+    Dir.chdir "git/a" do
+      FileUtils.mkdir "b"
 
-      Dir.chdir 'b' do
-        b = Gem::Specification.new 'b', 1
+      Dir.chdir "b" do
+        b = Gem::Specification.new "b", 1
 
-        File.open 'b.gemspec', 'w' do |io|
+        File.open "b.gemspec", "w" do |io|
           io.write b.to_ruby
         end
 
-        system @git, 'add', 'b.gemspec'
-        system @git, 'commit', '--quiet', '-m', 'add b/b.gemspec'
+        system @git, "add", "b.gemspec"
+        system @git, "commit", "--quiet", "-m", "add b/b.gemspec"
       end
     end
 
     specs = nil
 
-    capture_io do
+    capture_output do
       specs = source.specs
     end
 
-    assert_equal %w[a-1 b-1], specs.map { |spec| spec.full_name }
+    assert_equal %w[a-1 b-1], specs.map {|spec| spec.full_name }
 
     a_spec = specs.shift
 
     base_dir = File.dirname File.dirname source.install_dir
 
     assert_equal source.install_dir, a_spec.full_gem_path
-    assert_equal File.join(source.install_dir, 'a.gemspec'), a_spec.loaded_from
+    assert_equal File.join(source.install_dir, "a.gemspec"), a_spec.loaded_from
     assert_equal base_dir, a_spec.base_dir
 
     extension_dir =
-      File.join Gem.dir, 'bundler', 'extensions',
+      File.join Gem.dir, "bundler", "extensions",
         Gem::Platform.local.to_s, Gem.extension_api_version,
         "a-#{source.dir_shortref}"
 
@@ -263,8 +264,8 @@ class TestGemSourceGit < Gem::TestCase
 
     b_spec = specs.shift
 
-    assert_equal File.join(source.install_dir, 'b'), b_spec.full_gem_path
-    assert_equal File.join(source.install_dir, 'b', 'b.gemspec'),
+    assert_equal File.join(source.install_dir, "b"), b_spec.full_gem_path
+    assert_equal File.join(source.install_dir, "b", "b.gemspec"),
                  b_spec.loaded_from
     assert_equal base_dir, b_spec.base_dir
 
@@ -272,10 +273,10 @@ class TestGemSourceGit < Gem::TestCase
   end
 
   def test_specs_local
-    source = Gem::Source::Git.new @name, @repository, 'master', true
+    source = Gem::Source::Git.new @name, @repository, "master", true
     source.remote = false
 
-    capture_io do
+    capture_output do
       assert_empty source.specs
     end
   end
@@ -288,16 +289,15 @@ class TestGemSourceGit < Gem::TestCase
     assert_equal @hash, @source.uri_hash
 
     source =
-      Gem::Source::Git.new 'a', 'http://git@example/repo.git', 'master', false
+      Gem::Source::Git.new "a", "http://git@example/repo.git", "master", false
 
-    assert_equal '291c4caac7feba8bb64c297987028acb3dde6cfe',
+    assert_equal "291c4caac7feba8bb64c297987028acb3dde6cfe",
                  source.uri_hash
 
     source =
-      Gem::Source::Git.new 'a', 'HTTP://git@EXAMPLE/repo.git', 'master', false
+      Gem::Source::Git.new "a", "HTTP://git@EXAMPLE/repo.git", "master", false
 
-    assert_equal '291c4caac7feba8bb64c297987028acb3dde6cfe',
+    assert_equal "291c4caac7feba8bb64c297987028acb3dde6cfe",
                  source.uri_hash
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_source_installed.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_source_installed.rb
@@ -1,36 +1,34 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/source'
+require_relative "helper"
+require "rubygems/source"
 
 class TestGemSourceInstalled < Gem::TestCase
-
   def test_spaceship
-    a1 = quick_gem 'a', '1'
+    a1 = quick_gem "a", "1"
     util_build_gem a1
 
     remote    = Gem::Source.new @gem_repo
     specific  = Gem::Source::SpecificFile.new a1.cache_file
     installed = Gem::Source::Installed.new
     local     = Gem::Source::Local.new
-    git       = Gem::Source::Git.new 'a', 'a', 'master'
-    vendor    = Gem::Source::Vendor.new 'a'
+    git       = Gem::Source::Git.new "a", "a", "master"
+    vendor    = Gem::Source::Vendor.new "a"
 
-    assert_equal(0, installed.<=>(installed), 'installed <=> installed')
+    assert_equal(0, installed.<=>(installed), "installed <=> installed")
 
-    assert_equal(-1, remote.   <=>(installed), 'remote    <=> installed')
-    assert_equal(1, installed.<=>(remote),    'installed <=> remote')
+    assert_equal(-1, remote.<=>(installed), "remote <=> installed")
+    assert_equal(1, installed.<=>(remote),    "installed <=> remote")
 
-    assert_equal(1, installed.<=>(local),     'installed <=> local')
-    assert_equal(-1, local.    <=>(installed), 'local     <=> installed')
+    assert_equal(1, installed.<=>(local),     "installed <=> local")
+    assert_equal(-1, local.<=>(installed), "local <=> installed")
 
-    assert_equal(-1, specific. <=>(installed), 'specific  <=> installed')
-    assert_equal(1, installed.<=>(specific),  'installed <=> specific')
+    assert_equal(-1, specific.<=>(installed), "specific <=> installed")
+    assert_equal(1, installed.<=>(specific),  "installed <=> specific")
 
-    assert_equal(1, git.      <=>(installed), 'git       <=> installed')
-    assert_equal(-1, installed.<=>(git),       'installed <=> git')
+    assert_equal(1, git. <=>(installed), "git <=> installed")
+    assert_equal(-1, installed.<=>(git), "installed <=> git")
 
-    assert_equal(1, vendor.   <=>(installed), 'vendor    <=> installed')
-    assert_equal(-1, installed.<=>(vendor),    'installed <=> vendor')
+    assert_equal(1, vendor.<=>(installed), "vendor <=> installed")
+    assert_equal(-1, installed.<=>(vendor), "installed <=> vendor")
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_source_list.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_source_list.rb
@@ -1,9 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/source_list'
-require 'rubygems/test_case'
+require "rubygems"
+require "rubygems/source_list"
+require_relative "helper"
 
 class TestGemSourceList < Gem::TestCase
-
   def setup
     super
 
@@ -45,7 +45,7 @@ class TestGemSourceList < Gem::TestCase
   def test_clear
     sl = Gem::SourceList.new
 
-    sl << 'http://source.example'
+    sl << "http://source.example"
 
     sl.clear
 
@@ -76,7 +76,7 @@ class TestGemSourceList < Gem::TestCase
 
     assert_empty sl
 
-    sl << 'http://source.example'
+    sl << "http://source.example"
 
     refute_empty sl
   end
@@ -115,5 +115,4 @@ class TestGemSourceList < Gem::TestCase
     @sl.delete Gem::Source.new(@uri)
     assert_equal @sl.sources, []
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_source_local.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_source_local.rb
@@ -1,19 +1,18 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/source'
+require_relative "helper"
+require "rubygems/source"
 
-require 'fileutils'
+require "fileutils"
 
 class TestGemSourceLocal < Gem::TestCase
-
   def setup
     super
 
     @sl = Gem::Source::Local.new
 
-    @a, @a_gem = util_gem "a", '1'
-    @ap, @ap_gem = util_gem "a", '2.a'
-    @b, @b_gem = util_gem "b", '1'
+    @a, @a_gem = util_gem "a", "1"
+    @ap, @ap_gem = util_gem "a", "2.a"
+    @b, @b_gem = util_gem "b", "1"
 
     FileUtils.mv @a_gem, @tempdir
     FileUtils.mv @ap_gem, @tempdir
@@ -73,7 +72,7 @@ class TestGemSourceLocal < Gem::TestCase
 
     @sl.load_specs :released
 
-    inner = [@a, @ap, @b].map { |t| t.name_tuple }.inspect
+    inner = [@a, @ap, @b].map {|t| t.name_tuple }.inspect
 
     assert_equal "#<Gem::Source::Local specs: #{inner}>", @sl.inspect
   end
@@ -85,7 +84,7 @@ class TestGemSourceLocal < Gem::TestCase
   end
 
   def test_spaceship
-    a1 = quick_gem 'a', '1'
+    a1 = quick_gem "a", "1"
     util_build_gem a1
 
     remote    = Gem::Source.new @gem_repo
@@ -93,16 +92,15 @@ class TestGemSourceLocal < Gem::TestCase
     installed = Gem::Source::Installed.new
     local     = Gem::Source::Local.new
 
-    assert_equal(0, local.    <=>(local),     'local     <=> local')
+    assert_equal(0, local.<=>(local), "local <=> local")
 
-    assert_equal(-1, remote.   <=>(local),     'remote    <=> local')
-    assert_equal(1, local.    <=>(remote),    'local     <=> remote')
+    assert_equal(-1, remote.<=>(local), "remote <=> local")
+    assert_equal(1, local.<=>(remote), "local <=> remote")
 
-    assert_equal(1, installed.<=>(local),     'installed <=> local')
-    assert_equal(-1, local.    <=>(installed), 'local     <=> installed')
+    assert_equal(1, installed.<=>(local), "installed <=> local")
+    assert_equal(-1, local.<=>(installed), "local <=> installed")
 
-    assert_equal(-1, specific. <=>(local),     'specific  <=> local')
-    assert_equal(1, local.    <=>(specific),  'local     <=> specific')
+    assert_equal(-1, specific.<=>(local), "specific <=> local")
+    assert_equal(1, local.<=>(specific), "local <=> specific")
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_source_lock.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_source_lock.rb
@@ -1,25 +1,24 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemSourceLock < Gem::TestCase
-
   def test_fetch_spec
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
-    name_tuple = Gem::NameTuple.new 'a', v(1), 'ruby'
+    name_tuple = Gem::NameTuple.new "a", v(1), "ruby"
 
     remote = Gem::Source.new @gem_repo
     lock   = Gem::Source::Lock.new remote
 
     spec = lock.fetch_spec name_tuple
 
-    assert_equal 'a-1', spec.full_name
+    assert_equal "a-1", spec.full_name
   end
 
   def test_equals2
-    git    = Gem::Source::Git.new 'a', 'git/a', 'master', false
+    git    = Gem::Source::Git.new "a", "git/a", "master", false
     g_lock = Gem::Source::Lock.new git
 
     installed = Gem::Source::Installed.new
@@ -31,77 +30,77 @@ class TestGemSourceLock < Gem::TestCase
   end
 
   def test_spaceship
-    git    = Gem::Source::Git.new 'a', 'git/a', 'master', false
+    git    = Gem::Source::Git.new "a", "git/a", "master", false
     g_lock = Gem::Source::Lock.new git
 
     installed = Gem::Source::Installed.new
     i_lock    = Gem::Source::Lock.new installed
 
-    vendor = Gem::Source::Vendor.new 'vendor/a'
+    vendor = Gem::Source::Vendor.new "vendor/a"
     v_lock = Gem::Source::Lock.new vendor
 
-    assert_equal(0, g_lock.<=>(g_lock), 'g_lock <=> g_lock')
-    assert_equal(0, i_lock.<=>(i_lock), 'i_lock <=> i_lock')
-    assert_equal(0, v_lock.<=>(v_lock), 'v_lock <=> v_lock')
+    assert_equal(0, g_lock.<=>(g_lock), "g_lock <=> g_lock")
+    assert_equal(0, i_lock.<=>(i_lock), "i_lock <=> i_lock")
+    assert_equal(0, v_lock.<=>(v_lock), "v_lock <=> v_lock")
 
-    assert_equal(1, g_lock.<=>(i_lock), 'g_lock <=> i_lock')
-    assert_equal(-1, i_lock.<=>(g_lock), 'i_lock <=> g_lock')
+    assert_equal(1, g_lock.<=>(i_lock), "g_lock <=> i_lock")
+    assert_equal(-1, i_lock.<=>(g_lock), "i_lock <=> g_lock")
 
-    assert_equal(-1, g_lock.<=>(v_lock), 'g_lock <=> v_lock')
-    assert_equal(1, v_lock.<=>(g_lock), 'v_lock <=> g_lock')
+    assert_equal(-1, g_lock.<=>(v_lock), "g_lock <=> v_lock")
+    assert_equal(1, v_lock.<=>(g_lock), "v_lock <=> g_lock")
 
-    assert_equal(-1, i_lock.<=>(v_lock), 'i_lock <=> v_lock')
-    assert_equal(1, v_lock.<=>(i_lock), 'i_lock <=> v_lock')
+    assert_equal(-1, i_lock.<=>(v_lock), "i_lock <=> v_lock")
+    assert_equal(1, v_lock.<=>(i_lock), "i_lock <=> v_lock")
   end
 
   def test_spaceship_git
-    git  = Gem::Source::Git.new 'a', 'git/a', 'master', false
+    git  = Gem::Source::Git.new "a", "git/a", "master", false
     lock = Gem::Source::Lock.new git
 
-    assert_equal(1, lock.<=>(git),  'lock <=> git')
-    assert_equal(-1, git .<=>(lock), 'git  <=> lock')
+    assert_equal(1, lock.<=>(git),  "lock <=> git")
+    assert_equal(-1, git.<=>(lock), "git <=> lock")
   end
 
   def test_spaceship_installed
     installed = Gem::Source::Installed.new
     lock      = Gem::Source::Lock.new installed
 
-    assert_equal(1, lock.     <=>(installed),  'lock      <=> installed')
-    assert_equal(-1, installed.<=>(lock),       'installed <=> lock')
+    assert_equal(1, lock.<=>(installed), "lock <=> installed")
+    assert_equal(-1, installed.<=>(lock), "installed <=> lock")
   end
 
   def test_spaceship_local
     local = Gem::Source::Local.new
     lock  = Gem::Source::Lock.new local # nonsense
 
-    assert_equal(1, lock. <=>(local), 'lock  <=> local')
-    assert_equal(-1, local.<=>(lock),  'local <=> lock')
+    assert_equal(1, lock.<=>(local), "lock <=> local")
+    assert_equal(-1, local.<=>(lock), "local <=> lock")
   end
 
   def test_spaceship_remote
     remote = Gem::Source.new @gem_repo
     lock   = Gem::Source::Lock.new remote
 
-    assert_equal(1, lock.  <=>(remote), 'lock   <=> remote')
-    assert_equal(-1, remote.<=>(lock),   'remote <=> lock')
+    assert_equal(1, lock.<=>(remote), "lock <=> remote")
+    assert_equal(-1, remote.<=>(lock), "remote <=> lock")
   end
 
   def test_spaceship_specific_file
-    _, gem = util_gem 'a', 1
+    _, gem = util_gem "a", 1
 
     specific = Gem::Source::SpecificFile.new gem
     lock     = Gem::Source::Lock.new specific # nonsense
 
-    assert_equal(1, lock    .<=>(specific),  'lock     <=> specific')
-    assert_equal(-1, specific.<=>(lock),      'specific <=> lock')
+    assert_equal(1, lock.<=>(specific), "lock <=> specific")
+    assert_equal(-1, specific.<=>(lock),      "specific <=> lock")
   end
 
   def test_spaceship_vendor
-    vendor = Gem::Source::Vendor.new 'vendor/a'
+    vendor = Gem::Source::Vendor.new "vendor/a"
     lock   = Gem::Source::Lock.new vendor
 
-    assert_equal(1, lock.  <=>(vendor), 'lock   <=>    vendor')
-    assert_equal(-1, vendor.<=>(lock),   'vendor <=> lock')
+    assert_equal(1, lock.<=>(vendor), "lock <=> vendor")
+    assert_equal(-1, vendor.<=>(lock), "vendor <=> lock")
   end
 
   def test_uri
@@ -110,5 +109,4 @@ class TestGemSourceLock < Gem::TestCase
 
     assert_equal URI(@gem_repo), lock.uri
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_source_specific_file.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_source_specific_file.rb
@@ -1,13 +1,12 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/source'
+require_relative "helper"
+require "rubygems/source"
 
 class TestGemSourceSpecificFile < Gem::TestCase
-
   def setup
     super
 
-    @a, @a_gem = util_gem "a", '1'
+    @a, @a_gem = util_gem "a", "1"
     @sf = Gem::Source::SpecificFile.new(@a_gem)
   end
 
@@ -28,7 +27,7 @@ class TestGemSourceSpecificFile < Gem::T
   end
 
   def test_fetch_spec_fails_on_unknown_name
-    assert_raises Gem::Exception do
+    assert_raise Gem::Exception do
       @sf.fetch_spec(nil)
     end
   end
@@ -38,7 +37,7 @@ class TestGemSourceSpecificFile < Gem::T
   end
 
   def test_spaceship
-    a1 = quick_gem 'a', '1'
+    a1 = quick_gem "a", "1"
     util_build_gem a1
 
     remote    = Gem::Source.new @gem_repo
@@ -46,32 +45,31 @@ class TestGemSourceSpecificFile < Gem::T
     installed = Gem::Source::Installed.new
     local     = Gem::Source::Local.new
 
-    assert_equal(0, specific. <=>(specific),  'specific  <=> specific')
+    assert_equal(0, specific.<=>(specific), "specific <=> specific")
 
-    assert_equal(-1, remote.   <=>(specific),  'remote    <=> specific')
-    assert_equal(1, specific. <=>(remote),    'specific  <=> remote')
+    assert_equal(-1, remote.<=>(specific), "remote <=> specific")
+    assert_equal(1, specific.<=>(remote), "specific <=> remote")
 
-    assert_equal(-1, specific. <=>(local),     'specific  <=> local')
-    assert_equal(1, local.    <=>(specific),  'local     <=> specific')
+    assert_equal(-1, specific.<=>(local),     "specific <=> local")
+    assert_equal(1, local.    <=>(specific),  "local <=> specific")
 
-    assert_equal(-1, specific. <=>(installed), 'specific  <=> installed')
-    assert_equal(1, installed.<=>(specific),  'installed <=> specific')
+    assert_equal(-1, specific. <=>(installed), "specific <=> installed")
+    assert_equal(1, installed.<=>(specific), "installed <=> specific")
 
-    a2 = quick_gem 'a', '2'
+    a2 = quick_gem "a", "2"
     util_build_gem a2
 
-    b1 = quick_gem 'b', '1'
+    b1 = quick_gem "b", "1"
     util_build_gem b1
 
     a1_source = specific
     a2_source = Gem::Source::SpecificFile.new a2.cache_file
     b1_source = Gem::Source::SpecificFile.new b1.cache_file
 
-    assert_nil       a1_source.<=>(b1_source), 'a1_source <=> b1_source'
+    assert_nil       a1_source.<=>(b1_source), "a1_source <=> b1_source"
 
-    assert_equal(-1, a1_source.<=>(a2_source), 'a1_source <=> a2_source')
-    assert_equal(0, a1_source.<=>(a1_source), 'a1_source <=> a1_source')
-    assert_equal(1, a2_source.<=>(a1_source), 'a2_source <=> a1_source')
+    assert_equal(-1, a1_source.<=>(a2_source), "a1_source <=> a2_source")
+    assert_equal(0, a1_source.<=>(a1_source), "a1_source <=> a1_source")
+    assert_equal(1, a2_source.<=>(a1_source), "a2_source <=> a1_source")
   end
-
 end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_source_subpath_problem.rb
@@ -0,0 +1,49 @@
+# frozen_string_literal: true
+require_relative "helper"
+require "rubygems/source"
+
+class TestGemSourceSubpathProblem < Gem::TestCase
+  def tuple(*args)
+    Gem::NameTuple.new(*args)
+  end
+
+  def setup
+    super
+
+    @gem_repo = "http://gems.example.com/private"
+
+    spec_fetcher
+
+    @source = Gem::Source.new(@gem_repo)
+
+    util_make_gems
+  end
+
+  def test_dependency_resolver_set
+    response = Net::HTTPResponse.new "1.1", 200, "OK"
+    response.uri = URI("http://example")
+
+    @fetcher.data["#{@gem_repo}/"] = response
+
+    set = @source.dependency_resolver_set
+
+    assert_kind_of Gem::Resolver::APISet, set
+  end
+
+  def test_fetch_spec
+    @fetcher.data["#{@gem_repo}/#{Gem::MARSHAL_SPEC_DIR}#{@a1.spec_name}.rz"] = Zlib::Deflate.deflate(Marshal.dump(@a1))
+
+    spec = @source.fetch_spec tuple("a", Gem::Version.new(1), "ruby")
+    assert_equal @a1.full_name, spec.full_name
+  end
+
+  def test_load_specs
+    @fetcher.data["#{@gem_repo}/latest_specs.#{Gem.marshal_version}.gz"] = util_gzip(Marshal.dump([
+      Gem::NameTuple.new(@a1.name, @a1.version, "ruby"),
+      Gem::NameTuple.new(@b2.name, @b2.version, "ruby"),
+    ]))
+
+    released = @source.load_specs(:latest).map {|spec| spec.full_name }
+    assert_equal %W[a-1 b-2], released
+  end
+end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_source_vendor.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_source_vendor.rb
@@ -1,31 +1,29 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/source'
+require_relative "helper"
+require "rubygems/source"
 
 class TestGemSourceVendor < Gem::TestCase
-
   def test_initialize
-    source = Gem::Source::Vendor.new 'vendor/foo'
+    source = Gem::Source::Vendor.new "vendor/foo"
 
-    assert_equal 'vendor/foo', source.uri
+    assert_equal "vendor/foo", source.uri
   end
 
   def test_spaceship
-    vendor    = Gem::Source::Vendor.new 'vendor/foo'
+    vendor    = Gem::Source::Vendor.new "vendor/foo"
     remote    = Gem::Source.new @gem_repo
-    git       = Gem::Source::Git.new 'a', 'a', 'master'
+    git       = Gem::Source::Git.new "a", "a", "master"
     installed = Gem::Source::Installed.new
 
-    assert_equal(0, vendor.   <=>(vendor),    'vendor    <=> vendor')
+    assert_equal(0, vendor.<=>(vendor),    "vendor <=> vendor")
 
-    assert_equal(1, vendor.   <=>(remote),    'vendor    <=> remote')
-    assert_equal(-1, remote.   <=>(vendor),    'remote    <=> vendor')
+    assert_equal(1, vendor.<=>(remote),    "vendor <=> remote")
+    assert_equal(-1, remote.<=>(vendor), "remote <=> vendor")
 
-    assert_equal(1, vendor.   <=>(git),       'vendor    <=> git')
-    assert_equal(-1, git.      <=>(vendor),    'git       <=> vendor')
+    assert_equal(1, vendor.<=>(git), "vendor <=> git")
+    assert_equal(-1, git.<=>(vendor), "git <=> vendor")
 
-    assert_equal(1, vendor.   <=>(installed), 'vendor    <=> installed')
-    assert_equal(-1, installed.<=>(vendor),    'installed <=> vendor')
+    assert_equal(1, vendor.<=>(installed), "vendor <=> installed")
+    assert_equal(-1, installed.<=>(vendor), "installed <=> vendor")
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_spec_fetcher.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_spec_fetcher.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/spec_fetcher'
+require_relative "helper"
+require "rubygems/spec_fetcher"
 
 class TestGemSpecFetcher < Gem::TestCase
-
   def tuple(*args)
     Gem::NameTuple.new(*args)
   end
@@ -24,7 +23,7 @@ class TestGemSpecFetcher < Gem::TestCase
   end
 
   def test_initialize_source
-    alternate = 'http://alternate.example'
+    alternate = "http://alternate.example"
     fetcher = Gem::SpecFetcher.new alternate
 
     refute_same Gem.sources, fetcher.sources
@@ -39,7 +38,7 @@ class TestGemSpecFetcher < Gem::TestCase
   end
 
   def test_initialize_unwritable_home_dir
-    skip 'chmod not supported' if Gem.win_platform?
+    pend "chmod not supported" if Gem.win_platform?
 
     FileUtils.chmod 0000, Gem.user_home
 
@@ -52,13 +51,13 @@ class TestGemSpecFetcher < Gem::TestCase
 
   def test_spec_for_dependency_all
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', '2.a'
-      fetcher.spec 'a', 2
-      fetcher.spec 'a', '3.a'
+      fetcher.spec "a", 1
+      fetcher.spec "a", "2.a"
+      fetcher.spec "a", 2
+      fetcher.spec "a", "3.a"
     end
 
-    dep = Gem::Dependency.new 'a', ">= 1"
+    dep = Gem::Dependency.new "a", ">= 1"
 
     specs_and_sources, _ = @sf.spec_for_dependency dep
 
@@ -66,7 +65,7 @@ class TestGemSpecFetcher < Gem::TestCase
       [spec.full_name, source_uri]
     end
 
-    expected = [['a-1', @source], ['a-2', @source]]
+    expected = [["a-1", @source], ["a-2", @source]]
 
     assert_equal expected, spec_names
 
@@ -75,63 +74,63 @@ class TestGemSpecFetcher < Gem::TestCase
 
   def test_spec_for_dependency_latest
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', 2
-      fetcher.spec 'a', '3.a'
+      fetcher.spec "a", 1
+      fetcher.spec "a", 2
+      fetcher.spec "a", "3.a"
     end
 
-    dep = Gem::Dependency.new 'a'
+    dep = Gem::Dependency.new "a"
     specs_and_sources, _ = @sf.spec_for_dependency dep
 
     spec_names = specs_and_sources.map do |spec, source_uri|
       [spec.full_name, source_uri]
     end
 
-    assert_equal [['a-2', Gem::Source.new(@gem_repo)]],
+    assert_equal [["a-2", Gem::Source.new(@gem_repo)]],
                  spec_names
   end
 
   def test_spec_for_dependency_prerelease
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', '1.a'
-      fetcher.spec 'a', 1
+      fetcher.spec "a", "1.a"
+      fetcher.spec "a", 1
     end
 
-    specs_and_sources, _ = @sf.spec_for_dependency dep('a', '1.a')
+    specs_and_sources, _ = @sf.spec_for_dependency dep("a", "1.a")
 
     spec_names = specs_and_sources.map do |spec, source_uri|
       [spec.full_name, source_uri]
     end
 
-    assert_equal [['a-1.a', Gem::Source.new(@gem_repo)]], spec_names
+    assert_equal [["a-1.a", Gem::Source.new(@gem_repo)]], spec_names
   end
 
   def test_spec_for_dependency_platform
-    util_set_arch 'i386-linux'
+    util_set_arch "i386-linux"
 
     spec_fetcher do |fetcher|
       fetcher.legacy_platform
     end
 
-    dep = Gem::Dependency.new 'pl', 1
+    dep = Gem::Dependency.new "pl", 1
     specs_and_sources, _ = @sf.spec_for_dependency dep
 
     spec_names = specs_and_sources.map do |spec, source_uri|
       [spec.full_name, source_uri]
     end
 
-    assert_equal [['pl-1-x86-linux', Gem::Source.new(@gem_repo)]],
+    assert_equal [["pl-1-x86-linux", Gem::Source.new(@gem_repo)]],
                  spec_names
   end
 
   def test_spec_for_dependency_mismatched_platform
-    util_set_arch 'hrpa-989'
+    util_set_arch "hrpa-989"
 
     spec_fetcher do |fetcher|
       fetcher.legacy_platform
     end
 
-    dep = Gem::Dependency.new 'pl', 1
+    dep = Gem::Dependency.new "pl", 1
     specs_and_sources, errors = @sf.spec_for_dependency dep
 
     assert_equal 0, specs_and_sources.size
@@ -151,13 +150,13 @@ class TestGemSpecFetcher < Gem::TestCase
     Gem.sources.replace [src]
 
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', '2.a'
-      fetcher.spec 'a', 2
-      fetcher.spec 'a', '3.a'
+      fetcher.spec "a", 1
+      fetcher.spec "a", "2.a"
+      fetcher.spec "a", 2
+      fetcher.spec "a", "3.a"
     end
 
-    dep = Gem::Dependency.new 'a', ">= 1"
+    dep = Gem::Dependency.new "a", ">= 1"
 
     specs_and_sources, errors = @sf.spec_for_dependency dep
 
@@ -171,29 +170,38 @@ class TestGemSpecFetcher < Gem::TestCase
 
   def test_suggest_gems_from_name_latest
     spec_fetcher do|fetcher|
-      fetcher.spec 'example', 1
-      fetcher.spec 'other-example', 1
+      fetcher.spec "example", 1
+      fetcher.spec "other-example", 1
+      fetcher.spec "examp", 1
     end
 
-    suggestions = @sf.suggest_gems_from_name('examplw')
-    assert_equal ['example'], suggestions
+    suggestions = @sf.suggest_gems_from_name("examplw", :latest, 1)
+    assert_equal ["example"], suggestions
+
+    suggestions = @sf.suggest_gems_from_name("other")
+    assert_equal ["other-example"], suggestions
+
+    suggestions = @sf.suggest_gems_from_name("exam")
+    assert suggestions.any? { ["examp"] }
+    assert suggestions.any? { ["example"] }
+    assert suggestions.any? { ["other-example"] }
   end
 
   def test_suggest_gems_from_name_prerelease
     spec_fetcher do|fetcher|
-      fetcher.spec 'example', '1.a'
-      fetcher.spec 'other-example', 1
+      fetcher.spec "example", "1.a"
+      fetcher.spec "other-example", 1
     end
 
-    suggestions = @sf.suggest_gems_from_name('examplw')
-    assert_equal ['example'], suggestions
+    suggestions = @sf.suggest_gems_from_name("examplw")
+    assert_equal ["example"], suggestions
   end
 
   def test_available_specs_latest
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', 2
-      fetcher.spec 'a', '3.a'
+      fetcher.spec "a", 1
+      fetcher.spec "a", 2
+      fetcher.spec "a", "3.a"
       fetcher.legacy_platform
     end
 
@@ -202,15 +210,15 @@ class TestGemSpecFetcher < Gem::TestCase
     assert_equal [@source], specs.keys
 
     expected = Gem::NameTuple.from_list \
-      [['a',      v(2),     Gem::Platform::RUBY],
-       ['pl',     v(1),     'i386-linux']]
+      [["a",      v(2),     Gem::Platform::RUBY],
+       ["pl",     v(1),     "i386-linux"]]
 
     assert_equal expected, specs[@source]
   end
 
   def test_available_specs_released
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
       fetcher.legacy_platform
     end
 
@@ -219,17 +227,17 @@ class TestGemSpecFetcher < Gem::TestCase
     assert_equal [@source], specs.keys
 
     expected = Gem::NameTuple.from_list \
-      [['a',      v(1),     Gem::Platform::RUBY],
-       ['pl',     v(1),     'i386-linux']]
+      [["a",      v(1),     Gem::Platform::RUBY],
+       ["pl",     v(1),     "i386-linux"]]
 
     assert_equal expected, specs[@source]
   end
 
   def test_available_specs_complete
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', '2.a'
-      fetcher.spec 'b', 2
+      fetcher.spec "a", 1
+      fetcher.spec "a", "2.a"
+      fetcher.spec "b", 2
       fetcher.legacy_platform
     end
 
@@ -238,19 +246,19 @@ class TestGemSpecFetcher < Gem::TestCase
     assert_equal [@source], specs.keys
 
     expected = Gem::NameTuple.from_list \
-      [['a',      v(1),     Gem::Platform::RUBY],
-       ['a',      v('2.a'), Gem::Platform::RUBY],
-       ['b',      v(2),     Gem::Platform::RUBY],
-       ['pl',     v(1),     'i386-linux']]
+      [["a",      v(1),     Gem::Platform::RUBY],
+       ["a",      v("2.a"), Gem::Platform::RUBY],
+       ["b",      v(2),     Gem::Platform::RUBY],
+       ["pl",     v(1),     "i386-linux"]]
 
     assert_equal expected, specs[@source]
   end
 
   def test_available_specs_complete_handles_no_prerelease
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', '2.a'
-      fetcher.spec 'b', 2
+      fetcher.spec "a", 1
+      fetcher.spec "a", "2.a"
+      fetcher.spec "b", 2
       fetcher.legacy_platform
     end
 
@@ -262,16 +270,16 @@ class TestGemSpecFetcher < Gem::TestCase
     assert_equal [@source], specs.keys
 
     expected = Gem::NameTuple.from_list \
-      [['a',      v(1), Gem::Platform::RUBY],
-       ['b',      v(2), Gem::Platform::RUBY],
-       ['pl',     v(1), 'i386-linux']]
+      [["a",      v(1), Gem::Platform::RUBY],
+       ["b",      v(2), Gem::Platform::RUBY],
+       ["pl",     v(1), "i386-linux"]]
 
     assert_equal expected, specs[@source]
   end
 
   def test_available_specs_cache
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
+      fetcher.spec "a", 1
     end
 
     specs, _ = @sf.available_specs(:latest)
@@ -287,9 +295,9 @@ class TestGemSpecFetcher < Gem::TestCase
 
   def test_available_specs_cache_released
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', '2.a'
-      fetcher.spec 'b', 2
+      fetcher.spec "a", 1
+      fetcher.spec "a", "2.a"
+      fetcher.spec "b", 2
       fetcher.legacy_platform
     end
 
@@ -306,14 +314,14 @@ class TestGemSpecFetcher < Gem::TestCase
 
   def test_available_specs_prerelease
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1
-      fetcher.spec 'a', '2.a'
+      fetcher.spec "a", 1
+      fetcher.spec "a", "2.a"
     end
 
     specs, _ = @sf.available_specs(:prerelease)
 
     expected = Gem::NameTuple.from_list \
-      [['a',  v('2.a'), Gem::Platform::RUBY]]
+      [["a", v("2.a"), Gem::Platform::RUBY]]
 
     assert_equal expected, specs[@source]
   end
@@ -326,5 +334,4 @@ class TestGemSpecFetcher < Gem::TestCase
     assert_equal({}, specs)
     assert_kind_of Gem::SourceFetchProblem, errors.first
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_specification.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_specification.rb
@@ -1,15 +1,15 @@
 # frozen_string_literal: true
-require 'benchmark'
-require 'rubygems/test_case'
-require 'pathname'
-require 'stringio'
-require 'rubygems/ext'
-require 'rubygems/specification'
-require 'rubygems/installer'
-require 'rubygems/platform'
+require "benchmark"
+require_relative "helper"
+require "date"
+require "pathname"
+require "stringio"
+require "rubygems/ext"
+require "rubygems/specification"
+require "rubygems/installer"
+require "rubygems/platform"
 
 class TestGemSpecification < Gem::TestCase
-
   LEGACY_YAML_SPEC = <<-EOF.freeze
 --- !ruby/object:Gem::Specification
 rubygems_version: "1.0"
@@ -44,16 +44,16 @@ end
   EOF
 
   def make_spec_c1
-    @c1 = util_spec 'a', '1' do |s|
-      s.executable = 'exec'
-      s.extensions << 'ext/a/extconf.rb'
-      s.test_file = 'test/suite.rb'
-      s.requirements << 'A working computer'
-      s.license = 'MIT'
-
-      s.add_dependency 'rake', '> 0.4'
-      s.add_dependency 'jabber4r', '> 0.0.0'
-      s.add_dependency 'pqa', ['> 0.4', '<= 0.6']
+    @c1 = util_spec "a", "1" do |s|
+      s.executable = "exec"
+      s.extensions << "ext/a/extconf.rb"
+      s.test_file = "test/suite.rb"
+      s.requirements << "A working computer"
+      s.license = "MIT"
+
+      s.add_dependency "rake", "> 0.4"
+      s.add_dependency "jabber4r", "> 0.0.0"
+      s.add_dependency "pqa", ["> 0.4", "<= 0.6"]
 
       s.mark_version
       s.files = %w[lib/code.rb]
@@ -61,16 +61,16 @@ end
   end
 
   def ext_spec(platform: Gem::Platform::RUBY)
-    @ext = util_spec 'ext', '1' do |s|
-      s.executable = 'exec'
-      s.test_file = 'test/suite.rb'
+    @ext = util_spec "ext", "1" do |s|
+      s.executable = "exec"
+      s.test_file = "test/suite.rb"
       s.extensions = %w[ext/extconf.rb]
-      s.license = 'MIT'
+      s.license = "MIT"
       s.platform = platform
 
       s.mark_version
       s.files = %w[lib/code.rb]
-      s.installed_by_version = v('2.2')
+      s.installed_by_version = v("2.2")
     end
   end
 
@@ -88,306 +88,281 @@ end
     # is not set.
     Gem.instance_variable_set(:'@default_source_date_epoch', nil)
 
-    @a1 = util_spec 'a', '1' do |s|
-      s.executable = 'exec'
-      s.test_file = 'test/suite.rb'
-      s.requirements << 'A working computer'
-      s.license = 'MIT'
+    @a1 = util_spec "a", "1" do |s|
+      s.executable = "exec"
+      s.test_file = "test/suite.rb"
+      s.requirements << "A working computer"
+      s.license = "MIT"
 
       s.mark_version
       s.files = %w[lib/code.rb]
     end
 
-    @a2 = util_spec 'a', '2' do |s|
+    @a2 = util_spec "a", "2" do |s|
       s.files = %w[lib/code.rb]
     end
 
-    @a3 = util_spec 'a', '3' do |s|
-      s.metadata['allowed_push_host'] = "https://privategemserver.com"
+    @a3 = util_spec "a", "3" do |s|
+      s.metadata["allowed_push_host"] = "https://privategemserver.com"
     end
 
     @current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION
-
-    load 'rubygems/syck_hack.rb'
   end
 
   def test_self_find_active_stub_by_path
-    spec = util_spec('a', '1', nil, 'lib/foo.rb')
+    spec = util_spec("a", "1", nil, "lib/foo.rb")
     spec.activated = true
 
     # There used to be a bug (introduced in a9c1aaf) when Gem::Specification
     # objects are present in the @stubs collection. This test verifies that
     # this scenario works correctly.
     Gem::Specification.all = [spec]
-    assert_equal spec, Gem::Specification.find_active_stub_by_path('foo')
+    assert_equal spec, Gem::Specification.find_active_stub_by_path("foo")
   end
 
   def test_self_activate
-    foo = util_spec 'foo', '1'
+    foo = util_spec "foo", "1"
 
     assert_activate %w[foo-1], foo
   end
 
   def test_self_activate_ambiguous_direct
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      b1 = util_spec("b", "1", { "c" => ">= 1" }, "lib/d#{$$}.rb")
-      b2 = util_spec("b", "2", { "c" => ">= 2" }, "lib/d#{$$}.rb")
-      c1 = util_spec "c", "1"
-      c2 = util_spec "c", "2"
-
-      Gem::Specification.reset
-      install_specs c1, c2, b1, b2, a1
-
-      a1.activate
-      assert_equal %w(a-1), loaded_spec_names
-      assert_equal ["b (> 0)"], unresolved_names
+    a1 = util_spec "a", "1", "b" => "> 0"
+    b1 = util_spec("b", "1", { "c" => ">= 1" }, "lib/d#{$$}.rb")
+    b2 = util_spec("b", "2", { "c" => ">= 2" }, "lib/d#{$$}.rb")
+    c1 = util_spec "c", "1"
+    c2 = util_spec "c", "2"
 
-      require "d#{$$}"
+    Gem::Specification.reset
+    install_specs c1, c2, b1, b2, a1
 
-      assert_equal %w(a-1 b-2 c-2), loaded_spec_names
-      assert_equal [], unresolved_names
-    end
+    a1.activate
+    assert_equal %w[a-1], loaded_spec_names
+    assert_equal ["b (> 0)"], unresolved_names
+
+    require "d#{$$}"
+
+    assert_equal %w[a-1 b-2 c-2], loaded_spec_names
+    assert_equal [], unresolved_names
   end
 
   def test_find_in_unresolved_tree_is_not_exponentiental
-    save_loaded_features do
-      num_of_pkg = 7
-      num_of_version_per_pkg = 3
-      packages = (0..num_of_pkg).map do |pkgi|
-        (0..num_of_version_per_pkg).map do |pkg_version|
-          deps = Hash[((pkgi + 1)..num_of_pkg).map do |deppkgi|
-            ["pkg#{deppkgi}", ">= 0"]
-          end]
-          util_spec "pkg#{pkgi}", pkg_version.to_s, deps
-        end
+    pend "currently slower in CI on TruffleRuby" if RUBY_ENGINE == "truffleruby"
+    num_of_pkg = 7
+    num_of_version_per_pkg = 3
+    packages = (0..num_of_pkg).map do |pkgi|
+      (0..num_of_version_per_pkg).map do |pkg_version|
+        deps = Hash[((pkgi + 1)..num_of_pkg).map do |deppkgi|
+                      ["pkg#{deppkgi}", ">= 0"]
+                    end]
+        util_spec "pkg#{pkgi}", pkg_version.to_s, deps
       end
-      base = util_spec "pkg_base", "1", {"pkg0" => ">= 0"}
+    end
+    base = util_spec "pkg_base", "1", { "pkg0" => ">= 0" }
 
-      Gem::Specification.reset
-      install_specs(*packages.flatten.reverse)
-      install_specs base
-      base.activate
+    Gem::Specification.reset
+    install_specs(*packages.flatten.reverse)
+    install_specs base
+    base.activate
 
-      tms = Benchmark.measure do
-        assert_raises(LoadError) { require 'no_such_file_foo' }
-      end
-      assert_operator tms.total, :<=, 10
+    tms = Benchmark.measure do
+      assert_raise(LoadError) { require "no_such_file_foo" }
     end
+    assert_operator tms.total, :<=, 10
   end
 
   def test_self_activate_ambiguous_indirect
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      b1 = util_spec "b", "1", "c" => ">= 1"
-      b2 = util_spec "b", "2", "c" => ">= 2"
-      c1 = util_spec "c", "1", nil, "lib/d#{$$}.rb"
-      c2 = util_spec "c", "2", nil, "lib/d#{$$}.rb"
-
-      install_specs c1, c2, b1, b2, a1
-
-      a1.activate
-      assert_equal %w(a-1), loaded_spec_names
-      assert_equal ["b (> 0)"], unresolved_names
+    a1 = util_spec "a", "1", "b" => "> 0"
+    b1 = util_spec "b", "1", "c" => ">= 1"
+    b2 = util_spec "b", "2", "c" => ">= 2"
+    c1 = util_spec "c", "1", nil, "lib/d#{$$}.rb"
+    c2 = util_spec "c", "2", nil, "lib/d#{$$}.rb"
 
-      require "d#{$$}"
+    install_specs c1, c2, b1, b2, a1
 
-      assert_equal %w(a-1 b-2 c-2), loaded_spec_names
-      assert_equal [], unresolved_names
-    end
+    a1.activate
+    assert_equal %w[a-1], loaded_spec_names
+    assert_equal ["b (> 0)"], unresolved_names
+
+    require "d#{$$}"
+
+    assert_equal %w[a-1 b-2 c-2], loaded_spec_names
+    assert_equal [], unresolved_names
   end
 
   def test_self_activate_ambiguous_indirect_conflict
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      a2 = util_spec "a", "2", "b" => "> 0"
-      b1 = util_spec "b", "1", "c" => ">= 1"
-      b2 = util_spec "b", "2", "c" => ">= 2"
-      c1 = util_spec "c", "1", nil, "lib/d#{$$}.rb"
-      c2 = util_spec("c", "2", { "a" => "1" }, "lib/d#{$$}.rb") # conflicts with a-2
-
-      install_specs c1, b1, a1, a2, c2, b2
-
-      a2.activate
-      assert_equal %w(a-2), loaded_spec_names
-      assert_equal ["b (> 0)"], unresolved_names
+    a1 = util_spec "a", "1", "b" => "> 0"
+    a2 = util_spec "a", "2", "b" => "> 0"
+    b1 = util_spec "b", "1", "c" => ">= 1"
+    b2 = util_spec "b", "2", "c" => ">= 2"
+    c1 = util_spec "c", "1", nil, "lib/d#{$$}.rb"
+    c2 = util_spec("c", "2", { "a" => "1" }, "lib/d#{$$}.rb") # conflicts with a-2
+
+    install_specs c1, b1, a1, a2, c2, b2
+
+    a2.activate
+    assert_equal %w[a-2], loaded_spec_names
+    assert_equal ["b (> 0)"], unresolved_names
 
-      require "d#{$$}"
+    require "d#{$$}"
 
-      assert_equal %w(a-2 b-1 c-1), loaded_spec_names
-      assert_equal [], unresolved_names
-    end
+    assert_equal %w[a-2 b-1 c-1], loaded_spec_names
+    assert_equal [], unresolved_names
   end
 
   def test_self_activate_ambiguous_unrelated
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      b1 = util_spec "b", "1", "c" => ">= 1"
-      b2 = util_spec "b", "2", "c" => ">= 2"
-      c1 = util_spec "c", "1"
-      c2 = util_spec "c", "2"
-      d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb"
-
-      install_specs d1, c1, c2, b1, b2, a1
-
-      a1.activate
-      assert_equal %w(a-1), loaded_spec_names
-      assert_equal ["b (> 0)"], unresolved_names
+    a1 = util_spec "a", "1", "b" => "> 0"
+    b1 = util_spec "b", "1", "c" => ">= 1"
+    b2 = util_spec "b", "2", "c" => ">= 2"
+    c1 = util_spec "c", "1"
+    c2 = util_spec "c", "2"
+    d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb"
 
-      require "d#{$$}"
+    install_specs d1, c1, c2, b1, b2, a1
 
-      assert_equal %w(a-1 d-1), loaded_spec_names
-      assert_equal ["b (> 0)"], unresolved_names
-    end
+    a1.activate
+    assert_equal %w[a-1], loaded_spec_names
+    assert_equal ["b (> 0)"], unresolved_names
+
+    require "d#{$$}"
+
+    assert_equal %w[a-1 d-1], loaded_spec_names
+    assert_equal ["b (> 0)"], unresolved_names
   end
 
   def test_require_should_prefer_latest_gem_level1
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      b1 = util_spec "b", "1", "c" => ">= 0" # unresolved
-      b2 = util_spec "b", "2", "c" => ">= 0"
-      c1 = util_spec "c", "1", nil, "lib/c#{$$}.rb"  # 1st level
-      c2 = util_spec "c", "2", nil, "lib/c#{$$}.rb"
+    a1 = util_spec "a", "1", "b" => "> 0"
+    b1 = util_spec "b", "1", "c" => ">= 0" # unresolved
+    b2 = util_spec "b", "2", "c" => ">= 0"
+    c1 = util_spec "c", "1", nil, "lib/c#{$$}.rb" # 1st level
+    c2 = util_spec "c", "2", nil, "lib/c#{$$}.rb"
 
-      install_specs c1, c2, b1, b2, a1
+    install_specs c1, c2, b1, b2, a1
 
-      a1.activate
+    a1.activate
 
-      require "c#{$$}"
+    require "c#{$$}"
 
-      assert_equal %w(a-1 b-2 c-2), loaded_spec_names
-    end
+    assert_equal %w[a-1 b-2 c-2], loaded_spec_names
   end
 
   def test_require_should_prefer_latest_gem_level2
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      b1 = util_spec "b", "1", "c" => ">= 0" # unresolved
-      b2 = util_spec "b", "2", "c" => ">= 0"
-      c1 = util_spec "c", "1", "d" => ">= 0"  # 1st level
-      c2 = util_spec "c", "2", "d" => ">= 0"
-      d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb" # 2nd level
-      d2 = util_spec "d", "2", nil, "lib/d#{$$}.rb"
+    a1 = util_spec "a", "1", "b" => "> 0"
+    b1 = util_spec "b", "1", "c" => ">= 0" # unresolved
+    b2 = util_spec "b", "2", "c" => ">= 0"
+    c1 = util_spec "c", "1", "d" => ">= 0" # 1st level
+    c2 = util_spec "c", "2", "d" => ">= 0"
+    d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb" # 2nd level
+    d2 = util_spec "d", "2", nil, "lib/d#{$$}.rb"
 
-      install_specs d1, d2, c1, c2, b1, b2, a1
+    install_specs d1, d2, c1, c2, b1, b2, a1
 
-      a1.activate
+    a1.activate
 
-      require "d#{$$}"
+    require "d#{$$}"
 
-      assert_equal %w(a-1 b-2 c-2 d-2), loaded_spec_names
-    end
+    assert_equal %w[a-1 b-2 c-2 d-2], loaded_spec_names
   end
 
   def test_require_finds_in_2nd_level_indirect
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      b1 = util_spec "b", "1", "c" => ">= 0" # unresolved
-      b2 = util_spec "b", "2", "c" => ">= 0"
-      c1 = util_spec "c", "1", "d" => "<= 2" # 1st level
-      c2 = util_spec "c", "2", "d" => "<= 2"
-      d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb" # 2nd level
-      d2 = util_spec "d", "2", nil, "lib/d#{$$}.rb"
-      d3 = util_spec "d", "3", nil, "lib/d#{$$}.rb"
+    a1 = util_spec "a", "1", "b" => "> 0"
+    b1 = util_spec "b", "1", "c" => ">= 0" # unresolved
+    b2 = util_spec "b", "2", "c" => ">= 0"
+    c1 = util_spec "c", "1", "d" => "<= 2" # 1st level
+    c2 = util_spec "c", "2", "d" => "<= 2"
+    d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb" # 2nd level
+    d2 = util_spec "d", "2", nil, "lib/d#{$$}.rb"
+    d3 = util_spec "d", "3", nil, "lib/d#{$$}.rb"
 
-      install_specs d1, d2, d3, c1, c2, b1, b2, a1
+    install_specs d1, d2, d3, c1, c2, b1, b2, a1
 
-      a1.activate
+    a1.activate
 
-      require "d#{$$}"
+    require "d#{$$}"
 
-      assert_equal %w(a-1 b-2 c-2 d-2), loaded_spec_names
-    end
+    assert_equal %w[a-1 b-2 c-2 d-2], loaded_spec_names
   end
 
   def test_require_should_prefer_reachable_gems
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      b1 = util_spec "b", "1", "c" => ">= 0" # unresolved
-      b2 = util_spec "b", "2", "c" => ">= 0"
-      c1 = util_spec "c", "1", "d" => "<= 2" # 1st level
-      c2 = util_spec "c", "2", "d" => "<= 2"
-      d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb" # 2nd level
-      d2 = util_spec "d", "2", nil, "lib/d#{$$}.rb"
-      d3 = util_spec "d", "3", nil, "lib/d#{$$}.rb"
-      e  = util_spec "anti_d", "1", nil, "lib/d#{$$}.rb"
+    a1 = util_spec "a", "1", "b" => "> 0"
+    b1 = util_spec "b", "1", "c" => ">= 0" # unresolved
+    b2 = util_spec "b", "2", "c" => ">= 0"
+    c1 = util_spec "c", "1", "d" => "<= 2" # 1st level
+    c2 = util_spec "c", "2", "d" => "<= 2"
+    d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb" # 2nd level
+    d2 = util_spec "d", "2", nil, "lib/d#{$$}.rb"
+    d3 = util_spec "d", "3", nil, "lib/d#{$$}.rb"
+    e  = util_spec "anti_d", "1", nil, "lib/d#{$$}.rb"
 
-      install_specs d1, d2, d3, e, c1, c2, b1, b2, a1
+    install_specs d1, d2, d3, e, c1, c2, b1, b2, a1
 
-      a1.activate
+    a1.activate
 
-      require "d#{$$}"
+    require "d#{$$}"
 
-      assert_equal %w(a-1 b-2 c-2 d-2), loaded_spec_names
-    end
+    assert_equal %w[a-1 b-2 c-2 d-2], loaded_spec_names
   end
 
   def test_require_should_not_conflict
-    save_loaded_features do
-      base = util_spec "0", "1", "A" => ">= 1"
-      a1 = util_spec "A", "1", {"c" => ">= 2", "b" => "> 0"}, "lib/a.rb"
-      a2 = util_spec "A", "2", {"c" => ">= 2", "b" => "> 0"}, "lib/a.rb"
-      b1 = util_spec "b", "1", {"c" => "= 1"}, "lib/d#{$$}.rb"
-      b2 = util_spec "b", "2", {"c" => "= 2"}, "lib/d#{$$}.rb"
-      c1 = util_spec "c", "1", {}, "lib/c.rb"
-      c2 = util_spec "c", "2", {}, "lib/c.rb"
-      c3 = util_spec "c", "3", {}, "lib/c.rb"
-
-      install_specs c1, c2, c3, b1, b2, a1, a2, base
-
-      base.activate
-      assert_equal %w(0-1), loaded_spec_names
-      assert_equal ["A (>= 1)"], unresolved_names
+    base = util_spec "0", "1", "A" => ">= 1"
+    a1 = util_spec "A", "1", { "c" => ">= 2", "b" => "> 0" }, "lib/a.rb"
+    a2 = util_spec "A", "2", { "c" => ">= 2", "b" => "> 0" }, "lib/a.rb"
+    b1 = util_spec "b", "1", { "c" => "= 1" }, "lib/d#{$$}.rb"
+    b2 = util_spec "b", "2", { "c" => "= 2" }, "lib/d#{$$}.rb"
+    c1 = util_spec "c", "1", {}, "lib/c.rb"
+    c2 = util_spec "c", "2", {}, "lib/c.rb"
+    c3 = util_spec "c", "3", {}, "lib/c.rb"
+
+    install_specs c1, c2, c3, b1, b2, a1, a2, base
+
+    base.activate
+    assert_equal %w[0-1], loaded_spec_names
+    assert_equal ["A (>= 1)"], unresolved_names
 
-      require "d#{$$}"
+    require "d#{$$}"
 
-      assert_equal %w(0-1 A-2 b-2 c-2), loaded_spec_names
-      assert_equal [], unresolved_names
-    end
+    assert_equal %w[0-1 A-2 b-2 c-2], loaded_spec_names
+    assert_equal [], unresolved_names
   end
 
   def test_inner_clonflict_in_indirect_gems
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      b1 = util_spec "b", "1", "c" => ">= 1" # unresolved
-      b2 = util_spec "b", "2", "c" => ">= 1", "d" => "< 3"
-      c1 = util_spec "c", "1", "d" => "<= 2" # 1st level
-      c2 = util_spec "c", "2", "d" => "<= 2"
-      c3 = util_spec "c", "3", "d" => "<= 3"
-      d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb" # 2nd level
-      d2 = util_spec "d", "2", nil, "lib/d#{$$}.rb"
-      d3 = util_spec "d", "3", nil, "lib/d#{$$}.rb"
+    a1 = util_spec "a", "1", "b" => "> 0"
+    b1 = util_spec "b", "1", "c" => ">= 1" # unresolved
+    b2 = util_spec "b", "2", "c" => ">= 1", "d" => "< 3"
+    c1 = util_spec "c", "1", "d" => "<= 2" # 1st level
+    c2 = util_spec "c", "2", "d" => "<= 2"
+    c3 = util_spec "c", "3", "d" => "<= 3"
+    d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb" # 2nd level
+    d2 = util_spec "d", "2", nil, "lib/d#{$$}.rb"
+    d3 = util_spec "d", "3", nil, "lib/d#{$$}.rb"
 
-      install_specs d1, d2, d3, c1, c2, c3, b1, b2, a1
+    install_specs d1, d2, d3, c1, c2, c3, b1, b2, a1
 
-      a1.activate
+    a1.activate
 
-      require "d#{$$}"
+    require "d#{$$}"
 
-      assert_includes [%w(a-1 b-2 c-3 d-2),%w(a-1 b-2 d-2)], loaded_spec_names
-    end
+    assert_includes [%w[a-1 b-2 c-3 d-2],%w[a-1 b-2 d-2]], loaded_spec_names
   end
 
   def test_inner_clonflict_in_indirect_gems_reversed
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      b1 = util_spec "b", "1", "xc" => ">= 1" # unresolved
-      b2 = util_spec "b", "2", "xc" => ">= 1", "d" => "< 3"
-      c1 = util_spec "xc", "1", "d" => "<= 3" # 1st level
-      c2 = util_spec "xc", "2", "d" => "<= 2"
-      c3 = util_spec "xc", "3", "d" => "<= 3"
-      d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb" # 2nd level
-      d2 = util_spec "d", "2", nil, "lib/d#{$$}.rb"
-      d3 = util_spec "d", "3", nil, "lib/d#{$$}.rb"
+    a1 = util_spec "a", "1", "b" => "> 0"
+    b1 = util_spec "b", "1", "xc" => ">= 1" # unresolved
+    b2 = util_spec "b", "2", "xc" => ">= 1", "d" => "< 3"
+    c1 = util_spec "xc", "1", "d" => "<= 3" # 1st level
+    c2 = util_spec "xc", "2", "d" => "<= 2"
+    c3 = util_spec "xc", "3", "d" => "<= 3"
+    d1 = util_spec "d", "1", nil, "lib/d#{$$}.rb" # 2nd level
+    d2 = util_spec "d", "2", nil, "lib/d#{$$}.rb"
+    d3 = util_spec "d", "3", nil, "lib/d#{$$}.rb"
 
-      install_specs d1, d2, d3, c1, c2, c3, b1, b2, a1
+    install_specs d1, d2, d3, c1, c2, c3, b1, b2, a1
 
-      a1.activate
+    a1.activate
 
-      require "d#{$$}"
+    require "d#{$$}"
 
-      assert_includes [%w(a-1 b-2 d-2 xc-3), %w(a-1 b-2 d-2)], loaded_spec_names
-    end
+    assert_includes [%w[a-1 b-2 d-2 xc-3], %w[a-1 b-2 d-2]], loaded_spec_names
   end
 
   ##
@@ -397,16 +372,16 @@ end
   #     [B] ~> 1.0 (satisfied by 1.0)
 
   def test_self_activate_checks_dependencies
-    a = util_spec 'a', '1.0'
-    a.add_dependency 'c', '= 1.0'
-    a.add_dependency 'b', '~> 1.0'
-
-    b1 = util_spec 'b', '1.0'
-    b2 = util_spec 'b', '2.0'
-    c  = util_spec 'c', '1.0', 'b' => '= 2.0'
+    a = util_spec "a", "1.0"
+    a.add_dependency "c", "= 1.0"
+    a.add_dependency "b", "~> 1.0"
+
+    b1 = util_spec "b", "1.0"
+    b2 = util_spec "b", "2.0"
+    c  = util_spec "c", "1.0", "b" => "= 2.0"
     install_specs b1, b2, c, a
 
-    e = assert_raises Gem::LoadError do
+    e = assert_raise Gem::LoadError do
       assert_activate nil, a, c, "b"
     end
 
@@ -421,14 +396,14 @@ end
   #         [B] = 2.0
 
   def test_self_activate_divergent
-    a  = util_spec 'a', '1.0', 'b' => '~> 1.0', 'c' => '= 1.0'
-    b1 = util_spec 'b', '1.0'
-    b2 = util_spec 'b', '2.0'
-    c  = util_spec 'c', '1.0', 'b' => '= 2.0'
+    a  = util_spec "a", "1.0", "b" => "~> 1.0", "c" => "= 1.0"
+    b1 = util_spec "b", "1.0"
+    b2 = util_spec "b", "2.0"
+    c  = util_spec "c", "1.0", "b" => "= 2.0"
 
     install_specs b1, b2, c, a
 
-    e = assert_raises Gem::ConflictError do
+    e = assert_raise Gem::ConflictError do
       assert_activate nil, a, c, "b"
     end
 
@@ -440,9 +415,9 @@ end
   # DOC
 
   def test_self_activate_old_required
-    e1, = util_spec 'e', '1', 'd' => '= 1'
-    @d1 = util_spec 'd', '1'
-    @d2 = util_spec 'd', '2'
+    e1, = util_spec "e", "1", "d" => "= 1"
+    @d1 = util_spec "d", "1"
+    @d2 = util_spec "d", "2"
 
     install_specs @d1, @d2, e1
 
@@ -453,17 +428,17 @@ end
   # DOC
 
   def test_self_activate_platform_alternate
-    @x1_m = util_spec 'x', '1' do |s|
+    @x1_m = util_spec "x", "1" do |s|
       s.platform = Gem::Platform.new %w[cpu my_platform 1]
     end
 
-    @x1_o = util_spec 'x', '1' do |s|
+    @x1_o = util_spec "x", "1" do |s|
       s.platform = Gem::Platform.new %w[cpu other_platform 1]
     end
 
-    @w1 = util_spec 'w', '1', 'x' => nil
+    @w1 = util_spec "w", "1", "x" => nil
 
-    util_set_arch 'cpu-my_platform1'
+    util_set_arch "cpu-my_platform1"
     install_specs @x1_m, @x1_o, @w1
 
     assert_activate %w[x-1-cpu-my_platform-1 w-1], @w1, @x1_m
@@ -473,13 +448,13 @@ end
   # DOC
 
   def test_self_activate_platform_bump
-    @y1 = util_spec 'y', '1'
+    @y1 = util_spec "y", "1"
 
-    @y1_1_p = util_spec 'y', '1.1' do |s|
+    @y1_1_p = util_spec "y", "1.1" do |s|
       s.platform = Gem::Platform.new %w[cpu my_platform 1]
     end
 
-    @z1 = util_spec 'z', '1', 'y' => nil
+    @z1 = util_spec "z", "1", "y" => nil
     install_specs @y1, @y1_1_p, @z1
 
     assert_activate %w[y-1 z-1], @z1, @y1
@@ -492,11 +467,11 @@ end
   #         [A] >= 0 (satisfied by 1.a)
 
   def test_self_activate_prerelease
-    @c1_pre = util_spec 'c', '1.a', "a" => "1.a", "b" => "1"
-    @a1_pre = util_spec 'a', '1.a'
-    @b1     = util_spec 'b', '1' do |s|
-      s.add_dependency 'a'
-      s.add_development_dependency 'aa'
+    @c1_pre = util_spec "c", "1.a", "a" => "1.a", "b" => "1"
+    @a1_pre = util_spec "a", "1.a"
+    @b1     = util_spec "b", "1" do |s|
+      s.add_dependency "a"
+      s.add_development_dependency "aa"
     end
     install_specs @a1_pre, @b1, @c1_pre
 
@@ -511,41 +486,37 @@ end
     install_specs b1, b2, a1
 
     a1.activate
-    save_loaded_features do
-      require "b/c"
-    end
+    require "b/c"
 
-    assert_equal %w(a-1 b-1), loaded_spec_names
+    assert_equal %w[a-1 b-1], loaded_spec_names
   end
 
   def test_self_activate_via_require_wtf
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0", "d" => "> 0"    # this
-      b1 = util_spec "b", "1", { "c" => ">= 1" }, "lib/b#{$$}.rb"
-      b2 = util_spec "b", "2", { "c" => ">= 2" }, "lib/b#{$$}.rb" # this
-      c1 = util_spec "c", "1"
-      c2 = util_spec "c", "2"                                # this
-      d1 = util_spec "d", "1", { "c" => "< 2" },  "lib/d#{$$}.rb"
-      d2 = util_spec "d", "2", { "c" => "< 2" },  "lib/d#{$$}.rb" # this
+    a1 = util_spec "a", "1", "b" => "> 0", "d" => "> 0" # this
+    b1 = util_spec "b", "1", { "c" => ">= 1" }, "lib/b#{$$}.rb"
+    b2 = util_spec "b", "2", { "c" => ">= 2" }, "lib/b#{$$}.rb" # this
+    c1 = util_spec "c", "1"
+    c2 = util_spec "c", "2" # this
+    d1 = util_spec "d", "1", { "c" => "< 2" },  "lib/d#{$$}.rb"
+    d2 = util_spec "d", "2", { "c" => "< 2" },  "lib/d#{$$}.rb" # this
 
-      install_specs c1, c2, b1, b2, d1, d2, a1
+    install_specs c1, c2, b1, b2, d1, d2, a1
 
-      a1.activate
+    a1.activate
 
-      assert_equal %w(a-1), loaded_spec_names
-      assert_equal ["b (> 0)", "d (> 0)"], unresolved_names
+    assert_equal %w[a-1], loaded_spec_names
+    assert_equal ["b (> 0)", "d (> 0)"], unresolved_names
 
-      require "b#{$$}"
+    require "b#{$$}"
 
-      e = assert_raises Gem::LoadError do
-        require "d#{$$}"
-      end
+    e = assert_raise Gem::LoadError do
+      require "d#{$$}"
+    end
 
-      assert_equal "unable to find a version of 'd' to activate", e.message
+    assert_equal "unable to find a version of 'd' to activate", e.message
 
-      assert_equal %w(a-1 b-2 c-2), loaded_spec_names
-      assert_equal ["d (> 0)"], unresolved_names
-    end
+    assert_equal %w[a-1 b-2 c-2], loaded_spec_names
+    assert_equal ["d (> 0)"], unresolved_names
   end
 
   def test_self_activate_deep_unambiguous
@@ -558,11 +529,11 @@ end
     install_specs c1, c2, b1, b2, a1
 
     a1.activate
-    assert_equal %w(a-1 b-1 c-1), loaded_spec_names
+    assert_equal %w[a-1 b-1 c-1], loaded_spec_names
   end
 
   def test_self_activate_loaded
-    foo = util_spec 'foo', '1'
+    foo = util_spec "foo", "1"
 
     assert foo.activate
     refute foo.activate
@@ -574,9 +545,9 @@ end
   # [C] depends on nothing
 
   def test_self_activate_unrelated
-    a = util_spec 'a', '1.0', 'b' => '>= 1.0'
-    b = util_spec 'b', '1.0'
-    c = util_spec 'c', '1.0'
+    a = util_spec "a", "1.0", "b" => ">= 1.0"
+    b = util_spec "b", "1.0"
+    c = util_spec "c", "1.0"
     install_specs b, c, a
 
     assert_activate %w[b-1.0 c-1.0 a-1.0], a, c, "b"
@@ -592,11 +563,11 @@ end
   # TODO: move these to specification
 
   def test_self_activate_over
-    a = util_spec 'a', '1.0', 'b' => '>= 1.0', 'c' => '= 1.0'
-    install_specs util_spec 'b', '1.0'
-    install_specs util_spec 'b', '1.1'
-    install_specs util_spec 'b', '2.0'
-    install_specs util_spec 'c', '1.0', 'b' => '~> 1.0'
+    a = util_spec "a", "1.0", "b" => ">= 1.0", "c" => "= 1.0"
+    install_specs util_spec "b", "1.0"
+    install_specs util_spec "b", "1.1"
+    install_specs util_spec "b", "2.0"
+    install_specs util_spec "c", "1.0", "b" => "~> 1.0"
     install_specs a
 
     a.activate
@@ -617,10 +588,10 @@ end
   # first resolve through a dependency that is later pruned.
 
   def test_self_activate_under
-    a    = util_spec 'a', '1.0', 'b' => '~> 1.0', 'c' => '= 1.0'
-    b1   = util_spec 'b', '1.0'
-    b1_1 = util_spec 'b', '1.1'
-    c    = util_spec 'c', '1.0', 'b' => '= 1.0'
+    a    = util_spec "a", "1.0", "b" => "~> 1.0", "c" => "= 1.0"
+    b1   = util_spec "b", "1.0"
+    b1_1 = util_spec "b", "1.1"
+    c    = util_spec "c", "1.0", "b" => "= 1.0"
 
     install_specs b1, b1_1, c, a
 
@@ -636,10 +607,10 @@ end
   # [C1] depends on nothing
 
   def test_self_activate_dropped
-    a1 = util_spec 'a', '1', 'b' => nil
-    b1 = util_spec 'b', '1', 'c' => nil
-    b2 = util_spec 'b', '2'
-    c1 = util_spec 'c', '1'
+    a1 = util_spec "a", "1", "b" => nil
+    b1 = util_spec "b", "1", "c" => nil
+    b2 = util_spec "b", "2"
+    c1 = util_spec "c", "1"
     install_specs c1, b1, b2, a1
 
     assert_activate %w[b-2 a-1], a1, "b"
@@ -656,11 +627,11 @@ end
   # resolve.
 
   def test_self_activate_raggi_the_edgecase_generator
-    a    = util_spec 'a', '1.0', 'b' => '>= 1.0', 'c' => '>= 1.0'
-    b1   = util_spec 'b', '1.0'
-    b1_0 = util_spec 'b', '1.1', 'z' => '>= 1.0'
-    c    = util_spec 'c', '1.0', 'b' => '= 1.0'
-    z    = util_spec 'z', '1'
+    a    = util_spec "a", "1.0", "b" => ">= 1.0", "c" => ">= 1.0"
+    b1   = util_spec "b", "1.0"
+    b1_0 = util_spec "b", "1.1", "z" => ">= 1.0"
+    c    = util_spec "c", "1.0", "b" => "= 1.0"
+    z    = util_spec "z", "1"
 
     install_specs z, b1, b1_0, c, z
 
@@ -668,12 +639,12 @@ end
   end
 
   def test_self_activate_conflict
-    install_specs util_spec 'b', '1.0'
-    install_specs util_spec 'b', '2.0'
+    install_specs util_spec "b", "1.0"
+    install_specs util_spec "b", "2.0"
 
     gem "b", "= 1.0"
 
-    assert_raises Gem::LoadError do
+    assert_raise Gem::LoadError do
       gem "b", "= 2.0"
     end
   end
@@ -684,7 +655,7 @@ end
     install_specs a
     Gem::Specification.all = [a]
 
-    assert_equal a, Gem::Specification.find_inactive_by_path('foo')
+    assert_equal a, Gem::Specification.find_inactive_by_path("foo")
   end
 
   def test_self_attribute_names
@@ -720,20 +691,20 @@ end
       version
     ]
 
-    actual_value = Gem::Specification.attribute_names.map { |a| a.to_s }.sort
+    actual_value = Gem::Specification.attribute_names.map {|a| a.to_s }.sort
 
     assert_equal expected_value, actual_value
   end
 
   def test_self__load_future
     spec = Gem::Specification.new
-    spec.name = 'a'
-    spec.version = '1'
+    spec.name = "a"
+    spec.version = "1"
     spec.specification_version = @current_version + 1
 
     load_spec = Marshal.load Marshal.dump(spec)
 
-    assert_equal 'a', load_spec.name
+    assert_equal "a", load_spec.name
     assert_equal Gem::Version.new(1), load_spec.version
     assert_equal @current_version, load_spec.specification_version
   end
@@ -747,125 +718,6 @@ end
                  spec.specification_version
   end
 
-  def test_self_from_yaml_syck_date_bug
-    # This is equivalent to (and totally valid) psych 1.0 output and
-    # causes parse errors on syck.
-    yaml = @a1.to_yaml
-    yaml.sub!(/^date:.*/, "date: 2011-04-26 00:00:00.000000000Z")
-
-    spec = with_syck do
-      Gem::Specification.from_yaml yaml
-    end
-
-    assert_kind_of Time, @a1.date
-    assert_kind_of Time, spec.date
-  end
-
-  def test_self_from_yaml_syck_default_key_bug
-    # This is equivalent to (and totally valid) psych 1.0 output and
-    # causes parse errors on syck.
-    yaml = <<-YAML
---- !ruby/object:Gem::Specification
-name: posix-spawn
-version: !ruby/object:Gem::Version
-  version: 0.3.6
-  prerelease:
-dependencies:
-- !ruby/object:Gem::Dependency
-  name: rake-compiler
-  requirement: &70243867725240 !ruby/object:Gem::Requirement
-    none: false
-    requirements:
-    - - =
-      - !ruby/object:Gem::Version
-        version: 0.7.6
-  type: :development
-  prerelease: false
-  version_requirements: *70243867725240
-platform: ruby
-files: []
-test_files: []
-bindir:
-    YAML
-
-    spec = with_syck do
-      Gem::Specification.from_yaml yaml
-    end
-
-    op = spec.dependencies.first.requirement.requirements.first.first
-    refute_kind_of YAML::Syck::DefaultKey, op
-
-    refute_match %r%DefaultKey%, spec.to_ruby
-  end
-
-  def test_self_from_yaml_cleans_up_defaultkey
-    yaml = <<-YAML
---- !ruby/object:Gem::Specification
-name: posix-spawn
-version: !ruby/object:Gem::Version
-  version: 0.3.6
-  prerelease:
-dependencies:
-- !ruby/object:Gem::Dependency
-  name: rake-compiler
-  requirement: &70243867725240 !ruby/object:Gem::Requirement
-    none: false
-    requirements:
-    - - !ruby/object:YAML::Syck::DefaultKey {}
-
-      - !ruby/object:Gem::Version
-        version: 0.7.6
-  type: :development
-  prerelease: false
-  version_requirements: *70243867725240
-platform: ruby
-files: []
-test_files: []
-bindir:
-    YAML
-
-    spec = Gem::Specification.from_yaml yaml
-
-    op = spec.dependencies.first.requirement.requirements.first.first
-    refute_kind_of YAML::Syck::DefaultKey, op
-
-    refute_match %r%DefaultKey%, spec.to_ruby
-  end
-
-  def test_self_from_yaml_cleans_up_defaultkey_from_newer_192
-    yaml = <<-YAML
---- !ruby/object:Gem::Specification
-name: posix-spawn
-version: !ruby/object:Gem::Version
-  version: 0.3.6
-  prerelease:
-dependencies:
-- !ruby/object:Gem::Dependency
-  name: rake-compiler
-  requirement: &70243867725240 !ruby/object:Gem::Requirement
-    none: false
-    requirements:
-    - - !ruby/object:Syck::DefaultKey {}
-
-      - !ruby/object:Gem::Version
-        version: 0.7.6
-  type: :development
-  prerelease: false
-  version_requirements: *70243867725240
-platform: ruby
-files: []
-test_files: []
-bindir:
-    YAML
-
-    spec = Gem::Specification.from_yaml yaml
-
-    op = spec.dependencies.first.requirement.requirements.first.first
-    refute_kind_of YAML::Syck::DefaultKey, op
-
-    refute_match %r%DefaultKey%, spec.to_ruby
-  end
-
   def test_self_from_yaml_cleans_up_Date_objects
     yaml = <<-YAML
 --- !ruby/object:Gem::Specification
@@ -931,20 +783,20 @@ dependencies: []
   end
 
   def test_self_load_relative
-    File.open 'a-2.gemspec', 'w' do |io|
+    File.open "a-2.gemspec", "w" do |io|
       io.write @a2.to_ruby_for_cache
     end
 
-    spec = Gem::Specification.load 'a-2.gemspec'
+    spec = Gem::Specification.load "a-2.gemspec"
 
     @a2.files.clear
 
     assert_equal @a2, spec
 
-    assert_equal File.join(@tempdir, 'a-2.gemspec'), spec.loaded_from
+    assert_equal File.join(@tempdir, "a-2.gemspec"), spec.loaded_from
   end
 
-  if RUBY_ENGINE == 'ruby' and RUBY_VERSION < '2.7'
+  if RUBY_ENGINE == "ruby" && RUBY_VERSION < "2.7"
     def test_self_load_tainted
       full_path = @a2.spec_file
       write_file full_path do |io|
@@ -973,7 +825,7 @@ dependencies: []
         io.write @a2.to_ruby_for_cache
       end
     rescue Errno::EINVAL
-      skip "cannot create '#{full_path}' on this platform"
+      pend "cannot create '#{full_path}' on this platform"
     end
 
     spec = Gem::Specification.load full_path
@@ -992,7 +844,7 @@ dependencies: []
         io.write @a2.to_ruby_for_cache
       end
     rescue Errno::EINVAL
-      skip "cannot create '#{full_path}' on this platform"
+      pend "cannot create '#{full_path}' on this platform"
     end
 
     spec = Gem::Specification.load full_path
@@ -1011,7 +863,7 @@ dependencies: []
         io.write @a2.to_ruby_for_cache
       end
     rescue Errno::EINVAL
-      skip "cannot create '#{full_path}' on this platform"
+      pend "cannot create '#{full_path}' on this platform"
     end
 
     spec = Gem::Specification.load full_path
@@ -1022,34 +874,31 @@ dependencies: []
   end
 
   def test_self_load_utf8_with_ascii_encoding
-    int_enc = Encoding.default_internal
-    silence_warnings { Encoding.default_internal = 'US-ASCII' }
-
-    spec2 = @a2.dup
-    bin = "\u5678".dup
-    spec2.authors = [bin]
-    full_path = spec2.spec_file
-    write_file full_path do |io|
-      io.write spec2.to_ruby_for_cache.force_encoding('BINARY').sub("\\u{5678}", bin.force_encoding('BINARY'))
-    end
+    with_internal_encoding("US-ASCII") do
+      spec2 = @a2.dup
+      bin = "\u5678".dup
+      spec2.authors = [bin]
+      full_path = spec2.spec_file
+      write_file full_path do |io|
+        io.write spec2.to_ruby_for_cache.force_encoding("BINARY").sub("\\u{5678}", bin.force_encoding("BINARY"))
+      end
 
-    spec = Gem::Specification.load full_path
+      spec = Gem::Specification.load full_path
 
-    spec2.files.clear
+      spec2.files.clear
 
-    assert_equal spec2, spec
-  ensure
-    silence_warnings { Encoding.default_internal = int_enc }
+      assert_equal spec2, spec
+    end
   end
 
   def test_self_load_legacy_ruby
     spec = Gem::Deprecate.skip_during do
       eval LEGACY_RUBY_SPEC
     end
-    assert_equal 'keyedlist', spec.name
-    assert_equal '0.4.0', spec.version.to_s
+    assert_equal "keyedlist", spec.name
+    assert_equal "0.4.0", spec.version.to_s
     assert_kind_of Time, spec.date
-    assert spec.required_ruby_version.satisfied_by?(Gem::Version.new('1'))
+    assert spec.required_ruby_version.satisfied_by?(Gem::Version.new("1"))
     assert_equal false, spec.has_unit_tests?
   end
 
@@ -1084,26 +933,26 @@ dependencies: []
 
   def test_self_outdated
     spec_fetcher do |fetcher|
-      fetcher.download 'a', 4
+      fetcher.download "a", 4
 
-      fetcher.spec 'a', 3
+      fetcher.spec "a", 3
     end
 
     assert_equal %w[a], Gem::Specification.outdated
   end
 
   def test_self_outdated_and_latest_remotes
-    specs = spec_fetcher do |fetcher|
-      fetcher.download 'a', 4
-      fetcher.download 'b', 3
+    spec_fetcher do |fetcher|
+      fetcher.download "a", 4
+      fetcher.download "b", 3
 
-      fetcher.spec 'a', '3.a'
-      fetcher.spec 'b', 2
+      fetcher.spec "a", "3.a"
+      fetcher.spec "b", 2
     end
 
     expected = [
-      [specs['a-3.a'], v(4)],
-      [specs['b-2'],   v(3)],
+      [Gem::Specification.stubs.find {|s| s.full_name == "a-3.a" }, v(4)],
+      [Gem::Specification.stubs.find {|s| s.full_name == "b-2" }, v(3)],
     ]
 
     assert_equal expected, Gem::Specification.outdated_and_latest_version.to_a
@@ -1112,18 +961,18 @@ dependencies: []
   def test_self_remove_spec
     install_specs @a1
 
-    assert_includes Gem::Specification.all_names, 'a-1'
-    assert_includes Gem::Specification.stubs.map { |s| s.full_name }, 'a-1'
+    assert_includes Gem::Specification.all_names, "a-1"
+    assert_includes Gem::Specification.stubs.map {|s| s.full_name }, "a-1"
 
     uninstall_gem @a1
     Gem::Specification.reset
 
-    refute_includes Gem::Specification.all_names, 'a-1'
-    refute_includes Gem::Specification.stubs.map { |s| s.full_name }, 'a-1'
+    refute_includes Gem::Specification.all_names, "a-1"
+    refute_includes Gem::Specification.stubs.map {|s| s.full_name }, "a-1"
   end
 
   def test_self_remove_spec_removed
-    File.open @a1.spec_file, 'w' do |io|
+    File.open @a1.spec_file, "w" do |io|
       io.write @a1.to_ruby
     end
 
@@ -1133,50 +982,40 @@ dependencies: []
 
     Gem::Specification.reset
 
-    refute_includes Gem::Specification.all_names, 'a-1'
-    refute_includes Gem::Specification.stubs.map { |s| s.full_name }, 'a-1'
+    refute_includes Gem::Specification.all_names, "a-1"
+    refute_includes Gem::Specification.stubs.map {|s| s.full_name }, "a-1"
   end
 
-  def test_self_stubs
+  def test_self_stubs_for_lazy_loading
     Gem.loaded_specs.clear
     Gem::Specification.class_variable_set(:@@stubs, nil)
 
-    dir_standard_specs = File.join Gem.dir, 'specifications'
-    dir_default_specs = Gem.default_specifications_dir
+    dir_standard_specs = File.join Gem.dir, "specifications"
 
-    # Create gemspecs in three locations used in stubs
-    loaded_spec = Gem::Specification.new 'a', '3'
-    Gem.loaded_specs['a'] = loaded_spec
-    save_gemspec 'a', '2', dir_default_specs
-    save_gemspec 'a', '1', dir_standard_specs
+    save_gemspec("a-1", "1", dir_standard_specs) {|s| s.name = "a" }
+    save_gemspec("b-1", "1", dir_standard_specs) {|s| s.name = "b" }
 
-    full_names = ['a-3', 'a-2', 'a-1']
-    assert_equal full_names, Gem::Specification.stubs.map { |s| s.full_name }
+    assert_equal ["a-1"], Gem::Specification.stubs_for("a").map {|s| s.full_name }
+    assert_equal 1, Gem::Specification.class_variable_get(:@@stubs_by_name).length
+    assert_equal ["b-1"], Gem::Specification.stubs_for("b").map {|s| s.full_name }
+    assert_equal 2, Gem::Specification.class_variable_get(:@@stubs_by_name).length
 
-    Gem.loaded_specs.delete 'a'
-    Gem::Specification.class_variable_set(:@@stubs, nil)
-  end
+    assert_equal(
+      Gem::Specification.stubs_for("a").map {|s| s.object_id },
+      Gem::Specification.stubs_for("a").map {|s| s.object_id }
+    )
 
-  def test_self_stubs_for
-    Gem.loaded_specs.clear
+    Gem.loaded_specs.delete "a"
+    Gem.loaded_specs.delete "b"
     Gem::Specification.class_variable_set(:@@stubs, nil)
+  end
 
-    dir_standard_specs = File.join Gem.dir, 'specifications'
-    dir_default_specs = Gem.default_specifications_dir
-
-    # Create gemspecs in three locations used in stubs
-    loaded_spec = Gem::Specification.new 'a', '3'
-    Gem.loaded_specs['a'] = loaded_spec
-    save_gemspec('a-2', '2', dir_default_specs) { |s| s.name = 'a' }
-    save_gemspec('a-1', '1', dir_standard_specs) { |s| s.name = 'a' }
+  def test_self_stubs_for_no_lazy_loading_after_all_specs_setup
+    Gem::Specification.all = [util_spec("a", "1")]
 
-    full_names = ['a-3', 'a-2', 'a-1']
+    save_gemspec("b-1", "1", File.join(Gem.dir, "specifications")) {|s| s.name = "b" }
 
-    assert_equal full_names, Gem::Specification.stubs_for('a').map { |s| s.full_name }
-    assert_equal 1, Gem::Specification.class_variable_get(:@@stubs_by_name).length
-
-    Gem.loaded_specs.delete 'a'
-    Gem::Specification.class_variable_set(:@@stubs, nil)
+    assert_equal [], Gem::Specification.stubs_for("b").map {|s| s.full_name }
   end
 
   def test_self_stubs_for_mult_platforms
@@ -1186,30 +1025,30 @@ dependencies: []
     orig_platform = Gem.platforms.dup
 
     # create user spec
-    user_spec_dir = File.join Gem.user_dir, 'specifications'
-    FileUtils.mkdir_p(user_spec_dir)  unless Dir.exist? user_spec_dir
+    user_spec_dir = File.join Gem.user_dir, "specifications"
+    FileUtils.mkdir_p(user_spec_dir) unless Dir.exist? user_spec_dir
     # dirs doesn't include user ?
     Gem::Specification.dirs << user_spec_dir
 
-    gem = 'mingw'
-    v   = '1.1.1'
-    platforms = ['x86-mingw32', 'x64-mingw32']
+    gem = "mingw"
+    v   = "1.1.1"
+    platforms = ["x86-mingw32", "x64-mingw32"]
 
     #create specs
     platforms.each do |plat|
-      spec = Gem::Specification.new(gem, v) { |s| s.platform = plat }
-      File.open File.join(user_spec_dir, "#{gem}-#{v}-#{plat}.gemspec"), 'w' do |io|
+      spec = Gem::Specification.new(gem, v) {|s| s.platform = plat }
+      File.open File.join(user_spec_dir, "#{gem}-#{v}-#{plat}.gemspec"), "w" do |io|
         io.write spec.to_ruby
       end
     end
 
     platforms.each do |plat|
       cur_plat = Gem::Platform.new plat
-      Gem.platforms = ['ruby', cur_plat]
+      Gem.platforms = ["ruby", cur_plat]
 
       Gem::Specification.class_variable_set :@@stubs, nil
       Gem::Specification.stubs if plat == platforms.last # test loading via stubs
-      t = Gem::Specification.stubs_for 'mingw'
+      t = Gem::Specification.stubs_for "mingw"
 
       assert_equal 1, t.length
       assert_equal cur_plat, t.first.platform
@@ -1218,14 +1057,30 @@ dependencies: []
     Gem.platforms = orig_platform
   end
 
-  DATA_PATH = File.expand_path "../data", __FILE__
+  def test_self_stubs_returns_only_specified_named_specs
+    dir_standard_specs = File.join Gem.dir, "specifications"
+
+    save_gemspec("a-1", "1", dir_standard_specs) {|s| s.name = "a" }
+    save_gemspec("a-2", "2", dir_standard_specs) {|s| s.name = "a" }
+    save_gemspec("a-a", "3", dir_standard_specs) {|s| s.name = "a-a" }
+
+    assert_equal ["a-1", "a-2"], Gem::Specification.stubs_for("a").map(&:full_name).sort
+  end
 
   def test_handles_private_null_type
-    path = File.join DATA_PATH, "null-type.gemspec.rz"
+    path = File.expand_path "data/pry-0.4.7.gemspec.rz", __dir__
+
+    data = Marshal.load Gem::Util.inflate(Gem.read_binary(path))
+
+    assert_instance_of Gem::Specification, data
+  end
+
+  def test_handles_dependencies_with_syck_requirements_bug
+    path = File.expand_path "data/excon-0.7.7.gemspec.rz", __dir__
 
     data = Marshal.load Gem::Util.inflate(Gem.read_binary(path))
 
-    assert_nil data.signing_key
+    assert_instance_of Gem::Specification, data
   end
 
   def test_initialize
@@ -1247,9 +1102,9 @@ dependencies: []
     assert_equal [], spec.extensions
     assert_equal [], spec.requirements
     assert_equal [], spec.dependencies
-    assert_equal 'bin', spec.bindir
-    assert_equal '>= 0', spec.required_ruby_version.to_s
-    assert_equal '>= 0', spec.required_rubygems_version.to_s
+    assert_equal "bin", spec.bindir
+    assert_equal ">= 0", spec.required_ruby_version.to_s
+    assert_equal ">= 0", spec.required_rubygems_version.to_s
   end
 
   def test_initialize_future
@@ -1271,18 +1126,18 @@ dependencies: []
     spec = Gem::Specification.new do |s|
       s.name = "blah"
       s.version = "1.3.5"
-      s.summary = 'summary'
-      s.description = 'description'
-      s.authors = 'author a', 'author b'
-      s.licenses = 'BSD-2-Clause'
-      s.files = 'lib/file.rb'
-      s.test_files = 'test/file.rb'
-      s.rdoc_options = '--foo'
-      s.extra_rdoc_files = 'README.txt'
-      s.executables = 'exec'
-      s.extensions = 'ext/extconf.rb'
-      s.requirements = 'requirement'
-      s.add_dependency 'some_gem'
+      s.summary = "summary"
+      s.description = "description"
+      s.authors = "author a", "author b"
+      s.licenses = "BSD-2-Clause"
+      s.files = "lib/file.rb"
+      s.test_files = "test/file.rb"
+      s.rdoc_options = "--foo"
+      s.extra_rdoc_files = "README.txt"
+      s.executables = "exec"
+      s.extensions = "ext/extconf.rb"
+      s.requirements = "requirement"
+      s.add_dependency "some_gem"
     end
 
     dup_spec = spec.dup
@@ -1296,84 +1151,93 @@ dependencies: []
     assert_equal Gem::Platform::RUBY, spec.platform
     assert_same spec.platform, dup_spec.platform
 
-    assert_equal 'summary', spec.summary
+    assert_equal "summary", spec.summary
     assert_same spec.summary, dup_spec.summary
 
     assert_equal %w[README.txt bin/exec ext/extconf.rb lib/file.rb
                     test/file.rb].sort,
                  spec.files
-    refute_same spec.files, dup_spec.files, 'files'
+    refute_same spec.files, dup_spec.files, "files"
 
     assert_equal %w[test/file.rb], spec.test_files
-    refute_same spec.test_files, dup_spec.test_files, 'test_files'
+    refute_same spec.test_files, dup_spec.test_files, "test_files"
 
     assert_equal %w[--foo], spec.rdoc_options
-    refute_same spec.rdoc_options, dup_spec.rdoc_options, 'rdoc_options'
+    refute_same spec.rdoc_options, dup_spec.rdoc_options, "rdoc_options"
 
     assert_equal %w[README.txt], spec.extra_rdoc_files
     refute_same spec.extra_rdoc_files, dup_spec.extra_rdoc_files,
-                'extra_rdoc_files'
+                "extra_rdoc_files"
 
     assert_equal %w[exec], spec.executables
-    refute_same spec.executables, dup_spec.executables, 'executables'
+    refute_same spec.executables, dup_spec.executables, "executables"
 
     assert_equal %w[ext/extconf.rb], spec.extensions
-    refute_same spec.extensions, dup_spec.extensions, 'extensions'
+    refute_same spec.extensions, dup_spec.extensions, "extensions"
 
     assert_equal %w[requirement], spec.requirements
-    refute_same spec.requirements, dup_spec.requirements, 'requirements'
+    refute_same spec.requirements, dup_spec.requirements, "requirements"
 
-    assert_equal [Gem::Dependency.new('some_gem', Gem::Requirement.default)],
+    assert_equal [Gem::Dependency.new("some_gem", Gem::Requirement.default)],
                  spec.dependencies
-    refute_same spec.dependencies, dup_spec.dependencies, 'dependencies'
+    refute_same spec.dependencies, dup_spec.dependencies, "dependencies"
 
-    assert_equal 'bin', spec.bindir
+    assert_equal "bin", spec.bindir
     assert_same spec.bindir, dup_spec.bindir
 
-    assert_equal '>= 0', spec.required_ruby_version.to_s
+    assert_equal ">= 0", spec.required_ruby_version.to_s
     assert_same spec.required_ruby_version, dup_spec.required_ruby_version
 
-    assert_equal '>= 0', spec.required_rubygems_version.to_s
+    assert_equal ">= 0", spec.required_rubygems_version.to_s
     assert_same spec.required_rubygems_version,
                 dup_spec.required_rubygems_version
   end
 
   def test_initialize_copy_broken
     spec = Gem::Specification.new do |s|
-      s.name = 'a'
-      s.version = '1'
+      s.name = "a"
+      s.version = "1"
     end
 
     spec.instance_variable_set :@licenses, (class << (Object.new);self;end)
-    spec.loaded_from = '/path/to/file'
+    spec.loaded_from = "/path/to/file"
 
-    e = assert_raises Gem::FormatException do
+    e = assert_raise Gem::FormatException do
       spec.dup
     end
 
-    assert_equal 'a-1 has an invalid value for @licenses', e.message
-    assert_equal '/path/to/file', e.file_path
+    assert_equal "a-1 has an invalid value for @licenses", e.message
+    assert_equal "/path/to/file", e.file_path
   end
 
   def test_initialize_prerelease_version_before_name
     spec = Gem::Specification.new do |s|
-      s.version = '1.0.0.dev'
-      s.name = 'a'
+      s.version = "1.0.0.dev"
+      s.name = "a"
     end
 
     assert_equal "a", spec.name
     assert_equal "1.0.0.dev", spec.version.to_s
   end
 
+  def test_initialize_nil_version
+    expected = "nil versions are discouraged and will be deprecated in Rubygems 4\n"
+    actual_stdout, actual_stderr = capture_output do
+      Gem::Specification.new.version = nil
+    end
+    assert_empty actual_stdout
+    assert_equal(expected, actual_stderr)
+  end
+
   def test__dump
     @a2.platform = Gem::Platform.local
-    @a2.instance_variable_set :@original_platform, 'old_platform'
+    @a2.instance_variable_set :@original_platform, "old_platform"
 
     data = Marshal.dump @a2
 
     same_spec = Marshal.load data
 
-    assert_equal 'old_platform', same_spec.original_platform
+    assert_equal "old_platform", same_spec.original_platform
   end
 
   def test_activate
@@ -1388,12 +1252,12 @@ dependencies: []
       awesome.add_dependency :gem_name
     end
 
-    assert_equal %w[true gem_name], gem.dependencies.map { |dep| dep.name }
+    assert_equal %w[true gem_name], gem.dependencies.map {|dep| dep.name }
   end
 
   def test_add_dependency_from_existing_dependency
-    dep  = Gem::Dependency.new("existing_dep", Gem::Requirement.new('> 1'), :runtime)
-    spec = Gem::Specification.new { |s| s.add_dependency dep }
+    dep  = Gem::Dependency.new("existing_dep", Gem::Requirement.new("> 1"), :runtime)
+    spec = Gem::Specification.new {|s| s.add_dependency dep }
     assert_equal dep, spec.dependencies.first
   end
 
@@ -1402,27 +1266,27 @@ dependencies: []
       awesome.add_development_dependency "monkey"
     end
 
-    monkey = gem.dependencies.detect { |d| d.name == "monkey" }
+    monkey = gem.dependencies.detect {|d| d.name == "monkey" }
     assert_equal(:development, monkey.type)
   end
 
   def test_author
-    assert_equal 'A User', @a1.author
+    assert_equal "A User", @a1.author
   end
 
   def test_authors
-    assert_equal ['A User'], @a1.authors
+    assert_equal ["A User"], @a1.authors
   end
 
   def test_bindir_equals
-    @a1.bindir = 'apps'
+    @a1.bindir = "apps"
 
-    assert_equal 'apps', @a1.bindir
+    assert_equal "apps", @a1.bindir
   end
 
   def test_bindir_equals_nil
     @a2.bindir = nil
-    @a2.executable = 'app'
+    @a2.executable = "app"
 
     assert_nil                             @a2.bindir
     assert_equal %w[app lib/code.rb].sort, @a2.files
@@ -1453,35 +1317,35 @@ dependencies: []
   end
 
   def test_build_args
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
     ext_spec
 
     assert_empty @ext.build_args
 
-    File.open @ext.build_info_file, 'w' do |io|
+    File.open @ext.build_info_file, "w" do |io|
       io.puts
     end
 
     assert_empty @ext.build_args
 
-    File.open @ext.build_info_file, 'w' do |io|
-      io.puts '--with-foo-dir=wherever'
+    File.open @ext.build_info_file, "w" do |io|
+      io.puts "--with-foo-dir=wherever"
     end
 
     assert_equal %w[--with-foo-dir=wherever], @ext.build_args
   end
 
   def test_build_extensions
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
     ext_spec
 
-    refute_path_exists @ext.extension_dir, 'sanity check'
-    refute_empty @ext.extensions, 'sanity check'
+    assert_path_not_exist @ext.extension_dir, "sanity check"
+    refute_empty @ext.extensions, "sanity check"
 
     extconf_rb = File.join @ext.gem_dir, @ext.extensions.first
     FileUtils.mkdir_p File.dirname extconf_rb
 
-    File.open extconf_rb, 'w' do |f|
+    File.open extconf_rb, "w" do |f|
       f.write <<-'RUBY'
         File.open 'Makefile', 'w' do |f|
           f.puts "clean:\n\techo clean"
@@ -1493,46 +1357,46 @@ dependencies: []
 
     @ext.build_extensions
 
-    assert_path_exists @ext.extension_dir
+    assert_path_exist @ext.extension_dir
   end
 
   def test_default_spec_stub_is_marked_default
-    default = new_default_spec 'default', 2
+    default = new_default_spec "default", 2
     install_default_gems default
 
-    stub = Gem::Specification.stubs.find { |s| s.name == 'default' }
+    stub = Gem::Specification.stubs.find {|s| s.name == "default" }
     assert_predicate stub, :default_gem?
 
-    stub = Gem::Specification.find_all_by_name('default').first
+    stub = Gem::Specification.find_all_by_name("default").first
     assert_predicate stub, :default_gem?
   end
 
   def test_build_extensions_built
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
     ext_spec
 
-    refute_empty @ext.extensions, 'sanity check'
+    refute_empty @ext.extensions, "sanity check"
 
     gem_build_complete =
-      File.join @ext.extension_dir, 'gem.build_complete'
+      File.join @ext.extension_dir, "gem.build_complete"
 
     FileUtils.mkdir_p @ext.extension_dir
     FileUtils.touch gem_build_complete
 
     @ext.build_extensions
 
-    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'
-    refute_path_exists gem_make_out
+    gem_make_out = File.join @ext.extension_dir, "gem_make.out"
+    assert_path_not_exist gem_make_out
   end
 
   def test_build_extensions_default_gem
-    spec = new_default_spec 'default', 1
-    spec.extensions << 'extconf.rb'
+    spec = new_default_spec "default", 1
+    spec.extensions << "extconf.rb"
 
     extconf_rb = File.join spec.gem_dir, spec.extensions.first
     FileUtils.mkdir_p File.dirname extconf_rb
 
-    File.open extconf_rb, 'w' do |f|
+    File.open extconf_rb, "w" do |f|
       f.write <<-'RUBY'
         File.open 'Makefile', 'w' do |f|
           f.puts "default:\n\techo built"
@@ -1543,33 +1407,33 @@ dependencies: []
 
     spec.build_extensions
 
-    refute_path_exists spec.extension_dir
+    assert_path_not_exist spec.extension_dir
   end
 
   def test_build_extensions_error
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
     ext_spec
 
-    refute_empty @ext.extensions, 'sanity check'
+    refute_empty @ext.extensions, "sanity check"
 
-    assert_raises Gem::Ext::BuildError do
+    assert_raise Gem::Ext::BuildError do
       @ext.build_extensions
     end
   end
 
   def test_build_extensions_extensions_dir_unwritable
-    skip 'chmod not supported' if Gem.win_platform?
-    skip 'skipped in root privilege' if Process.uid.zero?
+    pend "chmod not supported" if Gem.win_platform?
+    pend "skipped in root privilege" if Process.uid.zero?
 
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
     ext_spec
 
-    refute_empty @ext.extensions, 'sanity check'
+    refute_empty @ext.extensions, "sanity check"
 
     extconf_rb = File.join @ext.gem_dir, @ext.extensions.first
     FileUtils.mkdir_p File.dirname extconf_rb
 
-    File.open extconf_rb, 'w' do |f|
+    File.open extconf_rb, "w" do |f|
       f.write <<-'RUBY'
         File.open 'Makefile', 'w' do |f|
           f.puts "clean:\n\techo clean"
@@ -1579,30 +1443,30 @@ dependencies: []
       RUBY
     end
 
-    FileUtils.mkdir_p File.join @ext.base_dir, 'extensions'
+    FileUtils.mkdir_p File.join @ext.base_dir, "extensions"
     FileUtils.chmod 0555, @ext.base_dir
-    FileUtils.chmod 0555, File.join(@ext.base_dir, 'extensions')
+    FileUtils.chmod 0555, File.join(@ext.base_dir, "extensions")
 
     @ext.build_extensions
-    refute_path_exists @ext.extension_dir
+    assert_path_not_exist @ext.extension_dir
   ensure
-    unless ($DEBUG or win_platform? or Process.uid.zero? or Gem.java_platform?)
-      FileUtils.chmod 0755, File.join(@ext.base_dir, 'extensions')
+    unless ($DEBUG || win_platform? || Process.uid.zero? || Gem.java_platform?)
+      FileUtils.chmod 0755, File.join(@ext.base_dir, "extensions")
       FileUtils.chmod 0755, @ext.base_dir
     end
   end
 
   def test_build_extensions_no_extensions_dir_unwritable
-    skip 'chmod not supported' if Gem.win_platform?
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "chmod not supported" if Gem.win_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
     ext_spec
 
-    refute_empty @ext.extensions, 'sanity check'
+    refute_empty @ext.extensions, "sanity check"
 
     extconf_rb = File.join @ext.gem_dir, @ext.extensions.first
     FileUtils.mkdir_p File.dirname extconf_rb
 
-    File.open extconf_rb, 'w' do |f|
+    File.open extconf_rb, "w" do |f|
       f.write <<-'RUBY'
         File.open 'Makefile', 'w' do |f|
           f.puts "clean:\n\techo clean"
@@ -1612,48 +1476,34 @@ dependencies: []
       RUBY
     end
 
-    FileUtils.rm_r File.join @gemhome, 'extensions'
+    FileUtils.rm_r File.join @gemhome, "extensions"
     FileUtils.chmod 0555, @gemhome
 
     @ext.build_extensions
 
-    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'
-    refute_path_exists gem_make_out
+    gem_make_out = File.join @ext.extension_dir, "gem_make.out"
+    assert_path_not_exist gem_make_out
   ensure
     FileUtils.chmod 0755, @gemhome
   end
 
   def test_build_extensions_none
-    refute_path_exists @a1.extension_dir, 'sanity check'
-    assert_empty @a1.extensions, 'sanity check'
+    assert_path_not_exist @a1.extension_dir, "sanity check"
+    assert_empty @a1.extensions, "sanity check"
 
     @a1.build_extensions
 
-    refute_path_exists @a1.extension_dir
-  end
-
-  def test_build_extensions_old
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
-    ext_spec
-
-    refute_empty @ext.extensions, 'sanity check'
-
-    @ext.installed_by_version = v(0)
-
-    @ext.build_extensions
-
-    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'
-    refute_path_exists gem_make_out
+    assert_path_not_exist @a1.extension_dir
   end
 
   def test_build_extensions_preview
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
     ext_spec
 
     extconf_rb = File.join @ext.gem_dir, @ext.extensions.first
     FileUtils.mkdir_p File.dirname extconf_rb
 
-    File.open extconf_rb, 'w' do |f|
+    File.open extconf_rb, "w" do |f|
       f.write <<-'RUBY'
         File.open 'Makefile', 'w' do |f|
           f.puts "clean:\n\techo clean"
@@ -1663,30 +1513,30 @@ dependencies: []
       RUBY
     end
 
-    refute_empty @ext.extensions, 'sanity check'
+    refute_empty @ext.extensions, "sanity check"
 
-    @ext.installed_by_version = v('2.2.0.preview.2')
+    @ext.installed_by_version = v("2.2.0.preview.2")
 
     @ext.build_extensions
 
-    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'
-    assert_path_exists gem_make_out
+    gem_make_out = File.join @ext.extension_dir, "gem_make.out"
+    assert_path_exist gem_make_out
   end
 
   def test_contains_requirable_file_eh
-    code_rb = File.join @a1.gem_dir, 'lib', 'code.rb'
+    code_rb = File.join @a1.gem_dir, "lib", "code.rb"
     FileUtils.mkdir_p File.dirname code_rb
     FileUtils.touch code_rb
 
-    assert @a1.contains_requirable_file? 'code'
+    assert @a1.contains_requirable_file? "code"
   end
 
   def test_contains_requirable_file_eh_extension
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
     ext_spec
 
-    _, err = capture_io do
-      refute @ext.contains_requirable_file? 'nonexistent'
+    _, err = capture_output do
+      refute @ext.contains_requirable_file? "nonexistent"
     end
 
     expected = "Ignoring ext-1 because its extensions are not built. " +
@@ -1698,8 +1548,8 @@ dependencies: []
   def test_contains_requirable_file_eh_extension_java_platform
     ext_spec(platform: Gem::Platform.new("java"))
 
-    _, err = capture_io do
-      refute @ext.contains_requirable_file? 'nonexistent'
+    _, err = capture_output do
+      refute @ext.contains_requirable_file? "nonexistent"
     end
 
     assert_empty err
@@ -1715,13 +1565,13 @@ dependencies: []
   end
 
   def test_date_equals_string
-    @a1.date = '2003-09-17'
+    @a1.date = "2003-09-17"
     assert_equal Time.utc(2003, 9, 17, 0,0,0), @a1.date
   end
 
   def test_date_equals_string_bad
-    assert_raises Gem::InvalidSpecificationException do
-      @a1.date = '9/11/2003'
+    assert_raise Gem::InvalidSpecificationException do
+      @a1.date = "9/11/2003"
     end
   end
 
@@ -1768,7 +1618,7 @@ dependencies: []
 
     assert_empty @gem.dependent_gems
 
-    bonobo = util_spec 'bonobo', 1
+    bonobo = util_spec "bonobo", 1
     install_gem bonobo
     install_gem @gem
 
@@ -1780,11 +1630,11 @@ dependencies: []
   end
 
   def test_doc_dir
-    assert_equal File.join(@gemhome, 'doc', 'a-1'), @a1.doc_dir
+    assert_equal File.join(@gemhome, "doc", "a-1"), @a1.doc_dir
   end
 
   def test_doc_dir_type
-    assert_equal File.join(@gemhome, 'doc', 'a-1', 'ri'), @a1.doc_dir('ri')
+    assert_equal File.join(@gemhome, "doc", "a-1", "ri"), @a1.doc_dir("ri")
   end
 
   def test_runtime_dependencies
@@ -1798,12 +1648,12 @@ dependencies: []
   end
 
   def test_description
-    assert_equal 'This is a test description', @a1.description
+    assert_equal "This is a test description", @a1.description
   end
 
   def test_eql_eh
-    g1 = util_spec 'gem', 1
-    g2 = util_spec 'gem', 1
+    g1 = util_spec "gem", 1
+    g2 = util_spec "gem", 1
 
     assert_equal g1, g2
     assert_equal g1.hash, g2.hash
@@ -1812,85 +1662,81 @@ dependencies: []
 
   def test_eql_eh_extensions
     spec = @a1.dup
-    spec.extensions = 'xx'
+    spec.extensions = "xx"
 
     refute_operator @a1, :eql?, spec
     refute_operator spec, :eql?, @a1
   end
 
   def test_executables
-    @a1.executable = 'app'
+    @a1.executable = "app"
     assert_equal %w[app], @a1.executables
   end
 
   def test_executable_equals
-    @a2.executable = 'app'
-    assert_equal 'app', @a2.executable
+    @a2.executable = "app"
+    assert_equal "app", @a2.executable
     assert_equal %w[bin/app lib/code.rb].sort, @a2.files
   end
 
   def test_extensions
-    assert_equal ['ext/extconf.rb'], ext_spec.extensions
+    assert_equal ["ext/extconf.rb"], ext_spec.extensions
   end
 
   def test_extension_dir
-    enable_shared, RbConfig::CONFIG['ENABLE_SHARED'] =
-      RbConfig::CONFIG['ENABLE_SHARED'], 'no'
+    enable_shared, RbConfig::CONFIG["ENABLE_SHARED"] =
+      RbConfig::CONFIG["ENABLE_SHARED"], "no"
 
     ext_spec
 
     refute_empty @ext.extensions
 
     expected =
-      File.join(@ext.base_dir, 'extensions', Gem::Platform.local.to_s,
+      File.join(@ext.base_dir, "extensions", Gem::Platform.local.to_s,
                 "#{Gem.ruby_api_version}-static", @ext.full_name)
 
     assert_equal expected, @ext.extension_dir
   ensure
-    RbConfig::CONFIG['ENABLE_SHARED'] = enable_shared
+    RbConfig::CONFIG["ENABLE_SHARED"] = enable_shared
   end
 
   def test_extension_dir_override
-    enable_shared, RbConfig::CONFIG['ENABLE_SHARED'] =
-      RbConfig::CONFIG['ENABLE_SHARED'], 'no'
+    enable_shared, RbConfig::CONFIG["ENABLE_SHARED"] =
+      RbConfig::CONFIG["ENABLE_SHARED"], "no"
 
     class << Gem
-
       alias orig_default_ext_dir_for default_ext_dir_for
 
       remove_method :default_ext_dir_for
 
       def Gem.default_ext_dir_for(base_dir)
-        'elsewhere'
+        "elsewhere"
       end
-
     end
 
     ext_spec
 
     refute_empty @ext.extensions
 
-    expected = File.join @tempdir, 'elsewhere', @ext.full_name
+    expected = File.join @tempdir, "elsewhere", @ext.full_name
 
     assert_equal expected, @ext.extension_dir
   ensure
-    RbConfig::CONFIG['ENABLE_SHARED'] = enable_shared
+    RbConfig::CONFIG["ENABLE_SHARED"] = enable_shared
 
     class << Gem
-
       remove_method :default_ext_dir_for
 
       alias default_ext_dir_for orig_default_ext_dir_for
-
     end
   end
 
   def test_files
-    @a1.files = %w(files bin/common)
-    @a1.test_files = %w(test_files bin/common)
-    @a1.executables = %w(executables common)
-    @a1.extra_rdoc_files = %w(extra_rdoc_files bin/common)
-    @a1.extensions = %w(extensions bin/common)
+    @a1.files = %w[files bin/common]
+    @a1.test_files = %w[test_files bin/common]
+    @a1.executables = %w[executables common]
+    @a1.extra_rdoc_files = %w[extra_rdoc_files bin/common]
+    @a1.extensions = %w[extensions bin/common]
 
     expected = %w[
       bin/common
@@ -1904,11 +1750,11 @@ dependencies: []
   end
 
   def test_files_append
-    @a1.files            = %w(files bin/common)
-    @a1.test_files       = %w(test_files bin/common)
-    @a1.executables      = %w(executables common)
-    @a1.extra_rdoc_files = %w(extra_rdoc_files bin/common)
-    @a1.extensions       = %w(extensions bin/common)
+    @a1.files            = %w[files bin/common]
+    @a1.test_files       = %w[test_files bin/common]
+    @a1.executables      = %w[executables common]
+    @a1.extra_rdoc_files = %w[extra_rdoc_files bin/common]
+    @a1.extensions       = %w[extensions bin/common]
 
     expected = %w[
       bin/common
@@ -1966,9 +1812,9 @@ dependencies: []
   end
 
   def test_for_cache
-    @a2.add_runtime_dependency 'b', '1'
+    @a2.add_runtime_dependency "b", "1"
     @a2.dependencies.first.instance_variable_set :@type, nil
-    @a2.required_rubygems_version = Gem::Requirement.new '> 0'
+    @a2.required_rubygems_version = Gem::Requirement.new "> 0"
     @a2.test_files = %w[test/test_b.rb]
 
     refute_empty @a2.files
@@ -1984,11 +1830,11 @@ dependencies: []
   end
 
   def test_full_gem_path
-    assert_equal File.join(@gemhome, 'gems', @a1.full_name), @a1.full_gem_path
+    assert_equal File.join(@gemhome, "gems", @a1.full_name), @a1.full_gem_path
 
-    @a1.original_platform = 'mswin32'
+    @a1.original_platform = "mswin32"
 
-    assert_equal File.join(@gemhome, 'gems', @a1.original_name),
+    assert_equal File.join(@gemhome, "gems", @a1.original_name),
                  @a1.full_gem_path
   end
 
@@ -2001,40 +1847,40 @@ dependencies: []
   end
 
   def test_full_name
-    assert_equal 'a-1', @a1.full_name
+    assert_equal "a-1", @a1.full_name
 
     @a1 = Gem::Specification.new "a", 1
-    @a1.platform = Gem::Platform.new ['universal', 'darwin', nil]
-    assert_equal 'a-1-universal-darwin', @a1.full_name
+    @a1.platform = Gem::Platform.new ["universal", "darwin", nil]
+    assert_equal "a-1-universal-darwin", @a1.full_name
 
     @a1 = Gem::Specification.new "a", 1
-    @a1.instance_variable_set :@new_platform, 'mswin32'
-    assert_equal 'a-1-mswin32', @a1.full_name, 'legacy'
+    @a1.instance_variable_set :@new_platform, "mswin32"
+    assert_equal "a-1-mswin32", @a1.full_name, "legacy"
 
     return if win_platform?
 
     @a1 = Gem::Specification.new "a", 1
-    @a1.platform = 'current'
-    assert_equal 'a-1-x86-darwin-8', @a1.full_name
+    @a1.platform = "current"
+    assert_equal "a-1-x86-darwin-8", @a1.full_name
   end
 
   def test_full_name_windows
     test_cases = {
-      'i386-mswin32'      => 'a-1-x86-mswin32-60',
-      'i386-mswin32_80'   => 'a-1-x86-mswin32-80',
-      'i386-mingw32'      => 'a-1-x86-mingw32'
+      "i386-mswin32"      => "a-1-x86-mswin32-60",
+      "i386-mswin32_80"   => "a-1-x86-mswin32-80",
+      "i386-mingw32"      => "a-1-x86-mingw32",
     }
 
     test_cases.each do |arch, expected|
       @a1 = Gem::Specification.new "a", 1
       util_set_arch arch
-      @a1.platform = 'current'
+      @a1.platform = "current"
       assert_equal expected, @a1.full_name
     end
   end
 
   def test_gem_build_complete_path
-    expected = File.join @a1.extension_dir, 'gem.build_complete'
+    expected = File.join @a1.extension_dir, "gem.build_complete"
     assert_equal expected, @a1.gem_build_complete_path
   end
 
@@ -2078,23 +1924,23 @@ dependencies: []
   end
 
   def test_license
-    assert_equal 'MIT', @a1.license
+    assert_equal "MIT", @a1.license
   end
 
   def test_licenses
-    assert_equal ['MIT'], @a1.licenses
+    assert_equal ["MIT"], @a1.licenses
   end
 
   def test_name
-    assert_equal 'a', @a1.name
+    assert_equal "a", @a1.name
   end
 
   def test_original_name
-    assert_equal 'a-1', @a1.full_name
+    assert_equal "a-1", @a1.full_name
 
-    @a1.platform = 'i386-linux'
-    @a1.instance_variable_set :@original_platform, 'i386-linux'
-    assert_equal 'a-1-i386-linux', @a1.original_name
+    @a1.platform = "i386-linux"
+    @a1.instance_variable_set :@original_platform, "i386-linux"
+    assert_equal "a-1-i386-linux", @a1.original_name
   end
 
   def test_platform
@@ -2123,10 +1969,10 @@ dependencies: []
     assert_equal Gem::Platform::RUBY, @a1.platform
 
     test_cases = {
-      'i386-mswin32'    => ['x86', 'mswin32', '60'],
-      'i386-mswin32_80' => ['x86', 'mswin32', '80'],
-      'i386-mingw32'    => ['x86', 'mingw32', nil ],
-      'x86-darwin8'     => ['x86', 'darwin',  '8' ],
+      "i386-mswin32"    => ["x86", "mswin32", "60"],
+      "i386-mswin32_80" => ["x86", "mswin32", "80"],
+      "i386-mingw32"    => ["x86", "mingw32", nil ],
+      "x86-darwin8"     => ["x86", "darwin",  "8" ],
     }
 
     test_cases.each do |arch, expected|
@@ -2143,59 +1989,55 @@ dependencies: []
   end
 
   def test_platform_equals_legacy
-    @a1.platform = 'mswin32'
-    assert_equal Gem::Platform.new('x86-mswin32'), @a1.platform
+    @a1.platform = "mswin32"
+    assert_equal Gem::Platform.new("x86-mswin32"), @a1.platform
 
-    @a1.platform = 'i586-linux'
-    assert_equal Gem::Platform.new('x86-linux'), @a1.platform
+    @a1.platform = "i586-linux"
+    assert_equal Gem::Platform.new("x86-linux"), @a1.platform
 
-    @a1.platform = 'powerpc-darwin'
-    assert_equal Gem::Platform.new('ppc-darwin'), @a1.platform
+    @a1.platform = "powerpc-darwin"
+    assert_equal Gem::Platform.new("ppc-darwin"), @a1.platform
   end
 
   def test_prerelease_spec_adds_required_rubygems_version
-    @prerelease = util_spec('tardis', '2.2.0.a')
-    refute @prerelease.required_rubygems_version.satisfied_by?(Gem::Version.new('1.3.1'))
-    assert @prerelease.required_rubygems_version.satisfied_by?(Gem::Version.new('1.4.0'))
+    @prerelease = util_spec("tardis", "2.2.0.a")
+    refute @prerelease.required_rubygems_version.satisfied_by?(Gem::Version.new("1.3.1"))
+    assert @prerelease.required_rubygems_version.satisfied_by?(Gem::Version.new("1.4.0"))
   end
 
   def test_require_paths
-    enable_shared 'no' do
+    enable_shared "no" do
       ext_spec
 
-      @ext.require_paths = 'lib'
+      @ext.require_paths = "lib"
 
-      assert_equal [@ext.extension_dir, 'lib'], @ext.require_paths
+      assert_equal [@ext.extension_dir, "lib"], @ext.require_paths
     end
   end
 
   def test_require_paths_default_ext_dir_for
     class << Gem
-
       send :alias_method, :orig_default_ext_dir_for, :default_ext_dir_for
 
       remove_method :default_ext_dir_for
-
     end
 
     def Gem.default_ext_dir_for(base_dir)
-      '/foo'
+      "/foo"
     end
 
-    enable_shared 'no' do
+    enable_shared "no" do
       ext_spec
 
-      @ext.require_paths = 'lib'
+      @ext.require_paths = "lib"
 
-      assert_equal [File.expand_path('/foo/ext-1'), 'lib'], @ext.require_paths
+      assert_equal [File.expand_path("/foo/ext-1"), "lib"], @ext.require_paths
     end
   ensure
     class << Gem
-
       send :remove_method, :default_ext_dir_for
       send :alias_method,  :default_ext_dir_for, :orig_default_ext_dir_for
       send :remove_method, :orig_default_ext_dir_for
-
     end
   end
 
@@ -2207,7 +2049,7 @@ dependencies: []
     ext_spec
 
     @ext.require_paths = %w[lib ext foo]
-    @ext.extensions << 'bar/baz'
+    @ext.extensions << "bar/baz"
 
     expected = %w[
       lib
@@ -2222,10 +2064,10 @@ dependencies: []
   def test_full_require_paths
     ext_spec
 
-    @ext.require_paths = 'lib'
+    @ext.require_paths = "lib"
 
     expected = [
-      File.join(@gemhome, 'gems', @ext.original_name, 'lib'),
+      File.join(@gemhome, "gems", @ext.original_name, "lib"),
       @ext.extension_dir,
     ]
 
@@ -2235,10 +2077,10 @@ dependencies: []
   def test_to_fullpath
     ext_spec
 
-    @ext.require_paths = 'lib'
+    @ext.require_paths = "lib"
 
-    dir = File.join(@gemhome, 'gems', @ext.original_name, 'lib')
-    expected_rb = File.join(dir, 'code.rb')
+    dir = File.join(@gemhome, "gems", @ext.original_name, "lib")
+    expected_rb = File.join(dir, "code.rb")
     FileUtils.mkdir_p dir
     FileUtils.touch expected_rb
 
@@ -2272,10 +2114,10 @@ dependencies: []
   def test_fullpath_return_rb_extension_file_when_exist_the_same_name_file
     ext_spec
 
-    @ext.require_paths = 'lib'
+    @ext.require_paths = "lib"
 
-    dir = File.join(@gemhome, 'gems', @ext.original_name, 'lib')
-    expected_rb = File.join(dir, 'code.rb')
+    dir = File.join(@gemhome, "gems", @ext.original_name, "lib")
+    expected_rb = File.join(dir, "code.rb")
     FileUtils.mkdir_p dir
     FileUtils.touch expected_rb
 
@@ -2291,52 +2133,48 @@ dependencies: []
   end
 
   def test_require_already_activated
-    save_loaded_features do
-      a1 = util_spec "a", "1", nil, "lib/d#{$$}.rb"
+    a1 = util_spec "a", "1", nil, "lib/d#{$$}.rb"
 
-      install_specs a1 # , a2, b1, b2, c1, c2
+    install_specs a1 # , a2, b1, b2, c1, c2
 
-      a1.activate
-      assert_equal %w(a-1), loaded_spec_names
-      assert_equal [], unresolved_names
+    a1.activate
+    assert_equal %w[a-1], loaded_spec_names
+    assert_equal [], unresolved_names
 
-      assert require "d#{$$}"
+    assert require "d#{$$}"
 
-      assert_equal %w(a-1), loaded_spec_names
-      assert_equal [], unresolved_names
-    end
+    assert_equal %w[a-1], loaded_spec_names
+    assert_equal [], unresolved_names
   end
 
   def test_require_already_activated_indirect_conflict
-    save_loaded_features do
-      a1 = util_spec "a", "1", "b" => "> 0"
-      a2 = util_spec "a", "2", "b" => "> 0"
-      b1 = util_spec "b", "1", "c" => ">= 1"
-      b2 = util_spec "b", "2", "c" => ">= 2"
-      c1 = util_spec "c", "1", nil, "lib/d#{$$}.rb"
-      c2 = util_spec("c", "2", { "a" => "1" }, "lib/d#{$$}.rb") # conflicts with a-2
-
-      install_specs c1, b1, a1, a2, c2, b2
-
-      a1.activate
-      c1.activate
-      assert_equal %w(a-1 c-1), loaded_spec_names
-      assert_equal ["b (> 0)"], unresolved_names
+    a1 = util_spec "a", "1", "b" => "> 0"
+    a2 = util_spec "a", "2", "b" => "> 0"
+    b1 = util_spec "b", "1", "c" => ">= 1"
+    b2 = util_spec "b", "2", "c" => ">= 2"
+    c1 = util_spec "c", "1", nil, "lib/d#{$$}.rb"
+    c2 = util_spec("c", "2", { "a" => "1" }, "lib/d#{$$}.rb") # conflicts with a-2
 
-      assert require "d#{$$}"
+    install_specs c1, b1, a1, a2, c2, b2
 
-      assert_equal %w(a-1 c-1), loaded_spec_names
-      assert_equal ["b (> 0)"], unresolved_names
-    end
+    a1.activate
+    c1.activate
+    assert_equal %w[a-1 c-1], loaded_spec_names
+    assert_equal ["b (> 0)"], unresolved_names
+
+    assert require "d#{$$}"
+
+    assert_equal %w[a-1 c-1], loaded_spec_names
+    assert_equal ["b (> 0)"], unresolved_names
   end
 
   def test_requirements
-    assert_equal ['A working computer'], @a1.requirements
+    assert_equal ["A working computer"], @a1.requirements
   end
 
   def test_allowed_push_host
-    assert_nil                                   @a1.metadata['allowed_push_host']
-    assert_equal 'https://privategemserver.com', @a3.metadata['allowed_push_host']
+    assert_nil                                   @a1.metadata["allowed_push_host"]
+    assert_equal "https://privategemserver.com", @a3.metadata["allowed_push_host"]
   end
 
   def test_runtime_dependencies_legacy
@@ -2348,12 +2186,12 @@ dependencies: []
 
     expected = %w[rake jabber4r pqa]
 
-    assert_equal expected, @c1.runtime_dependencies.map { |d| d.name }
+    assert_equal expected, @c1.runtime_dependencies.map {|d| d.name }
   end
 
   def test_spaceship_name
-    s1 = util_spec 'a', '1'
-    s2 = util_spec 'b', '1'
+    s1 = util_spec "a", "1"
+    s2 = util_spec "b", "1"
 
     assert_equal(-1, (s1 <=> s2))
     assert_equal(0, (s1 <=> s1))
@@ -2361,9 +2199,9 @@ dependencies: []
   end
 
   def test_spaceship_platform
-    s1 = util_spec 'a', '1'
-    s2 = util_spec 'a', '1' do |s|
-      s.platform = Gem::Platform.new 'x86-my_platform1'
+    s1 = util_spec "a", "1"
+    s2 = util_spec "a", "1" do |s|
+      s.platform = Gem::Platform.new "x86-my_platform1"
     end
 
     assert_equal(-1, (s1 <=> s2))
@@ -2372,8 +2210,8 @@ dependencies: []
   end
 
   def test_spaceship_version
-    s1 = util_spec 'a', '1'
-    s2 = util_spec 'a', '2'
+    s1 = util_spec "a", "1"
+    s2 = util_spec "a", "2"
 
     assert_equal(-1, (s1 <=> s2))
     assert_equal(0, (s1 <=> s1))
@@ -2381,25 +2219,25 @@ dependencies: []
   end
 
   def test_spec_file
-    assert_equal File.join(@gemhome, 'specifications', 'a-1.gemspec'),
+    assert_equal File.join(@gemhome, "specifications", "a-1.gemspec"),
                  @a1.spec_file
   end
 
   def test_spec_name
-    assert_equal 'a-1.gemspec', @a1.spec_name
+    assert_equal "a-1.gemspec", @a1.spec_name
   end
 
   def test_summary
-    assert_equal 'this is a summary', @a1.summary
+    assert_equal "this is a summary", @a1.summary
   end
 
   def test_test_files
-    @a1.test_file = 'test/suite.rb'
-    assert_equal ['test/suite.rb'], @a1.test_files
+    @a1.test_file = "test/suite.rb"
+    assert_equal ["test/suite.rb"], @a1.test_files
   end
 
   def test_runtime_predicate_true
-    @a2.add_runtime_dependency 'b', '1'
+    @a2.add_runtime_dependency "b", "1"
     assert_predicate @a2.dependencies.first, :runtime?
 
     @a2.dependencies.first.instance_variable_set :@type, nil
@@ -2407,15 +2245,15 @@ dependencies: []
   end
 
   def test_runtime_predicate_false
-    @a2.add_development_dependency 'b', '1'
+    @a2.add_development_dependency "b", "1"
     refute_predicate @a2.dependencies.first, :runtime?
   end
 
   def test_to_ruby
-    @a2.add_runtime_dependency 'b', '1'
+    @a2.add_runtime_dependency "b", "1"
     @a2.dependencies.first.instance_variable_set :@type, nil
-    @a2.required_rubygems_version = Gem::Requirement.new '> 0'
-    @a2.require_paths << 'other'
+    @a2.required_rubygems_version = Gem::Requirement.new "> 0"
+    @a2.require_paths << "other"
 
     ruby_code = @a2.to_ruby
 
@@ -2458,6 +2296,9 @@ end
   end
 
   def test_to_ruby_with_rsa_key
+    require "rubygems/openssl"
+    pend "openssl is missing" unless defined?(OpenSSL::PKey::RSA)
+
     rsa_key = OpenSSL::PKey::RSA.new(2048)
     @a2.signing_key = rsa_key
     ruby_code = @a2.to_ruby
@@ -2487,9 +2328,9 @@ end
   end
 
   def test_to_ruby_for_cache
-    @a2.add_runtime_dependency 'b', '1'
+    @a2.add_runtime_dependency "b", "1"
     @a2.dependencies.first.instance_variable_set :@type, nil
-    @a2.required_rubygems_version = Gem::Requirement.new '> 0'
+    @a2.required_rubygems_version = Gem::Requirement.new "> 0"
     @a2.installed_by_version = Gem.rubygems_version
 
     # cached specs do not have spec.files populated:
@@ -2598,8 +2439,8 @@ end
   end
 
   def test_to_ruby_keeps_requirements_as_originally_specified
-    spec = util_spec 'a', '1' do |s|
-      s.add_dependency 'b', ['~> 1.0', '>= 1.0.0']
+    spec = util_spec "a", "1" do |s|
+      s.add_dependency "b", ["~> 1.0", ">= 1.0.0"]
     end
 
     assert_includes spec.to_ruby, '"~> 1.0", ">= 1.0.0"'
@@ -2628,19 +2469,19 @@ end
 
   def test_to_ruby_platform
     @a2.platform = Gem::Platform.local
-    @a2.instance_variable_set :@original_platform, 'old_platform'
+    @a2.instance_variable_set :@original_platform, "old_platform"
 
     ruby_code = @a2.to_ruby
 
     same_spec = eval ruby_code
 
-    assert_equal 'old_platform', same_spec.original_platform
+    assert_equal "old_platform", same_spec.original_platform
   end
 
   def test_to_yaml
     yaml_str = @a1.to_yaml
 
-    refute_match '!!null', yaml_str
+    refute_match %r{!!null}, yaml_str
 
     same_spec = Gem::Specification.from_yaml(yaml_str)
 
@@ -2659,27 +2500,27 @@ end
   end
 
   def test_to_yaml_platform_empty_string
-    @a1.instance_variable_set :@original_platform, ''
+    @a1.instance_variable_set :@original_platform, ""
 
-    assert_match %r|^platform: ruby$|, @a1.to_yaml
+    assert_match %r{^platform: ruby$}, @a1.to_yaml
   end
 
   def test_to_yaml_platform_legacy
-    @a1.platform = 'powerpc-darwin7.9.0'
-    @a1.instance_variable_set :@original_platform, 'powerpc-darwin7.9.0'
+    @a1.platform = "powerpc-darwin7.9.0"
+    @a1.instance_variable_set :@original_platform, "powerpc-darwin7.9.0"
 
     yaml_str = @a1.to_yaml
 
-    same_spec = YAML.load yaml_str
+    same_spec = load_yaml yaml_str
 
-    assert_equal Gem::Platform.new('powerpc-darwin7'), same_spec.platform
-    assert_equal 'powerpc-darwin7.9.0', same_spec.original_platform
+    assert_equal Gem::Platform.new("powerpc-darwin7"), same_spec.platform
+    assert_equal "powerpc-darwin7.9.0", same_spec.original_platform
   end
 
   def test_to_yaml_platform_nil
     @a1.instance_variable_set :@original_platform, nil
 
-    assert_match %r|^platform: ruby$|, @a1.to_yaml
+    assert_match %r{^platform: ruby$}, @a1.to_yaml
   end
 
   def test_validate
@@ -2690,7 +2531,7 @@ end
     end
   end
 
-  def x(s); s.gsub(/xxx/, ''); end
+  def x(s); s.gsub(/xxx/, ""); end
   def w; x "WARxxxNING"; end
   def t; x "TOxxxDO"; end
   def f; x "FxxxIXME"; end
@@ -2705,13 +2546,13 @@ end
         @a1.validate
       end
 
-      assert_match "#{w}:  no author specified\n", @ui.error, 'error'
+      assert_match "#{w}:  no author specified\n", @ui.error, "error"
 
       @a1.authors = [Object.new]
 
       assert_equal [], @a1.authors
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
@@ -2719,19 +2560,19 @@ end
 
       @a1.authors = ["#{f} (who is writing this software)"]
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
-      assert_equal %{"#{f}" or "#{t}" is not an author}, e.message
+      assert_equal %("#{f}" or "#{t}" is not an author), e.message
 
       @a1.authors = ["#{t} (who is writing this software)"]
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
-      assert_equal %{"#{f}" or "#{t}" is not an author}, e.message
+      assert_equal %("#{f}" or "#{t}" is not an author), e.message
     end
   end
 
@@ -2739,14 +2580,14 @@ end
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @a1.autorequire = 'code'
+      @a1.autorequire = "code"
 
       use_ui @ui do
         @a1.validate
       end
 
       assert_match "#{w}:  deprecated autorequire specified\n",
-                   @ui.error, 'error'
+                   @ui.error, "error"
     end
   end
 
@@ -2754,19 +2595,19 @@ end
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @a1.add_runtime_dependency     'b', '>= 1.0.rc1'
-      @a1.add_development_dependency 'c', '>= 2.0.rc2'
-      @a1.add_runtime_dependency     'd', '~> 1.2.3'
-      @a1.add_runtime_dependency     'e', '~> 1.2.3.4'
-      @a1.add_runtime_dependency     'g', '~> 1.2.3', '>= 1.2.3.4'
-      @a1.add_runtime_dependency     'h', '>= 1.2.3', '<= 2'
-      @a1.add_runtime_dependency     'i', '>= 1.2'
-      @a1.add_runtime_dependency     'j', '>= 1.2.3'
-      @a1.add_runtime_dependency     'k', '> 1.2'
-      @a1.add_runtime_dependency     'l', '> 1.2.3'
-      @a1.add_runtime_dependency     'm', '~> 2.1.0'
-      @a1.add_runtime_dependency     'n', '~> 0.1.0'
-      @a1.add_runtime_dependency     'o'
+      @a1.add_runtime_dependency     "b", ">= 1.0.rc1"
+      @a1.add_development_dependency "c", ">= 2.0.rc2"
+      @a1.add_runtime_dependency     "d", "~> 1.2.3"
+      @a1.add_runtime_dependency     "e", "~> 1.2.3.4"
+      @a1.add_runtime_dependency     "g", "~> 1.2.3", ">= 1.2.3.4"
+      @a1.add_runtime_dependency     "h", ">= 1.2.3", "<= 2"
+      @a1.add_runtime_dependency     "i", ">= 1.2"
+      @a1.add_runtime_dependency     "j", ">= 1.2.3"
+      @a1.add_runtime_dependency     "k", "> 1.2"
+      @a1.add_runtime_dependency     "l", "> 1.2.3"
+      @a1.add_runtime_dependency     "m", "~> 2.1.0"
+      @a1.add_runtime_dependency     "n", "~> 0.1.0"
+      @a1.add_runtime_dependency     "o"
 
       use_ui @ui do
         @a1.validate
@@ -2792,7 +2633,7 @@ end
 #{w}:  See https://guides.rubygems.org/specification-reference/ for help
       EXPECTED
 
-      assert_equal expected, @ui.error, 'warning'
+      assert_equal expected, @ui.error, "warning"
     end
   end
 
@@ -2800,13 +2641,13 @@ end
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @a1.add_runtime_dependency 'b', '~> 1.2'
-      @a1.add_runtime_dependency 'b', '>= 1.2.3'
-      @a1.add_development_dependency 'c', '~> 1.2'
-      @a1.add_development_dependency 'c', '>= 1.2.3'
+      @a1.add_runtime_dependency "b", "~> 1.2"
+      @a1.add_runtime_dependency "b", ">= 1.2.3"
+      @a1.add_development_dependency "c", "~> 1.2"
+      @a1.add_development_dependency "c", ">= 1.2.3"
 
       use_ui @ui do
-        e = assert_raises Gem::InvalidSpecificationException do
+        e = assert_raise Gem::InvalidSpecificationException do
           @a1.validate
         end
 
@@ -2830,14 +2671,14 @@ duplicate dependency on c (>= 1.2.3, dev
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @a1.add_runtime_dependency 'b', '~> 1.2'
-      @a1.add_development_dependency 'b', '= 1.2.3'
+      @a1.add_runtime_dependency "b", "~> 1.2"
+      @a1.add_development_dependency "b", "= 1.2.3"
 
       use_ui @ui do
         @a1.validate
       end
 
-      assert_equal '', @ui.error, 'warning'
+      assert_equal "", @ui.error, "warning"
     end
   end
 
@@ -2845,14 +2686,45 @@ duplicate dependency on c (>= 1.2.3, dev
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @a1.version = '1.0.0.beta.1'
-      @a1.add_runtime_dependency 'b', '~> 1.2.0.beta.1'
+      @a1.version = "1.0.0.beta.1"
+      @a1.add_runtime_dependency "b", "~> 1.2.0.beta.1"
 
       use_ui @ui do
         @a1.validate
       end
 
-      assert_equal '', @ui.error, 'warning'
+      assert_equal "", @ui.error, "warning"
+    end
+  end
+
+  def test_validate_rake_extension_have_rake_dependency_warning
+    util_setup_validate
+
+    Dir.chdir @tempdir do
+      @a1.extensions = ["Rakefile"]
+      File.write File.join(@tempdir, "Rakefile"), ""
+
+      use_ui @ui do
+        @a1.validate
+      end
+
+      assert_match(/add rake as a dependency/, @ui.error)
+    end
+  end
+
+  def test_validate_rake_extension_have_rake_dependency_no_warning
+    util_setup_validate
+
+    Dir.chdir @tempdir do
+      @a1.extensions = ["Rakefile"]
+      @a1.add_runtime_dependency "rake"
+      File.write File.join(@tempdir, "Rakefile"), ""
+
+      use_ui @ui do
+        @a1.validate
+      end
+
+      refute_match(/add rake as a dependency/, @ui.error)
     end
   end
 
@@ -2860,7 +2732,7 @@ duplicate dependency on c (>= 1.2.3, dev
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @a1.description = ''
+      @a1.description = ""
 
       use_ui @ui do
         @a1.validate
@@ -2879,19 +2751,47 @@ duplicate dependency on c (>= 1.2.3, dev
 
       @a1.description = "#{f} (describe your package)"
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
-      assert_equal %{"#{f}" or "#{t}" is not a description}, e.message
+      assert_equal %("#{f}" or "#{t}" is not a description), e.message
 
       @a1.description = "#{t} (describe your package)"
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
-      assert_equal %{"#{f}" or "#{t}" is not a description}, e.message
+      assert_equal %("#{f}" or "#{t}" is not a description), e.message
+
+      # Adding #{f} anywhere after the start of the description should be fine.
+      @a1.description = "(some description) #{f}"
+
+      assert_nothing_raised do
+        @a1.validate
+      end
+
+      # Adding #{t} anywhere after the start of the description should be fine.
+      @a1.description = "(some description) #{t}"
+
+      assert_nothing_raised do
+        @a1.validate
+      end
+
+      # Adding #{f} at the start of the second or later line should be fine.
+      @a1.description = "(some description)\n#{f}"
+
+      assert_nothing_raised do
+        @a1.validate
+      end
+
+      # Adding #{t} at the start of the second or later line should be fine.
+      @a1.description = "(some description)\n#{t}"
+
+      assert_nothing_raised do
+        @a1.validate
+      end
     end
   end
 
@@ -2901,46 +2801,46 @@ duplicate dependency on c (>= 1.2.3, dev
     Dir.chdir @tempdir do
       @a1.email = "FIxxxXME (your e-mail)".sub(/xxx/, "")
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
-      assert_equal %{"#{f}" or "#{t}" is not an email}, e.message
+      assert_equal %("#{f}" or "#{t}" is not an email), e.message
 
       @a1.email = "#{t} (your e-mail)"
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
-      assert_equal %{"#{f}" or "#{t}" is not an email}, e.message
+      assert_equal %("#{f}" or "#{t}" is not an email), e.message
     end
   end
 
   def test_validate_empty
-    e = assert_raises Gem::InvalidSpecificationException do
+    e = assert_raise Gem::InvalidSpecificationException do
       Gem::Specification.new.validate
     end
 
-    assert_equal 'missing value for attribute name', e.message
+    assert_equal "missing value for attribute name", e.message
   end
 
   def test_validate_error
-    assert_raises Gem::InvalidSpecificationException do
+    assert_raise Gem::InvalidSpecificationException do
       use_ui @ui do
         Gem::Specification.new.validate
       end
     end
 
-    assert_match 'See https://guides.rubygems.org/specification-reference/ for help', @ui.error
+    assert_match "See https://guides.rubygems.org/specification-reference/ for help", @ui.error
   end
 
   def test_validate_executables
     util_setup_validate
 
-    FileUtils.mkdir_p File.join(@tempdir, 'bin')
-    File.write File.join(@tempdir, 'bin', 'exec'), ''
-    FileUtils.mkdir_p File.join(@tempdir, 'exec')
+    FileUtils.mkdir_p File.join(@tempdir, "bin")
+    File.write File.join(@tempdir, "bin", "exec"), ""
+    FileUtils.mkdir_p File.join(@tempdir, "exec")
 
     use_ui @ui do
       Dir.chdir @tempdir do
@@ -2950,41 +2850,41 @@ duplicate dependency on c (>= 1.2.3, dev
 
     assert_equal %w[exec], @a1.executables
 
-    assert_equal '', @ui.output, 'output'
-    assert_match "#{w}:  bin/exec is missing #! line\n", @ui.error, 'error'
+    assert_equal "", @ui.output, "output"
+    assert_match "#{w}:  bin/exec is missing #! line\n", @ui.error, "error"
   end
 
   def test_validate_empty_require_paths
     if win_platform?
-      skip 'test_validate_empty_require_paths skipped on MS Windows (symlink)'
+      pend "test_validate_empty_require_paths skipped on MS Windows (symlink)"
     else
       util_setup_validate
 
       @a1.require_paths = []
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
-      assert_equal 'specification must have at least one require_path',
+      assert_equal "specification must have at least one require_path",
                    e.message
     end
   end
 
   def test_validate_files
-    skip 'test_validate_files skipped on MS Windows (symlink)' if win_platform?
+    pend "test_validate_files skipped on MS Windows (symlink)" if win_platform?
     util_setup_validate
 
-    @a1.files += ['lib', 'lib2']
-    @a1.extensions << 'ext/a/extconf.rb'
+    @a1.files += ["lib", "lib2"]
+    @a1.extensions << "ext/a/extconf.rb"
 
     Dir.chdir @tempdir do
-      FileUtils.ln_s 'lib/code.rb', 'lib2' unless vc_windows?
+      FileUtils.ln_s "lib/code.rb", "lib2" unless vc_windows?
 
       use_ui @ui do
         @a1.validate
       end
 
-      assert_match 'WARNING:  lib2 is a symlink, which is not supported on all platforms', @ui.error
+      assert_match "WARNING:  lib2 is a symlink, which is not supported on all platforms", @ui.error
     end
 
     assert_equal %w[bin/exec ext/a/extconf.rb lib/code.rb lib2 test/suite.rb].sort,
@@ -3011,9 +2911,11 @@ WARN: Clearing out unresolved specs. Try
 Please report a bug if this causes problems.
     EXPECTED
 
-    assert_output nil, expected do
+    actual_stdout, actual_stderr = capture_output do
       specification.reset
     end
+    assert_empty actual_stdout
+    assert_equal(expected, actual_stderr)
   end
 
   def test_unresolved_specs_with_versions
@@ -3027,8 +2929,8 @@ Please report a bug if this causes probl
 
     specification.define_singleton_method(:find_all_by_name) do |dep_name|
       [
-        specification.new { |s| s.name = "z", s.version = Gem::Version.new("1") },
-        specification.new { |s| s.name = "z", s.version = Gem::Version.new("2") }
+        specification.new {|s| s.name = "z", s.version = Gem::Version.new("1") },
+        specification.new {|s| s.name = "z", s.version = Gem::Version.new("2") },
       ]
     end
 
@@ -3042,9 +2944,20 @@ WARN: Clearing out unresolved specs. Try
 Please report a bug if this causes problems.
     EXPECTED
 
-    assert_output nil, expected do
+    actual_stdout, actual_stderr = capture_output do
       specification.reset
     end
+    assert_empty actual_stdout
+    assert_equal(expected, actual_stderr)
+  end
+
+  def test_duplicate_runtime_dependency
+    expected = "WARNING: duplicated b dependency [\"~> 3.0\", \"~> 3.0\"]\n"
+    out, err = capture_output do
+      @a1.add_runtime_dependency "b", "~> 3.0", "~> 3.0"
+    end
+    assert_empty out
+    assert_equal(expected, err)
   end
 
   def set_orig(cls)
@@ -3059,7 +2972,7 @@ Please report a bug if this causes probl
 
     @a1.files = [@a1.file_name]
 
-    e = assert_raises Gem::InvalidSpecificationException do
+    e = assert_raise Gem::InvalidSpecificationException do
       @a1.validate
     end
 
@@ -3077,40 +2990,39 @@ Please report a bug if this causes probl
         @a1.validate
       end
 
-      assert_match "#{w}:  no homepage specified\n", @ui.error, 'error'
+      assert_match "#{w}:  no homepage specified\n", @ui.error, "error"
 
       @ui = Gem::MockGemUi.new
 
-      @a1.homepage = ''
+      @a1.homepage = ""
 
       use_ui @ui do
         @a1.validate
       end
 
-      assert_match "#{w}:  no homepage specified\n", @ui.error, 'error'
+      assert_match "#{w}:  no homepage specified\n", @ui.error, "error"
 
-      @a1.homepage = 'over at my cool site'
+      @a1.homepage = "over at my cool site"
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
       assert_equal '"over at my cool site" is not a valid HTTP URI', e.message
 
-      @a1.homepage = 'ftp://rubygems.org'
+      @a1.homepage = "ftp://rubygems.org"
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
       assert_equal '"ftp://rubygems.org" is not a valid HTTP URI', e.message
 
-      @a1.homepage = 'https://rubygems.org/'
+      @a1.homepage = "https://rubygems.org/"
       assert_equal true, @a1.validate
 
-      @a1.homepage = 'https://rubygems.org'
+      @a1.homepage = "https://rubygems.org"
       assert_equal true, @a1.validate
-
     end
   end
 
@@ -3122,10 +3034,21 @@ Please report a bug if this causes probl
       @a1.validate
     end
 
-    assert_match <<-warning, @ui.error
+    assert_match <<-WARNING, @ui.error
 WARNING:  licenses is empty, but is recommended.  Use a license identifier from
 http://spdx.org/licenses or 'Nonstandard' for a nonstandard license.
-    warning
+    WARNING
+  end
+
+  def test_validate_license_in_a_non_packaging_context
+    util_setup_validate
+
+    use_ui @ui do
+      @a1.licenses.clear
+      @a1.validate(false)
+    end
+
+    assert_empty @ui.error
   end
 
   def test_removed_methods
@@ -3136,7 +3059,7 @@ http://spdx.org/licenses or 'Nonstandard
     util_setup_validate
 
     use_ui @ui do
-      @a1.rubyforge_project = 'invalid-attribute'
+      @a1.rubyforge_project = "invalid-attribute"
       @a1.validate
     end
 
@@ -3147,21 +3070,32 @@ http://spdx.org/licenses or 'Nonstandard
     util_setup_validate
 
     use_ui @ui do
-      @a1.licenses = ['BSD']
+      @a1.licenses = ["BSD"]
       @a1.validate
     end
 
-    assert_match <<-warning, @ui.error
+    assert_match <<-WARNING, @ui.error
 WARNING:  license value 'BSD' is invalid.  Use a license identifier from
 http://spdx.org/licenses or 'Nonstandard' for a nonstandard license.
-    warning
+    WARNING
+  end
+
+  def test_validate_license_ref
+    util_setup_validate
+
+    use_ui @ui do
+      @a1.licenses = ["LicenseRef-LICENSE.md"]
+      @a1.validate
+    end
+
+    assert_empty @ui.error
   end
 
   def test_validate_license_values_plus
     util_setup_validate
 
     use_ui @ui do
-      @a1.licenses = ['GPL-2.0+']
+      @a1.licenses = ["GPL-2.0+"]
       @a1.validate
     end
 
@@ -3172,7 +3106,7 @@ http://spdx.org/licenses or 'Nonstandard
     util_setup_validate
 
     use_ui @ui do
-      @a1.licenses = ['GPL-2.0-or-later']
+      @a1.licenses = ["GPL-2.0-or-later"]
       @a1.validate
     end
 
@@ -3183,7 +3117,7 @@ http://spdx.org/licenses or 'Nonstandard
     util_setup_validate
 
     use_ui @ui do
-      @a1.licenses = ['GPL-2.0+ WITH Autoconf-exception-2.0']
+      @a1.licenses = ["GPL-2.0+ WITH Autoconf-exception-2.0"]
       @a1.validate
     end
 
@@ -3194,47 +3128,47 @@ http://spdx.org/licenses or 'Nonstandard
     util_setup_validate
 
     use_ui @ui do
-      @a1.licenses = ['GPL-2.0+ FOO', 'GPL-2.0 FOO']
+      @a1.licenses = ["GPL-2.0+ FOO", "GPL-2.0 FOO"]
       @a1.validate
     end
 
-    assert_match <<-warning, @ui.error
+    assert_match <<-WARNING, @ui.error
 WARNING:  license value 'GPL-2.0+ FOO' is invalid.  Use a license identifier from
 http://spdx.org/licenses or 'Nonstandard' for a nonstandard license.
-    warning
-    assert_match <<-warning, @ui.error
+    WARNING
+    assert_match <<-WARNING, @ui.error
 WARNING:  license value 'GPL-2.0 FOO' is invalid.  Use a license identifier from
 http://spdx.org/licenses or 'Nonstandard' for a nonstandard license.
-    warning
+    WARNING
   end
 
   def test_validate_license_with_invalid_exception
     util_setup_validate
 
     use_ui @ui do
-      @a1.licenses = ['GPL-2.0+ WITH Autocofn-exception-2.0']
+      @a1.licenses = ["GPL-2.0+ WITH Autocofn-exception-2.0"]
       @a1.validate
     end
 
-    assert_match <<-warning, @ui.error
+    assert_match <<-WARNING, @ui.error
 WARNING:  license value 'GPL-2.0+ WITH Autocofn-exception-2.0' is invalid.  Use a license identifier from
 http://spdx.org/licenses or 'Nonstandard' for a nonstandard license.
-    warning
+    WARNING
   end
 
   def test_validate_license_gives_suggestions
     util_setup_validate
 
     use_ui @ui do
-      @a1.licenses = ['ruby']
+      @a1.licenses = ["ruby"]
       @a1.validate
     end
 
-    assert_match <<-warning, @ui.error
+    assert_match <<-WARNING, @ui.error
 WARNING:  license value 'ruby' is invalid.  Use a license identifier from
 http://spdx.org/licenses or 'Nonstandard' for a nonstandard license.
 Did you mean 'Ruby'?
-    warning
+    WARNING
   end
 
   def test_validate_empty_files
@@ -3277,7 +3211,7 @@ Did you mean 'Ruby'?
   def test_validate_name
     util_setup_validate
 
-    e = assert_raises Gem::InvalidSpecificationException do
+    e = assert_raise Gem::InvalidSpecificationException do
       @a1.name = :json
       @a1.validate
     end
@@ -3285,31 +3219,31 @@ Did you mean 'Ruby'?
     assert_equal 'invalid value for attribute name: ":json" must be a string', e.message
 
     @a1.name = []
-    e = assert_raises Gem::InvalidSpecificationException do
+    e = assert_raise Gem::InvalidSpecificationException do
       @a1.validate
     end
     assert_equal "invalid value for attribute name: \"[]\" must be a string", e.message
 
     @a1.name = ""
-    e = assert_raises Gem::InvalidSpecificationException do
+    e = assert_raise Gem::InvalidSpecificationException do
       @a1.validate
     end
     assert_equal "invalid value for attribute name: \"\" must include at least one letter", e.message
 
     @a1.name = "12345"
-    e = assert_raises Gem::InvalidSpecificationException do
+    e = assert_raise Gem::InvalidSpecificationException do
       @a1.validate
     end
     assert_equal "invalid value for attribute name: \"12345\" must include at least one letter", e.message
 
     @a1.name = "../malicious"
-    e = assert_raises Gem::InvalidSpecificationException do
+    e = assert_raise Gem::InvalidSpecificationException do
       @a1.validate
     end
     assert_equal "invalid value for attribute name: \"../malicious\" can only include letters, numbers, dashes, and underscores", e.message
 
     @a1.name = "\ba\t"
-    e = assert_raises Gem::InvalidSpecificationException do
+    e = assert_raise Gem::InvalidSpecificationException do
       @a1.validate
     end
     assert_equal "invalid value for attribute name: \"\\ba\\t\" can only include letters, numbers, dashes, and underscores", e.message
@@ -3326,23 +3260,23 @@ Did you mean 'Ruby'?
         spec = @a1.dup
         spec.instance_variable_set "@#{name}", nil
 
-        e = assert_raises Gem::InvalidSpecificationException do
+        e = assert_raise Gem::InvalidSpecificationException do
           spec.validate
         end
 
-        assert_match %r%^#{name}%, e.message
+        assert_match %r{^#{name}}, e.message
       end
     end
   end
 
   def test_validate_permissions
-    skip 'chmod not supported' if Gem.win_platform?
+    pend "chmod not supported" if Gem.win_platform?
 
     util_setup_validate
 
     Dir.chdir @tempdir do
-      File.chmod 0640, File.join('lib', 'code.rb')
-      File.chmod 0640, File.join('bin', 'exec')
+      File.chmod 0640, File.join("lib", "code.rb")
+      File.chmod 0640, File.join("bin", "exec")
 
       use_ui @ui do
         @a1.validate
@@ -3355,12 +3289,12 @@ Did you mean 'Ruby'?
   end
 
   def test_validate_permissions_of_missing_file_non_packaging
-    skip 'chmod not supported' if Gem.win_platform?
+    pend "chmod not supported" if Gem.win_platform?
 
     util_setup_validate
 
     Dir.chdir @tempdir do
-      File.delete File.join('lib', 'code.rb')
+      File.delete File.join("lib", "code.rb")
 
       use_ui @ui do
         assert @a1.validate(false)
@@ -3372,13 +3306,13 @@ Did you mean 'Ruby'?
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @a1.platform = 'mswin32'
+      @a1.platform = "mswin32"
       assert @a1.validate
 
-      @a1.platform = 'i586-linux'
+      @a1.platform = "i586-linux"
       assert @a1.validate
 
-      @a1.platform = 'powerpc-darwin'
+      @a1.platform = "powerpc-darwin"
       assert @a1.validate
     end
   end
@@ -3387,7 +3321,7 @@ Did you mean 'Ruby'?
     util_setup_validate
 
     @a1.rubygems_version = "3"
-    e = assert_raises Gem::InvalidSpecificationException do
+    e = assert_raise Gem::InvalidSpecificationException do
       @a1.validate
     end
 
@@ -3399,15 +3333,15 @@ Did you mean 'Ruby'?
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @a1.specification_version = '1.0'
+      @a1.specification_version = "1.0"
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         use_ui @ui do
           @a1.validate
         end
       end
 
-      err = 'specification_version must be an Integer (did you mean version?)'
+      err = "specification_version must be an Integer (did you mean version?)"
       assert_equal err, e.message
     end
   end
@@ -3416,29 +3350,29 @@ Did you mean 'Ruby'?
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @a1.summary = ''
+      @a1.summary = ""
 
       use_ui @ui do
         @a1.validate
       end
 
-      assert_match "#{w}:  no summary specified\n", @ui.error, 'error'
+      assert_match "#{w}:  no summary specified\n", @ui.error, "error"
 
       @a1.summary = "#{f} (describe your package)"
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
-      assert_equal %{"#{f}" or "#{t}" is not a summary}, e.message
+      assert_equal %("#{f}" or "#{t}" is not a summary), e.message
 
       @a1.summary = "#{t} (describe your package)"
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @a1.validate
       end
 
-      assert_equal %{"#{f}" or "#{t}" is not a summary}, e.message
+      assert_equal %("#{f}" or "#{t}" is not a summary), e.message
     end
   end
 
@@ -3450,11 +3384,11 @@ Did you mean 'Ruby'?
       @a1.validate
     end
 
-    assert_match 'See https://guides.rubygems.org/specification-reference/ for help', @ui.error
+    assert_match "See https://guides.rubygems.org/specification-reference/ for help", @ui.error
   end
 
   def test_version
-    assert_equal Gem::Version.new('1'), @a1.version
+    assert_equal Gem::Version.new("1"), @a1.version
   end
 
   def test_version_change_reset_full_name
@@ -3487,7 +3421,7 @@ Did you mean 'Ruby'?
     specfile.write "raise 'boom'"
     specfile.close
     begin
-      capture_io do
+      capture_output do
         Gem::Specification.load(specfile.path)
       end
     rescue => e
@@ -3498,43 +3432,28 @@ Did you mean 'Ruby'?
     specfile.delete
   end
 
-  ##
-  # KEEP p-1-x86-darwin-8
-  # KEEP p-1
-  # KEEP c-1.2
-  # KEEP a_evil-9
-  #      a-1
-  #      a-1-x86-my_platform-1
-  # KEEP a-2
-  #      a-2-x86-other_platform-1
-  # KEEP a-2-x86-my_platform-1
-  #      a-3.a
-  # KEEP a-3-x86-other_platform-1
-
   def test_latest_specs
     spec_fetcher do |fetcher|
-      fetcher.spec 'a', 1 do |s|
-        s.platform = Gem::Platform.new 'x86-my_platform1'
+      fetcher.spec "a", 1 do |s|
+        s.platform = Gem::Platform.new "x86-my_platform1"
       end
 
-      fetcher.spec 'a', 2
+      fetcher.spec "a", 2
 
-      fetcher.spec 'a', 2 do |s|
-        s.platform = Gem::Platform.new 'x86-my_platform1'
+      fetcher.spec "a", 2 do |s|
+        s.platform = Gem::Platform.new "x86-my_platform1"
       end
 
-      fetcher.spec 'a', 2 do |s|
-        s.platform = Gem::Platform.new 'x86-other_platform1'
+      fetcher.spec "a", 2 do |s|
+        s.platform = Gem::Platform.new "x86-other_platform1"
       end
 
-      fetcher.spec 'a', 3 do |s|
-        s.platform = Gem::Platform.new 'x86-other_platform1'
+      fetcher.spec "a", 3 do |s|
+        s.platform = Gem::Platform.new "x86-other_platform1"
       end
     end
 
     expected = %W[
-      a-2
-      a-2-x86-my_platform-1
       a-3-x86-other_platform-1
     ]
 
@@ -3547,12 +3466,13 @@ Did you mean 'Ruby'?
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @m1 = quick_gem 'm', '1' do |s|
+      @m1 = quick_gem "m", "1" do |s|
         s.files = %w[lib/code.rb]
         s.metadata = {
           "one"          => "two",
           "home"         => "three",
-          "homepage_uri" => "https://example.com/user/repo"
+          "homepage_uri" => "https://example.com/user/repo",
+          "funding_uri"  => "https://example.com/donate",
         }
       end
 
@@ -3566,12 +3486,12 @@ Did you mean 'Ruby'?
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @m2 = quick_gem 'm', '2' do |s|
+      @m2 = quick_gem "m", "2" do |s|
         s.files = %w[lib/code.rb]
         s.metadata = { 1 => "fail" }
       end
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @m2.validate
       end
 
@@ -3583,16 +3503,16 @@ Did you mean 'Ruby'?
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @m2 = quick_gem 'm', '2' do |s|
+      @m2 = quick_gem "m", "2" do |s|
         s.files = %w[lib/code.rb]
         s.metadata = { ("x" * 129) => "fail" }
       end
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @m2.validate
       end
 
-      assert_equal "metadata key too large (129 > 128)", e.message
+      assert_equal "metadata key is too large (129 > 128)", e.message
     end
   end
 
@@ -3600,16 +3520,16 @@ Did you mean 'Ruby'?
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @m2 = quick_gem 'm', '2' do |s|
+      @m2 = quick_gem "m", "2" do |s|
         s.files = %w[lib/code.rb]
-        s.metadata = { 'fail' => [] }
+        s.metadata = { "fail" => [] }
       end
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @m2.validate
       end
 
-      assert_equal "metadata values must be a String", e.message
+      assert_equal "metadata['fail'] value must be a String", e.message
     end
   end
 
@@ -3617,16 +3537,16 @@ Did you mean 'Ruby'?
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @m2 = quick_gem 'm', '2' do |s|
+      @m2 = quick_gem "m", "2" do |s|
         s.files = %w[lib/code.rb]
-        s.metadata = { 'fail' => ("x" * 1025) }
+        s.metadata = { "fail" => ("x" * 1025) }
       end
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @m2.validate
       end
 
-      assert_equal "metadata value too large (1025 > 1024)", e.message
+      assert_equal "metadata['fail'] value is too large (1025 > 1024)", e.message
     end
   end
 
@@ -3634,12 +3554,12 @@ Did you mean 'Ruby'?
     util_setup_validate
 
     Dir.chdir @tempdir do
-      @m2 = quick_gem 'm', '2' do |s|
+      @m2 = quick_gem "m", "2" do |s|
         s.files = %w[lib/code.rb]
-        s.metadata = { 'homepage_uri' => 'http:/example.com' }
+        s.metadata = { "homepage_uri" => "http:/example.com" }
       end
 
-      e = assert_raises Gem::InvalidSpecificationException do
+      e = assert_raise Gem::InvalidSpecificationException do
         @m2.validate
       end
 
@@ -3648,9 +3568,9 @@ Did you mean 'Ruby'?
   end
 
   def test_metadata_specs
-    @m1 = quick_gem 'm', '1' do |s|
+    @m1 = quick_gem "m", "1" do |s|
       s.files = %w[lib/code.rb]
-      s.metadata = { 'one' => "two", 'two' => "three" }
+      s.metadata = { "one" => "two", "two" => "three" }
     end
 
     valid_ruby_spec = <<-EOF
@@ -3679,7 +3599,7 @@ end
   end
 
   def test_missing_extensions_eh
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
     ext_spec
 
     assert @ext.missing_extensions?
@@ -3687,7 +3607,7 @@ end
     extconf_rb = File.join @ext.gem_dir, @ext.extensions.first
     FileUtils.mkdir_p File.dirname extconf_rb
 
-    File.open extconf_rb, 'w' do |f|
+    File.open extconf_rb, "w" do |f|
       f.write <<-'RUBY'
         File.open 'Makefile', 'w' do |f|
           f.puts "clean:\n\techo clean"
@@ -3703,30 +3623,18 @@ end
   end
 
   def test_missing_extensions_eh_default_gem
-    spec = new_default_spec 'default', 1
-    spec.extensions << 'extconf.rb'
+    spec = new_default_spec "default", 1
+    spec.extensions << "extconf.rb"
 
     refute spec.missing_extensions?
   end
 
-  def test_missing_extensions_eh_legacy
-    ext_spec
-
-    @ext.installed_by_version = v '2.2.0.preview.2'
-
-    assert @ext.missing_extensions?
-
-    @ext.installed_by_version = v '2.2.0.preview.1'
-
-    refute @ext.missing_extensions?
-  end
-
   def test_missing_extensions_eh_none
     refute @a1.missing_extensions?
   end
 
   def test_find_all_by_full_name
-    pl = Gem::Platform.new 'i386-linux'
+    pl = Gem::Platform.new "i386-linux"
 
     a1 = util_spec "a", "1"
     a1_pre = util_spec "a", "1.0.0.pre.1"
@@ -3758,7 +3666,7 @@ end
     assert Gem::Specification.find_by_name "a", "1"
     assert Gem::Specification.find_by_name "a", ">1"
 
-    assert_raises Gem::MissingSpecError do
+    assert_raise Gem::MissingSpecError do
       Gem::Specification.find_by_name "monkeys"
     end
   end
@@ -3777,9 +3685,11 @@ end
 
     install_specs b
 
+    Gem::Specification.reset
+
     assert Gem::Specification.find_by_name "b"
 
-    assert_raises Gem::MissingSpecVersionError do
+    assert_raise Gem::MissingSpecVersionError do
       Gem::Specification.find_by_name "b", "1"
     end
 
@@ -3791,9 +3701,9 @@ end
 
     install_specs a
 
-    assert_equal a, Gem::Specification.find_by_path('foo')
+    assert_equal a, Gem::Specification.find_by_path("foo")
     a.activate
-    assert_equal a, Gem::Specification.find_by_path('foo')
+    assert_equal a, Gem::Specification.find_by_path("foo")
   end
 
   def test_find_inactive_by_path
@@ -3801,9 +3711,9 @@ end
 
     install_specs a
 
-    assert_equal a, Gem::Specification.find_inactive_by_path('foo')
+    assert_equal a, Gem::Specification.find_inactive_by_path("foo")
     a.activate
-    assert_nil Gem::Specification.find_inactive_by_path('foo')
+    assert_nil Gem::Specification.find_inactive_by_path("foo")
   end
 
   def test_load_default_gem
@@ -3812,7 +3722,7 @@ end
 
     default_gem_spec = new_default_spec("default", "2.0.0.0",
                                         nil, "default/gem.rb")
-    spec_path = File.join(@default_spec_dir, default_gem_spec.spec_name)
+    spec_path = File.join(@gemhome, "specifications", "default", default_gem_spec.spec_name)
     write_file(spec_path) do |file|
       file.print(default_gem_spec.to_ruby)
     end
@@ -3837,64 +3747,18 @@ end
       FileUtils.mkdir_p "test"
       FileUtils.mkdir_p "bin"
 
-      FileUtils.touch File.join("ext", "a", "extconf.rb")
-      FileUtils.touch File.join("lib", "code.rb")
-      FileUtils.touch File.join("test", "suite.rb")
+      begin
+        umask_orig = File.umask(2)
+        FileUtils.touch File.join("ext", "a", "extconf.rb")
+        FileUtils.touch File.join("lib", "code.rb")
+        FileUtils.touch File.join("test", "suite.rb")
 
-      File.open "bin/exec", "w", 0755 do |fp|
-        fp.puts "#!#{Gem.ruby}"
+        File.open "bin/exec", "w", 0755 do |fp|
+          fp.puts "#!#{Gem.ruby}"
+        end
+      ensure
+        File.umask(umask_orig)
       end
     end
   end
-
-  def with_syck
-    begin
-      verbose, $VERBOSE = $VERBOSE, nil
-      require "yaml"
-      old_engine = YAML::ENGINE.yamler
-      YAML::ENGINE.yamler = 'syck'
-      load 'rubygems/syck_hack.rb'
-    rescue NameError
-      # probably on 1.8, ignore
-    ensure
-      $VERBOSE = verbose
-    end
-
-    yield
-  ensure
-    begin
-      YAML::ENGINE.yamler = old_engine
-      load 'rubygems/syck_hack.rb'
-    rescue NameError
-      # ignore
-    end
-  end
-
-  def with_psych
-    begin
-      require "yaml"
-      old_engine = YAML::ENGINE.yamler
-      YAML::ENGINE.yamler = 'psych'
-      load 'rubygems/syck_hack.rb'
-    rescue NameError
-      # probably on 1.8, ignore
-    end
-
-    yield
-  ensure
-    begin
-      YAML::ENGINE.yamler = old_engine
-      load 'rubygems/syck_hack.rb'
-    rescue NameError
-      # ignore
-    end
-  end
-
-  def silence_warnings
-    old_verbose, $VERBOSE = $VERBOSE, false
-    yield
-  ensure
-    $VERBOSE = old_verbose
-  end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_stream_ui.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_stream_ui.rb
@@ -1,11 +1,12 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/user_interaction'
-require 'timeout'
+require_relative "helper"
+require "rubygems/user_interaction"
+require "timeout"
 
 class TestGemStreamUI < Gem::TestCase
-
-  SHORT_TIMEOUT = (defined?(RubyVM::MJIT) && RubyVM::MJIT.enabled?) ? 1.0 : 0.1 # increase timeout with MJIT for --jit-wait testing
+  # increase timeout with MJIT for --jit-wait testing
+  mjit_enabled = defined?(RubyVM::MJIT) && RubyVM::MJIT.enabled?
+  SHORT_TIMEOUT = (RUBY_ENGINE == "ruby" && !mjit_enabled) ? 0.1 : 1.0
 
   module IsTty
     attr_accessor :tty
@@ -89,7 +90,7 @@ class TestGemStreamUI < Gem::TestCase
     @in.tty = false
 
     Timeout.timeout(SHORT_TIMEOUT) do
-      assert_raises(Gem::OperationNotSupportedError) do
+      assert_raise(Gem::OperationNotSupportedError) do
         @sui.ask_yes_no("do coconuts migrate?")
       end
     end
@@ -99,14 +100,14 @@ class TestGemStreamUI < Gem::TestCase
     @in.puts "1"
     @in.rewind
 
-    result = @sui.choose_from_list 'which one?', %w[foo bar]
+    result = @sui.choose_from_list "which one?", %w[foo bar]
 
-    assert_equal ['foo', 0], result
+    assert_equal ["foo", 0], result
     assert_equal "which one?\n 1. foo\n 2. bar\n> ", @out.string
   end
 
   def test_choose_from_list_EOF
-    result = @sui.choose_from_list 'which one?', %w[foo bar]
+    result = @sui.choose_from_list "which one?", %w[foo bar]
 
     assert_equal [nil, nil], result
     assert_equal "which one?\n 1. foo\n 2. bar\n> ", @out.string
@@ -114,27 +115,27 @@ class TestGemStreamUI < Gem::TestCase
 
   def test_progress_reporter_silent_nil
     @cfg.verbose = nil
-    reporter = @sui.progress_reporter 10, 'hi'
+    reporter = @sui.progress_reporter 10, "hi"
     assert_kind_of Gem::StreamUI::SilentProgressReporter, reporter
   end
 
   def test_progress_reporter_silent_false
     @cfg.verbose = false
-    reporter = @sui.progress_reporter 10, 'hi'
+    reporter = @sui.progress_reporter 10, "hi"
     assert_kind_of Gem::StreamUI::SilentProgressReporter, reporter
     assert_equal "", @out.string
   end
 
   def test_progress_reporter_simple
     @cfg.verbose = true
-    reporter = @sui.progress_reporter 10, 'hi'
+    reporter = @sui.progress_reporter 10, "hi"
     assert_kind_of Gem::StreamUI::SimpleProgressReporter, reporter
     assert_equal "hi\n", @out.string
   end
 
   def test_progress_reporter_verbose
     @cfg.verbose = 0
-    reporter = @sui.progress_reporter 10, 'hi'
+    reporter = @sui.progress_reporter 10, "hi"
     assert_kind_of Gem::StreamUI::VerboseProgressReporter, reporter
     assert_equal "hi\n", @out.string
   end
@@ -142,7 +143,7 @@ class TestGemStreamUI < Gem::TestCase
   def test_download_reporter_silent_nil
     @cfg.verbose = nil
     reporter = @sui.download_reporter
-    reporter.fetch 'a.gem', 1024
+    reporter.fetch "a.gem", 1024
     assert_kind_of Gem::StreamUI::SilentDownloadReporter, reporter
     assert_equal "", @out.string
   end
@@ -150,7 +151,7 @@ class TestGemStreamUI < Gem::TestCase
   def test_download_reporter_silent_false
     @cfg.verbose = false
     reporter = @sui.download_reporter
-    reporter.fetch 'a.gem', 1024
+    reporter.fetch "a.gem", 1024
     assert_kind_of Gem::StreamUI::SilentDownloadReporter, reporter
     assert_equal "", @out.string
   end
@@ -164,14 +165,14 @@ class TestGemStreamUI < Gem::TestCase
   def test_threaded_download_reporter
     @cfg.verbose = true
     reporter = @sui.download_reporter
-    reporter.fetch 'a.gem', 1024
+    reporter.fetch "a.gem", 1024
     assert_equal "Fetching a.gem\n", @out.string
   end
 
   def test_verbose_download_reporter_progress
     @cfg.verbose = true
     reporter = @sui.download_reporter
-    reporter.fetch 'a.gem', 1024
+    reporter.fetch "a.gem", 1024
     reporter.update 512
     assert_equal "Fetching a.gem\n", @out.string
   end
@@ -179,7 +180,7 @@ class TestGemStreamUI < Gem::TestCase
   def test_verbose_download_reporter_progress_once
     @cfg.verbose = true
     reporter = @sui.download_reporter
-    reporter.fetch 'a.gem', 1024
+    reporter.fetch "a.gem", 1024
     reporter.update 510
     reporter.update 512
     assert_equal "Fetching a.gem\n", @out.string
@@ -188,7 +189,7 @@ class TestGemStreamUI < Gem::TestCase
   def test_verbose_download_reporter_progress_complete
     @cfg.verbose = true
     reporter = @sui.download_reporter
-    reporter.fetch 'a.gem', 1024
+    reporter.fetch "a.gem", 1024
     reporter.update 510
     reporter.done
     assert_equal "Fetching a.gem\n", @out.string
@@ -197,7 +198,7 @@ class TestGemStreamUI < Gem::TestCase
   def test_verbose_download_reporter_progress_nil_length
     @cfg.verbose = true
     reporter = @sui.download_reporter
-    reporter.fetch 'a.gem', nil
+    reporter.fetch "a.gem", nil
     reporter.update 1024
     reporter.done
     assert_equal "Fetching a.gem\n", @out.string
@@ -206,7 +207,7 @@ class TestGemStreamUI < Gem::TestCase
   def test_verbose_download_reporter_progress_zero_length
     @cfg.verbose = true
     reporter = @sui.download_reporter
-    reporter.fetch 'a.gem', 0
+    reporter.fetch "a.gem", 0
     reporter.update 1024
     reporter.done
     assert_equal "Fetching a.gem\n", @out.string
@@ -217,8 +218,7 @@ class TestGemStreamUI < Gem::TestCase
 
     @cfg.verbose = true
     reporter = @sui.download_reporter
-    reporter.fetch 'a.gem', 1024
+    reporter.fetch "a.gem", 1024
     assert_equal "", @out.string
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_stub_specification.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_stub_specification.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require "rubygems/test_case"
+require_relative "helper"
 require "rubygems/stub_specification"
 
 class TestStubSpecification < Gem::TestCase
-
   FOO = File.expand_path File.join("specifications", "foo-0.0.1-x86-mswin32.gemspec"), __dir__
   BAR = File.expand_path File.join("specifications", "bar-0.0.2.gemspec"), __dir__
 
@@ -11,7 +10,7 @@ class TestStubSpecification < Gem::TestC
     super
 
     @base_dir = __dir__
-    @gems_dir = File.join __dir__, 'gem'
+    @gems_dir = File.join __dir__, "gem"
     @foo = Gem::StubSpecification.gemspec_stub FOO, @base_dir, @gems_dir
   end
 
@@ -26,24 +25,24 @@ class TestStubSpecification < Gem::TestC
   def test_initialize_extension
     stub = stub_with_extension
 
-    assert_equal 'stub_e',                    stub.name
+    assert_equal "stub_e",                    stub.name
     assert_equal v(2),                        stub.version
     assert_equal Gem::Platform::RUBY,         stub.platform
-    assert_equal [stub.extension_dir, 'lib'], stub.require_paths
+    assert_equal [stub.extension_dir, "lib"], stub.require_paths
     assert_equal %w[ext/stub_e/extconf.rb],   stub.extensions
   end
 
   def test_initialize_version
     stub = stub_with_version
 
-    assert_equal 'stub_v',                    stub.name
+    assert_equal "stub_v",                    stub.name
     assert_equal v(2),                        stub.version
   end
 
   def test_initialize_with_empty_version
     stub = stub_without_version
 
-    assert_equal 'stub_v',                    stub.name
+    assert_equal "stub_v",                    stub.name
     assert_equal v(0),                        stub.version
   end
 
@@ -58,18 +57,18 @@ class TestStubSpecification < Gem::TestC
 
   def test_contains_requirable_file_eh
     stub = stub_without_extension
-    code_rb = File.join stub.gem_dir, 'lib', 'code.rb'
+    code_rb = File.join stub.gem_dir, "lib", "code.rb"
     FileUtils.mkdir_p File.dirname code_rb
     FileUtils.touch code_rb
 
-    assert stub.contains_requirable_file? 'code'
+    assert stub.contains_requirable_file? "code"
   end
 
   def test_contains_requirable_file_eh_extension
-    skip "I guess making the stub match the running platform should work" if Gem.java_platform?
+    pend "I guess making the stub match the running platform should work" if Gem.java_platform?
     stub_with_extension do |stub|
-      _, err = capture_io do
-        refute stub.contains_requirable_file? 'nonexistent'
+      _, err = capture_output do
+        refute stub.contains_requirable_file? "nonexistent"
       end
 
       expected = "Ignoring stub_e-2 because its extensions are not built. " +
@@ -83,7 +82,7 @@ class TestStubSpecification < Gem::TestC
     stub = stub_with_extension
 
     expected = [
-      File.join(stub.full_gem_path, 'lib'),
+      File.join(stub.full_gem_path, "lib"),
       stub.extension_dir,
     ]
 
@@ -93,42 +92,42 @@ class TestStubSpecification < Gem::TestC
   def test_lib_dirs_glob
     stub = stub_without_extension
 
-    assert_equal File.join(stub.full_gem_path, 'lib'), stub.lib_dirs_glob
+    assert_equal File.join(stub.full_gem_path, "lib"), stub.lib_dirs_glob
   end
 
   def test_lib_dirs_glob_with_extension
     stub = stub_with_extension
 
-    assert_equal File.join(stub.full_gem_path, 'lib'), stub.lib_dirs_glob
+    assert_equal File.join(stub.full_gem_path, "lib"), stub.lib_dirs_glob
   end
 
   def test_matches_for_glob
     stub = stub_without_extension
-    code_rb = File.join stub.gem_dir, 'lib', 'code.rb'
+    code_rb = File.join stub.gem_dir, "lib", "code.rb"
     FileUtils.mkdir_p File.dirname code_rb
     FileUtils.touch code_rb
 
-    assert_equal code_rb, stub.matches_for_glob('code*').first
+    assert_equal code_rb, stub.matches_for_glob("code*").first
   end
 
   def test_matches_for_glob_with_bundler_inline
     stub = stub_with_extension
-    code_rb = File.join stub.gem_dir, 'lib', 'code.rb'
+    code_rb = File.join stub.gem_dir, "lib", "code.rb"
     FileUtils.mkdir_p File.dirname code_rb
     FileUtils.touch code_rb
 
     stub.stub(:raw_require_paths, nil) do
-      assert_equal code_rb, stub.matches_for_glob('code*').first
+      assert_equal code_rb, stub.matches_for_glob("code*").first
     end
   end
 
   def test_missing_extensions_eh
-    skip "I guess making the stub match the running platform should work" if Gem.java_platform?
+    pend "I guess making the stub match the running platform should work" if Gem.java_platform?
     stub = stub_with_extension do |s|
       extconf_rb = File.join s.gem_dir, s.extensions.first
       FileUtils.mkdir_p File.dirname extconf_rb
 
-      File.open extconf_rb, 'w' do |f|
+      File.open extconf_rb, "w" do |f|
         f.write <<-'RUBY'
         File.open 'Makefile', 'w' do |f|
           f.puts "clean:\n\techo clean"
@@ -147,10 +146,10 @@ class TestStubSpecification < Gem::TestC
   end
 
   def test_missing_extensions_eh_default_gem
-    spec = new_default_spec 'default', 1
-    spec.extensions << 'extconf.rb'
+    spec = new_default_spec "default", 1
+    spec.extensions << "extconf.rb"
 
-    File.open spec.loaded_from, 'w' do |io|
+    File.open spec.loaded_from, "w" do |io|
       io.write spec.to_ruby_for_cache
     end
 
@@ -168,7 +167,7 @@ class TestStubSpecification < Gem::TestC
     real_foo.activate
 
     assert_equal @foo.version, Gem.loaded_specs[@foo.name].version,
-                 'sanity check'
+                 "sanity check"
 
     assert_same real_foo, @foo.to_spec
   end
@@ -181,25 +180,9 @@ class TestStubSpecification < Gem::TestC
     assert bar.to_spec
   end
 
-  def test_to_spec_activated
-    assert @foo.to_spec.is_a?(Gem::Specification)
-    assert_equal "foo", @foo.to_spec.name
-    refute @foo.to_spec.instance_variable_get :@ignored
-  end
-
-  def test_to_spec_missing_extensions
-    stub = stub_with_extension
-
-    capture_io do
-      stub.contains_requirable_file? 'nonexistent'
-    end
-
-    assert stub.to_spec.instance_variable_get :@ignored
-  end
-
   def stub_with_version
-    spec = File.join @gemhome, 'specifications', 'stub_e-2.gemspec'
-    File.open spec, 'w' do |io|
+    spec = File.join @gemhome, "specifications", "stub_e-2.gemspec"
+    File.open spec, "w" do |io|
       io.write <<-STUB
 # -*- encoding: utf-8 -*-
 # stub: stub_v 2 ruby lib
@@ -212,7 +195,7 @@ end
 
       io.flush
 
-      stub = Gem::StubSpecification.gemspec_stub io.path, @gemhome, File.join(@gemhome, 'gems')
+      stub = Gem::StubSpecification.gemspec_stub io.path, @gemhome, File.join(@gemhome, "gems")
 
       yield stub if block_given?
 
@@ -221,8 +204,8 @@ end
   end
 
   def stub_without_version
-    spec = File.join @gemhome, 'specifications', 'stub-2.gemspec'
-    File.open spec, 'w' do |io|
+    spec = File.join @gemhome, "specifications", "stub-2.gemspec"
+    File.open spec, "w" do |io|
       io.write <<-STUB
 # -*- encoding: utf-8 -*-
 # stub: stub_v ruby lib
@@ -235,7 +218,7 @@ end
 
       io.flush
 
-      stub = Gem::StubSpecification.gemspec_stub io.path, @gemhome, File.join(@gemhome, 'gems')
+      stub = Gem::StubSpecification.gemspec_stub io.path, @gemhome, File.join(@gemhome, "gems")
 
       yield stub if block_given?
 
@@ -244,8 +227,8 @@ end
   end
 
   def stub_with_extension
-    spec = File.join @gemhome, 'specifications', 'stub_e-2.gemspec'
-    File.open spec, 'w' do |io|
+    spec = File.join @gemhome, "specifications", "stub_e-2.gemspec"
+    File.open spec, "w" do |io|
       io.write <<-STUB
 # -*- encoding: utf-8 -*-
 # stub: stub_e 2 ruby lib
@@ -261,7 +244,7 @@ end
 
       io.flush
 
-      stub = Gem::StubSpecification.gemspec_stub io.path, @gemhome, File.join(@gemhome, 'gems')
+      stub = Gem::StubSpecification.gemspec_stub io.path, @gemhome, File.join(@gemhome, "gems")
 
       yield stub if block_given?
 
@@ -270,8 +253,8 @@ end
   end
 
   def stub_without_extension
-    spec = File.join @gemhome, 'specifications', 'stub-2.gemspec'
-    File.open spec, 'w' do |io|
+    spec = File.join @gemhome, "specifications", "stub-2.gemspec"
+    File.open spec, "w" do |io|
       io.write <<-STUB
 # -*- encoding: utf-8 -*-
 # stub: stub 2 ruby lib
@@ -284,12 +267,11 @@ end
 
       io.flush
 
-      stub = Gem::StubSpecification.gemspec_stub io.path, @gemhome, File.join(@gemhome, 'gems')
+      stub = Gem::StubSpecification.gemspec_stub io.path, @gemhome, File.join(@gemhome, "gems")
 
       yield stub if block_given?
 
       return stub
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_text.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_text.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 require "rubygems/text"
 
 class TestGemText < Gem::TestCase
-
   include Gem::Text
 
   def test_format_text
@@ -23,7 +22,7 @@ class TestGemText < Gem::TestCase
   end
 
   def test_format_text_no_space
-    assert_equal "texttowr\nap",     format_text("texttowrap", 8)
+    assert_equal "texttowr\nap", format_text("texttowrap", 8)
   end
 
   def test_format_text_trailing # for two spaces after .
@@ -84,6 +83,12 @@ Without the wrapping, the text might not
     assert_equal 7, levenshtein_distance("zentest", "xxxxxxx")
   end
 
+  def test_levenshtein_distance_all
+    assert_equal 6, levenshtein_distance("algorithm", "altruistic")
+    assert_equal 3, levenshtein_distance("saturday", "sunday")
+    assert_equal 3, levenshtein_distance("kitten", "sitting")
+  end
+
   def test_truncate_text
     assert_equal "abc", truncate_text("abc", "desc")
     assert_equal "Truncating desc to 2 characters:\nab", truncate_text("abc", "desc", 2)
@@ -94,5 +99,4 @@ Without the wrapping, the text might not
   def test_clean_text
     assert_equal ".]2;nyan.", clean_text("\e]2;nyan\a")
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_uninstaller.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_uninstaller.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/installer_test_case'
-require 'rubygems/uninstaller'
+require_relative "installer_test_case"
+require "rubygems/uninstaller"
 
 class TestGemUninstaller < Gem::InstallerTestCase
-
   def setup
     super
     @installer = setup_base_installer
@@ -24,14 +23,14 @@ class TestGemUninstaller < Gem::Installe
   end
 
   def test_initialize_expand_path
-    FileUtils.mkdir_p 'foo/bar'
-    uninstaller = Gem::Uninstaller.new nil, :install_dir => 'foo//bar'
+    FileUtils.mkdir_p "foo/bar"
+    uninstaller = Gem::Uninstaller.new nil, :install_dir => "foo//bar"
 
-    assert_match %r|foo/bar$|, uninstaller.instance_variable_get(:@gem_home)
+    assert_match %r{foo/bar$}, uninstaller.instance_variable_get(:@gem_home)
   end
 
   def test_ask_if_ok
-    c = util_spec 'c'
+    c = util_spec "c"
 
     uninstaller = Gem::Uninstaller.new nil
 
@@ -55,14 +54,14 @@ class TestGemUninstaller < Gem::Installe
       uninstaller.remove_all [@spec]
     end
 
-    refute_path_exists @spec.gem_dir
+    assert_path_not_exist @spec.gem_dir
   end
 
   def test_remove_executables_force_keep
     uninstaller = Gem::Uninstaller.new nil, :executables => false
 
-    executable = File.join Gem.bindir(@user_spec.base_dir), 'executable'
-    assert File.exist?(executable), 'executable not written'
+    executable = File.join Gem.bindir(@user_spec.base_dir), "executable"
+    assert File.exist?(executable), "executable not written"
 
     use_ui @ui do
       uninstaller.remove_executables @user_spec
@@ -76,8 +75,8 @@ class TestGemUninstaller < Gem::Installe
   def test_remove_executables_force_remove
     uninstaller = Gem::Uninstaller.new nil, :executables => true
 
-    executable = File.join Gem.bindir(@user_spec.base_dir), 'executable'
-    assert File.exist?(executable), 'executable not written'
+    executable = File.join Gem.bindir(@user_spec.base_dir), "executable"
+    assert File.exist?(executable), "executable not written"
 
     use_ui @ui do
       uninstaller.remove_executables @user_spec
@@ -95,14 +94,14 @@ class TestGemUninstaller < Gem::Installe
       uninstaller.remove_executables @user_spec
     end
 
-    exec_path = File.join Gem.user_dir, 'bin', 'executable'
-    refute File.exist?(exec_path), 'exec still exists in user bin dir'
+    exec_path = File.join Gem.user_dir, "bin", "executable"
+    refute File.exist?(exec_path), "exec still exists in user bin dir"
 
     assert_equal "Removing executable\n", @ui.output
   end
 
   def test_remove_executables_user_format
-    Gem::Installer.exec_format = 'foo-%s-bar'
+    Gem::Installer.exec_format = "foo-%s-bar"
 
     uninstaller = Gem::Uninstaller.new nil, :executables => true, :format_executable => true
 
@@ -110,8 +109,8 @@ class TestGemUninstaller < Gem::Installe
       uninstaller.remove_executables @user_spec
     end
 
-    exec_path = File.join Gem.user_dir, 'bin', 'foo-executable-bar'
-    assert_equal false, File.exist?(exec_path), 'removed exec from bin dir'
+    exec_path = File.join Gem.user_dir, "bin", "foo-executable-bar"
+    assert_equal false, File.exist?(exec_path), "removed exec from bin dir"
 
     assert_equal "Removing foo-executable-bar\n", @ui.output
   ensure
@@ -119,7 +118,7 @@ class TestGemUninstaller < Gem::Installe
   end
 
   def test_remove_executables_user_format_disabled
-    Gem::Installer.exec_format = 'foo-%s-bar'
+    Gem::Installer.exec_format = "foo-%s-bar"
 
     uninstaller = Gem::Uninstaller.new nil, :executables => true
 
@@ -127,8 +126,8 @@ class TestGemUninstaller < Gem::Installe
       uninstaller.remove_executables @user_spec
     end
 
-    exec_path = File.join Gem.user_dir, 'bin', 'executable'
-    refute File.exist?(exec_path), 'removed exec from bin dir'
+    exec_path = File.join Gem.user_dir, "bin", "executable"
+    refute File.exist?(exec_path), "removed exec from bin dir"
 
     assert_equal "Removing executable\n", @ui.output
   ensure
@@ -139,7 +138,7 @@ class TestGemUninstaller < Gem::Installe
     Dir.mkdir "#{@gemhome}2"
     uninstaller = Gem::Uninstaller.new nil, :install_dir => "#{@gemhome}2"
 
-    e = assert_raises Gem::GemNotInHomeException do
+    e = assert_raise Gem::GemNotInHomeException do
       use_ui ui do
         uninstaller.remove @spec
       end
@@ -150,10 +149,12 @@ class TestGemUninstaller < Gem::Installe
 
     assert_equal expected, e.message
 
-    assert_path_exists @spec.gem_dir
+    assert_path_exist @spec.gem_dir
   end
 
   def test_remove_symlinked_gem_home
+    pend "Symlinks not supported or not enabled" unless symlink_supported?
+
     Dir.mktmpdir("gem_home") do |dir|
       symlinked_gem_home = "#{dir}/#{File.basename(@gemhome)}"
 
@@ -165,8 +166,61 @@ class TestGemUninstaller < Gem::Installe
         uninstaller.remove @spec
       end
 
-      refute_path_exists @spec.gem_dir
+      assert_path_not_exist @spec.gem_dir
+    end
+  end
+
+  def test_remove_plugins
+    write_file File.join(@tempdir, "lib", "rubygems_plugin.rb") do |io|
+      io.write "puts __FILE__"
+    end
+
+    @spec.files += %w[lib/rubygems_plugin.rb]
+
+    Gem::Installer.at(Gem::Package.build(@spec), :force => true).install
+
+    plugin_path = File.join Gem.plugindir, "a_plugin.rb"
+    assert File.exist?(plugin_path), "plugin not written"
+
+    Gem::Uninstaller.new(nil).remove_plugins @spec
+
+    refute File.exist?(plugin_path), "plugin not removed"
+  end
+
+  def test_remove_plugins_with_install_dir
+    write_file File.join(@tempdir, "lib", "rubygems_plugin.rb") do |io|
+      io.write "puts __FILE__"
+    end
+
+    @spec.files += %w[lib/rubygems_plugin.rb]
+
+    Gem::Installer.at(Gem::Package.build(@spec), :force => true).install
+
+    plugin_path = File.join Gem.plugindir, "a_plugin.rb"
+    assert File.exist?(plugin_path), "plugin not written"
+
+    Dir.mkdir "#{@gemhome}2"
+    Gem::Uninstaller.new(nil, :install_dir => "#{@gemhome}2").remove_plugins @spec
+
+    assert File.exist?(plugin_path), "plugin unintentionally removed"
+  end
+
+  def test_regenerate_plugins_for
+    write_file File.join(@tempdir, "lib", "rubygems_plugin.rb") do |io|
+      io.write "puts __FILE__"
     end
+
+    @spec.files += %w[lib/rubygems_plugin.rb]
+
+    Gem::Installer.at(Gem::Package.build(@spec), :force => true).install
+
+    plugin_path = File.join Gem.plugindir, "a_plugin.rb"
+    assert File.exist?(plugin_path), "plugin not written"
+
+    FileUtils.rm plugin_path
+    Gem::Uninstaller.new(nil).regenerate_plugins_for @spec, Gem.plugindir
+
+    assert File.exist?(plugin_path), "plugin not regenerated"
   end
 
   def test_path_ok_eh
@@ -180,7 +234,7 @@ class TestGemUninstaller < Gem::Installe
 
     @spec.loaded_from = @spec.loaded_from.gsub @spec.full_name, '\&-legacy'
     @spec.internal_init # blow out cache. but why did ^^ depend on cache?
-    @spec.platform = 'legacy'
+    @spec.platform = "legacy"
 
     assert_equal true, uninstaller.path_ok?(@gemhome, @spec)
   end
@@ -194,16 +248,16 @@ class TestGemUninstaller < Gem::Installe
   def test_uninstall
     uninstaller = Gem::Uninstaller.new @spec.name, :executables => true
 
-    gem_dir = File.join @gemhome, 'gems', @spec.full_name
+    gem_dir = File.join @gemhome, "gems", @spec.full_name
 
     Gem.pre_uninstall do
       sleep(0.1) if win_platform?
-      assert File.exist?(gem_dir), 'gem_dir should exist'
+      assert File.exist?(gem_dir), "gem_dir should exist"
     end
 
     Gem.post_uninstall do
       sleep(0.1) if win_platform?
-      refute File.exist?(gem_dir), 'gem_dir should not exist'
+      refute File.exist?(gem_dir), "gem_dir should not exist"
     end
 
     uninstaller.uninstall
@@ -215,7 +269,7 @@ class TestGemUninstaller < Gem::Installe
   end
 
   def test_uninstall_default_gem
-    spec = new_default_spec 'default', '2'
+    spec = new_default_spec "default", "2"
 
     install_default_gems spec
 
@@ -227,28 +281,35 @@ class TestGemUninstaller < Gem::Installe
 
     lines = @ui.output.split("\n")
 
-    assert_equal 'Gem default-2 cannot be uninstalled because it is a default gem', lines.shift
+    assert_equal "Gem default-2 cannot be uninstalled because it is a default gem", lines.shift
   end
 
   def test_uninstall_default_gem_with_same_version
-    default_spec = new_default_spec 'default', '2'
+    default_spec = new_default_spec "default", "2"
     install_default_gems default_spec
 
-    spec = util_spec 'default', '2'
+    spec = util_spec "default", "2"
     install_gem spec
 
     Gem::Specification.reset
 
     uninstaller = Gem::Uninstaller.new spec.name, :executables => true
 
-    uninstaller.uninstall
-
-    refute_path_exists spec.gem_dir
+    ui = Gem::MockGemUi.new "1\ny\n"
+    use_ui ui do
+      uninstaller.uninstall
+    end
+    expected = "Successfully uninstalled default-2\n" \
+      "There was both a regular copy and a default copy of default-2. The " \
+      "regular copy was successfully uninstalled, but the default copy " \
+      "was left around because default gems can't be removed.\n"
+    assert_equal expected, ui.output
+    assert_path_not_exist spec.gem_dir
   end
 
   def test_uninstall_extension
-    @spec.extensions << 'extconf.rb'
-    write_file File.join(@tempdir, 'extconf.rb') do |io|
+    @spec.extensions << "extconf.rb"
+    write_file File.join(@tempdir, "extconf.rb") do |io|
       io.write <<-RUBY
 require 'mkmf'
 create_makefile '#{@spec.name}'
@@ -260,22 +321,22 @@ create_makefile '#{@spec.name}'
     use_ui @ui do
       path = Gem::Package.build @spec
 
-      installer = Gem::Installer.at path
+      installer = Gem::Installer.at path, :force => true
       installer.install
     end
 
-    assert_path_exists @spec.extension_dir, 'sanity check'
+    assert_path_exist @spec.extension_dir, "sanity check"
 
     uninstaller = Gem::Uninstaller.new @spec.name, :executables => true
     uninstaller.uninstall
 
-    refute_path_exists @spec.extension_dir
+    assert_path_not_exist @spec.extension_dir
   end
 
   def test_uninstall_nonexistent
-    uninstaller = Gem::Uninstaller.new 'bogus', :executables => true
+    uninstaller = Gem::Uninstaller.new "bogus", :executables => true
 
-    e = assert_raises Gem::InstallError do
+    e = assert_raise Gem::InstallError do
       uninstaller.uninstall
     end
 
@@ -283,32 +344,32 @@ create_makefile '#{@spec.name}'
   end
 
   def test_uninstall_not_ok
-    quick_gem 'z' do |s|
+    quick_gem "z" do |s|
       s.add_runtime_dependency @spec.name
     end
 
     uninstaller = Gem::Uninstaller.new @spec.name
 
-    gem_dir = File.join @gemhome, 'gems', @spec.full_name
-    executable = File.join @gemhome, 'bin', 'executable'
+    gem_dir = File.join @gemhome, "gems", @spec.full_name
+    executable = File.join @gemhome, "bin", "executable"
 
-    assert File.exist?(gem_dir),    'gem_dir must exist'
-    assert File.exist?(executable), 'executable must exist'
+    assert File.exist?(gem_dir),    "gem_dir must exist"
+    assert File.exist?(executable), "executable must exist"
 
     ui = Gem::MockGemUi.new "n\n"
 
-    assert_raises Gem::DependencyRemovalException do
+    assert_raise Gem::DependencyRemovalException do
       use_ui ui do
         uninstaller.uninstall
       end
     end
 
-    assert File.exist?(gem_dir),    'gem_dir must still exist'
-    assert File.exist?(executable), 'executable must still exist'
+    assert File.exist?(gem_dir),    "gem_dir must still exist"
+    assert File.exist?(executable), "executable must still exist"
   end
 
   def test_uninstall_user_install
-    @user_spec = Gem::Specification.find_by_name 'b'
+    @user_spec = Gem::Specification.find_by_name "b"
 
     uninstaller = Gem::Uninstaller.new(@user_spec.name,
                                        :executables  => true,
@@ -317,16 +378,16 @@ create_makefile '#{@spec.name}'
     gem_dir = File.join @user_spec.gem_dir
 
     Gem.pre_uninstall do
-      assert_path_exists gem_dir
+      assert_path_exist gem_dir
     end
 
     Gem.post_uninstall do
-      refute_path_exists gem_dir
+      assert_path_not_exist gem_dir
     end
 
     uninstaller.uninstall
 
-    refute_path_exists gem_dir
+    assert_path_not_exist gem_dir
 
     assert_same uninstaller, @pre_uninstall_hook_arg
     assert_same uninstaller, @post_uninstall_hook_arg
@@ -338,7 +399,7 @@ create_makefile '#{@spec.name}'
 
     uninstaller = Gem::Uninstaller.new @spec.name, :executables => true
 
-    e = assert_raises Gem::InstallError do
+    e = assert_raise Gem::InstallError do
       uninstaller.uninstall
     end
 
@@ -353,9 +414,9 @@ create_makefile '#{@spec.name}'
   def test_uninstall_selection
     util_make_gems
 
-    list = Gem::Specification.find_all_by_name 'a'
+    list = Gem::Specification.find_all_by_name "a"
 
-    uninstaller = Gem::Uninstaller.new 'a'
+    uninstaller = Gem::Uninstaller.new "a"
 
     ui = Gem::MockGemUi.new "1\ny\n"
 
@@ -363,39 +424,39 @@ create_makefile '#{@spec.name}'
       uninstaller.uninstall
     end
 
-    updated_list = Gem::Specification.find_all_by_name('a')
+    updated_list = Gem::Specification.find_all_by_name("a")
     assert_equal list.length - 1, updated_list.length
 
-    assert_match ' 1. a-1',          ui.output
-    assert_match ' 2. a-2',          ui.output
-    assert_match ' 3. a-3.a',        ui.output
-    assert_match ' 4. All versions', ui.output
-    assert_match 'uninstalled a-1',  ui.output
+    assert_match " 1. a-1",          ui.output
+    assert_match " 2. a-2",          ui.output
+    assert_match " 3. a-3.a",        ui.output
+    assert_match " 4. All versions", ui.output
+    assert_match "uninstalled a-1",  ui.output
   end
 
   def test_uninstall_selection_greater_than_one
     util_make_gems
 
-    list = Gem::Specification.find_all_by_name('a')
+    list = Gem::Specification.find_all_by_name("a")
 
-    uninstaller = Gem::Uninstaller.new('a')
+    uninstaller = Gem::Uninstaller.new("a")
 
     use_ui Gem::MockGemUi.new("2\ny\n") do
       uninstaller.uninstall
     end
 
-    updated_list = Gem::Specification.find_all_by_name('a')
+    updated_list = Gem::Specification.find_all_by_name("a")
     assert_equal list.length - 1, updated_list.length
   end
 
   def test_uninstall_prompts_about_broken_deps
-    quick_gem 'r', '1' do |s|
-      s.add_dependency 'q', '= 1'
+    quick_gem "r", "1" do |s|
+      s.add_dependency "q", "= 1"
     end
 
-    quick_gem 'q', '1'
+    quick_gem "q", "1"
 
-    un = Gem::Uninstaller.new('q')
+    un = Gem::Uninstaller.new("q")
     ui = Gem::MockGemUi.new("y\n")
 
     use_ui ui do
@@ -405,27 +466,27 @@ create_makefile '#{@spec.name}'
     lines = ui.output.split("\n")
     lines.shift
 
-    assert_match %r!You have requested to uninstall the gem:!, lines.shift
+    assert_match %r{You have requested to uninstall the gem:}, lines.shift
     lines.shift
     lines.shift
 
-    assert_match %r!r-1 depends on q \(= 1\)!, lines.shift
-    assert_match %r!Successfully uninstalled q-1!, lines.last
+    assert_match %r{r-1 depends on q \(= 1\)}, lines.shift
+    assert_match %r{Successfully uninstalled q-1}, lines.last
   end
 
   def test_uninstall_only_lists_unsatisfied_deps
-    quick_gem 'r', '1' do |s|
-      s.add_dependency 'q', '~> 1.0'
+    quick_gem "r", "1" do |s|
+      s.add_dependency "q", "~> 1.0"
     end
 
-    quick_gem 'x', '1' do |s|
-      s.add_dependency 'q', '= 1.0'
+    quick_gem "x", "1" do |s|
+      s.add_dependency "q", "= 1.0"
     end
 
-    quick_gem 'q', '1.0'
-    quick_gem 'q', '1.1'
+    quick_gem "q", "1.0"
+    quick_gem "q", "1.1"
 
-    un = Gem::Uninstaller.new('q', :version => "1.0")
+    un = Gem::Uninstaller.new("q", :version => "1.0")
     ui = Gem::MockGemUi.new("y\n")
 
     use_ui ui do
@@ -435,23 +496,23 @@ create_makefile '#{@spec.name}'
     lines = ui.output.split("\n")
     lines.shift
 
-    assert_match %r!You have requested to uninstall the gem:!, lines.shift
+    assert_match %r{You have requested to uninstall the gem:}, lines.shift
     lines.shift
     lines.shift
 
-    assert_match %r!x-1 depends on q \(= 1.0\)!, lines.shift
-    assert_match %r!Successfully uninstalled q-1.0!, lines.last
+    assert_match %r{x-1 depends on q \(= 1.0\)}, lines.shift
+    assert_match %r{Successfully uninstalled q-1.0}, lines.last
   end
 
   def test_uninstall_doesnt_prompt_when_other_gem_satisfies_requirement
-    quick_gem 'r', '1' do |s|
-      s.add_dependency 'q', '~> 1.0'
+    quick_gem "r", "1" do |s|
+      s.add_dependency "q", "~> 1.0"
     end
 
-    quick_gem 'q', '1.0'
-    quick_gem 'q', '1.1'
+    quick_gem "q", "1.0"
+    quick_gem "q", "1.1"
 
-    un = Gem::Uninstaller.new('q', :version => "1.0")
+    un = Gem::Uninstaller.new("q", :version => "1.0")
     ui = Gem::MockGemUi.new("y\n")
 
     use_ui ui do
@@ -464,13 +525,13 @@ create_makefile '#{@spec.name}'
   end
 
   def test_uninstall_doesnt_prompt_when_removing_a_dev_dep
-    quick_gem 'r', '1' do |s|
-      s.add_development_dependency 'q', '= 1.0'
+    quick_gem "r", "1" do |s|
+      s.add_development_dependency "q", "= 1.0"
     end
 
-    quick_gem 'q', '1.0'
+    quick_gem "q", "1.0"
 
-    un = Gem::Uninstaller.new('q', :version => "1.0")
+    un = Gem::Uninstaller.new("q", :version => "1.0")
     ui = Gem::MockGemUi.new("y\n")
 
     use_ui ui do
@@ -483,16 +544,16 @@ create_makefile '#{@spec.name}'
   end
 
   def test_uninstall_doesnt_prompt_and_raises_when_abort_on_dependent_set
-    quick_gem 'r', '1' do |s|
-      s.add_dependency 'q', '= 1'
+    quick_gem "r", "1" do |s|
+      s.add_dependency "q", "= 1"
     end
 
-    quick_gem 'q', '1'
+    quick_gem "q", "1"
 
-    un = Gem::Uninstaller.new('q', :abort_on_dependent => true)
+    un = Gem::Uninstaller.new("q", :abort_on_dependent => true)
     ui = Gem::MockGemUi.new("y\n")
 
-    assert_raises Gem::DependencyRemovalException do
+    assert_raise Gem::DependencyRemovalException do
       use_ui ui do
         un.uninstall
       end
@@ -500,13 +561,13 @@ create_makefile '#{@spec.name}'
   end
 
   def test_uninstall_prompt_includes_dep_type
-    quick_gem 'r', '1' do |s|
-      s.add_development_dependency 'q', '= 1'
+    quick_gem "r", "1" do |s|
+      s.add_development_dependency "q", "= 1"
     end
 
-    quick_gem 'q', '1'
+    quick_gem "q", "1"
 
-    un = Gem::Uninstaller.new('q', :check_dev => true)
+    un = Gem::Uninstaller.new("q", :check_dev => true)
     ui = Gem::MockGemUi.new("y\n")
 
     use_ui ui do
@@ -516,12 +577,41 @@ create_makefile '#{@spec.name}'
     lines = ui.output.split("\n")
     lines.shift
 
-    assert_match %r!You have requested to uninstall the gem:!, lines.shift
+    assert_match %r{You have requested to uninstall the gem:}, lines.shift
     lines.shift
     lines.shift
 
-    assert_match %r!r-1 depends on q \(= 1, development\)!, lines.shift
-    assert_match %r!Successfully uninstalled q-1!, lines.last
+    assert_match %r{r-1 depends on q \(= 1, development\)}, lines.shift
+    assert_match %r{Successfully uninstalled q-1}, lines.last
+  end
+
+  def test_uninstall_prompt_only_lists_the_dependents_that_prevented_uninstallation
+    quick_gem "r", "1" do |s|
+      s.add_development_dependency "q", "= 1"
+    end
+
+    quick_gem "s", "1" do |s|
+      s.add_dependency "q", "= 1"
+    end
+
+    quick_gem "q", "1"
+
+    un = Gem::Uninstaller.new("q", :check_dev => false)
+    ui = Gem::MockGemUi.new("y\n")
+
+    use_ui ui do
+      un.uninstall
+    end
+
+    lines = ui.output.split("\n")
+    lines.shift
+
+    assert_match %r{You have requested to uninstall the gem:}, lines.shift
+    lines.shift
+    lines.shift
+
+    assert_match %r{s-1 depends on q \(= 1\)}, lines.shift
+    assert_match %r{Successfully uninstalled q-1}, lines.last
   end
 
   def test_uninstall_no_permission
@@ -536,10 +626,49 @@ create_makefile '#{@spec.name}'
     end
 
     FileUtils.stub :rm_r, stub_rm_r do
-      assert_raises Gem::UninstallError do
+      assert_raise Gem::UninstallError do
         uninstaller.uninstall
       end
     end
   end
 
+  def test_uninstall_keeps_plugins_up_to_date
+    write_file File.join(@tempdir, "lib", "rubygems_plugin.rb") do |io|
+      io.write "puts __FILE__"
+    end
+
+    plugin_path = File.join Gem.plugindir, "a_plugin.rb"
+
+    @spec.version = "1"
+    Gem::Installer.at(Gem::Package.build(@spec), :force => true).install
+
+    refute File.exist?(plugin_path), "version without plugin installed, but plugin written"
+
+    @spec.files += %w[lib/rubygems_plugin.rb]
+    @spec.version = "2"
+    Gem::Installer.at(Gem::Package.build(@spec), :force => true).install
+
+    assert File.exist?(plugin_path), "version with plugin installed, but plugin not written"
+    assert_match %r{\Arequire.*a-2/lib/rubygems_plugin\.rb}, File.read(plugin_path), "written plugin has incorrect content"
+
+    @spec.version = "3"
+    Gem::Installer.at(Gem::Package.build(@spec), :force => true).install
+
+    assert File.exist?(plugin_path), "version with plugin installed, but plugin removed"
+    assert_match %r{\Arequire.*a-3/lib/rubygems_plugin\.rb}, File.read(plugin_path), "old version installed, but plugin updated"
+
+    Gem::Uninstaller.new("a", :version => "1", :executables => true).uninstall
+
+    assert File.exist?(plugin_path), "plugin removed when old version uninstalled"
+    assert_match %r{\Arequire.*a-3/lib/rubygems_plugin\.rb}, File.read(plugin_path), "old version uninstalled, but plugin updated"
+
+    Gem::Uninstaller.new("a", version: "3", :executables => true).uninstall
+
+    assert File.exist?(plugin_path), "plugin removed when old version uninstalled and another version with plugin still present"
+    assert_match %r{\Arequire.*a-2/lib/rubygems_plugin\.rb}, File.read(plugin_path), "latest version uninstalled, but plugin not updated to previous version"
+
+    Gem::Uninstaller.new("a", version: "2", :executables => true).uninstall
+
+    refute File.exist?(plugin_path), "last version uninstalled, but plugin still present"
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_unsatisfiable_dependency_error.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_unsatisfiable_dependency_error.rb
@@ -1,12 +1,11 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestGemUnsatisfiableDependencyError < Gem::TestCase
-
   def setup
     super
 
-    @a_dep = dep 'a', '~> 1'
+    @a_dep = dep "a", "~> 1"
 
     @req = Gem::Resolver::DependencyRequest.new @a_dep, nil
 
@@ -22,11 +21,10 @@ class TestGemUnsatisfiableDependencyErro
   end
 
   def test_name
-    assert_equal 'a', @e.name
+    assert_equal "a", @e.name
   end
 
   def test_version
     assert_equal @a_dep.requirement, @e.version
   end
-
 end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_gem_uri.rb
@@ -0,0 +1,39 @@
+require_relative "helper"
+require "rubygems/uri"
+
+class TestUri < Gem::TestCase
+  def test_to_s_not_string
+    assert_equal "not_a_uri", Gem::Uri.new(:not_a_uri).to_s
+  end
+
+  def test_to_s_invalid_uri
+    assert_equal "https://www.example.com:80index", Gem::Uri.new("https://www.example.com:80index").to_s
+  end
+
+  def test_redacted_with_user_pass
+    assert_equal "https://user:REDACTED@example.com", Gem::Uri.new("https://user:pass@example.com").redacted.to_s
+  end
+
+  def test_redacted_with_token
+    assert_equal "https://REDACTED@example.com", Gem::Uri.new("https://token@example.com").redacted.to_s
+  end
+
+  def test_redacted_with_user_x_oauth_basic
+    assert_equal "https://REDACTED:x-oauth-basic@example.com", Gem::Uri.new("https://token:x-oauth-basic@example.com").redacted.to_s
+  end
+
+  def test_redacted_without_credential
+    assert_equal "https://www.example.com", Gem::Uri.new("https://www.example.com").redacted.to_s
+  end
+
+  def test_redacted_with_invalid_uri
+    assert_equal "https://www.example.com:80index", Gem::Uri.new("https://www.example.com:80index").redacted.to_s
+  end
+
+  def test_redacted_does_not_modify_uri
+    url = "https://user:password@example.com"
+    uri = Gem::Uri.new(url)
+    assert_equal "https://user:REDACTED@example.com", uri.redacted.to_s
+    assert_equal url, uri.to_s
+  end
+end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_uri_formatter.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_uri_formatter.rb
@@ -1,28 +1,26 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/uri_formatter'
+require_relative "helper"
+require "rubygems/uri_formatter"
 
 class TestGemUriFormatter < Gem::TestCase
-
   def test_normalize_uri
-    assert_equal 'FILE://example/',
-      Gem::UriFormatter.new('FILE://example/').normalize
-    assert_equal 'FTP://example/',
-      Gem::UriFormatter.new('FTP://example/').normalize
-    assert_equal 'HTTP://example/',
-      Gem::UriFormatter.new('HTTP://example/').normalize
-    assert_equal 'HTTPS://example/',
-      Gem::UriFormatter.new('HTTPS://example/').normalize
-    assert_equal 'http://example/',
-      Gem::UriFormatter.new('example/').normalize
+    assert_equal "FILE://example/",
+      Gem::UriFormatter.new("FILE://example/").normalize
+    assert_equal "FTP://example/",
+      Gem::UriFormatter.new("FTP://example/").normalize
+    assert_equal "HTTP://example/",
+      Gem::UriFormatter.new("HTTP://example/").normalize
+    assert_equal "HTTPS://example/",
+      Gem::UriFormatter.new("HTTPS://example/").normalize
+    assert_equal "http://example/",
+      Gem::UriFormatter.new("example/").normalize
   end
 
   def test_escape
-    assert_equal 'a%40b%5Cc', Gem::UriFormatter.new('a@b\c').escape
+    assert_equal "a%40b%5Cc", Gem::UriFormatter.new('a@b\c').escape
   end
 
   def test_unescape
-    assert_equal 'a@b\c', Gem::UriFormatter.new('a%40b%5Cc').unescape
+    assert_equal 'a@b\c', Gem::UriFormatter.new("a%40b%5Cc").unescape
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_util.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_util.rb
@@ -1,80 +1,83 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/util'
+require_relative "helper"
+require "rubygems/util"
 
 class TestGemUtil < Gem::TestCase
-
   def test_class_popen
-    skip "popen with a block does not behave well on jruby" if Gem.java_platform?
-    assert_equal "0\n", Gem::Util.popen(Gem.ruby, '-I', File.expand_path('../../../lib', __FILE__), '-e', 'p 0')
+    pend "popen with a block does not behave well on jruby" if Gem.java_platform?
+    assert_equal "0\n", Gem::Util.popen(*ruby_with_rubygems_in_load_path, "-e", "p 0")
 
-    assert_raises Errno::ECHILD do
+    assert_raise Errno::ECHILD do
       Process.wait(-1)
     end
   end
 
   def test_silent_system
-    skip if Gem.java_platform?
-    assert_silent do
-      Gem::Util.silent_system Gem.ruby, '-I', File.expand_path('../../../lib', __FILE__), '-e', 'puts "hello"; warn "hello"'
+    pend if Gem.java_platform?
+    Gem::Deprecate.skip_during do
+      out, err = capture_output do
+        Gem::Util.silent_system(*ruby_with_rubygems_in_load_path, "-e", 'puts "hello"; warn "hello"')
+      end
+      assert_empty out
+      assert_empty err
     end
   end
 
   def test_traverse_parents
-    FileUtils.mkdir_p 'a/b/c'
+    FileUtils.mkdir_p "a/b/c"
 
-    enum = Gem::Util.traverse_parents 'a/b/c'
+    enum = Gem::Util.traverse_parents "a/b/c"
 
-    assert_equal File.join(@tempdir, 'a/b/c'), enum.next
-    assert_equal File.join(@tempdir, 'a/b'),   enum.next
-    assert_equal File.join(@tempdir, 'a'),     enum.next
+    assert_equal File.join(@tempdir, "a/b/c"), enum.next
+    assert_equal File.join(@tempdir, "a/b"),   enum.next
+    assert_equal File.join(@tempdir, "a"),     enum.next
     loop { break if enum.next.nil? } # exhaust the enumerator
   end
 
   def test_traverse_parents_does_not_crash_on_permissions_error
-    skip 'skipped on MS Windows (chmod has no effect)' if win_platform? || java_platform?
+    pend "skipped on MS Windows (chmod has no effect)" if win_platform? || java_platform?
 
-    FileUtils.mkdir_p 'd/e/f'
+    FileUtils.mkdir_p "d/e/f"
     # remove 'execute' permission from "e" directory and make it
     # impossible to cd into it and its children
-    FileUtils.chmod(0666, 'd/e')
+    FileUtils.chmod(0666, "d/e")
 
-    skip 'skipped in root privilege' if Process.uid.zero?
+    pend "skipped in root privilege" if Process.uid.zero?
 
-    paths = Gem::Util.traverse_parents('d/e/f').to_a
+    paths = Gem::Util.traverse_parents("d/e/f").to_a
 
-    assert_equal File.join(@tempdir, 'd'), paths[0]
+    assert_equal File.join(@tempdir, "d"), paths[0]
     assert_equal @tempdir, paths[1]
-    assert_equal File.realpath(Dir.tmpdir), paths[2]
-    assert_equal File.realpath("..", Dir.tmpdir), paths[3]
+    assert_equal File.realpath("..", @tempdir), paths[2]
+    assert_equal File.realpath("../..", @tempdir), paths[3]
   ensure
     # restore default permissions, allow the directory to be removed
-    FileUtils.chmod(0775, 'd/e') unless win_platform? || java_platform?
+    FileUtils.chmod(0775, "d/e") unless win_platform? || java_platform?
   end
 
   def test_linked_list_find
     list = [1,2,3,4,5].inject(Gem::List.new(0)) do |m,o|
       Gem::List.new o, m
     end
-    assert_equal 5, list.find { |x| x == 5 }
-    assert_equal 4, list.find { |x| x == 4 }
+    assert_equal 5, list.find {|x| x == 5 }
+    assert_equal 4, list.find {|x| x == 4 }
   end
 
   def test_glob_files_in_dir
-    FileUtils.mkdir_p 'g'
-    FileUtils.touch File.join('g', 'h.rb')
-    FileUtils.touch File.join('g', 'i.rb')
+    FileUtils.mkdir_p "g"
+    FileUtils.touch File.join("g", "h.rb")
+    FileUtils.touch File.join("g", "i.rb")
 
     expected_paths = [
-      File.join(@tempdir, 'g/h.rb'),
-      File.join(@tempdir, 'g/i.rb'),
+      File.join(@tempdir, "g/h.rb"),
+      File.join(@tempdir, "g/i.rb"),
     ]
 
-    files_with_absolute_base = Gem::Util.glob_files_in_dir('*.rb', File.join(@tempdir, 'g'))
-    assert_equal expected_paths.to_set, files_with_absolute_base.to_set
+    files_with_absolute_base = Gem::Util.glob_files_in_dir("*.rb", File.join(@tempdir, "g"))
+    assert_equal expected_paths.sort, files_with_absolute_base.sort
 
-    files_with_relative_base = Gem::Util.glob_files_in_dir('*.rb', 'g')
-    assert_equal expected_paths.to_set, files_with_relative_base.to_set
+    files_with_relative_base = Gem::Util.glob_files_in_dir("*.rb", "g")
+    assert_equal expected_paths.sort, files_with_relative_base.sort
   end
 
   def test_correct_for_windows_path
@@ -84,5 +87,4 @@ class TestGemUtil < Gem::TestCase
     path = "/home/skillet"
     assert_equal "/home/skillet", Gem::Util.correct_for_windows_path(path)
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_validator.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_validator.rb
@@ -1,10 +1,9 @@
 # frozen_string_literal: true
 
-require "rubygems/test_case"
+require_relative "helper"
 require "rubygems/validator"
 
 class TestGemValidator < Gem::TestCase
-
   def setup
     super
 
@@ -12,33 +11,32 @@ class TestGemValidator < Gem::TestCase
   end
 
   def test_alien
-    @spec = quick_gem 'a' do |s|
+    @spec = quick_gem "a" do |s|
       s.files = %w[lib/a.rb lib/b.rb]
     end
 
     util_build_gem @spec
 
-    FileUtils.rm    File.join(@spec.gem_dir, 'lib/b.rb')
-    FileUtils.touch File.join(@spec.gem_dir, 'lib/c.rb')
+    FileUtils.rm    File.join(@spec.gem_dir, "lib/b.rb")
+    FileUtils.touch File.join(@spec.gem_dir, "lib/c.rb")
 
-    alien = @validator.alien 'a'
+    alien = @validator.alien "a"
 
     expected = {
       @spec.file_name => [
-        Gem::Validator::ErrorData.new('lib/b.rb', 'Missing file'),
-        Gem::Validator::ErrorData.new('lib/c.rb', 'Extra file'),
-      ]
+        Gem::Validator::ErrorData.new("lib/b.rb", "Missing file"),
+        Gem::Validator::ErrorData.new("lib/c.rb", "Extra file"),
+      ],
     }
 
     assert_equal expected, alien
   end
 
   def test_alien_default
-    new_default_spec 'c', 1, nil, 'lib/c.rb'
+    new_default_spec "c", 1, nil, "lib/c.rb"
 
-    alien = @validator.alien 'c'
+    alien = @validator.alien "c"
 
     assert_empty alien
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_version.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_version.rb
@@ -1,11 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 require "rubygems/version"
 
-require "minitest/benchmark"
-
 class TestGemVersion < Gem::TestCase
-
   class V < ::Gem::Version
   end
 
@@ -35,12 +32,19 @@ class TestGemVersion < Gem::TestCase
   def test_class_create
     real = Gem::Version.new(1.0)
 
-    assert_same  real, Gem::Version.create(real)
-    assert_nil   Gem::Version.create(nil)
+    assert_same real, Gem::Version.create(real)
+
+    expected = "nil versions are discouraged and will be deprecated in Rubygems 4\n"
+    actual_stdout, actual_stderr = capture_output do
+      assert_nil Gem::Version.create(nil)
+    end
+    assert_empty actual_stdout
+    assert_equal(expected, actual_stderr)
+
     assert_equal v("5.1"), Gem::Version.create("5.1")
 
-    ver = '1.1'.freeze
-    assert_equal v('1.1'), Gem::Version.create(ver)
+    ver = "1.1".freeze
+    assert_equal v("1.1"), Gem::Version.create(ver)
   end
 
   def test_class_correct
@@ -48,14 +52,16 @@ class TestGemVersion < Gem::TestCase
     assert_equal false, Gem::Version.correct?("an incorrect version")
 
     expected = "nil versions are discouraged and will be deprecated in Rubygems 4\n"
-    assert_output nil, expected do
+    actual_stdout, actual_stderr = capture_output do
       Gem::Version.correct?(nil)
     end
+    assert_empty actual_stdout
+    assert_equal(expected, actual_stderr)
   end
 
   def test_class_new_subclass
-    v1 = Gem::Version.new '1'
-    v2 = V.new '1'
+    v1 = Gem::Version.new "1"
+    v2 = V.new "1"
 
     refute_same v1, v2
   end
@@ -101,7 +107,7 @@ class TestGemVersion < Gem::TestCase
     invalid_versions << "2.3422222.222.222222222.22222.ads0as.dasd0.ddd2222.2.qd3e."
 
     invalid_versions.each do |invalid|
-      e = assert_raises ArgumentError, invalid do
+      e = assert_raise ArgumentError, invalid do
         Gem::Version.new invalid
       end
 
@@ -109,15 +115,6 @@ class TestGemVersion < Gem::TestCase
     end
   end
 
-  def bench_anchored_version_pattern
-    assert_performance_linear 0.5 do |count|
-      version_string = count.times.map {|i| "0" * i.succ }.join(".") << "."
-      version_string =~ Gem::Version::ANCHORED_VERSION_PATTERN
-    end
-  rescue RegexpError
-    skip "It fails to allocate the memory for regex pattern of Gem::Version::ANCHORED_VERSION_PATTERN"
-  end
-
   def test_empty_version
     ["", "   ", " "].each do |empty|
       assert_equal "0", Gem::Version.new(empty).version
@@ -130,10 +127,10 @@ class TestGemVersion < Gem::TestCase
     assert_prerelease "22.1.50.0.d"
     assert_prerelease "1.2.d.42"
 
-    assert_prerelease '1.A'
+    assert_prerelease "1.A"
 
-    assert_prerelease '1-1'
-    assert_prerelease '1-a'
+    assert_prerelease "1-1"
+    assert_prerelease "1-a"
 
     refute_prerelease "1.2.0"
     refute_prerelease "2.9"
@@ -164,6 +161,10 @@ class TestGemVersion < Gem::TestCase
     assert_equal(-1, v("5.a") <=> v("5.0.0.rc2"))
     assert_equal(1, v("5.x") <=> v("5.0.0.rc2"))
 
+    assert_equal(0, v("1.9.3")  <=> "1.9.3")
+    assert_equal(1, v("1.9.3")  <=> "1.9.2.99")
+    assert_equal(-1, v("1.9.3") <=> "1.9.3.1")
+
     assert_nil v("1.0") <=> "whatever"
   end
 
@@ -205,7 +206,7 @@ class TestGemVersion < Gem::TestCase
 
   # modifying the segments of a version should not affect the segments of the cached version object
   def test_segments
-    v('9.8.7').segments[2] += 1
+    v("9.8.7").segments[2] += 1
 
     refute_version_equal "9.8.8", "9.8.7"
     assert_equal         [9,8,7], v("9.8.7").segments
@@ -218,10 +219,10 @@ class TestGemVersion < Gem::TestCase
   end
 
   def test_frozen_version
-    v = v('1.freeze.test').freeze
-    assert_less_than v, v('1')
-    assert_version_equal v('1'), v.release
-    assert_version_equal v('2'), v.bump
+    v = v("1.freeze.test").freeze
+    assert_less_than v, v("1")
+    assert_version_equal v("1"), v.release
+    assert_version_equal v("2"), v.bump
   end
 
   # Asserts that +version+ is a prerelease.
@@ -236,7 +237,7 @@ class TestGemVersion < Gem::TestCase
     assert_equal expected, v(version).approximate_recommendation
   end
 
-  # Assert that the "approximate" recommendation for +version+ satifies +version+.
+  # Assert that the "approximate" recommendation for +version+ satisfies +version+.
 
   def assert_approximate_satisfies_itself(version)
     gem_version = v(version)
@@ -298,5 +299,4 @@ class TestGemVersion < Gem::TestCase
   def refute_version_equal(unexpected, actual)
     refute_equal v(unexpected), v(actual)
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_gem_version_option.rb
+++ ruby2.7-2.7.6/test/rubygems/test_gem_version_option.rb
@@ -1,14 +1,13 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/command'
-require 'rubygems/version_option'
+require_relative "helper"
+require "rubygems/command"
+require "rubygems/version_option"
 
 class TestGemVersionOption < Gem::TestCase
-
   def setup
     super
 
-    @cmd = Gem::Command.new 'dummy', 'dummy'
+    @cmd = Gem::Command.new "dummy", "dummy"
     @cmd.extend Gem::VersionOption
   end
 
@@ -44,8 +43,8 @@ class TestGemVersionOption < Gem::TestCa
 
     expected = [
       Gem::Platform::RUBY,
-      Gem::Platform.new('x86-freebsd6'),
-      Gem::Platform.new('x86-freebsd7'),
+      Gem::Platform.new("x86-freebsd6"),
+      Gem::Platform.new("x86-freebsd7"),
     ]
 
     assert_equal expected, Gem.platforms
@@ -57,7 +56,7 @@ class TestGemVersionOption < Gem::TestCa
     @cmd.handle_options %w[--platform ruby]
 
     expected = [
-      Gem::Platform::RUBY
+      Gem::Platform::RUBY,
     ]
 
     assert_equal expected, Gem.platforms
@@ -70,7 +69,7 @@ class TestGemVersionOption < Gem::TestCa
 
     expected = [
       Gem::Platform::RUBY,
-      Gem::Platform.new('x86-freebsd6'),
+      Gem::Platform.new("x86-freebsd6"),
     ]
 
     assert_equal expected, Gem.platforms
@@ -85,7 +84,7 @@ class TestGemVersionOption < Gem::TestCa
       :args => [],
       :explicit_prerelease => false,
       :prerelease => false,
-      :version => Gem::Requirement.new('> 1'),
+      :version => Gem::Requirement.new("> 1"),
     }
 
     assert_equal expected, @cmd.options
@@ -94,13 +93,13 @@ class TestGemVersionOption < Gem::TestCa
   def test_version_option_compound
     @cmd.add_version_option
 
-    @cmd.handle_options ['--version', '< 1, > 0.9']
+    @cmd.handle_options ["--version", "< 1, > 0.9"]
 
     expected = {
       :args => [],
       :explicit_prerelease => false,
       :prerelease => false,
-      :version => Gem::Requirement.new('< 1', '> 0.9'),
+      :version => Gem::Requirement.new("< 1", "> 0.9"),
     }
 
     assert_equal expected, @cmd.options
@@ -109,13 +108,13 @@ class TestGemVersionOption < Gem::TestCa
   def test_multiple_version_operator_option_compound
     @cmd.add_version_option
 
-    @cmd.handle_options ['--version', '< 1', '--version', '> 0.9']
+    @cmd.handle_options ["--version", "< 1", "--version", "> 0.9"]
 
     expected = {
       :args => [],
       :explicit_prerelease => false,
       :prerelease => false,
-      :version => Gem::Requirement.new('< 1', '> 0.9'),
+      :version => Gem::Requirement.new("< 1", "> 0.9"),
     }
 
     assert_equal expected, @cmd.options
@@ -131,7 +130,7 @@ class TestGemVersionOption < Gem::TestCa
       :args => [],
       :explicit_prerelease => true,
       :prerelease => true,
-      :version => Gem::Requirement.new('> 1'),
+      :version => Gem::Requirement.new("> 1"),
     }
 
     assert_equal expected, @cmd.options
@@ -146,7 +145,7 @@ class TestGemVersionOption < Gem::TestCa
       :args => [],
       :explicit_prerelease => false,
       :prerelease => true,
-      :version => Gem::Requirement.new('> 1.a'),
+      :version => Gem::Requirement.new("> 1.a"),
     }
 
     assert_equal expected, @cmd.options
@@ -157,10 +156,9 @@ class TestGemVersionOption < Gem::TestCa
       :args => [],
       :explicit_prerelease => false,
       :prerelease => false,
-      :version => Gem::Requirement.new('> 1'),
+      :version => Gem::Requirement.new("> 1"),
     }
 
     assert_equal expected, @cmd.options
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_kernel.rb
+++ ruby2.7-2.7.6/test/rubygems/test_kernel.rb
@@ -1,14 +1,15 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestKernel < Gem::TestCase
-
   def setup
     super
 
     @old_path = $:.dup
 
     util_make_gems
+
+    without_any_upwards_gemfiles
   end
 
   def teardown
@@ -18,77 +19,77 @@ class TestKernel < Gem::TestCase
   end
 
   def test_gem
-    assert gem('a', '= 1'), "Should load"
-    assert $:.any? { |p| %r{a-1/lib} =~ p }
+    assert gem("a", "= 1"), "Should load"
+    assert $:.any? {|p| %r{a-1/lib} =~ p }
   end
 
   def test_gem_default
-    assert gem('a', '>= 0')
+    assert gem("a", ">= 0")
 
-    assert_equal @a2, Gem.loaded_specs['a']
+    assert_equal @a2, Gem.loaded_specs["a"]
   end
 
   def test_gem_default_re_gem
-    assert gem('a', '=1')
+    assert gem("a", "=1")
 
-    refute gem('a', '>= 0')
+    refute gem("a", ">= 0")
 
-    assert_equal @a1, Gem.loaded_specs['a']
+    assert_equal @a1, Gem.loaded_specs["a"]
   end
 
   def test_gem_re_gem_mismatch
-    assert gem('a', '=1')
+    assert gem("a", "=1")
 
-    assert_raises Gem::LoadError do
-      gem('a', '= 2')
+    assert_raise Gem::LoadError do
+      gem("a", "= 2")
     end
 
-    assert_equal @a1, Gem.loaded_specs['a']
+    assert_equal @a1, Gem.loaded_specs["a"]
   end
 
   def test_gem_redundant
-    assert gem('a', '= 1'), "Should load"
-    refute gem('a', '= 1'), "Should not load"
-    assert_equal 1, $:.select { |p| %r{a-1/lib} =~ p }.size
+    assert gem("a", "= 1"), "Should load"
+    refute gem("a", "= 1"), "Should not load"
+    assert_equal 1, $:.select {|p| %r{a-1/lib} =~ p }.size
   end
 
   def test_gem_overlapping
-    assert gem('a', '= 1'), "Should load"
-    refute gem('a', '>= 1'), "Should not load"
-    assert_equal 1, $:.select { |p| %r{a-1/lib} =~ p }.size
+    assert gem("a", "= 1"), "Should load"
+    refute gem("a", ">= 1"), "Should not load"
+    assert_equal 1, $:.select {|p| %r{a-1/lib} =~ p }.size
   end
 
   def test_gem_prerelease
-    quick_gem 'd', '1.1.a'
-    refute gem('d', '>= 1'),   'release requirement must not load prerelease'
-    assert gem('d', '>= 1.a'), 'prerelease requirement may load prerelease'
+    quick_gem "d", "1.1.a"
+    refute gem("d", ">= 1"),   "release requirement must not load prerelease"
+    assert gem("d", ">= 1.a"), "prerelease requirement may load prerelease"
   end
 
   def test_gem_env_req
-    ENV["GEM_REQUIREMENT_A"] = '~> 2.0'
-    assert_raises(Gem::MissingSpecVersionError) { gem('a', '= 1') }
-    assert gem('a', '> 1')
-    assert_equal @a2, Gem.loaded_specs['a']
+    ENV["GEM_REQUIREMENT_A"] = "~> 2.0"
+    assert_raise(Gem::MissingSpecVersionError) { gem("a", "= 1") }
+    assert gem("a", "> 1")
+    assert_equal @a2, Gem.loaded_specs["a"]
   end
 
   def test_gem_conflicting
-    assert gem('a', '= 1'), "Should load"
+    assert gem("a", "= 1"), "Should load"
 
-    ex = assert_raises Gem::LoadError do
-      gem 'a', '= 2'
+    ex = assert_raise Gem::LoadError do
+      gem "a", "= 2"
     end
 
     assert_equal "can't activate a-2, already activated a-1", ex.message
     assert_match(/activated a-1/, ex.message)
-    assert_equal 'a', ex.name
+    assert_equal "a", ex.name
 
-    assert $:.any? { |p| %r{a-1/lib} =~ p }
-    refute $:.any? { |p| %r{a-2/lib} =~ p }
+    assert $:.any? {|p| %r{a-1/lib} =~ p }
+    refute $:.any? {|p| %r{a-2/lib} =~ p }
   end
 
   def test_gem_not_adding_bin
-    assert gem('a', '= 1'), "Should load"
-    refute $:.any? { |p| %r{a-1/bin} =~ p }
+    assert gem("a", "= 1"), "Should load"
+    refute $:.any? {|p| %r{a-1/bin} =~ p }
   end
 
   def test_gem_failing_inside_require_doesnt_cause_double_exceptions
@@ -98,46 +99,31 @@ class TestKernel < Gem::TestCase
 
     output, _ = Open3.capture2e(
       { "GEM_HOME" => Gem.paths.home },
-      Gem.ruby,
-      "-I",
-      File.expand_path("../../lib", __dir__),
+      *ruby_with_rubygems_in_load_path,
       "-r",
       "./activate.rb"
     )
 
-    load_errors = output.split("\n").select { |line| line.include?("Could not find")}
+    load_errors = output.split("\n").select {|line| line.include?("Could not find") }
 
     assert_equal 1, load_errors.size
   end
 
   def test_gem_bundler
-    quick_gem 'bundler', '1'
-    quick_gem 'bundler', '2.a'
-
-    assert gem('bundler')
-    assert $:.any? { |p| %r{bundler-1/lib} =~ p }
-  end
+    quick_gem "bundler", "1"
+    quick_gem "bundler", "2.a"
 
-  def test_gem_bundler_missing_bundler_version
-    Gem::BundlerVersionFinder.stub(:bundler_version_with_reason, ["55", "reason"]) do
-      quick_gem 'bundler', '1'
-      quick_gem 'bundler', '2.a'
-
-      e = assert_raises Gem::MissingSpecVersionError do
-        gem('bundler')
-      end
-      assert_match "Could not find 'bundler' (55) required by reason.", e.message
-    end
+    assert gem("bundler")
+    assert $:.any? {|p| %r{bundler-1/lib} =~ p }
   end
 
   def test_gem_bundler_inferred_bundler_version
-    Gem::BundlerVersionFinder.stub(:bundler_version_with_reason, ["1", "reason"]) do
-      quick_gem 'bundler', '1'
-      quick_gem 'bundler', '2.a'
+    Gem::BundlerVersionFinder.stub(:bundler_version, Gem::Version.new("1")) do
+      quick_gem "bundler", "1"
+      quick_gem "bundler", "2.a"
 
-      assert gem('bundler', '>= 0.a')
-      assert $:.any? { |p| %r{bundler-1/lib} =~ p }
+      assert gem("bundler", ">= 0.a")
+      assert $:.any? {|p| %r{bundler-1/lib} =~ p }
     end
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_project_sanity.rb
+++ ruby2.7-2.7.6/test/rubygems/test_project_sanity.rb
@@ -1,15 +1,20 @@
 # frozen_string_literal: true
 
+require_relative "helper"
 require "open3"
 
-class TestProjectSanity < Minitest::Test
-
+class TestProjectSanity < Gem::TestCase
   def test_manifest_is_up_to_date
-    skip unless File.exist?(File.expand_path("../../../Rakefile", __FILE__))
+    pend unless File.exist?(File.expand_path("../../Rakefile", __dir__))
 
     _, status = Open3.capture2e("rake check_manifest")
 
     assert status.success?, "Expected Manifest.txt to be up to date, but it's not. Run `rake update_manifest` to sync it."
   end
 
+  def test_require_rubygems_package
+    err, status = Open3.capture2e(*ruby_with_rubygems_in_load_path, "--disable-gems", "-e", "require \"rubygems/package\"")
+
+    assert status.success?, err
+  end
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_remote_fetch_error.rb
+++ ruby2.7-2.7.6/test/rubygems/test_remote_fetch_error.rb
@@ -1,21 +1,19 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
+require_relative "helper"
 
 class TestRemoteFetchError < Gem::TestCase
-
   def test_password_redacted
-    error = Gem::RemoteFetcher::FetchError.new('There was an error fetching', 'https://user:secret@gemsource.org')
-    refute_match 'secret', error.to_s
+    error = Gem::RemoteFetcher::FetchError.new("There was an error fetching", "https://user:secret@gemsource.org")
+    refute_match %r{secret}, error.to_s
   end
 
   def test_invalid_url
-    error = Gem::RemoteFetcher::FetchError.new('There was an error fetching', 'https://::gemsource.org')
-    assert_equal error.to_s, 'There was an error fetching (https://::gemsource.org)'
+    error = Gem::RemoteFetcher::FetchError.new("There was an error fetching", "https://::gemsource.org")
+    assert_equal error.to_s, "There was an error fetching (https://::gemsource.org)"
   end
 
   def test_to_s
-    error = Gem::RemoteFetcher::FetchError.new('There was an error fetching', 'https://gemsource.org')
-    assert_equal error.to_s, 'There was an error fetching (https://gemsource.org)'
+    error = Gem::RemoteFetcher::FetchError.new("There was an error fetching", "https://gemsource.org")
+    assert_equal error.to_s, "There was an error fetching (https://gemsource.org)"
   end
-
 end
--- ruby2.7-2.7.6.orig/test/rubygems/test_require.rb
+++ ruby2.7-2.7.6/test/rubygems/test_require.rb
@@ -1,11 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems'
+require_relative "helper"
+require "rubygems"
 
 class TestGemRequire < Gem::TestCase
-
   class Latch
-
     def initialize(count = 1)
       @count = count
       @lock  = Monitor.new
@@ -24,17 +22,6 @@ class TestGemRequire < Gem::TestCase
         @cv.wait_while { @count > 0 }
       end
     end
-
-  end
-
-  def setup
-    super
-
-    @old_loaded_features = $LOADED_FEATURES.dup
-    assert_raises LoadError do
-      require 'test_gem_require_a'
-    end
-    $LOADED_FEATURES.replace @old_loaded_features
   end
 
   def assert_require(path)
@@ -48,26 +35,26 @@ class TestGemRequire < Gem::TestCase
   def test_respect_loaded_features_caching_like_standard_require
     dir = Dir.mktmpdir("test_require", @tempdir)
 
-    lp1 = File.join dir, 'foo1'
-    foo1 = File.join lp1, 'foo.rb'
+    lp1 = File.join dir, "foo1"
+    foo1 = File.join lp1, "foo.rb"
 
     FileUtils.mkdir_p lp1
-    File.open(foo1, 'w') { |f| f.write "class Object; HELLO = 'foo1' end" }
+    File.open(foo1, "w") {|f| f.write "class Object; HELLO = 'foo1' end" }
 
     lp = $LOAD_PATH.dup
 
     $LOAD_PATH.unshift lp1
-    assert_require 'foo'
+    assert_require "foo"
     assert_equal "foo1", ::Object::HELLO
 
-    lp2 = File.join dir, 'foo2'
-    foo2 = File.join lp2, 'foo.rb'
+    lp2 = File.join dir, "foo2"
+    foo2 = File.join lp2, "foo.rb"
 
     FileUtils.mkdir_p lp2
-    File.open(foo2, 'w') { |f| f.write "class Object; HELLO = 'foo2' end" }
+    File.open(foo2, "w") {|f| f.write "class Object; HELLO = 'foo2' end" }
 
     $LOAD_PATH.unshift lp2
-    refute_require 'foo'
+    refute_require "foo"
     assert_equal "foo1", ::Object::HELLO
   ensure
     $LOAD_PATH.replace lp
@@ -76,32 +63,29 @@ class TestGemRequire < Gem::TestCase
 
   # Providing -I on the commandline should always beat gems
   def test_dash_i_beats_gems
-    a1 = util_spec "a", "1", {"b" => "= 1"}, "lib/test_gem_require_a.rb"
-    b1 = util_spec "b", "1", {"c" => "> 0"}, "lib/b/c.rb"
+    a1 = util_spec "a", "1", { "b" => "= 1" }, "lib/test_gem_require_a.rb"
+    b1 = util_spec "b", "1", { "c" => "> 0" }, "lib/b/c.rb"
     c1 = util_spec "c", "1", nil, "lib/c/c.rb"
     c2 = util_spec "c", "2", nil, "lib/c/c.rb"
 
     install_specs c1, c2, b1, a1
 
     dir = Dir.mktmpdir("test_require", @tempdir)
-    dash_i_arg = File.join dir, 'lib'
+    dash_i_arg = File.join dir, "lib"
 
-    c_rb = File.join dash_i_arg, 'b', 'c.rb'
+    c_rb = File.join dash_i_arg, "b", "c.rb"
 
     FileUtils.mkdir_p File.dirname c_rb
-    File.open(c_rb, 'w') { |f| f.write "class Object; HELLO = 'world' end" }
-
-    lp = $LOAD_PATH.dup
+    File.open(c_rb, "w") {|f| f.write "class Object; HELLO = 'world' end" }
 
     # Pretend to provide a commandline argument that overrides a file in gem b
     $LOAD_PATH.unshift dash_i_arg
 
-    assert_require 'test_gem_require_a'
-    assert_require 'b/c' # this should be required from -I
+    assert_require "test_gem_require_a"
+    assert_require "b/c" # this should be required from -I
     assert_equal "world", ::Object::HELLO
-    assert_equal %w(a-1 b-1), loaded_spec_names
+    assert_equal %w[a-1 b-1], loaded_spec_names
   ensure
-    $LOAD_PATH.replace lp
     Object.send :remove_const, :HELLO if Object.const_defined? :HELLO
   end
 
@@ -118,53 +102,45 @@ class TestGemRequire < Gem::TestCase
 
   # Providing -I on the commandline should always beat gems
   def test_dash_i_beats_default_gems
-    a1 = new_default_spec "a", "1", {"b" => "= 1"}, "test_gem_require_a.rb"
-    b1 = new_default_spec "b", "1", {"c" => "> 0"}, "b/c.rb"
+    a1 = new_default_spec "a", "1", { "b" => "= 1" }, "test_gem_require_a.rb"
+    b1 = new_default_spec "b", "1", { "c" => "> 0" }, "b/c.rb"
     c1 = new_default_spec "c", "1", nil, "c/c.rb"
     c2 = new_default_spec "c", "2", nil, "c/c.rb"
 
-    install_default_specs c1, c2, b1, a1
+    install_default_gems c1, c2, b1, a1
 
     dir = Dir.mktmpdir("test_require", @tempdir)
-    dash_i_arg = File.join dir, 'lib'
+    dash_i_arg = File.join dir, "lib"
 
-    c_rb = File.join dash_i_arg, 'c', 'c.rb'
+    c_rb = File.join dash_i_arg, "c", "c.rb"
 
     FileUtils.mkdir_p File.dirname c_rb
-    File.open(c_rb, 'w') { |f| f.write "class Object; HELLO = 'world' end" }
+    File.open(c_rb, "w") {|f| f.write "class Object; HELLO = 'world' end" }
 
-    assert_require 'test_gem_require_a'
-
-    lp = $LOAD_PATH.dup
+    assert_require "test_gem_require_a"
 
     # Pretend to provide a commandline argument that overrides a file in gem b
     $LOAD_PATH.unshift dash_i_arg
 
-    assert_require 'b/c'
-    assert_require 'c/c' # this should be required from -I
+    assert_require "b/c"
+    assert_require "c/c" # this should be required from -I
     assert_equal "world", ::Object::HELLO
-    assert_equal %w(a-1 b-1), loaded_spec_names
+    assert_equal %w[a-1 b-1], loaded_spec_names
   ensure
-    $LOAD_PATH.replace lp
     Object.send :remove_const, :HELLO if Object.const_defined? :HELLO
   end
 
   def test_dash_i_respects_default_library_extension_priority
-    skip "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "extensions don't quite work on jruby" if Gem.java_platform?
+    pend "not installed yet" unless RbConfig::TOPDIR
 
-    dash_i_ext_arg = util_install_extension_file('a')
-    dash_i_lib_arg = util_install_ruby_file('a')
+    dash_i_ext_arg = util_install_extension_file("a")
+    dash_i_lib_arg = util_install_ruby_file("a")
 
-    lp = $LOAD_PATH.dup
-
-    begin
-      $LOAD_PATH.unshift dash_i_lib_arg
-      $LOAD_PATH.unshift dash_i_ext_arg
-      assert_require 'a'
-      assert_match(/a\.rb$/, $LOADED_FEATURES.last)
-    ensure
-      $LOAD_PATH.replace lp
-    end
+    $LOAD_PATH.unshift dash_i_lib_arg
+    $LOAD_PATH.unshift dash_i_ext_arg
+    assert_require "a"
+    assert_match(/a\.rb$/, $LOADED_FEATURES.last)
   end
 
   def test_concurrent_require
@@ -176,8 +152,8 @@ class TestGemRequire < Gem::TestCase
 
     install_specs a1, b1
 
-    t1 = create_sync_thread{ assert_require "a#{$$}" }
-    t2 = create_sync_thread{ assert_require "b#{$$}" }
+    t1 = create_sync_thread { assert_require "a#{$$}" }
+    t2 = create_sync_thread { assert_require "b#{$$}" }
 
     # wait until both files are waiting on the exit latch
     FILE_ENTERED_LATCH.await
@@ -193,47 +169,47 @@ class TestGemRequire < Gem::TestCase
   end
 
   def test_require_is_not_lazy_with_exact_req
-    a1 = util_spec "a", "1", {"b" => "= 1"}, "lib/test_gem_require_a.rb"
+    a1 = util_spec "a", "1", { "b" => "= 1" }, "lib/test_gem_require_a.rb"
     b1 = util_spec "b", "1", nil, "lib/b/c.rb"
     b2 = util_spec "b", "2", nil, "lib/b/c.rb"
 
     install_specs b1, b2, a1
 
-    assert_require 'test_gem_require_a'
-    assert_equal %w(a-1 b-1), loaded_spec_names
+    assert_require "test_gem_require_a"
+    assert_equal %w[a-1 b-1], loaded_spec_names
     assert_equal unresolved_names, []
 
     assert_require "b/c"
-    assert_equal %w(a-1 b-1), loaded_spec_names
+    assert_equal %w[a-1 b-1], loaded_spec_names
   end
 
   def test_require_is_lazy_with_inexact_req
-    a1 = util_spec "a", "1", {"b" => ">= 1"}, "lib/test_gem_require_a.rb"
+    a1 = util_spec "a", "1", { "b" => ">= 1" }, "lib/test_gem_require_a.rb"
     b1 = util_spec "b", "1", nil, "lib/b/c.rb"
     b2 = util_spec "b", "2", nil, "lib/b/c.rb"
 
     install_specs b1, b2, a1
 
-    assert_require 'test_gem_require_a'
-    assert_equal %w(a-1), loaded_spec_names
+    assert_require "test_gem_require_a"
+    assert_equal %w[a-1], loaded_spec_names
     assert_equal unresolved_names, ["b (>= 1)"]
 
     assert_require "b/c"
-    assert_equal %w(a-1 b-2), loaded_spec_names
+    assert_equal %w[a-1 b-2], loaded_spec_names
   end
 
   def test_require_is_not_lazy_with_one_possible
-    a1 = util_spec "a", "1", {"b" => ">= 1"}, "lib/test_gem_require_a.rb"
+    a1 = util_spec "a", "1", { "b" => ">= 1" }, "lib/test_gem_require_a.rb"
     b1 = util_spec "b", "1", nil, "lib/b/c.rb"
 
     install_specs b1, a1
 
-    assert_require 'test_gem_require_a'
-    assert_equal %w(a-1 b-1), loaded_spec_names
+    assert_require "test_gem_require_a"
+    assert_equal %w[a-1 b-1], loaded_spec_names
     assert_equal unresolved_names, []
 
     assert_require "b/c"
-    assert_equal %w(a-1 b-1), loaded_spec_names
+    assert_equal %w[a-1 b-1], loaded_spec_names
   end
 
   def test_require_can_use_a_pathname_object
@@ -241,43 +217,88 @@ class TestGemRequire < Gem::TestCase
 
     install_specs a1
 
-    assert_require Pathname.new 'test_gem_require_a'
-    assert_equal %w(a-1), loaded_spec_names
+    assert_require Pathname.new "test_gem_require_a"
+    assert_equal %w[a-1], loaded_spec_names
     assert_equal unresolved_names, []
   end
 
   def test_activate_via_require_respects_loaded_files
-    skip "Not sure what's going on. If another spec creates a 'a' gem before
+    pend "Not sure what's going on. If another spec creates a 'a' gem before
       this test, somehow require will load the benchmark in b, and ignore that the
       stdlib one is already in $LOADED_FEATURES?. Reproducible by running the
       spaceship_specific_file test before this one" if java_platform?
 
-    lp = $LOAD_PATH.dup
-    lib_dir = File.expand_path(File.join(File.dirname(__FILE__), "../../lib"))
-    if File.exist?(lib_dir)
+    pend "not installed yet" unless RbConfig::TOPDIR
+
+    lib_dir = File.expand_path("../lib", __dir__)
+    rubylibdir = File.realdirpath(RbConfig::CONFIG["rubylibdir"])
+    if rubylibdir == lib_dir
+      # testing in the ruby repository where RubyGems' lib/ == stdlib lib/
+      # In that case we want to move the stdlib lib/ to still be after b-2 in $LOAD_PATH
+      lp = $LOAD_PATH.dup
       $LOAD_PATH.delete lib_dir
       $LOAD_PATH.push lib_dir
+      load_path_changed = true
     end
 
-    a1 = util_spec "a", "1", {"b" => ">= 1"}, "lib/test_gem_require_a.rb"
+    require "benchmark" # the stdlib
+
+    a1 = util_spec "a", "1", { "b" => ">= 1" }, "lib/test_gem_require_a.rb"
     b1 = util_spec "b", "1", nil, "lib/benchmark.rb"
     b2 = util_spec "b", "2", nil, "lib/benchmark.rb"
 
     install_specs b1, b2, a1
 
-    assert_require 'test_gem_require_a'
+    # Activates a-1, but not b-1 and b-2
+    assert_require "test_gem_require_a"
+    assert_equal %w[a-1], loaded_spec_names
+    assert $LOAD_PATH.include? a1.load_paths[0]
+    refute $LOAD_PATH.include? b1.load_paths[0]
+    refute $LOAD_PATH.include? b2.load_paths[0]
+
     assert_equal unresolved_names, ["b (>= 1)"]
 
-    refute require('benchmark'), "benchmark should have already been loaded"
+    # The require('benchmark') below will activate b-2. However, its
+    # lib/benchmark.rb won't ever be loaded. The reason is MRI sees that even
+    # though b-2 is earlier in $LOAD_PATH it already loaded a benchmark.rb file
+    # and that still exists in $LOAD_PATH (further down),
+    # and as a result #gem_original_require returns false.
+    refute require("benchmark"), "the benchmark stdlib should be recognized as already loaded"
+
+    assert_includes $LOAD_PATH, b2.load_paths[0]
+    assert_includes $LOAD_PATH, rubylibdir
+    message = proc {
+      "this test relies on the b-2 gem lib/ to be before stdlib to make sense\n" +
+        $LOAD_PATH.pretty_inspect
+    }
+    assert_operator $LOAD_PATH.index(b2.load_paths[0]), :<, $LOAD_PATH.index(rubylibdir), message
 
     # We detected that we should activate b-2, so we did so, but
-    # then original_require decided "I've already got benchmark.rb" loaded.
-    # This case is fine because our lazy loading is provided exactly
+    # then #gem_original_require decided "I've already got some benchmark.rb" loaded.
+    # This case is fine because our lazy loading provided exactly
     # the same behavior as eager loading would have.
 
-    assert_equal %w(a-1 b-2), loaded_spec_names
+    assert_equal %w[a-1 b-2], loaded_spec_names
   ensure
-    $LOAD_PATH.replace lp unless java_platform?
+    $LOAD_PATH.replace lp if load_path_changed
+  end
+
+  def test_activate_via_require_respects_loaded_default_from_default_gems
+    a1 = new_default_spec "a", "1", nil, "a.rb"
+
+    # simulate requiring a default gem before rubygems is loaded
+    Kernel.send(:gem_original_require, "a")
+
+    # simulate registering default specs on loading rubygems
+    install_default_gems a1
+
+    a2 = util_spec "a", "2", nil, "lib/a.rb"
+
+    install_specs a2
+
+    refute_require "a"
+
+    assert_equal %w[a-1], loaded_spec_names
   end
 
   def test_already_activated_direct_conflict
@@ -291,12 +312,12 @@ class TestGemRequire < Gem::TestCase
 
     a1.activate
     c1.activate
-    assert_equal %w(a-1 c-1), loaded_spec_names
+    assert_equal %w[a-1 c-1], loaded_spec_names
     assert_equal ["b (> 0)"], unresolved_names
 
     assert require("ib")
 
-    assert_equal %w(a-1 b-1 c-1), loaded_spec_names
+    assert_equal %w[a-1 b-1 c-1], loaded_spec_names
     assert_equal [], unresolved_names
   end
 
@@ -313,10 +334,10 @@ class TestGemRequire < Gem::TestCase
 
     a1.activate
     c1.activate
-    assert_equal %w(a-1 c-1), loaded_spec_names
+    assert_equal %w[a-1 c-1], loaded_spec_names
     assert_equal ["b (> 0)", "x (> 0)"], unresolved_names
 
-    e = assert_raises(Gem::LoadError) do
+    e = assert_raise(Gem::LoadError) do
       require("ib")
     end
 
@@ -336,10 +357,10 @@ class TestGemRequire < Gem::TestCase
 
     a1.activate
     c1.activate
-    assert_equal %w(a-1 c-1), loaded_spec_names
+    assert_equal %w[a-1 c-1], loaded_spec_names
     assert_equal ["b (> 0)"], unresolved_names
 
-    e = assert_raises(Gem::LoadError) do
+    e = assert_raise(Gem::LoadError) do
       require("ib")
     end
 
@@ -357,31 +378,31 @@ class TestGemRequire < Gem::TestCase
 
     # Load default ruby gems fresh as if we've just started a ruby script.
     Gem::Specification.reset
-    require 'rubygems'
+    require "rubygems"
     Gem::Specification.stubs
 
     # Remove an old default gem version directly from disk as if someone ran
     # gem cleanup.
-    FileUtils.rm_rf(File.join @default_dir, "#{b1.full_name}")
-    FileUtils.rm_rf(File.join @default_spec_dir, "#{b1.full_name}.gemspec")
+    FileUtils.rm_rf(File.join @gemhome, "#{b1.full_name}")
+    FileUtils.rm_rf(File.join @gemhome, "specifications", "default", "#{b1.full_name}.gemspec")
 
     # Require gems that have not been removed.
-    assert_require 'a/b'
-    assert_equal %w(a-1.0), loaded_spec_names
-    assert_require 'b/d'
-    assert_equal %w(a-1.0 b-2.0), loaded_spec_names
+    assert_require "a/b"
+    assert_equal %w[a-1.0], loaded_spec_names
+    assert_require "b/d"
+    assert_equal %w[a-1.0 b-2.0], loaded_spec_names
   end
 
   def test_require_doesnt_traverse_development_dependencies
     a = util_spec("a#{$$}", "1", nil, "lib/a#{$$}.rb")
     z = util_spec("z", "1", "w" => "> 0")
-    w1 = util_spec("w", "1") { |s| s.add_development_dependency "non-existent" }
-    w2 = util_spec("w", "2") { |s| s.add_development_dependency "non-existent" }
+    w1 = util_spec("w", "1") {|s| s.add_development_dependency "non-existent" }
+    w2 = util_spec("w", "2") {|s| s.add_development_dependency "non-existent" }
 
     install_specs a, w1, w2, z
 
     assert gem("z")
-    assert_equal %w(z-1), loaded_spec_names
+    assert_equal %w[z-1], loaded_spec_names
     assert_equal ["w (> 0)"], unresolved_names
 
     assert require("a#{$$}")
@@ -390,15 +411,15 @@ class TestGemRequire < Gem::TestCase
   def test_default_gem_only
     default_gem_spec = new_default_spec("default", "2.0.0.0",
                                         nil, "default/gem.rb")
-    install_default_specs(default_gem_spec)
+    install_default_gems(default_gem_spec)
     assert_require "default/gem"
-    assert_equal %w(default-2.0.0.0), loaded_spec_names
+    assert_equal %w[default-2.0.0.0], loaded_spec_names
   end
 
   def test_default_gem_require_activates_just_once
     default_gem_spec = new_default_spec("default", "2.0.0.0",
                                         nil, "default/gem.rb")
-    install_default_specs(default_gem_spec)
+    install_default_gems(default_gem_spec)
 
     assert_require "default/gem"
 
@@ -423,40 +444,90 @@ class TestGemRequire < Gem::TestCase
   end
 
   def test_realworld_default_gem
-    testing_ruby_repo = !ENV["GEM_COMMAND"].nil?
-    skip "this test can't work under ruby-core setup" if testing_ruby_repo || java_platform?
+    omit "this test can't work under ruby-core setup" if ruby_repo?
 
     cmd = <<-RUBY
       $stderr = $stdout
       require "json"
       puts Gem.loaded_specs["json"]
     RUBY
-    output = Gem::Util.popen(Gem.ruby, "-e", cmd).strip
+    output = Gem::Util.popen(*ruby_with_rubygems_in_load_path, "-e", cmd).strip
+    assert $?.success?
     refute_empty output
   end
 
+  def test_realworld_upgraded_default_gem
+    omit "this test can't work under ruby-core setup" if ruby_repo?
+
+    newer_json = util_spec("json", "999.99.9", nil, ["lib/json.rb"])
+    install_gem newer_json
+
+    path = "#{@tempdir}/test_realworld_upgraded_default_gem.rb"
+    code = <<-RUBY
+      $stderr = $stdout
+      require "json"
+      puts Gem.loaded_specs["json"].version
+      puts $LOADED_FEATURES
+    RUBY
+    File.write(path, code)
+
+    output = Gem::Util.popen({ "GEM_HOME" => @gemhome }, *ruby_with_rubygems_in_load_path, path).strip
+    assert $?.success?
+    refute_empty output
+    assert_equal "999.99.9", output.lines[0].chomp
+    # Make sure only files from the newer json gem are loaded, and no files from the default json gem
+    assert_equal ["#{@gemhome}/gems/json-999.99.9/lib/json.rb"], output.lines.grep(%r{/gems/json-}).map(&:chomp)
+  end
+
   def test_default_gem_and_normal_gem
     default_gem_spec = new_default_spec("default", "2.0.0.0",
                                         nil, "default/gem.rb")
-    install_default_specs(default_gem_spec)
+    install_default_gems(default_gem_spec)
     normal_gem_spec = util_spec("default", "3.0", nil,
                                "lib/default/gem.rb")
     install_specs(normal_gem_spec)
     assert_require "default/gem"
-    assert_equal %w(default-3.0), loaded_spec_names
+    assert_equal %w[default-3.0], loaded_spec_names
+  end
+
+  def test_normal_gems_with_overridden_load_error_message
+    normal_gem_spec = util_spec("normal", "3.0", nil, "lib/normal/gem.rb")
+
+    install_specs(normal_gem_spec)
+
+    File.write("require_with_overridden_load_error_message.rb", <<-RUBY)
+      LoadError.class_eval do
+        def message
+          "Overridden message"
+        end
+      end
+
+      require 'normal/gem'
+    RUBY
+
+    require "open3"
+
+    output, exit_status = Open3.capture2e(
+      { "GEM_HOME" => Gem.paths.home },
+      *ruby_with_rubygems_in_load_path,
+      "-r",
+      "./require_with_overridden_load_error_message.rb"
+    )
+
+    assert exit_status.success?, "Require failed due to #{output}"
   end
 
   def test_default_gem_prerelease
     default_gem_spec = new_default_spec("default", "2.0.0",
                                         nil, "default/gem.rb")
-    install_default_specs(default_gem_spec)
+    install_default_gems(default_gem_spec)
 
     normal_gem_higher_prerelease_spec = util_spec("default", "3.0.0.rc2", nil,
                                                   "lib/default/gem.rb")
-    install_default_specs(normal_gem_higher_prerelease_spec)
+    install_default_gems(normal_gem_higher_prerelease_spec)
 
     assert_require "default/gem"
-    assert_equal %w(default-3.0.0.rc2), loaded_spec_names
+    assert_equal %w[default-3.0.0.rc2], loaded_spec_names
   end
 
   def loaded_spec_names
@@ -470,23 +541,19 @@ class TestGemRequire < Gem::TestCase
   def test_try_activate_error_unlocks_require_monitor
     silence_warnings do
       class << ::Gem
-
         alias old_try_activate try_activate
-        def try_activate(*); raise 'raised from try_activate'; end
-
+        def try_activate(*); raise "raised from try_activate"; end
       end
     end
 
-    require 'does_not_exist_for_try_activate_test'
+    require "does_not_exist_for_try_activate_test"
   rescue RuntimeError => e
     assert_match(/raised from try_activate/, e.message)
     assert Kernel::RUBYGEMS_ACTIVATION_MONITOR.try_enter, "require monitor was not unlocked when try_activate raised"
   ensure
     silence_warnings do
       class << ::Gem
-
         alias try_activate old_try_activate
-
       end
     end
     Kernel::RUBYGEMS_ACTIVATION_MONITOR.exit
@@ -495,14 +562,14 @@ class TestGemRequire < Gem::TestCase
   def test_require_when_gem_defined
     default_gem_spec = new_default_spec("default", "2.0.0.0",
                                         nil, "default/gem.rb")
-    install_default_specs(default_gem_spec)
+    install_default_gems(default_gem_spec)
     c = Class.new do
       def self.gem(*args)
         raise "received #gem with #{args.inspect}"
       end
     end
     assert c.send(:require, "default/gem")
-    assert_equal %w(default-2.0.0.0), loaded_spec_names
+    assert_equal %w[default-2.0.0.0], loaded_spec_names
   end
 
   def test_require_default_when_gem_defined
@@ -514,89 +581,96 @@ class TestGemRequire < Gem::TestCase
       end
     end
     assert c.send(:require, "a#{$$}")
-    assert_equal %W(a#{$$}-1), loaded_spec_names
+    assert_equal %W[a#{$$}-1], loaded_spec_names
   end
 
   def test_require_bundler
-    b1 = util_spec('bundler', '1', nil, "lib/bundler/setup.rb")
-    b2a = util_spec('bundler', '2.a', nil, "lib/bundler/setup.rb")
+    b1 = util_spec("bundler", "1", nil, "lib/bundler/setup.rb")
+    b2a = util_spec("bundler", "2.a", nil, "lib/bundler/setup.rb")
     install_specs b1, b2a
 
     require "rubygems/bundler_version_finder"
     $:.clear
-    assert_require 'bundler/setup'
+    assert_require "bundler/setup"
     assert_equal %w[bundler-2.a], loaded_spec_names
     assert_empty unresolved_names
   end
 
-  def test_require_bundler_missing_bundler_version
-    Gem::BundlerVersionFinder.stub(:bundler_version_with_reason, ["55", "reason"]) do
-      b1 = util_spec('bundler', '1.999999999', nil, "lib/bundler/setup.rb")
-      b2a = util_spec('bundler', '2.a', nil, "lib/bundler/setup.rb")
-      install_specs b1, b2a
-
-      e = assert_raises Gem::MissingSpecVersionError do
-        gem('bundler')
-      end
-      assert_match "Could not find 'bundler' (55) required by reason.", e.message
-    end
-  end
-
-  def test_require_bundler_with_bundler_version
-    Gem::BundlerVersionFinder.stub(:bundler_version_with_reason, ["1", "reason"]) do
-      b1 = util_spec('bundler', '1.999999999', nil, "lib/bundler/setup.rb")
-      b2 = util_spec('bundler', '2', nil, "lib/bundler/setup.rb")
-      install_specs b1, b2
-
-      $:.clear
-      assert_require 'bundler/setup'
-      assert_equal %w[bundler-1.999999999], loaded_spec_names
-    end
-  end
-
   # uplevel is 2.5+ only
   if RUBY_VERSION >= "2.5"
     ["", "Kernel."].each do |prefix|
       define_method "test_no_kernel_require_in_#{prefix.tr(".", "_")}warn_with_uplevel" do
-        lib = File.realpath("../../../lib", __FILE__)
         Dir.mktmpdir("warn_test") do |dir|
           File.write(dir + "/sub.rb", "#{prefix}warn 'uplevel', 'test', uplevel: 1\n")
           File.write(dir + "/main.rb", "require 'sub'\n")
           _, err = capture_subprocess_io do
-            system(@@ruby, "-w", "--disable=gems", "-I", lib, "-C", dir, "-I.", "main.rb")
+            system(*ruby_with_rubygems_in_load_path, "-w", "--disable=gems", "-C", dir, "-I", dir, "main.rb")
           end
           assert_match(/main\.rb:1: warning: uplevel\ntest\n$/, err)
           _, err = capture_subprocess_io do
-            system(@@ruby, "-w", "--enable=gems", "-I", lib, "-C", dir, "-I.", "main.rb")
+            system(*ruby_with_rubygems_in_load_path, "-w", "--enable=gems", "-C", dir, "-I", dir, "main.rb")
           end
           assert_match(/main\.rb:1: warning: uplevel\ntest\n$/, err)
         end
       end
 
       define_method "test_no_other_behavioral_changes_with_#{prefix.tr(".", "_")}warn" do
-        lib = File.realpath("../../../lib", __FILE__)
         Dir.mktmpdir("warn_test") do |dir|
           File.write(dir + "/main.rb", "#{prefix}warn({x:1}, {y:2}, [])\n")
           _, err = capture_subprocess_io do
-            system(@@ruby, "-w", "--disable=gems", "-I", lib, "-C", dir, "main.rb")
+            system(*ruby_with_rubygems_in_load_path, "-w", "--disable=gems", "-C", dir, "main.rb")
           end
           assert_match(/{:x=>1}\n{:y=>2}\n$/, err)
           _, err = capture_subprocess_io do
-            system(@@ruby, "-w", "--enable=gems", "-I", lib, "-C", dir, "main.rb")
+            system(*ruby_with_rubygems_in_load_path, "-w", "--enable=gems", "-C", dir, "main.rb")
           end
           assert_match(/{:x=>1}\n{:y=>2}\n$/, err)
         end
       end
     end
-  end
 
-  def silence_warnings
-    old_verbose, $VERBOSE = $VERBOSE, false
-    yield
-  ensure
-    $VERBOSE = old_verbose
+    def test_no_crash_when_overriding_warn_with_warning_module
+      Dir.mktmpdir("warn_test") do |dir|
+        File.write(dir + "/main.rb", "module Warning; def warn(str); super; end; end; warn 'Foo Bar'")
+        _, err = capture_subprocess_io do
+          system(*ruby_with_rubygems_in_load_path, "-w", "--disable=gems", "-C", dir, "main.rb")
+        end
+        assert_match(/Foo Bar\n$/, err)
+        _, err = capture_subprocess_io do
+          system(*ruby_with_rubygems_in_load_path, "-w", "--enable=gems", "-C", dir, "main.rb")
+        end
+        assert_match(/Foo Bar\n$/, err)
+      end
+    end
+
+    def test_expected_backtrace_location_when_inheriting_from_basic_object_and_including_kernel
+      Dir.mktmpdir("warn_test") do |dir|
+        File.write(dir + "/main.rb", "\nrequire 'sub'\n")
+        File.write(dir + "/sub.rb", <<-'RUBY')
+          require 'rubygems'
+          class C < BasicObject
+            include ::Kernel
+            def deprecated
+              warn "This is a deprecated method", uplevel: 2
+            end
+          end
+          C.new.deprecated
+        RUBY
+
+        _, err = capture_subprocess_io do
+          system(*ruby_with_rubygems_in_load_path, "-w", "--disable=gems", "-C", dir, "-I", dir, "main.rb")
+        end
+        assert_match(/main\.rb:2: warning: This is a deprecated method$/, err)
+        _, err = capture_subprocess_io do
+          system(*ruby_with_rubygems_in_load_path, "-w", "--enable=gems", "-C", dir, "-I", dir, "main.rb")
+        end
+        assert_match(/main\.rb:2: warning: This is a deprecated method$/, err)
+      end
+    end
   end
 
+  private
+
   def util_install_extension_file(name)
     spec = quick_gem name
     util_build_gem spec
@@ -621,12 +695,12 @@ class TestGemRequire < Gem::TestCase
     spec.files += ["extconf.rb", "depend", "#{name}.c"]
 
     so = File.join(spec.gem_dir, "#{name}.#{RbConfig::CONFIG["DLEXT"]}")
-    refute_path_exists so
+    assert_path_not_exist so
 
     path = Gem::Package.build spec
     installer = Gem::Installer.at path
     installer.install
-    assert_path_exists so
+    assert_path_exist so
 
     spec.gem_dir
   end
@@ -638,9 +712,8 @@ class TestGemRequire < Gem::TestCase
     a_rb = File.join dash_i_lib_arg, "#{name}.rb"
 
     FileUtils.mkdir_p File.dirname a_rb
-    File.open(a_rb, 'w') { |f| f.write "# #{name}.rb" }
+    File.open(a_rb, "w") {|f| f.write "# #{name}.rb" }
 
     dash_i_lib_arg
   end
-
 end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/test_rubygems.rb
@@ -0,0 +1,74 @@
+require_relative "helper"
+
+class GemTest < Gem::TestCase
+  def test_rubygems_normal_behaviour
+    _ = Gem::Util.popen(*ruby_with_rubygems_in_load_path, "-e", "'require \"rubygems\"'", { :err => [:child, :out] }).strip
+    assert $?.success?
+  end
+
+  def test_operating_system_other_exceptions
+    pend "does not apply to truffleruby" if RUBY_ENGINE == "truffleruby"
+
+    path = util_install_operating_system_rb <<-RUBY
+      intentionally_not_implemented_method
+    RUBY
+
+    output = Gem::Util.popen(*ruby_with_rubygems_and_fake_operating_system_in_load_path(path), "-e", "'require \"rubygems\"'", { :err => [:child, :out] }).strip
+    assert !$?.success?
+    assert_includes output, "undefined local variable or method `intentionally_not_implemented_method'"
+    assert_includes output, "Loading the #{operating_system_rb_at(path)} file caused an error. " \
+    "This file is owned by your OS, not by rubygems upstream. " \
+    "Please find out which OS package this file belongs to and follow the guidelines from your OS to report " \
+    "the problem and ask for help."
+  end
+
+  def test_operating_system_customizing_default_dir
+    pend "does not apply to truffleruby" if RUBY_ENGINE == "truffleruby"
+    pend "loads a custom defaults/jruby file that gets in the middle" if RUBY_ENGINE == "jruby"
+
+    # On a non existing default dir, there should be no gems
+
+    path = util_install_operating_system_rb <<-RUBY
+      module Gem
+        def self.default_dir
+          File.expand_path("foo")
+        end
+      end
+    RUBY
+
+    output = Gem::Util.popen(
+      *ruby_with_rubygems_and_fake_operating_system_in_load_path(path),
+      "-e",
+      "require \"rubygems\"; puts Gem::Specification.stubs.map(&:full_name)",
+      { :err => [:child, :out] }
+    ).strip
+    begin
+      assert_empty output
+    rescue Test::Unit::AssertionFailedError
+      pend "Temporary pending custom default_dir test"
+    end
+  end
+
+  private
+
+  def util_install_operating_system_rb(content)
+    dir_lib = Dir.mktmpdir("test_operating_system_lib", @tempdir)
+    dir_lib_arg = File.join dir_lib, "lib"
+
+    operating_system_rb = operating_system_rb_at(dir_lib_arg)
+
+    FileUtils.mkdir_p File.dirname(operating_system_rb)
+
+    File.open(operating_system_rb, "w") {|f| f.write content }
+
+    dir_lib_arg
+  end
+
+  def operating_system_rb_at(dir)
+    File.join dir, "rubygems", "defaults", "operating_system.rb"
+  end
+
+  def ruby_with_rubygems_and_fake_operating_system_in_load_path(operating_system_path)
+    [Gem.ruby, "-I", operating_system_path, "-I" , $LOAD_PATH.find {|p| p == File.dirname($LOADED_FEATURES.find {|f| f.end_with?("/rubygems.rb") }) }]
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/test/rubygems/utilities.rb
@@ -0,0 +1,371 @@
+# frozen_string_literal: true
+require "tempfile"
+require "rubygems"
+require "rubygems/remote_fetcher"
+
+##
+# A fake Gem::RemoteFetcher for use in tests or to avoid real live HTTP
+# requests when testing code that uses RubyGems.
+#
+# Example:
+#
+#   @fetcher = Gem::FakeFetcher.new
+#   @fetcher.data['http://gems.example.com/yaml'] = source_index.to_yaml
+#   Gem::RemoteFetcher.fetcher = @fetcher
+#
+#   use nested array if multiple response is needed
+#
+#   @fetcher.data['http://gems.example.com/sequence'] = [['Success', 200, 'OK'], ['Failed', 401, 'Unauthorized']]
+#
+#   @fetcher.fetch_path('http://gems.example.com/sequence') # => ['Success', 200, 'OK']
+#   @fetcher.fetch_path('http://gems.example.com/sequence') # => ['Failed', 401, 'Unauthorized']
+#
+#   # invoke RubyGems code
+#
+#   paths = @fetcher.paths
+#   assert_equal 'http://gems.example.com/yaml', paths.shift
+#   assert paths.empty?, paths.join(', ')
+#
+# See RubyGems' tests for more examples of FakeFetcher.
+
+class Gem::FakeFetcher
+  attr_reader :data
+  attr_reader :last_request
+  attr_accessor :paths
+
+  def initialize
+    @data = {}
+    @paths = []
+  end
+
+  def find_data(path)
+    return Gem.read_binary path.path if URI === path && "file" == path.scheme
+
+    if URI === path && "URI::#{path.scheme.upcase}" != path.class.name
+      raise ArgumentError,
+        "mismatch for scheme #{path.scheme} and class #{path.class}"
+    end
+
+    path = path.to_s
+    @paths << path
+    raise ArgumentError, "need full URI" unless path.start_with?("https://", "http://")
+
+    unless @data.key? path
+      raise Gem::RemoteFetcher::FetchError.new("no data for #{path}", path)
+    end
+
+    if @data[path].kind_of?(Array) && @data[path].first.kind_of?(Array)
+      @data[path].shift
+    else
+      @data[path]
+    end
+  end
+
+  def fetch_path(path, mtime = nil, head = false)
+    data = find_data(path)
+
+    if data.respond_to?(:call)
+      data.call
+    else
+      if path.to_s.end_with?(".gz") && !data.nil? && !data.empty?
+        data = Gem::Util.gunzip data
+      end
+      data
+    end
+  end
+
+  def cache_update_path(uri, path = nil, update = true)
+    if data = fetch_path(uri)
+      File.open(path, "wb") {|io| io.write data } if path && update
+      data
+    else
+      Gem.read_binary(path) if path
+    end
+  end
+
+  # Thanks, FakeWeb!
+  def open_uri_or_path(path)
+    data = find_data(path)
+    body, code, msg = data
+
+    response = Net::HTTPResponse.send(:response_class, code.to_s).new("1.0", code.to_s, msg)
+    response.instance_variable_set(:@body, body)
+    response.instance_variable_set(:@read, true)
+    response
+  end
+
+  def request(uri, request_class, last_modified = nil)
+    data = find_data(uri)
+    body, code, msg = (data.respond_to?(:call) ? data.call : data)
+
+    @last_request = request_class.new uri.request_uri
+    yield @last_request if block_given?
+
+    response = Net::HTTPResponse.send(:response_class, code.to_s).new("1.0", code.to_s, msg)
+    response.instance_variable_set(:@body, body)
+    response.instance_variable_set(:@read, true)
+    response
+  end
+
+  def pretty_print(q) # :nodoc:
+    q.group 2, "[FakeFetcher", "]" do
+      q.breakable
+      q.text "URIs:"
+
+      q.breakable
+      q.pp @data.keys
+    end
+  end
+
+  def fetch_size(path)
+    path = path.to_s
+    @paths << path
+
+    raise ArgumentError, "need full URI" unless path =~ %r{^http://}
+
+    unless @data.key? path
+      raise Gem::RemoteFetcher::FetchError.new("no data for #{path}", path)
+    end
+
+    data = @data[path]
+
+    data.respond_to?(:call) ? data.call : data.length
+  end
+
+  def download(spec, source_uri, install_dir = Gem.dir)
+    name = File.basename spec.cache_file
+    path = if Dir.pwd == install_dir # see fetch_command
+      install_dir
+    else
+      File.join install_dir, "cache"
+    end
+
+    path = File.join path, name
+
+    if source_uri =~ /^http/
+      File.open(path, "wb") do |f|
+        f.write fetch_path(File.join(source_uri, "gems", name))
+      end
+    else
+      FileUtils.cp source_uri, path
+    end
+
+    path
+  end
+
+  def download_to_cache(dependency)
+    found, _ = Gem::SpecFetcher.fetcher.spec_for_dependency dependency
+
+    return if found.empty?
+
+    spec, source = found.first
+
+    download spec, source.uri.to_s
+  end
+end
+
+# :stopdoc:
+class Gem::RemoteFetcher
+  def self.fetcher=(fetcher)
+    @fetcher = fetcher
+  end
+end
+# :startdoc:
+
+##
+# The SpecFetcherSetup allows easy setup of a remote source in RubyGems tests:
+#
+#   spec_fetcher do |f|
+#     f.gem  'a', 1
+#     f.spec 'a', 2
+#     f.gem  'b', 1' 'a' => '~> 1.0'
+#   end
+#
+# The above declaration creates two gems, a-1 and b-1, with a dependency from
+# b to a.  The declaration creates an additional spec a-2, but no gem for it
+# (so it cannot be installed).
+#
+# After the gems are created they are removed from Gem.dir.
+
+class Gem::TestCase::SpecFetcherSetup
+  ##
+  # Executes a SpecFetcher setup block.  Yields an instance then creates the
+  # gems and specifications defined in the instance.
+
+  def self.declare(test, repository)
+    setup = new test, repository
+
+    yield setup
+
+    setup.execute
+  end
+
+  def initialize(test, repository) # :nodoc:
+    @test       = test
+    @repository = repository
+
+    @gems       = {}
+    @downloaded = []
+    @installed  = []
+    @operations = []
+  end
+
+  ##
+  # Returns a Hash of created Specification full names and the corresponding
+  # Specification.
+
+  def created_specs
+    created = {}
+
+    @gems.keys.each do |spec|
+      created[spec.full_name] = spec
+    end
+
+    created
+  end
+
+  ##
+  # Creates any defined gems or specifications
+
+  def execute # :nodoc:
+    execute_operations
+
+    setup_fetcher
+
+    created_specs
+  end
+
+  def execute_operations # :nodoc:
+    @operations.each do |operation, *arguments|
+      block = arguments.pop
+      case operation
+      when :gem then
+        spec, gem = @test.util_gem(*arguments, &block)
+
+        write_spec spec
+
+        @gems[spec] = gem
+        @installed << spec
+      when :download then
+        spec, gem = @test.util_gem(*arguments, &block)
+
+        @gems[spec] = gem
+        @downloaded << spec
+      when :spec then
+        spec = @test.util_spec(*arguments, &block)
+
+        write_spec spec
+
+        @gems[spec] = nil
+        @installed << spec
+      end
+    end
+  end
+
+  ##
+  # Creates a gem with +name+, +version+ and +deps+.  The created gem can be
+  # downloaded and installed.
+  #
+  # The specification will be yielded before gem creation for customization,
+  # but only the block or the dependencies may be set, not both.
+
+  def gem(name, version, dependencies = nil, &block)
+    @operations << [:gem, name, version, dependencies, block]
+  end
+
+  ##
+  # Creates a gem with +name+, +version+ and +deps+.  The created gem is
+  # downloaded in to the cache directory but is not installed
+  #
+  # The specification will be yielded before gem creation for customization,
+  # but only the block or the dependencies may be set, not both.
+
+  def download(name, version, dependencies = nil, &block)
+    @operations << [:download, name, version, dependencies, block]
+  end
+
+  ##
+  # Creates a legacy platform spec with the name 'pl' and version 1
+
+  def legacy_platform
+    spec "pl", 1 do |s|
+      s.platform = Gem::Platform.new "i386-linux"
+      s.instance_variable_set :@original_platform, "i386-linux"
+    end
+  end
+
+  def setup_fetcher # :nodoc:
+    require "zlib"
+    require "socket"
+    require "rubygems/remote_fetcher"
+
+    unless @test.fetcher
+      @test.fetcher = Gem::FakeFetcher.new
+      Gem::RemoteFetcher.fetcher = @test.fetcher
+    end
+
+    Gem::Specification.reset
+
+    begin
+      gem_repo, @test.gem_repo = @test.gem_repo, @repository
+      @test.uri = URI @repository
+
+      @test.util_setup_spec_fetcher(*@downloaded)
+    ensure
+      @test.gem_repo = gem_repo
+      @test.uri = URI gem_repo
+    end
+
+    @gems.each do |spec, gem|
+      next unless gem
+
+      @test.fetcher.data["#{@repository}gems/#{spec.file_name}"] =
+        Gem.read_binary(gem)
+
+      FileUtils.cp gem, spec.cache_file
+    end
+  end
+
+  ##
+  # Creates a spec with +name+, +version+ and +deps+.  The created gem can be
+  # downloaded and installed.
+  #
+  # The specification will be yielded before creation for customization,
+  # but only the block or the dependencies may be set, not both.
+
+  def spec(name, version, dependencies = nil, &block)
+    @operations << [:spec, name, version, dependencies, block]
+  end
+
+  def write_spec(spec) # :nodoc:
+    File.open spec.spec_file, "w" do |io|
+      io.write spec.to_ruby_for_cache
+    end
+  end
+end
+
+##
+# A StringIO duck-typed class that uses Tempfile instead of String as the
+# backing store.
+#
+# This class was added to flush out problems in Rubinius' IO implementation.
+
+class TempIO < Tempfile
+  ##
+  # Creates a new TempIO that will be initialized to contain +string+.
+
+  def initialize(string = "")
+    super "TempIO"
+    binmode
+    write string
+    rewind
+  end
+
+  ##
+  # The content of the TempIO as a String.
+
+  def string
+    flush
+    Gem.read_binary path
+  end
+end
