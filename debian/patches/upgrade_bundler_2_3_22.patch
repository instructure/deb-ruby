--- ruby2.7-2.7.6.orig/lib/bundler.rb
+++ ruby2.7-2.7.6/lib/bundler.rb
@@ -19,7 +19,7 @@ require_relative "bundler/build_metadata
 #
 # Since Ruby 2.6, Bundler is a part of Ruby's standard library.
 #
-# Bunder is used by creating _gemfiles_ listing all the project dependencies
+# Bundler is used by creating _gemfiles_ listing all the project dependencies
 # and (optionally) their versions and then using
 #
 #   require 'bundler/setup'
@@ -34,15 +34,16 @@ require_relative "bundler/build_metadata
 # of loaded and required modules.
 #
 module Bundler
-  environment_preserver = EnvironmentPreserver.new(ENV, EnvironmentPreserver::BUNDLER_KEYS)
+  environment_preserver = EnvironmentPreserver.from_env
   ORIGINAL_ENV = environment_preserver.restore
-  ENV.replace(environment_preserver.backup)
-  SUDO_MUTEX = Mutex.new
+  environment_preserver.replace_with_backup
+  SUDO_MUTEX = Thread::Mutex.new
 
   autoload :Definition,             File.expand_path("bundler/definition", __dir__)
   autoload :Dependency,             File.expand_path("bundler/dependency", __dir__)
   autoload :DepProxy,               File.expand_path("bundler/dep_proxy", __dir__)
   autoload :Deprecate,              File.expand_path("bundler/deprecate", __dir__)
+  autoload :Digest,                 File.expand_path("bundler/digest", __dir__)
   autoload :Dsl,                    File.expand_path("bundler/dsl", __dir__)
   autoload :EndpointSpecification,  File.expand_path("bundler/endpoint_specification", __dir__)
   autoload :Env,                    File.expand_path("bundler/env", __dir__)
@@ -57,19 +58,20 @@ module Bundler
   autoload :Installer,              File.expand_path("bundler/installer", __dir__)
   autoload :LazySpecification,      File.expand_path("bundler/lazy_specification", __dir__)
   autoload :LockfileParser,         File.expand_path("bundler/lockfile_parser", __dir__)
-  autoload :MatchPlatform,          File.expand_path("bundler/match_platform", __dir__)
+  autoload :MatchRemoteMetadata,    File.expand_path("bundler/match_remote_metadata", __dir__)
   autoload :ProcessLock,            File.expand_path("bundler/process_lock", __dir__)
   autoload :RemoteSpecification,    File.expand_path("bundler/remote_specification", __dir__)
   autoload :Resolver,               File.expand_path("bundler/resolver", __dir__)
   autoload :Retry,                  File.expand_path("bundler/retry", __dir__)
   autoload :RubyDsl,                File.expand_path("bundler/ruby_dsl", __dir__)
-  autoload :RubyGemsGemInstaller,   File.expand_path("bundler/rubygems_gem_installer", __dir__)
   autoload :RubyVersion,            File.expand_path("bundler/ruby_version", __dir__)
   autoload :Runtime,                File.expand_path("bundler/runtime", __dir__)
+  autoload :SelfManager,            File.expand_path("bundler/self_manager", __dir__)
   autoload :Settings,               File.expand_path("bundler/settings", __dir__)
   autoload :SharedHelpers,          File.expand_path("bundler/shared_helpers", __dir__)
   autoload :Source,                 File.expand_path("bundler/source", __dir__)
   autoload :SourceList,             File.expand_path("bundler/source_list", __dir__)
+  autoload :SourceMap,              File.expand_path("bundler/source_map", __dir__)
   autoload :SpecSet,                File.expand_path("bundler/spec_set", __dir__)
   autoload :StubSpecification,      File.expand_path("bundler/stub_specification", __dir__)
   autoload :UI,                     File.expand_path("bundler/ui", __dir__)
@@ -95,6 +97,17 @@ module Bundler
       @bundle_path ||= Pathname.new(configured_bundle_path.path).expand_path(root)
     end
 
+    def create_bundle_path
+      SharedHelpers.filesystem_access(bundle_path.to_s) do |p|
+        mkdir_p(p)
+      end unless bundle_path.exist?
+
+      @bundle_path = bundle_path.realpath
+    rescue Errno::EEXIST
+      raise PathError, "Could not install to path `#{bundle_path}` " \
+        "because a file already exists at that path. Either remove or rename the file so the directory can be created."
+    end
+
     def configured_bundle_path
       @configured_bundle_path ||= settings.path.tap(&:validate!)
     end
@@ -198,7 +211,7 @@ module Bundler
 
     def frozen_bundle?
       frozen = settings[:deployment]
-      frozen ||= settings[:frozen] unless feature_flag.deployment_means_frozen?
+      frozen ||= settings[:frozen]
       frozen
     end
 
@@ -212,6 +225,12 @@ module Bundler
         end
     end
 
+    def most_specific_locked_platform?(platform)
+      return false unless defined?(@definition) && @definition
+
+      definition.most_specific_locked_platform == platform
+    end
+
     def ruby_scope
       "#{Bundler.rubygems.ruby_engine}/#{RbConfig::CONFIG["ruby_version"]}"
     end
@@ -230,8 +249,9 @@ module Bundler
         end
 
         if warning
-          user_home = tmp_home_path(warning)
-          Bundler.ui.warn "#{warning}\nBundler will use `#{user_home}' as your home directory temporarily.\n"
+          Bundler.ui.warn "#{warning}\n"
+          user_home = tmp_home_path
+          Bundler.ui.warn "Bundler will use `#{user_home}' as your home directory temporarily.\n"
           user_home
         else
           Pathname.new(home)
@@ -285,7 +305,13 @@ module Bundler
 
     def app_config_path
       if app_config = ENV["BUNDLE_APP_CONFIG"]
-        Pathname.new(app_config).expand_path(root)
+        app_config_pathname = Pathname.new(app_config)
+
+        if app_config_pathname.absolute?
+          app_config_pathname
+        else
+          app_config_pathname.expand_path(root)
+        end
       else
         root.join(".bundle")
       end
@@ -305,9 +331,9 @@ module Bundler
       FileUtils.remove_entry_secure(path) if path && File.exist?(path)
     rescue ArgumentError
       message = <<EOF
-It is a security vulnerability to allow your home directory to be world-writable, and bundler can not continue.
+It is a security vulnerability to allow your home directory to be world-writable, and bundler cannot continue.
 You should probably consider fixing this issue by running `chmod o-w ~` on *nix.
-Please refer to https://ruby-doc.org/stdlib-2.1.2/libdoc/fileutils/rdoc/FileUtils.html#method-c-remove_entry_secure for details.
+Please refer to https://ruby-doc.org/stdlib-3.1.2/libdoc/fileutils/rdoc/FileUtils.html#method-c-remove_entry_secure for details.
 EOF
       File.world_writable?(path) ? Bundler.ui.warn(message) : raise
       raise PathError, "Please fix the world-writable issue with your #{path} directory"
@@ -347,12 +373,15 @@ EOF
       env.delete_if {|k, _| k[0, 7] == "BUNDLE_" }
 
       if env.key?("RUBYOPT")
-        env["RUBYOPT"] = env["RUBYOPT"].sub "-rbundler/setup", ""
+        rubyopt = env["RUBYOPT"].split(" ")
+        rubyopt.delete("-r#{File.expand_path("bundler/setup", __dir__)}")
+        rubyopt.delete("-rbundler/setup")
+        env["RUBYOPT"] = rubyopt.join(" ")
       end
 
       if env.key?("RUBYLIB")
         rubylib = env["RUBYLIB"].split(File::PATH_SEPARATOR)
-        rubylib.delete(File.expand_path("..", __FILE__))
+        rubylib.delete(__dir__)
         env["RUBYLIB"] = rubylib.join(File::PATH_SEPARATOR)
       end
 
@@ -426,7 +455,7 @@ EOF
     end
 
     def local_platform
-      return Gem::Platform::RUBY if settings[:force_ruby_platform]
+      return Gem::Platform::RUBY if settings[:force_ruby_platform] || Gem.platforms == [Gem::Platform::RUBY]
       Gem::Platform.local
     end
 
@@ -447,10 +476,14 @@ EOF
       # system binaries. If you put '-n foo' in your .gemrc, RubyGems will
       # install binstubs there instead. Unfortunately, RubyGems doesn't expose
       # that directory at all, so rather than parse .gemrc ourselves, we allow
-      # the directory to be set as well, via `bundle config set bindir foo`.
+      # the directory to be set as well, via `bundle config set --local bindir foo`.
       Bundler.settings[:system_bindir] || Bundler.rubygems.gem_bindir
     end
 
+    def preferred_gemfile_name
+      Bundler.settings[:init_gems_rb] ? "gems.rb" : "Gemfile"
+    end
+
     def use_system_gems?
       configured_bundle_path.use_system_gems?
     end
@@ -512,7 +545,8 @@ EOF
         Your user account isn't allowed to install to the system RubyGems.
         You can cancel this installation and run:
 
-            bundle install --path vendor/bundle
+            bundle config set --local path 'vendor/bundle'
+            bundle install
 
         to install the gems into ./vendor/bundle/, or you can enter your password
         and install the bundled gems to RubyGems using sudo.
@@ -538,7 +572,7 @@ EOF
 
     def load_marshal(data)
       Marshal.load(data)
-    rescue StandardError => e
+    rescue TypeError => e
       raise MarshalError, "#{e.class}: #{e.message}"
     end
 
@@ -588,6 +622,11 @@ EOF
       reset_rubygems!
     end
 
+    def reset_settings_and_root!
+      @settings = nil
+      @root = nil
+    end
+
     def reset_paths!
       @bin_path = nil
       @bundler_major_version = nil
@@ -610,15 +649,26 @@ EOF
       @rubygems = nil
     end
 
-  private
+    def configure_gem_home_and_path(path = bundle_path)
+      configure_gem_path
+      configure_gem_home(path)
+      Bundler.rubygems.clear_paths
+    end
+
+    def self_manager
+      @self_manager ||= begin
+                          require_relative "bundler/self_manager"
+                          Bundler::SelfManager.new
+                        end
+    end
+
+    private
 
     def eval_yaml_gemspec(path, contents)
-      require_relative "bundler/psyched_yaml"
+      Kernel.require "psych"
 
-      # If the YAML is invalid, Syck raises an ArgumentError, and Psych
-      # raises a Psych::SyntaxError. See psyched_yaml.rb for more info.
       Gem::Specification.from_yaml(contents)
-    rescue YamlLibrarySyntaxError, ArgumentError, Gem::EndOfYAMLException, Gem::Exception
+    rescue ::Psych::SyntaxError, ArgumentError, Gem::EndOfYAMLException, Gem::Exception
       eval_gemspec(path, contents)
     end
 
@@ -627,47 +677,29 @@ EOF
     rescue ScriptError, StandardError => e
       msg = "There was an error while loading `#{path.basename}`: #{e.message}"
 
-      if e.is_a?(LoadError)
-        msg += "\nDoes it try to require a relative path? That's been removed in Ruby 1.9"
-      end
-
       raise GemspecError, Dsl::DSLError.new(msg, path, e.backtrace, contents)
     end
 
-    def configure_gem_home_and_path
-      configure_gem_path
-      configure_gem_home
-      bundle_path
-    end
-
-    def configure_gem_path(env = ENV)
-      blank_home = env["GEM_HOME"].nil? || env["GEM_HOME"].empty?
-      if !use_system_gems?
+    def configure_gem_path
+      unless use_system_gems?
         # this needs to be empty string to cause
         # PathSupport.split_gem_path to only load up the
         # Bundler --path setting as the GEM_PATH.
-        env["GEM_PATH"] = ""
-      elsif blank_home
-        possibles = [Bundler.rubygems.gem_dir, Bundler.rubygems.gem_path]
-        paths = possibles.flatten.compact.uniq.reject(&:empty?)
-        env["GEM_PATH"] = paths.join(File::PATH_SEPARATOR)
+        Bundler::SharedHelpers.set_env "GEM_PATH", ""
       end
     end
 
-    def configure_gem_home
-      Bundler::SharedHelpers.set_env "GEM_HOME", File.expand_path(bundle_path, root)
-      Bundler.rubygems.clear_paths
+    def configure_gem_home(path)
+      Bundler::SharedHelpers.set_env "GEM_HOME", path.to_s
     end
 
-    def tmp_home_path(warning)
+    def tmp_home_path
       Kernel.send(:require, "tmpdir")
       SharedHelpers.filesystem_access(Dir.tmpdir) do
         path = Bundler.tmp
         at_exit { Bundler.rm_rf(path) }
         path
       end
-    rescue RuntimeError => e
-      raise e.exception("#{warning}\nBundler also failed to create a temporary home directory':\n#{e}")
     end
 
     # @param env [Hash]
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/.document
@@ -0,0 +1 @@
+# not in RDoc
--- ruby2.7-2.7.6.orig/lib/bundler/build_metadata.rb
+++ ruby2.7-2.7.6/lib/bundler/build_metadata.rb
@@ -27,19 +27,11 @@ module Bundler
 
       # If Bundler has been installed without its .git directory and without a
       # commit instance variable then we can't determine its commits SHA.
-      git_dir = File.join(File.expand_path("../../..", __FILE__), ".git")
+      git_dir = File.expand_path("../../../.git", __dir__)
       if File.directory?(git_dir)
         return @git_commit_sha = Dir.chdir(git_dir) { `git rev-parse --short HEAD`.strip.freeze }
       end
 
-      # If Bundler is a submodule in RubyGems, get the submodule commit
-      git_sub_dir = File.join(File.expand_path("../../../..", __FILE__), ".git")
-      if File.directory?(git_sub_dir)
-        return @git_commit_sha = Dir.chdir(git_sub_dir) do
-          `git ls-tree --abbrev=8 HEAD bundler`.split(/\s/).fetch(2, "").strip.freeze
-        end
-      end
-
       @git_commit_sha ||= "unknown"
     end
 
--- ruby2.7-2.7.6.orig/lib/bundler/bundler.gemspec
+++ ruby2.7-2.7.6/lib/bundler/bundler.gemspec
@@ -22,23 +22,23 @@ Gem::Specification.new do |s|
   s.summary     = "The best way to manage your application's dependencies"
   s.description = "Bundler manages an application's dependencies through its entire life, across many machines, systematically and repeatably"
 
-  if s.respond_to?(:metadata=)
-    s.metadata = {
-      "bug_tracker_uri" => "https://github.com/bundler/bundler/issues",
-      "changelog_uri" => "https://github.com/bundler/bundler/blob/master/CHANGELOG.md",
-      "homepage_uri" => "https://bundler.io/",
-      "source_code_uri" => "https://github.com/bundler/bundler/",
-    }
-  end
+  s.metadata = {
+    "bug_tracker_uri" => "https://github.com/rubygems/rubygems/issues?q=is%3Aopen+is%3Aissue+label%3ABundler",
+    "changelog_uri" => "https://github.com/rubygems/rubygems/blob/master/bundler/CHANGELOG.md",
+    "homepage_uri" => "https://bundler.io/",
+    "source_code_uri" => "https://github.com/rubygems/rubygems/tree/master/bundler",
+  }
 
   s.required_ruby_version     = ">= 2.3.0"
   s.required_rubygems_version = ">= 2.5.2"
 
-  s.files = (Dir.glob("lib/bundler/**/*", File::FNM_DOTMATCH) + Dir.glob("man/bundler*") + Dir.glob("libexec/bundle*")).reject {|f| File.directory?(f) }
+  s.files = Dir.glob("lib/bundler{.rb,/**/*}", File::FNM_DOTMATCH).reject {|f| File.directory?(f) }
 
-  s.files += ["lib/bundler.rb"]
+  # include the gemspec itself because warbler breaks w/o it
+  s.files += %w[bundler.gemspec]
 
-  s.bindir        = "libexec"
+  s.files += %w[CHANGELOG.md LICENSE.md README.md]
+  s.bindir        = "exe"
   s.executables   = %w[bundle bundler]
   s.require_paths = ["lib"]
 end
--- ruby2.7-2.7.6.orig/lib/bundler/cli.rb
+++ ruby2.7-2.7.6/lib/bundler/cli.rb
@@ -14,6 +14,7 @@ module Bundler
     COMMAND_ALIASES = {
       "check" => "c",
       "install" => "i",
+      "plugin" => "",
       "list" => "ls",
       "exec" => ["e", "ex", "exe"],
       "cache" => ["package", "pack"],
@@ -57,9 +58,11 @@ module Bundler
       custom_gemfile = options[:gemfile] || Bundler.settings[:gemfile]
       if custom_gemfile && !custom_gemfile.empty?
         Bundler::SharedHelpers.set_env "BUNDLE_GEMFILE", File.expand_path(custom_gemfile)
-        Bundler.reset_paths!
+        Bundler.reset_settings_and_root!
       end
 
+      Bundler.self_manager.restart_with_locked_bundler_if_needed
+
       Bundler.settings.set_command_option_if_given :retry, options[:retry]
 
       current_cmd = args.last[:current_command].name
@@ -72,14 +75,6 @@ module Bundler
       Bundler.ui = UI::Shell.new(options)
       Bundler.ui.level = "debug" if options["verbose"]
       unprinted_warnings.each {|w| Bundler.ui.warn(w) }
-
-      if ENV["RUBYGEMS_GEMDEPS"] && !ENV["RUBYGEMS_GEMDEPS"].empty?
-        Bundler.ui.warn(
-          "The RUBYGEMS_GEMDEPS environment variable is set. This enables RubyGems' " \
-          "experimental Gemfile mode, which may conflict with Bundler and cause unexpected errors. " \
-          "To remove this warning, unset RUBYGEMS_GEMDEPS.", :wrap => true
-        )
-      end
     end
 
     check_unknown_options!(:except => [:config, :exec])
@@ -122,16 +117,17 @@ module Bundler
       else command = "bundle-#{cli}"
       end
 
-      man_path  = File.expand_path("../../../man", __FILE__)
-      man_pages = Hash[Dir.glob(File.join(man_path, "*")).grep(/.*\.\d*\Z/).collect do |f|
+      man_path = File.expand_path("man", __dir__)
+      man_pages = Hash[Dir.glob(File.join(man_path, "**", "*")).grep(/.*\.\d*\Z/).collect do |f|
         [File.basename(f, ".*"), f]
       end]
 
       if man_pages.include?(command)
+        man_page = man_pages[command]
         if Bundler.which("man") && man_path !~ %r{^file:/.+!/META-INF/jruby.home/.+}
-          Kernel.exec "man #{man_pages[command]}"
+          Kernel.exec "man #{man_page}"
         else
-          puts File.read("#{man_path}/#{File.basename(man_pages[command])}.txt")
+          puts File.read("#{man_path}/#{File.basename(man_page)}.ronn")
         end
       elsif command_path = Bundler.which("bundler-#{cli}")
         Kernel.exec(command_path, "--help")
@@ -190,6 +186,7 @@ module Bundler
     method_option "install", :type => :boolean, :banner =>
       "Runs 'bundle install' after removing the gems from the Gemfile"
     def remove(*gems)
+      SharedHelpers.major_deprecation(2, "The `--install` flag has been deprecated. `bundle install` is triggered by default.") if ARGV.include?("--install")
       require_relative "cli/remove"
       Remove.new(gems, options).run
     end
@@ -221,6 +218,8 @@ module Bundler
       "Specify the number of jobs to run in parallel"
     method_option "local", :type => :boolean, :banner =>
       "Do not attempt to fetch gems remotely and use the gem cache instead"
+    method_option "prefer-local", :type => :boolean, :banner =>
+      "Only attempt to fetch gems remotely if not present locally, even if newer versions are available remotely"
     method_option "no-cache", :type => :boolean, :banner =>
       "Don't update the existing gem cache."
     method_option "redownload", :type => :boolean, :aliases => "--force", :banner =>
@@ -239,7 +238,7 @@ module Bundler
       "Install to the system location ($BUNDLE_PATH or $GEM_HOME) even if the bundle was previously installed somewhere else for this application"
     method_option "trust-policy", :alias => "P", :type => :string, :banner =>
       "Gem trust policy (like gem install -P). Must be one of " +
-        Bundler.rubygems.security_policy_keys.join("|")
+      Bundler.rubygems.security_policy_keys.join("|")
     method_option "without", :type => :array, :banner =>
       "Exclude gems that are part of the specified named group."
     method_option "with", :type => :array, :banner =>
@@ -247,10 +246,12 @@ module Bundler
     def install
       SharedHelpers.major_deprecation(2, "The `--force` option has been renamed to `--redownload`") if ARGV.include?("--force")
 
-      %w[clean deployment frozen no-cache no-prune path shebang system without with].each do |option|
+      %w[clean deployment frozen no-prune path shebang system without with].each do |option|
         remembered_flag_deprecation(option)
       end
 
+      remembered_negative_flag_deprecation("no-deployment")
+
       require_relative "cli/install"
       Bundler.settings.temporary(:no_install => false) do
         Install.new(options.dup).run
@@ -305,45 +306,25 @@ module Bundler
       end
     end
 
-    unless Bundler.feature_flag.bundler_3_mode?
-      desc "show GEM [OPTIONS]", "Shows all gems that are part of the bundle, or the path to a given gem"
-      long_desc <<-D
-        Show lists the names and versions of all gems that are required by your Gemfile.
-        Calling show with [GEM] will list the exact location of that gem on your machine.
-      D
-      method_option "paths", :type => :boolean,
-                             :banner => "List the paths of all gems that are required by your Gemfile."
-      method_option "outdated", :type => :boolean,
-                                :banner => "Show verbose output including whether gems are outdated."
-      def show(gem_name = nil)
-        if ARGV[0] == "show"
-          rest = ARGV[1..-1]
-
-          if flag = rest.find{|arg| ["--verbose", "--outdated"].include?(arg) }
-            Bundler::SharedHelpers.major_deprecation(2, "the `#{flag}` flag to `bundle show` was undocumented and will be removed without replacement")
-          else
-            new_command = rest.find {|arg| !arg.start_with?("--") } ? "info" : "list"
-
-            new_arguments = rest.map do |arg|
-              next arg if arg != "--paths"
-              next "--path" if new_command == "info"
-            end
-
-            old_argv = ARGV.join(" ")
-            new_argv = [new_command, *new_arguments.compact].join(" ")
-
-            Bundler::SharedHelpers.major_deprecation(2, "use `bundle #{new_argv}` instead of `bundle #{old_argv}`")
-          end
-        end
-        require_relative "cli/show"
-        Show.new(options, gem_name).run
-      end
+    desc "show GEM [OPTIONS]", "Shows all gems that are part of the bundle, or the path to a given gem"
+    long_desc <<-D
+      Show lists the names and versions of all gems that are required by your Gemfile.
+      Calling show with [GEM] will list the exact location of that gem on your machine.
+    D
+    method_option "paths", :type => :boolean,
+                           :banner => "List the paths of all gems that are required by your Gemfile."
+    method_option "outdated", :type => :boolean,
+                              :banner => "Show verbose output including whether gems are outdated."
+    def show(gem_name = nil)
+      SharedHelpers.major_deprecation(2, "the `--outdated` flag to `bundle show` was undocumented and will be removed without replacement") if ARGV.include?("--outdated")
+      require_relative "cli/show"
+      Show.new(options, gem_name).run
     end
 
     desc "list", "List all gems in the bundle"
     method_option "name-only", :type => :boolean, :banner => "print only the gem names"
-    method_option "only-group", :type => :string, :banner => "print gems from a particular group"
-    method_option "without-group", :type => :string, :banner => "print all gems except from a group"
+    method_option "only-group", :type => :array, :default => [], :banner => "print gems from a given set of groups"
+    method_option "without-group", :type => :array, :default => [], :banner => "print all gems except from a given set of groups"
     method_option "paths", :type => :boolean, :banner => "print the path to each gem in the bundle"
     def list
       require_relative "cli/list"
@@ -354,6 +335,7 @@ module Bundler
 
     desc "info GEM [OPTIONS]", "Show information for the given gem"
     method_option "path", :type => :boolean, :banner => "Print full path to gem"
+    method_option "version", :type => :boolean, :banner => "Print gem version"
     def info(gem_name)
       require_relative "cli/info"
       Info.new(options, gem_name).run
@@ -375,6 +357,8 @@ module Bundler
       "Make binstubs that can work without the Bundler runtime"
     method_option "all", :type => :boolean, :banner =>
       "Install binstubs for all gems"
+    method_option "all-platforms", :type => :boolean, :default => false, :banner =>
+      "Install binstubs for all platforms"
     def binstubs(*gems)
       require_relative "cli/binstubs"
       Binstubs.new(options, gems).run
@@ -387,8 +371,12 @@ module Bundler
     method_option "version", :aliases => "-v", :type => :string
     method_option "group", :aliases => "-g", :type => :string
     method_option "source", :aliases => "-s", :type => :string
+    method_option "require", :aliases => "-r", :type => :string, :banner => "Adds require path to gem. Provide false, or a path as a string."
+    method_option "path", :type => :string
     method_option "git", :type => :string
+    method_option "github", :type => :string
     method_option "branch", :type => :string
+    method_option "ref", :type => :string
     method_option "skip-install", :type => :boolean, :banner =>
       "Adds gem to the Gemfile but does not install it"
     method_option "optimistic", :type => :boolean, :banner => "Adds optimistic declaration of version to gem"
@@ -406,7 +394,7 @@ module Bundler
       are up to date, Bundler will exit with a status of 0. Otherwise, it will exit 1.
 
       For more information on patch level options (--major, --minor, --patch,
-      --update-strict) see documentation on the same options on the update command.
+      --strict) see documentation on the same options on the update command.
     D
     method_option "group", :type => :string, :banner => "List gems from a specific group"
     method_option "groups", :type => :boolean, :banner => "List gems organized by groups"
@@ -414,10 +402,9 @@ module Bundler
       "Do not attempt to fetch gems remotely and use the gem cache instead"
     method_option "pre", :type => :boolean, :banner => "Check for newer pre-release gems"
     method_option "source", :type => :array, :banner => "Check against a specific source"
-    strict_is_update = Bundler.feature_flag.forget_cli_options?
-    method_option "filter-strict", :type => :boolean, :aliases => strict_is_update ? [] : %w[--strict], :banner =>
+    method_option "filter-strict", :type => :boolean, :aliases => "--strict", :banner =>
       "Only list newer versions allowed by your Gemfile requirements"
-    method_option "update-strict", :type => :boolean, :aliases => strict_is_update ? %w[--strict] : [], :banner =>
+    method_option "update-strict", :type => :boolean, :banner =>
       "Strict conservative resolution, do not allow any gem to be updated past latest --patch | --minor | --major"
     method_option "minor", :type => :boolean, :banner => "Prefer updating only to next minor version"
     method_option "major", :type => :boolean, :banner => "Prefer updating to next major version (default)"
@@ -434,11 +421,18 @@ module Bundler
       Outdated.new(options, gems).run
     end
 
-    desc "cache [OPTIONS]", "Locks and then caches all of the gems into vendor/cache"
-    unless Bundler.feature_flag.cache_all?
-      method_option "all",  :type => :boolean,
-                            :banner => "Include all sources (including path and git)."
+    desc "fund [OPTIONS]", "Lists information about gems seeking funding assistance"
+    method_option "group", :aliases => "-g", :type => :array, :banner =>
+      "Fetch funding information for a specific group"
+    def fund
+      require_relative "cli/fund"
+      Fund.new(options).run
     end
+
+    desc "cache [OPTIONS]", "Locks and then caches all of the gems into vendor/cache"
+    method_option "all",  :type => :boolean,
+                          :default => Bundler.feature_flag.cache_all?,
+                          :banner => "Include all sources (including path and git)."
     method_option "all-platforms", :type => :boolean, :banner => "Include gems for all platforms present in the lockfile, not only the current one"
     method_option "cache-path", :type => :string, :banner =>
       "Specify a different cache path than the default (vendor/cache)."
@@ -457,6 +451,18 @@ module Bundler
       bundle without having to download any additional gems.
     D
     def cache
+      SharedHelpers.major_deprecation 2,
+        "The `--all` flag is deprecated because it relies on being " \
+        "remembered across bundler invocations, which bundler will no longer " \
+        "do in future versions. Instead please use `bundle config set cache_all true`, " \
+        "and stop using this flag" if ARGV.include?("--all")
+
+      SharedHelpers.major_deprecation 2,
+        "The `--path` flag is deprecated because its semantics are unclear. " \
+        "Use `bundle config cache_path` to configure the path of your cache of gems, " \
+        "and `bundle config path` to configure the path where your gems are installed, " \
+        "and stop using this flag" if ARGV.include?("--path")
+
       require_relative "cli/cache"
       Cache.new(options).run
     end
@@ -464,7 +470,7 @@ module Bundler
     map aliases_for("cache")
 
     desc "exec [OPTIONS]", "Run the command in context of the bundle"
-    method_option :keep_file_descriptors, :type => :boolean, :default => false
+    method_option :keep_file_descriptors, :type => :boolean, :default => true
     method_option :gemfile, :type => :string, :required => false
     long_desc <<-D
       Exec runs a command, providing it access to the gems in the bundle. While using
@@ -472,6 +478,10 @@ module Bundler
       into the system wide RubyGems repository.
     D
     def exec(*args)
+      if ARGV.include?("--no-keep-file-descriptors")
+        SharedHelpers.major_deprecation(2, "The `--no-keep-file-descriptors` has been deprecated. `bundle exec` no longer mess with your file descriptors. Close them in the exec'd script if you need to")
+      end
+
       require_relative "cli/exec"
       Exec.new(options, args).run
     end
@@ -486,8 +496,8 @@ module Bundler
       By default, setting a configuration value sets it for all projects
       on the machine.
 
-      If a global setting is superceded by local configuration, this command
-      will show the current value, as well as any superceded values and
+      If a global setting is superseded by local configuration, this command
+      will show the current value, as well as any superseded values and
       where they were specified.
     D
     require_relative "cli/config"
@@ -507,7 +517,7 @@ module Bundler
       end
     end
 
-    desc "version", "Prints the bundler's version information"
+    desc "version", "Prints Bundler version information"
     def version
       cli_help = current_command.name == "cli_help"
       if cli_help || ARGV.include?("version")
@@ -550,7 +560,7 @@ module Bundler
       method_option :version, :type => :boolean, :default => false, :aliases => "-v", :desc => "Set to show each gem version."
       method_option :without, :type => :array, :default => [], :aliases => "-W", :banner => "GROUP[ GROUP...]", :desc => "Exclude gems that are part of the specified named group."
       def viz
-        SharedHelpers.major_deprecation 2, "The `viz` command has been moved to the `bundle-viz` gem, see https://github.com/bundler/bundler-viz"
+        SharedHelpers.major_deprecation 2, "The `viz` command has been renamed to `graph` and moved to a plugin. See https://github.com/rubygems/bundler-graph"
         require_relative "cli/viz"
         Viz.new(options.dup).run
       end
@@ -560,15 +570,23 @@ module Bundler
 
     desc "gem NAME [OPTIONS]", "Creates a skeleton for creating a rubygem"
     method_option :exe, :type => :boolean, :default => false, :aliases => ["--bin", "-b"], :desc => "Generate a binary executable for your library."
-    method_option :coc, :type => :boolean, :desc => "Generate a code of conduct file. Set a default with `bundle config set gem.coc true`."
+    method_option :coc, :type => :boolean, :desc => "Generate a code of conduct file. Set a default with `bundle config set --global gem.coc true`."
     method_option :edit, :type => :string, :aliases => "-e", :required => false, :banner => "EDITOR",
                          :lazy_default => [ENV["BUNDLER_EDITOR"], ENV["VISUAL"], ENV["EDITOR"]].find {|e| !e.nil? && !e.empty? },
                          :desc => "Open generated gemspec in the specified editor (defaults to $EDITOR or $BUNDLER_EDITOR)"
     method_option :ext, :type => :boolean, :default => false, :desc => "Generate the boilerplate for C extension code"
     method_option :git, :type => :boolean, :default => true, :desc => "Initialize a git repo inside your library."
-    method_option :mit, :type => :boolean, :desc => "Generate an MIT license file. Set a default with `bundle config set gem.mit true`."
-    method_option :test, :type => :string, :lazy_default => "rspec", :aliases => "-t", :banner => "rspec",
-                         :desc => "Generate a test directory for your library, either rspec or minitest. Set a default with `bundle config set gem.test rspec`."
+    method_option :mit, :type => :boolean, :desc => "Generate an MIT license file. Set a default with `bundle config set --global gem.mit true`."
+    method_option :rubocop, :type => :boolean, :desc => "Add rubocop to the generated Rakefile and gemspec. Set a default with `bundle config set --global gem.rubocop true`."
+    method_option :changelog, :type => :boolean, :desc => "Generate changelog file. Set a default with `bundle config set --global gem.changelog true`."
+    method_option :test, :type => :string, :lazy_default => Bundler.settings["gem.test"] || "", :aliases => "-t", :banner => "Use the specified test framework for your library",
+                         :desc => "Generate a test directory for your library, either rspec, minitest or test-unit. Set a default with `bundle config set --global gem.test (rspec|minitest|test-unit)`."
+    method_option :ci, :type => :string, :lazy_default => Bundler.settings["gem.ci"] || "",
+                       :desc => "Generate CI configuration, either GitHub Actions, Travis CI, GitLab CI or CircleCI. Set a default with `bundle config set --global gem.ci (github|travis|gitlab|circle)`"
+    method_option :linter, :type => :string, :lazy_default => Bundler.settings["gem.linter"] || "",
+                           :desc => "Add a linter and code formatter, either RuboCop or Standard. Set a default with `bundle config set --global gem.linter (rubocop|standard)`"
+    method_option :github_username, :type => :string, :default => Bundler.settings["gem.github_username"], :banner => "Set your username on GitHub", :desc => "Fill in GitHub username on README so that you don't have to do it manually. Set a default with `bundle config set --global gem.github_username <your_username>`."
+
     def gem(name)
     end
 
@@ -595,7 +613,7 @@ module Bundler
     private :gem
 
     def self.source_root
-      File.expand_path(File.join(File.dirname(__FILE__), "templates"))
+      File.expand_path("templates", __dir__)
     end
 
     desc "clean [OPTIONS]", "Cleans up unused gems in your bundler directory", :hide => true
@@ -731,11 +749,11 @@ module Bundler
       end
     end
 
-  private
+    private
 
     # Automatically invoke `bundle install` and resume if
     # Bundler.settings[:auto_install] exists. This is set through config cmd
-    # `bundle config set auto_install 1`.
+    # `bundle config set --global auto_install 1`.
     #
     # Note that this method `nil`s out the global Definition object, so it
     # should be called first, before you instantiate anything like an
@@ -793,35 +811,40 @@ module Bundler
 
       current = Gem::Version.new(VERSION)
       return if current >= latest
-      latest_installed = Bundler.rubygems.find_name("bundler").map(&:version).max
 
-      installation = "To install the latest version, run `gem install bundler#{" --pre" if latest.prerelease?}`"
-      if latest_installed && latest_installed > current
-        suggestion = "To update to the most recent installed version (#{latest_installed}), run `bundle update --bundler`"
-        suggestion = "#{installation}\n#{suggestion}" if latest_installed < latest
-      else
-        suggestion = installation
-      end
-
-      Bundler.ui.warn "The latest bundler is #{latest}, but you are currently running #{current}.\n#{suggestion}"
+      Bundler.ui.warn \
+        "The latest bundler is #{latest}, but you are currently running #{current}.\n" \
+        "To update to the most recent version, run `bundle update --bundler`"
     rescue RuntimeError
       nil
     end
 
+    def remembered_negative_flag_deprecation(name)
+      positive_name = name.gsub(/\Ano-/, "")
+      option = current_command.options[positive_name]
+      flag_name = "--no-" + option.switch_name.gsub(/\A--/, "")
+
+      flag_deprecation(positive_name, flag_name, option)
+    end
+
     def remembered_flag_deprecation(name)
       option = current_command.options[name]
       flag_name = option.switch_name
 
-      name_index = ARGV.find {|arg| flag_name == arg }
+      flag_deprecation(name, flag_name, option)
+    end
+
+    def flag_deprecation(name, flag_name, option)
+      name_index = ARGV.find {|arg| flag_name == arg.split("=")[0] }
       return unless name_index
 
       value = options[name]
       value = value.join(" ").to_s if option.type == :array
 
-      Bundler::SharedHelpers.major_deprecation 2,\
+      Bundler::SharedHelpers.major_deprecation 2,
         "The `#{flag_name}` flag is deprecated because it relies on being " \
         "remembered across bundler invocations, which bundler will no longer " \
-        "do in future versions. Instead please use `bundle config set #{name} " \
+        "do in future versions. Instead please use `bundle config set --local #{name.tr("-", "_")} " \
         "'#{value}'`, and stop using this flag"
     end
   end
--- ruby2.7-2.7.6.orig/lib/bundler/cli/add.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/add.rb
@@ -17,7 +17,7 @@ module Bundler
       perform_bundle_install unless options["skip-install"]
     end
 
-  private
+    private
 
     def perform_bundle_install
       Installer.install(Bundler.root, Bundler.definition)
--- ruby2.7-2.7.6.orig/lib/bundler/cli/binstubs.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/binstubs.rb
@@ -16,7 +16,11 @@ module Bundler
       Bundler.settings.set_command_option_if_given :shebang, options["shebang"]
       installer = Installer.new(Bundler.root, Bundler.definition)
 
-      installer_opts = { :force => options[:force], :binstubs_cmd => true }
+      installer_opts = {
+        :force => options[:force],
+        :binstubs_cmd => true,
+        :all_platforms => options["all-platforms"],
+      }
 
       if options[:all]
         raise InvalidOption, "Cannot specify --all with specific gems" unless gems.empty?
@@ -38,7 +42,7 @@ module Bundler
         if options[:standalone]
           next Bundler.ui.warn("Sorry, Bundler can only be run via RubyGems.") if gem_name == "bundler"
           Bundler.settings.temporary(:path => (Bundler.settings[:path] || Bundler.root)) do
-            installer.generate_standalone_bundler_executable_stubs(spec)
+            installer.generate_standalone_bundler_executable_stubs(spec, installer_opts)
           end
         else
           installer.generate_bundler_executable_stubs(spec, installer_opts)
--- ruby2.7-2.7.6.orig/lib/bundler/cli/cache.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/cache.rb
@@ -9,7 +9,7 @@ module Bundler
     end
 
     def run
-      Bundler.ui.level = "error" if options[:quiet]
+      Bundler.ui.level = "warn" if options[:quiet]
       Bundler.settings.set_command_option_if_given :path, options[:path]
       Bundler.settings.set_command_option_if_given :cache_path, options["cache-path"]
 
@@ -24,12 +24,13 @@ module Bundler
       end
     end
 
-  private
+    private
 
     def install
       require_relative "install"
       options = self.options.dup
       options["local"] = false if Bundler.settings[:cache_all_platforms]
+      options["no-cache"] = true
       Bundler::CLI::Install.new(options).run
     end
 
@@ -37,12 +38,6 @@ module Bundler
       all = options.fetch(:all, Bundler.feature_flag.cache_all? || nil)
 
       Bundler.settings.set_command_option_if_given :cache_all, all
-
-      if Bundler.definition.has_local_dependencies? && !Bundler.feature_flag.cache_all?
-        Bundler.ui.warn "Your Gemfile contains path and git dependencies. If you want "    \
-          "to cache them as well, please pass the --all flag. This will be the default " \
-          "on Bundler 3.0."
-      end
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/cli/check.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/check.rb
@@ -11,9 +11,11 @@ module Bundler
     def run
       Bundler.settings.set_command_option_if_given :path, options[:path]
 
+      definition = Bundler.definition
+      definition.validate_runtime!
+
       begin
-        definition = Bundler.definition
-        definition.validate_runtime!
+        definition.resolve_only_locally!
         not_installed = definition.missing_specs
       rescue GemNotFound, VersionConflict
         Bundler.ui.error "Bundler can't satisfy your Gemfile's dependencies."
--- ruby2.7-2.7.6.orig/lib/bundler/cli/clean.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/clean.rb
@@ -13,7 +13,7 @@ module Bundler
       Bundler.load.clean(options[:"dry-run"])
     end
 
-  protected
+    protected
 
     def require_path_or_force
       return unless Bundler.use_system_gems? && !options[:force]
--- ruby2.7-2.7.6.orig/lib/bundler/cli/common.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/common.rb
@@ -14,6 +14,21 @@ module Bundler
       Bundler.ui.info msg
     end
 
+    def self.output_fund_metadata_summary
+      return if Bundler.settings["ignore_funding_requests"]
+      definition = Bundler.definition
+      current_dependencies = definition.requested_dependencies
+      current_specs = definition.specs
+
+      count = current_dependencies.count {|dep| current_specs[dep.name].first.metadata.key?("funding_uri") }
+
+      return if count.zero?
+
+      intro = count > 1 ? "#{count} installed gems you directly depend on are" : "#{count} installed gem you directly depend on is"
+      message = "#{intro} looking for funding.\n  Run `bundle fund` for details"
+      Bundler.ui.info message
+    end
+
     def self.output_without_groups_message(command)
       return if Bundler.settings[:without].empty?
       Bundler.ui.confirm without_groups_message(command)
@@ -22,10 +37,15 @@ module Bundler
     def self.without_groups_message(command)
       command_in_past_tense = command == :install ? "installed" : "updated"
       groups = Bundler.settings[:without]
+      "Gems in the #{verbalize_groups(groups)} were not #{command_in_past_tense}."
+    end
+
+    def self.verbalize_groups(groups)
+      groups.map! {|g| "'#{g}'" }
       group_list = [groups[0...-1].join(", "), groups[-1..-1]].
         reject {|s| s.to_s.empty? }.join(" and ")
       group_str = groups.size == 1 ? "group" : "groups"
-      "Gems in the #{group_str} #{group_list} were not #{command_in_past_tense}."
+      "#{group_str} #{group_list}"
     end
 
     def self.select_spec(name, regex_match = nil)
@@ -39,7 +59,13 @@ module Bundler
 
       case specs.count
       when 0
-        raise GemNotFound, gem_not_found_message(name, Bundler.definition.dependencies)
+        dep_in_other_group = Bundler.definition.current_dependencies.find {|dep|dep.name == name }
+
+        if dep_in_other_group
+          raise GemNotFound, "Could not find gem '#{name}', because it's in the #{verbalize_groups(dep_in_other_group.groups)}, configured to be ignored."
+        else
+          raise GemNotFound, gem_not_found_message(name, Bundler.definition.dependencies)
+        end
       when 1
         specs.first
       else
@@ -69,6 +95,8 @@ module Bundler
     end
 
     def self.ensure_all_gems_in_lockfile!(names, locked_gems = Bundler.locked_gems)
+      return unless locked_gems
+
       locked_names = locked_gems.specs.map(&:name).uniq
       names.-(locked_names).each do |g|
         raise GemNotFound, gem_not_found_message(g, locked_names)
@@ -82,7 +110,7 @@ module Bundler
 
       definition.gem_version_promoter.tap do |gvp|
         gvp.level = patch_level.first || :major
-        gvp.strict = options[:strict] || options["update-strict"] || options["filter-strict"]
+        gvp.strict = options[:strict] || options["filter-strict"]
       end
     end
 
--- ruby2.7-2.7.6.orig/lib/bundler/cli/config.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/config.rb
@@ -180,7 +180,7 @@ module Bundler
         scopes = %w[global local].select {|s| options[s] }
         case scopes.size
         when 0
-          @scope = "global"
+          @scope = inside_app? ? "local" : "global"
           @explicit_scope = false
         when 1
           @scope = scopes.first
@@ -189,6 +189,15 @@ module Bundler
             "The options #{scopes.join " and "} were specified. Please only use one of the switches at a time."
         end
       end
+
+      private
+
+      def inside_app?
+        Bundler.root
+        true
+      rescue GemfileNotFound
+        false
+      end
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/cli/console.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/console.rb
@@ -12,7 +12,7 @@ module Bundler
       Bundler::SharedHelpers.major_deprecation 2, "bundle console will be replaced " \
                            "by `bin/console` generated by `bundle gem <name>`"
 
-      group ? Bundler.require(:default, *group.split.map!(&:to_sym)) : Bundler.require
+      group ? Bundler.require(:default, *group.split(" ").map!(&:to_sym)) : Bundler.require
       ARGV.clear
 
       console = get_console(Bundler.settings[:console] || "irb")
--- ruby2.7-2.7.6.orig/lib/bundler/cli/doctor.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/doctor.rb
@@ -1,6 +1,8 @@
 # frozen_string_literal: true
 
 require "rbconfig"
+require "shellwords"
+require "fiddle"
 
 module Bundler
   class CLI::Doctor
@@ -22,14 +24,14 @@ module Bundler
     end
 
     def dylibs_darwin(path)
-      output = `/usr/bin/otool -L "#{path}"`.chomp
+      output = `/usr/bin/otool -L #{path.shellescape}`.chomp
       dylibs = output.split("\n")[1..-1].map {|l| l.match(DARWIN_REGEX).captures[0] }.uniq
       # ignore @rpath and friends
       dylibs.reject {|dylib| dylib.start_with? "@" }
     end
 
     def dylibs_ldd(path)
-      output = `/usr/bin/ldd "#{path}"`.chomp
+      output = `/usr/bin/ldd #{path.shellescape}`.chomp
       output.split("\n").map do |l|
         match = l.match(LDD_REGEX)
         next if match.nil?
@@ -61,7 +63,7 @@ module Bundler
     end
 
     def run
-      Bundler.ui.level = "error" if options[:quiet]
+      Bundler.ui.level = "warn" if options[:quiet]
       Bundler.settings.validate!
       check!
 
@@ -70,7 +72,14 @@ module Bundler
 
       definition.specs.each do |spec|
         bundles_for_gem(spec).each do |bundle|
-          bad_paths = dylibs(bundle).select {|f| !File.exist?(f) }
+          bad_paths = dylibs(bundle).select do |f|
+            begin
+              Fiddle.dlopen(f)
+              false
+            rescue Fiddle::DLError
+              true
+            end
+          end
           if bad_paths.any?
             broken_links[spec] ||= []
             broken_links[spec].concat(bad_paths)
@@ -93,15 +102,18 @@ module Bundler
       end
     end
 
-  private
+    private
 
     def check_home_permissions
       require "find"
       files_not_readable_or_writable = []
       files_not_rw_and_owned_by_different_user = []
       files_not_owned_by_current_user_but_still_rw = []
+      broken_symlinks = []
       Find.find(Bundler.bundle_path.to_s).each do |f|
-        if !File.writable?(f) || !File.readable?(f)
+        if !File.exist?(f)
+          broken_symlinks << f
+        elsif !File.writable?(f) || !File.readable?(f)
           if File.stat(f).uid != Process.uid
             files_not_rw_and_owned_by_different_user << f
           else
@@ -113,6 +125,13 @@ module Bundler
       end
 
       ok = true
+
+      if broken_symlinks.any?
+        Bundler.ui.warn "Broken links exist in the Bundler home. Please report them to the offending gem's upstream repo. These files are:\n - #{broken_symlinks.join("\n - ")}"
+
+        ok = false
+      end
+
       if files_not_owned_by_current_user_but_still_rw.any?
         Bundler.ui.warn "Files exist in the Bundler home that are owned by another " \
           "user, but are still readable/writable. These files are:\n - #{files_not_owned_by_current_user_but_still_rw.join("\n - ")}"
--- ruby2.7-2.7.6.orig/lib/bundler/cli/exec.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/exec.rb
@@ -12,12 +12,7 @@ module Bundler
       @options = options
       @cmd = args.shift
       @args = args
-
-      if !Bundler.current_ruby.jruby?
-        @args << { :close_others => !options.keep_file_descriptors? }
-      elsif options.keep_file_descriptors?
-        Bundler.ui.warn "Ruby version #{RUBY_VERSION} defaults to keeping non-standard file descriptors on Kernel#exec."
-      end
+      @args << { :close_others => !options.keep_file_descriptors? } unless Bundler.current_ruby.jruby?
     end
 
     def run
@@ -34,7 +29,7 @@ module Bundler
       end
     end
 
-  private
+    private
 
     def validate_cmd!
       return unless cmd.nil?
@@ -63,10 +58,10 @@ module Bundler
       Kernel.load(file)
     rescue SystemExit, SignalException
       raise
-    rescue Exception => e # rubocop:disable Lint/RescueException
+    rescue Exception # rubocop:disable Lint/RescueException
       Bundler.ui.error "bundler: failed to load command: #{cmd} (#{file})"
-      backtrace = e.backtrace ? e.backtrace.take_while {|bt| !bt.start_with?(__FILE__) } : []
-      abort "#{e.class}: #{e.message}\n  #{backtrace.join("\n  ")}"
+      Bundler::FriendlyErrors.disable!
+      raise
     end
 
     def process_title(file, args)
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/cli/fund.rb
@@ -0,0 +1,36 @@
+# frozen_string_literal: true
+
+module Bundler
+  class CLI::Fund
+    attr_reader :options
+
+    def initialize(options)
+      @options = options
+    end
+
+    def run
+      Bundler.definition.validate_runtime!
+
+      groups = Array(options[:group]).map(&:to_sym)
+
+      deps = if groups.any?
+        Bundler.definition.dependencies_for(groups)
+      else
+        Bundler.definition.current_dependencies
+      end
+
+      fund_info = deps.each_with_object([]) do |dep, arr|
+        spec = Bundler.definition.specs[dep.name].first
+        if spec.metadata.key?("funding_uri")
+          arr << "* #{spec.name} (#{spec.version})\n  Funding: #{spec.metadata["funding_uri"]}"
+        end
+      end
+
+      if fund_info.empty?
+        Bundler.ui.info "None of the installed gems you directly depend on are looking for funding."
+      else
+        Bundler.ui.info fund_info.join("\n")
+      end
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/lib/bundler/cli/gem.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/gem.rb
@@ -12,6 +12,7 @@ module Bundler
     TEST_FRAMEWORK_VERSIONS = {
       "rspec" => "3.0",
       "minitest" => "5.0",
+      "test-unit" => "3.0",
     }.freeze
 
     attr_reader :options, :gem_name, :thor, :name, :target
@@ -37,12 +38,21 @@ module Bundler
       namespaced_path = name.tr("-", "/")
       constant_name = name.gsub(/-[_-]*(?![_-]|$)/) { "::" }.gsub(/([_-]+|(::)|^)(.|$)/) { $2.to_s + $3.upcase }
       constant_array = constant_name.split("::")
+      minitest_constant_name = constant_array.clone.tap {|a| a[-1] = "Test#{a[-1]}" }.join("::") # Foo::Bar => Foo::TestBar
 
-      git_installed = Bundler.git_present?
+      use_git = Bundler.git_present? && options[:git]
 
-      git_author_name = git_installed ? `git config user.name`.chomp : ""
-      github_username = git_installed ? `git config github.user`.chomp : ""
-      git_user_email = git_installed ? `git config user.email`.chomp : ""
+      git_author_name = use_git ? `git config user.name`.chomp : ""
+      git_username = use_git ? `git config github.user`.chomp : ""
+      git_user_email = use_git ? `git config user.email`.chomp : ""
+
+      github_username = if options[:github_username].nil?
+        git_username
+      elsif options[:github_username] == false
+        ""
+      else
+        options[:github_username]
+      end
 
       config = {
         :name             => name,
@@ -57,14 +67,18 @@ module Bundler
         :ext              => options[:ext],
         :exe              => options[:exe],
         :bundler_version  => bundler_dependency_version,
+        :git              => use_git,
         :github_username  => github_username.empty? ? "[USERNAME]" : github_username,
+        :required_ruby_version => required_ruby_version,
+        :minitest_constant_name => minitest_constant_name,
       }
       ensure_safe_gem_name(name, constant_array)
 
       templates = {
-        "Gemfile.tt" => "Gemfile",
+        "#{Bundler.preferred_gemfile_name}.tt" => Bundler.preferred_gemfile_name,
         "lib/newgem.rb.tt" => "lib/#{namespaced_path}.rb",
         "lib/newgem/version.rb.tt" => "lib/#{namespaced_path}/version.rb",
+        "sig/newgem.rbs.tt" => "sig/#{namespaced_path}.rbs",
         "newgem.gemspec.tt" => "#{name}.gemspec",
         "Rakefile.tt" => "Rakefile",
         "README.md.tt" => "README.md",
@@ -77,14 +91,12 @@ module Bundler
         bin/setup
       ]
 
-      templates.merge!("gitignore.tt" => ".gitignore") if Bundler.git_present?
+      templates.merge!("gitignore.tt" => ".gitignore") if use_git
 
       if test_framework = ask_and_set_test_framework
         config[:test] = test_framework
         config[:test_framework_version] = TEST_FRAMEWORK_VERSIONS[test_framework]
 
-        templates.merge!("travis.yml.tt" => ".travis.yml")
-
         case test_framework
         when "rspec"
           templates.merge!(
@@ -92,15 +104,41 @@ module Bundler
             "spec/spec_helper.rb.tt" => "spec/spec_helper.rb",
             "spec/newgem_spec.rb.tt" => "spec/#{namespaced_path}_spec.rb"
           )
+          config[:test_task] = :spec
         when "minitest"
+          # Generate path for minitest target file (FileList["test/**/test_*.rb"])
+          #   foo     => test/test_foo.rb
+          #   foo-bar => test/foo/test_bar.rb
+          #   foo_bar => test/test_foo_bar.rb
+          paths = namespaced_path.rpartition("/")
+          paths[2] = "test_#{paths[2]}"
+          minitest_namespaced_path = paths.join("")
+
           templates.merge!(
-            "test/test_helper.rb.tt" => "test/test_helper.rb",
-            "test/newgem_test.rb.tt" => "test/#{namespaced_path}_test.rb"
+            "test/minitest/test_helper.rb.tt" => "test/test_helper.rb",
+            "test/minitest/test_newgem.rb.tt" => "test/#{minitest_namespaced_path}.rb"
           )
+          config[:test_task] = :test
+        when "test-unit"
+          templates.merge!(
+            "test/test-unit/test_helper.rb.tt" => "test/test_helper.rb",
+            "test/test-unit/newgem_test.rb.tt" => "test/#{namespaced_path}_test.rb"
+          )
+          config[:test_task] = :test
         end
       end
 
-      config[:test_task] = config[:test] == "minitest" ? "test" : "spec"
+      config[:ci] = ask_and_set_ci
+      case config[:ci]
+      when "github"
+        templates.merge!("github/workflows/main.yml.tt" => ".github/workflows/main.yml")
+      when "travis"
+        templates.merge!("travis.yml.tt" => ".travis.yml")
+      when "gitlab"
+        templates.merge!("gitlab-ci.yml.tt" => ".gitlab-ci.yml")
+      when "circle"
+        templates.merge!("circleci/config.yml.tt" => ".circleci/config.yml")
+      end
 
       if ask_and_set(:mit, "Do you want to license your code permissively under the MIT license?",
         "This means that any other developer or company will be legally allowed to use your code " \
@@ -124,6 +162,30 @@ module Bundler
         templates.merge!("CODE_OF_CONDUCT.md.tt" => "CODE_OF_CONDUCT.md")
       end
 
+      if ask_and_set(:changelog, "Do you want to include a changelog?",
+        "A changelog is a file which contains a curated, chronologically ordered list of notable " \
+        "changes for each version of a project. To make it easier for users and contributors to" \
+        " see precisely what notable changes have been made between each release (or version) of" \
+        " the project. Whether consumers or developers, the end users of software are" \
+        " human beings who care about what's in the software. When the software changes, people " \
+        "want to know why and how. see https://keepachangelog.com")
+        config[:changelog] = true
+        Bundler.ui.info "Changelog enabled in config"
+        templates.merge!("CHANGELOG.md.tt" => "CHANGELOG.md")
+      end
+
+      config[:linter] = ask_and_set_linter
+      case config[:linter]
+      when "rubocop"
+        config[:linter_version] = rubocop_version
+        Bundler.ui.info "RuboCop enabled in config"
+        templates.merge!("rubocop.yml.tt" => ".rubocop.yml")
+      when "standard"
+        config[:linter_version] = standard_version
+        Bundler.ui.info "Standard enabled in config"
+        templates.merge!("standard.yml.tt" => ".standard.yml")
+      end
+
       templates.merge!("exe/newgem.tt" => "exe/#{name}") if config[:exe]
 
       if options[:ext]
@@ -134,24 +196,32 @@ module Bundler
         )
       end
 
+      if target.exist? && !target.directory?
+        Bundler.ui.error "Couldn't create a new gem named `#{gem_name}` because there's an existing file named `#{gem_name}`."
+        exit Bundler::BundlerError.all_errors[Bundler::GenericSystemCallError]
+      end
+
+      if use_git
+        Bundler.ui.info "Initializing git repo in #{target}"
+        require "shellwords"
+        `git init #{target.to_s.shellescape}`
+
+        config[:git_default_branch] = File.read("#{target}/.git/HEAD").split("/").last.chomp
+      end
+
       templates.each do |src, dst|
         destination = target.join(dst)
-        SharedHelpers.filesystem_access(destination) do
-          thor.template("newgem/#{src}", destination, config)
-        end
+        thor.template("newgem/#{src}", destination, config)
       end
 
       executables.each do |file|
-        SharedHelpers.filesystem_access(target.join(file)) do |path|
-          executable = (path.stat.mode | 0o111)
-          path.chmod(executable)
-        end
+        path = target.join(file)
+        executable = (path.stat.mode | 0o111)
+        path.chmod(executable)
       end
 
-      if Bundler.git_present? && options[:git]
-        Bundler.ui.info "Initializing git repo in #{target}"
+      if use_git
         Dir.chdir(target) do
-          `git init`
           `git add .`
         end
       end
@@ -161,11 +231,9 @@ module Bundler
 
       Bundler.ui.info "Gem '#{name}' was successfully created. " \
         "For more information on making a RubyGem visit https://bundler.io/guides/creating_gem.html"
-    rescue Errno::EEXIST => e
-      raise GenericSystemCallError.new(e, "There was a conflict while creating the new gem.")
     end
 
-  private
+    private
 
     def resolve_name(name)
       SharedHelpers.pwd.join(name).basename.to_s
@@ -197,11 +265,12 @@ module Bundler
     def ask_and_set_test_framework
       test_framework = options[:test] || Bundler.settings["gem.test"]
 
-      if test_framework.nil?
+      if test_framework.to_s.empty?
         Bundler.ui.confirm "Do you want to generate tests with your gem?"
-        result = Bundler.ui.ask "Type 'rspec' or 'minitest' to generate those test files now and " \
-          "in the future. rspec/minitest/(none):"
-        if result =~ /rspec|minitest/
+        Bundler.ui.info hint_text("test")
+
+        result = Bundler.ui.ask "Enter a test framework. rspec/minitest/test-unit/(none):"
+        if result =~ /rspec|minitest|test-unit/
           test_framework = result
         else
           test_framework = false
@@ -212,9 +281,106 @@ module Bundler
         Bundler.settings.set_global("gem.test", test_framework)
       end
 
+      if options[:test] == Bundler.settings["gem.test"]
+        Bundler.ui.info "#{options[:test]} is already configured, ignoring --test flag."
+      end
+
       test_framework
     end
 
+    def hint_text(setting)
+      if Bundler.settings["gem.#{setting}"] == false
+        "Your choice will only be applied to this gem."
+      else
+        "Future `bundle gem` calls will use your choice. " \
+        "This setting can be changed anytime with `bundle config gem.#{setting}`."
+      end
+    end
+
+    def ask_and_set_ci
+      ci_template = options[:ci] || Bundler.settings["gem.ci"]
+
+      if ci_template.to_s.empty?
+        Bundler.ui.confirm "Do you want to set up continuous integration for your gem? " \
+          "Supported services:\n" \
+          "* CircleCI:       https://circleci.com/\n" \
+          "* GitHub Actions: https://github.com/features/actions\n" \
+          "* GitLab CI:      https://docs.gitlab.com/ee/ci/\n" \
+          "* Travis CI:      https://travis-ci.org/\n" \
+          "\n"
+        Bundler.ui.info hint_text("ci")
+
+        result = Bundler.ui.ask "Enter a CI service. github/travis/gitlab/circle/(none):"
+        if result =~ /github|travis|gitlab|circle/
+          ci_template = result
+        else
+          ci_template = false
+        end
+      end
+
+      if Bundler.settings["gem.ci"].nil?
+        Bundler.settings.set_global("gem.ci", ci_template)
+      end
+
+      if options[:ci] == Bundler.settings["gem.ci"]
+        Bundler.ui.info "#{options[:ci]} is already configured, ignoring --ci flag."
+      end
+
+      ci_template
+    end
+
+    def ask_and_set_linter
+      linter_template = options[:linter] || Bundler.settings["gem.linter"]
+      linter_template = deprecated_rubocop_option if linter_template.nil?
+
+      if linter_template.to_s.empty?
+        Bundler.ui.confirm "Do you want to add a code linter and formatter to your gem? " \
+          "Supported Linters:\n" \
+          "* RuboCop:       https://rubocop.org\n" \
+          "* Standard:      https://github.com/testdouble/standard\n" \
+          "\n"
+        Bundler.ui.info hint_text("linter")
+
+        result = Bundler.ui.ask "Enter a linter. rubocop/standard/(none):"
+        if result =~ /rubocop|standard/
+          linter_template = result
+        else
+          linter_template = false
+        end
+      end
+
+      if Bundler.settings["gem.linter"].nil?
+        Bundler.settings.set_global("gem.linter", linter_template)
+      end
+
+      # Once gem.linter safely set, unset the deprecated gem.rubocop
+      unless Bundler.settings["gem.rubocop"].nil?
+        Bundler.settings.set_global("gem.rubocop", nil)
+      end
+
+      if options[:linter] == Bundler.settings["gem.linter"]
+        Bundler.ui.info "#{options[:linter]} is already configured, ignoring --linter flag."
+      end
+
+      linter_template
+    end
+
+    def deprecated_rubocop_option
+      if !options[:rubocop].nil?
+        if options[:rubocop]
+          Bundler::SharedHelpers.major_deprecation 2, "--rubocop is deprecated, use --linter=rubocop"
+          "rubocop"
+        else
+          Bundler::SharedHelpers.major_deprecation 2, "--no-rubocop is deprecated, use --linter"
+          false
+        end
+      elsif !Bundler.settings["gem.rubocop"].nil?
+        Bundler::SharedHelpers.major_deprecation 2,
+          "config gem.rubocop is deprecated; we've updated your config to use gem.linter instead"
+        Bundler.settings["gem.rubocop"] ? "rubocop" : false
+      end
+    end
+
     def bundler_dependency_version
       v = Gem::Version.new(Bundler::VERSION)
       req = v.segments[0..1]
@@ -248,5 +414,30 @@ module Bundler
     def open_editor(editor, file)
       thor.run(%(#{editor} "#{file}"))
     end
+
+    def required_ruby_version
+      if Gem.ruby_version < Gem::Version.new("2.4.a") then "2.3.0"
+      elsif Gem.ruby_version < Gem::Version.new("2.5.a") then "2.4.0"
+      elsif Gem.ruby_version < Gem::Version.new("2.6.a") then "2.5.0"
+      else
+        "2.6.0"
+      end
+    end
+
+    def rubocop_version
+      if Gem.ruby_version < Gem::Version.new("2.4.a") then "0.81.0"
+      elsif Gem.ruby_version < Gem::Version.new("2.5.a") then "1.12"
+      else
+        "1.21"
+      end
+    end
+
+    def standard_version
+      if Gem.ruby_version < Gem::Version.new("2.4.a") then "0.2.5"
+      elsif Gem.ruby_version < Gem::Version.new("2.5.a") then "1.0"
+      else
+        "1.3"
+      end
+    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/cli/info.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/info.rb
@@ -18,11 +18,12 @@ module Bundler
 
       if spec
         return print_gem_path(spec) if @options[:path]
+        return print_gem_version(spec) if @options[:version]
         print_gem_info(spec)
       end
     end
 
-  private
+    private
 
     def spec_for_gem(gem_name)
       spec = Bundler.definition.specs.find {|s| s.name == gem_name }
@@ -39,24 +40,55 @@ module Bundler
       raise GemNotFound, Bundler::CLI::Common.gem_not_found_message(gem_name, Bundler.definition.dependencies)
     end
 
+    def print_gem_version(spec)
+      Bundler.ui.info spec.version.to_s
+    end
+
     def print_gem_path(spec)
-      path = if spec.name == "bundler"
-        File.expand_path("../../../..", __FILE__)
+      name = spec.name
+      if name == "bundler"
+        path = File.expand_path("../../..", __dir__)
       else
-        spec.full_gem_path
+        path = spec.full_gem_path
+        if spec.deleted_gem?
+          return Bundler.ui.warn "The gem #{name} has been deleted. It was installed at: #{path}"
+        end
       end
 
       Bundler.ui.info path
     end
 
     def print_gem_info(spec)
+      metadata = spec.metadata
+      name = spec.name
       gem_info = String.new
-      gem_info << "  * #{spec.name} (#{spec.version}#{spec.git_version})\n"
+      gem_info << "  * #{name} (#{spec.version}#{spec.git_version})\n"
       gem_info << "\tSummary: #{spec.summary}\n" if spec.summary
       gem_info << "\tHomepage: #{spec.homepage}\n" if spec.homepage
+      gem_info << "\tDocumentation: #{metadata["documentation_uri"]}\n" if metadata.key?("documentation_uri")
+      gem_info << "\tSource Code: #{metadata["source_code_uri"]}\n" if metadata.key?("source_code_uri")
+      gem_info << "\tFunding: #{metadata["funding_uri"]}\n" if metadata.key?("funding_uri")
+      gem_info << "\tWiki: #{metadata["wiki_uri"]}\n" if metadata.key?("wiki_uri")
+      gem_info << "\tChangelog: #{metadata["changelog_uri"]}\n" if metadata.key?("changelog_uri")
+      gem_info << "\tBug Tracker: #{metadata["bug_tracker_uri"]}\n" if metadata.key?("bug_tracker_uri")
+      gem_info << "\tMailing List: #{metadata["mailing_list_uri"]}\n" if metadata.key?("mailing_list_uri")
       gem_info << "\tPath: #{spec.full_gem_path}\n"
-      gem_info << "\tDefault Gem: yes" if spec.respond_to?(:default_gem?) && spec.default_gem?
+      gem_info << "\tDefault Gem: yes\n" if spec.respond_to?(:default_gem?) && spec.default_gem?
+      gem_info << "\tReverse Dependencies: \n\t\t#{gem_dependencies.join("\n\t\t")}" if gem_dependencies.any?
+
+      if name != "bundler" && spec.deleted_gem?
+        return Bundler.ui.warn "The gem #{name} has been deleted. Gemspec information is still available though:\n#{gem_info}"
+      end
+
       Bundler.ui.info gem_info
     end
+
+    def gem_dependencies
+      @gem_dependencies ||= Bundler.definition.specs.map do |spec|
+        dependency = spec.dependencies.find {|dep| dep.name == gem_name }
+        next unless dependency
+        "#{spec.name} (#{spec.version}) depends on #{gem_name} (#{dependency.requirements_list.join(", ")})"
+      end.compact.sort
+    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/cli/init.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/init.rb
@@ -32,16 +32,16 @@ module Bundler
           file << spec.to_gemfile
         end
       else
-        FileUtils.cp(File.expand_path("../../templates/#{gemfile}", __FILE__), gemfile)
+        FileUtils.cp(File.expand_path("../templates/#{gemfile}", __dir__), gemfile)
       end
 
       puts "Writing new #{gemfile} to #{SharedHelpers.pwd}/#{gemfile}"
     end
 
-  private
+    private
 
     def gemfile
-      @gemfile ||= Bundler.settings[:init_gems_rb] ? "gems.rb" : "Gemfile"
+      @gemfile ||= Bundler.preferred_gemfile_name
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/cli/inject.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/inject.rb
@@ -44,7 +44,7 @@ module Bundler
       end
     end
 
-  private
+    private
 
     def last_version_number
       definition = Bundler.definition(true)
--- ruby2.7-2.7.6.orig/lib/bundler/cli/install.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/install.rb
@@ -8,11 +8,11 @@ module Bundler
     end
 
     def run
-      Bundler.ui.level = "error" if options[:quiet]
+      Bundler.ui.level = "warn" if options[:quiet]
 
       warn_if_root
 
-      normalize_groups
+      Bundler.self_manager.install_locked_bundler_and_restart_with_it_if_needed
 
       Bundler::SharedHelpers.set_env "RB_USER_INSTALL", "1" if Bundler::FREEBSD
 
@@ -35,12 +35,8 @@ module Bundler
 
         options[:local] = true if Bundler.app_cache.exist?
 
-        if Bundler.feature_flag.deployment_means_frozen?
-          Bundler.settings.set_command_option :deployment, true
-        else
-          Bundler.settings.set_command_option :deployment, true if options[:deployment]
-          Bundler.settings.set_command_option :frozen, true if options[:frozen]
-        end
+        Bundler.settings.set_command_option :deployment, true if options[:deployment]
+        Bundler.settings.set_command_option :frozen, true if options[:frozen]
       end
 
       # When install is called with --no-deployment, disable deployment mode
@@ -55,7 +51,7 @@ module Bundler
 
       if options["binstubs"]
         Bundler::SharedHelpers.major_deprecation 2,
-          "The --binstubs option will be removed in favor of `bundle binstubs`"
+          "The --binstubs option will be removed in favor of `bundle binstubs --all`"
       end
 
       Plugin.gemfile_install(Bundler.default_gemfile) if Bundler.feature_flag.plugins?
@@ -64,7 +60,10 @@ module Bundler
       definition.validate_runtime!
 
       installer = Installer.install(Bundler.root, definition, options)
-      Bundler.load.cache if Bundler.app_cache.exist? && !options["no-cache"] && !Bundler.frozen_bundle?
+
+      Bundler.settings.temporary(:cache_all_platforms => options[:local] ? false : Bundler.settings[:cache_all_platforms]) do
+        Bundler.load.cache(nil, options[:local]) if Bundler.app_cache.exist? && !options["no-cache"] && !Bundler.frozen_bundle?
+      end
 
       Bundler.ui.confirm "Bundle complete! #{dependencies_count_for(definition)}, #{gems_installed_for(definition)}."
       Bundler::CLI::Common.output_without_groups_message(:install)
@@ -84,28 +83,17 @@ module Bundler
         require_relative "clean"
         Bundler::CLI::Clean.new(options).run
       end
-    rescue GemNotFound, VersionConflict => e
-      if options[:local] && Bundler.app_cache.exist?
-        Bundler.ui.warn "Some gems seem to be missing from your #{Bundler.settings.app_cache_path} directory."
-      end
 
-      unless Bundler.definition.has_rubygems_remotes?
-        Bundler.ui.warn <<-WARN, :wrap => true
-          Your Gemfile has no gem server sources. If you need gems that are \
-          not already on your machine, add a line like this to your Gemfile:
-          source 'https://rubygems.org'
-        WARN
-      end
-      raise e
-    rescue Gem::InvalidSpecificationException => e
+      Bundler::CLI::Common.output_fund_metadata_summary
+    rescue Gem::InvalidSpecificationException
       Bundler.ui.warn "You have one or more invalid gemspecs that need to be fixed."
-      raise e
+      raise
     end
 
-  private
+    private
 
     def warn_if_root
-      return if Bundler.settings[:silence_root_warning] || Bundler::WINDOWS || !Process.uid.zero?
+      return if Bundler.settings[:silence_root_warning] || Gem.win_platform? || !Process.uid.zero?
       Bundler.ui.warn "Don't run Bundler as root. Bundler can ask for sudo " \
         "if it is needed, and installing your bundle as root will break this " \
         "application for all non-root users on this machine.", :wrap => true
@@ -147,34 +135,23 @@ module Bundler
     end
 
     def normalize_groups
-      options[:with] &&= options[:with].join(":").tr(" ", ":").split(":")
-      options[:without] &&= options[:without].join(":").tr(" ", ":").split(":")
-
       check_for_group_conflicts_in_cli_options
 
-      Bundler.settings.set_command_option :with, nil if options[:with] == []
-      Bundler.settings.set_command_option :without, nil if options[:without] == []
-
-      with = options.fetch(:with, [])
-      with |= Bundler.settings[:with].map(&:to_s)
-      with -= options[:without] if options[:without]
-
-      without = options.fetch(:without, [])
-      without |= Bundler.settings[:without].map(&:to_s)
-      without -= options[:with] if options[:with]
-
-      options[:with]    = with
-      options[:without] = without
+      # need to nil them out first to get around validation for backwards compatibility
+      Bundler.settings.set_command_option :without, nil
+      Bundler.settings.set_command_option :with,    nil
+      Bundler.settings.set_command_option :without, options[:without]
+      Bundler.settings.set_command_option :with,    options[:with]
     end
 
     def normalize_settings
       Bundler.settings.set_command_option :path, nil if options[:system]
-      Bundler.settings.temporary(:path_relative_to_cwd => false) do
-        Bundler.settings.set_command_option :path, "vendor/bundle" if Bundler.settings[:deployment] && Bundler.settings[:path].nil?
-      end
       Bundler.settings.set_command_option_if_given :path, options[:path]
-      Bundler.settings.temporary(:path_relative_to_cwd => false) do
-        Bundler.settings.set_command_option :path, "bundle" if options["standalone"] && Bundler.settings[:path].nil?
+
+      if options["standalone"] && Bundler.settings[:path].nil? && !options["local"]
+        Bundler.settings.temporary(:path_relative_to_cwd => false) do
+          Bundler.settings.set_command_option :path, "bundle"
+        end
       end
 
       bin_option = options["binstubs"]
@@ -191,13 +168,7 @@ module Bundler
 
       Bundler.settings.set_command_option_if_given :clean, options["clean"]
 
-      unless Bundler.settings[:without] == options[:without] && Bundler.settings[:with] == options[:with]
-        # need to nil them out first to get around validation for backwards compatibility
-        Bundler.settings.set_command_option :without, nil
-        Bundler.settings.set_command_option :with,    nil
-        Bundler.settings.set_command_option :without, options[:without] - options[:with]
-        Bundler.settings.set_command_option :with,    options[:with]
-      end
+      normalize_groups if options[:without] || options[:with]
 
       options[:force] = options[:redownload]
     end
--- ruby2.7-2.7.6.orig/lib/bundler/cli/issue.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/issue.rb
@@ -10,7 +10,7 @@ module Bundler
         be sure to check out these resources:
 
         1. Check out our troubleshooting guide for quick fixes to common issues:
-        https://github.com/bundler/bundler/blob/master/doc/TROUBLESHOOTING.md
+        https://github.com/rubygems/rubygems/blob/master/bundler/doc/TROUBLESHOOTING.md
 
         2. Instructions for common Bundler uses can be found on the documentation
         site: https://bundler.io/
@@ -20,9 +20,10 @@ module Bundler
 
         Hopefully the troubleshooting steps above resolved your problem!  If things
         still aren't working the way you expect them to, please let us know so
-        that we can diagnose and help fix the problem you're having. Please
-        view the Filing Issues guide for more information:
-        https://github.com/bundler/bundler/blob/master/doc/contributing/ISSUES.md
+        that we can diagnose and help fix the problem you're having, by filling
+        in the new issue form located at
+        https://github.com/rubygems/rubygems/issues/new?labels=Bundler&template=bundler-related-issue.md,
+        and copy and pasting the information below.
 
       EOS
 
--- ruby2.7-2.7.6.orig/lib/bundler/cli/list.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/list.rb
@@ -4,17 +4,25 @@ module Bundler
   class CLI::List
     def initialize(options)
       @options = options
+      @without_group = options["without-group"].map(&:to_sym)
+      @only_group = options["only-group"].map(&:to_sym)
     end
 
     def run
-      raise InvalidOption, "The `--only-group` and `--without-group` options cannot be used together" if @options["only-group"] && @options["without-group"]
+      raise InvalidOption, "The `--only-group` and `--without-group` options cannot be used together" if @only_group.any? && @without_group.any?
 
       raise InvalidOption, "The `--name-only` and `--paths` options cannot be used together" if @options["name-only"] && @options[:paths]
 
-      specs = if @options["only-group"] || @options["without-group"]
+      specs = if @only_group.any? || @without_group.any?
         filtered_specs_by_groups
       else
-        Bundler.load.specs
+        begin
+          Bundler.load.specs
+        rescue GemNotFound => e
+          Bundler.ui.error e.message
+          Bundler.ui.warn "Install missing gems with `bundle install`."
+          exit 1
+        end
       end.reject {|s| s.name == "bundler" }.sort_by(&:name)
 
       return Bundler.ui.info "No gems in the Gemfile" if specs.empty?
@@ -29,12 +37,12 @@ module Bundler
       Bundler.ui.info "Use `bundle info` to print more detailed information about a gem"
     end
 
-  private
+    private
 
     def verify_group_exists(groups)
-      raise InvalidOption, "`#{@options["without-group"]}` group could not be found." if @options["without-group"] && !groups.include?(@options["without-group"].to_sym)
-
-      raise InvalidOption, "`#{@options["only-group"]}` group could not be found." if @options["only-group"] && !groups.include?(@options["only-group"].to_sym)
+      (@without_group + @only_group).each do |group|
+        raise InvalidOption, "`#{group}` group could not be found." unless groups.include?(group)
+      end
     end
 
     def filtered_specs_by_groups
@@ -44,10 +52,10 @@ module Bundler
       verify_group_exists(groups)
 
       show_groups =
-        if @options["without-group"]
-          groups.reject {|g| g == @options["without-group"].to_sym }
-        elsif @options["only-group"]
-          groups.select {|g| g == @options["only-group"].to_sym }
+        if @without_group.any?
+          groups.reject {|g| @without_group.include?(g) }
+        elsif @only_group.any?
+          groups.select {|g| @only_group.include?(g) }
         else
           groups
         end.map(&:to_sym)
--- ruby2.7-2.7.6.orig/lib/bundler/cli/lock.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/lock.rb
@@ -21,9 +21,13 @@ module Bundler
       Bundler::Fetcher.disable_endpoint = options["full-index"]
 
       update = options[:update]
+      conservative = options[:conservative]
+
       if update.is_a?(Array) # unlocking specific gems
         Bundler::CLI::Common.ensure_all_gems_in_lockfile!(update)
-        update = { :gems => update, :lock_shared_dependencies => options[:conservative] }
+        update = { :gems => update, :conservative => conservative }
+      elsif update
+        update = { :conservative => conservative } if conservative
       end
       definition = Bundler.definition(update)
 
--- ruby2.7-2.7.6.orig/lib/bundler/cli/open.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/open.rb
@@ -1,7 +1,5 @@
 # frozen_string_literal: true
 
-require "shellwords"
-
 module Bundler
   class CLI::Open
     attr_reader :options, :name
@@ -19,6 +17,7 @@ module Bundler
       else
         path = spec.full_gem_path
         Dir.chdir(path) do
+          require "shellwords"
           command = Shellwords.split(editor) + [path]
           Bundler.with_original_env do
             system(*command)
--- ruby2.7-2.7.6.orig/lib/bundler/cli/outdated.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/outdated.rb
@@ -3,18 +3,16 @@
 module Bundler
   class CLI::Outdated
     attr_reader :options, :gems, :options_include_groups, :filter_options_patch, :sources, :strict
-    attr_accessor :outdated_gems_by_groups, :outdated_gems_list
+    attr_accessor :outdated_gems
 
     def initialize(options, gems)
       @options = options
       @gems = gems
       @sources = Array(options[:source])
 
-      @filter_options_patch = options.keys &
-        %w[filter-major filter-minor filter-patch]
+      @filter_options_patch = options.keys & %w[filter-major filter-minor filter-patch]
 
-      @outdated_gems_by_groups = {}
-      @outdated_gems_list = []
+      @outdated_gems = []
 
       @options_include_groups = [:group, :groups].any? do |v|
         options.keys.include?(v.to_s)
@@ -22,8 +20,7 @@ module Bundler
 
       # the patch level options imply strict is also true. It wouldn't make
       # sense otherwise.
-      @strict = options["filter-strict"] ||
-        Bundler::CLI::Common.patch_level_options(options).any?
+      @strict = options["filter-strict"] || Bundler::CLI::Common.patch_level_options(options).any?
     end
 
     def run
@@ -49,7 +46,7 @@ module Bundler
 
       Bundler::CLI::Common.configure_gem_version_promoter(
         Bundler.definition,
-        options
+        options.merge(:strict => @strict)
       )
 
       definition_resolution = proc do
@@ -75,85 +72,71 @@ module Bundler
         gemfile_specs + dependency_specs
       end
 
-      specs.sort_by(&:name).each do |current_spec|
-        next if !gems.empty? && !gems.include?(current_spec.name)
+      specs.sort_by(&:name).uniq(&:name).each do |current_spec|
+        next unless gems.empty? || gems.include?(current_spec.name)
 
-        dependency = current_dependencies[current_spec.name]
         active_spec = retrieve_active_spec(definition, current_spec)
+        next unless active_spec
 
-        next if active_spec.nil?
-        next if filter_options_patch.any? &&
-          !update_present_via_semver_portions(current_spec, active_spec, options)
+        next unless filter_options_patch.empty? || update_present_via_semver_portions(current_spec, active_spec, options)
 
         gem_outdated = Gem::Version.new(active_spec.version) > Gem::Version.new(current_spec.version)
         next unless gem_outdated || (current_spec.git_version != active_spec.git_version)
-        groups = nil
+
+        dependency = current_dependencies[current_spec.name]
+        groups = ""
         if dependency && !options[:parseable]
           groups = dependency.groups.join(", ")
         end
 
-        outdated_gems_list << { :active_spec => active_spec,
-                                :current_spec => current_spec,
-                                :dependency => dependency,
-                                :groups => groups }
-
-        outdated_gems_by_groups[groups] ||= []
-        outdated_gems_by_groups[groups] << outdated_gems_list[-1]
+        outdated_gems << {
+          :active_spec => active_spec,
+          :current_spec => current_spec,
+          :dependency => dependency,
+          :groups => groups,
+        }
       end
 
-      if outdated_gems_list.empty?
-        display_nothing_outdated_message
-      else
+      if outdated_gems.empty?
         unless options[:parseable]
-          Bundler.ui.info(header_outdated_message)
+          Bundler.ui.info(nothing_outdated_message)
         end
-
+      else
         if options_include_groups
-          ordered_groups = outdated_gems_by_groups.keys.compact.sort
-          ordered_groups.insert(0, nil).each do |groups|
-            gems = outdated_gems_by_groups[groups]
-            contains_group = if groups
-              groups.split(", ").include?(options[:group])
-            else
-              options[:group] == "group"
+          relevant_outdated_gems = outdated_gems.group_by {|g| g[:groups] }.sort.flat_map do |groups, gems|
+            contains_group = groups.split(", ").include?(options[:group])
+            next unless options[:groups] || contains_group
+
+            gems
+          end.compact
+
+          if options[:parseable]
+            relevant_outdated_gems.each do |gems|
+              print_gems(gems)
             end
-
-            next if (!options[:groups] && !contains_group) || gems.nil?
-
-            unless options[:parseable]
-              Bundler.ui.info(header_group_message(groups))
-            end
-
-            print_gems(gems)
+          else
+            print_gems_table(relevant_outdated_gems)
           end
+        elsif options[:parseable]
+          print_gems(outdated_gems)
         else
-          print_gems(outdated_gems_list)
+          print_gems_table(outdated_gems)
         end
 
         exit 1
       end
     end
 
-  private
+    private
 
-    def groups_text(group_text, groups)
-      "#{group_text}#{groups.split(",").size > 1 ? "s" : ""} \"#{groups}\""
-    end
+    def loaded_from_for(spec)
+      return unless spec.respond_to?(:loaded_from)
 
-    def header_outdated_message
-      if options[:pre]
-        "Outdated gems included in the bundle (including pre-releases):"
-      else
-        "Outdated gems included in the bundle:"
-      end
+      spec.loaded_from
     end
 
-    def header_group_message(groups)
-      if groups
-        "===== #{groups_text("Group", groups)} ====="
-      else
-        "===== Without group ====="
-      end
+    def groups_text(group_text, groups)
+      "#{group_text}#{groups.split(",").size > 1 ? "s" : ""} \"#{groups}\""
     end
 
     def nothing_outdated_message
@@ -169,23 +152,16 @@ module Bundler
     end
 
     def retrieve_active_spec(definition, current_spec)
-      if strict
-        active_spec = definition.find_resolved_spec(current_spec)
-      else
-        active_specs = definition.find_indexed_specs(current_spec)
-        if !current_spec.version.prerelease? && !options[:pre] && active_specs.size > 1
-          active_specs.delete_if {|b| b.respond_to?(:version) && b.version.prerelease? }
-        end
-        active_spec = active_specs.last
-      end
+      active_spec = definition.resolve.find_by_name_and_platform(current_spec.name, current_spec.platform)
+      return unless active_spec
 
-      active_spec
-    end
+      return active_spec if strict
 
-    def display_nothing_outdated_message
-      unless options[:parseable]
-        Bundler.ui.info(nothing_outdated_message)
+      active_specs = active_spec.source.specs.search(current_spec.name).select {|spec| spec.match_platform(current_spec.platform) }.sort_by(&:version)
+      if !current_spec.version.prerelease? && !options[:pre] && active_specs.size > 1
+        active_specs.delete_if {|b| b.respond_to?(:version) && b.version.prerelease? }
       end
+      active_specs.last
     end
 
     def print_gems(gems_list)
@@ -199,9 +175,25 @@ module Bundler
       end
     end
 
+    def print_gems_table(gems_list)
+      data = gems_list.map do |gem|
+        gem_column_for(
+          gem[:current_spec],
+          gem[:active_spec],
+          gem[:dependency],
+          gem[:groups],
+        )
+      end
+
+      print_indented([table_header] + data)
+    end
+
     def print_gem(current_spec, active_spec, dependency, groups)
       spec_version = "#{active_spec.version}#{active_spec.git_version}"
-      spec_version += " (from #{active_spec.loaded_from})" if Bundler.ui.debug? && active_spec.loaded_from
+      if Bundler.ui.debug?
+        loaded_from = loaded_from_for(active_spec)
+        spec_version += " (from #{loaded_from})" if loaded_from
+      end
       current_version = "#{current_spec.version}#{current_spec.git_version}"
 
       if dependency && dependency.specific?
@@ -213,7 +205,7 @@ module Bundler
 
       output_message = if options[:parseable]
         spec_outdated_info.to_s
-      elsif options_include_groups || !groups
+      elsif options_include_groups || groups.empty?
         "  * #{spec_outdated_info}"
       else
         "  * #{spec_outdated_info} in #{groups_text("group", groups)}"
@@ -222,14 +214,22 @@ module Bundler
       Bundler.ui.info output_message.rstrip
     end
 
+    def gem_column_for(current_spec, active_spec, dependency, groups)
+      current_version = "#{current_spec.version}#{current_spec.git_version}"
+      spec_version = "#{active_spec.version}#{active_spec.git_version}"
+      dependency = dependency.requirement if dependency
+
+      ret_val = [active_spec.name, current_version, spec_version, dependency.to_s, groups.to_s]
+      ret_val << loaded_from_for(active_spec).to_s if Bundler.ui.debug?
+      ret_val
+    end
+
     def check_for_deployment_mode!
       return unless Bundler.frozen_bundle?
-      suggested_command = if Bundler.settings.locations("frozen")[:global]
+      suggested_command = if Bundler.settings.locations("frozen").keys.&([:global, :local]).any?
         "bundle config unset frozen"
       elsif Bundler.settings.locations("deployment").keys.&([:global, :local]).any?
         "bundle config unset deployment"
-      else
-        "bundle install --no-deployment"
       end
       raise ProductionError, "You are trying to check outdated gems in " \
         "deployment mode. Run `bundle outdated` elsewhere.\n" \
@@ -266,5 +266,34 @@ module Bundler
       version_section = spec.version.segments[version_portion_index, 1]
       version_section.to_a[0].to_i
     end
+
+    def print_indented(matrix)
+      header = matrix[0]
+      data = matrix[1..-1]
+
+      column_sizes = Array.new(header.size) do |index|
+        matrix.max_by {|row| row[index].length }[index].length
+      end
+
+      Bundler.ui.info justify(header, column_sizes)
+
+      data.sort_by! {|row| row[0] }
+
+      data.each do |row|
+        Bundler.ui.info justify(row, column_sizes)
+      end
+    end
+
+    def table_header
+      header = ["Gem", "Current", "Latest", "Requested", "Groups"]
+      header << "Path" if Bundler.ui.debug?
+      header
+    end
+
+    def justify(row, sizes)
+      row.each_with_index.map do |element, index|
+        element.ljust(sizes[index])
+      end.join("  ").strip + "\n"
+    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/cli/package.rb
+++ /dev/null
@@ -1,48 +0,0 @@
-# frozen_string_literal: true
-
-module Bundler
-  class CLI::Package
-    attr_reader :options
-
-    def initialize(options)
-      @options = options
-    end
-
-    def run
-      Bundler.ui.level = "error" if options[:quiet]
-      Bundler.settings.set_command_option_if_given :path, options[:path]
-      Bundler.settings.set_command_option_if_given :cache_path, options["cache-path"]
-
-      setup_cache_all
-      install
-
-      # TODO: move cache contents here now that all bundles are locked
-      custom_path = Bundler.settings[:path] if options[:path]
-
-      Bundler.settings.temporary(:cache_all_platforms => options["all-platforms"]) do
-        Bundler.load.cache(custom_path)
-      end
-    end
-
-  private
-
-    def install
-      require_relative "install"
-      options = self.options.dup
-      options["local"] = false if Bundler.settings[:cache_all_platforms]
-      Bundler::CLI::Install.new(options).run
-    end
-
-    def setup_cache_all
-      all = options.fetch(:all, Bundler.feature_flag.cache_all? || nil)
-
-      Bundler.settings.set_command_option_if_given :cache_all, all
-
-      if Bundler.definition.has_local_dependencies? && !Bundler.feature_flag.cache_all?
-        Bundler.ui.warn "Your Gemfile contains path and git dependencies. If you want "    \
-          "to package them as well, please pass the --all flag. This will be the default " \
-          "on Bundler 3.0."
-      end
-    end
-  end
-end
--- ruby2.7-2.7.6.orig/lib/bundler/cli/platform.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/platform.rb
@@ -9,7 +9,7 @@ module Bundler
 
     def run
       platforms, ruby_version = Bundler.ui.silence do
-        locked_ruby_version = Bundler.locked_gems && Bundler.locked_gems.ruby_version
+        locked_ruby_version = Bundler.locked_gems && Bundler.locked_gems.ruby_version&.gsub(/p\d+\Z/, "")
         gemfile_ruby_version = Bundler.definition.ruby_version && Bundler.definition.ruby_version.single_version_string
         [Bundler.definition.platforms.map {|p| "* #{p}" },
          locked_ruby_version || gemfile_ruby_version]
@@ -23,7 +23,7 @@ module Bundler
           output << "No ruby version specified"
         end
       else
-        output << "Your platform is: #{RUBY_PLATFORM}"
+        output << "Your platform is: #{Gem::Platform.local}"
         output << "Your app has gems that work on these platforms:\n#{platforms.join("\n")}"
 
         if ruby_version
--- ruby2.7-2.7.6.orig/lib/bundler/cli/plugin.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/plugin.rb
@@ -23,6 +23,16 @@ module Bundler
       Bundler::Plugin.install(plugins, options)
     end
 
+    desc "uninstall PLUGINS", "Uninstall the plugins"
+    long_desc <<-D
+      Uninstall given list of plugins. To uninstall all the plugins, use -all option.
+    D
+    method_option "all", :type => :boolean, :default => nil, :banner =>
+      "Uninstall all the installed plugins. If no plugin is installed, then it does nothing."
+    def uninstall(*plugins)
+      Bundler::Plugin.uninstall(plugins, options)
+    end
+
     desc "list", "List the installed plugins and available commands"
     def list
       Bundler::Plugin.list
--- ruby2.7-2.7.6.orig/lib/bundler/cli/pristine.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/pristine.rb
@@ -29,6 +29,11 @@ module Bundler
 
           FileUtils.rm_rf spec.full_gem_path
         when Source::Git
+          if source.local?
+            Bundler.ui.warn("Cannot pristine #{gem_name}. Gem is locally overridden.")
+            next
+          end
+
           source.remote!
           if extension_cache_path = source.extension_cache_path(spec)
             FileUtils.rm_rf extension_cache_path
--- ruby2.7-2.7.6.orig/lib/bundler/cli/remove.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/remove.rb
@@ -11,8 +11,7 @@ module Bundler
       raise InvalidOption, "Please specify gems to remove." if @gems.empty?
 
       Injector.remove(@gems, {})
-
-      Installer.install(Bundler.root, Bundler.definition) if @options["install"]
+      Installer.install(Bundler.root, Bundler.definition)
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/cli/show.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/show.rb
@@ -18,7 +18,7 @@ module Bundler
 
       if gem_name
         if gem_name == "bundler"
-          path = File.expand_path("../../../..", __FILE__)
+          path = File.expand_path("../../..", __dir__)
         else
           spec = Bundler::CLI::Common.select_spec(gem_name, :regex_match)
           return unless spec
@@ -53,7 +53,7 @@ module Bundler
       end
     end
 
-  private
+    private
 
     def fetch_latest_specs
       definition = Bundler.definition(true)
--- ruby2.7-2.7.6.orig/lib/bundler/cli/update.rb
+++ ruby2.7-2.7.6/lib/bundler/cli/update.rb
@@ -9,14 +9,18 @@ module Bundler
     end
 
     def run
-      Bundler.ui.level = "error" if options[:quiet]
+      Bundler.ui.level = "warn" if options[:quiet]
+
+      update_bundler = options[:bundler]
+
+      Bundler.self_manager.update_bundler_and_restart_with_it_if_needed(update_bundler) if update_bundler
 
       Plugin.gemfile_install(Bundler.default_gemfile) if Bundler.feature_flag.plugins?
 
       sources = Array(options[:source])
       groups  = Array(options[:group]).map(&:to_sym)
 
-      full_update = gems.empty? && sources.empty? && groups.empty? && !options[:ruby] && !options[:bundler]
+      full_update = gems.empty? && sources.empty? && groups.empty? && !options[:ruby] && !update_bundler
 
       if full_update && !options[:all]
         if Bundler.feature_flag.update_requires_all_flag?
@@ -27,9 +31,14 @@ module Bundler
         raise InvalidOption, "Cannot specify --all along with specific options."
       end
 
+      conservative = options[:conservative]
+
       if full_update
-        # We're doing a full update
-        Bundler.definition(true)
+        if conservative
+          Bundler.definition(:conservative => conservative)
+        else
+          Bundler.definition(true)
+        end
       else
         unless Bundler.default_lockfile.exist?
           raise GemfileLockNotFound, "This Bundle hasn't been installed yet. " \
@@ -43,8 +52,8 @@ module Bundler
         end
 
         Bundler.definition(:gems => gems, :sources => sources, :ruby => options[:ruby],
-                           :lock_shared_dependencies => options[:conservative],
-                           :bundler => options[:bundler])
+                           :conservative => conservative,
+                           :bundler => update_bundler)
       end
 
       Bundler::CLI::Common.configure_gem_version_promoter(Bundler.definition, options)
@@ -61,7 +70,7 @@ module Bundler
 
       if locked_gems = Bundler.definition.locked_gems
         previous_locked_info = locked_gems.specs.reduce({}) do |h, s|
-          h[s.name] = { :spec => s, :version => s.version, :source => s.source.to_s }
+          h[s.name] = { :spec => s, :version => s.version, :source => s.source.identifier }
           h
         end
       end
@@ -82,7 +91,7 @@ module Bundler
           locked_spec = locked_info[:spec]
           new_spec = Bundler.definition.specs[name].first
           unless new_spec
-            if Bundler.rubygems.platforms.none? {|p| locked_spec.match_platform(p) }
+            unless locked_spec.match_platform(Bundler.local_platform)
               Bundler.ui.warn "Bundler attempted to update #{name} but it was not considered because it is for a different platform from the current one"
             end
 
@@ -90,7 +99,7 @@ module Bundler
           end
 
           locked_source = locked_info[:source]
-          new_source = new_spec.source.to_s
+          new_source = new_spec.source.identifier
           next if locked_source != new_source
 
           new_version = new_spec.version
@@ -106,6 +115,8 @@ module Bundler
       Bundler.ui.confirm "Bundle updated!"
       Bundler::CLI::Common.output_without_groups_message(:update)
       Bundler::CLI::Common.output_post_install_messages installer.post_install_messages
+
+      Bundler::CLI::Common.output_fund_metadata_summary
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/compact_index_client.rb
+++ ruby2.7-2.7.6/lib/bundler/compact_index_client.rb
@@ -5,7 +5,7 @@ require "set"
 
 module Bundler
   class CompactIndexClient
-    DEBUG_MUTEX = Mutex.new
+    DEBUG_MUTEX = Thread::Mutex.new
     def self.debug
       return unless ENV["DEBUG_COMPACT_INDEX"]
       DEBUG_MUTEX.synchronize { warn("[#{self}] #{yield}") }
@@ -25,7 +25,7 @@ module Bundler
       @endpoints = Set.new
       @info_checksums_by_name = {}
       @parsed_checksums = false
-      @mutex = Mutex.new
+      @mutex = Thread::Mutex.new
     end
 
     def execution_mode=(block)
@@ -73,12 +73,6 @@ module Bundler
       end.flatten(1)
     end
 
-    def spec(name, version, platform = nil)
-      Bundler::CompactIndexClient.debug { "spec(name = #{name}, version = #{version}, platform = #{platform})" }
-      update_info(name)
-      @cache.specific_dependency(name, version, platform)
-    end
-
     def update_and_parse_checksums!
       Bundler::CompactIndexClient.debug { "update_and_parse_checksums!" }
       return @info_checksums_by_name if @parsed_checksums
@@ -87,7 +81,7 @@ module Bundler
       @parsed_checksums = true
     end
 
-  private
+    private
 
     def update(local_path, remote_path)
       Bundler::CompactIndexClient.debug { "update(#{local_path}, #{remote_path})" }
--- ruby2.7-2.7.6.orig/lib/bundler/compact_index_client/cache.rb
+++ ruby2.7-2.7.6/lib/bundler/compact_index_client/cache.rb
@@ -1,5 +1,7 @@
 # frozen_string_literal: true
 
+require_relative "gem_parser"
+
 module Bundler
   class CompactIndexClient
     class Cache
@@ -74,16 +76,7 @@ module Bundler
         end
       end
 
-      def specific_dependency(name, version, platform)
-        pattern = [version, platform].compact.join("-")
-        return nil if pattern.empty?
-
-        gem_lines = info_path(name).read
-        gem_line = gem_lines[/^#{Regexp.escape(pattern)}\b.*/, 0]
-        gem_line ? parse_gem(gem_line) : nil
-      end
-
-    private
+      private
 
       def lines(path)
         return [] unless path.file?
@@ -92,19 +85,9 @@ module Bundler
         header ? lines[header + 1..-1] : lines
       end
 
-      def parse_gem(string)
-        version_and_platform, rest = string.split(" ", 2)
-        version, platform = version_and_platform.split("-", 2)
-        dependencies, requirements = rest.split("|", 2).map {|s| s.split(",") } if rest
-        dependencies = dependencies ? dependencies.map {|d| parse_dependency(d) } : []
-        requirements = requirements ? requirements.map {|r| parse_dependency(r) } : []
-        [version, platform, dependencies, requirements]
-      end
-
-      def parse_dependency(string)
-        dependency = string.split(":")
-        dependency[-1] = dependency[-1].split("&") if dependency.size > 1
-        dependency
+      def parse_gem(line)
+        @dependency_parser ||= GemParser.new
+        @dependency_parser.parse(line)
       end
 
       def info_roots
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/compact_index_client/gem_parser.rb
@@ -0,0 +1,28 @@
+# frozen_string_literal: true
+
+module Bundler
+  class CompactIndexClient
+    if defined?(Gem::Resolver::APISet::GemParser)
+      GemParser = Gem::Resolver::APISet::GemParser
+    else
+      class GemParser
+        def parse(line)
+          version_and_platform, rest = line.split(" ", 2)
+          version, platform = version_and_platform.split("-", 2)
+          dependencies, requirements = rest.split("|", 2).map {|s| s.split(",") } if rest
+          dependencies = dependencies ? dependencies.map {|d| parse_dependency(d) } : []
+          requirements = requirements ? requirements.map {|d| parse_dependency(d) } : []
+          [version, platform, dependencies, requirements]
+        end
+
+        private
+
+        def parse_dependency(string)
+          dependency = string.split(":")
+          dependency[-1] = dependency[-1].split("&") if dependency.size > 1
+          dependency
+        end
+      end
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/lib/bundler/compact_index_client/updater.rb
+++ ruby2.7-2.7.6/lib/bundler/compact_index_client/updater.rb
@@ -1,8 +1,6 @@
 # frozen_string_literal: true
 
 require_relative "../vendored_fileutils"
-require "stringio"
-require "zlib"
 
 module Bundler
   class CompactIndexClient
@@ -22,20 +20,19 @@ module Bundler
 
       def initialize(fetcher)
         @fetcher = fetcher
-        require "tmpdir"
+        require_relative "../vendored_tmpdir"
       end
 
       def update(local_path, remote_path, retrying = nil)
         headers = {}
 
-        Dir.mktmpdir("bundler-compact-index-") do |local_temp_dir|
+        Bundler::Dir.mktmpdir("bundler-compact-index-") do |local_temp_dir|
           local_temp_path = Pathname.new(local_temp_dir).join(local_path.basename)
 
           # first try to fetch any new bytes on the existing file
           if retrying.nil? && local_path.file?
-            SharedHelpers.filesystem_access(local_temp_path) do
-              FileUtils.cp local_path, local_temp_path
-            end
+            copy_file local_path, local_temp_path
+
             headers["If-None-Match"] = etag_for(local_temp_path)
             headers["Range"] =
               if local_temp_path.size.nonzero?
@@ -45,29 +42,27 @@ module Bundler
               else
                 "bytes=#{local_temp_path.size}-"
               end
-          else
-            # Fastly ignores Range when Accept-Encoding: gzip is set
-            headers["Accept-Encoding"] = "gzip"
           end
 
           response = @fetcher.call(remote_path, headers)
           return nil if response.is_a?(Net::HTTPNotModified)
 
           content = response.body
-          if response["Content-Encoding"] == "gzip"
-            content = Zlib::GzipReader.new(StringIO.new(content)).read
-          end
 
-          SharedHelpers.filesystem_access(local_temp_path) do
+          etag = (response["ETag"] || "").gsub(%r{\AW/}, "")
+          correct_response = SharedHelpers.filesystem_access(local_temp_path) do
             if response.is_a?(Net::HTTPPartialContent) && local_temp_path.size.nonzero?
               local_temp_path.open("a") {|f| f << slice_body(content, 1..-1) }
+
+              etag_for(local_temp_path) == etag
             else
-              local_temp_path.open("w") {|f| f << content }
+              local_temp_path.open("wb") {|f| f << content }
+
+              etag.length.zero? || etag_for(local_temp_path) == etag
             end
           end
 
-          response_etag = (response["ETag"] || "").gsub(%r{\AW/}, "")
-          if etag_for(local_temp_path) == response_etag
+          if correct_response
             SharedHelpers.filesystem_access(local_path) do
               FileUtils.mv(local_temp_path, local_path)
             end
@@ -75,16 +70,11 @@ module Bundler
           end
 
           if retrying
-            raise MisMatchedChecksumError.new(remote_path, response_etag, etag_for(local_temp_path))
+            raise MisMatchedChecksumError.new(remote_path, etag, etag_for(local_temp_path))
           end
 
           update(local_path, remote_path, :retrying)
         end
-      rescue Errno::EACCES
-        raise Bundler::PermissionError,
-          "Bundler does not have write access to create a temp directory " \
-          "within #{Dir.tmpdir}. Bundler must have write access to your " \
-          "systems temp directory to function properly. "
       rescue Zlib::GzipFile::Error
         raise Bundler::HTTPError
       end
@@ -100,11 +90,25 @@ module Bundler
 
       def checksum_for_file(path)
         return nil unless path.file?
-        # This must use IO.read instead of Digest.file().hexdigest
+        # This must use File.read instead of Digest.file().hexdigest
         # because we need to preserve \n line endings on windows when calculating
         # the checksum
         SharedHelpers.filesystem_access(path, :read) do
-          SharedHelpers.digest(:MD5).hexdigest(IO.read(path))
+          SharedHelpers.digest(:MD5).hexdigest(File.read(path))
+        end
+      end
+
+      private
+
+      def copy_file(source, dest)
+        SharedHelpers.filesystem_access(source, :read) do
+          File.open(source, "r") do |s|
+            SharedHelpers.filesystem_access(dest, :write) do
+              File.open(dest, "wb", s.stat.mode) do |f|
+                IO.copy_stream(s, f)
+              end
+            end
+          end
         end
       end
     end
--- ruby2.7-2.7.6.orig/lib/bundler/current_ruby.rb
+++ ruby2.7-2.7.6/lib/bundler/current_ruby.rb
@@ -20,6 +20,8 @@ module Bundler
       2.5
       2.6
       2.7
+      3.0
+      3.1
     ].freeze
 
     KNOWN_MAJOR_VERSIONS = KNOWN_MINOR_VERSIONS.map {|v| v.split(".", 2).first }.uniq.freeze
@@ -34,17 +36,18 @@ module Bundler
       rbx
       ruby
       truffleruby
+      windows
       x64_mingw
     ].freeze
 
     def ruby?
       return true if Bundler::GemHelpers.generic_local_platform == Gem::Platform::RUBY
 
-      !mswin? && (RUBY_ENGINE == "ruby" || RUBY_ENGINE == "rbx" || RUBY_ENGINE == "maglev" || RUBY_ENGINE == "truffleruby")
+      !windows? && (RUBY_ENGINE == "ruby" || RUBY_ENGINE == "rbx" || RUBY_ENGINE == "maglev" || RUBY_ENGINE == "truffleruby")
     end
 
     def mri?
-      !mswin? && RUBY_ENGINE == "ruby"
+      !windows? && RUBY_ENGINE == "ruby"
     end
 
     def rbx?
@@ -63,20 +66,28 @@ module Bundler
       RUBY_ENGINE == "truffleruby"
     end
 
+    def windows?
+      Gem.win_platform?
+    end
+
     def mswin?
-      Bundler::WINDOWS
+      # For backwards compatibility
+      windows?
+
+      # TODO: This should correctly be:
+      # windows? && Bundler.local_platform != Gem::Platform::RUBY && Bundler.local_platform.os == "mswin32" && Bundler.local_platform.cpu == "x86"
     end
 
     def mswin64?
-      Bundler::WINDOWS && Bundler.local_platform != Gem::Platform::RUBY && Bundler.local_platform.os == "mswin64" && Bundler.local_platform.cpu == "x64"
+      windows? && Bundler.local_platform != Gem::Platform::RUBY && Bundler.local_platform.os == "mswin64" && Bundler.local_platform.cpu == "x64"
     end
 
     def mingw?
-      Bundler::WINDOWS && Bundler.local_platform != Gem::Platform::RUBY && Bundler.local_platform.os == "mingw32" && Bundler.local_platform.cpu != "x64"
+      windows? && Bundler.local_platform != Gem::Platform::RUBY && Bundler.local_platform.os == "mingw32" && Bundler.local_platform.cpu != "x64"
     end
 
     def x64_mingw?
-      Bundler::WINDOWS && Bundler.local_platform != Gem::Platform::RUBY && Bundler.local_platform.os == "mingw32" && Bundler.local_platform.cpu == "x64"
+      Gem.win_platform? && Bundler.local_platform != Gem::Platform::RUBY && Bundler.local_platform.os.start_with?("mingw") && Bundler.local_platform.cpu == "x64"
     end
 
     (KNOWN_MINOR_VERSIONS + KNOWN_MAJOR_VERSIONS).each do |version|
--- ruby2.7-2.7.6.orig/lib/bundler/definition.rb
+++ ruby2.7-2.7.6/lib/bundler/definition.rb
@@ -1,12 +1,16 @@
 # frozen_string_literal: true
 
 require_relative "lockfile_parser"
-require "set"
 
 module Bundler
   class Definition
     include GemHelpers
 
+    class << self
+      # Do not create or modify a lockfile (Makes #lock a noop)
+      attr_accessor :no_lock
+    end
+
     attr_reader(
       :dependencies,
       :locked_deps,
@@ -57,10 +61,8 @@ module Bundler
         @unlocking_bundler = false
         @unlocking = unlock
       else
-        unlock = unlock.dup
         @unlocking_bundler = unlock.delete(:bundler)
-        unlock.delete_if {|_k, v| Array(v).empty? }
-        @unlocking = !unlock.empty?
+        @unlocking = unlock.any? {|_k, v| !Array(v).empty? }
       end
 
       @dependencies    = dependencies
@@ -68,6 +70,7 @@ module Bundler
       @unlock          = unlock
       @optional_groups = optional_groups
       @remote          = false
+      @prefer_local    = false
       @specs           = nil
       @ruby_version    = ruby_version
       @gemfiles        = gemfiles
@@ -76,7 +79,7 @@ module Bundler
       @lockfile_contents      = String.new
       @locked_bundler_version = nil
       @locked_ruby_version    = nil
-      @locked_specs_incomplete_for_platform = false
+      @new_platform = nil
 
       if lockfile && File.exist?(lockfile)
         @lockfile_contents = Bundler.read_file(lockfile)
@@ -85,10 +88,11 @@ module Bundler
         @platforms = @locked_platforms.dup
         @locked_bundler_version = @locked_gems.bundler_version
         @locked_ruby_version = @locked_gems.ruby_version
+        @originally_locked_specs = SpecSet.new(@locked_gems.specs)
 
         if unlock != true
           @locked_deps    = @locked_gems.dependencies
-          @locked_specs   = SpecSet.new(@locked_gems.specs)
+          @locked_specs   = @originally_locked_specs
           @locked_sources = @locked_gems.sources
         else
           @unlock         = {}
@@ -106,22 +110,36 @@ module Bundler
         @locked_platforms = []
       end
 
-      @unlock[:gems] ||= []
+      locked_gem_sources = @locked_sources.select {|s| s.is_a?(Source::Rubygems) }
+      @multisource_allowed = locked_gem_sources.size == 1 && locked_gem_sources.first.multiple_remotes? && Bundler.frozen_bundle?
+
+      if @multisource_allowed
+        unless sources.aggregate_global_source?
+          msg = "Your lockfile contains a single rubygems source section with multiple remotes, which is insecure. Make sure you run `bundle install` in non frozen mode and commit the result to make your lockfile secure."
+
+          Bundler::SharedHelpers.major_deprecation 2, msg
+        end
+
+        @sources.merged_gem_lockfile_sections!(locked_gem_sources.first)
+      end
+
       @unlock[:sources] ||= []
       @unlock[:ruby] ||= if @ruby_version && locked_ruby_version_object
         @ruby_version.diff(locked_ruby_version_object)
       end
       @unlocking ||= @unlock[:ruby] ||= (!@locked_ruby_version ^ !@ruby_version)
 
-      add_current_platform unless Bundler.frozen_bundle?
+      add_current_platform unless current_ruby_platform_locked? || Bundler.frozen_bundle?
 
       converge_path_sources_to_gemspec_sources
       @path_changes = converge_paths
       @source_changes = converge_sources
 
-      unless @unlock[:lock_shared_dependencies]
-        eager_unlock = expand_dependencies(@unlock[:gems], true)
-        @unlock[:gems] = @locked_specs.for(eager_unlock, [], false, false, false).map(&:name)
+      if @unlock[:conservative]
+        @unlock[:gems] ||= @dependencies.map(&:name)
+      else
+        eager_unlock = expand_dependencies(@unlock[:gems] || [], true)
+        @unlock[:gems] = @locked_specs.for(eager_unlock, false, platforms).map(&:name)
       end
 
       @dependency_changes = converge_dependencies
@@ -145,17 +163,28 @@ module Bundler
       end
     end
 
+    def resolve_only_locally!
+      @remote = false
+      sources.local_only!
+      resolve
+    end
+
+    def resolve_prefering_local!
+      @prefer_local = true
+      @remote = true
+      sources.remote!
+      resolve
+    end
+
     def resolve_with_cache!
-      raise "Specs already loaded" if @specs
       sources.cached!
-      specs
+      resolve
     end
 
     def resolve_remotely!
-      raise "Specs already loaded" if @specs
       @remote = true
       sources.remote!
-      specs
+      resolve
     end
 
     # For given dependency list returns a SpecSet with Gemspec of all the required
@@ -165,25 +194,7 @@ module Bundler
     #
     # @return [Bundler::SpecSet]
     def specs
-      @specs ||= begin
-        begin
-          specs = resolve.materialize(requested_dependencies)
-        rescue GemNotFound => e # Handle yanked gem
-          gem_name, gem_version = extract_gem_info(e)
-          locked_gem = @locked_specs[gem_name].last
-          raise if locked_gem.nil? || locked_gem.version.to_s != gem_version || !@remote
-          raise GemNotFound, "Your bundle is locked to #{locked_gem}, but that version could not " \
-                             "be found in any of the sources listed in your Gemfile. If you haven't changed sources, " \
-                             "that means the author of #{locked_gem} has removed it. You'll need to update your bundle " \
-                             "to a version other than #{locked_gem} that hasn't been removed in order to install."
-        end
-        unless specs["bundler"].any?
-          bundler = sources.metadata_source.specs.search(Gem::Dependency.new("bundler", VERSION)).last
-          specs["bundler"] = bundler
-        end
-
-        specs
-      end
+      @specs ||= materialize(requested_dependencies)
     end
 
     def new_specs
@@ -194,14 +205,8 @@ module Bundler
       @locked_specs - specs
     end
 
-    def new_platform?
-      @new_platform
-    end
-
     def missing_specs
-      missing = []
-      resolve.materialize(requested_dependencies, missing)
-      missing
+      resolve.materialize(requested_dependencies).missing_specs
     end
 
     def missing_specs?
@@ -210,8 +215,8 @@ module Bundler
       Bundler.ui.debug "The definition is missing #{missing.map(&:full_name)}"
       true
     rescue BundlerError => e
-      @index = nil
       @resolve = nil
+      @resolver = nil
       @specs = nil
       @gem_version_promoter = nil
 
@@ -220,21 +225,43 @@ module Bundler
     end
 
     def requested_specs
-      @requested_specs ||= begin
-        groups = requested_groups
-        groups.map!(&:to_sym)
-        specs_for(groups)
-      end
+      specs_for(requested_groups)
+    end
+
+    def requested_dependencies
+      dependencies_for(requested_groups)
     end
 
     def current_dependencies
-      dependencies.select(&:should_include?)
+      dependencies.select do |d|
+        d.should_include? && !d.gem_platforms(@platforms).empty?
+      end
+    end
+
+    def locked_dependencies
+      @locked_deps.values
+    end
+
+    def new_deps
+      @new_deps ||= @dependencies - locked_dependencies
+    end
+
+    def deleted_deps
+      @deleted_deps ||= locked_dependencies - @dependencies
     end
 
     def specs_for(groups)
-      deps = dependencies.select {|d| (d.groups & groups).any? }
-      deps.delete_if {|d| !d.should_include? }
-      specs.for(expand_dependencies(deps))
+      return specs if groups.empty?
+      deps = dependencies_for(groups)
+      materialize(deps)
+    end
+
+    def dependencies_for(groups)
+      groups.map!(&:to_sym)
+      deps = current_dependencies.reject do |d|
+        (d.groups & groups).empty?
+      end
+      expand_dependencies(deps)
     end
 
     # Resolve all the dependencies specified in Gemfile. It ensures that
@@ -243,78 +270,26 @@ module Bundler
     #
     # @return [SpecSet] resolved dependencies
     def resolve
-      @resolve ||= begin
-        last_resolve = converge_locked_specs
-        resolve =
-          if Bundler.frozen_bundle?
-            Bundler.ui.debug "Frozen, using resolution from the lockfile"
-            last_resolve
-          elsif !unlocking? && nothing_changed?
-            Bundler.ui.debug("Found no changes, using resolution from the lockfile")
-            last_resolve
+      @resolve ||= if Bundler.frozen_bundle?
+        Bundler.ui.debug "Frozen, using resolution from the lockfile"
+        @locked_specs
+      elsif !unlocking? && nothing_changed?
+        if deleted_deps.any?
+          Bundler.ui.debug("Some dependencies were deleted, using a subset of the resolution from the lockfile")
+          SpecSet.new(filter_specs(@locked_specs, @dependencies - deleted_deps))
+        else
+          Bundler.ui.debug("Found no changes, using resolution from the lockfile")
+          if @locked_gems.may_include_redundant_platform_specific_gems?
+            SpecSet.new(filter_specs(@locked_specs, @dependencies))
           else
-            # Run a resolve against the locally available gems
-            Bundler.ui.debug("Found changes from the lockfile, re-resolving dependencies because #{change_reason}")
-            last_resolve.merge Resolver.resolve(expanded_dependencies, index, source_requirements, last_resolve, gem_version_promoter, additional_base_requirements_for_resolve, platforms)
+            @locked_specs
           end
-
-        # filter out gems that _can_ be installed on multiple platforms, but don't need
-        # to be
-        resolve.for(expand_dependencies(dependencies, true), [], false, false, false)
-      end
-    end
-
-    def index
-      @index ||= Index.build do |idx|
-        dependency_names = @dependencies.map(&:name)
-
-        sources.all_sources.each do |source|
-          source.dependency_names = dependency_names - pinned_spec_names(source)
-          idx.add_source source.specs
-          dependency_names.concat(source.unmet_deps).uniq!
         end
-
-        double_check_for_index(idx, dependency_names)
-      end
-    end
-
-    # Suppose the gem Foo depends on the gem Bar.  Foo exists in Source A.  Bar has some versions that exist in both
-    # sources A and B.  At this point, the API request will have found all the versions of Bar in source A,
-    # but will not have found any versions of Bar from source B, which is a problem if the requested version
-    # of Foo specifically depends on a version of Bar that is only found in source B. This ensures that for
-    # each spec we found, we add all possible versions from all sources to the index.
-    def double_check_for_index(idx, dependency_names)
-      pinned_names = pinned_spec_names
-      loop do
-        idxcount = idx.size
-
-        names = :names # do this so we only have to traverse to get dependency_names from the index once
-        unmet_dependency_names = lambda do
-          return names unless names == :names
-          new_names = sources.all_sources.map(&:dependency_names_to_double_check)
-          return names = nil if new_names.compact!
-          names = new_names.flatten(1).concat(dependency_names)
-          names.uniq!
-          names -= pinned_names
-          names
-        end
-
-        sources.all_sources.each do |source|
-          source.double_check_for(unmet_dependency_names)
-        end
-
-        break if idxcount == idx.size
+      else
+        Bundler.ui.debug("Found changes from the lockfile, re-resolving dependencies because #{change_reason}")
+        resolver.start(expanded_dependencies)
       end
     end
-    private :double_check_for_index
-
-    def has_rubygems_remotes?
-      sources.rubygems_sources.any? {|s| s.remotes.any? }
-    end
-
-    def has_local_dependencies?
-      !sources.path_sources.empty? || !sources.git_sources.empty?
-    end
 
     def spec_git_paths
       sources.git_sources.map {|s| File.realpath(s.path) if File.exist?(s.path) }.compact
@@ -325,6 +300,8 @@ module Bundler
     end
 
     def lock(file, preserve_unknown_sections = false)
+      return if Definition.no_lock
+
       contents = to_lock
 
       # Convert to \r\n if the existing lock has them
@@ -335,10 +312,7 @@ module Bundler
         locked_major = @locked_bundler_version.segments.first
         current_major = Gem::Version.create(Bundler::VERSION).segments.first
 
-        if updating_major = locked_major < current_major
-          Bundler.ui.warn "Warning: the lockfile is being updated to Bundler #{current_major}, " \
-                          "after which you will be unable to return to Bundler #{@locked_bundler_version.segments.first}."
-        end
+        updating_major = locked_major < current_major
       end
 
       preserve_unknown_sections ||= !updating_major && (Bundler.frozen_bundle? || !(unlocking? || @unlocking_bundler))
@@ -355,14 +329,6 @@ module Bundler
       end
     end
 
-    def locked_bundler_version
-      if @locked_bundler_version && @locked_bundler_version < Gem::Version.new(Bundler::VERSION)
-        new_version = Bundler::VERSION
-      end
-
-      new_version || @locked_bundler_version || Bundler::VERSION
-    end
-
     def locked_ruby_version
       return unless ruby_version
       if @unlock[:ruby] || !@locked_ruby_version
@@ -396,12 +362,10 @@ module Bundler
              "updated #{Bundler.default_lockfile.relative_path_from(SharedHelpers.pwd)} to version control."
 
       unless explicit_flag
-        suggested_command = if Bundler.settings.locations("frozen")[:global]
+        suggested_command = if Bundler.settings.locations("frozen").keys.&([:global, :local]).any?
           "bundle config unset frozen"
         elsif Bundler.settings.locations("deployment").keys.&([:global, :local]).any?
           "bundle config unset deployment"
-        else
-          "bundle install --no-deployment"
         end
         msg << "\n\nIf this is a development machine, remove the #{Bundler.default_gemfile} " \
                "freeze \nby running `#{suggested_command}`."
@@ -416,44 +380,28 @@ module Bundler
       added.concat new_platforms.map {|p| "* platform: #{p}" }
       deleted.concat deleted_platforms.map {|p| "* platform: #{p}" }
 
-      gemfile_sources = sources.lock_sources
+      added.concat new_deps.map {|d| "* #{pretty_dep(d)}" } if new_deps.any?
+      deleted.concat deleted_deps.map {|d| "* #{pretty_dep(d)}" } if deleted_deps.any?
 
-      new_sources = gemfile_sources - @locked_sources
-      deleted_sources = @locked_sources - gemfile_sources
+      both_sources = Hash.new {|h, k| h[k] = [] }
+      @dependencies.each {|d| both_sources[d.name][0] = d }
 
-      new_deps = @dependencies - @locked_deps.values
-      deleted_deps = @locked_deps.values - @dependencies
+      locked_dependencies.each do |d|
+        next if !Bundler.feature_flag.bundler_3_mode? && @locked_specs[d.name].empty?
 
-      # Check if it is possible that the source is only changed thing
-      if (new_deps.empty? && deleted_deps.empty?) && (!new_sources.empty? && !deleted_sources.empty?)
-        new_sources.reject! {|source| (source.path? && source.path.exist?) || equivalent_rubygems_remotes?(source) }
-        deleted_sources.reject! {|source| (source.path? && source.path.exist?) || equivalent_rubygems_remotes?(source) }
+        both_sources[d.name][1] = d
       end
 
-      if @locked_sources != gemfile_sources
-        if new_sources.any?
-          added.concat new_sources.map {|source| "* source: #{source}" }
-        end
+      both_sources.each do |name, (dep, lock_dep)|
+        next if dep.nil? || lock_dep.nil?
 
-        if deleted_sources.any?
-          deleted.concat deleted_sources.map {|source| "* source: #{source}" }
-        end
-      end
+        gemfile_source = dep.source || sources.default_source
+        lock_source = lock_dep.source || sources.default_source
+        next if lock_source.include?(gemfile_source)
 
-      added.concat new_deps.map {|d| "* #{pretty_dep(d)}" } if new_deps.any?
-      if deleted_deps.any?
-        deleted.concat deleted_deps.map {|d| "* #{pretty_dep(d)}" }
-      end
-
-      both_sources = Hash.new {|h, k| h[k] = [] }
-      @dependencies.each {|d| both_sources[d.name][0] = d }
-      @locked_deps.each  {|name, d| both_sources[name][1] = d.source }
-
-      both_sources.each do |name, (dep, lock_source)|
-        next unless (dep.nil? && !lock_source.nil?) || (!dep.nil? && !lock_source.nil? && !lock_source.can_lock?(dep))
-        gemfile_source_name = (dep && dep.source) || "no specified source"
-        lockfile_source_name = lock_source || "no specified source"
-        changed << "* #{name} from `#{gemfile_source_name}` to `#{lockfile_source_name}`"
+        gemfile_source_name = dep.source ? gemfile_source.identifier : "no specified source"
+        lockfile_source_name = lock_dep.source ? lock_source.identifier : "no specified source"
+        changed << "* #{name} from `#{lockfile_source_name}` to `#{gemfile_source_name}`"
       end
 
       reason = change_reason
@@ -497,15 +445,11 @@ module Bundler
     end
 
     def validate_platforms!
-      return if @platforms.any? do |bundle_platform|
-        Bundler.rubygems.platforms.any? do |local_platform|
-          MatchPlatform.platforms_match?(bundle_platform, local_platform)
-        end
-      end
+      return if current_platform_locked?
 
       raise ProductionError, "Your bundle only supports platforms #{@platforms.map(&:to_s)} " \
-        "but your local platforms are #{Bundler.rubygems.platforms.map(&:to_s)}, and " \
-        "there's no compatible match between those two lists."
+        "but your local platform is #{Bundler.local_platform}. " \
+        "Add the current platform to the lockfile with\n`bundle lock --add-platform #{Bundler.local_platform}` and try again."
     end
 
     def add_platform(platform)
@@ -518,39 +462,111 @@ module Bundler
       raise InvalidOption, "Unable to remove the platform `#{platform}` since the only platforms are #{@platforms.join ", "}"
     end
 
-    def add_current_platform
-      current_platforms.each {|platform| add_platform(platform) }
-    end
-
-    def find_resolved_spec(current_spec)
-      specs.find_by_name_and_platform(current_spec.name, current_spec.platform)
-    end
-
-    def find_indexed_specs(current_spec)
-      index[current_spec.name].select {|spec| spec.match_platform(current_spec.platform) }.sort_by(&:version)
+    def most_specific_locked_platform
+      @platforms.min_by do |bundle_platform|
+        platform_specificity_match(bundle_platform, local_platform)
+      end
     end
 
     attr_reader :sources
     private :sources
 
     def nothing_changed?
-      !@source_changes && !@dependency_changes && !@new_platform && !@path_changes && !@local_changes && !@locked_specs_incomplete_for_platform
+      !@source_changes && !@dependency_changes && !@new_platform && !@path_changes && !@local_changes
     end
 
     def unlocking?
       @unlocking
     end
 
-  private
+    private
+
+    def resolver
+      @resolver ||= begin
+        last_resolve = converge_locked_specs
+        remove_ruby_from_platforms_if_necessary!(dependencies)
+        Resolver.new(source_requirements, last_resolve, gem_version_promoter, additional_base_requirements_for_resolve(last_resolve), platforms)
+      end
+    end
+
+    def expanded_dependencies
+      @expanded_dependencies ||= expand_dependencies(dependencies + metadata_dependencies, true)
+    end
+
+    def filter_specs(specs, deps)
+      SpecSet.new(specs).for(expand_dependencies(deps, true), false, platforms)
+    end
+
+    def materialize(dependencies)
+      specs = resolve.materialize(dependencies)
+      missing_specs = specs.missing_specs
+
+      if missing_specs.any?
+        missing_specs.each do |s|
+          locked_gem = @locked_specs[s.name].last
+          next if locked_gem.nil? || locked_gem.version != s.version || !@remote
+          raise GemNotFound, "Your bundle is locked to #{locked_gem} from #{locked_gem.source}, but that version can " \
+                             "no longer be found in that source. That means the author of #{locked_gem} has removed it. " \
+                             "You'll need to update your bundle to a version other than #{locked_gem} that hasn't been " \
+                             "removed in order to install."
+        end
+
+        missing_specs_list = missing_specs.group_by(&:source).map do |source, missing_specs_for_source|
+          "#{missing_specs_for_source.map(&:full_name).join(", ")} in #{source}"
+        end
+
+        raise GemNotFound, "Could not find #{missing_specs_list.join(" nor ")}"
+      end
+
+      loop do
+        incomplete_specs = specs.incomplete_specs
+        break if incomplete_specs.empty?
+
+        Bundler.ui.debug("The lockfile does not have all gems needed for the current platform though, Bundler will still re-resolve dependencies")
+        @resolve = resolver.start(expanded_dependencies, :exclude_specs => incomplete_specs)
+        specs = resolve.materialize(dependencies)
+      end
+
+      bundler = sources.metadata_source.specs.search(Gem::Dependency.new("bundler", VERSION)).last
+      specs["bundler"] = bundler
+
+      specs
+    end
+
+    def precompute_source_requirements_for_indirect_dependencies?
+      @remote && sources.non_global_rubygems_sources.all?(&:dependency_api_available?) && !sources.aggregate_global_source?
+    end
 
-    def current_platforms
-      current_platform = Bundler.local_platform
-      [].tap do |platforms|
-        platforms << current_platform if Bundler.feature_flag.specific_platform?
-        platforms << generic(current_platform)
+    def pin_locally_available_names(source_requirements)
+      source_requirements.each_with_object({}) do |(name, original_source), new_source_requirements|
+        local_source = original_source.dup
+        local_source.local_only!
+
+        new_source_requirements[name] = if local_source.specs.search(name).any?
+          local_source
+        else
+          original_source
+        end
       end
     end
 
+    def current_ruby_platform_locked?
+      return false unless generic_local_platform == Gem::Platform::RUBY
+      return false if Bundler.settings[:force_ruby_platform] && !@platforms.include?(Gem::Platform::RUBY)
+
+      current_platform_locked?
+    end
+
+    def current_platform_locked?
+      @platforms.any? do |bundle_platform|
+        MatchPlatform.platforms_match?(bundle_platform, Bundler.local_platform)
+      end
+    end
+
+    def add_current_platform
+      add_platform(local_platform)
+    end
+
     def change_reason
       if unlocking?
         unlock_reason = @unlock.reject {|_k, v| Array(v).empty? }.map do |k, v|
@@ -569,7 +585,6 @@ module Bundler
         [@new_platform, "you added a new platform to your gemfile"],
         [@path_changes, "the gemspecs for path gems changed"],
         [@local_changes, "the gemspecs for git local gems changed"],
-        [@locked_specs_incomplete_for_platform, "the lockfile does not have all gems needed for the current platform"],
       ].select(&:first).map(&:last).join(", ")
     end
 
@@ -587,9 +602,9 @@ module Bundler
 
     def dependencies_for_source_changed?(source, locked_source = source)
       deps_for_source = @dependencies.select {|s| s.source == source }
-      locked_deps_for_source = @locked_deps.values.select {|dep| dep.source == locked_source }
+      locked_deps_for_source = locked_dependencies.select {|dep| dep.source == locked_source }
 
-      Set.new(deps_for_source) != Set.new(locked_deps_for_source)
+      deps_for_source.uniq.sort != locked_deps_for_source.sort
     end
 
     def specs_for_source_changed?(source)
@@ -648,36 +663,11 @@ module Bundler
       end
     end
 
-    def converge_rubygems_sources
-      return false if Bundler.feature_flag.disable_multisource?
-
-      changes = false
-
-      # Get the RubyGems sources from the Gemfile.lock
-      locked_gem_sources = @locked_sources.select {|s| s.is_a?(Source::Rubygems) }
-      # Get the RubyGems remotes from the Gemfile
-      actual_remotes = sources.rubygems_remotes
-
-      # If there is a RubyGems source in both
-      if !locked_gem_sources.empty? && !actual_remotes.empty?
-        locked_gem_sources.each do |locked_gem|
-          # Merge the remotes from the Gemfile into the Gemfile.lock
-          changes |= locked_gem.replace_remotes(actual_remotes, Bundler.settings[:allow_deployment_source_credential_changes])
-        end
-      end
-
-      changes
-    end
-
     def converge_sources
-      changes = false
-
-      changes |= converge_rubygems_sources
-
       # Replace the sources from the Gemfile with the sources from the Gemfile.lock,
       # if they exist in the Gemfile.lock and are `==`. If you can't find an equivalent
       # source in the Gemfile.lock, use the one from the Gemfile.
-      changes |= sources.replace_sources!(@locked_sources)
+      changes = sources.replace_sources!(@locked_sources)
 
       sources.all_sources.each do |source|
         # If the source is unlockable and the current command allows an unlock of
@@ -695,28 +685,14 @@ module Bundler
     end
 
     def converge_dependencies
-      frozen = Bundler.frozen_bundle?
-      (@dependencies + @locked_deps.values).each do |dep|
-        locked_source = @locked_deps[dep.name]
-        # This is to make sure that if bundler is installing in deployment mode and
-        # after locked_source and sources don't match, we still use locked_source.
-        if frozen && !locked_source.nil? &&
-            locked_source.respond_to?(:source) && locked_source.source.instance_of?(Source::Path) && locked_source.source.path.exist?
-          dep.source = locked_source.source
-        elsif dep.source
+      changes = false
+
+      @dependencies.each do |dep|
+        if dep.source
           dep.source = sources.get(dep.source)
         end
-        if dep.source.is_a?(Source::Gemspec)
-          dep.platforms.concat(@platforms.map {|p| Dependency::REVERSE_PLATFORM_MAP[p] }.flatten(1)).uniq!
-        end
-      end
 
-      changes = false
-      # We want to know if all match, but don't want to check all entries
-      # This means we need to return false if any dependency doesn't match
-      # the lock or doesn't exist in the lock.
-      @dependencies.each do |dependency|
-        unless locked_dep = @locked_deps[dependency.name]
+        unless locked_dep = @locked_deps[dep.name]
           changes = true
           next
         end
@@ -727,11 +703,11 @@ module Bundler
         # directive, the lockfile dependencies and resolved dependencies end up
         # with a mismatch on #type. Work around that by setting the type on the
         # dep from the lockfile.
-        locked_dep.instance_variable_set(:@type, dependency.type)
+        locked_dep.instance_variable_set(:@type, dep.type)
 
         # We already know the name matches from the hash lookup
         # so we only need to check the requirement now
-        changes ||= dependency.requirement != locked_dep.requirement
+        changes ||= dep.requirement != locked_dep.requirement
       end
 
       changes
@@ -741,50 +717,50 @@ module Bundler
     # commonly happen if the Gemfile has changed since the lockfile was last
     # generated
     def converge_locked_specs
-      deps = []
+      converged = converge_specs(@locked_specs)
 
-      # Build a list of dependencies that are the same in the Gemfile
-      # and Gemfile.lock. If the Gemfile modified a dependency, but
-      # the gem in the Gemfile.lock still satisfies it, this is fine
-      # too.
-      @dependencies.each do |dep|
-        locked_dep = @locked_deps[dep.name]
+      resolve = SpecSet.new(converged.reject {|s| @unlock[:gems].include?(s.name) })
 
-        # If the locked_dep doesn't match the dependency we're looking for then we ignore the locked_dep
-        locked_dep = nil unless locked_dep == dep
+      diff = nil
 
-        if in_locked_deps?(dep, locked_dep) || satisfies_locked_spec?(dep)
-          deps << dep
-        elsif dep.source.is_a?(Source::Path) && dep.current_platform? && (!locked_dep || dep.source != locked_dep.source)
-          @locked_specs.each do |s|
-            @unlock[:gems] << s.name if s.source == dep.source
-          end
+      # Now, we unlock any sources that do not have anymore gems pinned to it
+      sources.all_sources.each do |source|
+        next unless source.respond_to?(:unlock!)
 
-          dep.source.unlock! if dep.source.respond_to?(:unlock!)
-          dep.source.specs.each {|s| @unlock[:gems] << s.name }
+        unless resolve.any? {|s| s.source == source }
+          diff ||= @locked_specs.to_a - resolve.to_a
+          source.unlock! if diff.any? {|s| s.source == source }
         end
       end
 
-      unlock_source_unlocks_spec = Bundler.feature_flag.unlock_source_unlocks_spec?
+      resolve
+    end
 
+    def converge_specs(specs)
       converged = []
-      @locked_specs.each do |s|
-        # Replace the locked dependency's source with the equivalent source from the Gemfile
+
+      deps = @dependencies.select do |dep|
+        specs[dep].any? {|s| s.satisfies?(dep) && (!dep.source || s.source.include?(dep.source)) }
+      end
+
+      @specs_that_changed_sources = []
+
+      specs.each do |s|
         dep = @dependencies.find {|d| s.satisfies?(d) }
-        s.source = (dep && dep.source) || sources.get(s.source)
 
-        # Don't add a spec to the list if its source is expired. For example,
-        # if you change a Git gem to RubyGems.
-        next if s.source.nil?
-        next if @unlock[:sources].include?(s.source.name)
+        # Replace the locked dependency's source with the equivalent source from the Gemfile
+        s.source = if dep && dep.source
+          gemfile_source = dep.source
+          lockfile_source = s.source
 
-        # XXX This is a backwards-compatibility fix to preserve the ability to
-        # unlock a single gem by passing its name via `--source`. See issue #3759
-        # TODO: delete in Bundler 2
-        next if unlock_source_unlocks_spec && @unlock[:sources].include?(s.name)
+          @specs_that_changed_sources << s if gemfile_source != lockfile_source
 
-        # If the spec is from a path source and it doesn't exist anymore
-        # then we unlock it.
+          gemfile_source
+        else
+          sources.get_with_fallback(s.source)
+        end
+
+        next if @unlock[:sources].include?(s.source.name)
 
         # Path sources have special logic
         if s.source.instance_of?(Source::Path) || s.source.instance_of?(Source::Gemspec)
@@ -793,8 +769,8 @@ module Bundler
           rescue PathError, GitError
             # if we won't need the source (according to the lockfile),
             # don't error if the path/git source isn't available
-            next if @locked_specs.
-                    for(requested_dependencies, [], false, true, false).
+            next if specs.
+                    for(requested_dependencies, false).
                     none? {|locked_spec| locked_spec.source == s.source }
 
             raise
@@ -806,147 +782,76 @@ module Bundler
           # commonly happens if the version changed in the gemspec
           next unless new_spec
 
-          new_runtime_deps = new_spec.dependencies.select {|d| d.type != :development }
-          old_runtime_deps = s.dependencies.select {|d| d.type != :development }
-          # If the dependencies of the path source have changed and locked spec can't satisfy new dependencies, unlock it
-          next unless new_runtime_deps.sort == old_runtime_deps.sort || new_runtime_deps.all? {|d| satisfies_locked_spec?(d) }
-
           s.dependencies.replace(new_spec.dependencies)
         end
 
-        converged << s
-      end
-
-      resolve = SpecSet.new(converged)
-      @locked_specs_incomplete_for_platform = !resolve.for(expand_dependencies(deps), @unlock[:gems], true, true)
-      resolve = resolve.for(expand_dependencies(deps, true), @unlock[:gems], false, false, false)
-      diff    = nil
-
-      # Now, we unlock any sources that do not have anymore gems pinned to it
-      sources.all_sources.each do |source|
-        next unless source.respond_to?(:unlock!)
-
-        unless resolve.any? {|s| s.source == source }
-          diff ||= @locked_specs.to_a - resolve.to_a
-          source.unlock! if diff.any? {|s| s.source == source }
+        if dep.nil? && requested_dependencies.find {|d| s.name == d.name }
+          @unlock[:gems] << s.name
+        else
+          converged << s
         end
       end
 
-      resolve
-    end
-
-    def in_locked_deps?(dep, locked_dep)
-      # Because the lockfile can't link a dep to a specific remote, we need to
-      # treat sources as equivalent anytime the locked dep has all the remotes
-      # that the Gemfile dep does.
-      locked_dep && locked_dep.source && dep.source && locked_dep.source.include?(dep.source)
-    end
-
-    def satisfies_locked_spec?(dep)
-      @locked_specs[dep].any? {|s| s.satisfies?(dep) && (!dep.source || s.source.include?(dep.source)) }
-    end
-
-    # This list of dependencies is only used in #resolve, so it's OK to add
-    # the metadata dependencies here
-    def expanded_dependencies
-      @expanded_dependencies ||= begin
-        expand_dependencies(dependencies + metadata_dependencies, @remote)
-      end
+      filter_specs(converged, deps)
     end
 
     def metadata_dependencies
-      @metadata_dependencies ||= begin
-        ruby_versions = concat_ruby_version_requirements(@ruby_version)
-        if ruby_versions.empty? || !@ruby_version.exact?
-          concat_ruby_version_requirements(RubyVersion.system)
-          concat_ruby_version_requirements(locked_ruby_version_object) unless @unlock[:ruby]
-        end
-        [
-          Dependency.new("Ruby\0", ruby_versions),
-          Dependency.new("RubyGems\0", Gem::VERSION),
-        ]
-      end
-    end
-
-    def concat_ruby_version_requirements(ruby_version, ruby_versions = [])
-      return ruby_versions unless ruby_version
-      if ruby_version.patchlevel
-        ruby_versions << ruby_version.to_gem_version_with_patchlevel
-      else
-        ruby_versions.concat(ruby_version.versions.map do |version|
-          requirement = Gem::Requirement.new(version)
-          if requirement.exact?
-            "~> #{version}.0"
-          else
-            requirement
-          end
-        end)
-      end
+      @metadata_dependencies ||= [
+        Dependency.new("Ruby\0", Gem.ruby_version),
+        Dependency.new("RubyGems\0", Gem::VERSION),
+      ]
     end
 
     def expand_dependencies(dependencies, remote = false)
-      sorted_platforms = Resolver.sort_platforms(@platforms)
       deps = []
       dependencies.each do |dep|
         dep = Dependency.new(dep, ">= 0") unless dep.respond_to?(:name)
-        next if !remote && !dep.current_platform?
-        platforms = dep.gem_platforms(sorted_platforms)
-        if platforms.empty? && !Bundler.settings[:disable_platform_warnings]
-          mapped_platforms = dep.expanded_platforms
-          Bundler.ui.warn \
-            "The dependency #{dep} will be unused by any of the platforms Bundler is installing for. " \
-            "Bundler is installing for #{@platforms.join ", "} but the dependency " \
-            "is only for #{mapped_platforms.join ", "}. " \
-            "To add those platforms to the bundle, " \
-            "run `bundle lock --add-platform #{mapped_platforms.join " "}`."
-        end
-        platforms.each do |p|
-          deps << DepProxy.new(dep, p) if remote || p == generic_local_platform
-        end
+        next unless remote || dep.current_platform?
+        target_platforms = dep.gem_platforms(remote ? @platforms : [generic_local_platform])
+        deps += expand_dependency_with_platforms(dep, target_platforms)
       end
       deps
     end
 
-    def requested_dependencies
-      groups = requested_groups
-      groups.map!(&:to_sym)
-      dependencies.reject {|d| !d.should_include? || (d.groups & groups).empty? }
+    def expand_dependency_with_platforms(dep, platforms)
+      platforms.map do |p|
+        DepProxy.get_proxy(dep, p)
+      end
     end
 
     def source_requirements
-      # Load all specs from remote sources
-      index
-
       # Record the specs available in each gem's source, so that those
       # specs will be available later when the resolver knows where to
       # look for that gemspec (or its dependencies)
-      default = sources.default_source
-      source_requirements = { :default => default }
-      default = nil unless Bundler.feature_flag.disable_multisource?
-      dependencies.each do |dep|
-        next unless source = dep.source || default
-        source_requirements[dep.name] = source
+      source_requirements = if precompute_source_requirements_for_indirect_dependencies?
+        all_requirements = source_map.all_requirements
+        all_requirements = pin_locally_available_names(all_requirements) if @prefer_local
+        { :default => sources.default_source }.merge(all_requirements)
+      else
+        { :default => Source::RubygemsAggregate.new(sources, source_map) }.merge(source_map.direct_requirements)
       end
+      source_requirements.merge!(source_map.locked_requirements) unless @remote
       metadata_dependencies.each do |dep|
         source_requirements[dep.name] = sources.metadata_source
       end
+      source_requirements[:default_bundler] = source_requirements["bundler"] || sources.default_source
       source_requirements["bundler"] = sources.metadata_source # needs to come last to override
+      verify_changed_sources!
       source_requirements
     end
 
-    def pinned_spec_names(skip = nil)
-      pinned_names = []
-      default = Bundler.feature_flag.disable_multisource? && sources.default_source
-      @dependencies.each do |dep|
-        next unless dep_source = dep.source || default
-        next if dep_source == skip
-        pinned_names << dep.name
+    def verify_changed_sources!
+      @specs_that_changed_sources.each do |s|
+        if s.source.specs.search(s.name).empty?
+          raise GemNotFound, "Could not find gem '#{s.name}' in #{s.source}"
+        end
       end
-      pinned_names
     end
 
     def requested_groups
-      groups - Bundler.settings[:without] - @optional_groups + Bundler.settings[:with]
+      values = groups - Bundler.settings[:without] - @optional_groups + Bundler.settings[:with]
+      values &= Bundler.settings[:only] unless Bundler.settings[:only].empty?
+      values
     end
 
     def lockfiles_equal?(current, proposed, preserve_unknown_sections)
@@ -962,12 +867,6 @@ module Bundler
       current == proposed
     end
 
-    def extract_gem_info(error)
-      # This method will extract the error message like "Could not find foo-1.2.3 in any of the sources"
-      # to an array. The first element will be the gem name (e.g. foo), the second will be the version number.
-      error.message.scan(/Could not find (\w+)-(\d+(?:\.\d+)+)/).flatten
-    end
-
     def compute_requires
       dependencies.reduce({}) do |requires, dep|
         next requires unless dep.should_include?
@@ -979,24 +878,26 @@ module Bundler
       end
     end
 
-    def additional_base_requirements_for_resolve
-      return [] unless @locked_gems && Bundler.feature_flag.only_update_to_newer_versions?
-      dependencies_by_name = dependencies.inject({}) {|memo, dep| memo.update(dep.name => dep) }
-      @locked_gems.specs.reduce({}) do |requirements, locked_spec|
-        name = locked_spec.name
-        dependency = dependencies_by_name[name]
-        next requirements if @locked_gems.dependencies[name] != dependency
-        next requirements if dependency && dependency.source.is_a?(Source::Path)
-        dep = Gem::Dependency.new(name, ">= #{locked_spec.version}")
-        requirements[name] = DepProxy.new(dep, locked_spec.platform)
-        requirements
-      end.values
-    end
+    def additional_base_requirements_for_resolve(last_resolve)
+      return [] unless @locked_gems && unlocking? && !sources.expired_sources?(@locked_gems.sources)
+      converge_specs(@originally_locked_specs - last_resolve).map do |locked_spec|
+        Dependency.new(locked_spec.name, ">= #{locked_spec.version}")
+      end.uniq
+    end
+
+    def remove_ruby_from_platforms_if_necessary!(dependencies)
+      return if Bundler.frozen_bundle? ||
+                Bundler.local_platform == Gem::Platform::RUBY ||
+                !platforms.include?(Gem::Platform::RUBY) ||
+                (@new_platform && platforms.last == Gem::Platform::RUBY) ||
+                !@originally_locked_specs.incomplete_ruby_specs?(expand_dependencies(dependencies))
 
-    def equivalent_rubygems_remotes?(source)
-      return false unless source.is_a?(Source::Rubygems)
+      remove_platform(Gem::Platform::RUBY)
+      add_current_platform
+    end
 
-      Bundler.settings[:allow_deployment_source_credential_changes] && source.equivalent_remotes?(sources.rubygems_remotes)
+    def source_map
+      @source_map ||= SourceMap.new(sources, dependencies, @locked_specs)
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/dep_proxy.rb
+++ ruby2.7-2.7.6/lib/bundler/dep_proxy.rb
@@ -4,19 +4,18 @@ module Bundler
   class DepProxy
     attr_reader :__platform, :dep
 
+    @proxies = {}
+
+    def self.get_proxy(dep, platform)
+      @proxies[[dep, platform]] ||= new(dep, platform).freeze
+    end
+
     def initialize(dep, platform)
       @dep = dep
       @__platform = platform
     end
 
-    def hash
-      @hash ||= [dep, __platform].hash
-    end
-
-    def ==(other)
-      return false if other.class != self.class
-      dep == other.dep && __platform == other.__platform
-    end
+    private_class_method :new
 
     alias_method :eql?, :==
 
@@ -39,7 +38,15 @@ module Bundler
       s
     end
 
-  private
+    def dup
+      raise NoMethodError.new("DepProxy cannot be duplicated")
+    end
+
+    def clone
+      raise NoMethodError.new("DepProxy cannot be cloned")
+    end
+
+    private
 
     def method_missing(*args, &blk)
       @dep.send(*args, &blk)
--- ruby2.7-2.7.6.orig/lib/bundler/dependency.rb
+++ ruby2.7-2.7.6/lib/bundler/dependency.rb
@@ -7,80 +7,23 @@ require_relative "rubygems_ext"
 module Bundler
   class Dependency < Gem::Dependency
     attr_reader :autorequire
-    attr_reader :groups, :platforms, :gemfile, :git, :branch
+    attr_reader :groups, :platforms, :gemfile, :path, :git, :github, :branch, :ref, :force_ruby_platform
 
+    ALL_RUBY_VERSIONS = ((18..27).to_a + (30..31).to_a).freeze
     PLATFORM_MAP = {
-      :ruby     => Gem::Platform::RUBY,
-      :ruby_18  => Gem::Platform::RUBY,
-      :ruby_19  => Gem::Platform::RUBY,
-      :ruby_20  => Gem::Platform::RUBY,
-      :ruby_21  => Gem::Platform::RUBY,
-      :ruby_22  => Gem::Platform::RUBY,
-      :ruby_23  => Gem::Platform::RUBY,
-      :ruby_24  => Gem::Platform::RUBY,
-      :ruby_25  => Gem::Platform::RUBY,
-      :ruby_26  => Gem::Platform::RUBY,
-      :mri      => Gem::Platform::RUBY,
-      :mri_18   => Gem::Platform::RUBY,
-      :mri_19   => Gem::Platform::RUBY,
-      :mri_20   => Gem::Platform::RUBY,
-      :mri_21   => Gem::Platform::RUBY,
-      :mri_22   => Gem::Platform::RUBY,
-      :mri_23   => Gem::Platform::RUBY,
-      :mri_24   => Gem::Platform::RUBY,
-      :mri_25   => Gem::Platform::RUBY,
-      :mri_26   => Gem::Platform::RUBY,
-      :rbx      => Gem::Platform::RUBY,
-      :truffleruby => Gem::Platform::RUBY,
-      :jruby    => Gem::Platform::JAVA,
-      :jruby_18 => Gem::Platform::JAVA,
-      :jruby_19 => Gem::Platform::JAVA,
-      :mswin    => Gem::Platform::MSWIN,
-      :mswin_18 => Gem::Platform::MSWIN,
-      :mswin_19 => Gem::Platform::MSWIN,
-      :mswin_20 => Gem::Platform::MSWIN,
-      :mswin_21 => Gem::Platform::MSWIN,
-      :mswin_22 => Gem::Platform::MSWIN,
-      :mswin_23 => Gem::Platform::MSWIN,
-      :mswin_24 => Gem::Platform::MSWIN,
-      :mswin_25 => Gem::Platform::MSWIN,
-      :mswin_26 => Gem::Platform::MSWIN,
-      :mswin64    => Gem::Platform::MSWIN64,
-      :mswin64_19 => Gem::Platform::MSWIN64,
-      :mswin64_20 => Gem::Platform::MSWIN64,
-      :mswin64_21 => Gem::Platform::MSWIN64,
-      :mswin64_22 => Gem::Platform::MSWIN64,
-      :mswin64_23 => Gem::Platform::MSWIN64,
-      :mswin64_24 => Gem::Platform::MSWIN64,
-      :mswin64_25 => Gem::Platform::MSWIN64,
-      :mswin64_26 => Gem::Platform::MSWIN64,
-      :mingw    => Gem::Platform::MINGW,
-      :mingw_18 => Gem::Platform::MINGW,
-      :mingw_19 => Gem::Platform::MINGW,
-      :mingw_20 => Gem::Platform::MINGW,
-      :mingw_21 => Gem::Platform::MINGW,
-      :mingw_22 => Gem::Platform::MINGW,
-      :mingw_23 => Gem::Platform::MINGW,
-      :mingw_24 => Gem::Platform::MINGW,
-      :mingw_25 => Gem::Platform::MINGW,
-      :mingw_26 => Gem::Platform::MINGW,
-      :x64_mingw    => Gem::Platform::X64_MINGW,
-      :x64_mingw_20 => Gem::Platform::X64_MINGW,
-      :x64_mingw_21 => Gem::Platform::X64_MINGW,
-      :x64_mingw_22 => Gem::Platform::X64_MINGW,
-      :x64_mingw_23 => Gem::Platform::X64_MINGW,
-      :x64_mingw_24 => Gem::Platform::X64_MINGW,
-      :x64_mingw_25 => Gem::Platform::X64_MINGW,
-      :x64_mingw_26 => Gem::Platform::X64_MINGW,
-    }.freeze
-
-    REVERSE_PLATFORM_MAP = {}.tap do |reverse_platform_map|
-      PLATFORM_MAP.each do |key, value|
-        reverse_platform_map[value] ||= []
-        reverse_platform_map[value] << key
-      end
-
-      reverse_platform_map.each {|_, platforms| platforms.freeze }
+      :ruby        => [Gem::Platform::RUBY, ALL_RUBY_VERSIONS],
+      :mri         => [Gem::Platform::RUBY, ALL_RUBY_VERSIONS],
+      :rbx         => [Gem::Platform::RUBY],
+      :truffleruby => [Gem::Platform::RUBY],
+      :jruby       => [Gem::Platform::JAVA, [18, 19]],
+      :windows     => [Gem::Platform::WINDOWS, ALL_RUBY_VERSIONS],
+      :mswin       => [Gem::Platform::MSWIN,     ALL_RUBY_VERSIONS],
+      :mswin64     => [Gem::Platform::MSWIN64,   ALL_RUBY_VERSIONS - [18]],
+      :mingw       => [Gem::Platform::MINGW,     ALL_RUBY_VERSIONS],
+      :x64_mingw   => [Gem::Platform::X64_MINGW, ALL_RUBY_VERSIONS - [18, 19]],
+    }.each_with_object({}) do |(platform, spec), hash|
+      hash[platform] = spec[0]
+      spec[1]&.each {|version| hash[:"#{platform}_#{version}"] = spec[0] }
     end.freeze
 
     def initialize(name, version, options = {}, &blk)
@@ -90,12 +33,16 @@ module Bundler
       @autorequire    = nil
       @groups         = Array(options["group"] || :default).map(&:to_sym)
       @source         = options["source"]
+      @path           = options["path"]
       @git            = options["git"]
+      @github         = options["github"]
       @branch         = options["branch"]
+      @ref            = options["ref"]
       @platforms      = Array(options["platforms"])
       @env            = options["env"]
       @should_include = options.fetch("should_include", true)
       @gemfile        = options["gemfile"]
+      @force_ruby_platform = options["force_ruby_platform"]
 
       @autorequire = Array(options["require"] || []) if options.key?("require")
     end
@@ -105,13 +52,11 @@ module Bundler
     def gem_platforms(valid_platforms)
       return valid_platforms if @platforms.empty?
 
-      @gem_platforms ||= expanded_platforms.compact.uniq
-
-      valid_platforms & @gem_platforms
+      valid_platforms.select {|p| expanded_platforms.include?(GemHelpers.generic(p)) }
     end
 
     def expanded_platforms
-      @platforms.map {|pl| PLATFORM_MAP[pl] }
+      @expanded_platforms ||= @platforms.map {|pl| PLATFORM_MAP[pl] }.compact.flatten.uniq
     end
 
     def should_include?
@@ -139,7 +84,7 @@ module Bundler
     def to_lock
       out = super
       out << "!" if source
-      out << "\n"
+      out
     end
 
     def specific?
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/digest.rb
@@ -0,0 +1,71 @@
+# frozen_string_literal: true
+
+# This code was extracted from https://github.com/Solistra/ruby-digest which is under public domain
+module Bundler
+  module Digest
+    # The initial constant values for the 32-bit constant words A, B, C, D, and
+    # E, respectively.
+    SHA1_WORDS = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0].freeze
+
+    # The 8-bit field used for bitwise `AND` masking. Defaults to `0xFFFFFFFF`.
+    SHA1_MASK = 0xFFFFFFFF
+
+    class << self
+      def sha1(string)
+        unless string.is_a?(String)
+          raise TypeError, "can't convert #{string.class.inspect} into String"
+        end
+
+        buffer = string.b
+
+        words = SHA1_WORDS.dup
+        generate_split_buffer(buffer) do |chunk|
+          w = []
+          chunk.each_slice(4) do |a, b, c, d|
+            w << (((a << 8 | b) << 8 | c) << 8 | d)
+          end
+          a, b, c, d, e = *words
+          (16..79).each do |i|
+            w[i] = SHA1_MASK & rotate((w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16]), 1)
+          end
+          0.upto(79) do |i|
+            case i
+            when  0..19
+              f = ((b & c) | (~b & d))
+              k = 0x5A827999
+            when 20..39
+              f = (b ^ c ^ d)
+              k = 0x6ED9EBA1
+            when 40..59
+              f = ((b & c) | (b & d) | (c & d))
+              k = 0x8F1BBCDC
+            when 60..79
+              f = (b ^ c ^ d)
+              k = 0xCA62C1D6
+            end
+            t = SHA1_MASK & (SHA1_MASK & rotate(a, 5) + f + e + k + w[i])
+            a, b, c, d, e = t, a, SHA1_MASK & rotate(b, 30), c, d # rubocop:disable Style/ParallelAssignment
+          end
+          mutated = [a, b, c, d, e]
+          words.map!.with_index {|word, index| SHA1_MASK & (word + mutated[index]) }
+        end
+
+        words.pack("N*").unpack("H*").first
+      end
+
+      private
+
+      def generate_split_buffer(string, &block)
+        size   = string.bytesize * 8
+        buffer = string.bytes << 128
+        buffer << 0 while buffer.size % 64 != 56
+        buffer.concat([size].pack("Q>").bytes)
+        buffer.each_slice(64, &block)
+      end
+
+      def rotate(value, spaces)
+        value << spaces | value >> (32 - spaces)
+      end
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/lib/bundler/dsl.rb
+++ ruby2.7-2.7.6/lib/bundler/dsl.rb
@@ -16,7 +16,9 @@ module Bundler
     VALID_PLATFORMS = Bundler::Dependency::PLATFORM_MAP.keys.freeze
 
     VALID_KEYS = %w[group groups git path glob name branch ref tag require submodules
-                    platform platforms type source install_if gemfile].freeze
+                    platform platforms type source install_if gemfile force_ruby_platform].freeze
+
+    GITHUB_PULL_REQUEST_URL = %r{\Ahttps://github\.com/([A-Za-z0-9_\-\.]+/[A-Za-z0-9_\-\.]+)/pull/(\d+)\z}.freeze
 
     attr_reader :gemspecs
     attr_accessor :dependencies
@@ -44,7 +46,7 @@ module Bundler
       @gemfile = expanded_gemfile_path
       @gemfiles << expanded_gemfile_path
       contents ||= Bundler.read_file(@gemfile.to_s)
-      instance_eval(contents.dup.tap{|x| x.untaint if RUBY_VERSION < "2.7" }, gemfile.to_s, 1)
+      instance_eval(contents.dup.tap {|x| x.untaint if RUBY_VERSION < "2.7" }, gemfile.to_s, 1)
     rescue Exception => e # rubocop:disable Lint/RescueException
       message = "There was an error " \
         "#{e.is_a?(GemfileEvalError) ? "evaluating" : "parsing"} " \
@@ -63,7 +65,7 @@ module Bundler
       development_group = opts[:development_group] || :development
       expanded_path     = gemfile_root.join(path)
 
-      gemspecs = Dir[File.join(expanded_path, "{,*}.gemspec")].map {|g| Bundler.load_gemspec(g) }.compact
+      gemspecs = Gem::Util.glob_files_in_dir("{,*}.gemspec", expanded_path).map {|g| Bundler.load_gemspec(g) }.compact
       gemspecs.reject! {|s| s.name != name } if name
       Index.sort_specs(gemspecs)
       specs_by_name_and_version = gemspecs.group_by {|s| [s.name, s.version] }
@@ -75,8 +77,7 @@ module Bundler
 
         @gemspecs << spec
 
-        gem_platforms = Bundler::Dependency::REVERSE_PLATFORM_MAP[Bundler::GemHelpers.generic_local_platform]
-        gem spec.name, :name => spec.name, :path => path, :glob => glob, :platforms => gem_platforms
+        gem spec.name, :name => spec.name, :path => path, :glob => glob
 
         group(development_group) do
           spec.development_dependencies.each do |dep|
@@ -104,8 +105,8 @@ module Bundler
       if current = @dependencies.find {|d| d.name == dep.name }
         deleted_dep = @dependencies.delete(current) if current.type == :development
 
-        if current.requirement != dep.requirement
-          unless deleted_dep
+        unless deleted_dep
+          if current.requirement != dep.requirement
             return if dep.type == :development
 
             update_prompt = ""
@@ -123,21 +124,16 @@ module Bundler
             raise GemfileError, "You cannot specify the same gem twice with different version requirements.\n" \
                             "You specified: #{current.name} (#{current.requirement}) and #{dep.name} (#{dep.requirement})" \
                              "#{update_prompt}"
-          end
-
-        else
-          Bundler.ui.warn "Your Gemfile lists the gem #{current.name} (#{current.requirement}) more than once.\n" \
-                          "You should probably keep only one of them.\n" \
-                          "Remove any duplicate entries and specify the gem only once.\n" \
-                          "While it's not a problem now, it could cause errors if you change the version of one of them later."
-        end
-
-        if current.source != dep.source
-          unless deleted_dep
+          elsif current.source != dep.source
             return if dep.type == :development
             raise GemfileError, "You cannot specify the same gem twice coming from different sources.\n" \
                             "You specified that #{dep.name} (#{dep.requirement}) should come from " \
                             "#{current.source || "an unspecified source"} and #{dep.source}\n"
+          else
+            Bundler.ui.warn "Your Gemfile lists the gem #{current.name} (#{current.requirement}) more than once.\n" \
+                            "You should probably keep only one of them.\n" \
+                            "Remove any duplicate entries and specify the gem only once.\n" \
+                            "While it's not a problem now, it could cause errors if you change the version of one of them later."
           end
         end
       end
@@ -165,8 +161,7 @@ module Bundler
       elsif block_given?
         with_source(@sources.add_rubygems_source("remotes" => source), &blk)
       else
-        check_primary_source_safety(@sources)
-        @sources.global_rubygems_source = source
+        @sources.add_global_rubygems_remote(source)
       end
     end
 
@@ -184,24 +179,14 @@ module Bundler
     end
 
     def path(path, options = {}, &blk)
-      unless block_given?
-        msg = "You can no longer specify a path source by itself. Instead, \n" \
-              "either use the :path option on a gem, or specify the gems that \n" \
-              "bundler should find in the path source by passing a block to \n" \
-              "the path method, like: \n\n" \
-              "    path 'dir/containing/rails' do\n" \
-              "      gem 'rails'\n" \
-              "    end\n\n"
-
-        raise DeprecatedError, msg if Bundler.feature_flag.disable_multisource?
-        SharedHelpers.major_deprecation(2, msg.strip)
-      end
-
       source_options = normalize_hash(options).merge(
         "path" => Pathname.new(path),
         "root_path" => gemfile_root,
         "gemspec" => gemspecs.find {|g| g.name == options["name"] }
       )
+
+      source_options["global"] = true unless block_given?
+
       source = @sources.add_path_source(source_options)
       with_source(source, &blk)
     end
@@ -223,7 +208,6 @@ module Bundler
 
     def github(repo, options = {})
       raise ArgumentError, "GitHub sources require a block" unless block_given?
-      raise DeprecatedError, "The #github method has been removed" if Bundler.feature_flag.skip_default_git_sources?
       github_uri  = @git_sources["github"].call(repo)
       git_options = normalize_hash(options).merge("uri" => github_uri)
       git_source  = @sources.add_git_source(git_options)
@@ -231,6 +215,7 @@ module Bundler
     end
 
     def to_definition(lockfile, unlock)
+      check_primary_source_safety
       Definition.new(lockfile, @dependencies, @sources, unlock, @ruby_version, @optional_groups, @gemfiles)
     end
 
@@ -281,32 +266,33 @@ module Bundler
       raise GemfileError, "Undefined local variable or method `#{name}' for Gemfile"
     end
 
-  private
+    def check_primary_source_safety
+      check_path_source_safety
+      check_rubygems_source_safety
+    end
 
-    def add_git_sources
-      return if Bundler.feature_flag.skip_default_git_sources?
+    private
 
+    def add_git_sources
       git_source(:github) do |repo_name|
-        warn_deprecated_git_source(:github, <<-'RUBY'.strip, 'Change any "reponame" :github sources to "username/reponame".')
-"https://github.com/#{repo_name}.git"
-        RUBY
-        repo_name = "#{repo_name}/#{repo_name}" unless repo_name.include?("/")
-        "https://github.com/#{repo_name}.git"
+        if repo_name =~ GITHUB_PULL_REQUEST_URL
+          {
+            "git" => "https://github.com/#{$1}.git",
+            "branch" => "refs/pull/#{$2}/head",
+            "ref" => nil,
+            "tag" => nil,
+          }
+        else
+          repo_name = "#{repo_name}/#{repo_name}" unless repo_name.include?("/")
+          "https://github.com/#{repo_name}.git"
+        end
       end
 
       git_source(:gist) do |repo_name|
-        warn_deprecated_git_source(:gist, '"https://gist.github.com/#{repo_name}.git"')
-
         "https://gist.github.com/#{repo_name}.git"
       end
 
       git_source(:bitbucket) do |repo_name|
-        warn_deprecated_git_source(:bitbucket, <<-'RUBY'.strip)
-user_name, repo_name = repo_name.split("/")
-repo_name ||= user_name
-"https://#{user_name}@bitbucket.org/#{user_name}/#{repo_name}.git"
-        RUBY
-
         user_name, repo_name = repo_name.split("/")
         repo_name ||= user_name
         "https://#{user_name}@bitbucket.org/#{user_name}/#{repo_name}.git"
@@ -377,7 +363,11 @@ repo_name ||= user_name
 
       git_name = (git_names & opts.keys).last
       if @git_sources[git_name]
-        opts["git"] = @git_sources[git_name].call(opts[git_name])
+        git_opts = @git_sources[git_name].call(opts[git_name])
+        git_opts = { "git" => git_opts } if git_opts.is_a?(String)
+        opts.merge!(git_opts) do |key, _gemfile_value, _git_source_value|
+          raise GemfileError, %(The :#{key} option can't be used with `#{git_name}: #{opts[git_name].inspect}`)
+        end
       end
 
       %w[git path].each do |type|
@@ -444,42 +434,47 @@ repo_name ||= user_name
       end
     end
 
-    def check_primary_source_safety(source_list)
-      return if source_list.rubygems_primary_remotes.empty? && source_list.global_rubygems_source.nil?
+    def check_path_source_safety
+      return if @sources.global_path_source.nil?
+
+      msg = "You can no longer specify a path source by itself. Instead, \n" \
+              "either use the :path option on a gem, or specify the gems that \n" \
+              "bundler should find in the path source by passing a block to \n" \
+              "the path method, like: \n\n" \
+              "    path 'dir/containing/rails' do\n" \
+              "      gem 'rails'\n" \
+              "    end\n\n"
+
+      SharedHelpers.major_deprecation(2, msg.strip)
+    end
+
+    def check_rubygems_source_safety
+      if @sources.implicit_global_source?
+        implicit_global_source_warning
+      elsif @sources.aggregate_global_source?
+        multiple_global_source_warning
+      end
+    end
 
-      if Bundler.feature_flag.disable_multisource?
-        msg = "This Gemfile contains multiple primary sources. " \
+    def implicit_global_source_warning
+      Bundler::SharedHelpers.major_deprecation 2, "This Gemfile does not include an explicit global source. " \
+        "Not using an explicit global source may result in a different lockfile being generated depending on " \
+        "the gems you have installed locally before bundler is run. " \
+        "Instead, define a global source in your Gemfile like this: source \"https://rubygems.org\"."
+    end
+
+    def multiple_global_source_warning
+      if Bundler.feature_flag.bundler_3_mode?
+        msg = "This Gemfile contains multiple global sources. " \
           "Each source after the first must include a block to indicate which gems " \
           "should come from that source"
-        unless Bundler.feature_flag.bundler_2_mode?
-          msg += ". To downgrade this error to a warning, run " \
-            "`bundle config unset disable_multisource`"
-        end
         raise GemfileEvalError, msg
       else
-        Bundler::SharedHelpers.major_deprecation 2, "Your Gemfile contains multiple primary sources. " \
+        Bundler::SharedHelpers.major_deprecation 2, "Your Gemfile contains multiple global sources. " \
           "Using `source` more than once without a block is a security risk, and " \
           "may result in installing unexpected gems. To resolve this warning, use " \
-          "a block to indicate which gems should come from the secondary source. " \
-          "To upgrade this warning to an error, run `bundle config set " \
-          "disable_multisource true`."
-      end
-    end
-
-    def warn_deprecated_git_source(name, replacement, additional_message = nil)
-      additional_message &&= " #{additional_message}"
-      replacement = if replacement.count("\n").zero?
-        "{|repo_name| #{replacement} }"
-      else
-        "do |repo_name|\n#{replacement.to_s.gsub(/^/, "      ")}\n    end"
+          "a block to indicate which gems should come from the secondary source."
       end
-
-      Bundler::SharedHelpers.major_deprecation 3, <<-EOS
-The :#{name} git source is deprecated, and will be removed in the future.#{additional_message} Add this code to the top of your Gemfile to ensure it continues to work:
-
-    git_source(:#{name}) #{replacement}
-
-      EOS
     end
 
     class DSLError < GemfileError
@@ -516,9 +511,7 @@ The :#{name} git source is deprecated, a
       #         be raised.
       #
       def contents
-        @contents ||= begin
-          dsl_path && File.exist?(dsl_path) && File.read(dsl_path)
-        end
+        @contents ||= dsl_path && File.exist?(dsl_path) && File.read(dsl_path)
       end
 
       # The message of the exception reports the content of podspec for the
@@ -571,7 +564,7 @@ The :#{name} git source is deprecated, a
         end
       end
 
-    private
+      private
 
       def parse_line_number_from_description
         description = self.description
--- ruby2.7-2.7.6.orig/lib/bundler/endpoint_specification.rb
+++ ruby2.7-2.7.6/lib/bundler/endpoint_specification.rb
@@ -3,17 +3,17 @@
 module Bundler
   # used for Creating Specifications from the Gemcutter Endpoint
   class EndpointSpecification < Gem::Specification
-    ILLFORMED_MESSAGE = 'Ill-formed requirement ["#<YAML::Syck::DefaultKey'.freeze
-    include MatchPlatform
+    include MatchRemoteMetadata
 
-    attr_reader :name, :version, :platform, :required_rubygems_version, :required_ruby_version, :checksum
+    attr_reader :name, :version, :platform, :checksum
     attr_accessor :source, :remote, :dependencies
 
-    def initialize(name, version, platform, dependencies, metadata = nil)
+    def initialize(name, version, platform, spec_fetcher, dependencies, metadata = nil)
       super()
       @name         = name
       @version      = Gem::Version.create version
-      @platform     = platform
+      @platform     = Gem::Platform.new(platform)
+      @spec_fetcher = spec_fetcher
       @dependencies = dependencies.map {|dep, reqs| build_dependency(dep, reqs) }
 
       @loaded_from          = nil
@@ -104,14 +104,23 @@ module Bundler
       @remote_specification = spec
     end
 
-  private
+    private
+
+    def _remote_specification
+      @_remote_specification ||= @spec_fetcher.fetch_spec([@name, @version, @platform])
+    end
 
     def local_specification_path
       "#{base_dir}/specifications/#{full_name}.gemspec"
     end
 
     def parse_metadata(data)
-      return unless data
+      unless data
+        @required_ruby_version = nil
+        @required_rubygems_version = nil
+        return
+      end
+
       data.each do |k, v|
         next unless v
         case k.to_s
@@ -129,13 +138,6 @@ module Bundler
 
     def build_dependency(name, requirements)
       Gem::Dependency.new(name, requirements)
-    rescue ArgumentError => e
-      raise unless e.message.include?(ILLFORMED_MESSAGE)
-      puts # we shouldn't print the error message on the "fetching info" status line
-      raise GemspecError,
-        "Unfortunately, the gem #{name} (#{version}) has an invalid " \
-        "gemspec.\nPlease ask the gem author to yank the bad version to fix " \
-        "this issue. For more information, see http://bit.ly/syck-defaultkey."
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/env.rb
+++ ruby2.7-2.7.6/lib/bundler/env.rb
@@ -71,7 +71,7 @@ module Bundler
     def self.ruby_version
       str = String.new(RUBY_VERSION)
       str << "p#{RUBY_PATCHLEVEL}" if defined? RUBY_PATCHLEVEL
-      str << " (#{RUBY_RELEASE_DATE} revision #{RUBY_REVISION}) [#{RUBY_PLATFORM}]"
+      str << " (#{RUBY_RELEASE_DATE} revision #{RUBY_REVISION}) [#{Gem::Platform.local}]"
     end
 
     def self.git_version
@@ -105,7 +105,7 @@ module Bundler
       out << ["  User Home", Gem.user_home]
       out << ["  User Path", Gem.user_dir]
       out << ["  Bin Dir", Gem.bindir]
-      if defined?(OpenSSL)
+      if defined?(OpenSSL::SSL)
         out << ["OpenSSL"]
         out << ["  Compiled", OpenSSL::OPENSSL_VERSION] if defined?(OpenSSL::OPENSSL_VERSION)
         out << ["  Loaded", OpenSSL::OPENSSL_LIBRARY_VERSION] if defined?(OpenSSL::OPENSSL_LIBRARY_VERSION)
--- ruby2.7-2.7.6.orig/lib/bundler/environment_preserver.rb
+++ ruby2.7-2.7.6/lib/bundler/environment_preserver.rb
@@ -17,14 +17,41 @@ module Bundler
     ].map(&:freeze).freeze
     BUNDLER_PREFIX = "BUNDLER_ORIG_".freeze
 
-    # @param env [ENV]
+    def self.from_env
+      new(env_to_hash(ENV), BUNDLER_KEYS)
+    end
+
+    def self.env_to_hash(env)
+      to_hash = env.to_hash
+      return to_hash unless Gem.win_platform?
+
+      to_hash.each_with_object({}) {|(k,v), a| a[k.upcase] = v }
+    end
+
+    # @param env [Hash]
     # @param keys [Array<String>]
     def initialize(env, keys)
-      @original = env.to_hash
+      @original = env
       @keys = keys
       @prefix = BUNDLER_PREFIX
     end
 
+    # Replaces `ENV` with the bundler environment variables backed up
+    def replace_with_backup
+      unless Gem.win_platform?
+        ENV.replace(backup)
+        return
+      end
+
+      # Fallback logic for Windows below to workaround
+      # https://bugs.ruby-lang.org/issues/16798. Can be dropped once all
+      # supported rubies include the fix for that.
+
+      ENV.clear
+
+      backup.each {|k, v| ENV[k] = v }
+    end
+
     # @return [Hash]
     def backup
       env = @original.clone
--- ruby2.7-2.7.6.orig/lib/bundler/errors.rb
+++ ruby2.7-2.7.6/lib/bundler/errors.rb
@@ -41,12 +41,14 @@ module Bundler
   class GemspecError < BundlerError; status_code(14); end
   class InvalidOption < BundlerError; status_code(15); end
   class ProductionError < BundlerError; status_code(16); end
+
   class HTTPError < BundlerError
     status_code(17)
     def filter_uri(uri)
       URICredentialsFilter.credential_filtered_uri(uri)
     end
   end
+
   class RubyVersionMismatch < BundlerError; status_code(18); end
   class SecurityError < BundlerError; status_code(19); end
   class LockfileError < BundlerError; status_code(20); end
@@ -56,6 +58,7 @@ module Bundler
   class SudoNotPermittedError < BundlerError; status_code(30); end
   class ThreadCreationError < BundlerError; status_code(33); end
   class APIResponseMismatchError < BundlerError; status_code(34); end
+  class APIResponseInvalidDependenciesError < BundlerError; status_code(35); end
   class GemfileEvalError < GemfileError; end
   class MarshalError < StandardError; end
 
@@ -74,10 +77,22 @@ module Bundler
       end
     end
 
+    def permission_type
+      case @permission_type
+      when :create
+        "executable permissions for all parent directories and write permissions for `#{parent_folder}`"
+      else
+        "#{@permission_type} permissions for that path"
+      end
+    end
+
+    def parent_folder
+      File.dirname(@path)
+    end
+
     def message
       "There was an error while trying to #{action} `#{@path}`. " \
-      "It is likely that you need to grant #{@permission_type} permissions " \
-      "for that path."
+      "It is likely that you need to grant #{permission_type}."
     end
 
     status_code(23)
@@ -121,7 +136,7 @@ module Bundler
 
   class VirtualProtocolError < BundlerError
     def message
-      "There was an error relating to virtualization and file access." \
+      "There was an error relating to virtualization and file access. " \
       "It is likely that you need to grant access to or mount some file system correctly."
     end
 
@@ -155,4 +170,16 @@ module Bundler
 
     status_code(32)
   end
+
+  class DirectoryRemovalError < BundlerError
+    def initialize(orig_exception, msg)
+      full_message = "#{msg}.\n" \
+                     "The underlying error was #{orig_exception.class}: #{orig_exception.message}, with backtrace:\n" \
+                     "  #{orig_exception.backtrace.join("\n  ")}\n\n" \
+                     "Bundler Error Backtrace:"
+      super(full_message)
+    end
+
+    status_code(36)
+  end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/feature_flag.rb
+++ ruby2.7-2.7.6/lib/bundler/feature_flag.rb
@@ -27,27 +27,18 @@ module Bundler
 
     (1..10).each {|v| define_method("bundler_#{v}_mode?") { major_version >= v } }
 
-    settings_flag(:allow_bundler_dependency_conflicts) { bundler_3_mode? }
     settings_flag(:allow_offline_install) { bundler_3_mode? }
     settings_flag(:auto_clean_without_path) { bundler_3_mode? }
-    settings_flag(:auto_config_jobs) { bundler_3_mode? }
     settings_flag(:cache_all) { bundler_3_mode? }
     settings_flag(:default_install_uses_path) { bundler_3_mode? }
-    settings_flag(:deployment_means_frozen) { bundler_3_mode? }
-    settings_flag(:disable_multisource) { bundler_3_mode? }
     settings_flag(:forget_cli_options) { bundler_3_mode? }
     settings_flag(:global_gem_cache) { bundler_3_mode? }
-    settings_flag(:only_update_to_newer_versions) { bundler_3_mode? }
     settings_flag(:path_relative_to_cwd) { bundler_3_mode? }
     settings_flag(:plugins) { @bundler_version >= Gem::Version.new("1.14") }
     settings_flag(:print_only_version_number) { bundler_3_mode? }
     settings_flag(:setup_makes_kernel_gem_public) { !bundler_3_mode? }
-    settings_flag(:skip_default_git_sources) { bundler_3_mode? }
-    settings_flag(:specific_platform) { bundler_3_mode? }
     settings_flag(:suppress_install_using_messages) { bundler_3_mode? }
-    settings_flag(:unlock_source_unlocks_spec) { !bundler_3_mode? }
     settings_flag(:update_requires_all_flag) { bundler_4_mode? }
-    settings_flag(:use_gem_version_promoter_for_major_updates) { bundler_3_mode? }
 
     settings_option(:default_cli_command) { bundler_3_mode? ? :cli_help : :install }
 
--- ruby2.7-2.7.6.orig/lib/bundler/fetcher.rb
+++ ruby2.7-2.7.6/lib/bundler/fetcher.rb
@@ -20,6 +20,7 @@ module Bundler
     class TooManyRequestsError < HTTPError; end
     # This error is raised if the API returns a 413 (only printed in verbose)
     class FallbackError < HTTPError; end
+
     # This is the error raised if OpenSSL fails the cert verification
     class CertificateFailureError < HTTPError
       def initialize(remote_uri)
@@ -28,10 +29,12 @@ module Bundler
           " is a chance you are experiencing a man-in-the-middle attack, but" \
           " most likely your system doesn't have the CA certificates needed" \
           " for verification. For information about OpenSSL certificates, see" \
-          " http://bit.ly/ruby-ssl. To connect without using SSL, edit your Gemfile" \
+          " https://railsapps.github.io/openssl-certificate-verify-failed.html." \
+          " To connect without using SSL, edit your Gemfile" \
           " sources and change 'https' to 'http'."
       end
     end
+
     # This is the error raised when a source is HTTPS and OpenSSL didn't load
     class SSLError < HTTPError
       def initialize(msg = nil)
@@ -41,15 +44,18 @@ module Bundler
             "using RVM are available at rvm.io/packages/openssl."
       end
     end
+
     # This error is raised if HTTP authentication is required, but not provided.
     class AuthenticationRequiredError < HTTPError
       def initialize(remote_uri)
         remote_uri = filter_uri(remote_uri)
         super "Authentication is required for #{remote_uri}.\n" \
           "Please supply credentials for this source. You can do this by running:\n" \
-          " bundle config set #{remote_uri} username:password"
+          "`bundle config set --global #{remote_uri} username:password`\n" \
+          "or by storing the credentials in the `#{Settings.key_for(remote_uri)}` environment variable"
       end
     end
+
     # This error is raised if HTTP authentication is provided, but incorrect.
     class BadAuthenticationError < HTTPError
       def initialize(remote_uri)
@@ -69,8 +75,8 @@ module Bundler
                   :HTTPUnsupportedMediaType, :HTTPVersionNotSupported].freeze
     FAIL_ERRORS = begin
       fail_errors = [AuthenticationRequiredError, BadAuthenticationError, FallbackError]
-      fail_errors << Gem::Requirement::BadRequirementError if defined?(Gem::Requirement::BadRequirementError)
-      fail_errors.concat(NET_ERRORS.map {|e| SharedHelpers.const_get_safely(e, Net) }.compact)
+      fail_errors << Gem::Requirement::BadRequirementError
+      fail_errors.concat(NET_ERRORS.map {|e| Net.const_get(e) })
     end.freeze
 
     class << self
@@ -120,7 +126,6 @@ module Bundler
 
     # return the specs in the bundler format as an index
     def specs(gem_names, source)
-      old = Bundler.rubygems.sources
       index = Bundler::Index.new
 
       if Bundler::Fetcher.disable_endpoint
@@ -128,18 +133,15 @@ module Bundler
         specs = fetchers.last.specs(gem_names)
       else
         specs = []
-        fetchers.shift until fetchers.first.available? || fetchers.empty?
-        fetchers.dup.each do |f|
-          break unless f.api_fetcher? && !gem_names || !specs = f.specs(gem_names)
-          fetchers.delete(f)
+        @fetchers = fetchers.drop_while do |f|
+          !f.available? || (f.api_fetcher? && !gem_names) || !specs = f.specs(gem_names)
         end
         @use_api = false if fetchers.none?(&:api_fetcher?)
       end
 
       specs.each do |name, version, platform, dependencies, metadata|
-        next if name == "bundler"
         spec = if dependencies
-          EndpointSpecification.new(name, version, platform, dependencies, metadata)
+          EndpointSpecification.new(name, version, platform, self, dependencies, metadata)
         else
           RemoteSpecification.new(name, version, platform, self)
         end
@@ -152,8 +154,6 @@ module Bundler
     rescue CertificateFailureError
       Bundler.ui.info "" if gem_names && use_api # newline after dots
       raise
-    ensure
-      Bundler.rubygems.sources = old
     end
 
     def use_api
@@ -216,7 +216,7 @@ module Bundler
       "#<#{self.class}:0x#{object_id} uri=#{uri}>"
     end
 
-  private
+    private
 
     FETCHERS = [CompactIndex, Dependency, Index].freeze
 
@@ -229,6 +229,8 @@ module Bundler
         "BUILDBOX" => "buildbox",
         "GO_SERVER_URL" => "go",
         "SNAP_CI" => "snap",
+        "GITLAB_CI" => "gitlab",
+        "GITHUB_ACTIONS" => "github",
         "CI_NAME" => ENV["CI_NAME"],
         "CI" => "ci",
       }
@@ -238,12 +240,12 @@ module Bundler
     def connection
       @connection ||= begin
         needs_ssl = remote_uri.scheme == "https" ||
-          Bundler.settings[:ssl_verify_mode] ||
-          Bundler.settings[:ssl_client_cert]
+                    Bundler.settings[:ssl_verify_mode] ||
+                    Bundler.settings[:ssl_client_cert]
         raise SSLError if needs_ssl && !defined?(OpenSSL::SSL)
 
         con = PersistentHTTP.new :name => "bundler", :proxy => :ENV
-        if gem_proxy = Bundler.rubygems.configuration[:http_proxy]
+        if gem_proxy = Gem.configuration[:http_proxy]
           con.proxy = Bundler::URI.parse(gem_proxy) if gem_proxy != :no_proxy
         end
 
@@ -254,8 +256,8 @@ module Bundler
         end
 
         ssl_client_cert = Bundler.settings[:ssl_client_cert] ||
-          (Bundler.rubygems.configuration.ssl_client_cert if
-            Bundler.rubygems.configuration.respond_to?(:ssl_client_cert))
+                          (Gem.configuration.ssl_client_cert if
+                            Gem.configuration.respond_to?(:ssl_client_cert))
         if ssl_client_cert
           pem = File.read(ssl_client_cert)
           con.cert = OpenSSL::X509::Certificate.new(pem)
@@ -273,8 +275,7 @@ module Bundler
     # cached gem specification path, if one exists
     def gemspec_cached_path(spec_file_name)
       paths = Bundler.rubygems.spec_cache_dirs.map {|dir| File.join(dir, spec_file_name) }
-      paths = paths.select {|path| File.file? path }
-      paths.first
+      paths.find {|path| File.file? path }
     end
 
     HTTP_ERRORS = [
@@ -287,8 +288,8 @@ module Bundler
     def bundler_cert_store
       store = OpenSSL::X509::Store.new
       ssl_ca_cert = Bundler.settings[:ssl_ca_cert] ||
-        (Bundler.rubygems.configuration.ssl_ca_cert if
-          Bundler.rubygems.configuration.respond_to?(:ssl_ca_cert))
+                    (Gem.configuration.ssl_ca_cert if
+                      Gem.configuration.respond_to?(:ssl_ca_cert))
       if ssl_ca_cert
         if File.directory? ssl_ca_cert
           store.add_path ssl_ca_cert
@@ -302,8 +303,6 @@ module Bundler
       store
     end
 
-  private
-
     def remote_uri
       @remote.uri
     end
--- ruby2.7-2.7.6.orig/lib/bundler/fetcher/base.rb
+++ ruby2.7-2.7.6/lib/bundler/fetcher/base.rb
@@ -19,14 +19,12 @@ module Bundler
       end
 
       def fetch_uri
-        @fetch_uri ||= begin
-          if remote_uri.host == "rubygems.org"
-            uri = remote_uri.dup
-            uri.host = "index.rubygems.org"
-            uri
-          else
-            remote_uri
-          end
+        @fetch_uri ||= if remote_uri.host == "rubygems.org"
+          uri = remote_uri.dup
+          uri.host = "index.rubygems.org"
+          uri
+        else
+          remote_uri
         end
       end
 
@@ -38,7 +36,7 @@ module Bundler
         false
       end
 
-    private
+      private
 
       def log_specs(debug_msg)
         if Bundler.ui.debug?
--- ruby2.7-2.7.6.orig/lib/bundler/fetcher/compact_index.rb
+++ ruby2.7-2.7.6/lib/bundler/fetcher/compact_index.rb
@@ -57,22 +57,17 @@ module Bundler
         gem_info
       end
 
-      def fetch_spec(spec)
-        spec -= [nil, "ruby", ""]
-        contents = compact_index_client.spec(*spec)
-        return nil if contents.nil?
-        contents.unshift(spec.first)
-        contents[3].map! {|d| Gem::Dependency.new(*d) }
-        EndpointSpecification.new(*contents)
-      end
-      compact_index_request :fetch_spec
-
       def available?
-        return nil unless SharedHelpers.md5_available?
-        user_home = Bundler.user_home
-        return nil unless user_home.directory? && user_home.writable?
+        unless SharedHelpers.md5_available?
+          Bundler.ui.debug("FIPS mode is enabled, bundler can't use the CompactIndex API")
+          return nil
+        end
+        if fetch_uri.scheme == "file"
+          Bundler.ui.debug("Using a local server, bundler won't use the CompactIndex API")
+          return false
+        end
         # Read info file checksums out of /versions, so we can know if gems are up to date
-        fetch_uri.scheme != "file" && compact_index_client.update_and_parse_checksums!
+        compact_index_client.update_and_parse_checksums!
       rescue CompactIndexClient::Updater::MisMatchedChecksumError => e
         Bundler.ui.debug(e.message)
         nil
@@ -83,7 +78,7 @@ module Bundler
         true
       end
 
-    private
+      private
 
       def compact_index_client
         @compact_index_client ||=
@@ -111,7 +106,7 @@ module Bundler
       def bundle_worker(func = nil)
         @bundle_worker ||= begin
           worker_name = "Compact Index (#{display_uri.host})"
-          Bundler::Worker.new(Bundler.current_ruby.rbx? ? 1 : 25, worker_name, func)
+          Bundler::Worker.new(Bundler.settings.processor_count, worker_name, func)
         end
         @bundle_worker.tap do |worker|
           worker.instance_variable_set(:@func, func) if func
--- ruby2.7-2.7.6.orig/lib/bundler/fetcher/downloader.rb
+++ ruby2.7-2.7.6/lib/bundler/fetcher/downloader.rb
@@ -14,8 +14,10 @@ module Bundler
       def fetch(uri, headers = {}, counter = 0)
         raise HTTPError, "Too many redirects" if counter >= redirect_limit
 
+        filtered_uri = URICredentialsFilter.credential_filtered_uri(uri)
+
         response = request(uri, headers)
-        Bundler.ui.debug("HTTP #{response.code} #{response.message} #{uri}")
+        Bundler.ui.debug("HTTP #{response.code} #{response.message} #{filtered_uri}")
 
         case response
         when Net::HTTPSuccess, Net::HTTPNotModified
@@ -40,7 +42,7 @@ module Bundler
           raise BadAuthenticationError, uri.host if uri.userinfo
           raise AuthenticationRequiredError, uri.host
         when Net::HTTPNotFound
-          raise FallbackError, "Net::HTTPNotFound: #{URICredentialsFilter.credential_filtered_uri(uri)}"
+          raise FallbackError, "Net::HTTPNotFound: #{filtered_uri}"
         else
           raise HTTPError, "#{response.class}#{": #{response.body}" unless response.body.empty?}"
         end
@@ -49,7 +51,9 @@ module Bundler
       def request(uri, headers)
         validate_uri_scheme!(uri)
 
-        Bundler.ui.debug "HTTP GET #{uri}"
+        filtered_uri = URICredentialsFilter.credential_filtered_uri(uri)
+
+        Bundler.ui.debug "HTTP GET #{filtered_uri}"
         req = Net::HTTP::Get.new uri.request_uri, headers
         if uri.user
           user = CGI.unescape(uri.user)
@@ -64,17 +68,16 @@ module Bundler
         raise CertificateFailureError.new(uri)
       rescue *HTTP_ERRORS => e
         Bundler.ui.trace e
-        case e.message
-        when /host down:/, /getaddrinfo: nodename nor servname provided/
+        if e.is_a?(SocketError) || e.message =~ /host down:/
           raise NetworkDownError, "Could not reach host #{uri.host}. Check your network " \
             "connection and try again."
         else
-          raise HTTPError, "Network error while fetching #{URICredentialsFilter.credential_filtered_uri(uri)}" \
+          raise HTTPError, "Network error while fetching #{filtered_uri}" \
             " (#{e})"
         end
       end
 
-    private
+      private
 
       def validate_uri_scheme!(uri)
         return if uri.scheme =~ /\Ahttps?\z/
--- ruby2.7-2.7.6.orig/lib/bundler/fetcher/index.rb
+++ ruby2.7-2.7.6/lib/bundler/fetcher/index.rb
@@ -1,14 +1,13 @@
 # frozen_string_literal: true
 
 require_relative "base"
-require "rubygems/remote_fetcher"
 
 module Bundler
   class Fetcher
     class Index < Base
       def specs(_gem_names)
         Bundler.rubygems.fetch_all_remote_specs(remote)
-      rescue Gem::RemoteFetcher::FetchError, OpenSSL::SSL::SSLError, Net::HTTPFatalError => e
+      rescue Gem::RemoteFetcher::FetchError => e
         case e.message
         when /certificate verify failed/
           raise CertificateFailureError.new(display_uri)
@@ -19,36 +18,9 @@ module Bundler
           raise BadAuthenticationError, remote_uri if remote_uri.userinfo
           raise AuthenticationRequiredError, remote_uri
         else
-          Bundler.ui.trace e
-          raise HTTPError, "Could not fetch specs from #{display_uri}"
+          raise HTTPError, "Could not fetch specs from #{display_uri} due to underlying error <#{e.message}>"
         end
       end
-
-      def fetch_spec(spec)
-        spec -= [nil, "ruby", ""]
-        spec_file_name = "#{spec.join "-"}.gemspec"
-
-        uri = Bundler::URI.parse("#{remote_uri}#{Gem::MARSHAL_SPEC_DIR}#{spec_file_name}.rz")
-        if uri.scheme == "file"
-          path = Bundler.rubygems.correct_for_windows_path(uri.path)
-          Bundler.load_marshal Bundler.rubygems.inflate(Gem.read_binary(path))
-        elsif cached_spec_path = gemspec_cached_path(spec_file_name)
-          Bundler.load_gemspec(cached_spec_path)
-        else
-          Bundler.load_marshal Bundler.rubygems.inflate(downloader.fetch(uri).body)
-        end
-      rescue MarshalError
-        raise HTTPError, "Gemspec #{spec} contained invalid data.\n" \
-          "Your network or your gem server is probably having issues right now."
-      end
-
-    private
-
-      # cached gem specification path, if one exists
-      def gemspec_cached_path(spec_file_name)
-        paths = Bundler.rubygems.spec_cache_dirs.map {|dir| File.join(dir, spec_file_name) }
-        paths.find {|path| File.file? path }
-      end
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/friendly_errors.rb
+++ ruby2.7-2.7.6/lib/bundler/friendly_errors.rb
@@ -4,7 +4,19 @@ require_relative "vendored_thor"
 
 module Bundler
   module FriendlyErrors
-  module_function
+    module_function
+
+    def enable!
+      @disabled = false
+    end
+
+    def disabled?
+      @disabled
+    end
+
+    def disable!
+      @disabled = true
+    end
 
     def log_error(error)
       case error
@@ -17,19 +29,16 @@ module Bundler
         Bundler.ui.error error.message
         Bundler.ui.trace error.orig_exception
       when BundlerError
-        Bundler.ui.error error.message, :wrap => true
-        Bundler.ui.trace error
+        if Bundler.ui.debug?
+          Bundler.ui.trace error
+        else
+          Bundler.ui.error error.message, :wrap => true
+        end
       when Thor::Error
         Bundler.ui.error error.message
       when LoadError
         raise error unless error.message =~ /cannot load such file -- openssl|openssl.so|libcrypto.so/
-        Bundler.ui.error "\nCould not load OpenSSL."
-        Bundler.ui.warn <<-WARN, :wrap => true
-          You must recompile Ruby with OpenSSL support or change the sources in your \
-          Gemfile from 'https' to 'http'. Instructions for compiling with OpenSSL \
-          using RVM are available at https://rvm.io/packages/openssl.
-        WARN
-        Bundler.ui.trace error
+        Bundler.ui.error "\nCould not load OpenSSL. #{error.class}: #{error}\n#{error.backtrace.join("\n  ")}"
       when Interrupt
         Bundler.ui.error "\nQuitting..."
         Bundler.ui.trace error
@@ -43,8 +52,6 @@ module Bundler
           "Alternatively, you can increase the amount of memory the JVM is able to use by running Bundler with jruby -J-Xmx1024m -S bundle (JRuby defaults to 500MB)."
       else request_issue_report_for(error)
       end
-    rescue StandardError
-      raise error
     end
 
     def exit_status(error)
@@ -57,40 +64,11 @@ module Bundler
     end
 
     def request_issue_report_for(e)
-      Bundler.ui.info <<-EOS.gsub(/^ {8}/, "")
+      Bundler.ui.error <<-EOS.gsub(/^ {8}/, ""), nil, nil
         --- ERROR REPORT TEMPLATE -------------------------------------------------------
-        # Error Report
-
-        ## Questions
-
-        Please fill out answers to these questions, it'll help us figure out
-        why things are going wrong.
-
-        - **What did you do?**
-
-          I ran the command `#{$PROGRAM_NAME} #{ARGV.join(" ")}`
-
-        - **What did you expect to happen?**
-
-          I expected Bundler to...
-
-        - **What happened instead?**
-
-          Instead, what happened was...
-
-        - **Have you tried any solutions posted on similar issues in our issue tracker, stack overflow, or google?**
-
-          I tried...
-
-        - **Have you read our issues document, https://github.com/bundler/bundler/blob/master/doc/contributing/ISSUES.md?**
-
-          ...
-
-        ## Backtrace
 
         ```
-        #{e.class}: #{e.message}
-          #{e.backtrace && e.backtrace.join("\n          ").chomp}
+        #{exception_message(e)}
         ```
 
         #{Bundler::Env.report}
@@ -100,13 +78,27 @@ module Bundler
 
       Bundler.ui.error "Unfortunately, an unexpected error occurred, and Bundler cannot continue."
 
-      Bundler.ui.warn <<-EOS.gsub(/^ {8}/, "")
+      Bundler.ui.error <<-EOS.gsub(/^ {8}/, ""), nil, :yellow
 
         First, try this link to see if there are any existing issue reports for this error:
         #{issues_url(e)}
 
-        If there aren't any reports for this error yet, please create copy and paste the report template above into a new issue. Don't forget to anonymize any private data! The new issue form is located at:
-        https://github.com/bundler/bundler/issues/new
+        If there aren't any reports for this error yet, please fill in the new issue form located at #{new_issue_url}, and copy and paste the report template above in there.
+      EOS
+    end
+
+    def exception_message(error)
+      message = serialized_exception_for(error)
+      cause = error.cause
+      return message unless cause
+
+      message + serialized_exception_for(cause)
+    end
+
+    def serialized_exception_for(e)
+      <<-EOS.gsub(/^ {8}/, "")
+        #{e.class}: #{e.message}
+          #{e.backtrace && e.backtrace.join("\n          ").chomp}
       EOS
     end
 
@@ -114,16 +106,23 @@ module Bundler
       message = exception.message.lines.first.tr(":", " ").chomp
       message = message.split("-").first if exception.is_a?(Errno)
       require "cgi"
-      "https://github.com/bundler/bundler/search?q=" \
+      "https://github.com/rubygems/rubygems/search?q=" \
         "#{CGI.escape(message)}&type=Issues"
     end
+
+    def new_issue_url
+      "https://github.com/rubygems/rubygems/issues/new?labels=Bundler&template=bundler-related-issue.md"
+    end
   end
 
   def self.with_friendly_errors
+    FriendlyErrors.enable!
     yield
   rescue SignalException
     raise
   rescue Exception => e # rubocop:disable Lint/RescueException
+    raise if FriendlyErrors.disabled?
+
     FriendlyErrors.log_error(e)
     exit FriendlyErrors.exit_status(e)
   end
--- ruby2.7-2.7.6.orig/lib/bundler/gem_helper.rb
+++ ruby2.7-2.7.6/lib/bundler/gem_helper.rb
@@ -15,6 +15,10 @@ module Bundler
         new(opts[:dir], opts[:name]).install
       end
 
+      def tag_prefix=(prefix)
+        instance.tag_prefix = prefix
+      end
+
       def gemspec(&block)
         gemspec = instance.gemspec
         block.call(gemspec) if block
@@ -24,12 +28,15 @@ module Bundler
 
     attr_reader :spec_path, :base, :gemspec
 
+    attr_writer :tag_prefix
+
     def initialize(base = nil, name = nil)
-      @base = (base ||= SharedHelpers.pwd)
-      gemspecs = name ? [File.join(base, "#{name}.gemspec")] : Dir[File.join(base, "{,*}.gemspec")]
+      @base = File.expand_path(base || SharedHelpers.pwd)
+      gemspecs = name ? [File.join(@base, "#{name}.gemspec")] : Gem::Util.glob_files_in_dir("{,*}.gemspec", @base)
       raise "Unable to determine name from existing gemspec. Use :name => 'gemname' in #install_tasks to manually set it." unless gemspecs.size == 1
       @spec_path = gemspecs.first
       @gemspec = Bundler.load_gemspec(@spec_path)
+      @tag_prefix = ""
     end
 
     def install
@@ -40,6 +47,11 @@ module Bundler
         built_gem_path = build_gem
       end
 
+      desc "Generate SHA512 checksum if #{name}-#{version}.gem into the checksums directory."
+      task "build:checksum" => "build" do
+        build_checksum(built_gem_path)
+      end
+
       desc "Build and install #{name}-#{version}.gem into system gems."
       task "install" => "build" do
         install_gem(built_gem_path)
@@ -64,7 +76,7 @@ module Bundler
         tag_version { git_push(args[:remote]) } unless already_tagged?
       end
 
-      task "release:rubygem_push" do
+      task "release:rubygem_push" => "build" do
         rubygem_push(built_gem_path) if gem_push?
       end
 
@@ -73,7 +85,7 @@ module Bundler
 
     def build_gem
       file_name = nil
-      sh("#{gem_command} build -V #{spec_path.shellescape}".shellsplit) do
+      sh([*gem_command, "build", "-V", spec_path]) do
         file_name = File.basename(built_gem_path)
         SharedHelpers.filesystem_access(File.join(base, "pkg")) {|p| FileUtils.mkdir_p(p) }
         FileUtils.mv(built_gem_path, "pkg")
@@ -84,36 +96,54 @@ module Bundler
 
     def install_gem(built_gem_path = nil, local = false)
       built_gem_path ||= build_gem
-      cmd = "#{gem_command} install #{built_gem_path}"
-      cmd += " --local" if local
-      _, status = sh_with_status(cmd.shellsplit)
-      unless status.success?
-        raise "Couldn't install gem, run `gem install #{built_gem_path}' for more detailed output"
-      end
+      cmd = [*gem_command, "install", built_gem_path.to_s]
+      cmd << "--local" if local
+      sh(cmd)
       Bundler.ui.confirm "#{name} (#{version}) installed."
     end
 
-  protected
+    def build_checksum(built_gem_path = nil)
+      built_gem_path ||= build_gem
+      SharedHelpers.filesystem_access(File.join(base, "checksums")) {|p| FileUtils.mkdir_p(p) }
+      file_name = "#{File.basename(built_gem_path)}.sha512"
+      require "digest/sha2"
+      checksum = ::Digest::SHA512.file(built_gem_path).hexdigest
+      target = File.join(base, "checksums", file_name)
+      File.write(target, checksum + "\n")
+      Bundler.ui.confirm "#{name} #{version} checksum written to checksums/#{file_name}."
+    end
+
+    protected
 
     def rubygem_push(path)
-      cmd = %W[#{gem_command} push #{path}]
+      cmd = [*gem_command, "push", path]
       cmd << "--key" << gem_key if gem_key
       cmd << "--host" << allowed_push_host if allowed_push_host
-      unless allowed_push_host || Bundler.user_home.join(".gem/credentials").file?
-        raise "Your rubygems.org credentials aren't set. Run `gem push` to set them."
-      end
       sh_with_input(cmd)
       Bundler.ui.confirm "Pushed #{name} #{version} to #{gem_push_host}"
     end
 
     def built_gem_path
-      Dir[File.join(base, "#{name}-*.gem")].sort_by {|f| File.mtime(f) }.last
+      Gem::Util.glob_files_in_dir("#{name}-*.gem", base).sort_by {|f| File.mtime(f) }.last
     end
 
-    def git_push(remote = "")
-      perform_git_push remote
-      perform_git_push "#{remote} --tags"
-      Bundler.ui.confirm "Pushed git commits and tags."
+    def git_push(remote = nil)
+      remote ||= default_remote
+      sh("git push #{remote} refs/heads/#{current_branch}".shellsplit)
+      sh("git push #{remote} refs/tags/#{version_tag}".shellsplit)
+      Bundler.ui.confirm "Pushed git commits and release tag."
+    end
+
+    def default_remote
+      remote_for_branch, status = sh_with_status(%W[git config --get branch.#{current_branch}.remote])
+      return "origin" unless status.success?
+
+      remote_for_branch.strip
+    end
+
+    def current_branch
+      # We can replace this with `git branch --show-current` once we drop support for git < 2.22.0
+      sh(%w[git rev-parse --abbrev-ref HEAD]).gsub(%r{\Aheads/}, "").strip
     end
 
     def allowed_push_host
@@ -128,13 +158,6 @@ module Bundler
       allowed_push_host || env_rubygems_host || "rubygems.org"
     end
 
-    def perform_git_push(options = "")
-      cmd = "git push #{options}"
-      out, status = sh_with_status(cmd.shellsplit)
-      return if status.success?
-      raise "Couldn't git push. `#{cmd}' failed with the following output:\n\n#{out}\n"
-    end
-
     def already_tagged?
       return false unless sh(%w[git tag]).split(/\n/).include?(version_tag)
       Bundler.ui.confirm "Tag #{version_tag} has already been created."
@@ -168,7 +191,7 @@ module Bundler
     end
 
     def version_tag
-      "v#{version}"
+      "#{@tag_prefix}v#{version}"
     end
 
     def name
@@ -185,8 +208,7 @@ module Bundler
     def sh(cmd, &block)
       out, status = sh_with_status(cmd, &block)
       unless status.success?
-        cmd = cmd.shelljoin if cmd.respond_to?(:shelljoin)
-        raise(out.empty? ? "Running `#{cmd}` failed. Run this command directly for more detailed output." : out)
+        raise("Running `#{cmd.shelljoin}` failed with the following output:\n\n#{out}\n")
       end
       out
     end
@@ -210,7 +232,7 @@ module Bundler
     end
 
     def gem_command
-      ENV["GEM_COMMAND"] ? ENV["GEM_COMMAND"] : "gem"
+      ENV["GEM_COMMAND"]&.shellsplit || ["gem"]
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/gem_helpers.rb
+++ ruby2.7-2.7.6/lib/bundler/gem_helpers.rb
@@ -5,11 +5,13 @@ module Bundler
     GENERIC_CACHE = { Gem::Platform::RUBY => Gem::Platform::RUBY } # rubocop:disable Style/MutableConstant
     GENERICS = [
       [Gem::Platform.new("java"), Gem::Platform.new("java")],
+      [Gem::Platform.new("universal-java"), Gem::Platform.new("java")],
       [Gem::Platform.new("mswin32"), Gem::Platform.new("mswin32")],
       [Gem::Platform.new("mswin64"), Gem::Platform.new("mswin64")],
       [Gem::Platform.new("universal-mingw32"), Gem::Platform.new("universal-mingw32")],
       [Gem::Platform.new("x64-mingw32"), Gem::Platform.new("x64-mingw32")],
       [Gem::Platform.new("x86_64-mingw32"), Gem::Platform.new("x64-mingw32")],
+      [Gem::Platform.new("x64-mingw-ucrt"), Gem::Platform.new("x64-mingw-ucrt")],
       [Gem::Platform.new("mingw32"), Gem::Platform.new("x86-mingw32")],
     ].freeze
 
@@ -24,47 +26,50 @@ module Bundler
     module_function :generic
 
     def generic_local_platform
-      generic(Bundler.local_platform)
+      generic(local_platform)
     end
     module_function :generic_local_platform
 
+    def local_platform
+      Bundler.local_platform
+    end
+    module_function :local_platform
+
     def platform_specificity_match(spec_platform, user_platform)
       spec_platform = Gem::Platform.new(spec_platform)
-      return PlatformMatch::EXACT_MATCH if spec_platform == user_platform
-      return PlatformMatch::WORST_MATCH if spec_platform.nil? || spec_platform == Gem::Platform::RUBY || user_platform == Gem::Platform::RUBY
 
-      PlatformMatch.new(
-        PlatformMatch.os_match(spec_platform, user_platform),
-        PlatformMatch.cpu_match(spec_platform, user_platform),
-        PlatformMatch.platform_version_match(spec_platform, user_platform)
-      )
+      PlatformMatch.specificity_score(spec_platform, user_platform)
     end
     module_function :platform_specificity_match
 
     def select_best_platform_match(specs, platform)
-      specs.select {|spec| spec.match_platform(platform) }.
-        min_by {|spec| platform_specificity_match(spec.platform, platform) }
+      matching = specs.select {|spec| spec.match_platform(platform) }
+
+      sort_best_platform_match(matching, platform)
     end
     module_function :select_best_platform_match
 
-    PlatformMatch = Struct.new(:os_match, :cpu_match, :platform_version_match)
-    class PlatformMatch
-      def <=>(other)
-        return nil unless other.is_a?(PlatformMatch)
+    def sort_best_platform_match(matching, platform)
+      exact = matching.select {|spec| spec.platform == platform }
+      return exact if exact.any?
 
-        m = os_match <=> other.os_match
-        return m unless m.zero?
+      sorted_matching = matching.sort_by {|spec| platform_specificity_match(spec.platform, platform) }
+      exemplary_spec = sorted_matching.first
 
-        m = cpu_match <=> other.cpu_match
-        return m unless m.zero?
+      sorted_matching.take_while {|spec| same_specificity(platform, spec, exemplary_spec) && same_deps(spec, exemplary_spec) }
+    end
+    module_function :sort_best_platform_match
 
-        m = platform_version_match <=> other.platform_version_match
-        m
+    class PlatformMatch
+      def self.specificity_score(spec_platform, user_platform)
+        return -1 if spec_platform == user_platform
+        return 1_000_000 if spec_platform.nil? || spec_platform == Gem::Platform::RUBY || user_platform == Gem::Platform::RUBY
+
+        os_match(spec_platform, user_platform) +
+          cpu_match(spec_platform, user_platform) * 10 +
+          platform_version_match(spec_platform, user_platform) * 100
       end
 
-      EXACT_MATCH = new(-1, -1, -1).freeze
-      WORST_MATCH = new(1_000_000, 1_000_000, 1_000_000).freeze
-
       def self.os_match(spec_platform, user_platform)
         if spec_platform.os == user_platform.os
           0
@@ -95,5 +100,19 @@ module Bundler
         end
       end
     end
+
+    def same_specificity(platform, spec, exemplary_spec)
+      platform_specificity_match(spec.platform, platform) == platform_specificity_match(exemplary_spec.platform, platform)
+    end
+    module_function :same_specificity
+
+    def same_deps(spec, exemplary_spec)
+      same_runtime_deps = spec.dependencies.sort == exemplary_spec.dependencies.sort
+      return same_runtime_deps unless spec.is_a?(Gem::Specification) && exemplary_spec.is_a?(Gem::Specification)
+
+      same_metadata_deps = spec.required_ruby_version == exemplary_spec.required_ruby_version && spec.required_rubygems_version == exemplary_spec.required_rubygems_version
+      same_runtime_deps && same_metadata_deps
+    end
+    module_function :same_deps
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/gem_remote_fetcher.rb
+++ /dev/null
@@ -1,43 +0,0 @@
-# frozen_string_literal: true
-
-require "rubygems/remote_fetcher"
-
-module Bundler
-  # Adds support for setting custom HTTP headers when fetching gems from the
-  # server.
-  #
-  # TODO: Get rid of this when and if gemstash only supports RubyGems versions
-  # that contain https://github.com/rubygems/rubygems/commit/3db265cc20b2f813.
-  class GemRemoteFetcher < Gem::RemoteFetcher
-    attr_accessor :headers
-
-    # Extracted from RubyGems 2.4.
-    def fetch_http(uri, last_modified = nil, head = false, depth = 0)
-      fetch_type = head ? Net::HTTP::Head : Net::HTTP::Get
-      # beginning of change
-      response   = request uri, fetch_type, last_modified do |req|
-        headers.each {|k, v| req.add_field(k, v) } if headers
-      end
-      # end of change
-
-      case response
-      when Net::HTTPOK, Net::HTTPNotModified then
-        response.uri = uri if response.respond_to? :uri
-        head ? response : response.body
-      when Net::HTTPMovedPermanently, Net::HTTPFound, Net::HTTPSeeOther,
-           Net::HTTPTemporaryRedirect then
-        raise FetchError.new("too many redirects", uri) if depth > 10
-
-        location = URI.parse response["Location"]
-
-        if https?(uri) && !https?(location)
-          raise FetchError.new("redirecting to non-https resource: #{location}", uri)
-        end
-
-        fetch_http(location, last_modified, head, depth + 1)
-      else
-        raise FetchError.new("bad response #{response.message} #{response.code}", uri)
-      end
-    end
-  end
-end
--- ruby2.7-2.7.6.orig/lib/bundler/gem_version_promoter.rb
+++ ruby2.7-2.7.6/lib/bundler/gem_version_promoter.rb
@@ -7,7 +7,7 @@ module Bundler
   # available dependency versions as found in its index, before returning it to
   # to the resolution engine to select the best version.
   class GemVersionPromoter
-    DEBUG = ENV["DEBUG_RESOLVER"]
+    DEBUG = ENV["BUNDLER_DEBUG_RESOLVER"] || ENV["DEBUG_RESOLVER"]
 
     attr_reader :level, :locked_specs, :unlock_gems
 
@@ -55,19 +55,17 @@ module Bundler
       @level = v
     end
 
-    # Given a Dependency and an Array of SpecGroups of available versions for a
-    # gem, this method will return the Array of SpecGroups sorted (and possibly
+    # Given a Dependency and an Array of Specifications of available versions for a
+    # gem, this method will return the Array of Specifications sorted (and possibly
     # truncated if strict is true) in an order to give preference to the current
     # level (:major, :minor or :patch) when resolution is deciding what versions
     # best resolve all dependencies in the bundle.
     # @param dep [Dependency] The Dependency of the gem.
-    # @param spec_groups [SpecGroup] An array of SpecGroups for the same gem
+    # @param spec_groups [Specification] An array of Specifications for the same gem
     #    named in the @dep param.
-    # @return [SpecGroup] A new instance of the SpecGroup Array sorted and
+    # @return [Specification] A new instance of the Specification Array sorted and
     #    possibly filtered.
     def sort_versions(dep, spec_groups)
-      before_result = "before sort_versions: #{debug_format_result(dep, spec_groups).inspect}" if DEBUG
-
       @sort_versions[dep] ||= begin
         gem_name = dep.name
 
@@ -79,15 +77,14 @@ module Bundler
           filter_dep_specs(spec_groups, locked_spec)
         else
           sort_dep_specs(spec_groups, locked_spec)
-        end.tap do |specs|
-          if DEBUG
-            warn before_result
-            warn " after sort_versions: #{debug_format_result(dep, specs).inspect}"
-          end
         end
       end
     end
 
+    def reset
+      @sort_versions = {}
+    end
+
     # @return [bool] Convenience method for testing value of level variable.
     def major?
       level == :major
@@ -98,7 +95,7 @@ module Bundler
       level == :minor
     end
 
-  private
+    private
 
     def filter_dep_specs(spec_groups, locked_spec)
       res = spec_groups.select do |spec_group|
@@ -179,12 +176,5 @@ module Bundler
       move, keep = result.partition {|s| s.version.to_s == version.to_s }
       keep.concat(move)
     end
-
-    def debug_format_result(dep, spec_groups)
-      a = [dep.to_s,
-           spec_groups.map {|sg| [sg.version, sg.dependencies_for_activated_platforms.map {|dp| [dp.name, dp.requirement.to_s] }] }]
-      last_map = a.last.map {|sg_data| [sg_data.first.version, sg_data.last.map {|aa| aa.join(" ") }] }
-      [a.first, last_map, level, strict ? :strict : :not_strict]
-    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/gemdeps.rb
+++ /dev/null
@@ -1,29 +0,0 @@
-# frozen_string_literal: true
-
-module Bundler
-  class Gemdeps
-    def initialize(runtime)
-      @runtime = runtime
-    end
-
-    def requested_specs
-      @runtime.requested_specs
-    end
-
-    def specs
-      @runtime.specs
-    end
-
-    def dependencies
-      @runtime.dependencies
-    end
-
-    def current_dependencies
-      @runtime.current_dependencies
-    end
-
-    def requires
-      @runtime.requires
-    end
-  end
-end
--- ruby2.7-2.7.6.orig/lib/bundler/graph.rb
+++ ruby2.7-2.7.6/lib/bundler/graph.rb
@@ -27,7 +27,7 @@ module Bundler
       GraphVizClient.new(self).run
     end
 
-  private
+    private
 
     def _populate_relations
       parent_dependencies = _groups.values.to_set.flatten
--- ruby2.7-2.7.6.orig/lib/bundler/index.rb
+++ ruby2.7-2.7.6/lib/bundler/index.rb
@@ -1,7 +1,5 @@
 # frozen_string_literal: true
 
-require "set"
-
 module Bundler
   class Index
     include Enumerable
@@ -58,18 +56,21 @@ module Bundler
 
     # Search this index's specs, and any source indexes that this index knows
     # about, returning all of the results.
-    def search(query, base = nil)
-      sort_specs(unsorted_search(query, base))
+    def search(query)
+      sort_specs(unsorted_search(query))
     end
 
-    def unsorted_search(query, base)
-      results = local_search(query, base)
+    def unsorted_search(query)
+      results = local_search(query)
 
-      seen = results.map(&:full_name).to_set unless @sources.empty?
+      seen = results.map(&:full_name).uniq unless @sources.empty?
 
       @sources.each do |source|
-        source.unsorted_search(query, base).each do |spec|
-          results << spec if seen.add?(spec.full_name)
+        source.unsorted_search(query).each do |spec|
+          next if seen.include?(spec.full_name)
+
+          seen << spec.full_name
+          results << spec
         end
       end
 
@@ -88,12 +89,12 @@ module Bundler
       self.class.sort_specs(specs)
     end
 
-    def local_search(query, base = nil)
+    def local_search(query)
       case query
       when Gem::Specification, RemoteSpecification, LazySpecification, EndpointSpecification then search_by_spec(query)
       when String then specs_by_name(query)
-      when Gem::Dependency then search_by_dependency(query, base)
-      when DepProxy then search_by_dependency(query.dep, base)
+      when Gem::Dependency then search_by_dependency(query)
+      when DepProxy then search_by_dependency(query.dep)
       else
         raise "You can't search for a #{query.inspect}."
       end
@@ -121,10 +122,9 @@ module Bundler
       names
     end
 
-    # returns a list of the dependencies
     def unmet_dependency_names
       dependency_names.select do |name|
-        name != "bundler" && search(name).empty?
+        search(name).empty?
       end
     end
 
@@ -170,7 +170,7 @@ module Bundler
     def dependencies_eql?(spec, other_spec)
       deps       = spec.dependencies.select {|d| d.type != :development }
       other_deps = other_spec.dependencies.select {|d| d.type != :development }
-      Set.new(deps) == Set.new(other_deps)
+      deps.sort == other_deps.sort
     end
 
     def add_source(index)
@@ -179,24 +179,18 @@ module Bundler
       @sources.uniq! # need to use uniq! here instead of checking for the item before adding
     end
 
-  private
+    private
 
     def specs_by_name(name)
       @specs[name].values
     end
 
-    def search_by_dependency(dependency, base = nil)
-      @cache[base || false] ||= {}
-      @cache[base || false][dependency] ||= begin
+    def search_by_dependency(dependency)
+      @cache[dependency] ||= begin
         specs = specs_by_name(dependency.name)
-        specs += base if base
         found = specs.select do |spec|
           next true if spec.source.is_a?(Source::Gemspec)
-          if base # allow all platforms when searching from a lockfile
-            dependency.matches_spec?(spec)
-          else
-            dependency.matches_spec?(spec) && Gem::Platform.match(spec.platform)
-          end
+          dependency.matches_spec?(spec)
         end
 
         found
--- ruby2.7-2.7.6.orig/lib/bundler/injector.rb
+++ ruby2.7-2.7.6/lib/bundler/injector.rb
@@ -72,9 +72,13 @@ module Bundler
 
         deps.each {|dep| Bundler.ui.confirm "#{SharedHelpers.pretty_dependency(dep, false)} was removed." }
       end
+
+      # Invalidate the cached Bundler.definition.
+      # This prevents e.g. `bundle remove ...` from using outdated information.
+      Bundler.reset_paths!
     end
 
-  private
+    private
 
     def conservative_version(spec)
       version = spec.version
@@ -111,10 +115,14 @@ module Bundler
         end
 
         source = ", :source => \"#{d.source}\"" unless d.source.nil?
+        path = ", :path => \"#{d.path}\"" unless d.path.nil?
         git = ", :git => \"#{d.git}\"" unless d.git.nil?
+        github = ", :github => \"#{d.github}\"" unless d.github.nil?
         branch = ", :branch => \"#{d.branch}\"" unless d.branch.nil?
+        ref = ", :ref => \"#{d.ref}\"" unless d.ref.nil?
+        require_path = ", :require => #{convert_autorequire(d.autorequire)}" unless d.autorequire.nil?
 
-        %(gem #{name}#{requirement}#{group}#{source}#{git}#{branch})
+        %(gem #{name}#{requirement}#{group}#{source}#{path}#{git}#{github}#{branch}#{ref}#{require_path})
       end.join("\n")
     end
 
@@ -128,7 +136,7 @@ module Bundler
     # evaluates a gemfile to remove the specified gem
     # from it.
     def remove_deps(gemfile_path)
-      initial_gemfile = IO.readlines(gemfile_path)
+      initial_gemfile = File.readlines(gemfile_path)
 
       Bundler.ui.info "Removing gems from #{gemfile_path}"
 
@@ -179,11 +187,22 @@ module Bundler
     # @param [Pathname] gemfile_path The Gemfile from which to remove dependencies.
     def remove_gems_from_gemfile(gems, gemfile_path)
       patterns = /gem\s+(['"])#{Regexp.union(gems)}\1|gem\s*\((['"])#{Regexp.union(gems)}\2\)/
+      new_gemfile = []
+      multiline_removal = false
+      File.readlines(gemfile_path).each do |line|
+        match_data = line.match(patterns)
+        if match_data && is_not_within_comment?(line, match_data)
+          multiline_removal = line.rstrip.end_with?(",")
+          # skip lines which match the regex
+          next
+        end
 
-      # remove lines which match the regex
-      new_gemfile = IO.readlines(gemfile_path).reject {|line| line.match(patterns) }
+        # skip followup lines until line does not end with ','
+        new_gemfile << line unless multiline_removal
+        multiline_removal = line.rstrip.end_with?(",") if multiline_removal
+      end
 
-      # remove lone \n and append them with other strings
+      # remove line \n and append them with other strings
       new_gemfile.each_with_index do |_line, index|
         if new_gemfile[index + 1] == "\n"
           new_gemfile[index] += new_gemfile[index + 1]
@@ -196,6 +215,13 @@ module Bundler
       new_gemfile.join.chomp
     end
 
+    # @param [String] line          Individual line of gemfile content.
+    # @param [MatchData] match_data Data about Regex match.
+    def is_not_within_comment?(line, match_data)
+      match_start_index = match_data.offset(0).first
+      !line[0..match_start_index].include?("#")
+    end
+
     # @param [Array] gemfile       Array of gemfile contents.
     # @param [String] block_name   Name of block name to look for.
     def remove_nested_blocks(gemfile, block_name)
@@ -251,5 +277,11 @@ module Bundler
     def show_warning(message)
       Bundler.ui.info Bundler.ui.add_color(message, :yellow)
     end
+
+    def convert_autorequire(autorequire)
+      autorequire = autorequire.first
+      return autorequire if autorequire == "false"
+      autorequire.inspect
+    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/inline.rb
+++ ruby2.7-2.7.6/lib/bundler/inline.rb
@@ -38,27 +38,23 @@ def gemfile(install = false, options = {
   raise ArgumentError, "Unknown options: #{opts.keys.join(", ")}" unless opts.empty?
 
   begin
-    old_root = Bundler.method(:root)
-    bundler_module = class << Bundler; self; end
-    bundler_module.send(:remove_method, :root)
-    def Bundler.root
-      Bundler::SharedHelpers.pwd.expand_path
-    end
+    Bundler.instance_variable_set(:@bundle_path, Pathname.new(Gem.dir))
     old_gemfile = ENV["BUNDLE_GEMFILE"]
     Bundler::SharedHelpers.set_env "BUNDLE_GEMFILE", "Gemfile"
 
     Bundler::Plugin.gemfile_install(&gemfile) if Bundler.feature_flag.plugins?
     builder = Bundler::Dsl.new
     builder.instance_eval(&gemfile)
+    builder.check_primary_source_safety
 
-    Bundler.settings.temporary(:frozen => false) do
+    Bundler.settings.temporary(:deployment => false, :frozen => false) do
       definition = builder.to_definition(nil, true)
       def definition.lock(*); end
       definition.validate_runtime!
 
       Bundler.ui = install ? ui : Bundler::UI::Silent.new
       if install || definition.missing_specs?
-        Bundler.settings.temporary(:inline => true, :disable_platform_warnings => true) do
+        Bundler.settings.temporary(:inline => true, :no_install => false) do
           installer = Bundler::Installer.install(Bundler.root, definition, :system => true)
           installer.post_install_messages.each do |name, message|
             Bundler.ui.info "Post-install message from #{name}:\n#{message}"
@@ -70,11 +66,6 @@ def gemfile(install = false, options = {
       runtime.setup.require
     end
   ensure
-    if bundler_module
-      bundler_module.send(:remove_method, :root)
-      bundler_module.send(:define_method, :root, old_root)
-    end
-
     if old_gemfile
       ENV["BUNDLE_GEMFILE"] = old_gemfile
     else
--- ruby2.7-2.7.6.orig/lib/bundler/installer.rb
+++ ruby2.7-2.7.6/lib/bundler/installer.rb
@@ -1,7 +1,5 @@
 # frozen_string_literal: true
 
-require "erb"
-require "rubygems/dependency_installer"
 require_relative "worker"
 require_relative "installer/parallel_installer"
 require_relative "installer/standalone"
@@ -15,7 +13,7 @@ module Bundler
       Installer.ambiguous_gems = []
     end
 
-    attr_reader :post_install_messages
+    attr_reader :post_install_messages, :definition
 
     # Begins the installation process for Bundler.
     # For more information see the #run method on this class.
@@ -68,7 +66,7 @@ module Bundler
     # require paths and save them in a `setup.rb` file. See `bundle standalone --help` for more
     # information.
     def run(options)
-      create_bundle_path
+      Bundler.create_bundle_path
 
       ProcessLock.lock do
         if Bundler.frozen_bundle?
@@ -83,7 +81,6 @@ module Bundler
 
         if resolve_if_needed(options)
           ensure_specs_are_compatible!
-          warn_on_incompatible_bundler_deps
           load_plugins
           options.delete(:jobs)
         else
@@ -91,6 +88,8 @@ module Bundler
         end
         install(options)
 
+        Gem::Specification.reset # invalidate gem specification cache so that installed gems are immediately available
+
         lock unless Bundler.frozen_bundle?
         Standalone.new(options[:standalone], @definition).generate if options[:standalone]
       end
@@ -120,7 +119,7 @@ module Bundler
       relative_gemfile_path = relative_gemfile_path
       ruby_command = Thor::Util.ruby_command
       ruby_command = ruby_command
-      template_path = File.expand_path("../templates/Executable", __FILE__)
+      template_path = File.expand_path("templates/Executable", __dir__)
       if spec.name == "bundler"
         template_path += ".bundler"
         spec.executables = %(bundle)
@@ -135,12 +134,18 @@ module Bundler
           next
         end
 
-        File.open(binstub_path, "w", 0o777 & ~File.umask) do |f|
-          if RUBY_VERSION >= "2.6"
-            f.puts ERB.new(template, :trim_mode => "-").result(binding)
-          else
-            f.puts ERB.new(template, nil, "-").result(binding)
-          end
+        mode = Gem.win_platform? ? "wb:UTF-8" : "w"
+        require "erb"
+        content = if RUBY_VERSION >= "2.6"
+          ERB.new(template, :trim_mode => "-").result(binding)
+        else
+          ERB.new(template, nil, "-").result(binding)
+        end
+
+        File.write(binstub_path, content, :mode => mode, :perm => 0o777 & ~File.umask)
+        if Gem.win_platform? || options[:all_platforms]
+          prefix = "@ruby -x \"%~f0\" %*\n@exit /b %ERRORLEVEL%\n\n"
+          File.write("#{binstub_path}.cmd", prefix + content, :mode => mode)
         end
       end
 
@@ -159,7 +164,7 @@ module Bundler
       end
     end
 
-    def generate_standalone_bundler_executable_stubs(spec)
+    def generate_standalone_bundler_executable_stubs(spec, options = {})
       # double-assignment to avoid warnings about variables that will be used by ERB
       bin_path = Bundler.bin_path
       unless path = Bundler.settings[:path]
@@ -167,7 +172,7 @@ module Bundler
       end
       standalone_path = Bundler.root.join(path).relative_path_from(bin_path)
       standalone_path = standalone_path
-      template = File.read(File.expand_path("../templates/Executable.standalone", __FILE__))
+      template = File.read(File.expand_path("templates/Executable.standalone", __dir__))
       ruby_command = Thor::Util.ruby_command
       ruby_command = ruby_command
 
@@ -175,17 +180,24 @@ module Bundler
         next if executable == "bundle"
         executable_path = Pathname(spec.full_gem_path).join(spec.bindir, executable).relative_path_from(bin_path)
         executable_path = executable_path
-        File.open "#{bin_path}/#{executable}", "w", 0o755 do |f|
-          if RUBY_VERSION >= "2.6"
-            f.puts ERB.new(template, :trim_mode => "-").result(binding)
-          else
-            f.puts ERB.new(template, nil, "-").result(binding)
-          end
+
+        mode = Gem.win_platform? ? "wb:UTF-8" : "w"
+        require "erb"
+        content = if RUBY_VERSION >= "2.6"
+          ERB.new(template, :trim_mode => "-").result(binding)
+        else
+          ERB.new(template, nil, "-").result(binding)
+        end
+
+        File.write("#{bin_path}/#{executable}", content, :mode => mode, :perm => 0o755)
+        if Gem.win_platform? || options[:all_platforms]
+          prefix = "@ruby -x \"%~f0\" %*\n@exit /b %ERRORLEVEL%\n\n"
+          File.write("#{bin_path}/#{executable}.cmd", prefix + content, :mode => mode)
         end
       end
     end
 
-  private
+    private
 
     # the order that the resolver provides is significant, since
     # dependencies might affect the installation of a gem.
@@ -202,27 +214,11 @@ module Bundler
         return jobs
       end
 
-      return 1 unless can_install_in_parallel?
-
-      auto_config_jobs = Bundler.feature_flag.auto_config_jobs?
       if jobs = Bundler.settings[:jobs]
-        if auto_config_jobs
-          jobs
-        else
-          [jobs.pred, 1].max
-        end
-      elsif auto_config_jobs
-        processor_count
-      else
-        1
+        return jobs
       end
-    end
 
-    def processor_count
-      require "etc"
-      Etc.nprocessors
-    rescue StandardError
-      1
+      Bundler.settings.processor_count
     end
 
     def load_plugins
@@ -238,46 +234,22 @@ module Bundler
         end
       end.flatten
       Bundler.rubygems.load_plugin_files(path_plugin_files)
+      Bundler.rubygems.load_env_plugins
     end
 
     def ensure_specs_are_compatible!
-      system_ruby = Bundler::RubyVersion.system
-      rubygems_version = Gem::Version.create(Gem::VERSION)
       @definition.specs.each do |spec|
-        if required_ruby_version = spec.required_ruby_version
-          unless required_ruby_version.satisfied_by?(system_ruby.gem_version)
-            raise InstallError, "#{spec.full_name} requires ruby version #{required_ruby_version}, " \
-              "which is incompatible with the current version, #{system_ruby}"
-          end
-        end
-        next unless required_rubygems_version = spec.required_rubygems_version
-        unless required_rubygems_version.satisfied_by?(rubygems_version)
-          raise InstallError, "#{spec.full_name} requires rubygems version #{required_rubygems_version}, " \
-            "which is incompatible with the current version, #{rubygems_version}"
+        unless spec.matches_current_ruby?
+          raise InstallError, "#{spec.full_name} requires ruby version #{spec.required_ruby_version}, " \
+            "which is incompatible with the current version, #{Gem.ruby_version}"
+        end
+        unless spec.matches_current_rubygems?
+          raise InstallError, "#{spec.full_name} requires rubygems version #{spec.required_rubygems_version}, " \
+            "which is incompatible with the current version, #{Gem.rubygems_version}"
         end
       end
     end
 
-    def warn_on_incompatible_bundler_deps
-      bundler_version = Gem::Version.create(Bundler::VERSION)
-      @definition.specs.each do |spec|
-        spec.dependencies.each do |dep|
-          next if dep.type == :development
-          next unless dep.name == "bundler".freeze
-          next if dep.requirement.satisfied_by?(bundler_version)
-
-          Bundler.ui.warn "#{spec.name} (#{spec.version}) has dependency" \
-            " #{SharedHelpers.pretty_dependency(dep)}" \
-            ", which is unsatisfied by the current bundler version #{VERSION}" \
-            ", so the dependency is being ignored"
-        end
-      end
-    end
-
-    def can_install_in_parallel?
-      true
-    end
-
     def install_in_parallel(size, standalone, force = false)
       spec_installations = ParallelInstaller.call(self, @definition.specs, size, standalone, force)
       spec_installations.each do |installation|
@@ -285,22 +257,20 @@ module Bundler
       end
     end
 
-    def create_bundle_path
-      SharedHelpers.filesystem_access(Bundler.bundle_path.to_s) do |p|
-        Bundler.mkdir_p(p)
-      end unless Bundler.bundle_path.exist?
-    rescue Errno::EEXIST
-      raise PathError, "Could not install to path `#{Bundler.bundle_path}` " \
-        "because a file already exists at that path. Either remove or rename the file so the directory can be created."
-    end
-
     # returns whether or not a re-resolve was needed
     def resolve_if_needed(options)
-      if !@definition.unlocking? && !options["force"] && !options["all-platforms"] && !Bundler.settings[:inline] && Bundler.default_lockfile.file?
+      if !@definition.unlocking? && !options["force"] && !Bundler.settings[:inline] && Bundler.default_lockfile.file?
         return false if @definition.nothing_changed? && !@definition.missing_specs?
       end
 
-      options["local"] ? @definition.resolve_with_cache! : @definition.resolve_remotely!
+      if options["local"]
+        @definition.resolve_with_cache!
+      elsif options["prefer-local"]
+        @definition.resolve_prefering_local!
+      else
+        @definition.resolve_remotely!
+      end
+
       true
     end
 
--- ruby2.7-2.7.6.orig/lib/bundler/installer/gem_installer.rb
+++ ruby2.7-2.7.6/lib/bundler/installer/gem_installer.rb
@@ -1,7 +1,5 @@
 # frozen_string_literal: true
 
-require "shellwords"
-
 module Bundler
   class GemInstaller
     attr_reader :spec, :standalone, :worker, :force, :installer
@@ -15,61 +13,58 @@ module Bundler
     end
 
     def install_from_spec
-      post_install_message = spec_settings ? install_with_settings : install
+      post_install_message = install
       Bundler.ui.debug "#{worker}:  #{spec.name} (#{spec.version}) from #{spec.loaded_from}"
       generate_executable_stubs
       return true, post_install_message
-    rescue Bundler::InstallHookError, Bundler::SecurityError, APIResponseMismatchError
+    rescue Bundler::InstallHookError, Bundler::SecurityError, Bundler::APIResponseMismatchError
       raise
     rescue Errno::ENOSPC
       return false, out_of_space_message
-    rescue StandardError => e
+    rescue Bundler::BundlerError, Gem::InstallError, Bundler::APIResponseInvalidDependenciesError => e
       return false, specific_failure_message(e)
     end
 
-  private
+    private
 
     def specific_failure_message(e)
       message = "#{e.class}: #{e.message}\n"
-      message += "  " + e.backtrace.join("\n  ") + "\n\n" if Bundler.ui.debug?
+      message += "  " + e.backtrace.join("\n  ") + "\n\n"
       message = message.lines.first + Bundler.ui.add_color(message.lines.drop(1).join, :clear)
       message + Bundler.ui.add_color(failure_message, :red)
     end
 
     def failure_message
-      return install_error_message if spec.source.options["git"]
-      "#{install_error_message}\n#{gem_install_message}"
+      install_error_message
     end
 
     def install_error_message
       "An error occurred while installing #{spec.name} (#{spec.version}), and Bundler cannot continue."
     end
 
-    def gem_install_message
-      source = spec.source
-      return unless source.respond_to?(:remotes)
-
-      if source.remotes.size == 1
-        "Make sure that `gem install #{spec.name} -v '#{spec.version}' --source '#{source.remotes.first}'` succeeds before bundling."
-      else
-        "Make sure that `gem install #{spec.name} -v '#{spec.version}'` succeeds before bundling."
-      end
-    end
-
     def spec_settings
       # Fetch the build settings, if there are any
       if settings = Bundler.settings["build.#{spec.name}"]
+        require "shellwords"
         Shellwords.shellsplit(settings)
       end
     end
 
     def install
-      spec.source.install(spec, :force => force, :ensure_builtin_gems_cached => standalone, :build_args => Array(spec_settings))
+      spec.source.install(
+        spec,
+        :force => force,
+        :ensure_builtin_gems_cached => standalone,
+        :build_args => Array(spec_settings),
+        :previous_spec => previous_spec,
+      )
     end
 
-    def install_with_settings
-      # Build arguments are global, so this is mutexed
-      Bundler.rubygems.install_with_build_args([spec_settings]) { install }
+    def previous_spec
+      locked_gems = installer.definition.locked_gems
+      return unless locked_gems
+
+      locked_gems.specs.find {|s| s.name == spec.name }
     end
 
     def out_of_space_message
--- ruby2.7-2.7.6.orig/lib/bundler/installer/parallel_installer.rb
+++ ruby2.7-2.7.6/lib/bundler/installer/parallel_installer.rb
@@ -6,10 +6,11 @@ require_relative "gem_installer"
 module Bundler
   class ParallelInstaller
     class SpecInstallation
-      attr_accessor :spec, :name, :post_install_message, :state, :error
+      attr_accessor :spec, :name, :full_name, :post_install_message, :state, :error
       def initialize(spec)
         @spec = spec
         @name = spec.name
+        @full_name = spec.full_name
         @state = :none
         @post_install_message = ""
         @error = nil
@@ -27,13 +28,8 @@ module Bundler
         state == :failed
       end
 
-      def installation_attempted?
-        installed? || failed?
-      end
-
-      # Only true when spec in neither installed nor already enqueued
       def ready_to_enqueue?
-        !enqueued? && !installation_attempted?
+        state == :none
       end
 
       def has_post_install_message?
@@ -54,14 +50,11 @@ module Bundler
       # Represents only the non-development dependencies, the ones that are
       # itself and are in the total list.
       def dependencies
-        @dependencies ||= begin
-          all_dependencies.reject {|dep| ignorable_dependency? dep }
-        end
+        @dependencies ||= all_dependencies.reject {|dep| ignorable_dependency? dep }
       end
 
       def missing_lockfile_dependencies(all_spec_names)
-        deps = all_dependencies.reject {|dep| ignorable_dependency? dep }
-        deps.reject {|dep| all_spec_names.include? dep.name }
+        dependencies.reject {|dep| all_spec_names.include? dep.name }
       end
 
       # Represents all dependencies
@@ -70,7 +63,7 @@ module Bundler
       end
 
       def to_s
-        "#<#{self.class} #{@spec.full_name} (#{state})>"
+        "#<#{self.class} #{full_name} (#{state})>"
       end
     end
 
@@ -93,18 +86,48 @@ module Bundler
     def call
       check_for_corrupt_lockfile
 
+      if @rake
+        do_install(@rake, 0)
+        Gem::Specification.reset
+      end
+
       if @size > 1
         install_with_worker
       else
         install_serially
       end
 
-      handle_error if @specs.any?(&:failed?)
+      check_for_unmet_dependencies
+
+      handle_error if failed_specs.any?
       @specs
     ensure
       worker_pool && worker_pool.stop
     end
 
+    def check_for_unmet_dependencies
+      unmet_dependencies = @specs.map do |s|
+        [
+          s,
+          s.dependencies.reject {|dep| @specs.any? {|spec| dep.matches_spec?(spec.spec) } },
+        ]
+      end.reject {|a| a.last.empty? }
+      return if unmet_dependencies.empty?
+
+      warning = []
+      warning << "Your lockfile doesn't include a valid resolution."
+      warning << "You can fix this by regenerating your lockfile or trying to manually editing the bad locked gems to a version that satisfies all dependencies."
+      warning << "The unmet dependencies are:"
+
+      unmet_dependencies.each do |spec, unmet_spec_dependencies|
+        unmet_spec_dependencies.each do |unmet_spec_dependency|
+          warning << "* #{unmet_spec_dependency}, depended upon #{spec.full_name}, unsatisfied by #{@specs.find {|s| s.name == unmet_spec_dependency.name && !unmet_spec_dependency.matches_spec?(s.spec) }.full_name}"
+        end
+      end
+
+      Bundler.ui.warn(warning.join("\n"))
+    end
+
     def check_for_corrupt_lockfile
       missing_dependencies = @specs.map do |s|
         [
@@ -130,7 +153,11 @@ module Bundler
       Bundler.ui.warn(warning.join("\n"))
     end
 
-  private
+    private
+
+    def failed_specs
+      @specs.select(&:failed?)
+    end
 
     def install_with_worker
       enqueue_specs
@@ -156,17 +183,13 @@ module Bundler
       gem_installer = Bundler::GemInstaller.new(
         spec_install.spec, @installer, @standalone, worker_num, @force
       )
-      success, message = begin
-        gem_installer.install_from_spec
-      rescue RuntimeError => e
-        raise e, "#{e}\n\n#{require_tree_for_spec(spec_install.spec)}"
-      end
+      success, message = gem_installer.install_from_spec
       if success
         spec_install.state = :installed
         spec_install.post_install_message = message unless message.nil?
       else
-        spec_install.state = :failed
         spec_install.error = "#{message}\n\n#{require_tree_for_spec(spec_install.spec)}"
+        spec_install.state = :failed
       end
       Plugin.hook(Plugin::Events::GEM_AFTER_INSTALL, spec_install)
       spec_install
@@ -190,11 +213,11 @@ module Bundler
     end
 
     def handle_error
-      errors = @specs.select(&:failed?).map(&:error)
+      errors = failed_specs.map(&:error)
       if exception = errors.find {|e| e.is_a?(Bundler::BundlerError) }
         raise exception
       end
-      raise Bundler::InstallError, errors.map(&:to_s).join("\n\n")
+      raise Bundler::InstallError, errors.join("\n\n")
     end
 
     def require_tree_for_spec(spec)
@@ -217,8 +240,6 @@ module Bundler
     # are installed.
     def enqueue_specs
       @specs.select(&:ready_to_enqueue?).each do |spec|
-        next if @rake && !@rake.installed? && spec.name != @rake.name
-
         if spec.dependencies_installed? @specs
           spec.state = :enqueued
           worker_pool.enq spec
--- ruby2.7-2.7.6.orig/lib/bundler/installer/standalone.rb
+++ ruby2.7-2.7.6/lib/bundler/installer/standalone.rb
@@ -3,7 +3,7 @@
 module Bundler
   class Standalone
     def initialize(groups, definition)
-      @specs = groups.empty? ? definition.requested_specs : definition.specs_for(groups.map(&:to_sym))
+      @specs = definition.specs_for(groups)
     end
 
     def generate
@@ -12,41 +12,88 @@ module Bundler
       end
       File.open File.join(bundler_path, "setup.rb"), "w" do |file|
         file.puts "require 'rbconfig'"
-        file.puts "ruby_engine = RUBY_ENGINE"
-        file.puts "ruby_version = RbConfig::CONFIG[\"ruby_version\"]"
-        file.puts "path = File.expand_path('..', __FILE__)"
+        file.puts define_path_helpers
+        file.puts reverse_rubygems_kernel_mixin
         paths.each do |path|
-          file.puts %($:.unshift "\#{path}/#{path}")
+          if Pathname.new(path).absolute?
+            file.puts %($:.unshift "#{path}")
+          else
+            file.puts %($:.unshift File.expand_path("\#{__dir__}/#{path}"))
+          end
         end
       end
     end
 
-  private
+    private
 
     def paths
       @specs.map do |spec|
         next if spec.name == "bundler"
         Array(spec.require_paths).map do |path|
-          gem_path(path, spec).sub(version_dir, '#{ruby_engine}/#{ruby_version}')
+          gem_path(path, spec).
+            sub(version_dir, '#{RUBY_ENGINE}/#{Gem.ruby_api_version}').
+            sub(extensions_dir, 'extensions/\k<platform>/#{Gem.extension_api_version}')
           # This is a static string intentionally. It's interpolated at a later time.
         end
-      end.flatten
+      end.flatten.compact
     end
 
     def version_dir
-      "#{Bundler::RubyVersion.system.engine}/#{RbConfig::CONFIG["ruby_version"]}"
+      "#{RUBY_ENGINE}/#{Gem.ruby_api_version}"
+    end
+
+    def extensions_dir
+      %r{extensions/(?<platform>[^/]+)/#{Regexp.escape(Gem.extension_api_version)}}
     end
 
     def bundler_path
-      Bundler.root.join(Bundler.settings[:path], "bundler")
+      Bundler.root.join(Bundler.settings[:path].to_s, "bundler")
     end
 
     def gem_path(path, spec)
       full_path = Pathname.new(path).absolute? ? path : File.join(spec.full_gem_path, path)
-      Pathname.new(full_path).relative_path_from(Bundler.root.join(bundler_path)).to_s
+      if spec.source.instance_of?(Source::Path)
+        full_path
+      else
+        Pathname.new(full_path).relative_path_from(Bundler.root.join(bundler_path)).to_s
+      end
     rescue TypeError
       error_message = "#{spec.name} #{spec.version} has an invalid gemspec"
       raise Gem::InvalidSpecificationException.new(error_message)
     end
+
+    def define_path_helpers
+      <<~'END'
+        unless defined?(Gem)
+          module Gem
+            def self.ruby_api_version
+              RbConfig::CONFIG["ruby_version"]
+            end
+
+            def self.extension_api_version
+              if 'no' == RbConfig::CONFIG['ENABLE_SHARED']
+                "#{ruby_api_version}-static"
+              else
+                ruby_api_version
+              end
+            end
+          end
+        end
+      END
+    end
+
+    def reverse_rubygems_kernel_mixin
+      <<~END
+      kernel = (class << ::Kernel; self; end)
+      [kernel, ::Kernel].each do |k|
+        if k.private_method_defined?(:gem_original_require)
+          private_require = k.private_method_defined?(:require)
+          k.send(:remove_method, :require)
+          k.send(:define_method, :require, k.instance_method(:gem_original_require))
+          k.send(:private, :require) if private_require
+        end
+      end
+      END
+    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/lazy_specification.rb
+++ ruby2.7-2.7.6/lib/bundler/lazy_specification.rb
@@ -1,29 +1,11 @@
 # frozen_string_literal: true
 
-require_relative "match_platform"
-
 module Bundler
   class LazySpecification
-    Identifier = Struct.new(:name, :version, :source, :platform, :dependencies)
-    class Identifier
-      include Comparable
-      def <=>(other)
-        return unless other.is_a?(Identifier)
-        [name, version, platform_string] <=> [other.name, other.version, other.platform_string]
-      end
-
-    protected
-
-      def platform_string
-        platform_string = platform.to_s
-        platform_string == Index::RUBY ? Index::NULL : platform_string
-      end
-    end
-
     include MatchPlatform
 
     attr_reader :name, :version, :dependencies, :platform
-    attr_accessor :source, :remote
+    attr_accessor :source, :remote, :force_ruby_platform
 
     def initialize(name, version, platform, source = nil)
       @name          = name
@@ -35,7 +17,7 @@ module Bundler
     end
 
     def full_name
-      if platform == Gem::Platform::RUBY || platform.nil?
+      if platform == Gem::Platform::RUBY
         "#{@name}-#{@version}"
       else
         "#{@name}-#{@version}-#{platform}"
@@ -46,14 +28,38 @@ module Bundler
       identifier == other.identifier
     end
 
+    def eql?(other)
+      identifier.eql?(other.identifier)
+    end
+
+    def hash
+      identifier.hash
+    end
+
+    ##
+    # Does this locked specification satisfy +dependency+?
+    #
+    # NOTE: Rubygems default requirement is ">= 0", which doesn't match
+    # prereleases of 0 versions, like "0.0.0.dev" or "0.0.0.SNAPSHOT". However,
+    # bundler users expect those to work. We need to make sure that Gemfile
+    # dependencies without explicit requirements (which use ">= 0" under the
+    # hood by default) are still valid for locked specs using this kind of
+    # versions. The method implements an ad-hoc fix for that. A better solution
+    # might be to change default rubygems requirement of dependencies to be ">=
+    # 0.A" but that's a major refactoring likely to break things. Hopefully we
+    # can attempt it in the future.
+    #
+
     def satisfies?(dependency)
-      @name == dependency.name && dependency.requirement.satisfied_by?(Gem::Version.new(@version))
+      effective_requirement = dependency.requirement == Gem::Requirement.default ? Gem::Requirement.new(">= 0.A") : dependency.requirement
+
+      @name == dependency.name && effective_requirement.satisfied_by?(Gem::Version.new(@version))
     end
 
     def to_lock
       out = String.new
 
-      if platform == Gem::Platform::RUBY || platform.nil?
+      if platform == Gem::Platform::RUBY
         out << "    #{name} (#{version})\n"
       else
         out << "    #{name} (#{version}-#{platform})\n"
@@ -67,19 +73,36 @@ module Bundler
       out
     end
 
-    def __materialize__
-      search_object = Bundler.feature_flag.specific_platform? || Bundler.settings[:force_ruby_platform] ? self : Dependency.new(name, version)
-      @specification = if source.is_a?(Source::Gemspec) && source.gemspec.name == name
-        source.gemspec.tap {|s| s.source = source }
+    def materialize_for_installation
+      source.local!
+
+      candidates = if source.is_a?(Source::Path) || !ruby_platform_materializes_to_ruby_platform?
+        target_platform = ruby_platform_materializes_to_ruby_platform? ? platform : Bundler.local_platform
+
+        source.specs.search(Dependency.new(name, version)).select do |spec|
+          MatchPlatform.platforms_match?(spec.platform, target_platform)
+        end
       else
-        search = source.specs.search(search_object).last
-        if search && Gem::Platform.new(search.platform) != Gem::Platform.new(platform) && !search.runtime_dependencies.-(dependencies.reject {|d| d.type == :development }).empty?
-          Bundler.ui.warn "Unable to use the platform-specific (#{search.platform}) version of #{name} (#{version}) " \
-            "because it has different dependencies from the #{platform} version. " \
-            "To use the platform-specific version of the gem, run `bundle config set specific_platform true` and install again."
-          search = source.specs.search(self).last
+        source.specs.search(self)
+      end
+
+      return self if candidates.empty?
+
+      __materialize__(candidates)
+    end
+
+    def __materialize__(candidates)
+      @specification = begin
+        search = candidates.reverse.find do |spec|
+          spec.is_a?(StubSpecification) ||
+            (spec.matches_current_ruby? &&
+              spec.matches_current_rubygems?)
+        end
+        if search.nil? && Bundler.frozen_bundle?
+          search = candidates.last
+        else
+          search.dependencies = dependencies if search && search.full_name == full_name && (search.is_a?(RemoteSpecification) || search.is_a?(EndpointSpecification))
         end
-        search.dependencies = dependencies if search && (search.is_a?(RemoteSpecification) || search.is_a?(EndpointSpecification))
         search
       end
     end
@@ -89,7 +112,7 @@ module Bundler
     end
 
     def to_s
-      @__to_s ||= if platform == Gem::Platform::RUBY || platform.nil?
+      @__to_s ||= if platform == Gem::Platform::RUBY
         "#{name} (#{version})"
       else
         "#{name} (#{version}-#{platform})"
@@ -97,7 +120,7 @@ module Bundler
     end
 
     def identifier
-      @__identifier ||= Identifier.new(name, version, source, platform, dependencies)
+      @__identifier ||= [name, version, platform_string]
     end
 
     def git_version
@@ -105,7 +128,14 @@ module Bundler
       " #{source.revision[0..6]}"
     end
 
-  private
+    protected
+
+    def platform_string
+      platform_string = platform.to_s
+      platform_string == Index::RUBY ? Index::NULL : platform_string
+    end
+
+    private
 
     def to_ary
       nil
@@ -118,5 +148,18 @@ module Bundler
 
       @specification.send(method, *args, &blk)
     end
+
+    #
+    # For backwards compatibility with existing lockfiles, if the most specific
+    # locked platform is RUBY, we keep the previous behaviour of resolving the
+    # best platform variant at materiliazation time. For previous bundler
+    # versions (before 2.2.0) this was always the case (except when the lockfile
+    # only included non-ruby platforms), but we're also keeping this behaviour
+    # on newer bundlers unless users generate the lockfile from scratch or
+    # explicitly add a more specific platform.
+    #
+    def ruby_platform_materializes_to_ruby_platform?
+      !Bundler.most_specific_locked_platform?(generic_local_platform) || force_ruby_platform || Bundler.settings[:force_ruby_platform]
+    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/lockfile_generator.rb
+++ ruby2.7-2.7.6/lib/bundler/lockfile_generator.rb
@@ -25,7 +25,7 @@ module Bundler
       out
     end
 
-  private
+    private
 
     def add_sources
       definition.send(:sources).lock_sources.each_with_index do |source, idx|
@@ -60,7 +60,7 @@ module Bundler
       handled = []
       definition.dependencies.sort_by(&:to_s).each do |dep|
         next if handled.include?(dep.name)
-        out << dep.to_lock
+        out << dep.to_lock << "\n"
         handled << dep.name
       end
     end
@@ -71,7 +71,7 @@ module Bundler
     end
 
     def add_bundled_with
-      add_section("BUNDLED WITH", definition.locked_bundler_version.to_s)
+      add_section("BUNDLED WITH", Bundler::VERSION)
     end
 
     def add_section(name, value)
--- ruby2.7-2.7.6.orig/lib/bundler/lockfile_parser.rb
+++ ruby2.7-2.7.6/lib/bundler/lockfile_parser.rb
@@ -1,16 +1,5 @@
 # frozen_string_literal: true
 
-#--
-# Some versions of the Bundler 1.1 RC series introduced corrupted
-# lockfiles. There were two major problems:
-#
-# * multiple copies of the same GIT section appeared in the lockfile
-# * when this happened, those sections got multiple copies of gems
-#   in those sections.
-#
-# As a result, Bundler 1.1 contains code that fixes the earlier
-# corruption. We will remove this fix-up code in Bundler 1.2.
-
 module Bundler
   class LockfileParser
     attr_reader :sources, :dependencies, :specs, :platforms, :bundler_version, :ruby_version
@@ -57,6 +46,16 @@ module Bundler
       attributes
     end
 
+    def self.bundled_with
+      lockfile = Bundler.default_lockfile
+      return unless lockfile.file?
+
+      lockfile_contents = Bundler.read_file(lockfile)
+      return unless lockfile_contents.include?(BUNDLED)
+
+      lockfile_contents.split(BUNDLED).last.strip
+    end
+
     def initialize(lockfile)
       @platforms    = []
       @sources      = []
@@ -64,8 +63,6 @@ module Bundler
       @state        = nil
       @specs        = {}
 
-      @rubygems_aggregate = Source::Rubygems.new
-
       if lockfile.match(/<<<<<<<|=======|>>>>>>>|\|\|\|\|\|\|\|/)
         raise LockfileError, "Your #{Bundler.default_lockfile.relative_path_from(SharedHelpers.pwd)} contains merge conflicts.\n" \
           "Run `git checkout HEAD -- #{Bundler.default_lockfile.relative_path_from(SharedHelpers.pwd)}` first to get a clean lock."
@@ -89,27 +86,18 @@ module Bundler
           send("parse_#{@state}", line)
         end
       end
-      @sources << @rubygems_aggregate unless Bundler.feature_flag.disable_multisource?
       @specs = @specs.values.sort_by(&:identifier)
-      warn_for_outdated_bundler_version
     rescue ArgumentError => e
       Bundler.ui.debug(e)
       raise LockfileError, "Your lockfile is unreadable. Run `rm #{Bundler.default_lockfile.relative_path_from(SharedHelpers.pwd)}` " \
         "and then `bundle install` to generate a new lockfile."
     end
 
-    def warn_for_outdated_bundler_version
-      return unless bundler_version
-      prerelease_text = bundler_version.prerelease? ? " --pre" : ""
-      current_version = Gem::Version.create(Bundler::VERSION)
-      return unless current_version < bundler_version
-      Bundler.ui.warn "Warning: the running version of Bundler (#{current_version}) is older " \
-           "than the version that created the lockfile (#{bundler_version}). We suggest you to " \
-           "upgrade to the version that created the lockfile by running `gem install " \
-           "bundler:#{bundler_version}#{prerelease_text}`.\n"
+    def may_include_redundant_platform_specific_gems?
+      bundler_version.nil? || bundler_version < Gem::Version.new("1.16.2")
     end
 
-  private
+    private
 
     TYPES = {
       GIT    => Bundler::Source::Git,
@@ -127,23 +115,11 @@ module Bundler
           @sources << @current_source
         when GIT
           @current_source = TYPES[@type].from_lock(@opts)
-          # Strip out duplicate GIT sections
-          if @sources.include?(@current_source)
-            @current_source = @sources.find {|s| s == @current_source }
-          else
-            @sources << @current_source
-          end
+          @sources << @current_source
         when GEM
-          if Bundler.feature_flag.disable_multisource?
-            @opts["remotes"] = @opts.delete("remote")
-            @current_source = TYPES[@type].from_lock(@opts)
-            @sources << @current_source
-          else
-            Array(@opts["remote"]).each do |url|
-              @rubygems_aggregate.add_remote(url)
-            end
-            @current_source = @rubygems_aggregate
-          end
+          @opts["remotes"] = Array(@opts.delete("remote")).reverse
+          @current_source = TYPES[@type].from_lock(@opts)
+          @sources << @current_source
         when PLUGIN
           @current_source = Plugin.source_from_lock(@opts)
           @sources << @current_source
@@ -221,10 +197,9 @@ module Bundler
         platform = platform ? Gem::Platform.new(platform) : Gem::Platform::RUBY
         @current_spec = LazySpecification.new(name, version, platform)
         @current_spec.source = @current_source
+        @current_source.add_dependency_names(name)
 
-        # Avoid introducing multiple copies of the same spec (caused by
-        # duplicate GIT sections)
-        @specs[@current_spec.identifier] ||= @current_spec
+        @specs[@current_spec.identifier] = @current_spec
       elsif spaces.size == 6
         version = version.split(",").map(&:strip) if version
         dep = Gem::Dependency.new(name, version)
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/.document
@@ -0,0 +1 @@
+# Ignore all files in this directory
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-add.1
@@ -0,0 +1,82 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-ADD" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-add\fR \- Add gem to the Gemfile and run bundle install
+.
+.SH "SYNOPSIS"
+\fBbundle add\fR \fIGEM_NAME\fR [\-\-group=GROUP] [\-\-version=VERSION] [\-\-source=SOURCE] [\-\-path=PATH] [\-\-git=GIT] [\-\-github=GITHUB] [\-\-branch=BRANCH] [\-\-ref=REF] [\-\-skip\-install] [\-\-strict] [\-\-optimistic]
+.
+.SH "DESCRIPTION"
+Adds the named gem to the Gemfile and run \fBbundle install\fR\. \fBbundle install\fR can be avoided by using the flag \fB\-\-skip\-install\fR\.
+.
+.P
+Example:
+.
+.P
+bundle add rails
+.
+.P
+bundle add rails \-\-version "< 3\.0, > 1\.1"
+.
+.P
+bundle add rails \-\-version "~> 5\.0\.0" \-\-source "https://gems\.example\.com" \-\-group "development"
+.
+.P
+bundle add rails \-\-skip\-install
+.
+.P
+bundle add rails \-\-group "development, test"
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-version\fR, \fB\-v\fR
+Specify version requirements(s) for the added gem\.
+.
+.TP
+\fB\-\-group\fR, \fB\-g\fR
+Specify the group(s) for the added gem\. Multiple groups should be separated by commas\.
+.
+.TP
+\fB\-\-source\fR, \fB\-s\fR
+Specify the source for the added gem\.
+.
+.TP
+\fB\-\-require\fR, \fB\-r\fR
+Adds require path to gem\. Provide false, or a path as a string\.
+.
+.TP
+\fB\-\-path\fR
+Specify the file system path for the added gem\.
+.
+.TP
+\fB\-\-git\fR
+Specify the git source for the added gem\.
+.
+.TP
+\fB\-\-github\fR
+Specify the github source for the added gem\.
+.
+.TP
+\fB\-\-branch\fR
+Specify the git branch for the added gem\.
+.
+.TP
+\fB\-\-ref\fR
+Specify the git ref for the added gem\.
+.
+.TP
+\fB\-\-skip\-install\fR
+Adds the gem to the Gemfile but does not install it\.
+.
+.TP
+\fB\-\-optimistic\fR
+Adds optimistic declaration of version\.
+.
+.TP
+\fB\-\-strict\fR
+Adds strict declaration of version\.
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-add.1.ronn
@@ -0,0 +1,58 @@
+bundle-add(1) -- Add gem to the Gemfile and run bundle install
+================================================================
+
+## SYNOPSIS
+
+`bundle add` <GEM_NAME> [--group=GROUP] [--version=VERSION] [--source=SOURCE] [--path=PATH] [--git=GIT] [--github=GITHUB] [--branch=BRANCH] [--ref=REF] [--skip-install] [--strict] [--optimistic]
+
+## DESCRIPTION
+Adds the named gem to the Gemfile and run `bundle install`. `bundle install` can be avoided by using the flag `--skip-install`.
+
+Example:
+
+bundle add rails
+
+bundle add rails --version "< 3.0, > 1.1"
+
+bundle add rails --version "~> 5.0.0" --source "https://gems.example.com" --group "development"
+
+bundle add rails --skip-install
+
+bundle add rails --group "development, test"
+
+## OPTIONS
+* `--version`, `-v`:
+  Specify version requirements(s) for the added gem.
+
+* `--group`, `-g`:
+  Specify the group(s) for the added gem. Multiple groups should be separated by commas.
+
+* `--source`, `-s`:
+  Specify the source for the added gem.
+
+* `--require`, `-r`:
+  Adds require path to gem. Provide false, or a path as a string.
+
+* `--path`:
+  Specify the file system path for the added gem.
+
+* `--git`:
+  Specify the git source for the added gem.
+
+* `--github`:
+  Specify the github source for the added gem.
+
+* `--branch`:
+  Specify the git branch for the added gem.
+
+* `--ref`:
+  Specify the git ref for the added gem.
+
+* `--skip-install`:
+  Adds the gem to the Gemfile but does not install it.
+
+* `--optimistic`:
+  Adds optimistic declaration of version.
+
+* `--strict`:
+  Adds strict declaration of version.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-binstubs.1
@@ -0,0 +1,42 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-BINSTUBS" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-binstubs\fR \- Install the binstubs of the listed gems
+.
+.SH "SYNOPSIS"
+\fBbundle binstubs\fR \fIGEM_NAME\fR [\-\-force] [\-\-path PATH] [\-\-standalone]
+.
+.SH "DESCRIPTION"
+Binstubs are scripts that wrap around executables\. Bundler creates a small Ruby file (a binstub) that loads Bundler, runs the command, and puts it into \fBbin/\fR\. Binstubs are a shortcut\-or alternative\- to always using \fBbundle exec\fR\. This gives you a file that can be run directly, and one that will always run the correct gem version used by the application\.
+.
+.P
+For example, if you run \fBbundle binstubs rspec\-core\fR, Bundler will create the file \fBbin/rspec\fR\. That file will contain enough code to load Bundler, tell it to load the bundled gems, and then run rspec\.
+.
+.P
+This command generates binstubs for executables in \fBGEM_NAME\fR\. Binstubs are put into \fBbin\fR, or the \fB\-\-path\fR directory if one has been set\. Calling binstubs with [GEM [GEM]] will create binstubs for all given gems\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-force\fR
+Overwrite existing binstubs if they exist\.
+.
+.TP
+\fB\-\-path\fR
+The location to install the specified binstubs to\. This defaults to \fBbin\fR\.
+.
+.TP
+\fB\-\-standalone\fR
+Makes binstubs that can work without depending on Rubygems or Bundler at runtime\.
+.
+.TP
+\fB\-\-shebang\fR
+Specify a different shebang executable name than the default (default \'ruby\')
+.
+.TP
+\fB\-\-all\fR
+Create binstubs for all gems in the bundle\.
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-binstubs.1.ronn
@@ -0,0 +1,41 @@
+bundle-binstubs(1) -- Install the binstubs of the listed gems
+=============================================================
+
+## SYNOPSIS
+
+`bundle binstubs` <GEM_NAME> [--force] [--path PATH] [--standalone]
+
+## DESCRIPTION
+
+Binstubs are scripts that wrap around executables. Bundler creates a
+small Ruby file (a binstub) that loads Bundler, runs the command,
+and puts it into `bin/`. Binstubs are a shortcut-or alternative-
+to always using `bundle exec`. This gives you a file that can be run
+directly, and one that will always run the correct gem version
+used by the application.
+
+For example, if you run `bundle binstubs rspec-core`, Bundler will create
+the file `bin/rspec`. That file will contain enough code to load Bundler,
+tell it to load the bundled gems, and then run rspec.
+
+This command generates binstubs for executables in `GEM_NAME`.
+Binstubs are put into `bin`, or the `--path` directory if one has been set.
+Calling binstubs with [GEM [GEM]] will create binstubs for all given gems.
+
+## OPTIONS
+
+* `--force`:
+  Overwrite existing binstubs if they exist.
+
+* `--path`:
+  The location to install the specified binstubs to. This defaults to `bin`.
+
+* `--standalone`:
+  Makes binstubs that can work without depending on Rubygems or Bundler at
+  runtime.
+
+* `--shebang`:
+  Specify a different shebang executable name than the default (default 'ruby')
+
+* `--all`:
+  Create binstubs for all gems in the bundle.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-cache.1
@@ -0,0 +1,61 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-CACHE" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-cache\fR \- Package your needed \fB\.gem\fR files into your application
+.
+.SH "SYNOPSIS"
+\fBbundle cache\fR
+.
+.P
+alias: \fBpackage\fR, \fBpack\fR
+.
+.SH "DESCRIPTION"
+Copy all of the \fB\.gem\fR files needed to run the application into the \fBvendor/cache\fR directory\. In the future, when running [bundle install(1)][bundle\-install], use the gems in the cache in preference to the ones on \fBrubygems\.org\fR\.
+.
+.SH "GIT AND PATH GEMS"
+The \fBbundle cache\fR command can also package \fB:git\fR and \fB:path\fR dependencies besides \.gem files\. This needs to be explicitly enabled via the \fB\-\-all\fR option\. Once used, the \fB\-\-all\fR option will be remembered\.
+.
+.SH "SUPPORT FOR MULTIPLE PLATFORMS"
+When using gems that have different packages for different platforms, Bundler supports caching of gems for other platforms where the Gemfile has been resolved (i\.e\. present in the lockfile) in \fBvendor/cache\fR\. This needs to be enabled via the \fB\-\-all\-platforms\fR option\. This setting will be remembered in your local bundler configuration\.
+.
+.SH "REMOTE FETCHING"
+By default, if you run \fBbundle install(1)\fR](bundle\-install\.1\.html) after running bundle cache(1) \fIbundle\-cache\.1\.html\fR, bundler will still connect to \fBrubygems\.org\fR to check whether a platform\-specific gem exists for any of the gems in \fBvendor/cache\fR\.
+.
+.P
+For instance, consider this Gemfile(5):
+.
+.IP "" 4
+.
+.nf
+
+source "https://rubygems\.org"
+
+gem "nokogiri"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+If you run \fBbundle cache\fR under C Ruby, bundler will retrieve the version of \fBnokogiri\fR for the \fB"ruby"\fR platform\. If you deploy to JRuby and run \fBbundle install\fR, bundler is forced to check to see whether a \fB"java"\fR platformed \fBnokogiri\fR exists\.
+.
+.P
+Even though the \fBnokogiri\fR gem for the Ruby platform is \fItechnically\fR acceptable on JRuby, it has a C extension that does not run on JRuby\. As a result, bundler will, by default, still connect to \fBrubygems\.org\fR to check whether it has a version of one of your gems more specific to your platform\.
+.
+.P
+This problem is also not limited to the \fB"java"\fR platform\. A similar (common) problem can happen when developing on Windows and deploying to Linux, or even when developing on OSX and deploying to Linux\.
+.
+.P
+If you know for sure that the gems packaged in \fBvendor/cache\fR are appropriate for the platform you are on, you can run \fBbundle install \-\-local\fR to skip checking for more appropriate gems, and use the ones in \fBvendor/cache\fR\.
+.
+.P
+One way to be sure that you have the right platformed versions of all your gems is to run \fBbundle cache\fR on an identical machine and check in the gems\. For instance, you can run \fBbundle cache\fR on an identical staging box during your staging process, and check in the \fBvendor/cache\fR before deploying to production\.
+.
+.P
+By default, bundle cache(1) \fIbundle\-cache\.1\.html\fR fetches and also installs the gems to the default location\. To package the dependencies to \fBvendor/cache\fR without installing them to the local install location, you can run \fBbundle cache \-\-no\-install\fR\.
+.
+.SH "HISTORY"
+In Bundler 2\.1, \fBcache\fR took in the functionalities of \fBpackage\fR and now \fBpackage\fR and \fBpack\fR are aliases of \fBcache\fR\.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-cache.1.ronn
@@ -0,0 +1,79 @@
+bundle-cache(1) -- Package your needed `.gem` files into your application
+===========================================================================
+
+## SYNOPSIS
+
+`bundle cache`
+
+alias: `package`, `pack`
+
+## DESCRIPTION
+
+Copy all of the `.gem` files needed to run the application into the
+`vendor/cache` directory. In the future, when running [bundle install(1)][bundle-install],
+use the gems in the cache in preference to the ones on `rubygems.org`.
+
+## GIT AND PATH GEMS
+
+The `bundle cache` command can also package `:git` and `:path` dependencies
+besides .gem files. This needs to be explicitly enabled via the `--all` option.
+Once used, the `--all` option will be remembered.
+
+## SUPPORT FOR MULTIPLE PLATFORMS
+
+When using gems that have different packages for different platforms, Bundler
+supports caching of gems for other platforms where the Gemfile has been resolved
+(i.e. present in the lockfile) in `vendor/cache`.  This needs to be enabled via
+the `--all-platforms` option. This setting will be remembered in your local
+bundler configuration.
+
+## REMOTE FETCHING
+
+By default, if you run `bundle install(1)`](bundle-install.1.html) after running
+[bundle cache(1)](bundle-cache.1.html), bundler will still connect to `rubygems.org`
+to check whether a platform-specific gem exists for any of the gems
+in `vendor/cache`.
+
+For instance, consider this Gemfile(5):
+
+    source "https://rubygems.org"
+
+    gem "nokogiri"
+
+If you run `bundle cache` under C Ruby, bundler will retrieve
+the version of `nokogiri` for the `"ruby"` platform. If you deploy
+to JRuby and run `bundle install`, bundler is forced to check to
+see whether a `"java"` platformed `nokogiri` exists.
+
+Even though the `nokogiri` gem for the Ruby platform is
+_technically_ acceptable on JRuby, it has a C extension
+that does not run on JRuby. As a result, bundler will, by default,
+still connect to `rubygems.org` to check whether it has a version
+of one of your gems more specific to your platform.
+
+This problem is also not limited to the `"java"` platform.
+A similar (common) problem can happen when developing on Windows
+and deploying to Linux, or even when developing on OSX and
+deploying to Linux.
+
+If you know for sure that the gems packaged in `vendor/cache`
+are appropriate for the platform you are on, you can run
+`bundle install --local` to skip checking for more appropriate
+gems, and use the ones in `vendor/cache`.
+
+One way to be sure that you have the right platformed versions
+of all your gems is to run `bundle cache` on an identical
+machine and check in the gems. For instance, you can run
+`bundle cache` on an identical staging box during your
+staging process, and check in the `vendor/cache` before
+deploying to production.
+
+By default, [bundle cache(1)](bundle-cache.1.html) fetches and also
+installs the gems to the default location. To package the
+dependencies to `vendor/cache` without installing them to the
+local install location, you can run `bundle cache --no-install`.
+
+## HISTORY
+
+In Bundler 2.1, `cache` took in the functionalities of `package` and now
+`package` and `pack` are aliases of `cache`.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-check.1
@@ -0,0 +1,31 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-CHECK" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-check\fR \- Verifies if dependencies are satisfied by installed gems
+.
+.SH "SYNOPSIS"
+\fBbundle check\fR [\-\-dry\-run] [\-\-gemfile=FILE] [\-\-path=PATH]
+.
+.SH "DESCRIPTION"
+\fBcheck\fR searches the local machine for each of the gems requested in the Gemfile\. If all gems are found, Bundler prints a success message and exits with a status of 0\.
+.
+.P
+If not, the first missing gem is listed and Bundler exits status 1\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-dry\-run\fR
+Locks the [\fBGemfile(5)\fR][Gemfile(5)] before running the command\.
+.
+.TP
+\fB\-\-gemfile\fR
+Use the specified gemfile instead of the [\fBGemfile(5)\fR][Gemfile(5)]\.
+.
+.TP
+\fB\-\-path\fR
+Specify a different path than the system default (\fB$BUNDLE_PATH\fR or \fB$GEM_HOME\fR)\. Bundler will remember this value for future installs on this machine\.
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-check.1.ronn
@@ -0,0 +1,26 @@
+bundle-check(1) -- Verifies if dependencies are satisfied by installed gems
+===========================================================================
+
+## SYNOPSIS
+
+`bundle check` [--dry-run]
+               [--gemfile=FILE]
+               [--path=PATH]
+
+## DESCRIPTION
+
+`check` searches the local machine for each of the gems requested in the
+Gemfile. If all gems are found, Bundler prints a success message and exits with
+a status of 0.
+
+If not, the first missing gem is listed and Bundler exits status 1.
+
+## OPTIONS
+
+* `--dry-run`:
+  Locks the [`Gemfile(5)`][Gemfile(5)] before running the command.
+* `--gemfile`:
+  Use the specified gemfile instead of the [`Gemfile(5)`][Gemfile(5)].
+* `--path`:
+  Specify a different path than the system default (`$BUNDLE_PATH` or `$GEM_HOME`).
+  Bundler will remember this value for future installs on this machine.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-clean.1
@@ -0,0 +1,24 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-CLEAN" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-clean\fR \- Cleans up unused gems in your bundler directory
+.
+.SH "SYNOPSIS"
+\fBbundle clean\fR [\-\-dry\-run] [\-\-force]
+.
+.SH "DESCRIPTION"
+This command will remove all unused gems in your bundler directory\. This is useful when you have made many changes to your gem dependencies\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-dry\-run\fR
+Print the changes, but do not clean the unused gems\.
+.
+.TP
+\fB\-\-force\fR
+Force a clean even if \fB\-\-path\fR is not set\.
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-clean.1.ronn
@@ -0,0 +1,18 @@
+bundle-clean(1) -- Cleans up unused gems in your bundler directory
+==================================================================
+
+## SYNOPSIS
+
+`bundle clean` [--dry-run] [--force]
+
+## DESCRIPTION
+
+This command will remove all unused gems in your bundler directory. This is
+useful when you have made many changes to your gem dependencies.
+
+## OPTIONS
+
+* `--dry-run`:
+  Print the changes, but do not clean the unused gems.
+* `--force`:
+  Force a clean even if `--path` is not set.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-config.1
@@ -0,0 +1,515 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-CONFIG" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-config\fR \- Set bundler configuration options
+.
+.SH "SYNOPSIS"
+\fBbundle config\fR list
+.
+.br
+\fBbundle config\fR [get] NAME
+.
+.br
+\fBbundle config\fR [set] NAME VALUE
+.
+.br
+\fBbundle config\fR unset NAME
+.
+.SH "DESCRIPTION"
+This command allows you to interact with Bundler\'s configuration system\.
+.
+.P
+Bundler loads configuration settings in this order:
+.
+.IP "1." 4
+Local config (\fB<project_root>/\.bundle/config\fR or \fB$BUNDLE_APP_CONFIG/config\fR)
+.
+.IP "2." 4
+Environmental variables (\fBENV\fR)
+.
+.IP "3." 4
+Global config (\fB~/\.bundle/config\fR)
+.
+.IP "4." 4
+Bundler default config
+.
+.IP "" 0
+.
+.P
+Executing \fBbundle config list\fR with will print a list of all bundler configuration for the current bundle, and where that configuration was set\.
+.
+.P
+Executing \fBbundle config get <name>\fR will print the value of that configuration setting, and where it was set\.
+.
+.P
+Executing \fBbundle config set <name> <value>\fR defaults to setting \fBlocal\fR configuration if executing from within a local application, otherwise it will set \fBglobal\fR configuration\. See \fB\-\-local\fR and \fB\-\-global\fR options below\.
+.
+.P
+Executing \fBbundle config set \-\-local <name> <value>\fR will set that configuration in the directory for the local application\. The configuration will be stored in \fB<project_root>/\.bundle/config\fR\. If \fBBUNDLE_APP_CONFIG\fR is set, the configuration will be stored in \fB$BUNDLE_APP_CONFIG/config\fR\.
+.
+.P
+Executing \fBbundle config set \-\-global <name> <value>\fR will set that configuration to the value specified for all bundles executed as the current user\. The configuration will be stored in \fB~/\.bundle/config\fR\. If \fIname\fR already is set, \fIname\fR will be overridden and user will be warned\.
+.
+.P
+Executing \fBbundle config unset <name>\fR will delete the configuration in both local and global sources\.
+.
+.P
+Executing \fBbundle config unset \-\-global <name>\fR will delete the configuration only from the user configuration\.
+.
+.P
+Executing \fBbundle config unset \-\-local <name>\fR will delete the configuration only from the local application\.
+.
+.P
+Executing bundle with the \fBBUNDLE_IGNORE_CONFIG\fR environment variable set will cause it to ignore all configuration\.
+.
+.SH "REMEMBERING OPTIONS"
+Flags passed to \fBbundle install\fR or the Bundler runtime, such as \fB\-\-path foo\fR or \fB\-\-without production\fR, are remembered between commands and saved to your local application\'s configuration (normally, \fB\./\.bundle/config\fR)\.
+.
+.P
+However, this will be changed in bundler 3, so it\'s better not to rely on this behavior\. If these options must be remembered, it\'s better to set them using \fBbundle config\fR (e\.g\., \fBbundle config set \-\-local path foo\fR)\.
+.
+.P
+The options that can be configured are:
+.
+.TP
+\fBbin\fR
+Creates a directory (defaults to \fB~/bin\fR) and place any executables from the gem there\. These executables run in Bundler\'s context\. If used, you might add this directory to your environment\'s \fBPATH\fR variable\. For instance, if the \fBrails\fR gem comes with a \fBrails\fR executable, this flag will create a \fBbin/rails\fR executable that ensures that all referred dependencies will be resolved using the bundled gems\.
+.
+.TP
+\fBdeployment\fR
+In deployment mode, Bundler will \'roll\-out\' the bundle for \fBproduction\fR use\. Please check carefully if you want to have this option enabled in \fBdevelopment\fR or \fBtest\fR environments\.
+.
+.TP
+\fBonly\fR
+A space\-separated list of groups to install only gems of the specified groups\.
+.
+.TP
+\fBpath\fR
+The location to install the specified gems to\. This defaults to Rubygems\' setting\. Bundler shares this location with Rubygems, \fBgem install \.\.\.\fR will have gem installed there, too\. Therefore, gems installed without a \fB\-\-path \.\.\.\fR setting will show up by calling \fBgem list\fR\. Accordingly, gems installed to other locations will not get listed\.
+.
+.TP
+\fBwithout\fR
+A space\-separated list of groups referencing gems to skip during installation\.
+.
+.TP
+\fBwith\fR
+A space\-separated list of \fBoptional\fR groups referencing gems to include during installation\.
+.
+.SH "BUILD OPTIONS"
+You can use \fBbundle config\fR to give Bundler the flags to pass to the gem installer every time bundler tries to install a particular gem\.
+.
+.P
+A very common example, the \fBmysql\fR gem, requires Snow Leopard users to pass configuration flags to \fBgem install\fR to specify where to find the \fBmysql_config\fR executable\.
+.
+.IP "" 4
+.
+.nf
+
+gem install mysql \-\- \-\-with\-mysql\-config=/usr/local/mysql/bin/mysql_config
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Since the specific location of that executable can change from machine to machine, you can specify these flags on a per\-machine basis\.
+.
+.IP "" 4
+.
+.nf
+
+bundle config set \-\-global build\.mysql \-\-with\-mysql\-config=/usr/local/mysql/bin/mysql_config
+.
+.fi
+.
+.IP "" 0
+.
+.P
+After running this command, every time bundler needs to install the \fBmysql\fR gem, it will pass along the flags you specified\.
+.
+.SH "CONFIGURATION KEYS"
+Configuration keys in bundler have two forms: the canonical form and the environment variable form\.
+.
+.P
+For instance, passing the \fB\-\-without\fR flag to bundle install(1) \fIbundle\-install\.1\.html\fR prevents Bundler from installing certain groups specified in the Gemfile(5)\. Bundler persists this value in \fBapp/\.bundle/config\fR so that calls to \fBBundler\.setup\fR do not try to find gems from the \fBGemfile\fR that you didn\'t install\. Additionally, subsequent calls to bundle install(1) \fIbundle\-install\.1\.html\fR remember this setting and skip those groups\.
+.
+.P
+The canonical form of this configuration is \fB"without"\fR\. To convert the canonical form to the environment variable form, capitalize it, and prepend \fBBUNDLE_\fR\. The environment variable form of \fB"without"\fR is \fBBUNDLE_WITHOUT\fR\.
+.
+.P
+Any periods in the configuration keys must be replaced with two underscores when setting it via environment variables\. The configuration key \fBlocal\.rack\fR becomes the environment variable \fBBUNDLE_LOCAL__RACK\fR\.
+.
+.SH "LIST OF AVAILABLE KEYS"
+The following is a list of all configuration keys and their purpose\. You can learn more about their operation in bundle install(1) \fIbundle\-install\.1\.html\fR\.
+.
+.IP "\(bu" 4
+\fBallow_deployment_source_credential_changes\fR (\fBBUNDLE_ALLOW_DEPLOYMENT_SOURCE_CREDENTIAL_CHANGES\fR): When in deployment mode, allow changing the credentials to a gem\'s source\. Ex: \fBhttps://some\.host\.com/gems/path/\fR \-> \fBhttps://user_name:password@some\.host\.com/gems/path\fR
+.
+.IP "\(bu" 4
+\fBallow_offline_install\fR (\fBBUNDLE_ALLOW_OFFLINE_INSTALL\fR): Allow Bundler to use cached data when installing without network access\.
+.
+.IP "\(bu" 4
+\fBauto_clean_without_path\fR (\fBBUNDLE_AUTO_CLEAN_WITHOUT_PATH\fR): Automatically run \fBbundle clean\fR after installing when an explicit \fBpath\fR has not been set and Bundler is not installing into the system gems\.
+.
+.IP "\(bu" 4
+\fBauto_install\fR (\fBBUNDLE_AUTO_INSTALL\fR): Automatically run \fBbundle install\fR when gems are missing\.
+.
+.IP "\(bu" 4
+\fBbin\fR (\fBBUNDLE_BIN\fR): Install executables from gems in the bundle to the specified directory\. Defaults to \fBfalse\fR\.
+.
+.IP "\(bu" 4
+\fBcache_all\fR (\fBBUNDLE_CACHE_ALL\fR): Cache all gems, including path and git gems\. This needs to be explicitly configured on bundler 1 and bundler 2, but will be the default on bundler 3\.
+.
+.IP "\(bu" 4
+\fBcache_all_platforms\fR (\fBBUNDLE_CACHE_ALL_PLATFORMS\fR): Cache gems for all platforms\.
+.
+.IP "\(bu" 4
+\fBcache_path\fR (\fBBUNDLE_CACHE_PATH\fR): The directory that bundler will place cached gems in when running \fBbundle package\fR, and that bundler will look in when installing gems\. Defaults to \fBvendor/cache\fR\.
+.
+.IP "\(bu" 4
+\fBclean\fR (\fBBUNDLE_CLEAN\fR): Whether Bundler should run \fBbundle clean\fR automatically after \fBbundle install\fR\.
+.
+.IP "\(bu" 4
+\fBconsole\fR (\fBBUNDLE_CONSOLE\fR): The console that \fBbundle console\fR starts\. Defaults to \fBirb\fR\.
+.
+.IP "\(bu" 4
+\fBdefault_install_uses_path\fR (\fBBUNDLE_DEFAULT_INSTALL_USES_PATH\fR): Whether a \fBbundle install\fR without an explicit \fB\-\-path\fR argument defaults to installing gems in \fB\.bundle\fR\.
+.
+.IP "\(bu" 4
+\fBdeployment\fR (\fBBUNDLE_DEPLOYMENT\fR): Disallow changes to the \fBGemfile\fR\. When the \fBGemfile\fR is changed and the lockfile has not been updated, running Bundler commands will be blocked\.
+.
+.IP "\(bu" 4
+\fBdisable_checksum_validation\fR (\fBBUNDLE_DISABLE_CHECKSUM_VALIDATION\fR): Allow installing gems even if they do not match the checksum provided by RubyGems\.
+.
+.IP "\(bu" 4
+\fBdisable_exec_load\fR (\fBBUNDLE_DISABLE_EXEC_LOAD\fR): Stop Bundler from using \fBload\fR to launch an executable in\-process in \fBbundle exec\fR\.
+.
+.IP "\(bu" 4
+\fBdisable_local_branch_check\fR (\fBBUNDLE_DISABLE_LOCAL_BRANCH_CHECK\fR): Allow Bundler to use a local git override without a branch specified in the Gemfile\.
+.
+.IP "\(bu" 4
+\fBdisable_local_revision_check\fR (\fBBUNDLE_DISABLE_LOCAL_REVISION_CHECK\fR): Allow Bundler to use a local git override without checking if the revision present in the lockfile is present in the repository\.
+.
+.IP "\(bu" 4
+\fBdisable_shared_gems\fR (\fBBUNDLE_DISABLE_SHARED_GEMS\fR): Stop Bundler from accessing gems installed to RubyGems\' normal location\.
+.
+.IP "\(bu" 4
+\fBdisable_version_check\fR (\fBBUNDLE_DISABLE_VERSION_CHECK\fR): Stop Bundler from checking if a newer Bundler version is available on rubygems\.org\.
+.
+.IP "\(bu" 4
+\fBforce_ruby_platform\fR (\fBBUNDLE_FORCE_RUBY_PLATFORM\fR): Ignore the current machine\'s platform and install only \fBruby\fR platform gems\. As a result, gems with native extensions will be compiled from source\.
+.
+.IP "\(bu" 4
+\fBfrozen\fR (\fBBUNDLE_FROZEN\fR): Disallow changes to the \fBGemfile\fR\. When the \fBGemfile\fR is changed and the lockfile has not been updated, running Bundler commands will be blocked\. Defaults to \fBtrue\fR when \fB\-\-deployment\fR is used\.
+.
+.IP "\(bu" 4
+\fBgem\.github_username\fR (\fBBUNDLE_GEM__GITHUB_USERNAME\fR): Sets a GitHub username or organization to be used in \fBREADME\fR file when you create a new gem via \fBbundle gem\fR command\. It can be overridden by passing an explicit \fB\-\-github\-username\fR flag to \fBbundle gem\fR\.
+.
+.IP "\(bu" 4
+\fBgem\.push_key\fR (\fBBUNDLE_GEM__PUSH_KEY\fR): Sets the \fB\-\-key\fR parameter for \fBgem push\fR when using the \fBrake release\fR command with a private gemstash server\.
+.
+.IP "\(bu" 4
+\fBgemfile\fR (\fBBUNDLE_GEMFILE\fR): The name of the file that bundler should use as the \fBGemfile\fR\. This location of this file also sets the root of the project, which is used to resolve relative paths in the \fBGemfile\fR, among other things\. By default, bundler will search up from the current working directory until it finds a \fBGemfile\fR\.
+.
+.IP "\(bu" 4
+\fBglobal_gem_cache\fR (\fBBUNDLE_GLOBAL_GEM_CACHE\fR): Whether Bundler should cache all gems globally, rather than locally to the installing Ruby installation\.
+.
+.IP "\(bu" 4
+\fBignore_funding_requests\fR (\fBBUNDLE_IGNORE_FUNDING_REQUESTS\fR): When set, no funding requests will be printed\.
+.
+.IP "\(bu" 4
+\fBignore_messages\fR (\fBBUNDLE_IGNORE_MESSAGES\fR): When set, no post install messages will be printed\. To silence a single gem, use dot notation like \fBignore_messages\.httparty true\fR\.
+.
+.IP "\(bu" 4
+\fBinit_gems_rb\fR (\fBBUNDLE_INIT_GEMS_RB\fR): Generate a \fBgems\.rb\fR instead of a \fBGemfile\fR when running \fBbundle init\fR\.
+.
+.IP "\(bu" 4
+\fBjobs\fR (\fBBUNDLE_JOBS\fR): The number of gems Bundler can install in parallel\. Defaults to the number of available processors\.
+.
+.IP "\(bu" 4
+\fBno_install\fR (\fBBUNDLE_NO_INSTALL\fR): Whether \fBbundle package\fR should skip installing gems\.
+.
+.IP "\(bu" 4
+\fBno_prune\fR (\fBBUNDLE_NO_PRUNE\fR): Whether Bundler should leave outdated gems unpruned when caching\.
+.
+.IP "\(bu" 4
+\fBonly\fR (\fBBUNDLE_ONLY\fR): A space\-separated list of groups to install only gems of the specified groups\.
+.
+.IP "\(bu" 4
+\fBpath\fR (\fBBUNDLE_PATH\fR): The location on disk where all gems in your bundle will be located regardless of \fB$GEM_HOME\fR or \fB$GEM_PATH\fR values\. Bundle gems not found in this location will be installed by \fBbundle install\fR\. Defaults to \fBGem\.dir\fR\. When \-\-deployment is used, defaults to vendor/bundle\.
+.
+.IP "\(bu" 4
+\fBpath\.system\fR (\fBBUNDLE_PATH__SYSTEM\fR): Whether Bundler will install gems into the default system path (\fBGem\.dir\fR)\.
+.
+.IP "\(bu" 4
+\fBpath_relative_to_cwd\fR (\fBBUNDLE_PATH_RELATIVE_TO_CWD\fR) Makes \fB\-\-path\fR relative to the CWD instead of the \fBGemfile\fR\.
+.
+.IP "\(bu" 4
+\fBplugins\fR (\fBBUNDLE_PLUGINS\fR): Enable Bundler\'s experimental plugin system\.
+.
+.IP "\(bu" 4
+\fBprefer_patch\fR (BUNDLE_PREFER_PATCH): Prefer updating only to next patch version during updates\. Makes \fBbundle update\fR calls equivalent to \fBbundler update \-\-patch\fR\.
+.
+.IP "\(bu" 4
+\fBprint_only_version_number\fR (\fBBUNDLE_PRINT_ONLY_VERSION_NUMBER\fR): Print only version number from \fBbundler \-\-version\fR\.
+.
+.IP "\(bu" 4
+\fBredirect\fR (\fBBUNDLE_REDIRECT\fR): The number of redirects allowed for network requests\. Defaults to \fB5\fR\.
+.
+.IP "\(bu" 4
+\fBretry\fR (\fBBUNDLE_RETRY\fR): The number of times to retry failed network requests\. Defaults to \fB3\fR\.
+.
+.IP "\(bu" 4
+\fBsetup_makes_kernel_gem_public\fR (\fBBUNDLE_SETUP_MAKES_KERNEL_GEM_PUBLIC\fR): Have \fBBundler\.setup\fR make the \fBKernel#gem\fR method public, even though RubyGems declares it as private\.
+.
+.IP "\(bu" 4
+\fBshebang\fR (\fBBUNDLE_SHEBANG\fR): The program name that should be invoked for generated binstubs\. Defaults to the ruby install name used to generate the binstub\.
+.
+.IP "\(bu" 4
+\fBsilence_deprecations\fR (\fBBUNDLE_SILENCE_DEPRECATIONS\fR): Whether Bundler should silence deprecation warnings for behavior that will be changed in the next major version\.
+.
+.IP "\(bu" 4
+\fBsilence_root_warning\fR (\fBBUNDLE_SILENCE_ROOT_WARNING\fR): Silence the warning Bundler prints when installing gems as root\.
+.
+.IP "\(bu" 4
+\fBssl_ca_cert\fR (\fBBUNDLE_SSL_CA_CERT\fR): Path to a designated CA certificate file or folder containing multiple certificates for trusted CAs in PEM format\.
+.
+.IP "\(bu" 4
+\fBssl_client_cert\fR (\fBBUNDLE_SSL_CLIENT_CERT\fR): Path to a designated file containing a X\.509 client certificate and key in PEM format\.
+.
+.IP "\(bu" 4
+\fBssl_verify_mode\fR (\fBBUNDLE_SSL_VERIFY_MODE\fR): The SSL verification mode Bundler uses when making HTTPS requests\. Defaults to verify peer\.
+.
+.IP "\(bu" 4
+\fBsuppress_install_using_messages\fR (\fBBUNDLE_SUPPRESS_INSTALL_USING_MESSAGES\fR): Avoid printing \fBUsing \.\.\.\fR messages during installation when the version of a gem has not changed\.
+.
+.IP "\(bu" 4
+\fBsystem_bindir\fR (\fBBUNDLE_SYSTEM_BINDIR\fR): The location where RubyGems installs binstubs\. Defaults to \fBGem\.bindir\fR\.
+.
+.IP "\(bu" 4
+\fBtimeout\fR (\fBBUNDLE_TIMEOUT\fR): The seconds allowed before timing out for network requests\. Defaults to \fB10\fR\.
+.
+.IP "\(bu" 4
+\fBupdate_requires_all_flag\fR (\fBBUNDLE_UPDATE_REQUIRES_ALL_FLAG\fR): Require passing \fB\-\-all\fR to \fBbundle update\fR when everything should be updated, and disallow passing no options to \fBbundle update\fR\.
+.
+.IP "\(bu" 4
+\fBuser_agent\fR (\fBBUNDLE_USER_AGENT\fR): The custom user agent fragment Bundler includes in API requests\.
+.
+.IP "\(bu" 4
+\fBwith\fR (\fBBUNDLE_WITH\fR): A \fB:\fR\-separated list of groups whose gems bundler should install\.
+.
+.IP "\(bu" 4
+\fBwithout\fR (\fBBUNDLE_WITHOUT\fR): A \fB:\fR\-separated list of groups whose gems bundler should not install\.
+.
+.IP "" 0
+.
+.P
+In general, you should set these settings per\-application by using the applicable flag to the bundle install(1) \fIbundle\-install\.1\.html\fR or bundle cache(1) \fIbundle\-cache\.1\.html\fR command\.
+.
+.P
+You can set them globally either via environment variables or \fBbundle config\fR, whichever is preferable for your setup\. If you use both, environment variables will take preference over global settings\.
+.
+.SH "LOCAL GIT REPOS"
+Bundler also allows you to work against a git repository locally instead of using the remote version\. This can be achieved by setting up a local override:
+.
+.IP "" 4
+.
+.nf
+
+bundle config set \-\-local local\.GEM_NAME /path/to/local/git/repository
+.
+.fi
+.
+.IP "" 0
+.
+.P
+For example, in order to use a local Rack repository, a developer could call:
+.
+.IP "" 4
+.
+.nf
+
+bundle config set \-\-local local\.rack ~/Work/git/rack
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Now instead of checking out the remote git repository, the local override will be used\. Similar to a path source, every time the local git repository change, changes will be automatically picked up by Bundler\. This means a commit in the local git repo will update the revision in the \fBGemfile\.lock\fR to the local git repo revision\. This requires the same attention as git submodules\. Before pushing to the remote, you need to ensure the local override was pushed, otherwise you may point to a commit that only exists in your local machine\. You\'ll also need to CGI escape your usernames and passwords as well\.
+.
+.P
+Bundler does many checks to ensure a developer won\'t work with invalid references\. Particularly, we force a developer to specify a branch in the \fBGemfile\fR in order to use this feature\. If the branch specified in the \fBGemfile\fR and the current branch in the local git repository do not match, Bundler will abort\. This ensures that a developer is always working against the correct branches, and prevents accidental locking to a different branch\.
+.
+.P
+Finally, Bundler also ensures that the current revision in the \fBGemfile\.lock\fR exists in the local git repository\. By doing this, Bundler forces you to fetch the latest changes in the remotes\.
+.
+.SH "MIRRORS OF GEM SOURCES"
+Bundler supports overriding gem sources with mirrors\. This allows you to configure rubygems\.org as the gem source in your Gemfile while still using your mirror to fetch gems\.
+.
+.IP "" 4
+.
+.nf
+
+bundle config set \-\-global mirror\.SOURCE_URL MIRROR_URL
+.
+.fi
+.
+.IP "" 0
+.
+.P
+For example, to use a mirror of https://rubygems\.org hosted at https://example\.org:
+.
+.IP "" 4
+.
+.nf
+
+bundle config set \-\-global mirror\.https://rubygems\.org https://example\.org
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Each mirror also provides a fallback timeout setting\. If the mirror does not respond within the fallback timeout, Bundler will try to use the original server instead of the mirror\.
+.
+.IP "" 4
+.
+.nf
+
+bundle config set \-\-global mirror\.SOURCE_URL\.fallback_timeout TIMEOUT
+.
+.fi
+.
+.IP "" 0
+.
+.P
+For example, to fall back to rubygems\.org after 3 seconds:
+.
+.IP "" 4
+.
+.nf
+
+bundle config set \-\-global mirror\.https://rubygems\.org\.fallback_timeout 3
+.
+.fi
+.
+.IP "" 0
+.
+.P
+The default fallback timeout is 0\.1 seconds, but the setting can currently only accept whole seconds (for example, 1, 15, or 30)\.
+.
+.SH "CREDENTIALS FOR GEM SOURCES"
+Bundler allows you to configure credentials for any gem source, which allows you to avoid putting secrets into your Gemfile\.
+.
+.IP "" 4
+.
+.nf
+
+bundle config set \-\-global SOURCE_HOSTNAME USERNAME:PASSWORD
+.
+.fi
+.
+.IP "" 0
+.
+.P
+For example, to save the credentials of user \fBclaudette\fR for the gem source at \fBgems\.longerous\.com\fR, you would run:
+.
+.IP "" 4
+.
+.nf
+
+bundle config set \-\-global gems\.longerous\.com claudette:s00pers3krit
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Or you can set the credentials as an environment variable like this:
+.
+.IP "" 4
+.
+.nf
+
+export BUNDLE_GEMS__LONGEROUS__COM="claudette:s00pers3krit"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+For gems with a git source with HTTP(S) URL you can specify credentials like so:
+.
+.IP "" 4
+.
+.nf
+
+bundle config set \-\-global https://github\.com/rubygems/rubygems\.git username:password
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Or you can set the credentials as an environment variable like so:
+.
+.IP "" 4
+.
+.nf
+
+export BUNDLE_GITHUB__COM=username:password
+.
+.fi
+.
+.IP "" 0
+.
+.P
+This is especially useful for private repositories on hosts such as GitHub, where you can use personal OAuth tokens:
+.
+.IP "" 4
+.
+.nf
+
+export BUNDLE_GITHUB__COM=abcd0123generatedtoken:x\-oauth\-basic
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Note that any configured credentials will be redacted by informative commands such as \fBbundle config list\fR or \fBbundle config get\fR, unless you use the \fB\-\-parseable\fR flag\. This is to avoid unintentionally leaking credentials when copy\-pasting bundler output\.
+.
+.P
+Also note that to guarantee a sane mapping between valid environment variable names and valid host names, bundler makes the following transformations:
+.
+.IP "\(bu" 4
+Any \fB\-\fR characters in a host name are mapped to a triple dash (\fB___\fR) in the corresponding environment variable\.
+.
+.IP "\(bu" 4
+Any \fB\.\fR characters in a host name are mapped to a double dash (\fB__\fR) in the corresponding environment variable\.
+.
+.IP "" 0
+.
+.P
+This means that if you have a gem server named \fBmy\.gem\-host\.com\fR, you\'ll need to use the \fBBUNDLE_MY__GEM___HOST__COM\fR variable to configure credentials for it through ENV\.
+.
+.SH "CONFIGURE BUNDLER DIRECTORIES"
+Bundler\'s home, config, cache and plugin directories are able to be configured through environment variables\. The default location for Bundler\'s home directory is \fB~/\.bundle\fR, which all directories inherit from by default\. The following outlines the available environment variables and their default values
+.
+.IP "" 4
+.
+.nf
+
+BUNDLE_USER_HOME : $HOME/\.bundle
+BUNDLE_USER_CACHE : $BUNDLE_USER_HOME/cache
+BUNDLE_USER_CONFIG : $BUNDLE_USER_HOME/config
+BUNDLE_USER_PLUGIN : $BUNDLE_USER_HOME/plugin
+.
+.fi
+.
+.IP "" 0
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-config.1.ronn
@@ -0,0 +1,408 @@
+bundle-config(1) -- Set bundler configuration options
+=====================================================
+
+## SYNOPSIS
+
+`bundle config` list<br>
+`bundle config` [get] NAME<br>
+`bundle config` [set] NAME VALUE<br>
+`bundle config` unset NAME
+
+## DESCRIPTION
+
+This command allows you to interact with Bundler's configuration system.
+
+Bundler loads configuration settings in this order:
+
+1. Local config (`<project_root>/.bundle/config` or `$BUNDLE_APP_CONFIG/config`)
+2. Environmental variables (`ENV`)
+3. Global config (`~/.bundle/config`)
+4. Bundler default config
+
+Executing `bundle config list` with will print a list of all bundler
+configuration for the current bundle, and where that configuration
+was set.
+
+Executing `bundle config get <name>` will print the value of that configuration
+setting, and where it was set.
+
+Executing `bundle config set <name> <value>` defaults to setting `local`
+configuration if executing from within a local application, otherwise it will
+set `global` configuration. See `--local` and `--global` options below.
+
+Executing `bundle config set --local <name> <value>` will set that configuration
+in the directory for the local application. The configuration will be stored in
+`<project_root>/.bundle/config`. If `BUNDLE_APP_CONFIG` is set, the configuration
+will be stored in `$BUNDLE_APP_CONFIG/config`.
+
+Executing `bundle config set --global <name> <value>` will set that
+configuration to the value specified for all bundles executed as the current
+user. The configuration will be stored in `~/.bundle/config`. If <name> already
+is set, <name> will be overridden and user will be warned.
+
+Executing `bundle config unset <name>` will delete the configuration in both
+local and global sources.
+
+Executing `bundle config unset --global <name>` will delete the configuration
+only from the user configuration.
+
+Executing `bundle config unset --local <name>` will delete the configuration
+only from the local application.
+
+Executing bundle with the `BUNDLE_IGNORE_CONFIG` environment variable set will
+cause it to ignore all configuration.
+
+## REMEMBERING OPTIONS
+
+Flags passed to `bundle install` or the Bundler runtime, such as `--path foo` or
+`--without production`, are remembered between commands and saved to your local
+application's configuration (normally, `./.bundle/config`).
+
+However, this will be changed in bundler 3, so it's better not to rely on this
+behavior. If these options must be remembered, it's better to set them using
+`bundle config` (e.g., `bundle config set --local path foo`).
+
+The options that can be configured are:
+
+* `bin`:
+   Creates a directory (defaults to `~/bin`) and place any executables from the
+   gem there. These executables run in Bundler's context. If used, you might add
+   this directory to your environment's `PATH` variable. For instance, if the
+   `rails` gem comes with a `rails` executable, this flag will create a
+   `bin/rails` executable that ensures that all referred dependencies will be
+   resolved using the bundled gems.
+
+* `deployment`:
+   In deployment mode, Bundler will 'roll-out' the bundle for
+   `production` use. Please check carefully if you want to have this option
+   enabled in `development` or `test` environments.
+
+* `only`:
+   A space-separated list of groups to install only gems of the specified groups.
+
+* `path`:
+   The location to install the specified gems to. This defaults to Rubygems'
+   setting. Bundler shares this location with Rubygems, `gem install ...` will
+   have gem installed there, too. Therefore, gems installed without a
+   `--path ...` setting will show up by calling `gem list`. Accordingly, gems
+   installed to other locations will not get listed.
+
+* `without`:
+   A space-separated list of groups referencing gems to skip during installation.
+
+* `with`:
+  A space-separated list of **optional** groups referencing gems to include during installation.
+
+## BUILD OPTIONS
+
+You can use `bundle config` to give Bundler the flags to pass to the gem
+installer every time bundler tries to install a particular gem.
+
+A very common example, the `mysql` gem, requires Snow Leopard users to
+pass configuration flags to `gem install` to specify where to find the
+`mysql_config` executable.
+
+    gem install mysql -- --with-mysql-config=/usr/local/mysql/bin/mysql_config
+
+Since the specific location of that executable can change from machine
+to machine, you can specify these flags on a per-machine basis.
+
+    bundle config set --global build.mysql --with-mysql-config=/usr/local/mysql/bin/mysql_config
+
+After running this command, every time bundler needs to install the
+`mysql` gem, it will pass along the flags you specified.
+
+## CONFIGURATION KEYS
+
+Configuration keys in bundler have two forms: the canonical form and the
+environment variable form.
+
+For instance, passing the `--without` flag to [bundle install(1)](bundle-install.1.html)
+prevents Bundler from installing certain groups specified in the Gemfile(5). Bundler
+persists this value in `app/.bundle/config` so that calls to `Bundler.setup`
+do not try to find gems from the `Gemfile` that you didn't install. Additionally,
+subsequent calls to [bundle install(1)](bundle-install.1.html) remember this setting
+and skip those groups.
+
+The canonical form of this configuration is `"without"`. To convert the canonical
+form to the environment variable form, capitalize it, and prepend `BUNDLE_`. The
+environment variable form of `"without"` is `BUNDLE_WITHOUT`.
+
+Any periods in the configuration keys must be replaced with two underscores when
+setting it via environment variables. The configuration key `local.rack` becomes
+the environment variable `BUNDLE_LOCAL__RACK`.
+
+## LIST OF AVAILABLE KEYS
+
+The following is a list of all configuration keys and their purpose. You can
+learn more about their operation in [bundle install(1)](bundle-install.1.html).
+
+* `allow_deployment_source_credential_changes` (`BUNDLE_ALLOW_DEPLOYMENT_SOURCE_CREDENTIAL_CHANGES`):
+   When in deployment mode, allow changing the credentials to a gem's source.
+   Ex: `https://some.host.com/gems/path/` -> `https://user_name:password@some.host.com/gems/path`
+* `allow_offline_install` (`BUNDLE_ALLOW_OFFLINE_INSTALL`):
+   Allow Bundler to use cached data when installing without network access.
+* `auto_clean_without_path` (`BUNDLE_AUTO_CLEAN_WITHOUT_PATH`):
+   Automatically run `bundle clean` after installing when an explicit `path`
+   has not been set and Bundler is not installing into the system gems.
+* `auto_install` (`BUNDLE_AUTO_INSTALL`):
+   Automatically run `bundle install` when gems are missing.
+* `bin` (`BUNDLE_BIN`):
+   Install executables from gems in the bundle to the specified directory.
+   Defaults to `false`.
+* `cache_all` (`BUNDLE_CACHE_ALL`):
+   Cache all gems, including path and git gems. This needs to be explicitly
+   configured on bundler 1 and bundler 2, but will be the default on bundler 3.
+* `cache_all_platforms` (`BUNDLE_CACHE_ALL_PLATFORMS`):
+   Cache gems for all platforms.
+* `cache_path` (`BUNDLE_CACHE_PATH`):
+   The directory that bundler will place cached gems in when running
+   <code>bundle package</code>, and that bundler will look in when installing gems.
+   Defaults to `vendor/cache`.
+* `clean` (`BUNDLE_CLEAN`):
+   Whether Bundler should run `bundle clean` automatically after
+   `bundle install`.
+* `console` (`BUNDLE_CONSOLE`):
+   The console that `bundle console` starts. Defaults to `irb`.
+* `default_install_uses_path` (`BUNDLE_DEFAULT_INSTALL_USES_PATH`):
+   Whether a `bundle install` without an explicit `--path` argument defaults
+   to installing gems in `.bundle`.
+* `deployment` (`BUNDLE_DEPLOYMENT`):
+   Disallow changes to the `Gemfile`. When the `Gemfile` is changed and the
+   lockfile has not been updated, running Bundler commands will be blocked.
+* `disable_checksum_validation` (`BUNDLE_DISABLE_CHECKSUM_VALIDATION`):
+   Allow installing gems even if they do not match the checksum provided by
+   RubyGems.
+* `disable_exec_load` (`BUNDLE_DISABLE_EXEC_LOAD`):
+   Stop Bundler from using `load` to launch an executable in-process in
+   `bundle exec`.
+* `disable_local_branch_check` (`BUNDLE_DISABLE_LOCAL_BRANCH_CHECK`):
+   Allow Bundler to use a local git override without a branch specified in the
+   Gemfile.
+* `disable_local_revision_check` (`BUNDLE_DISABLE_LOCAL_REVISION_CHECK`):
+   Allow Bundler to use a local git override without checking if the revision
+   present in the lockfile is present in the repository.
+* `disable_shared_gems` (`BUNDLE_DISABLE_SHARED_GEMS`):
+   Stop Bundler from accessing gems installed to RubyGems' normal location.
+* `disable_version_check` (`BUNDLE_DISABLE_VERSION_CHECK`):
+   Stop Bundler from checking if a newer Bundler version is available on
+   rubygems.org.
+* `force_ruby_platform` (`BUNDLE_FORCE_RUBY_PLATFORM`):
+   Ignore the current machine's platform and install only `ruby` platform gems.
+   As a result, gems with native extensions will be compiled from source.
+* `frozen` (`BUNDLE_FROZEN`):
+   Disallow changes to the `Gemfile`. When the `Gemfile` is changed and the
+   lockfile has not been updated, running Bundler commands will be blocked.
+   Defaults to `true` when `--deployment` is used.
+* `gem.github_username` (`BUNDLE_GEM__GITHUB_USERNAME`):
+   Sets a GitHub username or organization to be used in `README` file when you
+   create a new gem via `bundle gem` command. It can be overridden by passing an
+   explicit `--github-username` flag to `bundle gem`.
+* `gem.push_key` (`BUNDLE_GEM__PUSH_KEY`):
+   Sets the `--key` parameter for `gem push` when using the `rake release`
+   command with a private gemstash server.
+* `gemfile` (`BUNDLE_GEMFILE`):
+   The name of the file that bundler should use as the `Gemfile`. This location
+   of this file also sets the root of the project, which is used to resolve
+   relative paths in the `Gemfile`, among other things. By default, bundler
+   will search up from the current working directory until it finds a
+   `Gemfile`.
+* `global_gem_cache` (`BUNDLE_GLOBAL_GEM_CACHE`):
+   Whether Bundler should cache all gems globally, rather than locally to the
+   installing Ruby installation.
+* `ignore_funding_requests` (`BUNDLE_IGNORE_FUNDING_REQUESTS`):
+   When set, no funding requests will be printed.
+* `ignore_messages` (`BUNDLE_IGNORE_MESSAGES`):
+   When set, no post install messages will be printed. To silence a single gem,
+   use dot notation like `ignore_messages.httparty true`.
+* `init_gems_rb` (`BUNDLE_INIT_GEMS_RB`):
+   Generate a `gems.rb` instead of a `Gemfile` when running `bundle init`.
+* `jobs` (`BUNDLE_JOBS`):
+   The number of gems Bundler can install in parallel. Defaults to the number of
+   available processors.
+* `no_install` (`BUNDLE_NO_INSTALL`):
+   Whether `bundle package` should skip installing gems.
+* `no_prune` (`BUNDLE_NO_PRUNE`):
+   Whether Bundler should leave outdated gems unpruned when caching.
+* `only` (`BUNDLE_ONLY`):
+   A space-separated list of groups to install only gems of the specified groups.
+* `path` (`BUNDLE_PATH`):
+   The location on disk where all gems in your bundle will be located regardless
+   of `$GEM_HOME` or `$GEM_PATH` values. Bundle gems not found in this location
+   will be installed by `bundle install`. Defaults to `Gem.dir`. When --deployment
+   is used, defaults to vendor/bundle.
+* `path.system` (`BUNDLE_PATH__SYSTEM`):
+   Whether Bundler will install gems into the default system path (`Gem.dir`).
+* `path_relative_to_cwd` (`BUNDLE_PATH_RELATIVE_TO_CWD`)
+   Makes `--path` relative to the CWD instead of the `Gemfile`.
+* `plugins` (`BUNDLE_PLUGINS`):
+   Enable Bundler's experimental plugin system.
+* `prefer_patch` (BUNDLE_PREFER_PATCH):
+   Prefer updating only to next patch version during updates. Makes `bundle update` calls equivalent to `bundler update --patch`.
+* `print_only_version_number` (`BUNDLE_PRINT_ONLY_VERSION_NUMBER`):
+   Print only version number from `bundler --version`.
+* `redirect` (`BUNDLE_REDIRECT`):
+   The number of redirects allowed for network requests. Defaults to `5`.
+* `retry` (`BUNDLE_RETRY`):
+   The number of times to retry failed network requests. Defaults to `3`.
+* `setup_makes_kernel_gem_public` (`BUNDLE_SETUP_MAKES_KERNEL_GEM_PUBLIC`):
+   Have `Bundler.setup` make the `Kernel#gem` method public, even though
+   RubyGems declares it as private.
+* `shebang` (`BUNDLE_SHEBANG`):
+   The program name that should be invoked for generated binstubs. Defaults to
+   the ruby install name used to generate the binstub.
+* `silence_deprecations` (`BUNDLE_SILENCE_DEPRECATIONS`):
+   Whether Bundler should silence deprecation warnings for behavior that will
+   be changed in the next major version.
+* `silence_root_warning` (`BUNDLE_SILENCE_ROOT_WARNING`):
+   Silence the warning Bundler prints when installing gems as root.
+* `ssl_ca_cert` (`BUNDLE_SSL_CA_CERT`):
+   Path to a designated CA certificate file or folder containing multiple
+   certificates for trusted CAs in PEM format.
+* `ssl_client_cert` (`BUNDLE_SSL_CLIENT_CERT`):
+   Path to a designated file containing a X.509 client certificate
+   and key in PEM format.
+* `ssl_verify_mode` (`BUNDLE_SSL_VERIFY_MODE`):
+   The SSL verification mode Bundler uses when making HTTPS requests.
+   Defaults to verify peer.
+* `suppress_install_using_messages` (`BUNDLE_SUPPRESS_INSTALL_USING_MESSAGES`):
+   Avoid printing `Using ...` messages during installation when the version of
+   a gem has not changed.
+* `system_bindir` (`BUNDLE_SYSTEM_BINDIR`):
+   The location where RubyGems installs binstubs. Defaults to `Gem.bindir`.
+* `timeout` (`BUNDLE_TIMEOUT`):
+   The seconds allowed before timing out for network requests. Defaults to `10`.
+* `update_requires_all_flag` (`BUNDLE_UPDATE_REQUIRES_ALL_FLAG`):
+   Require passing `--all` to `bundle update` when everything should be updated,
+   and disallow passing no options to `bundle update`.
+* `user_agent` (`BUNDLE_USER_AGENT`):
+   The custom user agent fragment Bundler includes in API requests.
+* `with` (`BUNDLE_WITH`):
+   A `:`-separated list of groups whose gems bundler should install.
+* `without` (`BUNDLE_WITHOUT`):
+   A `:`-separated list of groups whose gems bundler should not install.
+
+In general, you should set these settings per-application by using the applicable
+flag to the [bundle install(1)](bundle-install.1.html) or [bundle cache(1)](bundle-cache.1.html) command.
+
+You can set them globally either via environment variables or `bundle config`,
+whichever is preferable for your setup. If you use both, environment variables
+will take preference over global settings.
+
+## LOCAL GIT REPOS
+
+Bundler also allows you to work against a git repository locally
+instead of using the remote version. This can be achieved by setting
+up a local override:
+
+    bundle config set --local local.GEM_NAME /path/to/local/git/repository
+
+For example, in order to use a local Rack repository, a developer could call:
+
+    bundle config set --local local.rack ~/Work/git/rack
+
+Now instead of checking out the remote git repository, the local
+override will be used. Similar to a path source, every time the local
+git repository change, changes will be automatically picked up by
+Bundler. This means a commit in the local git repo will update the
+revision in the `Gemfile.lock` to the local git repo revision. This
+requires the same attention as git submodules. Before pushing to
+the remote, you need to ensure the local override was pushed, otherwise
+you may point to a commit that only exists in your local machine.
+You'll also need to CGI escape your usernames and passwords as well.
+
+Bundler does many checks to ensure a developer won't work with
+invalid references. Particularly, we force a developer to specify
+a branch in the `Gemfile` in order to use this feature. If the branch
+specified in the `Gemfile` and the current branch in the local git
+repository do not match, Bundler will abort. This ensures that
+a developer is always working against the correct branches, and prevents
+accidental locking to a different branch.
+
+Finally, Bundler also ensures that the current revision in the
+`Gemfile.lock` exists in the local git repository. By doing this, Bundler
+forces you to fetch the latest changes in the remotes.
+
+## MIRRORS OF GEM SOURCES
+
+Bundler supports overriding gem sources with mirrors. This allows you to
+configure rubygems.org as the gem source in your Gemfile while still using your
+mirror to fetch gems.
+
+    bundle config set --global mirror.SOURCE_URL MIRROR_URL
+
+For example, to use a mirror of https://rubygems.org hosted at https://example.org:
+
+    bundle config set --global mirror.https://rubygems.org https://example.org
+
+Each mirror also provides a fallback timeout setting. If the mirror does not
+respond within the fallback timeout, Bundler will try to use the original
+server instead of the mirror.
+
+    bundle config set --global mirror.SOURCE_URL.fallback_timeout TIMEOUT
+
+For example, to fall back to rubygems.org after 3 seconds:
+
+    bundle config set --global mirror.https://rubygems.org.fallback_timeout 3
+
+The default fallback timeout is 0.1 seconds, but the setting can currently
+only accept whole seconds (for example, 1, 15, or 30).
+
+## CREDENTIALS FOR GEM SOURCES
+
+Bundler allows you to configure credentials for any gem source, which allows
+you to avoid putting secrets into your Gemfile.
+
+    bundle config set --global SOURCE_HOSTNAME USERNAME:PASSWORD
+
+For example, to save the credentials of user `claudette` for the gem source at
+`gems.longerous.com`, you would run:
+
+    bundle config set --global gems.longerous.com claudette:s00pers3krit
+
+Or you can set the credentials as an environment variable like this:
+
+    export BUNDLE_GEMS__LONGEROUS__COM="claudette:s00pers3krit"
+
+For gems with a git source with HTTP(S) URL you can specify credentials like so:
+
+    bundle config set --global https://github.com/rubygems/rubygems.git username:password
+
+Or you can set the credentials as an environment variable like so:
+
+    export BUNDLE_GITHUB__COM=username:password
+
+This is especially useful for private repositories on hosts such as GitHub,
+where you can use personal OAuth tokens:
+
+    export BUNDLE_GITHUB__COM=abcd0123generatedtoken:x-oauth-basic
+
+Note that any configured credentials will be redacted by informative commands
+such as `bundle config list` or `bundle config get`, unless you use the
+`--parseable` flag. This is to avoid unintentionally leaking credentials when
+copy-pasting bundler output.
+
+Also note that to guarantee a sane mapping between valid environment variable
+names and valid host names, bundler makes the following transformations:
+
+* Any `-` characters in a host name are mapped to a triple dash (`___`) in the
+  corresponding environment variable.
+
+* Any `.` characters in a host name are mapped to a double dash (`__`) in the
+  corresponding environment variable.
+
+This means that if you have a gem server named `my.gem-host.com`, you'll need to
+use the `BUNDLE_MY__GEM___HOST__COM` variable to configure credentials for it
+through ENV.
+
+## CONFIGURE BUNDLER DIRECTORIES
+
+Bundler's home, config, cache and plugin directories are able to be configured
+through environment variables. The default location for Bundler's home directory is
+`~/.bundle`, which all directories inherit from by default. The following
+outlines the available environment variables and their default values
+
+    BUNDLE_USER_HOME : $HOME/.bundle
+    BUNDLE_USER_CACHE : $BUNDLE_USER_HOME/cache
+    BUNDLE_USER_CONFIG : $BUNDLE_USER_HOME/config
+    BUNDLE_USER_PLUGIN : $BUNDLE_USER_HOME/plugin
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-console.1
@@ -0,0 +1,53 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-CONSOLE" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-console\fR \- Deprecated way to open an IRB session with the bundle pre\-loaded
+.
+.SH "SYNOPSIS"
+\fBbundle console\fR [GROUP]
+.
+.SH "DESCRIPTION"
+Starts an interactive Ruby console session in the context of the current bundle\.
+.
+.P
+If no \fBGROUP\fR is specified, all gems in the \fBdefault\fR group in the Gemfile(5) \fIhttps://bundler\.io/man/gemfile\.5\.html\fR are preliminarily loaded\.
+.
+.P
+If \fBGROUP\fR is specified, all gems in the given group in the Gemfile in addition to the gems in \fBdefault\fR group are loaded\. Even if the given group does not exist in the Gemfile, IRB console starts without any warning or error\.
+.
+.P
+The environment variable \fBBUNDLE_CONSOLE\fR or \fBbundle config set console\fR can be used to change the shell from the following:
+.
+.IP "\(bu" 4
+\fBirb\fR (default)
+.
+.IP "\(bu" 4
+\fBpry\fR (https://github\.com/pry/pry)
+.
+.IP "\(bu" 4
+\fBripl\fR (https://github\.com/cldwalker/ripl)
+.
+.IP "" 0
+.
+.P
+\fBbundle console\fR uses irb by default\. An alternative Pry or Ripl can be used with \fBbundle console\fR by adjusting the \fBconsole\fR Bundler setting\. Also make sure that \fBpry\fR or \fBripl\fR is in your Gemfile\.
+.
+.SH "EXAMPLE"
+.
+.nf
+
+$ bundle config set console pry
+$ bundle console
+Resolving dependencies\.\.\.
+[1] pry(main)>
+.
+.fi
+.
+.SH "NOTES"
+This command was deprecated in Bundler 2\.1 and will be removed in 3\.0\. Use \fBbin/console\fR script, which can be generated by \fBbundle gem <NAME>\fR\.
+.
+.SH "SEE ALSO"
+Gemfile(5) \fIhttps://bundler\.io/man/gemfile\.5\.html\fR
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-console.1.ronn
@@ -0,0 +1,44 @@
+bundle-console(1) -- Deprecated way to open an IRB session with the bundle pre-loaded
+=====================================================================================
+
+## SYNOPSIS
+
+`bundle console` [GROUP]
+
+## DESCRIPTION
+
+Starts an interactive Ruby console session in the context of the current bundle.
+
+If no `GROUP` is specified, all gems in the `default` group in the [Gemfile(5)](https://bundler.io/man/gemfile.5.html) are
+preliminarily loaded.
+
+If `GROUP` is specified, all gems in the given group in the Gemfile in addition
+to the gems in `default` group are loaded. Even if the given group does not
+exist in the Gemfile, IRB console starts without any warning or error.
+
+The environment variable `BUNDLE_CONSOLE` or `bundle config set console` can be used to change
+the shell from the following:
+
+* `irb` (default)
+* `pry` (https://github.com/pry/pry)
+* `ripl` (https://github.com/cldwalker/ripl)
+
+`bundle console` uses irb by default. An alternative Pry or Ripl can be used with
+`bundle console` by adjusting the `console` Bundler setting. Also make sure that
+`pry` or `ripl` is in your Gemfile.
+
+## EXAMPLE
+
+    $ bundle config set console pry
+    $ bundle console
+    Resolving dependencies...
+    [1] pry(main)>
+
+## NOTES
+
+This command was deprecated in Bundler 2.1 and will be removed in 3.0.
+Use `bin/console` script, which can be generated by `bundle gem <NAME>`.
+
+## SEE ALSO
+
+[Gemfile(5)](https://bundler.io/man/gemfile.5.html)
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-doctor.1
@@ -0,0 +1,44 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-DOCTOR" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-doctor\fR \- Checks the bundle for common problems
+.
+.SH "SYNOPSIS"
+\fBbundle doctor\fR [\-\-quiet] [\-\-gemfile=GEMFILE]
+.
+.SH "DESCRIPTION"
+Checks your Gemfile and gem environment for common problems\. If issues are detected, Bundler prints them and exits status 1\. Otherwise, Bundler prints a success message and exits status 0\.
+.
+.P
+Examples of common problems caught by bundle\-doctor include:
+.
+.IP "\(bu" 4
+Invalid Bundler settings
+.
+.IP "\(bu" 4
+Mismatched Ruby versions
+.
+.IP "\(bu" 4
+Mismatched platforms
+.
+.IP "\(bu" 4
+Uninstalled gems
+.
+.IP "\(bu" 4
+Missing dependencies
+.
+.IP "" 0
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-quiet\fR
+Only output warnings and errors\.
+.
+.TP
+\fB\-\-gemfile=<gemfile>\fR
+The location of the Gemfile(5) which Bundler should use\. This defaults to a Gemfile(5) in the current working directory\. In general, Bundler will assume that the location of the Gemfile(5) is also the project\'s root and will try to find \fBGemfile\.lock\fR and \fBvendor/cache\fR relative to this location\.
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-doctor.1.ronn
@@ -0,0 +1,33 @@
+bundle-doctor(1) -- Checks the bundle for common problems
+=========================================================
+
+## SYNOPSIS
+
+`bundle doctor` [--quiet]
+                [--gemfile=GEMFILE]
+
+## DESCRIPTION
+
+Checks your Gemfile and gem environment for common problems. If issues
+are detected, Bundler prints them and exits status 1. Otherwise,
+Bundler prints a success message and exits status 0.
+
+Examples of common problems caught by bundle-doctor include:
+
+* Invalid Bundler settings
+* Mismatched Ruby versions
+* Mismatched platforms
+* Uninstalled gems
+* Missing dependencies
+
+## OPTIONS
+
+* `--quiet`:
+  Only output warnings and errors.
+
+* `--gemfile=<gemfile>`:
+  The location of the Gemfile(5) which Bundler should use. This defaults
+  to a Gemfile(5) in the current working directory. In general, Bundler
+  will assume that the location of the Gemfile(5) is also the project's
+  root and will try to find `Gemfile.lock` and `vendor/cache` relative
+  to this location.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-exec.1
@@ -0,0 +1,165 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-EXEC" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-exec\fR \- Execute a command in the context of the bundle
+.
+.SH "SYNOPSIS"
+\fBbundle exec\fR [\-\-keep\-file\-descriptors] \fIcommand\fR
+.
+.SH "DESCRIPTION"
+This command executes the command, making all gems specified in the [\fBGemfile(5)\fR][Gemfile(5)] available to \fBrequire\fR in Ruby programs\.
+.
+.P
+Essentially, if you would normally have run something like \fBrspec spec/my_spec\.rb\fR, and you want to use the gems specified in the [\fBGemfile(5)\fR][Gemfile(5)] and installed via bundle install(1) \fIbundle\-install\.1\.html\fR, you should run \fBbundle exec rspec spec/my_spec\.rb\fR\.
+.
+.P
+Note that \fBbundle exec\fR does not require that an executable is available on your shell\'s \fB$PATH\fR\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-keep\-file\-descriptors\fR
+Exec in Ruby 2\.0 began discarding non\-standard file descriptors\. When this flag is passed, exec will revert to the 1\.9 behaviour of passing all file descriptors to the new process\.
+.
+.SH "BUNDLE INSTALL \-\-BINSTUBS"
+If you use the \fB\-\-binstubs\fR flag in bundle install(1) \fIbundle\-install\.1\.html\fR, Bundler will automatically create a directory (which defaults to \fBapp_root/bin\fR) containing all of the executables available from gems in the bundle\.
+.
+.P
+After using \fB\-\-binstubs\fR, \fBbin/rspec spec/my_spec\.rb\fR is identical to \fBbundle exec rspec spec/my_spec\.rb\fR\.
+.
+.SH "ENVIRONMENT MODIFICATIONS"
+\fBbundle exec\fR makes a number of changes to the shell environment, then executes the command you specify in full\.
+.
+.IP "\(bu" 4
+make sure that it\'s still possible to shell out to \fBbundle\fR from inside a command invoked by \fBbundle exec\fR (using \fB$BUNDLE_BIN_PATH\fR)
+.
+.IP "\(bu" 4
+put the directory containing executables (like \fBrails\fR, \fBrspec\fR, \fBrackup\fR) for your bundle on \fB$PATH\fR
+.
+.IP "\(bu" 4
+make sure that if bundler is invoked in the subshell, it uses the same \fBGemfile\fR (by setting \fBBUNDLE_GEMFILE\fR)
+.
+.IP "\(bu" 4
+add \fB\-rbundler/setup\fR to \fB$RUBYOPT\fR, which makes sure that Ruby programs invoked in the subshell can see the gems in the bundle
+.
+.IP "" 0
+.
+.P
+It also modifies Rubygems:
+.
+.IP "\(bu" 4
+disallow loading additional gems not in the bundle
+.
+.IP "\(bu" 4
+modify the \fBgem\fR method to be a no\-op if a gem matching the requirements is in the bundle, and to raise a \fBGem::LoadError\fR if it\'s not
+.
+.IP "\(bu" 4
+Define \fBGem\.refresh\fR to be a no\-op, since the source index is always frozen when using bundler, and to prevent gems from the system leaking into the environment
+.
+.IP "\(bu" 4
+Override \fBGem\.bin_path\fR to use the gems in the bundle, making system executables work
+.
+.IP "\(bu" 4
+Add all gems in the bundle into Gem\.loaded_specs
+.
+.IP "" 0
+.
+.P
+Finally, \fBbundle exec\fR also implicitly modifies \fBGemfile\.lock\fR if the lockfile and the Gemfile do not match\. Bundler needs the Gemfile to determine things such as a gem\'s groups, \fBautorequire\fR, and platforms, etc\., and that information isn\'t stored in the lockfile\. The Gemfile and lockfile must be synced in order to \fBbundle exec\fR successfully, so \fBbundle exec\fR updates the lockfile beforehand\.
+.
+.SS "Loading"
+By default, when attempting to \fBbundle exec\fR to a file with a ruby shebang, Bundler will \fBKernel\.load\fR that file instead of using \fBKernel\.exec\fR\. For the vast majority of cases, this is a performance improvement\. In a rare few cases, this could cause some subtle side\-effects (such as dependence on the exact contents of \fB$0\fR or \fB__FILE__\fR) and the optimization can be disabled by enabling the \fBdisable_exec_load\fR setting\.
+.
+.SS "Shelling out"
+Any Ruby code that opens a subshell (like \fBsystem\fR, backticks, or \fB%x{}\fR) will automatically use the current Bundler environment\. If you need to shell out to a Ruby command that is not part of your current bundle, use the \fBwith_clean_env\fR method with a block\. Any subshells created inside the block will be given the environment present before Bundler was activated\. For example, Homebrew commands run Ruby, but don\'t work inside a bundle:
+.
+.IP "" 4
+.
+.nf
+
+Bundler\.with_clean_env do
+  `brew install wget`
+end
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Using \fBwith_clean_env\fR is also necessary if you are shelling out to a different bundle\. Any Bundler commands run in a subshell will inherit the current Gemfile, so commands that need to run in the context of a different bundle also need to use \fBwith_clean_env\fR\.
+.
+.IP "" 4
+.
+.nf
+
+Bundler\.with_clean_env do
+  Dir\.chdir "/other/bundler/project" do
+    `bundle exec \./script`
+  end
+end
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Bundler provides convenience helpers that wrap \fBsystem\fR and \fBexec\fR, and they can be used like this:
+.
+.IP "" 4
+.
+.nf
+
+Bundler\.clean_system(\'brew install wget\')
+Bundler\.clean_exec(\'brew install wget\')
+.
+.fi
+.
+.IP "" 0
+.
+.SH "RUBYGEMS PLUGINS"
+At present, the Rubygems plugin system requires all files named \fBrubygems_plugin\.rb\fR on the load path of \fIany\fR installed gem when any Ruby code requires \fBrubygems\.rb\fR\. This includes executables installed into the system, like \fBrails\fR, \fBrackup\fR, and \fBrspec\fR\.
+.
+.P
+Since Rubygems plugins can contain arbitrary Ruby code, they commonly end up activating themselves or their dependencies\.
+.
+.P
+For instance, the \fBgemcutter 0\.5\fR gem depended on \fBjson_pure\fR\. If you had that version of gemcutter installed (even if you \fIalso\fR had a newer version without this problem), Rubygems would activate \fBgemcutter 0\.5\fR and \fBjson_pure <latest>\fR\.
+.
+.P
+If your Gemfile(5) also contained \fBjson_pure\fR (or a gem with a dependency on \fBjson_pure\fR), the latest version on your system might conflict with the version in your Gemfile(5), or the snapshot version in your \fBGemfile\.lock\fR\.
+.
+.P
+If this happens, bundler will say:
+.
+.IP "" 4
+.
+.nf
+
+You have already activated json_pure 1\.4\.6 but your Gemfile
+requires json_pure 1\.4\.3\. Consider using bundle exec\.
+.
+.fi
+.
+.IP "" 0
+.
+.P
+In this situation, you almost certainly want to remove the underlying gem with the problematic gem plugin\. In general, the authors of these plugins (in this case, the \fBgemcutter\fR gem) have released newer versions that are more careful in their plugins\.
+.
+.P
+You can find a list of all the gems containing gem plugins by running
+.
+.IP "" 4
+.
+.nf
+
+ruby \-e "puts Gem\.find_files(\'rubygems_plugin\.rb\')"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+At the very least, you should remove all but the newest version of each gem plugin, and also remove all gem plugins that you aren\'t using (\fBgem uninstall gem_name\fR)\.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-exec.1.ronn
@@ -0,0 +1,152 @@
+bundle-exec(1) -- Execute a command in the context of the bundle
+================================================================
+
+## SYNOPSIS
+
+`bundle exec` [--keep-file-descriptors] <command>
+
+## DESCRIPTION
+
+This command executes the command, making all gems specified in the
+[`Gemfile(5)`][Gemfile(5)] available to `require` in Ruby programs.
+
+Essentially, if you would normally have run something like
+`rspec spec/my_spec.rb`, and you want to use the gems specified
+in the [`Gemfile(5)`][Gemfile(5)] and installed via [bundle install(1)](bundle-install.1.html), you
+should run `bundle exec rspec spec/my_spec.rb`.
+
+Note that `bundle exec` does not require that an executable is
+available on your shell's `$PATH`.
+
+## OPTIONS
+
+* `--keep-file-descriptors`:
+  Exec in Ruby 2.0 began discarding non-standard file descriptors. When this
+  flag is passed, exec will revert to the 1.9 behaviour of passing all file
+  descriptors to the new process.
+
+## BUNDLE INSTALL --BINSTUBS
+
+If you use the `--binstubs` flag in [bundle install(1)](bundle-install.1.html), Bundler will
+automatically create a directory (which defaults to `app_root/bin`)
+containing all of the executables available from gems in the bundle.
+
+After using `--binstubs`, `bin/rspec spec/my_spec.rb` is identical
+to `bundle exec rspec spec/my_spec.rb`.
+
+## ENVIRONMENT MODIFICATIONS
+
+`bundle exec` makes a number of changes to the shell environment,
+then executes the command you specify in full.
+
+* make sure that it's still possible to shell out to `bundle`
+  from inside a command invoked by `bundle exec` (using
+  `$BUNDLE_BIN_PATH`)
+* put the directory containing executables (like `rails`, `rspec`,
+  `rackup`) for your bundle on `$PATH`
+* make sure that if bundler is invoked in the subshell, it uses
+  the same `Gemfile` (by setting `BUNDLE_GEMFILE`)
+* add `-rbundler/setup` to `$RUBYOPT`, which makes sure that
+  Ruby programs invoked in the subshell can see the gems in
+  the bundle
+
+It also modifies Rubygems:
+
+* disallow loading additional gems not in the bundle
+* modify the `gem` method to be a no-op if a gem matching
+  the requirements is in the bundle, and to raise a
+  `Gem::LoadError` if it's not
+* Define `Gem.refresh` to be a no-op, since the source
+  index is always frozen when using bundler, and to
+  prevent gems from the system leaking into the environment
+* Override `Gem.bin_path` to use the gems in the bundle,
+  making system executables work
+* Add all gems in the bundle into Gem.loaded_specs
+
+Finally, `bundle exec` also implicitly modifies `Gemfile.lock` if the lockfile
+and the Gemfile do not match. Bundler needs the Gemfile to determine things
+such as a gem's groups, `autorequire`, and platforms, etc., and that
+information isn't stored in the lockfile. The Gemfile and lockfile must be
+synced in order to `bundle exec` successfully, so `bundle exec`
+updates the lockfile beforehand.
+
+### Loading
+
+By default, when attempting to `bundle exec` to a file with a ruby shebang,
+Bundler will `Kernel.load` that file instead of using `Kernel.exec`. For the
+vast majority of cases, this is a performance improvement. In a rare few cases,
+this could cause some subtle side-effects (such as dependence on the exact
+contents of `$0` or `__FILE__`) and the optimization can be disabled by enabling
+the `disable_exec_load` setting.
+
+### Shelling out
+
+Any Ruby code that opens a subshell (like `system`, backticks, or `%x{}`) will
+automatically use the current Bundler environment. If you need to shell out to
+a Ruby command that is not part of your current bundle, use the
+`with_clean_env` method with a block. Any subshells created inside the block
+will be given the environment present before Bundler was activated. For
+example, Homebrew commands run Ruby, but don't work inside a bundle:
+
+    Bundler.with_clean_env do
+      `brew install wget`
+    end
+
+Using `with_clean_env` is also necessary if you are shelling out to a different
+bundle. Any Bundler commands run in a subshell will inherit the current
+Gemfile, so commands that need to run in the context of a different bundle also
+need to use `with_clean_env`.
+
+    Bundler.with_clean_env do
+      Dir.chdir "/other/bundler/project" do
+        `bundle exec ./script`
+      end
+    end
+
+Bundler provides convenience helpers that wrap `system` and `exec`, and they
+can be used like this:
+
+    Bundler.clean_system('brew install wget')
+    Bundler.clean_exec('brew install wget')
+
+
+## RUBYGEMS PLUGINS
+
+At present, the Rubygems plugin system requires all files
+named `rubygems_plugin.rb` on the load path of _any_ installed
+gem when any Ruby code requires `rubygems.rb`. This includes
+executables installed into the system, like `rails`, `rackup`,
+and `rspec`.
+
+Since Rubygems plugins can contain arbitrary Ruby code, they
+commonly end up activating themselves or their dependencies.
+
+For instance, the `gemcutter 0.5` gem depended on `json_pure`.
+If you had that version of gemcutter installed (even if
+you _also_ had a newer version without this problem), Rubygems
+would activate `gemcutter 0.5` and `json_pure <latest>`.
+
+If your Gemfile(5) also contained `json_pure` (or a gem
+with a dependency on `json_pure`), the latest version on
+your system might conflict with the version in your
+Gemfile(5), or the snapshot version in your `Gemfile.lock`.
+
+If this happens, bundler will say:
+
+    You have already activated json_pure 1.4.6 but your Gemfile
+    requires json_pure 1.4.3. Consider using bundle exec.
+
+In this situation, you almost certainly want to remove the
+underlying gem with the problematic gem plugin. In general,
+the authors of these plugins (in this case, the `gemcutter`
+gem) have released newer versions that are more careful in
+their plugins.
+
+You can find a list of all the gems containing gem plugins
+by running
+
+    ruby -e "puts Gem.find_files('rubygems_plugin.rb')"
+
+At the very least, you should remove all but the newest
+version of each gem plugin, and also remove all gem plugins
+that you aren't using (`gem uninstall gem_name`).
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-gem.1
@@ -0,0 +1,115 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-GEM" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-gem\fR \- Generate a project skeleton for creating a rubygem
+.
+.SH "SYNOPSIS"
+\fBbundle gem\fR \fIGEM_NAME\fR \fIOPTIONS\fR
+.
+.SH "DESCRIPTION"
+Generates a directory named \fBGEM_NAME\fR with a \fBRakefile\fR, \fBGEM_NAME\.gemspec\fR, and other supporting files and directories that can be used to develop a rubygem with that name\.
+.
+.P
+Run \fBrake \-T\fR in the resulting project for a list of Rake tasks that can be used to test and publish the gem to rubygems\.org\.
+.
+.P
+The generated project skeleton can be customized with OPTIONS, as explained below\. Note that these options can also be specified via Bundler\'s global configuration file using the following names:
+.
+.IP "\(bu" 4
+\fBgem\.coc\fR
+.
+.IP "\(bu" 4
+\fBgem\.mit\fR
+.
+.IP "\(bu" 4
+\fBgem\.test\fR
+.
+.IP "" 0
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-exe\fR or \fB\-b\fR or \fB\-\-bin\fR
+Specify that Bundler should create a binary executable (as \fBexe/GEM_NAME\fR) in the generated rubygem project\. This binary will also be added to the \fBGEM_NAME\.gemspec\fR manifest\. This behavior is disabled by default\.
+.
+.TP
+\fB\-\-no\-exe\fR
+Do not create a binary (overrides \fB\-\-exe\fR specified in the global config)\.
+.
+.TP
+\fB\-\-coc\fR
+Add a \fBCODE_OF_CONDUCT\.md\fR file to the root of the generated project\. If this option is unspecified, an interactive prompt will be displayed and the answer will be saved in Bundler\'s global config for future \fBbundle gem\fR use\.
+.
+.TP
+\fB\-\-no\-coc\fR
+Do not create a \fBCODE_OF_CONDUCT\.md\fR (overrides \fB\-\-coc\fR specified in the global config)\.
+.
+.TP
+\fB\-\-ext\fR
+Add boilerplate for C extension code to the generated project\. This behavior is disabled by default\.
+.
+.TP
+\fB\-\-no\-ext\fR
+Do not add C extension code (overrides \fB\-\-ext\fR specified in the global config)\.
+.
+.TP
+\fB\-\-mit\fR
+Add an MIT license to a \fBLICENSE\.txt\fR file in the root of the generated project\. Your name from the global git config is used for the copyright statement\. If this option is unspecified, an interactive prompt will be displayed and the answer will be saved in Bundler\'s global config for future \fBbundle gem\fR use\.
+.
+.TP
+\fB\-\-no\-mit\fR
+Do not create a \fBLICENSE\.txt\fR (overrides \fB\-\-mit\fR specified in the global config)\.
+.
+.TP
+\fB\-t\fR, \fB\-\-test=minitest\fR, \fB\-\-test=rspec\fR, \fB\-\-test=test\-unit\fR
+Specify the test framework that Bundler should use when generating the project\. Acceptable values are \fBminitest\fR, \fBrspec\fR and \fBtest\-unit\fR\. The \fBGEM_NAME\.gemspec\fR will be configured and a skeleton test/spec directory will be created based on this option\. Given no option is specified:
+.
+.IP
+When Bundler is configured to generate tests, this defaults to Bundler\'s global config setting \fBgem\.test\fR\.
+.
+.IP
+When Bundler is configured to not generate tests, an interactive prompt will be displayed and the answer will be used for the current rubygem project\.
+.
+.IP
+When Bundler is unconfigured, an interactive prompt will be displayed and the answer will be saved in Bundler\'s global config for future \fBbundle gem\fR use\.
+.
+.TP
+\fB\-\-ci\fR, \fB\-\-ci=github\fR, \fB\-\-ci=travis\fR, \fB\-\-ci=gitlab\fR, \fB\-\-ci=circle\fR
+Specify the continuous integration service that Bundler should use when generating the project\. Acceptable values are \fBgithub\fR, \fBtravis\fR, \fBgitlab\fR and \fBcircle\fR\. A configuration file will be generated in the project directory\. Given no option is specified:
+.
+.IP
+When Bundler is configured to generate CI files, this defaults to Bundler\'s global config setting \fBgem\.ci\fR\.
+.
+.IP
+When Bundler is configured to not generate CI files, an interactive prompt will be displayed and the answer will be used for the current rubygem project\.
+.
+.IP
+When Bundler is unconfigured, an interactive prompt will be displayed and the answer will be saved in Bundler\'s global config for future \fBbundle gem\fR use\.
+.
+.TP
+\fB\-\-linter\fR, \fB\-\-linter=rubocop\fR, \fB\-\-linter=standard\fR
+Specify the linter and code formatter that Bundler should add to the project\'s development dependencies\. Acceptable values are \fBrubocop\fR and \fBstandard\fR\. A configuration file will be generated in the project directory\. Given no option is specified:
+.
+.IP
+When Bundler is configured to add a linter, this defaults to Bundler\'s global config setting \fBgem\.linter\fR\.
+.
+.IP
+When Bundler is configured not to add a linter, an interactive prompt will be displayed and the answer will be used for the current rubygem project\.
+.
+.IP
+When Bundler is unconfigured, an interactive prompt will be displayed and the answer will be saved in Bundler\'s global config for future \fBbundle gem\fR use\.
+.
+.TP
+\fB\-e\fR, \fB\-\-edit[=EDITOR]\fR
+Open the resulting GEM_NAME\.gemspec in EDITOR, or the default editor if not specified\. The default is \fB$BUNDLER_EDITOR\fR, \fB$VISUAL\fR, or \fB$EDITOR\fR\.
+.
+.SH "SEE ALSO"
+.
+.IP "\(bu" 4
+bundle config(1) \fIbundle\-config\.1\.html\fR
+.
+.IP "" 0
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-gem.1.ronn
@@ -0,0 +1,117 @@
+bundle-gem(1) -- Generate a project skeleton for creating a rubygem
+====================================================================
+
+## SYNOPSIS
+
+`bundle gem` <GEM_NAME> [OPTIONS]
+
+## DESCRIPTION
+
+Generates a directory named `GEM_NAME` with a `Rakefile`, `GEM_NAME.gemspec`,
+and other supporting files and directories that can be used to develop a
+rubygem with that name.
+
+Run `rake -T` in the resulting project for a list of Rake tasks that can be used
+to test and publish the gem to rubygems.org.
+
+The generated project skeleton can be customized with OPTIONS, as explained
+below. Note that these options can also be specified via Bundler's global
+configuration file using the following names:
+
+* `gem.coc`
+* `gem.mit`
+* `gem.test`
+
+## OPTIONS
+
+* `--exe` or `-b` or `--bin`:
+  Specify that Bundler should create a binary executable (as `exe/GEM_NAME`)
+  in the generated rubygem project. This binary will also be added to the
+  `GEM_NAME.gemspec` manifest. This behavior is disabled by default.
+
+* `--no-exe`:
+  Do not create a binary (overrides `--exe` specified in the global config).
+
+* `--coc`:
+  Add a `CODE_OF_CONDUCT.md` file to the root of the generated project. If
+  this option is unspecified, an interactive prompt will be displayed and the
+  answer will be saved in Bundler's global config for future `bundle gem` use.
+
+* `--no-coc`:
+  Do not create a `CODE_OF_CONDUCT.md` (overrides `--coc` specified in the
+  global config).
+
+* `--ext`:
+  Add boilerplate for C extension code to the generated project. This behavior
+  is disabled by default.
+
+* `--no-ext`:
+  Do not add C extension code (overrides `--ext` specified in the global
+  config).
+
+* `--mit`:
+  Add an MIT license to a `LICENSE.txt` file in the root of the generated
+  project. Your name from the global git config is used for the copyright
+  statement. If this option is unspecified, an interactive prompt will be
+  displayed and the answer will be saved in Bundler's global config for future
+  `bundle gem` use.
+
+* `--no-mit`:
+  Do not create a `LICENSE.txt` (overrides `--mit` specified in the global
+  config).
+
+* `-t`, `--test=minitest`, `--test=rspec`, `--test=test-unit`:
+  Specify the test framework that Bundler should use when generating the
+  project. Acceptable values are `minitest`, `rspec` and `test-unit`. The
+  `GEM_NAME.gemspec` will be configured and a skeleton test/spec directory will
+  be created based on this option. Given no option is specified:
+
+  When Bundler is configured to generate tests, this defaults to Bundler's
+  global config setting `gem.test`.
+
+  When Bundler is configured to not generate tests, an interactive prompt will
+  be displayed and the answer will be used for the current rubygem project.
+
+  When Bundler is unconfigured, an interactive prompt will be displayed and
+  the answer will be saved in Bundler's global config for future `bundle gem`
+  use.
+
+* `--ci`, `--ci=github`, `--ci=travis`, `--ci=gitlab`, `--ci=circle`:
+  Specify the continuous integration service that Bundler should use when
+  generating the project. Acceptable values are `github`, `travis`, `gitlab`
+  and `circle`. A configuration file will be generated in the project directory.
+  Given no option is specified:
+
+  When Bundler is configured to generate CI files, this defaults to Bundler's
+  global config setting `gem.ci`.
+
+  When Bundler is configured to not generate CI files, an interactive prompt
+  will be displayed and the answer will be used for the current rubygem project.
+
+  When Bundler is unconfigured, an interactive prompt will be displayed and
+  the answer will be saved in Bundler's global config for future `bundle gem`
+  use.
+
+* `--linter`, `--linter=rubocop`, `--linter=standard`:
+  Specify the linter and code formatter that Bundler should add to the
+  project's development dependencies. Acceptable values are `rubocop` and
+  `standard`. A configuration file will be generated in the project directory.
+  Given no option is specified:
+
+  When Bundler is configured to add a linter, this defaults to Bundler's
+  global config setting `gem.linter`.
+
+  When Bundler is configured not to add a linter, an interactive prompt
+  will be displayed and the answer will be used for the current rubygem project.
+
+  When Bundler is unconfigured, an interactive prompt will be displayed and
+  the answer will be saved in Bundler's global config for future `bundle gem`
+  use.
+
+* `-e`, `--edit[=EDITOR]`:
+  Open the resulting GEM_NAME.gemspec in EDITOR, or the default editor if not
+  specified. The default is `$BUNDLER_EDITOR`, `$VISUAL`, or `$EDITOR`.
+
+## SEE ALSO
+
+* [bundle config(1)](bundle-config.1.html)
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-help.1
@@ -0,0 +1,13 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-HELP" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-help\fR \- Displays detailed help for each subcommand
+.
+.SH "SYNOPSIS"
+\fBbundle help\fR [COMMAND]
+.
+.SH "DESCRIPTION"
+Displays detailed help for the given subcommand\. You can specify a single \fBCOMMAND\fR at the same time\. When \fBCOMMAND\fR is omitted, help for \fBhelp\fR command will be displayed\.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-help.1.ronn
@@ -0,0 +1,12 @@
+bundle-help(1) -- Displays detailed help for each subcommand
+============================================================
+
+## SYNOPSIS
+
+`bundle help` [COMMAND]
+
+## DESCRIPTION
+
+Displays detailed help for the given subcommand.
+You can specify a single `COMMAND` at the same time.
+When `COMMAND` is omitted, help for `help` command will be displayed.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-info.1
@@ -0,0 +1,20 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-INFO" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-info\fR \- Show information for the given gem in your bundle
+.
+.SH "SYNOPSIS"
+\fBbundle info\fR [GEM] [\-\-path]
+.
+.SH "DESCRIPTION"
+Print the basic information about the provided GEM such as homepage, version, path and summary\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-path\fR
+Print the path of the given gem
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-info.1.ronn
@@ -0,0 +1,17 @@
+bundle-info(1) -- Show information for the given gem in your bundle
+=========================================================================
+
+## SYNOPSIS
+
+`bundle info` [GEM]
+              [--path]
+
+## DESCRIPTION
+
+Print the basic information about the provided GEM such as homepage, version,
+path and summary.
+
+## OPTIONS
+
+* `--path`:
+Print the path of the given gem
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-init.1
@@ -0,0 +1,25 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-INIT" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-init\fR \- Generates a Gemfile into the current working directory
+.
+.SH "SYNOPSIS"
+\fBbundle init\fR [\-\-gemspec=FILE]
+.
+.SH "DESCRIPTION"
+Init generates a default [\fBGemfile(5)\fR][Gemfile(5)] in the current working directory\. When adding a [\fBGemfile(5)\fR][Gemfile(5)] to a gem with a gemspec, the \fB\-\-gemspec\fR option will automatically add each dependency listed in the gemspec file to the newly created [\fBGemfile(5)\fR][Gemfile(5)]\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-gemspec\fR
+Use the specified \.gemspec to create the [\fBGemfile(5)\fR][Gemfile(5)]
+.
+.SH "FILES"
+Included in the default [\fBGemfile(5)\fR][Gemfile(5)] generated is the line \fB# frozen_string_literal: true\fR\. This is a magic comment supported for the first time in Ruby 2\.3\. The presence of this line results in all string literals in the file being implicitly frozen\.
+.
+.SH "SEE ALSO"
+Gemfile(5) \fIhttps://bundler\.io/man/gemfile\.5\.html\fR
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-init.1.ronn
@@ -0,0 +1,29 @@
+bundle-init(1) -- Generates a Gemfile into the current working directory
+========================================================================
+
+## SYNOPSIS
+
+`bundle init` [--gemspec=FILE]
+
+## DESCRIPTION
+
+Init generates a default [`Gemfile(5)`][Gemfile(5)] in the current working directory. When
+adding a [`Gemfile(5)`][Gemfile(5)] to a gem with a gemspec, the `--gemspec` option will
+automatically add each dependency listed in the gemspec file to the newly
+created [`Gemfile(5)`][Gemfile(5)].
+
+## OPTIONS
+
+* `--gemspec`:
+  Use the specified .gemspec to create the [`Gemfile(5)`][Gemfile(5)]
+
+## FILES
+
+Included in the default [`Gemfile(5)`][Gemfile(5)]
+generated is the line `# frozen_string_literal: true`. This is a magic comment
+supported for the first time in Ruby 2.3. The presence of this line
+results in all string literals in the file being implicitly frozen.
+
+## SEE ALSO
+
+[Gemfile(5)](https://bundler.io/man/gemfile.5.html)
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-inject.1
@@ -0,0 +1,36 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-INJECT" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-inject\fR \- Add named gem(s) with version requirements to Gemfile
+.
+.SH "SYNOPSIS"
+\fBbundle inject\fR [GEM] [VERSION]
+.
+.SH "DESCRIPTION"
+Adds the named gem(s) with their version requirements to the resolved [\fBGemfile(5)\fR][Gemfile(5)]\.
+.
+.P
+This command will add the gem to both your [\fBGemfile(5)\fR][Gemfile(5)] and Gemfile\.lock if it isn\'t listed yet\.
+.
+.P
+Example:
+.
+.IP "" 4
+.
+.nf
+
+bundle install
+bundle inject \'rack\' \'> 0\'
+.
+.fi
+.
+.IP "" 0
+.
+.P
+This will inject the \'rack\' gem with a version greater than 0 in your [\fBGemfile(5)\fR][Gemfile(5)] and Gemfile\.lock\.
+.
+.P
+The \fBbundle inject\fR command was deprecated in Bundler 2\.1 and will be removed in Bundler 3\.0\.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-inject.1.ronn
@@ -0,0 +1,24 @@
+bundle-inject(1) -- Add named gem(s) with version requirements to Gemfile
+=========================================================================
+
+## SYNOPSIS
+
+`bundle inject` [GEM] [VERSION]
+
+## DESCRIPTION
+
+Adds the named gem(s) with their version requirements to the resolved
+[`Gemfile(5)`][Gemfile(5)].
+
+This command will add the gem to both your [`Gemfile(5)`][Gemfile(5)] and Gemfile.lock if it
+isn't listed yet.
+
+Example:
+
+    bundle install
+    bundle inject 'rack' '> 0'
+
+This will inject the 'rack' gem with a version greater than 0 in your
+[`Gemfile(5)`][Gemfile(5)] and Gemfile.lock.
+
+The `bundle inject` command was deprecated in Bundler 2.1 and will be removed in Bundler 3.0.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-install.1
@@ -0,0 +1,342 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-INSTALL" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-install\fR \- Install the dependencies specified in your Gemfile
+.
+.SH "SYNOPSIS"
+\fBbundle install\fR [\-\-binstubs[=DIRECTORY]] [\-\-clean] [\-\-deployment] [\-\-frozen] [\-\-full\-index] [\-\-gemfile=GEMFILE] [\-\-jobs=NUMBER] [\-\-local] [\-\-no\-cache] [\-\-no\-prune] [\-\-path PATH] [\-\-quiet] [\-\-redownload] [\-\-retry=NUMBER] [\-\-shebang] [\-\-standalone[=GROUP[ GROUP\.\.\.]]] [\-\-system] [\-\-trust\-policy=POLICY] [\-\-with=GROUP[ GROUP\.\.\.]] [\-\-without=GROUP[ GROUP\.\.\.]]
+.
+.SH "DESCRIPTION"
+Install the gems specified in your Gemfile(5)\. If this is the first time you run bundle install (and a \fBGemfile\.lock\fR does not exist), Bundler will fetch all remote sources, resolve dependencies and install all needed gems\.
+.
+.P
+If a \fBGemfile\.lock\fR does exist, and you have not updated your Gemfile(5), Bundler will fetch all remote sources, but use the dependencies specified in the \fBGemfile\.lock\fR instead of resolving dependencies\.
+.
+.P
+If a \fBGemfile\.lock\fR does exist, and you have updated your Gemfile(5), Bundler will use the dependencies in the \fBGemfile\.lock\fR for all gems that you did not update, but will re\-resolve the dependencies of gems that you did update\. You can find more information about this update process below under \fICONSERVATIVE UPDATING\fR\.
+.
+.SH "OPTIONS"
+The \fB\-\-clean\fR, \fB\-\-deployment\fR, \fB\-\-frozen\fR, \fB\-\-no\-prune\fR, \fB\-\-path\fR, \fB\-\-shebang\fR, \fB\-\-system\fR, \fB\-\-without\fR and \fB\-\-with\fR options are deprecated because they only make sense if they are applied to every subsequent \fBbundle install\fR run automatically and that requires \fBbundler\fR to silently remember them\. Since \fBbundler\fR will no longer remember CLI flags in future versions, \fBbundle config\fR (see bundle\-config(1)) should be used to apply them permanently\.
+.
+.TP
+\fB\-\-binstubs[=<directory>]\fR
+Binstubs are scripts that wrap around executables\. Bundler creates a small Ruby file (a binstub) that loads Bundler, runs the command, and puts it in \fBbin/\fR\. This lets you link the binstub inside of an application to the exact gem version the application needs\.
+.
+.IP
+Creates a directory (defaults to \fB~/bin\fR) and places any executables from the gem there\. These executables run in Bundler\'s context\. If used, you might add this directory to your environment\'s \fBPATH\fR variable\. For instance, if the \fBrails\fR gem comes with a \fBrails\fR executable, this flag will create a \fBbin/rails\fR executable that ensures that all referred dependencies will be resolved using the bundled gems\.
+.
+.TP
+\fB\-\-clean\fR
+On finishing the installation Bundler is going to remove any gems not present in the current Gemfile(5)\. Don\'t worry, gems currently in use will not be removed\.
+.
+.IP
+This option is deprecated in favor of the \fBclean\fR setting\.
+.
+.TP
+\fB\-\-deployment\fR
+In \fIdeployment mode\fR, Bundler will \'roll\-out\' the bundle for production or CI use\. Please check carefully if you want to have this option enabled in your development environment\.
+.
+.IP
+This option is deprecated in favor of the \fBdeployment\fR setting\.
+.
+.TP
+\fB\-\-redownload\fR
+Force download every gem, even if the required versions are already available locally\.
+.
+.TP
+\fB\-\-frozen\fR
+Do not allow the Gemfile\.lock to be updated after this install\. Exits non\-zero if there are going to be changes to the Gemfile\.lock\.
+.
+.IP
+This option is deprecated in favor of the \fBfrozen\fR setting\.
+.
+.TP
+\fB\-\-full\-index\fR
+Bundler will not call Rubygems\' API endpoint (default) but download and cache a (currently big) index file of all gems\. Performance can be improved for large bundles that seldom change by enabling this option\.
+.
+.TP
+\fB\-\-gemfile=<gemfile>\fR
+The location of the Gemfile(5) which Bundler should use\. This defaults to a Gemfile(5) in the current working directory\. In general, Bundler will assume that the location of the Gemfile(5) is also the project\'s root and will try to find \fBGemfile\.lock\fR and \fBvendor/cache\fR relative to this location\.
+.
+.TP
+\fB\-\-jobs=[<number>]\fR, \fB\-j[<number>]\fR
+The maximum number of parallel download and install jobs\. The default is the number of available processors\.
+.
+.TP
+\fB\-\-local\fR
+Do not attempt to connect to \fBrubygems\.org\fR\. Instead, Bundler will use the gems already present in Rubygems\' cache or in \fBvendor/cache\fR\. Note that if an appropriate platform\-specific gem exists on \fBrubygems\.org\fR it will not be found\.
+.
+.TP
+\fB\-\-prefer\-local\fR
+Force using locally installed gems, or gems already present in Rubygems\' cache or in \fBvendor/cache\fR, when resolving, even if newer versions are available remotely\. Only attempt to connect to \fBrubygems\.org\fR for gems that are not present locally\.
+.
+.TP
+\fB\-\-no\-cache\fR
+Do not update the cache in \fBvendor/cache\fR with the newly bundled gems\. This does not remove any gems in the cache but keeps the newly bundled gems from being cached during the install\.
+.
+.TP
+\fB\-\-no\-prune\fR
+Don\'t remove stale gems from the cache when the installation finishes\.
+.
+.IP
+This option is deprecated in favor of the \fBno_prune\fR setting\.
+.
+.TP
+\fB\-\-path=<path>\fR
+The location to install the specified gems to\. This defaults to Rubygems\' setting\. Bundler shares this location with Rubygems, \fBgem install \.\.\.\fR will have gem installed there, too\. Therefore, gems installed without a \fB\-\-path \.\.\.\fR setting will show up by calling \fBgem list\fR\. Accordingly, gems installed to other locations will not get listed\.
+.
+.IP
+This option is deprecated in favor of the \fBpath\fR setting\.
+.
+.TP
+\fB\-\-quiet\fR
+Do not print progress information to the standard output\. Instead, Bundler will exit using a status code (\fB$?\fR)\.
+.
+.TP
+\fB\-\-retry=[<number>]\fR
+Retry failed network or git requests for \fInumber\fR times\.
+.
+.TP
+\fB\-\-shebang=<ruby\-executable>\fR
+Uses the specified ruby executable (usually \fBruby\fR) to execute the scripts created with \fB\-\-binstubs\fR\. In addition, if you use \fB\-\-binstubs\fR together with \fB\-\-shebang jruby\fR these executables will be changed to execute \fBjruby\fR instead\.
+.
+.IP
+This option is deprecated in favor of the \fBshebang\fR setting\.
+.
+.TP
+\fB\-\-standalone[=<list>]\fR
+Makes a bundle that can work without depending on Rubygems or Bundler at runtime\. A space separated list of groups to install has to be specified\. Bundler creates a directory named \fBbundle\fR and installs the bundle there\. It also generates a \fBbundle/bundler/setup\.rb\fR file to replace Bundler\'s own setup in the manner required\. Using this option implicitly sets \fBpath\fR, which is a [remembered option][REMEMBERED OPTIONS]\.
+.
+.TP
+\fB\-\-system\fR
+Installs the gems specified in the bundle to the system\'s Rubygems location\. This overrides any previous configuration of \fB\-\-path\fR\.
+.
+.IP
+This option is deprecated in favor of the \fBsystem\fR setting\.
+.
+.TP
+\fB\-\-trust\-policy=[<policy>]\fR
+Apply the Rubygems security policy \fIpolicy\fR, where policy is one of \fBHighSecurity\fR, \fBMediumSecurity\fR, \fBLowSecurity\fR, \fBAlmostNoSecurity\fR, or \fBNoSecurity\fR\. For more details, please see the Rubygems signing documentation linked below in \fISEE ALSO\fR\.
+.
+.TP
+\fB\-\-with=<list>\fR
+A space\-separated list of groups referencing gems to install\. If an optional group is given it is installed\. If a group is given that is in the remembered list of groups given to \-\-without, it is removed from that list\.
+.
+.IP
+This option is deprecated in favor of the \fBwith\fR setting\.
+.
+.TP
+\fB\-\-without=<list>\fR
+A space\-separated list of groups referencing gems to skip during installation\. If a group is given that is in the remembered list of groups given to \-\-with, it is removed from that list\.
+.
+.IP
+This option is deprecated in favor of the \fBwithout\fR setting\.
+.
+.SH "DEPLOYMENT MODE"
+Bundler\'s defaults are optimized for development\. To switch to defaults optimized for deployment and for CI, use the \fB\-\-deployment\fR flag\. Do not activate deployment mode on development machines, as it will cause an error when the Gemfile(5) is modified\.
+.
+.IP "1." 4
+A \fBGemfile\.lock\fR is required\.
+.
+.IP
+To ensure that the same versions of the gems you developed with and tested with are also used in deployments, a \fBGemfile\.lock\fR is required\.
+.
+.IP
+This is mainly to ensure that you remember to check your \fBGemfile\.lock\fR into version control\.
+.
+.IP "2." 4
+The \fBGemfile\.lock\fR must be up to date
+.
+.IP
+In development, you can modify your Gemfile(5) and re\-run \fBbundle install\fR to \fIconservatively update\fR your \fBGemfile\.lock\fR snapshot\.
+.
+.IP
+In deployment, your \fBGemfile\.lock\fR should be up\-to\-date with changes made in your Gemfile(5)\.
+.
+.IP "3." 4
+Gems are installed to \fBvendor/bundle\fR not your default system location
+.
+.IP
+In development, it\'s convenient to share the gems used in your application with other applications and other scripts that run on the system\.
+.
+.IP
+In deployment, isolation is a more important default\. In addition, the user deploying the application may not have permission to install gems to the system, or the web server may not have permission to read them\.
+.
+.IP
+As a result, \fBbundle install \-\-deployment\fR installs gems to the \fBvendor/bundle\fR directory in the application\. This may be overridden using the \fB\-\-path\fR option\.
+.
+.IP "" 0
+.
+.SH "SUDO USAGE"
+By default, Bundler installs gems to the same location as \fBgem install\fR\.
+.
+.P
+In some cases, that location may not be writable by your Unix user\. In that case, Bundler will stage everything in a temporary directory, then ask you for your \fBsudo\fR password in order to copy the gems into their system location\.
+.
+.P
+From your perspective, this is identical to installing the gems directly into the system\.
+.
+.P
+You should never use \fBsudo bundle install\fR\. This is because several other steps in \fBbundle install\fR must be performed as the current user:
+.
+.IP "\(bu" 4
+Updating your \fBGemfile\.lock\fR
+.
+.IP "\(bu" 4
+Updating your \fBvendor/cache\fR, if necessary
+.
+.IP "\(bu" 4
+Checking out private git repositories using your user\'s SSH keys
+.
+.IP "" 0
+.
+.P
+Of these three, the first two could theoretically be performed by \fBchown\fRing the resulting files to \fB$SUDO_USER\fR\. The third, however, can only be performed by invoking the \fBgit\fR command as the current user\. Therefore, git gems are downloaded and installed into \fB~/\.bundle\fR rather than $GEM_HOME or $BUNDLE_PATH\.
+.
+.P
+As a result, you should run \fBbundle install\fR as the current user, and Bundler will ask for your password if it is needed to put the gems into their final location\.
+.
+.SH "INSTALLING GROUPS"
+By default, \fBbundle install\fR will install all gems in all groups in your Gemfile(5), except those declared for a different platform\.
+.
+.P
+However, you can explicitly tell Bundler to skip installing certain groups with the \fB\-\-without\fR option\. This option takes a space\-separated list of groups\.
+.
+.P
+While the \fB\-\-without\fR option will skip \fIinstalling\fR the gems in the specified groups, it will still \fIdownload\fR those gems and use them to resolve the dependencies of every gem in your Gemfile(5)\.
+.
+.P
+This is so that installing a different set of groups on another machine (such as a production server) will not change the gems and versions that you have already developed and tested against\.
+.
+.P
+\fBBundler offers a rock\-solid guarantee that the third\-party code you are running in development and testing is also the third\-party code you are running in production\. You can choose to exclude some of that code in different environments, but you will never be caught flat\-footed by different versions of third\-party code being used in different environments\.\fR
+.
+.P
+For a simple illustration, consider the following Gemfile(5):
+.
+.IP "" 4
+.
+.nf
+
+source \'https://rubygems\.org\'
+
+gem \'sinatra\'
+
+group :production do
+  gem \'rack\-perftools\-profiler\'
+end
+.
+.fi
+.
+.IP "" 0
+.
+.P
+In this case, \fBsinatra\fR depends on any version of Rack (\fB>= 1\.0\fR), while \fBrack\-perftools\-profiler\fR depends on 1\.x (\fB~> 1\.0\fR)\.
+.
+.P
+When you run \fBbundle install \-\-without production\fR in development, we look at the dependencies of \fBrack\-perftools\-profiler\fR as well\. That way, you do not spend all your time developing against Rack 2\.0, using new APIs unavailable in Rack 1\.x, only to have Bundler switch to Rack 1\.2 when the \fBproduction\fR group \fIis\fR used\.
+.
+.P
+This should not cause any problems in practice, because we do not attempt to \fBinstall\fR the gems in the excluded groups, and only evaluate as part of the dependency resolution process\.
+.
+.P
+This also means that you cannot include different versions of the same gem in different groups, because doing so would result in different sets of dependencies used in development and production\. Because of the vagaries of the dependency resolution process, this usually affects more than the gems you list in your Gemfile(5), and can (surprisingly) radically change the gems you are using\.
+.
+.SH "THE GEMFILE\.LOCK"
+When you run \fBbundle install\fR, Bundler will persist the full names and versions of all gems that you used (including dependencies of the gems specified in the Gemfile(5)) into a file called \fBGemfile\.lock\fR\.
+.
+.P
+Bundler uses this file in all subsequent calls to \fBbundle install\fR, which guarantees that you always use the same exact code, even as your application moves across machines\.
+.
+.P
+Because of the way dependency resolution works, even a seemingly small change (for instance, an update to a point\-release of a dependency of a gem in your Gemfile(5)) can result in radically different gems being needed to satisfy all dependencies\.
+.
+.P
+As a result, you \fBSHOULD\fR check your \fBGemfile\.lock\fR into version control, in both applications and gems\. If you do not, every machine that checks out your repository (including your production server) will resolve all dependencies again, which will result in different versions of third\-party code being used if \fBany\fR of the gems in the Gemfile(5) or any of their dependencies have been updated\.
+.
+.P
+When Bundler first shipped, the \fBGemfile\.lock\fR was included in the \fB\.gitignore\fR file included with generated gems\. Over time, however, it became clear that this practice forces the pain of broken dependencies onto new contributors, while leaving existing contributors potentially unaware of the problem\. Since \fBbundle install\fR is usually the first step towards a contribution, the pain of broken dependencies would discourage new contributors from contributing\. As a result, we have revised our guidance for gem authors to now recommend checking in the lock for gems\.
+.
+.SH "CONSERVATIVE UPDATING"
+When you make a change to the Gemfile(5) and then run \fBbundle install\fR, Bundler will update only the gems that you modified\.
+.
+.P
+In other words, if a gem that you \fBdid not modify\fR worked before you called \fBbundle install\fR, it will continue to use the exact same versions of all dependencies as it used before the update\.
+.
+.P
+Let\'s take a look at an example\. Here\'s your original Gemfile(5):
+.
+.IP "" 4
+.
+.nf
+
+source \'https://rubygems\.org\'
+
+gem \'actionpack\', \'2\.3\.8\'
+gem \'activemerchant\'
+.
+.fi
+.
+.IP "" 0
+.
+.P
+In this case, both \fBactionpack\fR and \fBactivemerchant\fR depend on \fBactivesupport\fR\. The \fBactionpack\fR gem depends on \fBactivesupport 2\.3\.8\fR and \fBrack ~> 1\.1\.0\fR, while the \fBactivemerchant\fR gem depends on \fBactivesupport >= 2\.3\.2\fR, \fBbraintree >= 2\.0\.0\fR, and \fBbuilder >= 2\.0\.0\fR\.
+.
+.P
+When the dependencies are first resolved, Bundler will select \fBactivesupport 2\.3\.8\fR, which satisfies the requirements of both gems in your Gemfile(5)\.
+.
+.P
+Next, you modify your Gemfile(5) to:
+.
+.IP "" 4
+.
+.nf
+
+source \'https://rubygems\.org\'
+
+gem \'actionpack\', \'3\.0\.0\.rc\'
+gem \'activemerchant\'
+.
+.fi
+.
+.IP "" 0
+.
+.P
+The \fBactionpack 3\.0\.0\.rc\fR gem has a number of new dependencies, and updates the \fBactivesupport\fR dependency to \fB= 3\.0\.0\.rc\fR and the \fBrack\fR dependency to \fB~> 1\.2\.1\fR\.
+.
+.P
+When you run \fBbundle install\fR, Bundler notices that you changed the \fBactionpack\fR gem, but not the \fBactivemerchant\fR gem\. It evaluates the gems currently being used to satisfy its requirements:
+.
+.TP
+\fBactivesupport 2\.3\.8\fR
+also used to satisfy a dependency in \fBactivemerchant\fR, which is not being updated
+.
+.TP
+\fBrack ~> 1\.1\.0\fR
+not currently being used to satisfy another dependency
+.
+.P
+Because you did not explicitly ask to update \fBactivemerchant\fR, you would not expect it to suddenly stop working after updating \fBactionpack\fR\. However, satisfying the new \fBactivesupport 3\.0\.0\.rc\fR dependency of actionpack requires updating one of its dependencies\.
+.
+.P
+Even though \fBactivemerchant\fR declares a very loose dependency that theoretically matches \fBactivesupport 3\.0\.0\.rc\fR, Bundler treats gems in your Gemfile(5) that have not changed as an atomic unit together with their dependencies\. In this case, the \fBactivemerchant\fR dependency is treated as \fBactivemerchant 1\.7\.1 + activesupport 2\.3\.8\fR, so \fBbundle install\fR will report that it cannot update \fBactionpack\fR\.
+.
+.P
+To explicitly update \fBactionpack\fR, including its dependencies which other gems in the Gemfile(5) still depend on, run \fBbundle update actionpack\fR (see \fBbundle update(1)\fR)\.
+.
+.P
+\fBSummary\fR: In general, after making a change to the Gemfile(5) , you should first try to run \fBbundle install\fR, which will guarantee that no other gem in the Gemfile(5) is impacted by the change\. If that does not work, run bundle update(1) \fIbundle\-update\.1\.html\fR\.
+.
+.SH "SEE ALSO"
+.
+.IP "\(bu" 4
+Gem install docs \fIhttp://guides\.rubygems\.org/rubygems\-basics/#installing\-gems\fR
+.
+.IP "\(bu" 4
+Rubygems signing docs \fIhttp://guides\.rubygems\.org/security/\fR
+.
+.IP "" 0
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-install.1.ronn
@@ -0,0 +1,411 @@
+bundle-install(1) -- Install the dependencies specified in your Gemfile
+=======================================================================
+
+## SYNOPSIS
+
+`bundle install` [--binstubs[=DIRECTORY]]
+                 [--clean]
+                 [--deployment]
+                 [--frozen]
+                 [--full-index]
+                 [--gemfile=GEMFILE]
+                 [--jobs=NUMBER]
+                 [--local]
+                 [--no-cache]
+                 [--no-prune]
+                 [--path PATH]
+                 [--quiet]
+                 [--redownload]
+                 [--retry=NUMBER]
+                 [--shebang]
+                 [--standalone[=GROUP[ GROUP...]]]
+                 [--system]
+                 [--trust-policy=POLICY]
+                 [--with=GROUP[ GROUP...]]
+                 [--without=GROUP[ GROUP...]]
+
+## DESCRIPTION
+
+Install the gems specified in your Gemfile(5). If this is the first
+time you run bundle install (and a `Gemfile.lock` does not exist),
+Bundler will fetch all remote sources, resolve dependencies and
+install all needed gems.
+
+If a `Gemfile.lock` does exist, and you have not updated your Gemfile(5),
+Bundler will fetch all remote sources, but use the dependencies
+specified in the `Gemfile.lock` instead of resolving dependencies.
+
+If a `Gemfile.lock` does exist, and you have updated your Gemfile(5),
+Bundler will use the dependencies in the `Gemfile.lock` for all gems
+that you did not update, but will re-resolve the dependencies of
+gems that you did update. You can find more information about this
+update process below under [CONSERVATIVE UPDATING][].
+
+## OPTIONS
+
+The `--clean`, `--deployment`, `--frozen`, `--no-prune`, `--path`, `--shebang`,
+`--system`, `--without` and `--with` options are deprecated because they only
+make sense if they are applied to every subsequent `bundle install` run
+automatically and that requires `bundler` to silently remember them. Since
+`bundler` will no longer remember CLI flags in future versions, `bundle config`
+(see bundle-config(1)) should be used to apply them permanently.
+
+* `--binstubs[=<directory>]`:
+  Binstubs are scripts that wrap around executables. Bundler creates a small Ruby
+  file (a binstub) that loads Bundler, runs the command, and puts it in `bin/`.
+  This lets you link the binstub inside of an application to the exact gem
+  version the application needs.
+
+  Creates a directory (defaults to `~/bin`) and places any executables from the
+  gem there. These executables run in Bundler's context. If used, you might add
+  this directory to your environment's `PATH` variable. For instance, if the
+  `rails` gem comes with a `rails` executable, this flag will create a
+  `bin/rails` executable that ensures that all referred dependencies will be
+  resolved using the bundled gems.
+
+* `--clean`:
+  On finishing the installation Bundler is going to remove any gems not present
+  in the current Gemfile(5). Don't worry, gems currently in use will not be
+  removed.
+
+  This option is deprecated in favor of the `clean` setting.
+
+* `--deployment`:
+  In [deployment mode][DEPLOYMENT MODE], Bundler will 'roll-out' the bundle for
+  production or CI use. Please check carefully if you want to have this option
+  enabled in your development environment.
+
+  This option is deprecated in favor of the `deployment` setting.
+
+* `--redownload`:
+  Force download every gem, even if the required versions are already available
+  locally.
+
+* `--frozen`:
+  Do not allow the Gemfile.lock to be updated after this install. Exits
+  non-zero if there are going to be changes to the Gemfile.lock.
+
+  This option is deprecated in favor of the `frozen` setting.
+
+* `--full-index`:
+  Bundler will not call Rubygems' API endpoint (default) but download and cache
+  a (currently big) index file of all gems. Performance can be improved for
+  large bundles that seldom change by enabling this option.
+
+* `--gemfile=<gemfile>`:
+  The location of the Gemfile(5) which Bundler should use. This defaults
+  to a Gemfile(5) in the current working directory. In general, Bundler
+  will assume that the location of the Gemfile(5) is also the project's
+  root and will try to find `Gemfile.lock` and `vendor/cache` relative
+  to this location.
+
+* `--jobs=[<number>]`, `-j[<number>]`:
+  The maximum number of parallel download and install jobs. The default is the
+  number of available processors.
+
+* `--local`:
+  Do not attempt to connect to `rubygems.org`. Instead, Bundler will use the
+  gems already present in Rubygems' cache or in `vendor/cache`. Note that if an
+  appropriate platform-specific gem exists on `rubygems.org` it will not be
+  found.
+
+* `--prefer-local`:
+  Force using locally installed gems, or gems already present in Rubygems' cache
+  or in `vendor/cache`, when resolving, even if newer versions are available
+  remotely. Only attempt to connect to `rubygems.org` for gems that are not
+  present locally.
+
+* `--no-cache`:
+  Do not update the cache in `vendor/cache` with the newly bundled gems. This
+  does not remove any gems in the cache but keeps the newly bundled gems from
+  being cached during the install.
+
+* `--no-prune`:
+  Don't remove stale gems from the cache when the installation finishes.
+
+  This option is deprecated in favor of the `no_prune` setting.
+
+* `--path=<path>`:
+  The location to install the specified gems to. This defaults to Rubygems'
+  setting. Bundler shares this location with Rubygems, `gem install ...` will
+  have gem installed there, too. Therefore, gems installed without a
+  `--path ...` setting will show up by calling `gem list`. Accordingly, gems
+  installed to other locations will not get listed.
+
+  This option is deprecated in favor of the `path` setting.
+
+* `--quiet`:
+  Do not print progress information to the standard output. Instead, Bundler
+  will exit using a status code (`$?`).
+
+* `--retry=[<number>]`:
+  Retry failed network or git requests for <number> times.
+
+* `--shebang=<ruby-executable>`:
+  Uses the specified ruby executable (usually `ruby`) to execute the scripts
+  created with `--binstubs`. In addition, if you use `--binstubs` together with
+  `--shebang jruby` these executables will be changed to execute `jruby`
+  instead.
+
+  This option is deprecated in favor of the `shebang` setting.
+
+* `--standalone[=<list>]`:
+  Makes a bundle that can work without depending on Rubygems or Bundler at
+  runtime. A space separated list of groups to install has to be specified.
+  Bundler creates a directory named `bundle` and installs the bundle there. It
+  also generates a `bundle/bundler/setup.rb` file to replace Bundler's own setup
+  in the manner required. Using this option implicitly sets `path`, which is a
+  [remembered option][REMEMBERED OPTIONS].
+
+* `--system`:
+  Installs the gems specified in the bundle to the system's Rubygems location.
+  This overrides any previous configuration of `--path`.
+
+  This option is deprecated in favor of the `system` setting.
+
+* `--trust-policy=[<policy>]`:
+  Apply the Rubygems security policy <policy>, where policy is one of
+  `HighSecurity`, `MediumSecurity`, `LowSecurity`, `AlmostNoSecurity`, or
+  `NoSecurity`. For more details, please see the Rubygems signing documentation
+  linked below in [SEE ALSO][].
+
+* `--with=<list>`:
+  A space-separated list of groups referencing gems to install. If an
+  optional group is given it is installed. If a group is given that is
+  in the remembered list of groups given to --without, it is removed
+  from that list.
+
+  This option is deprecated in favor of the `with` setting.
+
+* `--without=<list>`:
+  A space-separated list of groups referencing gems to skip during installation.
+  If a group is given that is in the remembered list of groups given
+  to --with, it is removed from that list.
+
+  This option is deprecated in favor of the `without` setting.
+
+## DEPLOYMENT MODE
+
+Bundler's defaults are optimized for development. To switch to
+defaults optimized for deployment and for CI, use the `--deployment`
+flag. Do not activate deployment mode on development machines, as it
+will cause an error when the Gemfile(5) is modified.
+
+1. A `Gemfile.lock` is required.
+
+   To ensure that the same versions of the gems you developed with
+   and tested with are also used in deployments, a `Gemfile.lock`
+   is required.
+
+   This is mainly to ensure that you remember to check your
+   `Gemfile.lock` into version control.
+
+2. The `Gemfile.lock` must be up to date
+
+   In development, you can modify your Gemfile(5) and re-run
+   `bundle install` to [conservatively update][CONSERVATIVE UPDATING]
+   your `Gemfile.lock` snapshot.
+
+   In deployment, your `Gemfile.lock` should be up-to-date with
+   changes made in your Gemfile(5).
+
+3. Gems are installed to `vendor/bundle` not your default system location
+
+   In development, it's convenient to share the gems used in your
+   application with other applications and other scripts that run on
+   the system.
+
+   In deployment, isolation is a more important default. In addition,
+   the user deploying the application may not have permission to install
+   gems to the system, or the web server may not have permission to
+   read them.
+
+   As a result, `bundle install --deployment` installs gems to
+   the `vendor/bundle` directory in the application. This may be
+   overridden using the `--path` option.
+
+## SUDO USAGE
+
+By default, Bundler installs gems to the same location as `gem install`.
+
+In some cases, that location may not be writable by your Unix user. In
+that case, Bundler will stage everything in a temporary directory,
+then ask you for your `sudo` password in order to copy the gems into
+their system location.
+
+From your perspective, this is identical to installing the gems
+directly into the system.
+
+You should never use `sudo bundle install`. This is because several
+other steps in `bundle install` must be performed as the current user:
+
+* Updating your `Gemfile.lock`
+* Updating your `vendor/cache`, if necessary
+* Checking out private git repositories using your user's SSH keys
+
+Of these three, the first two could theoretically be performed by
+`chown`ing the resulting files to `$SUDO_USER`. The third, however,
+can only be performed by invoking the `git` command as
+the current user. Therefore, git gems are downloaded and installed
+into `~/.bundle` rather than $GEM_HOME or $BUNDLE_PATH.
+
+As a result, you should run `bundle install` as the current user,
+and Bundler will ask for your password if it is needed to put the
+gems into their final location.
+
+## INSTALLING GROUPS
+
+By default, `bundle install` will install all gems in all groups
+in your Gemfile(5), except those declared for a different platform.
+
+However, you can explicitly tell Bundler to skip installing
+certain groups with the `--without` option. This option takes
+a space-separated list of groups.
+
+While the `--without` option will skip _installing_ the gems in the
+specified groups, it will still _download_ those gems and use them to
+resolve the dependencies of every gem in your Gemfile(5).
+
+This is so that installing a different set of groups on another
+ machine (such as a production server) will not change the
+gems and versions that you have already developed and tested against.
+
+`Bundler offers a rock-solid guarantee that the third-party
+code you are running in development and testing is also the
+third-party code you are running in production. You can choose
+to exclude some of that code in different environments, but you
+will never be caught flat-footed by different versions of
+third-party code being used in different environments.`
+
+For a simple illustration, consider the following Gemfile(5):
+
+    source 'https://rubygems.org'
+
+    gem 'sinatra'
+
+    group :production do
+      gem 'rack-perftools-profiler'
+    end
+
+In this case, `sinatra` depends on any version of Rack (`>= 1.0`), while
+`rack-perftools-profiler` depends on 1.x (`~> 1.0`).
+
+When you run `bundle install --without production` in development, we
+look at the dependencies of `rack-perftools-profiler` as well. That way,
+you do not spend all your time developing against Rack 2.0, using new
+APIs unavailable in Rack 1.x, only to have Bundler switch to Rack 1.2
+when the `production` group _is_ used.
+
+This should not cause any problems in practice, because we do not
+attempt to `install` the gems in the excluded groups, and only evaluate
+as part of the dependency resolution process.
+
+This also means that you cannot include different versions of the same
+gem in different groups, because doing so would result in different
+sets of dependencies used in development and production. Because of
+the vagaries of the dependency resolution process, this usually
+affects more than the gems you list in your Gemfile(5), and can
+(surprisingly) radically change the gems you are using.
+
+## THE GEMFILE.LOCK
+
+When you run `bundle install`, Bundler will persist the full names
+and versions of all gems that you used (including dependencies of
+the gems specified in the Gemfile(5)) into a file called `Gemfile.lock`.
+
+Bundler uses this file in all subsequent calls to `bundle install`,
+which guarantees that you always use the same exact code, even
+as your application moves across machines.
+
+Because of the way dependency resolution works, even a
+seemingly small change (for instance, an update to a point-release
+of a dependency of a gem in your Gemfile(5)) can result in radically
+different gems being needed to satisfy all dependencies.
+
+As a result, you `SHOULD` check your `Gemfile.lock` into version
+control, in both applications and gems. If you do not, every machine that
+checks out your repository (including your production server) will resolve all
+dependencies again, which will result in different versions of
+third-party code being used if `any` of the gems in the Gemfile(5)
+or any of their dependencies have been updated.
+
+When Bundler first shipped, the `Gemfile.lock` was included in the `.gitignore`
+file included with generated gems.  Over time, however, it became clear that
+this practice forces the pain of broken dependencies onto new contributors,
+while leaving existing contributors potentially unaware of the problem. Since
+`bundle install` is usually the first step towards a contribution, the pain of
+broken dependencies would discourage new contributors from contributing. As a
+result, we have revised our guidance for gem authors to now recommend checking
+in the lock for gems.
+
+## CONSERVATIVE UPDATING
+
+When you make a change to the Gemfile(5) and then run `bundle install`,
+Bundler will update only the gems that you modified.
+
+In other words, if a gem that you `did not modify` worked before
+you called `bundle install`, it will continue to use the exact
+same versions of all dependencies as it used before the update.
+
+Let's take a look at an example. Here's your original Gemfile(5):
+
+    source 'https://rubygems.org'
+
+    gem 'actionpack', '2.3.8'
+    gem 'activemerchant'
+
+In this case, both `actionpack` and `activemerchant` depend on
+`activesupport`. The `actionpack` gem depends on `activesupport 2.3.8`
+and `rack ~> 1.1.0`, while the `activemerchant` gem depends on
+`activesupport >= 2.3.2`, `braintree >= 2.0.0`, and `builder >= 2.0.0`.
+
+When the dependencies are first resolved, Bundler will select
+`activesupport 2.3.8`, which satisfies the requirements of both
+gems in your Gemfile(5).
+
+Next, you modify your Gemfile(5) to:
+
+    source 'https://rubygems.org'
+
+    gem 'actionpack', '3.0.0.rc'
+    gem 'activemerchant'
+
+The `actionpack 3.0.0.rc` gem has a number of new dependencies,
+and updates the `activesupport` dependency to `= 3.0.0.rc` and
+the `rack` dependency to `~> 1.2.1`.
+
+When you run `bundle install`, Bundler notices that you changed
+the `actionpack` gem, but not the `activemerchant` gem. It
+evaluates the gems currently being used to satisfy its requirements:
+
+  * `activesupport 2.3.8`:
+    also used to satisfy a dependency in `activemerchant`,
+    which is not being updated
+  * `rack ~> 1.1.0`:
+    not currently being used to satisfy another dependency
+
+Because you did not explicitly ask to update `activemerchant`,
+you would not expect it to suddenly stop working after updating
+`actionpack`. However, satisfying the new `activesupport 3.0.0.rc`
+dependency of actionpack requires updating one of its dependencies.
+
+Even though `activemerchant` declares a very loose dependency
+that theoretically matches `activesupport 3.0.0.rc`, Bundler treats
+gems in your Gemfile(5) that have not changed as an atomic unit
+together with their dependencies. In this case, the `activemerchant`
+dependency is treated as `activemerchant 1.7.1 + activesupport 2.3.8`,
+so `bundle install` will report that it cannot update `actionpack`.
+
+To explicitly update `actionpack`, including its dependencies
+which other gems in the Gemfile(5) still depend on, run
+`bundle update actionpack` (see `bundle update(1)`).
+
+`Summary`: In general, after making a change to the Gemfile(5) , you
+should first try to run `bundle install`, which will guarantee that no
+other gem in the Gemfile(5) is impacted by the change. If that
+does not work, run [bundle update(1)](bundle-update.1.html).
+
+## SEE ALSO
+
+* [Gem install docs](http://guides.rubygems.org/rubygems-basics/#installing-gems)
+* [Rubygems signing docs](http://guides.rubygems.org/security/)
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-list.1
@@ -0,0 +1,50 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-LIST" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-list\fR \- List all the gems in the bundle
+.
+.SH "SYNOPSIS"
+\fBbundle list\fR [\-\-name\-only] [\-\-paths] [\-\-without\-group=GROUP[ GROUP\.\.\.]] [\-\-only\-group=GROUP[ GROUP\.\.\.]]
+.
+.SH "DESCRIPTION"
+Prints a list of all the gems in the bundle including their version\.
+.
+.P
+Example:
+.
+.P
+bundle list \-\-name\-only
+.
+.P
+bundle list \-\-paths
+.
+.P
+bundle list \-\-without\-group test
+.
+.P
+bundle list \-\-only\-group dev
+.
+.P
+bundle list \-\-only\-group dev test \-\-paths
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-name\-only\fR
+Print only the name of each gem\.
+.
+.TP
+\fB\-\-paths\fR
+Print the path to each gem in the bundle\.
+.
+.TP
+\fB\-\-without\-group=<list>\fR
+A space\-separated list of groups of gems to skip during printing\.
+.
+.TP
+\fB\-\-only\-group=<list>\fR
+A space\-separated list of groups of gems to print\.
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-list.1.ronn
@@ -0,0 +1,33 @@
+bundle-list(1) -- List all the gems in the bundle
+=========================================================================
+
+## SYNOPSIS
+
+`bundle list` [--name-only] [--paths] [--without-group=GROUP[ GROUP...]] [--only-group=GROUP[ GROUP...]]
+
+## DESCRIPTION
+
+Prints a list of all the gems in the bundle including their version.
+
+Example:
+
+bundle list --name-only
+
+bundle list --paths
+
+bundle list --without-group test
+
+bundle list --only-group dev
+
+bundle list --only-group dev test --paths
+
+## OPTIONS
+
+* `--name-only`:
+  Print only the name of each gem.
+* `--paths`:
+  Print the path to each gem in the bundle.
+* `--without-group=<list>`:
+  A space-separated list of groups of gems to skip during printing.
+* `--only-group=<list>`:
+  A space-separated list of groups of gems to print.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-lock.1
@@ -0,0 +1,84 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-LOCK" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-lock\fR \- Creates / Updates a lockfile without installing
+.
+.SH "SYNOPSIS"
+\fBbundle lock\fR [\-\-update] [\-\-local] [\-\-print] [\-\-lockfile=PATH] [\-\-full\-index] [\-\-add\-platform] [\-\-remove\-platform] [\-\-patch] [\-\-minor] [\-\-major] [\-\-strict] [\-\-conservative]
+.
+.SH "DESCRIPTION"
+Lock the gems specified in Gemfile\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-update=<*gems>\fR
+Ignores the existing lockfile\. Resolve then updates lockfile\. Taking a list of gems or updating all gems if no list is given\.
+.
+.TP
+\fB\-\-local\fR
+Do not attempt to connect to \fBrubygems\.org\fR\. Instead, Bundler will use the gems already present in Rubygems\' cache or in \fBvendor/cache\fR\. Note that if a appropriate platform\-specific gem exists on \fBrubygems\.org\fR it will not be found\.
+.
+.TP
+\fB\-\-print\fR
+Prints the lockfile to STDOUT instead of writing to the file system\.
+.
+.TP
+\fB\-\-lockfile=<path>\fR
+The path where the lockfile should be written to\.
+.
+.TP
+\fB\-\-full\-index\fR
+Fall back to using the single\-file index of all gems\.
+.
+.TP
+\fB\-\-add\-platform\fR
+Add a new platform to the lockfile, re\-resolving for the addition of that platform\.
+.
+.TP
+\fB\-\-remove\-platform\fR
+Remove a platform from the lockfile\.
+.
+.TP
+\fB\-\-patch\fR
+If updating, prefer updating only to next patch version\.
+.
+.TP
+\fB\-\-minor\fR
+If updating, prefer updating only to next minor version\.
+.
+.TP
+\fB\-\-major\fR
+If updating, prefer updating to next major version (default)\.
+.
+.TP
+\fB\-\-strict\fR
+If updating, do not allow any gem to be updated past latest \-\-patch | \-\-minor | \-\-major\.
+.
+.TP
+\fB\-\-conservative\fR
+If updating, use bundle install conservative update behavior and do not allow shared dependencies to be updated\.
+.
+.SH "UPDATING ALL GEMS"
+If you run \fBbundle lock\fR with \fB\-\-update\fR option without list of gems, bundler will ignore any previously installed gems and resolve all dependencies again based on the latest versions of all gems available in the sources\.
+.
+.SH "UPDATING A LIST OF GEMS"
+Sometimes, you want to update a single gem in the Gemfile(5), and leave the rest of the gems that you specified locked to the versions in the \fBGemfile\.lock\fR\.
+.
+.P
+For instance, you only want to update \fBnokogiri\fR, run \fBbundle lock \-\-update nokogiri\fR\.
+.
+.P
+Bundler will update \fBnokogiri\fR and any of its dependencies, but leave the rest of the gems that you specified locked to the versions in the \fBGemfile\.lock\fR\.
+.
+.SH "SUPPORTING OTHER PLATFORMS"
+If you want your bundle to support platforms other than the one you\'re running locally, you can run \fBbundle lock \-\-add\-platform PLATFORM\fR to add PLATFORM to the lockfile, force bundler to re\-resolve and consider the new platform when picking gems, all without needing to have a machine that matches PLATFORM handy to install those platform\-specific gems on\.
+.
+.P
+For a full explanation of gem platforms, see \fBgem help platform\fR\.
+.
+.SH "PATCH LEVEL OPTIONS"
+See bundle update(1) \fIbundle\-update\.1\.html\fR for details\.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-lock.1.ronn
@@ -0,0 +1,94 @@
+bundle-lock(1) -- Creates / Updates a lockfile without installing
+=================================================================
+
+## SYNOPSIS
+
+`bundle lock` [--update]
+              [--local]
+              [--print]
+              [--lockfile=PATH]
+              [--full-index]
+              [--add-platform]
+              [--remove-platform]
+              [--patch]
+              [--minor]
+              [--major]
+              [--strict]
+              [--conservative]
+
+## DESCRIPTION
+
+Lock the gems specified in Gemfile.
+
+## OPTIONS
+
+* `--update=<*gems>`:
+  Ignores the existing lockfile. Resolve then updates lockfile. Taking a list
+  of gems or updating all gems if no list is given.
+
+* `--local`:
+  Do not attempt to connect to `rubygems.org`. Instead, Bundler will use the
+  gems already present in Rubygems' cache or in `vendor/cache`. Note that if a
+  appropriate platform-specific gem exists on `rubygems.org` it will not be
+  found.
+
+* `--print`:
+  Prints the lockfile to STDOUT instead of writing to the file system.
+
+* `--lockfile=<path>`:
+  The path where the lockfile should be written to.
+
+* `--full-index`:
+  Fall back to using the single-file index of all gems.
+
+* `--add-platform`:
+  Add a new platform to the lockfile, re-resolving for the addition of that
+  platform.
+
+* `--remove-platform`:
+  Remove a platform from the lockfile.
+
+* `--patch`:
+  If updating, prefer updating only to next patch version.
+
+* `--minor`:
+  If updating, prefer updating only to next minor version.
+
+* `--major`:
+  If updating, prefer updating to next major version (default).
+
+* `--strict`:
+  If updating, do not allow any gem to be updated past latest --patch | --minor | --major.
+
+* `--conservative`:
+  If updating, use bundle install conservative update behavior and do not allow shared dependencies to be updated.
+
+## UPDATING ALL GEMS
+
+If you run `bundle lock` with `--update` option without list of gems, bundler will
+ignore any previously installed gems and resolve all dependencies again based
+on the latest versions of all gems available in the sources.
+
+## UPDATING A LIST OF GEMS
+
+Sometimes, you want to update a single gem in the Gemfile(5), and leave the rest of
+the gems that you specified locked to the versions in the `Gemfile.lock`.
+
+For instance, you only want to update `nokogiri`, run `bundle lock --update nokogiri`.
+
+Bundler will update `nokogiri` and any of its dependencies, but leave the rest of the
+gems that you specified locked to the versions in the `Gemfile.lock`.
+
+## SUPPORTING OTHER PLATFORMS
+
+If you want your bundle to support platforms other than the one you're running
+locally, you can run `bundle lock --add-platform PLATFORM` to add PLATFORM to
+the lockfile, force bundler to re-resolve and consider the new platform when
+picking gems, all without needing to have a machine that matches PLATFORM handy
+to install those platform-specific gems on.
+
+For a full explanation of gem platforms, see `gem help platform`.
+
+## PATCH LEVEL OPTIONS
+
+See [bundle update(1)](bundle-update.1.html) for details.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-open.1
@@ -0,0 +1,32 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-OPEN" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-open\fR \- Opens the source directory for a gem in your bundle
+.
+.SH "SYNOPSIS"
+\fBbundle open\fR [GEM]
+.
+.SH "DESCRIPTION"
+Opens the source directory of the provided GEM in your editor\.
+.
+.P
+For this to work the \fBEDITOR\fR or \fBBUNDLER_EDITOR\fR environment variable has to be set\.
+.
+.P
+Example:
+.
+.IP "" 4
+.
+.nf
+
+bundle open \'rack\'
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Will open the source directory for the \'rack\' gem in your bundle\.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-open.1.ronn
@@ -0,0 +1,19 @@
+bundle-open(1) -- Opens the source directory for a gem in your bundle
+=====================================================================
+
+## SYNOPSIS
+
+`bundle open` [GEM]
+
+## DESCRIPTION
+
+Opens the source directory of the provided GEM in your editor.
+
+For this to work the `EDITOR` or `BUNDLER_EDITOR` environment variable has to
+be set.
+
+Example:
+
+    bundle open 'rack'
+
+Will open the source directory for the 'rack' gem in your bundle.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-outdated.1
@@ -0,0 +1,148 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-OUTDATED" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-outdated\fR \- List installed gems with newer versions available
+.
+.SH "SYNOPSIS"
+\fBbundle outdated\fR [GEM] [\-\-local] [\-\-pre] [\-\-source] [\-\-strict] [\-\-parseable | \-\-porcelain] [\-\-group=GROUP] [\-\-groups] [\-\-patch|\-\-minor|\-\-major] [\-\-filter\-major] [\-\-filter\-minor] [\-\-filter\-patch] [\-\-only\-explicit]
+.
+.SH "DESCRIPTION"
+Outdated lists the names and versions of gems that have a newer version available in the given source\. Calling outdated with [GEM [GEM]] will only check for newer versions of the given gems\. Prerelease gems are ignored by default\. If your gems are up to date, Bundler will exit with a status of 0\. Otherwise, it will exit 1\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-local\fR
+Do not attempt to fetch gems remotely and use the gem cache instead\.
+.
+.TP
+\fB\-\-pre\fR
+Check for newer pre\-release gems\.
+.
+.TP
+\fB\-\-source\fR
+Check against a specific source\.
+.
+.TP
+\fB\-\-strict\fR
+Only list newer versions allowed by your Gemfile requirements, also respecting conservative update flags (\-\-patch, \-\-minor, \-\-major)\.
+.
+.TP
+\fB\-\-parseable\fR, \fB\-\-porcelain\fR
+Use minimal formatting for more parseable output\.
+.
+.TP
+\fB\-\-group\fR
+List gems from a specific group\.
+.
+.TP
+\fB\-\-groups\fR
+List gems organized by groups\.
+.
+.TP
+\fB\-\-minor\fR
+Prefer updating only to next minor version\.
+.
+.TP
+\fB\-\-major\fR
+Prefer updating to next major version (default)\.
+.
+.TP
+\fB\-\-patch\fR
+Prefer updating only to next patch version\.
+.
+.TP
+\fB\-\-filter\-major\fR
+Only list major newer versions\.
+.
+.TP
+\fB\-\-filter\-minor\fR
+Only list minor newer versions\.
+.
+.TP
+\fB\-\-filter\-patch\fR
+Only list patch newer versions\.
+.
+.TP
+\fB\-\-only\-explicit\fR
+Only list gems specified in your Gemfile, not their dependencies\.
+.
+.SH "PATCH LEVEL OPTIONS"
+See bundle update(1) \fIbundle\-update\.1\.html\fR for details\.
+.
+.SH "FILTERING OUTPUT"
+The 3 filtering options do not affect the resolution of versions, merely what versions are shown in the output\.
+.
+.P
+If the regular output shows the following:
+.
+.IP "" 4
+.
+.nf
+
+* faker (newest 1\.6\.6, installed 1\.6\.5, requested ~> 1\.4) in groups "development, test"
+* hashie (newest 3\.4\.6, installed 1\.2\.0, requested = 1\.2\.0) in groups "default"
+* headless (newest 2\.3\.1, installed 2\.2\.3) in groups "test"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+\fB\-\-filter\-major\fR would only show:
+.
+.IP "" 4
+.
+.nf
+
+* hashie (newest 3\.4\.6, installed 1\.2\.0, requested = 1\.2\.0) in groups "default"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+\fB\-\-filter\-minor\fR would only show:
+.
+.IP "" 4
+.
+.nf
+
+* headless (newest 2\.3\.1, installed 2\.2\.3) in groups "test"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+\fB\-\-filter\-patch\fR would only show:
+.
+.IP "" 4
+.
+.nf
+
+* faker (newest 1\.6\.6, installed 1\.6\.5, requested ~> 1\.4) in groups "development, test"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Filter options can be combined\. \fB\-\-filter\-minor\fR and \fB\-\-filter\-patch\fR would show:
+.
+.IP "" 4
+.
+.nf
+
+* faker (newest 1\.6\.6, installed 1\.6\.5, requested ~> 1\.4) in groups "development, test"
+* headless (newest 2\.3\.1, installed 2\.2\.3) in groups "test"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Combining all three \fBfilter\fR options would be the same result as providing none of them\.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-outdated.1.ronn
@@ -0,0 +1,102 @@
+bundle-outdated(1) -- List installed gems with newer versions available
+=======================================================================
+
+## SYNOPSIS
+
+`bundle outdated` [GEM] [--local]
+                        [--pre]
+                        [--source]
+                        [--strict]
+                        [--parseable | --porcelain]
+                        [--group=GROUP]
+                        [--groups]
+                        [--patch|--minor|--major]
+                        [--filter-major]
+                        [--filter-minor]
+                        [--filter-patch]
+                        [--only-explicit]
+
+## DESCRIPTION
+
+Outdated lists the names and versions of gems that have a newer version available
+in the given source. Calling outdated with [GEM [GEM]] will only check for newer
+versions of the given gems. Prerelease gems are ignored by default. If your gems
+are up to date, Bundler will exit with a status of 0. Otherwise, it will exit 1.
+
+## OPTIONS
+
+* `--local`:
+  Do not attempt to fetch gems remotely and use the gem cache instead.
+
+* `--pre`:
+  Check for newer pre-release gems.
+
+* `--source`:
+  Check against a specific source.
+
+* `--strict`:
+  Only list newer versions allowed by your Gemfile requirements, also respecting conservative update flags (--patch, --minor, --major).
+
+* `--parseable`, `--porcelain`:
+   Use minimal formatting for more parseable output.
+
+* `--group`:
+  List gems from a specific group.
+
+* `--groups`:
+  List gems organized by groups.
+
+* `--minor`:
+  Prefer updating only to next minor version.
+
+* `--major`:
+  Prefer updating to next major version (default).
+
+* `--patch`:
+  Prefer updating only to next patch version.
+
+* `--filter-major`:
+  Only list major newer versions.
+
+* `--filter-minor`:
+  Only list minor newer versions.
+
+* `--filter-patch`:
+  Only list patch newer versions.
+
+* `--only-explicit`:
+  Only list gems specified in your Gemfile, not their dependencies.
+
+## PATCH LEVEL OPTIONS
+
+See [bundle update(1)](bundle-update.1.html) for details.
+
+## FILTERING OUTPUT
+
+The 3 filtering options do not affect the resolution of versions, merely what versions are shown
+in the output.
+
+If the regular output shows the following:
+
+    * faker (newest 1.6.6, installed 1.6.5, requested ~> 1.4) in groups "development, test"
+    * hashie (newest 3.4.6, installed 1.2.0, requested = 1.2.0) in groups "default"
+    * headless (newest 2.3.1, installed 2.2.3) in groups "test"
+
+`--filter-major` would only show:
+
+    * hashie (newest 3.4.6, installed 1.2.0, requested = 1.2.0) in groups "default"
+
+`--filter-minor` would only show:
+
+    * headless (newest 2.3.1, installed 2.2.3) in groups "test"
+
+`--filter-patch` would only show:
+
+    * faker (newest 1.6.6, installed 1.6.5, requested ~> 1.4) in groups "development, test"
+
+Filter options can be combined. `--filter-minor` and `--filter-patch` would show:
+
+    * faker (newest 1.6.6, installed 1.6.5, requested ~> 1.4) in groups "development, test"
+    * headless (newest 2.3.1, installed 2.2.3) in groups "test"
+
+Combining all three `filter` options would be the same result as providing none of them.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-platform.1
@@ -0,0 +1,71 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-PLATFORM" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-platform\fR \- Displays platform compatibility information
+.
+.SH "SYNOPSIS"
+\fBbundle platform\fR [\-\-ruby]
+.
+.SH "DESCRIPTION"
+\fBplatform\fR displays information from your Gemfile, Gemfile\.lock, and Ruby VM about your platform\.
+.
+.P
+For instance, using this Gemfile(5):
+.
+.IP "" 4
+.
+.nf
+
+source "https://rubygems\.org"
+
+ruby "3\.1\.2"
+
+gem "rack"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+If you run \fBbundle platform\fR on Ruby 3\.1\.2, it displays the following output:
+.
+.IP "" 4
+.
+.nf
+
+Your platform is: x86_64\-linux
+
+Your app has gems that work on these platforms:
+* arm64\-darwin\-21
+* ruby
+* x64\-mingw\-ucrt
+* x86_64\-linux
+
+Your Gemfile specifies a Ruby version requirement:
+* ruby 3\.1\.2
+
+Your current platform satisfies the Ruby version requirement\.
+.
+.fi
+.
+.IP "" 0
+.
+.P
+\fBplatform\fR lists all the platforms in your \fBGemfile\.lock\fR as well as the \fBruby\fR directive if applicable from your Gemfile(5)\. It also lets you know if the \fBruby\fR directive requirement has been met\. If \fBruby\fR directive doesn\'t match the running Ruby VM, it tells you what part does not\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-ruby\fR
+It will display the ruby directive information, so you don\'t have to parse it from the Gemfile(5)\.
+.
+.SH "SEE ALSO"
+.
+.IP "\(bu" 4
+bundle\-lock(1) \fIbundle\-lock\.1\.ronn\fR
+.
+.IP "" 0
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-platform.1.ronn
@@ -0,0 +1,49 @@
+bundle-platform(1) -- Displays platform compatibility information
+=================================================================
+
+## SYNOPSIS
+
+`bundle platform` [--ruby]
+
+## DESCRIPTION
+
+`platform` displays information from your Gemfile, Gemfile.lock, and Ruby
+VM about your platform.
+
+For instance, using this Gemfile(5):
+
+    source "https://rubygems.org"
+
+    ruby "3.1.2"
+
+    gem "rack"
+
+If you run `bundle platform` on Ruby 3.1.2, it displays the following output:
+
+    Your platform is: x86_64-linux
+
+    Your app has gems that work on these platforms:
+    * arm64-darwin-21
+    * ruby
+    * x64-mingw-ucrt
+    * x86_64-linux
+
+    Your Gemfile specifies a Ruby version requirement:
+    * ruby 3.1.2
+
+    Your current platform satisfies the Ruby version requirement.
+
+`platform` lists all the platforms in your `Gemfile.lock` as well as the
+`ruby` directive if applicable from your Gemfile(5). It also lets you know
+if the `ruby` directive requirement has been met. If `ruby` directive doesn't
+match the running Ruby VM, it tells you what part does not.
+
+## OPTIONS
+
+* `--ruby`:
+  It will display the ruby directive information, so you don't have to
+  parse it from the Gemfile(5).
+
+## SEE ALSO
+
+* [bundle-lock(1)](bundle-lock.1.ronn)
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-plugin.1
@@ -0,0 +1,81 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-PLUGIN" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-plugin\fR \- Manage Bundler plugins
+.
+.SH "SYNOPSIS"
+\fBbundle plugin\fR install PLUGINS [\-\-source=\fISOURCE\fR] [\-\-version=\fIversion\fR] [\-\-git|\-\-local_git=\fIgit\-url\fR] [\-\-branch=\fIbranch\fR|\-\-ref=\fIrev\fR]
+.
+.br
+\fBbundle plugin\fR uninstall PLUGINS
+.
+.br
+\fBbundle plugin\fR list
+.
+.br
+\fBbundle plugin\fR help [COMMAND]
+.
+.SH "DESCRIPTION"
+You can install, uninstall, and list plugin(s) with this command to extend functionalities of Bundler\.
+.
+.SH "SUB\-COMMANDS"
+.
+.SS "install"
+Install the given plugin(s)\.
+.
+.IP "\(bu" 4
+\fBbundle plugin install bundler\-graph\fR: Install bundler\-graph gem from RubyGems\.org\. The global source, specified in source in Gemfile is ignored\.
+.
+.IP "\(bu" 4
+\fBbundle plugin install bundler\-graph \-\-source https://example\.com\fR: Install bundler\-graph gem from example\.com\. The global source, specified in source in Gemfile is not considered\.
+.
+.IP "\(bu" 4
+\fBbundle plugin install bundler\-graph \-\-version 0\.2\.1\fR: You can specify the version of the gem via \fB\-\-version\fR\.
+.
+.IP "\(bu" 4
+\fBbundle plugin install bundler\-graph \-\-git https://github\.com/rubygems/bundler\-graph\fR: Install bundler\-graph gem from Git repository\. \fB\-\-git\fR can be replaced with \fB\-\-local\-git\fR\. You cannot use both \fB\-\-git\fR and \fB\-\-local\-git\fR\. You can use standard Git URLs like:
+.
+.IP "\(bu" 4
+\fBssh://[user@]host\.xz[:port]/path/to/repo\.git\fR
+.
+.IP "\(bu" 4
+\fBhttp[s]://host\.xz[:port]/path/to/repo\.git\fR
+.
+.IP "\(bu" 4
+\fB/path/to/repo\fR
+.
+.IP "\(bu" 4
+\fBfile:///path/to/repo\fR
+.
+.IP "" 0
+.
+.IP
+When you specify \fB\-\-git\fR/\fB\-\-local\-git\fR, you can use \fB\-\-branch\fR or \fB\-\-ref\fR to specify any branch, tag, or commit hash (revision) to use\. When you specify both, only the latter is used\.
+.
+.IP "" 0
+.
+.SS "uninstall"
+Uninstall the plugin(s) specified in PLUGINS\.
+.
+.SS "list"
+List the installed plugins and available commands\.
+.
+.P
+No options\.
+.
+.SS "help"
+Describe subcommands or one specific subcommand\.
+.
+.P
+No options\.
+.
+.SH "SEE ALSO"
+.
+.IP "\(bu" 4
+How to write a Bundler plugin \fIhttps://bundler\.io/guides/bundler_plugins\.html\fR
+.
+.IP "" 0
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-plugin.1.ronn
@@ -0,0 +1,59 @@
+bundle-plugin(1) -- Manage Bundler plugins
+==========================================
+
+## SYNOPSIS
+
+`bundle plugin` install PLUGINS [--source=<SOURCE>] [--version=<version>]
+                              [--git|--local_git=<git-url>] [--branch=<branch>|--ref=<rev>]<br>
+`bundle plugin` uninstall PLUGINS<br>
+`bundle plugin` list<br>
+`bundle plugin` help [COMMAND]
+
+## DESCRIPTION
+
+You can install, uninstall, and list plugin(s) with this command to extend functionalities of Bundler.
+
+## SUB-COMMANDS
+
+### install
+
+Install the given plugin(s).
+
+* `bundle plugin install bundler-graph`:
+  Install bundler-graph gem from RubyGems.org. The global source, specified in source in Gemfile is ignored.
+
+* `bundle plugin install bundler-graph --source https://example.com`:
+  Install bundler-graph gem from example.com. The global source, specified in source in Gemfile is not considered.
+
+* `bundle plugin install bundler-graph --version 0.2.1`:
+  You can specify the version of the gem via `--version`.
+
+* `bundle plugin install bundler-graph --git https://github.com/rubygems/bundler-graph`:
+  Install bundler-graph gem from Git repository. `--git` can be replaced with `--local-git`. You cannot use both `--git` and `--local-git`. You can use standard Git URLs like:
+
+  * `ssh://[user@]host.xz[:port]/path/to/repo.git`
+  * `http[s]://host.xz[:port]/path/to/repo.git`
+  * `/path/to/repo`
+  * `file:///path/to/repo`
+
+  When you specify `--git`/`--local-git`, you can use `--branch` or `--ref` to specify any branch, tag, or commit hash (revision) to use. When you specify both, only the latter is used.
+
+### uninstall
+
+Uninstall the plugin(s) specified in PLUGINS.
+
+### list
+
+List the installed plugins and available commands.
+
+No options.
+
+### help
+
+Describe subcommands or one specific subcommand.
+
+No options.
+
+## SEE ALSO
+
+* [How to write a Bundler plugin](https://bundler.io/guides/bundler_plugins.html)
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-pristine.1
@@ -0,0 +1,34 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-PRISTINE" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-pristine\fR \- Restores installed gems to their pristine condition
+.
+.SH "SYNOPSIS"
+\fBbundle pristine\fR
+.
+.SH "DESCRIPTION"
+\fBpristine\fR restores the installed gems in the bundle to their pristine condition using the local gem cache from RubyGems\. For git gems, a forced checkout will be performed\.
+.
+.P
+For further explanation, \fBbundle pristine\fR ignores unpacked files on disk\. In other words, this command utilizes the local \fB\.gem\fR cache or the gem\'s git repository as if one were installing from scratch\.
+.
+.P
+Note: the Bundler gem cannot be restored to its original state with \fBpristine\fR\. One also cannot use \fBbundle pristine\fR on gems with a \'path\' option in the Gemfile, because bundler has no original copy it can restore from\.
+.
+.P
+When is it practical to use \fBbundle pristine\fR?
+.
+.P
+It comes in handy when a developer is debugging a gem\. \fBbundle pristine\fR is a great way to get rid of experimental changes to a gem that one may not want\.
+.
+.P
+Why use \fBbundle pristine\fR over \fBgem pristine \-\-all\fR?
+.
+.P
+Both commands are very similar\. For context: \fBbundle pristine\fR, without arguments, cleans all gems from the lockfile\. Meanwhile, \fBgem pristine \-\-all\fR cleans all installed gems for that Ruby version\.
+.
+.P
+If a developer forgets which gems in their project they might have been debugging, the Rubygems \fBgem pristine [GEMNAME]\fR command may be inconvenient\. One can avoid waiting for \fBgem pristine \-\-all\fR, and instead run \fBbundle pristine\fR\.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-pristine.1.ronn
@@ -0,0 +1,34 @@
+bundle-pristine(1) -- Restores installed gems to their pristine condition
+===========================================================================
+
+## SYNOPSIS
+
+`bundle pristine`
+
+## DESCRIPTION
+
+`pristine` restores the installed gems in the bundle to their pristine condition
+using the local gem cache from RubyGems. For git gems, a forced checkout will be performed.
+
+For further explanation, `bundle pristine` ignores unpacked files on disk. In other
+words, this command utilizes the local `.gem` cache or the gem's git repository
+as if one were installing from scratch.
+
+Note: the Bundler gem cannot be restored to its original state with `pristine`.
+One also cannot use `bundle pristine` on gems with a 'path' option in the Gemfile,
+because bundler has no original copy it can restore from.
+
+When is it practical to use `bundle pristine`?
+
+It comes in handy when a developer is debugging a gem. `bundle pristine` is a
+great way to get rid of experimental changes to a gem that one may not want.
+
+Why use `bundle pristine` over `gem pristine --all`?
+
+Both commands are very similar.
+For context: `bundle pristine`, without arguments, cleans all gems from the lockfile.
+Meanwhile, `gem pristine --all` cleans all installed gems for that Ruby version.
+
+If a developer forgets which gems in their project they might
+have been debugging, the Rubygems `gem pristine [GEMNAME]` command may be inconvenient.
+One can avoid waiting for `gem pristine --all`, and instead run `bundle pristine`.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-remove.1
@@ -0,0 +1,31 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-REMOVE" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-remove\fR \- Removes gems from the Gemfile
+.
+.SH "SYNOPSIS"
+\fBbundle remove [GEM [GEM \.\.\.]] [\-\-install]\fR
+.
+.SH "DESCRIPTION"
+Removes the given gems from the Gemfile while ensuring that the resulting Gemfile is still valid\. If a gem cannot be removed, a warning is printed\. If a gem is already absent from the Gemfile, and error is raised\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-install\fR
+Runs \fBbundle install\fR after the given gems have been removed from the Gemfile, which ensures that both the lockfile and the installed gems on disk are also updated to remove the given gem(s)\.
+.
+.P
+Example:
+.
+.P
+bundle remove rails
+.
+.P
+bundle remove rails rack
+.
+.P
+bundle remove rails rack \-\-install
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-remove.1.ronn
@@ -0,0 +1,23 @@
+bundle-remove(1) -- Removes gems from the Gemfile
+===========================================================================
+
+## SYNOPSIS
+
+`bundle remove [GEM [GEM ...]] [--install]`
+
+## DESCRIPTION
+
+Removes the given gems from the Gemfile while ensuring that the resulting Gemfile is still valid. If a gem cannot be removed, a warning is printed. If a gem is already absent from the Gemfile, and error is raised.
+
+## OPTIONS
+
+* `--install`:
+  Runs `bundle install` after the given gems have been removed from the Gemfile, which ensures that both the lockfile and the installed gems on disk are also updated to remove the given gem(s).
+
+Example:
+
+bundle remove rails
+
+bundle remove rails rack
+
+bundle remove rails rack --install
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-show.1
@@ -0,0 +1,23 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-SHOW" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-show\fR \- Shows all the gems in your bundle, or the path to a gem
+.
+.SH "SYNOPSIS"
+\fBbundle show\fR [GEM] [\-\-paths]
+.
+.SH "DESCRIPTION"
+Without the [GEM] option, \fBshow\fR will print a list of the names and versions of all gems that are required by your [\fBGemfile(5)\fR][Gemfile(5)], sorted by name\.
+.
+.P
+Calling show with [GEM] will list the exact location of that gem on your machine\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-paths\fR
+List the paths of all gems that are required by your [\fBGemfile(5)\fR][Gemfile(5)], sorted by gem name\.
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-show.1.ronn
@@ -0,0 +1,21 @@
+bundle-show(1) -- Shows all the gems in your bundle, or the path to a gem
+=========================================================================
+
+## SYNOPSIS
+
+`bundle show` [GEM]
+              [--paths]
+
+## DESCRIPTION
+
+Without the [GEM] option, `show` will print a list of the names and versions of
+all gems that are required by your [`Gemfile(5)`][Gemfile(5)], sorted by name.
+
+Calling show with [GEM] will list the exact location of that gem on your
+machine.
+
+## OPTIONS
+
+* `--paths`:
+  List the paths of all gems that are required by your [`Gemfile(5)`][Gemfile(5)],
+  sorted by gem name.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-update.1
@@ -0,0 +1,394 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-UPDATE" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-update\fR \- Update your gems to the latest available versions
+.
+.SH "SYNOPSIS"
+\fBbundle update\fR \fI*gems\fR [\-\-all] [\-\-group=NAME] [\-\-source=NAME] [\-\-local] [\-\-ruby] [\-\-bundler[=VERSION]] [\-\-full\-index] [\-\-jobs=JOBS] [\-\-quiet] [\-\-patch|\-\-minor|\-\-major] [\-\-redownload] [\-\-strict] [\-\-conservative]
+.
+.SH "DESCRIPTION"
+Update the gems specified (all gems, if \fB\-\-all\fR flag is used), ignoring the previously installed gems specified in the \fBGemfile\.lock\fR\. In general, you should use bundle install(1) \fIbundle\-install\.1\.html\fR to install the same exact gems and versions across machines\.
+.
+.P
+You would use \fBbundle update\fR to explicitly update the version of a gem\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-all\fR
+Update all gems specified in Gemfile\.
+.
+.TP
+\fB\-\-group=<name>\fR, \fB\-g=[<name>]\fR
+Only update the gems in the specified group\. For instance, you can update all gems in the development group with \fBbundle update \-\-group development\fR\. You can also call \fBbundle update rails \-\-group test\fR to update the rails gem and all gems in the test group, for example\.
+.
+.TP
+\fB\-\-source=<name>\fR
+The name of a \fB:git\fR or \fB:path\fR source used in the Gemfile(5)\. For instance, with a \fB:git\fR source of \fBhttp://github\.com/rails/rails\.git\fR, you would call \fBbundle update \-\-source rails\fR
+.
+.TP
+\fB\-\-local\fR
+Do not attempt to fetch gems remotely and use the gem cache instead\.
+.
+.TP
+\fB\-\-ruby\fR
+Update the locked version of Ruby to the current version of Ruby\.
+.
+.TP
+\fB\-\-bundler\fR
+Update the locked version of bundler to the invoked bundler version\.
+.
+.TP
+\fB\-\-full\-index\fR
+Fall back to using the single\-file index of all gems\.
+.
+.TP
+\fB\-\-jobs=[<number>]\fR, \fB\-j[<number>]\fR
+Specify the number of jobs to run in parallel\. The default is the number of available processors\.
+.
+.TP
+\fB\-\-retry=[<number>]\fR
+Retry failed network or git requests for \fInumber\fR times\.
+.
+.TP
+\fB\-\-quiet\fR
+Only output warnings and errors\.
+.
+.TP
+\fB\-\-redownload\fR
+Force downloading every gem\.
+.
+.TP
+\fB\-\-patch\fR
+Prefer updating only to next patch version\.
+.
+.TP
+\fB\-\-minor\fR
+Prefer updating only to next minor version\.
+.
+.TP
+\fB\-\-major\fR
+Prefer updating to next major version (default)\.
+.
+.TP
+\fB\-\-strict\fR
+Do not allow any gem to be updated past latest \fB\-\-patch\fR | \fB\-\-minor\fR | \fB\-\-major\fR\.
+.
+.TP
+\fB\-\-conservative\fR
+Use bundle install conservative update behavior and do not allow indirect dependencies to be updated\.
+.
+.SH "UPDATING ALL GEMS"
+If you run \fBbundle update \-\-all\fR, bundler will ignore any previously installed gems and resolve all dependencies again based on the latest versions of all gems available in the sources\.
+.
+.P
+Consider the following Gemfile(5):
+.
+.IP "" 4
+.
+.nf
+
+source "https://rubygems\.org"
+
+gem "rails", "3\.0\.0\.rc"
+gem "nokogiri"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+When you run bundle install(1) \fIbundle\-install\.1\.html\fR the first time, bundler will resolve all of the dependencies, all the way down, and install what you need:
+.
+.IP "" 4
+.
+.nf
+
+Fetching gem metadata from https://rubygems\.org/\.\.\.\.\.\.\.\.\.
+Resolving dependencies\.\.\.
+Installing builder 2\.1\.2
+Installing abstract 1\.0\.0
+Installing rack 1\.2\.8
+Using bundler 1\.7\.6
+Installing rake 10\.4\.0
+Installing polyglot 0\.3\.5
+Installing mime\-types 1\.25\.1
+Installing i18n 0\.4\.2
+Installing mini_portile 0\.6\.1
+Installing tzinfo 0\.3\.42
+Installing rack\-mount 0\.6\.14
+Installing rack\-test 0\.5\.7
+Installing treetop 1\.4\.15
+Installing thor 0\.14\.6
+Installing activesupport 3\.0\.0\.rc
+Installing erubis 2\.6\.6
+Installing activemodel 3\.0\.0\.rc
+Installing arel 0\.4\.0
+Installing mail 2\.2\.20
+Installing activeresource 3\.0\.0\.rc
+Installing actionpack 3\.0\.0\.rc
+Installing activerecord 3\.0\.0\.rc
+Installing actionmailer 3\.0\.0\.rc
+Installing railties 3\.0\.0\.rc
+Installing rails 3\.0\.0\.rc
+Installing nokogiri 1\.6\.5
+
+Bundle complete! 2 Gemfile dependencies, 26 gems total\.
+Use `bundle show [gemname]` to see where a bundled gem is installed\.
+.
+.fi
+.
+.IP "" 0
+.
+.P
+As you can see, even though you have two gems in the Gemfile(5), your application needs 26 different gems in order to run\. Bundler remembers the exact versions it installed in \fBGemfile\.lock\fR\. The next time you run bundle install(1) \fIbundle\-install\.1\.html\fR, bundler skips the dependency resolution and installs the same gems as it installed last time\.
+.
+.P
+After checking in the \fBGemfile\.lock\fR into version control and cloning it on another machine, running bundle install(1) \fIbundle\-install\.1\.html\fR will \fIstill\fR install the gems that you installed last time\. You don\'t need to worry that a new release of \fBerubis\fR or \fBmail\fR changes the gems you use\.
+.
+.P
+However, from time to time, you might want to update the gems you are using to the newest versions that still match the gems in your Gemfile(5)\.
+.
+.P
+To do this, run \fBbundle update \-\-all\fR, which will ignore the \fBGemfile\.lock\fR, and resolve all the dependencies again\. Keep in mind that this process can result in a significantly different set of the 25 gems, based on the requirements of new gems that the gem authors released since the last time you ran \fBbundle update \-\-all\fR\.
+.
+.SH "UPDATING A LIST OF GEMS"
+Sometimes, you want to update a single gem in the Gemfile(5), and leave the rest of the gems that you specified locked to the versions in the \fBGemfile\.lock\fR\.
+.
+.P
+For instance, in the scenario above, imagine that \fBnokogiri\fR releases version \fB1\.4\.4\fR, and you want to update it \fIwithout\fR updating Rails and all of its dependencies\. To do this, run \fBbundle update nokogiri\fR\.
+.
+.P
+Bundler will update \fBnokogiri\fR and any of its dependencies, but leave alone Rails and its dependencies\.
+.
+.SH "OVERLAPPING DEPENDENCIES"
+Sometimes, multiple gems declared in your Gemfile(5) are satisfied by the same second\-level dependency\. For instance, consider the case of \fBthin\fR and \fBrack\-perftools\-profiler\fR\.
+.
+.IP "" 4
+.
+.nf
+
+source "https://rubygems\.org"
+
+gem "thin"
+gem "rack\-perftools\-profiler"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+The \fBthin\fR gem depends on \fBrack >= 1\.0\fR, while \fBrack\-perftools\-profiler\fR depends on \fBrack ~> 1\.0\fR\. If you run bundle install, you get:
+.
+.IP "" 4
+.
+.nf
+
+Fetching source index for https://rubygems\.org/
+Installing daemons (1\.1\.0)
+Installing eventmachine (0\.12\.10) with native extensions
+Installing open4 (1\.0\.1)
+Installing perftools\.rb (0\.4\.7) with native extensions
+Installing rack (1\.2\.1)
+Installing rack\-perftools_profiler (0\.0\.2)
+Installing thin (1\.2\.7) with native extensions
+Using bundler (1\.0\.0\.rc\.3)
+.
+.fi
+.
+.IP "" 0
+.
+.P
+In this case, the two gems have their own set of dependencies, but they share \fBrack\fR in common\. If you run \fBbundle update thin\fR, bundler will update \fBdaemons\fR, \fBeventmachine\fR and \fBrack\fR, which are dependencies of \fBthin\fR, but not \fBopen4\fR or \fBperftools\.rb\fR, which are dependencies of \fBrack\-perftools_profiler\fR\. Note that \fBbundle update thin\fR will update \fBrack\fR even though it\'s \fIalso\fR a dependency of \fBrack\-perftools_profiler\fR\.
+.
+.P
+In short, by default, when you update a gem using \fBbundle update\fR, bundler will update all dependencies of that gem, including those that are also dependencies of another gem\.
+.
+.P
+To prevent updating indirect dependencies, prior to version 1\.14 the only option was the \fBCONSERVATIVE UPDATING\fR behavior in bundle install(1) \fIbundle\-install\.1\.html\fR:
+.
+.P
+In this scenario, updating the \fBthin\fR version manually in the Gemfile(5), and then running bundle install(1) \fIbundle\-install\.1\.html\fR will only update \fBdaemons\fR and \fBeventmachine\fR, but not \fBrack\fR\. For more information, see the \fBCONSERVATIVE UPDATING\fR section of bundle install(1) \fIbundle\-install\.1\.html\fR\.
+.
+.P
+Starting with 1\.14, specifying the \fB\-\-conservative\fR option will also prevent indirect dependencies from being updated\.
+.
+.SH "PATCH LEVEL OPTIONS"
+Version 1\.14 introduced 4 patch\-level options that will influence how gem versions are resolved\. One of the following options can be used: \fB\-\-patch\fR, \fB\-\-minor\fR or \fB\-\-major\fR\. \fB\-\-strict\fR can be added to further influence resolution\.
+.
+.TP
+\fB\-\-patch\fR
+Prefer updating only to next patch version\.
+.
+.TP
+\fB\-\-minor\fR
+Prefer updating only to next minor version\.
+.
+.TP
+\fB\-\-major\fR
+Prefer updating to next major version (default)\.
+.
+.TP
+\fB\-\-strict\fR
+Do not allow any gem to be updated past latest \fB\-\-patch\fR | \fB\-\-minor\fR | \fB\-\-major\fR\.
+.
+.P
+When Bundler is resolving what versions to use to satisfy declared requirements in the Gemfile or in parent gems, it looks up all available versions, filters out any versions that don\'t satisfy the requirement, and then, by default, sorts them from newest to oldest, considering them in that order\.
+.
+.P
+Providing one of the patch level options (e\.g\. \fB\-\-patch\fR) changes the sort order of the satisfying versions, causing Bundler to consider the latest \fB\-\-patch\fR or \fB\-\-minor\fR version available before other versions\. Note that versions outside the stated patch level could still be resolved to if necessary to find a suitable dependency graph\.
+.
+.P
+For example, if gem \'foo\' is locked at 1\.0\.2, with no gem requirement defined in the Gemfile, and versions 1\.0\.3, 1\.0\.4, 1\.1\.0, 1\.1\.1, 2\.0\.0 all exist, the default order of preference by default (\fB\-\-major\fR) will be "2\.0\.0, 1\.1\.1, 1\.1\.0, 1\.0\.4, 1\.0\.3, 1\.0\.2"\.
+.
+.P
+If the \fB\-\-patch\fR option is used, the order of preference will change to "1\.0\.4, 1\.0\.3, 1\.0\.2, 1\.1\.1, 1\.1\.0, 2\.0\.0"\.
+.
+.P
+If the \fB\-\-minor\fR option is used, the order of preference will change to "1\.1\.1, 1\.1\.0, 1\.0\.4, 1\.0\.3, 1\.0\.2, 2\.0\.0"\.
+.
+.P
+Combining the \fB\-\-strict\fR option with any of the patch level options will remove any versions beyond the scope of the patch level option, to ensure that no gem is updated that far\.
+.
+.P
+To continue the previous example, if both \fB\-\-patch\fR and \fB\-\-strict\fR options are used, the available versions for resolution would be "1\.0\.4, 1\.0\.3, 1\.0\.2"\. If \fB\-\-minor\fR and \fB\-\-strict\fR are used, it would be "1\.1\.1, 1\.1\.0, 1\.0\.4, 1\.0\.3, 1\.0\.2"\.
+.
+.P
+Gem requirements as defined in the Gemfile will still be the first determining factor for what versions are available\. If the gem requirement for \fBfoo\fR in the Gemfile is \'~> 1\.0\', that will accomplish the same thing as providing the \fB\-\-minor\fR and \fB\-\-strict\fR options\.
+.
+.SH "PATCH LEVEL EXAMPLES"
+Given the following gem specifications:
+.
+.IP "" 4
+.
+.nf
+
+foo 1\.4\.3, requires: ~> bar 2\.0
+foo 1\.4\.4, requires: ~> bar 2\.0
+foo 1\.4\.5, requires: ~> bar 2\.1
+foo 1\.5\.0, requires: ~> bar 2\.1
+foo 1\.5\.1, requires: ~> bar 3\.0
+bar with versions 2\.0\.3, 2\.0\.4, 2\.1\.0, 2\.1\.1, 3\.0\.0
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Gemfile:
+.
+.IP "" 4
+.
+.nf
+
+gem \'foo\'
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Gemfile\.lock:
+.
+.IP "" 4
+.
+.nf
+
+foo (1\.4\.3)
+  bar (~> 2\.0)
+bar (2\.0\.3)
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Cases:
+.
+.IP "" 4
+.
+.nf
+
+#  Command Line                     Result
+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
+1  bundle update \-\-patch            \'foo 1\.4\.5\', \'bar 2\.1\.1\'
+2  bundle update \-\-patch foo        \'foo 1\.4\.5\', \'bar 2\.1\.1\'
+3  bundle update \-\-minor            \'foo 1\.5\.1\', \'bar 3\.0\.0\'
+4  bundle update \-\-minor \-\-strict   \'foo 1\.5\.0\', \'bar 2\.1\.1\'
+5  bundle update \-\-patch \-\-strict   \'foo 1\.4\.4\', \'bar 2\.0\.4\'
+.
+.fi
+.
+.IP "" 0
+.
+.P
+In case 1, bar is upgraded to 2\.1\.1, a minor version increase, because the dependency from foo 1\.4\.5 required it\.
+.
+.P
+In case 2, only foo is requested to be unlocked, but bar is also allowed to move because it\'s not a declared dependency in the Gemfile\.
+.
+.P
+In case 3, bar goes up a whole major release, because a minor increase is preferred now for foo, and when it goes to 1\.5\.1, it requires 3\.0\.0 of bar\.
+.
+.P
+In case 4, foo is preferred up to a minor version, but 1\.5\.1 won\'t work because the \-\-strict flag removes bar 3\.0\.0 from consideration since it\'s a major increment\.
+.
+.P
+In case 5, both foo and bar have any minor or major increments removed from consideration because of the \-\-strict flag, so the most they can move is up to 1\.4\.4 and 2\.0\.4\.
+.
+.SH "RECOMMENDED WORKFLOW"
+In general, when working with an application managed with bundler, you should use the following workflow:
+.
+.IP "\(bu" 4
+After you create your Gemfile(5) for the first time, run
+.
+.IP
+$ bundle install
+.
+.IP "\(bu" 4
+Check the resulting \fBGemfile\.lock\fR into version control
+.
+.IP
+$ git add Gemfile\.lock
+.
+.IP "\(bu" 4
+When checking out this repository on another development machine, run
+.
+.IP
+$ bundle install
+.
+.IP "\(bu" 4
+When checking out this repository on a deployment machine, run
+.
+.IP
+$ bundle install \-\-deployment
+.
+.IP "\(bu" 4
+After changing the Gemfile(5) to reflect a new or update dependency, run
+.
+.IP
+$ bundle install
+.
+.IP "\(bu" 4
+Make sure to check the updated \fBGemfile\.lock\fR into version control
+.
+.IP
+$ git add Gemfile\.lock
+.
+.IP "\(bu" 4
+If bundle install(1) \fIbundle\-install\.1\.html\fR reports a conflict, manually update the specific gems that you changed in the Gemfile(5)
+.
+.IP
+$ bundle update rails thin
+.
+.IP "\(bu" 4
+If you want to update all the gems to the latest possible versions that still match the gems listed in the Gemfile(5), run
+.
+.IP
+$ bundle update \-\-all
+.
+.IP "" 0
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-update.1.ronn
@@ -0,0 +1,351 @@
+bundle-update(1) -- Update your gems to the latest available versions
+=====================================================================
+
+## SYNOPSIS
+
+`bundle update` <*gems> [--all]
+                        [--group=NAME]
+                        [--source=NAME]
+                        [--local]
+                        [--ruby]
+                        [--bundler[=VERSION]]
+                        [--full-index]
+                        [--jobs=JOBS]
+                        [--quiet]
+                        [--patch|--minor|--major]
+                        [--redownload]
+                        [--strict]
+                        [--conservative]
+
+## DESCRIPTION
+
+Update the gems specified (all gems, if `--all` flag is used), ignoring
+the previously installed gems specified in the `Gemfile.lock`. In
+general, you should use [bundle install(1)](bundle-install.1.html) to install the same exact
+gems and versions across machines.
+
+You would use `bundle update` to explicitly update the version of a
+gem.
+
+## OPTIONS
+
+* `--all`:
+  Update all gems specified in Gemfile.
+
+* `--group=<name>`, `-g=[<name>]`:
+  Only update the gems in the specified group. For instance, you can update all gems
+  in the development group with `bundle update --group development`. You can also
+  call `bundle update rails --group test` to update the rails gem and all gems in
+  the test group, for example.
+
+* `--source=<name>`:
+  The name of a `:git` or `:path` source used in the Gemfile(5). For
+  instance, with a `:git` source of `http://github.com/rails/rails.git`,
+  you would call `bundle update --source rails`
+
+* `--local`:
+  Do not attempt to fetch gems remotely and use the gem cache instead.
+
+* `--ruby`:
+  Update the locked version of Ruby to the current version of Ruby.
+
+* `--bundler`:
+  Update the locked version of bundler to the invoked bundler version.
+
+* `--full-index`:
+  Fall back to using the single-file index of all gems.
+
+* `--jobs=[<number>]`, `-j[<number>]`:
+  Specify the number of jobs to run in parallel. The default is the number of
+  available processors.
+
+* `--retry=[<number>]`:
+  Retry failed network or git requests for <number> times.
+
+* `--quiet`:
+  Only output warnings and errors.
+
+* `--redownload`:
+  Force downloading every gem.
+
+* `--patch`:
+  Prefer updating only to next patch version.
+
+* `--minor`:
+  Prefer updating only to next minor version.
+
+* `--major`:
+  Prefer updating to next major version (default).
+
+* `--strict`:
+  Do not allow any gem to be updated past latest `--patch` | `--minor` | `--major`.
+
+* `--conservative`:
+  Use bundle install conservative update behavior and do not allow indirect dependencies to be updated.
+
+## UPDATING ALL GEMS
+
+If you run `bundle update --all`, bundler will ignore
+any previously installed gems and resolve all dependencies again
+based on the latest versions of all gems available in the sources.
+
+Consider the following Gemfile(5):
+
+    source "https://rubygems.org"
+
+    gem "rails", "3.0.0.rc"
+    gem "nokogiri"
+
+When you run [bundle install(1)](bundle-install.1.html) the first time, bundler will resolve
+all of the dependencies, all the way down, and install what you need:
+
+    Fetching gem metadata from https://rubygems.org/.........
+    Resolving dependencies...
+    Installing builder 2.1.2
+    Installing abstract 1.0.0
+    Installing rack 1.2.8
+    Using bundler 1.7.6
+    Installing rake 10.4.0
+    Installing polyglot 0.3.5
+    Installing mime-types 1.25.1
+    Installing i18n 0.4.2
+    Installing mini_portile 0.6.1
+    Installing tzinfo 0.3.42
+    Installing rack-mount 0.6.14
+    Installing rack-test 0.5.7
+    Installing treetop 1.4.15
+    Installing thor 0.14.6
+    Installing activesupport 3.0.0.rc
+    Installing erubis 2.6.6
+    Installing activemodel 3.0.0.rc
+    Installing arel 0.4.0
+    Installing mail 2.2.20
+    Installing activeresource 3.0.0.rc
+    Installing actionpack 3.0.0.rc
+    Installing activerecord 3.0.0.rc
+    Installing actionmailer 3.0.0.rc
+    Installing railties 3.0.0.rc
+    Installing rails 3.0.0.rc
+    Installing nokogiri 1.6.5
+
+    Bundle complete! 2 Gemfile dependencies, 26 gems total.
+    Use `bundle show [gemname]` to see where a bundled gem is installed.
+
+As you can see, even though you have two gems in the Gemfile(5), your application
+needs 26 different gems in order to run. Bundler remembers the exact versions
+it installed in `Gemfile.lock`. The next time you run [bundle install(1)](bundle-install.1.html), bundler skips
+the dependency resolution and installs the same gems as it installed last time.
+
+After checking in the `Gemfile.lock` into version control and cloning it on another
+machine, running [bundle install(1)](bundle-install.1.html) will _still_ install the gems that you installed
+last time. You don't need to worry that a new release of `erubis` or `mail` changes
+the gems you use.
+
+However, from time to time, you might want to update the gems you are using to the
+newest versions that still match the gems in your Gemfile(5).
+
+To do this, run `bundle update --all`, which will ignore the `Gemfile.lock`, and resolve
+all the dependencies again. Keep in mind that this process can result in a significantly
+different set of the 25 gems, based on the requirements of new gems that the gem
+authors released since the last time you ran `bundle update --all`.
+
+## UPDATING A LIST OF GEMS
+
+Sometimes, you want to update a single gem in the Gemfile(5), and leave the rest of the
+gems that you specified locked to the versions in the `Gemfile.lock`.
+
+For instance, in the scenario above, imagine that `nokogiri` releases version `1.4.4`, and
+you want to update it _without_ updating Rails and all of its dependencies. To do this,
+run `bundle update nokogiri`.
+
+Bundler will update `nokogiri` and any of its dependencies, but leave alone Rails and
+its dependencies.
+
+## OVERLAPPING DEPENDENCIES
+
+Sometimes, multiple gems declared in your Gemfile(5) are satisfied by the same
+second-level dependency. For instance, consider the case of `thin` and
+`rack-perftools-profiler`.
+
+    source "https://rubygems.org"
+
+    gem "thin"
+    gem "rack-perftools-profiler"
+
+The `thin` gem depends on `rack >= 1.0`, while `rack-perftools-profiler` depends
+on `rack ~> 1.0`. If you run bundle install, you get:
+
+    Fetching source index for https://rubygems.org/
+    Installing daemons (1.1.0)
+    Installing eventmachine (0.12.10) with native extensions
+    Installing open4 (1.0.1)
+    Installing perftools.rb (0.4.7) with native extensions
+    Installing rack (1.2.1)
+    Installing rack-perftools_profiler (0.0.2)
+    Installing thin (1.2.7) with native extensions
+    Using bundler (1.0.0.rc.3)
+
+In this case, the two gems have their own set of dependencies, but they share
+`rack` in common. If you run `bundle update thin`, bundler will update `daemons`,
+`eventmachine` and `rack`, which are dependencies of `thin`, but not `open4` or
+`perftools.rb`, which are dependencies of `rack-perftools_profiler`. Note that
+`bundle update thin` will update `rack` even though it's _also_ a dependency of
+`rack-perftools_profiler`.
+
+In short, by default, when you update a gem using `bundle update`, bundler will
+update all dependencies of that gem, including those that are also dependencies
+of another gem.
+
+To prevent updating indirect dependencies, prior to version 1.14 the only option
+was the `CONSERVATIVE UPDATING` behavior in [bundle install(1)](bundle-install.1.html):
+
+In this scenario, updating the `thin` version manually in the Gemfile(5),
+and then running [bundle install(1)](bundle-install.1.html) will only update `daemons` and `eventmachine`,
+but not `rack`. For more information, see the `CONSERVATIVE UPDATING` section
+of [bundle install(1)](bundle-install.1.html).
+
+Starting with 1.14, specifying the `--conservative` option will also prevent indirect
+dependencies from being updated.
+
+## PATCH LEVEL OPTIONS
+
+Version 1.14 introduced 4 patch-level options that will influence how gem
+versions are resolved. One of the following options can be used: `--patch`,
+`--minor` or `--major`. `--strict` can be added to further influence resolution.
+
+* `--patch`:
+  Prefer updating only to next patch version.
+
+* `--minor`:
+  Prefer updating only to next minor version.
+
+* `--major`:
+  Prefer updating to next major version (default).
+
+* `--strict`:
+  Do not allow any gem to be updated past latest `--patch` | `--minor` | `--major`.
+
+When Bundler is resolving what versions to use to satisfy declared
+requirements in the Gemfile or in parent gems, it looks up all
+available versions, filters out any versions that don't satisfy
+the requirement, and then, by default, sorts them from newest to
+oldest, considering them in that order.
+
+Providing one of the patch level options (e.g. `--patch`) changes the
+sort order of the satisfying versions, causing Bundler to consider the
+latest `--patch` or `--minor` version available before other versions.
+Note that versions outside the stated patch level could still be
+resolved to if necessary to find a suitable dependency graph.
+
+For example, if gem 'foo' is locked at 1.0.2, with no gem requirement
+defined in the Gemfile, and versions 1.0.3, 1.0.4, 1.1.0, 1.1.1, 2.0.0
+all exist, the default order of preference by default (`--major`) will
+be "2.0.0, 1.1.1, 1.1.0, 1.0.4, 1.0.3, 1.0.2".
+
+If the `--patch` option is used, the order of preference will change to
+"1.0.4, 1.0.3, 1.0.2, 1.1.1, 1.1.0, 2.0.0".
+
+If the `--minor` option is used, the order of preference will change to
+"1.1.1, 1.1.0, 1.0.4, 1.0.3, 1.0.2, 2.0.0".
+
+Combining the `--strict` option with any of the patch level options
+will remove any versions beyond the scope of the patch level option,
+to ensure that no gem is updated that far.
+
+To continue the previous example, if both `--patch` and `--strict`
+options are used, the available versions for resolution would be
+"1.0.4, 1.0.3, 1.0.2". If `--minor` and `--strict` are used, it would
+be "1.1.1, 1.1.0, 1.0.4, 1.0.3, 1.0.2".
+
+Gem requirements as defined in the Gemfile will still be the first
+determining factor for what versions are available. If the gem
+requirement for `foo` in the Gemfile is '~> 1.0', that will accomplish
+the same thing as providing the `--minor` and `--strict` options.
+
+## PATCH LEVEL EXAMPLES
+
+Given the following gem specifications:
+
+    foo 1.4.3, requires: ~> bar 2.0
+    foo 1.4.4, requires: ~> bar 2.0
+    foo 1.4.5, requires: ~> bar 2.1
+    foo 1.5.0, requires: ~> bar 2.1
+    foo 1.5.1, requires: ~> bar 3.0
+    bar with versions 2.0.3, 2.0.4, 2.1.0, 2.1.1, 3.0.0
+
+Gemfile:
+
+    gem 'foo'
+
+Gemfile.lock:
+
+    foo (1.4.3)
+      bar (~> 2.0)
+    bar (2.0.3)
+
+Cases:
+
+    #  Command Line                     Result
+    ------------------------------------------------------------
+    1  bundle update --patch            'foo 1.4.5', 'bar 2.1.1'
+    2  bundle update --patch foo        'foo 1.4.5', 'bar 2.1.1'
+    3  bundle update --minor            'foo 1.5.1', 'bar 3.0.0'
+    4  bundle update --minor --strict   'foo 1.5.0', 'bar 2.1.1'
+    5  bundle update --patch --strict   'foo 1.4.4', 'bar 2.0.4'
+
+In case 1, bar is upgraded to 2.1.1, a minor version increase, because
+the dependency from foo 1.4.5 required it.
+
+In case 2, only foo is requested to be unlocked, but bar is also
+allowed to move because it's not a declared dependency in the Gemfile.
+
+In case 3, bar goes up a whole major release, because a minor increase
+is preferred now for foo, and when it goes to 1.5.1, it requires 3.0.0
+of bar.
+
+In case 4, foo is preferred up to a minor version, but 1.5.1 won't work
+because the --strict flag removes bar 3.0.0 from consideration since
+it's a major increment.
+
+In case 5, both foo and bar have any minor or major increments removed
+from consideration because of the --strict flag, so the most they can
+move is up to 1.4.4 and 2.0.4.
+
+## RECOMMENDED WORKFLOW
+
+In general, when working with an application managed with bundler, you should
+use the following workflow:
+
+* After you create your Gemfile(5) for the first time, run
+
+    $ bundle install
+
+* Check the resulting `Gemfile.lock` into version control
+
+    $ git add Gemfile.lock
+
+* When checking out this repository on another development machine, run
+
+    $ bundle install
+
+* When checking out this repository on a deployment machine, run
+
+    $ bundle install --deployment
+
+* After changing the Gemfile(5) to reflect a new or update dependency, run
+
+    $ bundle install
+
+* Make sure to check the updated `Gemfile.lock` into version control
+
+    $ git add Gemfile.lock
+
+* If [bundle install(1)](bundle-install.1.html) reports a conflict, manually update the specific
+  gems that you changed in the Gemfile(5)
+
+    $ bundle update rails thin
+
+* If you want to update all the gems to the latest possible versions that
+  still match the gems listed in the Gemfile(5), run
+
+    $ bundle update --all
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-version.1
@@ -0,0 +1,35 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-VERSION" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-version\fR \- Prints Bundler version information
+.
+.SH "SYNOPSIS"
+\fBbundle version\fR
+.
+.SH "DESCRIPTION"
+Prints Bundler version information\.
+.
+.SH "OPTIONS"
+No options\.
+.
+.SH "EXAMPLE"
+Print the version of Bundler with build date and commit hash of the in the Git source\.
+.
+.IP "" 4
+.
+.nf
+
+bundle version
+.
+.fi
+.
+.IP "" 0
+.
+.P
+shows \fBBundler version 2\.3\.21 (2022\-08\-24 commit d54be5fdd8)\fR for example\.
+.
+.P
+cf\. \fBbundle \-\-version\fR shows \fBBundler version 2\.3\.21\fR\.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-version.1.ronn
@@ -0,0 +1,24 @@
+bundle-version(1) -- Prints Bundler version information
+=======================================================
+
+## SYNOPSIS
+
+`bundle version`
+
+## DESCRIPTION
+
+Prints Bundler version information.
+
+## OPTIONS
+
+No options.
+
+## EXAMPLE
+
+Print the version of Bundler with build date and commit hash of the in the Git source.
+
+    bundle version
+
+shows `Bundler version 2.3.21 (2022-08-24 commit d54be5fdd8)` for example.
+
+cf. `bundle --version` shows `Bundler version 2.3.21`.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-viz.1
@@ -0,0 +1,42 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE\-VIZ" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\-viz\fR \- Generates a visual dependency graph for your Gemfile
+.
+.SH "SYNOPSIS"
+\fBbundle viz\fR [\-\-file=FILE] [\-\-format=FORMAT] [\-\-requirements] [\-\-version] [\-\-without=GROUP GROUP]
+.
+.SH "DESCRIPTION"
+\fBviz\fR generates a PNG file of the current \fBGemfile(5)\fR as a dependency graph\. \fBviz\fR requires the ruby\-graphviz gem (and its dependencies)\.
+.
+.P
+The associated gems must also be installed via \fBbundle install(1)\fR \fIbundle\-install\.1\.html\fR\.
+.
+.P
+\fBviz\fR command was deprecated in Bundler 2\.2\. Use bundler\-graph plugin \fIhttps://github\.com/rubygems/bundler\-graph\fR instead\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-file\fR, \fB\-f\fR
+The name to use for the generated file\. See \fB\-\-format\fR option
+.
+.TP
+\fB\-\-format\fR, \fB\-F\fR
+This is output format option\. Supported format is png, jpg, svg, dot \.\.\.
+.
+.TP
+\fB\-\-requirements\fR, \fB\-R\fR
+Set to show the version of each required dependency\.
+.
+.TP
+\fB\-\-version\fR, \fB\-v\fR
+Set to show each gem version\.
+.
+.TP
+\fB\-\-without\fR, \fB\-W\fR
+Exclude gems that are part of the specified named group\.
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle-viz.1.ronn
@@ -0,0 +1,32 @@
+bundle-viz(1) -- Generates a visual dependency graph for your Gemfile
+=====================================================================
+
+## SYNOPSIS
+
+`bundle viz` [--file=FILE]
+             [--format=FORMAT]
+             [--requirements]
+             [--version]
+             [--without=GROUP GROUP]
+
+## DESCRIPTION
+
+`viz` generates a PNG file of the current `Gemfile(5)` as a dependency graph.
+`viz` requires the ruby-graphviz gem (and its dependencies).
+
+The associated gems must also be installed via [`bundle install(1)`](bundle-install.1.html).
+
+`viz` command was deprecated in Bundler 2.2. Use [bundler-graph plugin](https://github.com/rubygems/bundler-graph) instead.
+
+## OPTIONS
+
+* `--file`, `-f`:
+  The name to use for the generated file. See `--format` option
+* `--format`, `-F`:
+  This is output format option. Supported format is png, jpg, svg, dot ...
+* `--requirements`, `-R`:
+  Set to show the version of each required dependency.
+* `--version`, `-v`:
+  Set to show each gem version.
+* `--without`, `-W`:
+  Exclude gems that are part of the specified named group.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle.1
@@ -0,0 +1,141 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "BUNDLE" "1" "September 2022" "" ""
+.
+.SH "NAME"
+\fBbundle\fR \- Ruby Dependency Management
+.
+.SH "SYNOPSIS"
+\fBbundle\fR COMMAND [\-\-no\-color] [\-\-verbose] [ARGS]
+.
+.SH "DESCRIPTION"
+Bundler manages an \fBapplication\'s dependencies\fR through its entire life across many machines systematically and repeatably\.
+.
+.P
+See the bundler website \fIhttps://bundler\.io\fR for information on getting started, and Gemfile(5) for more information on the \fBGemfile\fR format\.
+.
+.SH "OPTIONS"
+.
+.TP
+\fB\-\-no\-color\fR
+Print all output without color
+.
+.TP
+\fB\-\-retry\fR, \fB\-r\fR
+Specify the number of times you wish to attempt network commands
+.
+.TP
+\fB\-\-verbose\fR, \fB\-V\fR
+Print out additional logging information
+.
+.SH "BUNDLE COMMANDS"
+We divide \fBbundle\fR subcommands into primary commands and utilities:
+.
+.SH "PRIMARY COMMANDS"
+.
+.TP
+\fBbundle install(1)\fR \fIbundle\-install\.1\.html\fR
+Install the gems specified by the \fBGemfile\fR or \fBGemfile\.lock\fR
+.
+.TP
+\fBbundle update(1)\fR \fIbundle\-update\.1\.html\fR
+Update dependencies to their latest versions
+.
+.TP
+\fBbundle cache(1)\fR \fIbundle\-cache\.1\.html\fR
+Package the \.gem files required by your application into the \fBvendor/cache\fR directory (aliases: \fBbundle package\fR, \fBbundle pack\fR)
+.
+.TP
+\fBbundle exec(1)\fR \fIbundle\-exec\.1\.html\fR
+Execute a script in the current bundle
+.
+.TP
+\fBbundle config(1)\fR \fIbundle\-config\.1\.html\fR
+Specify and read configuration options for Bundler
+.
+.TP
+\fBbundle help(1)\fR \fIbundle\-help\.1\.html\fR
+Display detailed help for each subcommand
+.
+.SH "UTILITIES"
+.
+.TP
+\fBbundle add(1)\fR \fIbundle\-add\.1\.html\fR
+Add the named gem to the Gemfile and run \fBbundle install\fR
+.
+.TP
+\fBbundle binstubs(1)\fR \fIbundle\-binstubs\.1\.html\fR
+Generate binstubs for executables in a gem
+.
+.TP
+\fBbundle check(1)\fR \fIbundle\-check\.1\.html\fR
+Determine whether the requirements for your application are installed and available to Bundler
+.
+.TP
+\fBbundle show(1)\fR \fIbundle\-show\.1\.html\fR
+Show the source location of a particular gem in the bundle
+.
+.TP
+\fBbundle outdated(1)\fR \fIbundle\-outdated\.1\.html\fR
+Show all of the outdated gems in the current bundle
+.
+.TP
+\fBbundle console(1)\fR (deprecated)
+Start an IRB session in the current bundle
+.
+.TP
+\fBbundle open(1)\fR \fIbundle\-open\.1\.html\fR
+Open an installed gem in the editor
+.
+.TP
+\fBbundle lock(1)\fR \fIbundle\-lock\.1\.html\fR
+Generate a lockfile for your dependencies
+.
+.TP
+\fBbundle viz(1)\fR \fIbundle\-viz\.1\.html\fR (deprecated)
+Generate a visual representation of your dependencies
+.
+.TP
+\fBbundle init(1)\fR \fIbundle\-init\.1\.html\fR
+Generate a simple \fBGemfile\fR, placed in the current directory
+.
+.TP
+\fBbundle gem(1)\fR \fIbundle\-gem\.1\.html\fR
+Create a simple gem, suitable for development with Bundler
+.
+.TP
+\fBbundle platform(1)\fR \fIbundle\-platform\.1\.html\fR
+Display platform compatibility information
+.
+.TP
+\fBbundle clean(1)\fR \fIbundle\-clean\.1\.html\fR
+Clean up unused gems in your Bundler directory
+.
+.TP
+\fBbundle doctor(1)\fR \fIbundle\-doctor\.1\.html\fR
+Display warnings about common problems
+.
+.TP
+\fBbundle remove(1)\fR \fIbundle\-remove\.1\.html\fR
+Removes gems from the Gemfile
+.
+.TP
+\fBbundle plugin(1)\fR \fIbundle\-plugin\.1\.html\fR
+Manage Bundler plugins
+.
+.TP
+\fBbundle version(1)\fR \fIbundle\-version\.1\.html\fR
+Prints Bundler version information
+.
+.SH "PLUGINS"
+When running a command that isn\'t listed in PRIMARY COMMANDS or UTILITIES, Bundler will try to find an executable on your path named \fBbundler\-<command>\fR and execute it, passing down any extra arguments to it\.
+.
+.SH "OBSOLETE"
+These commands are obsolete and should no longer be used:
+.
+.IP "\(bu" 4
+\fBbundle inject(1)\fR
+.
+.IP "" 0
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/bundle.1.ronn
@@ -0,0 +1,116 @@
+bundle(1) -- Ruby Dependency Management
+=======================================
+
+## SYNOPSIS
+
+`bundle` COMMAND [--no-color] [--verbose] [ARGS]
+
+## DESCRIPTION
+
+Bundler manages an `application's dependencies` through its entire life
+across many machines systematically and repeatably.
+
+See [the bundler website](https://bundler.io) for information on getting
+started, and Gemfile(5) for more information on the `Gemfile` format.
+
+## OPTIONS
+
+* `--no-color`:
+  Print all output without color
+
+* `--retry`, `-r`:
+  Specify the number of times you wish to attempt network commands
+
+* `--verbose`, `-V`:
+  Print out additional logging information
+
+## BUNDLE COMMANDS
+
+We divide `bundle` subcommands into primary commands and utilities:
+
+## PRIMARY COMMANDS
+
+* [`bundle install(1)`](bundle-install.1.html):
+  Install the gems specified by the `Gemfile` or `Gemfile.lock`
+
+* [`bundle update(1)`](bundle-update.1.html):
+  Update dependencies to their latest versions
+
+* [`bundle cache(1)`](bundle-cache.1.html):
+  Package the .gem files required by your application into the
+  `vendor/cache` directory (aliases: `bundle package`, `bundle pack`)
+
+* [`bundle exec(1)`](bundle-exec.1.html):
+  Execute a script in the current bundle
+
+* [`bundle config(1)`](bundle-config.1.html):
+  Specify and read configuration options for Bundler
+
+* [`bundle help(1)`](bundle-help.1.html):
+  Display detailed help for each subcommand
+
+## UTILITIES
+
+* [`bundle add(1)`](bundle-add.1.html):
+  Add the named gem to the Gemfile and run `bundle install`
+
+* [`bundle binstubs(1)`](bundle-binstubs.1.html):
+  Generate binstubs for executables in a gem
+
+* [`bundle check(1)`](bundle-check.1.html):
+  Determine whether the requirements for your application are installed
+  and available to Bundler
+
+* [`bundle show(1)`](bundle-show.1.html):
+  Show the source location of a particular gem in the bundle
+
+* [`bundle outdated(1)`](bundle-outdated.1.html):
+  Show all of the outdated gems in the current bundle
+
+* `bundle console(1)` (deprecated):
+  Start an IRB session in the current bundle
+
+* [`bundle open(1)`](bundle-open.1.html):
+  Open an installed gem in the editor
+
+* [`bundle lock(1)`](bundle-lock.1.html):
+  Generate a lockfile for your dependencies
+
+* [`bundle viz(1)`](bundle-viz.1.html) (deprecated):
+  Generate a visual representation of your dependencies
+
+* [`bundle init(1)`](bundle-init.1.html):
+  Generate a simple `Gemfile`, placed in the current directory
+
+* [`bundle gem(1)`](bundle-gem.1.html):
+  Create a simple gem, suitable for development with Bundler
+
+* [`bundle platform(1)`](bundle-platform.1.html):
+  Display platform compatibility information
+
+* [`bundle clean(1)`](bundle-clean.1.html):
+  Clean up unused gems in your Bundler directory
+
+* [`bundle doctor(1)`](bundle-doctor.1.html):
+  Display warnings about common problems
+
+* [`bundle remove(1)`](bundle-remove.1.html):
+  Removes gems from the Gemfile
+
+* [`bundle plugin(1)`](bundle-plugin.1.html):
+  Manage Bundler plugins
+
+* [`bundle version(1)`](bundle-version.1.html):
+  Prints Bundler version information
+
+## PLUGINS
+
+When running a command that isn't listed in PRIMARY COMMANDS or UTILITIES,
+Bundler will try to find an executable on your path named `bundler-<command>`
+and execute it, passing down any extra arguments to it.
+
+## OBSOLETE
+
+These commands are obsolete and should no longer be used:
+
+* `bundle inject(1)`
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/gemfile.5
@@ -0,0 +1,712 @@
+.\" generated with Ronn/v0.7.3
+.\" http://github.com/rtomayko/ronn/tree/0.7.3
+.
+.TH "GEMFILE" "5" "September 2022" "" ""
+.
+.SH "NAME"
+\fBGemfile\fR \- A format for describing gem dependencies for Ruby programs
+.
+.SH "SYNOPSIS"
+A \fBGemfile\fR describes the gem dependencies required to execute associated Ruby code\.
+.
+.P
+Place the \fBGemfile\fR in the root of the directory containing the associated code\. For instance, in a Rails application, place the \fBGemfile\fR in the same directory as the \fBRakefile\fR\.
+.
+.SH "SYNTAX"
+A \fBGemfile\fR is evaluated as Ruby code, in a context which makes available a number of methods used to describe the gem requirements\.
+.
+.SH "GLOBAL SOURCE"
+At the top of the \fBGemfile\fR, add a single line for the \fBRubyGems\fR source that contains the gems listed in the \fBGemfile\fR\.
+.
+.IP "" 4
+.
+.nf
+
+source "https://rubygems\.org"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+You can add only one global source\. In Bundler 1\.13, adding multiple global sources was deprecated\. The \fBsource\fR \fBMUST\fR be a valid RubyGems repository\.
+.
+.P
+To use more than one source of RubyGems, you should use \fI\fBsource\fR block\fR\.
+.
+.P
+A source is checked for gems following the heuristics described in \fISOURCE PRIORITY\fR\.
+.
+.P
+\fBNote about a behavior of the feature deprecated in Bundler 1\.13\fR: If a gem is found in more than one global source, Bundler will print a warning after installing the gem indicating which source was used, and listing the other sources where the gem is available\. A specific source can be selected for gems that need to use a non\-standard repository, suppressing this warning, by using the \fI\fB:source\fR option\fR or \fBsource\fR block\.
+.
+.SS "CREDENTIALS"
+Some gem sources require a username and password\. Use bundle config(1) \fIbundle\-config\.1\.html\fR to set the username and password for any of the sources that need it\. The command must be run once on each computer that will install the Gemfile, but this keeps the credentials from being stored in plain text in version control\.
+.
+.IP "" 4
+.
+.nf
+
+bundle config gems\.example\.com user:password
+.
+.fi
+.
+.IP "" 0
+.
+.P
+For some sources, like a company Gemfury account, it may be easier to include the credentials in the Gemfile as part of the source URL\.
+.
+.IP "" 4
+.
+.nf
+
+source "https://user:password@gems\.example\.com"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Credentials in the source URL will take precedence over credentials set using \fBconfig\fR\.
+.
+.SH "RUBY"
+If your application requires a specific Ruby version or engine, specify your requirements using the \fBruby\fR method, with the following arguments\. All parameters are \fBOPTIONAL\fR unless otherwise specified\.
+.
+.SS "VERSION (required)"
+The version of Ruby that your application requires\. If your application requires an alternate Ruby engine, such as JRuby, Rubinius or TruffleRuby, this should be the Ruby version that the engine is compatible with\.
+.
+.IP "" 4
+.
+.nf
+
+ruby "1\.9\.3"
+.
+.fi
+.
+.IP "" 0
+.
+.SS "ENGINE"
+Each application \fImay\fR specify a Ruby engine\. If an engine is specified, an engine version \fImust\fR also be specified\.
+.
+.P
+What exactly is an Engine? \- A Ruby engine is an implementation of the Ruby language\.
+.
+.IP "\(bu" 4
+For background: the reference or original implementation of the Ruby programming language is called Matz\'s Ruby Interpreter \fIhttps://en\.wikipedia\.org/wiki/Ruby_MRI\fR, or MRI for short\. This is named after Ruby creator Yukihiro Matsumoto, also known as Matz\. MRI is also known as CRuby, because it is written in C\. MRI is the most widely used Ruby engine\.
+.
+.IP "\(bu" 4
+Other implementations \fIhttps://www\.ruby\-lang\.org/en/about/\fR of Ruby exist\. Some of the more well\-known implementations include Rubinius \fIhttps://rubinius\.com/\fR, and JRuby \fIhttp://jruby\.org/\fR\. Rubinius is an alternative implementation of Ruby written in Ruby\. JRuby is an implementation of Ruby on the JVM, short for Java Virtual Machine\.
+.
+.IP "" 0
+.
+.SS "ENGINE VERSION"
+Each application \fImay\fR specify a Ruby engine version\. If an engine version is specified, an engine \fImust\fR also be specified\. If the engine is "ruby" the engine version specified \fImust\fR match the Ruby version\.
+.
+.IP "" 4
+.
+.nf
+
+ruby "1\.8\.7", engine: "jruby", engine_version: "1\.6\.7"
+.
+.fi
+.
+.IP "" 0
+.
+.SS "PATCHLEVEL"
+Each application \fImay\fR specify a Ruby patchlevel\.
+.
+.IP "" 4
+.
+.nf
+
+ruby "2\.0\.0", patchlevel: "247"
+.
+.fi
+.
+.IP "" 0
+.
+.SH "GEMS"
+Specify gem requirements using the \fBgem\fR method, with the following arguments\. All parameters are \fBOPTIONAL\fR unless otherwise specified\.
+.
+.SS "NAME (required)"
+For each gem requirement, list a single \fIgem\fR line\.
+.
+.IP "" 4
+.
+.nf
+
+gem "nokogiri"
+.
+.fi
+.
+.IP "" 0
+.
+.SS "VERSION"
+Each \fIgem\fR \fBMAY\fR have one or more version specifiers\.
+.
+.IP "" 4
+.
+.nf
+
+gem "nokogiri", ">= 1\.4\.2"
+gem "RedCloth", ">= 4\.1\.0", "< 4\.2\.0"
+.
+.fi
+.
+.IP "" 0
+.
+.SS "REQUIRE AS"
+Each \fIgem\fR \fBMAY\fR specify files that should be used when autorequiring via \fBBundler\.require\fR\. You may pass an array with multiple files or \fBtrue\fR if the file you want \fBrequired\fR has the same name as \fIgem\fR or \fBfalse\fR to prevent any file from being autorequired\.
+.
+.IP "" 4
+.
+.nf
+
+gem "redis", require: ["redis/connection/hiredis", "redis"]
+gem "webmock", require: false
+gem "byebug", require: true
+.
+.fi
+.
+.IP "" 0
+.
+.P
+The argument defaults to the name of the gem\. For example, these are identical:
+.
+.IP "" 4
+.
+.nf
+
+gem "nokogiri"
+gem "nokogiri", require: "nokogiri"
+gem "nokogiri", require: true
+.
+.fi
+.
+.IP "" 0
+.
+.SS "GROUPS"
+Each \fIgem\fR \fBMAY\fR specify membership in one or more groups\. Any \fIgem\fR that does not specify membership in any group is placed in the \fBdefault\fR group\.
+.
+.IP "" 4
+.
+.nf
+
+gem "rspec", group: :test
+gem "wirble", groups: [:development, :test]
+.
+.fi
+.
+.IP "" 0
+.
+.P
+The Bundler runtime allows its two main methods, \fBBundler\.setup\fR and \fBBundler\.require\fR, to limit their impact to particular groups\.
+.
+.IP "" 4
+.
+.nf
+
+# setup adds gems to Ruby\'s load path
+Bundler\.setup                    # defaults to all groups
+require "bundler/setup"          # same as Bundler\.setup
+Bundler\.setup(:default)          # only set up the _default_ group
+Bundler\.setup(:test)             # only set up the _test_ group (but `not` _default_)
+Bundler\.setup(:default, :test)   # set up the _default_ and _test_ groups, but no others
+
+# require requires all of the gems in the specified groups
+Bundler\.require                  # defaults to the _default_ group
+Bundler\.require(:default)        # identical
+Bundler\.require(:default, :test) # requires the _default_ and _test_ groups
+Bundler\.require(:test)           # requires the _test_ group
+.
+.fi
+.
+.IP "" 0
+.
+.P
+The Bundler CLI allows you to specify a list of groups whose gems \fBbundle install\fR should not install with the \fBwithout\fR configuration\.
+.
+.P
+To specify multiple groups to ignore, specify a list of groups separated by spaces\.
+.
+.IP "" 4
+.
+.nf
+
+bundle config set \-\-local without test
+bundle config set \-\-local without development test
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Also, calling \fBBundler\.setup\fR with no parameters, or calling \fBrequire "bundler/setup"\fR will setup all groups except for the ones you excluded via \fB\-\-without\fR (since they are not available)\.
+.
+.P
+Note that on \fBbundle install\fR, bundler downloads and evaluates all gems, in order to create a single canonical list of all of the required gems and their dependencies\. This means that you cannot list different versions of the same gems in different groups\. For more details, see Understanding Bundler \fIhttps://bundler\.io/rationale\.html\fR\.
+.
+.SS "PLATFORMS"
+If a gem should only be used in a particular platform or set of platforms, you can specify them\. Platforms are essentially identical to groups, except that you do not need to use the \fB\-\-without\fR install\-time flag to exclude groups of gems for other platforms\.
+.
+.P
+There are a number of \fBGemfile\fR platforms:
+.
+.TP
+\fBruby\fR
+C Ruby (MRI), Rubinius, or TruffleRuby, but not Windows
+.
+.TP
+\fBmri\fR
+C Ruby (MRI) only, but not Windows
+.
+.TP
+\fBwindows\fR
+Windows C Ruby (MRI), including RubyInstaller 32\-bit and 64\-bit versions
+.
+.TP
+\fBrbx\fR
+Rubinius
+.
+.TP
+\fBjruby\fR
+JRuby
+.
+.TP
+\fBtruffleruby\fR
+TruffleRuby
+.
+.P
+On platforms \fBruby\fR, \fBmri\fR, and \fBwindows\fR, you may additionally specify a version by appending the major and minor version numbers without a delimiter\. For example, to specify that a gem should only be used on platform \fBruby\fR version 2\.3, use:
+.
+.IP "" 4
+.
+.nf
+
+ruby_23
+.
+.fi
+.
+.IP "" 0
+.
+.P
+As with groups (above), you may specify one or more platforms:
+.
+.IP "" 4
+.
+.nf
+
+gem "weakling",   platforms: :jruby
+gem "ruby\-debug", platforms: :mri_18
+gem "nokogiri",   platforms: [:windows_26, :jruby]
+.
+.fi
+.
+.IP "" 0
+.
+.P
+All operations involving groups (\fBbundle install\fR \fIbundle\-install\.1\.html\fR, \fBBundler\.setup\fR, \fBBundler\.require\fR) behave exactly the same as if any groups not matching the current platform were explicitly excluded\.
+.
+.SS "FORCE_RUBY_PLATFORM"
+If you always want the pure ruby variant of a gem to be chosen over platform specific variants, you can use the \fBforce_ruby_platform\fR option:
+.
+.IP "" 4
+.
+.nf
+
+gem "ffi", force_ruby_platform: true
+.
+.fi
+.
+.IP "" 0
+.
+.P
+This can be handy (assuming the pure ruby variant works fine) when:
+.
+.IP "\(bu" 4
+You\'re having issues with the platform specific variant\.
+.
+.IP "\(bu" 4
+The platform specific variant does not yet support a newer ruby (and thus has a \fBrequired_ruby_version\fR upper bound), but you still want your Gemfile{\.lock} files to resolve under that ruby\.
+.
+.IP "" 0
+.
+.SS "SOURCE"
+You can select an alternate RubyGems repository for a gem using the \':source\' option\.
+.
+.IP "" 4
+.
+.nf
+
+gem "some_internal_gem", source: "https://gems\.example\.com"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+This forces the gem to be loaded from this source and ignores the global source declared at the top level of the file\. If the gem does not exist in this source, it will not be installed\.
+.
+.P
+Bundler will search for child dependencies of this gem by first looking in the source selected for the parent, but if they are not found there, it will fall back on the global source\.
+.
+.P
+\fBNote about a behavior of the feature deprecated in Bundler 1\.13\fR: Selecting a specific source repository this way also suppresses the ambiguous gem warning described above in \fIGLOBAL SOURCE\fR\.
+.
+.P
+Using the \fB:source\fR option for an individual gem will also make that source available as a possible global source for any other gems which do not specify explicit sources\. Thus, when adding gems with explicit sources, it is recommended that you also ensure all other gems in the Gemfile are using explicit sources\.
+.
+.SS "GIT"
+If necessary, you can specify that a gem is located at a particular git repository using the \fB:git\fR parameter\. The repository can be accessed via several protocols:
+.
+.TP
+\fBHTTP(S)\fR
+gem "rails", git: "https://github\.com/rails/rails\.git"
+.
+.TP
+\fBSSH\fR
+gem "rails", git: "git@github\.com:rails/rails\.git"
+.
+.TP
+\fBgit\fR
+gem "rails", git: "git://github\.com/rails/rails\.git"
+.
+.P
+If using SSH, the user that you use to run \fBbundle install\fR \fBMUST\fR have the appropriate keys available in their \fB$HOME/\.ssh\fR\.
+.
+.P
+\fBNOTE\fR: \fBhttp://\fR and \fBgit://\fR URLs should be avoided if at all possible\. These protocols are unauthenticated, so a man\-in\-the\-middle attacker can deliver malicious code and compromise your system\. HTTPS and SSH are strongly preferred\.
+.
+.P
+The \fBgroup\fR, \fBplatforms\fR, and \fBrequire\fR options are available and behave exactly the same as they would for a normal gem\.
+.
+.P
+A git repository \fBSHOULD\fR have at least one file, at the root of the directory containing the gem, with the extension \fB\.gemspec\fR\. This file \fBMUST\fR contain a valid gem specification, as expected by the \fBgem build\fR command\.
+.
+.P
+If a git repository does not have a \fB\.gemspec\fR, bundler will attempt to create one, but it will not contain any dependencies, executables, or C extension compilation instructions\. As a result, it may fail to properly integrate into your application\.
+.
+.P
+If a git repository does have a \fB\.gemspec\fR for the gem you attached it to, a version specifier, if provided, means that the git repository is only valid if the \fB\.gemspec\fR specifies a version matching the version specifier\. If not, bundler will print a warning\.
+.
+.IP "" 4
+.
+.nf
+
+gem "rails", "2\.3\.8", git: "https://github\.com/rails/rails\.git"
+# bundle install will fail, because the \.gemspec in the rails
+# repository\'s master branch specifies version 3\.0\.0
+.
+.fi
+.
+.IP "" 0
+.
+.P
+If a git repository does \fBnot\fR have a \fB\.gemspec\fR for the gem you attached it to, a version specifier \fBMUST\fR be provided\. Bundler will use this version in the simple \fB\.gemspec\fR it creates\.
+.
+.P
+Git repositories support a number of additional options\.
+.
+.TP
+\fBbranch\fR, \fBtag\fR, and \fBref\fR
+You \fBMUST\fR only specify at most one of these options\. The default is \fBbranch: "master"\fR\. For example:
+.
+.IP
+gem "rails", git: "https://github\.com/rails/rails\.git", branch: "5\-0\-stable"
+.
+.IP
+gem "rails", git: "https://github\.com/rails/rails\.git", tag: "v5\.0\.0"
+.
+.IP
+gem "rails", git: "https://github\.com/rails/rails\.git", ref: "4aded"
+.
+.TP
+\fBsubmodules\fR
+For reference, a git submodule \fIhttps://git\-scm\.com/book/en/v2/Git\-Tools\-Submodules\fR lets you have another git repository within a subfolder of your repository\. Specify \fBsubmodules: true\fR to cause bundler to expand any submodules included in the git repository
+.
+.P
+If a git repository contains multiple \fB\.gemspecs\fR, each \fB\.gemspec\fR represents a gem located at the same place in the file system as the \fB\.gemspec\fR\.
+.
+.IP "" 4
+.
+.nf
+
+|~rails                   [git root]
+| |\-rails\.gemspec         [rails gem located here]
+|~actionpack
+| |\-actionpack\.gemspec    [actionpack gem located here]
+|~activesupport
+| |\-activesupport\.gemspec [activesupport gem located here]
+|\.\.\.
+.
+.fi
+.
+.IP "" 0
+.
+.P
+To install a gem located in a git repository, bundler changes to the directory containing the gemspec, runs \fBgem build name\.gemspec\fR and then installs the resulting gem\. The \fBgem build\fR command, which comes standard with Rubygems, evaluates the \fB\.gemspec\fR in the context of the directory in which it is located\.
+.
+.SS "GIT SOURCE"
+A custom git source can be defined via the \fBgit_source\fR method\. Provide the source\'s name as an argument, and a block which receives a single argument and interpolates it into a string to return the full repo address:
+.
+.IP "" 4
+.
+.nf
+
+git_source(:stash){ |repo_name| "https://stash\.corp\.acme\.pl/#{repo_name}\.git" }
+gem \'rails\', stash: \'forks/rails\'
+.
+.fi
+.
+.IP "" 0
+.
+.P
+In addition, if you wish to choose a specific branch:
+.
+.IP "" 4
+.
+.nf
+
+gem "rails", stash: "forks/rails", branch: "branch_name"
+.
+.fi
+.
+.IP "" 0
+.
+.SS "GITHUB"
+\fBNOTE\fR: This shorthand should be avoided until Bundler 2\.0, since it currently expands to an insecure \fBgit://\fR URL\. This allows a man\-in\-the\-middle attacker to compromise your system\.
+.
+.P
+If the git repository you want to use is hosted on GitHub and is public, you can use the :github shorthand to specify the github username and repository name (without the trailing "\.git"), separated by a slash\. If both the username and repository name are the same, you can omit one\.
+.
+.IP "" 4
+.
+.nf
+
+gem "rails", github: "rails/rails"
+gem "rails", github: "rails"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Are both equivalent to
+.
+.IP "" 4
+.
+.nf
+
+gem "rails", git: "git://github\.com/rails/rails\.git"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Since the \fBgithub\fR method is a specialization of \fBgit_source\fR, it accepts a \fB:branch\fR named argument\.
+.
+.P
+You can also directly pass a pull request URL:
+.
+.IP "" 4
+.
+.nf
+
+gem "rails", github: "https://github\.com/rails/rails/pull/43753"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Which is equivalent to:
+.
+.IP "" 4
+.
+.nf
+
+gem "rails", github: "rails/rails", branch: "refs/pull/43753/head"
+.
+.fi
+.
+.IP "" 0
+.
+.SS "GIST"
+If the git repository you want to use is hosted as a GitHub Gist and is public, you can use the :gist shorthand to specify the gist identifier (without the trailing "\.git")\.
+.
+.IP "" 4
+.
+.nf
+
+gem "the_hatch", gist: "4815162342"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Is equivalent to:
+.
+.IP "" 4
+.
+.nf
+
+gem "the_hatch", git: "https://gist\.github\.com/4815162342\.git"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Since the \fBgist\fR method is a specialization of \fBgit_source\fR, it accepts a \fB:branch\fR named argument\.
+.
+.SS "BITBUCKET"
+If the git repository you want to use is hosted on Bitbucket and is public, you can use the :bitbucket shorthand to specify the bitbucket username and repository name (without the trailing "\.git"), separated by a slash\. If both the username and repository name are the same, you can omit one\.
+.
+.IP "" 4
+.
+.nf
+
+gem "rails", bitbucket: "rails/rails"
+gem "rails", bitbucket: "rails"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Are both equivalent to
+.
+.IP "" 4
+.
+.nf
+
+gem "rails", git: "https://rails@bitbucket\.org/rails/rails\.git"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+Since the \fBbitbucket\fR method is a specialization of \fBgit_source\fR, it accepts a \fB:branch\fR named argument\.
+.
+.SS "PATH"
+You can specify that a gem is located in a particular location on the file system\. Relative paths are resolved relative to the directory containing the \fBGemfile\fR\.
+.
+.P
+Similar to the semantics of the \fB:git\fR option, the \fB:path\fR option requires that the directory in question either contains a \fB\.gemspec\fR for the gem, or that you specify an explicit version that bundler should use\.
+.
+.P
+Unlike \fB:git\fR, bundler does not compile C extensions for gems specified as paths\.
+.
+.IP "" 4
+.
+.nf
+
+gem "rails", path: "vendor/rails"
+.
+.fi
+.
+.IP "" 0
+.
+.P
+If you would like to use multiple local gems directly from the filesystem, you can set a global \fBpath\fR option to the path containing the gem\'s files\. This will automatically load gemspec files from subdirectories\.
+.
+.IP "" 4
+.
+.nf
+
+path \'components\' do
+  gem \'admin_ui\'
+  gem \'public_ui\'
+end
+.
+.fi
+.
+.IP "" 0
+.
+.SH "BLOCK FORM OF SOURCE, GIT, PATH, GROUP and PLATFORMS"
+The \fB:source\fR, \fB:git\fR, \fB:path\fR, \fB:group\fR, and \fB:platforms\fR options may be applied to a group of gems by using block form\.
+.
+.IP "" 4
+.
+.nf
+
+source "https://gems\.example\.com" do
+  gem "some_internal_gem"
+  gem "another_internal_gem"
+end
+
+git "https://github\.com/rails/rails\.git" do
+  gem "activesupport"
+  gem "actionpack"
+end
+
+platforms :ruby do
+  gem "ruby\-debug"
+  gem "sqlite3"
+end
+
+group :development, optional: true do
+  gem "wirble"
+  gem "faker"
+end
+.
+.fi
+.
+.IP "" 0
+.
+.P
+In the case of the group block form the :optional option can be given to prevent a group from being installed unless listed in the \fB\-\-with\fR option given to the \fBbundle install\fR command\.
+.
+.P
+In the case of the \fBgit\fR block form, the \fB:ref\fR, \fB:branch\fR, \fB:tag\fR, and \fB:submodules\fR options may be passed to the \fBgit\fR method, and all gems in the block will inherit those options\.
+.
+.P
+The presence of a \fBsource\fR block in a Gemfile also makes that source available as a possible global source for any other gems which do not specify explicit sources\. Thus, when defining source blocks, it is recommended that you also ensure all other gems in the Gemfile are using explicit sources, either via source blocks or \fB:source\fR directives on individual gems\.
+.
+.SH "INSTALL_IF"
+The \fBinstall_if\fR method allows gems to be installed based on a proc or lambda\. This is especially useful for optional gems that can only be used if certain software is installed or some other conditions are met\.
+.
+.IP "" 4
+.
+.nf
+
+install_if \-> { RUBY_PLATFORM =~ /darwin/ } do
+  gem "pasteboard"
+end
+.
+.fi
+.
+.IP "" 0
+.
+.SH "GEMSPEC"
+The \fB\.gemspec\fR \fIhttp://guides\.rubygems\.org/specification\-reference/\fR file is where you provide metadata about your gem to Rubygems\. Some required Gemspec attributes include the name, description, and homepage of your gem\. This is also where you specify the dependencies your gem needs to run\.
+.
+.P
+If you wish to use Bundler to help install dependencies for a gem while it is being developed, use the \fBgemspec\fR method to pull in the dependencies listed in the \fB\.gemspec\fR file\.
+.
+.P
+The \fBgemspec\fR method adds any runtime dependencies as gem requirements in the default group\. It also adds development dependencies as gem requirements in the \fBdevelopment\fR group\. Finally, it adds a gem requirement on your project (\fBpath: \'\.\'\fR)\. In conjunction with \fBBundler\.setup\fR, this allows you to require project files in your test code as you would if the project were installed as a gem; you need not manipulate the load path manually or require project files via relative paths\.
+.
+.P
+The \fBgemspec\fR method supports optional \fB:path\fR, \fB:glob\fR, \fB:name\fR, and \fB:development_group\fR options, which control where bundler looks for the \fB\.gemspec\fR, the glob it uses to look for the gemspec (defaults to: "{,\fI,\fR/*}\.gemspec"), what named \fB\.gemspec\fR it uses (if more than one is present), and which group development dependencies are included in\.
+.
+.P
+When a \fBgemspec\fR dependency encounters version conflicts during resolution, the local version under development will always be selected \-\- even if there are remote versions that better match other requirements for the \fBgemspec\fR gem\.
+.
+.SH "SOURCE PRIORITY"
+When attempting to locate a gem to satisfy a gem requirement, bundler uses the following priority order:
+.
+.IP "1." 4
+The source explicitly attached to the gem (using \fB:source\fR, \fB:path\fR, or \fB:git\fR)
+.
+.IP "2." 4
+For implicit gems (dependencies of explicit gems), any source, git, or path repository declared on the parent\. This results in bundler prioritizing the ActiveSupport gem from the Rails git repository over ones from \fBrubygems\.org\fR
+.
+.IP "3." 4
+If neither of the above conditions are met, the global source will be used\. If multiple global sources are specified, they will be prioritized from last to first, but this is deprecated since Bundler 1\.13, so Bundler prints a warning and will abort with an error in the future\.
+.
+.IP "" 0
+
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/gemfile.5.ronn
@@ -0,0 +1,528 @@
+Gemfile(5) -- A format for describing gem dependencies for Ruby programs
+========================================================================
+
+## SYNOPSIS
+
+A `Gemfile` describes the gem dependencies required to execute associated
+Ruby code.
+
+Place the `Gemfile` in the root of the directory containing the associated
+code. For instance, in a Rails application, place the `Gemfile` in the same
+directory as the `Rakefile`.
+
+## SYNTAX
+
+A `Gemfile` is evaluated as Ruby code, in a context which makes available
+a number of methods used to describe the gem requirements.
+
+## GLOBAL SOURCE
+
+At the top of the `Gemfile`, add a single line for the `RubyGems` source that
+contains the gems listed in the `Gemfile`.
+
+    source "https://rubygems.org"
+
+You can add only one global source. In Bundler 1.13, adding multiple global
+sources was deprecated. The `source` `MUST` be a valid RubyGems repository.
+
+To use more than one source of RubyGems, you should use [`source` block
+](#BLOCK-FORM-OF-SOURCE-GIT-PATH-GROUP-and-PLATFORMS).
+
+A source is checked for gems following the heuristics described in
+[SOURCE PRIORITY][].
+
+**Note about a behavior of the feature deprecated in Bundler 1.13**:
+If a gem is found in more than one global source, Bundler
+will print a warning after installing the gem indicating which source was used,
+and listing the other sources where the gem is available. A specific source can
+be selected for gems that need to use a non-standard repository, suppressing
+this warning, by using the [`:source` option](#SOURCE) or `source` block.
+
+### CREDENTIALS
+
+Some gem sources require a username and password. Use [bundle config(1)](bundle-config.1.html) to set
+the username and password for any of the sources that need it. The command must
+be run once on each computer that will install the Gemfile, but this keeps the
+credentials from being stored in plain text in version control.
+
+    bundle config gems.example.com user:password
+
+For some sources, like a company Gemfury account, it may be easier to
+include the credentials in the Gemfile as part of the source URL.
+
+    source "https://user:password@gems.example.com"
+
+Credentials in the source URL will take precedence over credentials set using
+`config`.
+
+## RUBY
+
+If your application requires a specific Ruby version or engine, specify your
+requirements using the `ruby` method, with the following arguments.
+All parameters are `OPTIONAL` unless otherwise specified.
+
+### VERSION (required)
+
+The version of Ruby that your application requires. If your application
+requires an alternate Ruby engine, such as JRuby, Rubinius or TruffleRuby, this
+should be the Ruby version that the engine is compatible with.
+
+    ruby "1.9.3"
+
+### ENGINE
+
+Each application _may_ specify a Ruby engine. If an engine is specified, an
+engine version _must_ also be specified.
+
+What exactly is an Engine?
+  - A Ruby engine is an implementation of the Ruby language.
+
+  - For background: the reference or original implementation of the Ruby
+    programming language is called
+    [Matz's Ruby Interpreter](https://en.wikipedia.org/wiki/Ruby_MRI), or  MRI
+    for short. This is named after Ruby creator Yukihiro Matsumoto,
+    also known as Matz. MRI is also known as CRuby, because it is written in C.
+    MRI is the most widely used Ruby engine.
+
+  - [Other implementations](https://www.ruby-lang.org/en/about/) of Ruby exist.
+    Some of the more well-known implementations include
+    [Rubinius](https://rubinius.com/), and [JRuby](http://jruby.org/).
+    Rubinius is an alternative implementation of Ruby written in Ruby.
+    JRuby is an implementation of Ruby on the JVM, short for Java Virtual Machine.
+
+### ENGINE VERSION
+
+Each application _may_ specify a Ruby engine version. If an engine version is
+specified, an engine _must_ also be specified. If the engine is "ruby" the
+engine version specified _must_ match the Ruby version.
+
+    ruby "1.8.7", engine: "jruby", engine_version: "1.6.7"
+
+### PATCHLEVEL
+
+Each application _may_ specify a Ruby patchlevel.
+
+    ruby "2.0.0", patchlevel: "247"
+
+## GEMS
+
+Specify gem requirements using the `gem` method, with the following arguments.
+All parameters are `OPTIONAL` unless otherwise specified.
+
+### NAME (required)
+
+For each gem requirement, list a single _gem_ line.
+
+    gem "nokogiri"
+
+### VERSION
+
+Each _gem_ `MAY` have one or more version specifiers.
+
+    gem "nokogiri", ">= 1.4.2"
+    gem "RedCloth", ">= 4.1.0", "< 4.2.0"
+
+### REQUIRE AS
+
+Each _gem_ `MAY` specify files that should be used when autorequiring via
+`Bundler.require`. You may pass an array with multiple files or `true` if the file
+you want `required` has the same name as _gem_ or `false` to
+prevent any file from being autorequired.
+
+    gem "redis", require: ["redis/connection/hiredis", "redis"]
+    gem "webmock", require: false
+    gem "byebug", require: true
+
+The argument defaults to the name of the gem. For example, these are identical:
+
+    gem "nokogiri"
+    gem "nokogiri", require: "nokogiri"
+    gem "nokogiri", require: true
+
+### GROUPS
+
+Each _gem_ `MAY` specify membership in one or more groups. Any _gem_ that does
+not specify membership in any group is placed in the `default` group.
+
+    gem "rspec", group: :test
+    gem "wirble", groups: [:development, :test]
+
+The Bundler runtime allows its two main methods, `Bundler.setup` and
+`Bundler.require`, to limit their impact to particular groups.
+
+    # setup adds gems to Ruby's load path
+    Bundler.setup                    # defaults to all groups
+    require "bundler/setup"          # same as Bundler.setup
+    Bundler.setup(:default)          # only set up the _default_ group
+    Bundler.setup(:test)             # only set up the _test_ group (but `not` _default_)
+    Bundler.setup(:default, :test)   # set up the _default_ and _test_ groups, but no others
+
+    # require requires all of the gems in the specified groups
+    Bundler.require                  # defaults to the _default_ group
+    Bundler.require(:default)        # identical
+    Bundler.require(:default, :test) # requires the _default_ and _test_ groups
+    Bundler.require(:test)           # requires the _test_ group
+
+The Bundler CLI allows you to specify a list of groups whose gems `bundle install` should
+not install with the `without` configuration.
+
+To specify multiple groups to ignore, specify a list of groups separated by spaces.
+
+    bundle config set --local without test
+    bundle config set --local without development test
+
+Also, calling `Bundler.setup` with no parameters, or calling `require "bundler/setup"`
+will setup all groups except for the ones you excluded via `--without` (since they
+are not available).
+
+Note that on `bundle install`, bundler downloads and evaluates all gems, in order to
+create a single canonical list of all of the required gems and their dependencies.
+This means that you cannot list different versions of the same gems in different
+groups. For more details, see [Understanding Bundler](https://bundler.io/rationale.html).
+
+### PLATFORMS
+
+If a gem should only be used in a particular platform or set of platforms, you can
+specify them. Platforms are essentially identical to groups, except that you do not
+need to use the `--without` install-time flag to exclude groups of gems for other
+platforms.
+
+There are a number of `Gemfile` platforms:
+
+  * `ruby`:
+    C Ruby (MRI), Rubinius, or TruffleRuby, but not Windows
+  * `mri`:
+    C Ruby (MRI) only, but not Windows
+  * `windows`:
+    Windows C Ruby (MRI), including RubyInstaller 32-bit and 64-bit versions
+  * `rbx`:
+    Rubinius
+  * `jruby`:
+    JRuby
+  * `truffleruby`:
+    TruffleRuby
+
+On platforms `ruby`, `mri`, and `windows`, you may additionally specify a version
+by appending the major and minor version numbers without a delimiter. For example,
+to specify that a gem should only be used on platform `ruby` version 2.3, use:
+
+    ruby_23
+
+As with groups (above), you may specify one or more platforms:
+
+    gem "weakling",   platforms: :jruby
+    gem "ruby-debug", platforms: :mri_18
+    gem "nokogiri",   platforms: [:windows_26, :jruby]
+
+All operations involving groups ([`bundle install`](bundle-install.1.html), `Bundler.setup`,
+`Bundler.require`) behave exactly the same as if any groups not
+matching the current platform were explicitly excluded.
+
+### FORCE_RUBY_PLATFORM
+
+If you always want the pure ruby variant of a gem to be chosen over platform
+specific variants, you can use the `force_ruby_platform` option:
+
+    gem "ffi", force_ruby_platform: true
+
+This can be handy (assuming the pure ruby variant works fine) when:
+
+* You're having issues with the platform specific variant.
+* The platform specific variant does not yet support a newer ruby (and thus has
+  a `required_ruby_version` upper bound), but you still want your Gemfile{.lock}
+  files to resolve under that ruby.
+
+### SOURCE
+
+You can select an alternate RubyGems repository for a gem using the ':source'
+option.
+
+    gem "some_internal_gem", source: "https://gems.example.com"
+
+This forces the gem to be loaded from this source and ignores the global source
+declared at the top level of the file. If the gem does not exist in this source,
+it will not be installed.
+
+Bundler will search for child dependencies of this gem by first looking in the
+source selected for the parent, but if they are not found there, it will fall
+back on the global source.
+
+**Note about a behavior of the feature deprecated in Bundler 1.13**:
+Selecting a specific source repository this way also suppresses the ambiguous
+gem warning described above in [GLOBAL SOURCE](#GLOBAL-SOURCE).
+
+Using the `:source` option for an individual gem will also make that source
+available as a possible global source for any other gems which do not specify
+explicit sources. Thus, when adding gems with explicit sources, it is
+recommended that you also ensure all other gems in the Gemfile are using
+explicit sources.
+
+### GIT
+
+If necessary, you can specify that a gem is located at a particular
+git repository using the `:git` parameter. The repository can be accessed via
+several protocols:
+
+  * `HTTP(S)`:
+    gem "rails", git: "https://github.com/rails/rails.git"
+  * `SSH`:
+    gem "rails", git: "git@github.com:rails/rails.git"
+  * `git`:
+    gem "rails", git: "git://github.com/rails/rails.git"
+
+If using SSH, the user that you use to run `bundle install` `MUST` have the
+appropriate keys available in their `$HOME/.ssh`.
+
+`NOTE`: `http://` and `git://` URLs should be avoided if at all possible. These
+protocols are unauthenticated, so a man-in-the-middle attacker can deliver
+malicious code and compromise your system. HTTPS and SSH are strongly
+preferred.
+
+The `group`, `platforms`, and `require` options are available and behave
+exactly the same as they would for a normal gem.
+
+A git repository `SHOULD` have at least one file, at the root of the
+directory containing the gem, with the extension `.gemspec`. This file
+`MUST` contain a valid gem specification, as expected by the `gem build`
+command.
+
+If a git repository does not have a `.gemspec`, bundler will attempt to
+create one, but it will not contain any dependencies, executables, or
+C extension compilation instructions. As a result, it may fail to properly
+integrate into your application.
+
+If a git repository does have a `.gemspec` for the gem you attached it
+to, a version specifier, if provided, means that the git repository is
+only valid if the `.gemspec` specifies a version matching the version
+specifier. If not, bundler will print a warning.
+
+    gem "rails", "2.3.8", git: "https://github.com/rails/rails.git"
+    # bundle install will fail, because the .gemspec in the rails
+    # repository's master branch specifies version 3.0.0
+
+If a git repository does `not` have a `.gemspec` for the gem you attached
+it to, a version specifier `MUST` be provided. Bundler will use this
+version in the simple `.gemspec` it creates.
+
+Git repositories support a number of additional options.
+
+  * `branch`, `tag`, and `ref`:
+    You `MUST` only specify at most one of these options. The default
+    is `branch: "master"`.  For example:
+
+      gem "rails", git: "https://github.com/rails/rails.git", branch: "5-0-stable"
+
+      gem "rails", git: "https://github.com/rails/rails.git", tag: "v5.0.0"
+
+      gem "rails", git: "https://github.com/rails/rails.git", ref: "4aded"
+
+  * `submodules`:
+    For reference, a [git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules)
+    lets you have another git repository within a subfolder of your repository.
+    Specify `submodules: true` to cause bundler to expand any
+    submodules included in the git repository
+
+If a git repository contains multiple `.gemspecs`, each `.gemspec`
+represents a gem located at the same place in the file system as
+the `.gemspec`.
+
+    |~rails                   [git root]
+    | |-rails.gemspec         [rails gem located here]
+    |~actionpack
+    | |-actionpack.gemspec    [actionpack gem located here]
+    |~activesupport
+    | |-activesupport.gemspec [activesupport gem located here]
+    |...
+
+To install a gem located in a git repository, bundler changes to
+the directory containing the gemspec, runs `gem build name.gemspec`
+and then installs the resulting gem. The `gem build` command,
+which comes standard with Rubygems, evaluates the `.gemspec` in
+the context of the directory in which it is located.
+
+### GIT SOURCE
+
+A custom git source can be defined via the `git_source` method. Provide the source's name
+as an argument, and a block which receives a single argument and interpolates it into a
+string to return the full repo address:
+
+    git_source(:stash){ |repo_name| "https://stash.corp.acme.pl/#{repo_name}.git" }
+    gem 'rails', stash: 'forks/rails'
+
+In addition, if you wish to choose a specific branch:
+
+    gem "rails", stash: "forks/rails", branch: "branch_name"
+
+### GITHUB
+
+`NOTE`: This shorthand should be avoided until Bundler 2.0, since it
+currently expands to an insecure `git://` URL. This allows a
+man-in-the-middle attacker to compromise your system.
+
+If the git repository you want to use is hosted on GitHub and is public, you can use the
+:github shorthand to specify the github username and repository name (without the
+trailing ".git"), separated by a slash. If both the username and repository name are the
+same, you can omit one.
+
+    gem "rails", github: "rails/rails"
+    gem "rails", github: "rails"
+
+Are both equivalent to
+
+    gem "rails", git: "git://github.com/rails/rails.git"
+
+Since the `github` method is a specialization of `git_source`, it accepts a `:branch` named argument.
+
+You can also directly pass a pull request URL:
+
+    gem "rails", github: "https://github.com/rails/rails/pull/43753"
+
+Which is equivalent to:
+
+    gem "rails", github: "rails/rails", branch: "refs/pull/43753/head"
+
+### GIST
+
+If the git repository you want to use is hosted as a GitHub Gist and is public, you can use
+the :gist shorthand to specify the gist identifier (without the trailing ".git").
+
+    gem "the_hatch", gist: "4815162342"
+
+Is equivalent to:
+
+    gem "the_hatch", git: "https://gist.github.com/4815162342.git"
+
+Since the `gist` method is a specialization of `git_source`, it accepts a `:branch` named argument.
+
+### BITBUCKET
+
+If the git repository you want to use is hosted on Bitbucket and is public, you can use the
+:bitbucket shorthand to specify the bitbucket username and repository name (without the
+trailing ".git"), separated by a slash. If both the username and repository name are the
+same, you can omit one.
+
+    gem "rails", bitbucket: "rails/rails"
+    gem "rails", bitbucket: "rails"
+
+Are both equivalent to
+
+    gem "rails", git: "https://rails@bitbucket.org/rails/rails.git"
+
+Since the `bitbucket` method is a specialization of `git_source`, it accepts a `:branch` named argument.
+
+### PATH
+
+You can specify that a gem is located in a particular location
+on the file system. Relative paths are resolved relative to the
+directory containing the `Gemfile`.
+
+Similar to the semantics of the `:git` option, the `:path`
+option requires that the directory in question either contains
+a `.gemspec` for the gem, or that you specify an explicit
+version that bundler should use.
+
+Unlike `:git`, bundler does not compile C extensions for
+gems specified as paths.
+
+    gem "rails", path: "vendor/rails"
+
+If you would like to use multiple local gems directly from the filesystem, you can set a global `path` option to the path containing the gem's files. This will automatically load gemspec files from subdirectories.
+
+    path 'components' do
+      gem 'admin_ui'
+      gem 'public_ui'
+    end
+
+## BLOCK FORM OF SOURCE, GIT, PATH, GROUP and PLATFORMS
+
+The `:source`, `:git`, `:path`, `:group`, and `:platforms` options may be
+applied to a group of gems by using block form.
+
+    source "https://gems.example.com" do
+      gem "some_internal_gem"
+      gem "another_internal_gem"
+    end
+
+    git "https://github.com/rails/rails.git" do
+      gem "activesupport"
+      gem "actionpack"
+    end
+
+    platforms :ruby do
+      gem "ruby-debug"
+      gem "sqlite3"
+    end
+
+    group :development, optional: true do
+      gem "wirble"
+      gem "faker"
+    end
+
+In the case of the group block form the :optional option can be given
+to prevent a group from being installed unless listed in the `--with`
+option given to the `bundle install` command.
+
+In the case of the `git` block form, the `:ref`, `:branch`, `:tag`,
+and `:submodules` options may be passed to the `git` method, and
+all gems in the block will inherit those options.
+
+The presence of a `source` block in a Gemfile also makes that source
+available as a possible global source for any other gems which do not specify
+explicit sources. Thus, when defining source blocks, it is
+recommended that you also ensure all other gems in the Gemfile are using
+explicit sources, either via source blocks or `:source` directives on
+individual gems.
+
+## INSTALL_IF
+
+The `install_if` method allows gems to be installed based on a proc or lambda.
+This is especially useful for optional gems that can only be used if certain
+software is installed or some other conditions are met.
+
+    install_if -> { RUBY_PLATFORM =~ /darwin/ } do
+      gem "pasteboard"
+    end
+
+## GEMSPEC
+
+The [`.gemspec`](http://guides.rubygems.org/specification-reference/) file is where
+ you provide metadata about your gem to Rubygems. Some required Gemspec
+ attributes include the name, description, and homepage of your gem. This is
+ also where you specify the dependencies your gem needs to run.
+
+If you wish to use Bundler to help install dependencies for a gem while it is
+being developed, use the `gemspec` method to pull in the dependencies listed in
+the `.gemspec` file.
+
+The `gemspec` method adds any runtime dependencies as gem requirements in the
+default group. It also adds development dependencies as gem requirements in the
+`development` group. Finally, it adds a gem requirement on your project (`path:
+'.'`). In conjunction with `Bundler.setup`, this allows you to require project
+files in your test code as you would if the project were installed as a gem; you
+need not manipulate the load path manually or require project files via relative
+paths.
+
+The `gemspec` method supports optional `:path`, `:glob`, `:name`, and `:development_group`
+options, which control where bundler looks for the `.gemspec`, the glob it uses to look
+for the gemspec (defaults to: "{,*,*/*}.gemspec"), what named `.gemspec` it uses
+(if more than one is present), and which group development dependencies are included in.
+
+When a `gemspec` dependency encounters version conflicts during resolution, the
+local version under development will always be selected -- even if there are
+remote versions that better match other requirements for the `gemspec` gem.
+
+## SOURCE PRIORITY
+
+When attempting to locate a gem to satisfy a gem requirement,
+bundler uses the following priority order:
+
+  1. The source explicitly attached to the gem (using `:source`, `:path`, or
+     `:git`)
+  2. For implicit gems (dependencies of explicit gems), any source, git, or path
+     repository declared on the parent. This results in bundler prioritizing the
+     ActiveSupport gem from the Rails git repository over ones from
+     `rubygems.org`
+  3. If neither of the above conditions are met, the global source will be used.
+     If multiple global sources are specified, they will be prioritized from
+     last to first, but this is deprecated since Bundler 1.13, so Bundler prints
+     a warning and will abort with an error in the future.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/man/index.txt
@@ -0,0 +1,29 @@
+Gemfile(5)            gemfile.5
+bundle(1)             bundle.1
+bundle-add(1)         bundle-add.1
+bundle-binstubs(1)    bundle-binstubs.1
+bundle-cache(1)       bundle-cache.1
+bundle-check(1)       bundle-check.1
+bundle-clean(1)       bundle-clean.1
+bundle-config(1)      bundle-config.1
+bundle-console(1)     bundle-console.1
+bundle-doctor(1)      bundle-doctor.1
+bundle-exec(1)        bundle-exec.1
+bundle-gem(1)         bundle-gem.1
+bundle-help(1)        bundle-help.1
+bundle-info(1)        bundle-info.1
+bundle-init(1)        bundle-init.1
+bundle-inject(1)      bundle-inject.1
+bundle-install(1)     bundle-install.1
+bundle-list(1)        bundle-list.1
+bundle-lock(1)        bundle-lock.1
+bundle-open(1)        bundle-open.1
+bundle-outdated(1)    bundle-outdated.1
+bundle-platform(1)    bundle-platform.1
+bundle-plugin(1)      bundle-plugin.1
+bundle-pristine(1)    bundle-pristine.1
+bundle-remove(1)      bundle-remove.1
+bundle-show(1)        bundle-show.1
+bundle-update(1)      bundle-update.1
+bundle-version(1)     bundle-version.1
+bundle-viz(1)         bundle-viz.1
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/match_metadata.rb
@@ -0,0 +1,13 @@
+# frozen_string_literal: true
+
+module Bundler
+  module MatchMetadata
+    def matches_current_ruby?
+      @required_ruby_version.satisfied_by?(Gem.ruby_version)
+    end
+
+    def matches_current_rubygems?
+      @required_rubygems_version.satisfied_by?(Gem.rubygems_version)
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/lib/bundler/match_platform.rb
+++ ruby2.7-2.7.6/lib/bundler/match_platform.rb
@@ -15,7 +15,6 @@ module Bundler
       return true if Gem::Platform::RUBY == gemspec_platform
       return true if local_platform == gemspec_platform
       gemspec_platform = Gem::Platform.new(gemspec_platform)
-      return true if GemHelpers.generic(gemspec_platform) === local_platform
       return true if gemspec_platform === local_platform
 
       false
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/match_remote_metadata.rb
@@ -0,0 +1,29 @@
+# frozen_string_literal: true
+
+module Bundler
+  module FetchMetadata
+    # A fallback is included because the original version of the specification
+    # API didn't include that field, so some marshalled specs in the index have it
+    # set to +nil+.
+    def matches_current_ruby?
+      @required_ruby_version ||= _remote_specification.required_ruby_version || Gem::Requirement.default
+
+      super
+    end
+
+    def matches_current_rubygems?
+      # A fallback is included because the original version of the specification
+      # API didn't include that field, so some marshalled specs in the index have it
+      # set to +nil+.
+      @required_rubygems_version ||= _remote_specification.required_rubygems_version || Gem::Requirement.default
+
+      super
+    end
+  end
+
+  module MatchRemoteMetadata
+    include MatchMetadata
+
+    prepend FetchMetadata
+  end
+end
--- ruby2.7-2.7.6.orig/lib/bundler/mirror.rb
+++ ruby2.7-2.7.6/lib/bundler/mirror.rb
@@ -43,7 +43,7 @@ module Bundler
         config.update_mirror(mirror)
       end
 
-    private
+      private
 
       def fetch_valid_mirror_for(uri)
         downcased = uri.to_s.downcase
@@ -158,7 +158,7 @@ module Bundler
         end
       end
 
-    private
+      private
 
       def wait_for_writtable_socket(socket, address, timeout)
         if IO.select(nil, [socket], nil, timeout)
--- ruby2.7-2.7.6.orig/lib/bundler/plugin.rb
+++ ruby2.7-2.7.6/lib/bundler/plugin.rb
@@ -13,10 +13,11 @@ module Bundler
     class MalformattedPlugin < PluginError; end
     class UndefinedCommandError < PluginError; end
     class UnknownSourceError < PluginError; end
+    class PluginInstallError < PluginError; end
 
     PLUGIN_FILE_NAME = "plugins.rb".freeze
 
-  module_function
+    module_function
 
     def reset!
       instance_variables.each {|i| remove_instance_variable(i) }
@@ -35,16 +36,42 @@ module Bundler
     # @param [Hash] options various parameters as described in description.
     #               Refer to cli/plugin for available options
     def install(names, options)
+      raise InvalidOption, "You cannot specify `--branch` and `--ref` at the same time." if options["branch"] && options["ref"]
+
       specs = Installer.new.install(names, options)
 
       save_plugins names, specs
-    rescue PluginError => e
-      if specs
-        specs_to_delete = Hash[specs.select {|k, _v| names.include?(k) && !index.commands.values.include?(k) }]
-        specs_to_delete.values.each {|spec| Bundler.rm_rf(spec.full_gem_path) }
+    rescue PluginError
+      specs_to_delete = specs.select {|k, _v| names.include?(k) && !index.commands.values.include?(k) }
+      specs_to_delete.each_value {|spec| Bundler.rm_rf(spec.full_gem_path) }
+
+      raise
+    end
+
+    # Uninstalls plugins by the given names
+    #
+    # @param [Array<String>] names the names of plugins to be uninstalled
+    def uninstall(names, options)
+      if names.empty? && !options[:all]
+        Bundler.ui.error "No plugins to uninstall. Specify at least 1 plugin to uninstall.\n"\
+          "Use --all option to uninstall all the installed plugins."
+        return
       end
 
-      Bundler.ui.error "Failed to install plugin #{name}: #{e.message}\n  #{e.backtrace.join("\n ")}"
+      names = index.installed_plugins if options[:all]
+      if names.any?
+        names.each do |name|
+          if index.installed?(name)
+            Bundler.rm_rf(index.plugin_path(name))
+            index.unregister_plugin(name)
+            Bundler.ui.info "Uninstalled plugin #{name}"
+          else
+            Bundler.ui.error "Plugin #{name} is not installed \n"
+          end
+        end
+      else
+        Bundler.ui.info "No plugins installed"
+      end
     end
 
     # List installed plugins and commands
@@ -80,6 +107,7 @@ module Bundler
         else
           builder.eval_gemfile(gemfile)
         end
+        builder.check_primary_source_safety
         definition = builder.to_definition(nil, true)
 
         return if definition.dependencies.empty?
@@ -138,7 +166,7 @@ module Bundler
     end
 
     # To be called from Cli class to pass the command and argument to
-    # approriate plugin class
+    # appropriate plugin class
     def exec_command(command, args)
       raise UndefinedCommandError, "Command `#{command}` not found" unless command? command
 
@@ -157,7 +185,7 @@ module Bundler
       !index.source_plugin(name.to_s).nil?
     end
 
-    # @return [Class] that handles the source. The calss includes API::Source
+    # @return [Class] that handles the source. The class includes API::Source
     def source(name)
       raise UnknownSourceError, "Source #{name} not found" unless source? name
 
@@ -219,10 +247,11 @@ module Bundler
     # @param [Array<String>] names of inferred source plugins that can be ignored
     def save_plugins(plugins, specs, optional_plugins = [])
       plugins.each do |name|
+        next if index.installed?(name)
+
         spec = specs[name]
-        validate_plugin! Pathname.new(spec.full_gem_path)
-        installed = register_plugin(name, spec, optional_plugins.include?(name))
-        Bundler.ui.info "Installed plugin #{name}" if installed
+
+        save_plugin(name, spec, optional_plugins.include?(name))
       end
     end
 
@@ -237,6 +266,22 @@ module Bundler
       raise MalformattedPlugin, "#{PLUGIN_FILE_NAME} was not found in the plugin." unless plugin_file.file?
     end
 
+    # Validates and registers a plugin.
+    #
+    # @param [String] name the name of the plugin
+    # @param [Specification] spec of installed plugin
+    # @param [Boolean] optional_plugin, removed if there is conflict with any
+    #                     other plugin (used for default source plugins)
+    #
+    # @raise [PluginInstallError] if validation or registration raises any error
+    def save_plugin(name, spec, optional_plugin = false)
+      validate_plugin! Pathname.new(spec.full_gem_path)
+      installed = register_plugin(name, spec, optional_plugin)
+      Bundler.ui.info "Installed plugin #{name}" if installed
+    rescue PluginError => e
+      raise PluginInstallError, "Failed to install plugin `#{spec.name}`, due to #{e.class} (#{e.message})"
+    end
+
     # Runs the plugins.rb file in an isolated namespace, records the plugin
     # actions it registers for and then passes the data to index to be stored.
     #
@@ -283,6 +328,8 @@ module Bundler
     #
     # @param [String] name of the plugin
     def load_plugin(name)
+      return unless name && !name.empty?
+
       # Need to ensure before this that plugin root where the rest of gems
       # are installed to be on load path to support plugin deps. Currently not
       # done to avoid conflicts
--- ruby2.7-2.7.6.orig/lib/bundler/plugin/api/source.rb
+++ ruby2.7-2.7.6/lib/bundler/plugin/api/source.rb
@@ -140,6 +140,13 @@ module Bundler
           end
         end
 
+        # Set internal representation to fetch the gems/specs locally.
+        #
+        # When this is called, the source should try to fetch the specs and
+        # install from the local system.
+        def local!
+        end
+
         # Set internal representation to fetch the gems/specs from remote.
         #
         # When this is called, the source should try to fetch the specs and
@@ -237,7 +244,21 @@ module Bundler
           specs.unmet_dependency_names
         end
 
+        # Used by definition.
+        #
+        # Note: Do not override if you don't know what you are doing.
+        def spec_names
+          specs.spec_names
+        end
+
+        # Used by definition.
+        #
         # Note: Do not override if you don't know what you are doing.
+        def add_dependency_names(names)
+          @dependencies |= Array(names)
+        end
+
+        # NOTE: Do not override if you don't know what you are doing.
         def can_lock?(spec)
           spec.source == self
         end
@@ -260,10 +281,11 @@ module Bundler
         end
 
         def to_s
-          "plugin source for #{options[:type]} with uri #{uri}"
+          "plugin source for #{@type} with uri #{@uri}"
         end
+        alias_method :identifier, :to_s
 
-        # Note: Do not override if you don't know what you are doing.
+        # NOTE: Do not override if you don't know what you are doing.
         def include?(other)
           other == self
         end
@@ -272,7 +294,7 @@ module Bundler
           SharedHelpers.digest(:SHA1).hexdigest(uri)
         end
 
-        # Note: Do not override if you don't know what you are doing.
+        # NOTE: Do not override if you don't know what you are doing.
         def gem_install_dir
           Bundler.install_path
         end
@@ -287,12 +309,6 @@ module Bundler
         end
 
         # @private
-        # Returns true
-        def bundler_plugin_api_source?
-          true
-        end
-
-        # @private
         # This API on source might not be stable, and for now we expect plugins
         # to download all specs in `#specs`, so we implement the method for
         # compatibility purposes and leave it undocumented (and don't support)
--- ruby2.7-2.7.6.orig/lib/bundler/plugin/dsl.rb
+++ ruby2.7-2.7.6/lib/bundler/plugin/dsl.rb
@@ -10,7 +10,7 @@ module Bundler
       # So that we don't have to override all there methods to dummy ones
       # explicitly.
       # They will be handled by method_missing
-      [:gemspec, :gem, :path, :install_if, :platforms, :env].each {|m| undef_method m }
+      [:gemspec, :gem, :install_if, :platforms, :env].each {|m| undef_method m }
 
       # This lists the plugins that was added automatically and not specified by
       # the user.
--- ruby2.7-2.7.6.orig/lib/bundler/plugin/index.rb
+++ ruby2.7-2.7.6/lib/bundler/plugin/index.rb
@@ -71,6 +71,18 @@ module Bundler
         raise
       end
 
+      def unregister_plugin(name)
+        @commands.delete_if {|_, v| v == name }
+        @sources.delete_if {|_, v| v == name }
+        @hooks.each do |hook, names|
+          names.delete(name)
+          @hooks.delete(hook) if names.empty?
+        end
+        @plugin_paths.delete(name)
+        @load_paths.delete(name)
+        save_index
+      end
+
       # Path of default index file
       def index_file
         Plugin.root.join("index")
@@ -124,7 +136,7 @@ module Bundler
         @hooks[event] || []
       end
 
-    private
+      private
 
       # Reads the index file from the directory and initializes the instance
       # variables.
--- ruby2.7-2.7.6.orig/lib/bundler/plugin/installer.rb
+++ ruby2.7-2.7.6/lib/bundler/plugin/installer.rb
@@ -16,15 +16,13 @@ module Bundler
 
         version = options[:version] || [">= 0"]
 
-        Bundler.settings.temporary(:disable_multisource => false) do
-          if options[:git]
-            install_git(names, version, options)
-          elsif options[:local_git]
-            install_local_git(names, version, options)
-          else
-            sources = options[:source] || Bundler.rubygems.sources
-            install_rubygems(names, version, sources)
-          end
+        if options[:git]
+          install_git(names, version, options)
+        elsif options[:local_git]
+          install_local_git(names, version, options)
+        else
+          sources = options[:source] || Gem.sources
+          install_rubygems(names, version, sources)
         end
       end
 
@@ -41,7 +39,7 @@ module Bundler
         install_from_specs specs
       end
 
-    private
+      private
 
       def check_sources_consistency!(options)
         if options.key?(:git) && options.key?(:local_git)
@@ -79,10 +77,12 @@ module Bundler
         source_list = SourceList.new
 
         source_list.add_git_source(git_source_options) if git_source_options
-        source_list.add_rubygems_source("remotes" => rubygems_source) if rubygems_source
+        Array(rubygems_source).each {|remote| source_list.add_global_rubygems_remote(remote) } if rubygems_source
 
         deps = names.map {|name| Dependency.new name, version }
 
+        Bundler.configure_gem_home_and_path(Plugin.root)
+
         definition = Definition.new(nil, deps, source_list, true)
         install_definition(definition)
       end
--- ruby2.7-2.7.6.orig/lib/bundler/plugin/installer/git.rb
+++ ruby2.7-2.7.6/lib/bundler/plugin/installer/git.rb
@@ -20,10 +20,6 @@ module Bundler
           end
         end
 
-        def version_message(spec)
-          "#{spec.name} #{spec.version}"
-        end
-
         def root
           Plugin.root
         end
--- ruby2.7-2.7.6.orig/lib/bundler/plugin/installer/rubygems.rb
+++ ruby2.7-2.7.6/lib/bundler/plugin/installer/rubygems.rb
@@ -4,11 +4,7 @@ module Bundler
   module Plugin
     class Installer
       class Rubygems < Bundler::Source::Rubygems
-        def version_message(spec)
-          "#{spec.name} #{spec.version}"
-        end
-
-      private
+        private
 
         def requires_sudo?
           false # Will change on implementation of project level plugins
--- ruby2.7-2.7.6.orig/lib/bundler/plugin/source_list.rb
+++ ruby2.7-2.7.6/lib/bundler/plugin/source_list.rb
@@ -17,7 +17,11 @@ module Bundler
         path_sources + git_sources + rubygems_sources + [metadata_source]
       end
 
-    private
+      def default_source
+        git_sources.first || global_rubygems_source
+      end
+
+      private
 
       def rubygems_aggregate_class
         Plugin::Installer::Rubygems
--- ruby2.7-2.7.6.orig/lib/bundler/process_lock.rb
+++ ruby2.7-2.7.6/lib/bundler/process_lock.rb
@@ -12,7 +12,7 @@ module Bundler
         yield
         f.flock(File::LOCK_UN)
       end
-    rescue Errno::EACCES, Errno::ENOLCK, *[SharedHelpers.const_get_safely(:ENOTSUP, Errno)].compact
+    rescue Errno::EACCES, Errno::ENOLCK, Errno::ENOTSUP, Errno::EPERM, Errno::EROFS
       # In the case the user does not have access to
       # create the lock file or is using NFS where
       # locks are not available we skip locking.
--- ruby2.7-2.7.6.orig/lib/bundler/psyched_yaml.rb
+++ /dev/null
@@ -1,37 +0,0 @@
-# frozen_string_literal: true
-
-# Psych could be a gem, so try to ask for it
-begin
-  gem "psych"
-rescue LoadError
-end if defined?(gem)
-
-# Psych could be in the stdlib
-# but it's too late if Syck is already loaded
-begin
-  require "psych" unless defined?(Syck)
-rescue LoadError
-  # Apparently Psych wasn't available. Oh well.
-end
-
-# At least load the YAML stdlib, whatever that may be
-require "yaml" unless defined?(YAML.dump)
-
-module Bundler
-  # On encountering invalid YAML,
-  # Psych raises Psych::SyntaxError
-  if defined?(::Psych::SyntaxError)
-    YamlLibrarySyntaxError = ::Psych::SyntaxError
-  else # Syck raises ArgumentError
-    YamlLibrarySyntaxError = ::ArgumentError
-  end
-end
-
-require_relative "deprecate"
-begin
-  Bundler::Deprecate.skip_during do
-    require "rubygems/safe_yaml"
-  end
-rescue LoadError
-  # it's OK if the file isn't there
-end
--- ruby2.7-2.7.6.orig/lib/bundler/remote_specification.rb
+++ ruby2.7-2.7.6/lib/bundler/remote_specification.rb
@@ -6,6 +6,7 @@ module Bundler
   # be seeded with what we're given from the source's abbreviated index - the
   # full specification will only be fetched when necessary.
   class RemoteSpecification
+    include MatchRemoteMetadata
     include MatchPlatform
     include Comparable
 
@@ -16,7 +17,8 @@ module Bundler
     def initialize(name, version, platform, spec_fetcher)
       @name         = name
       @version      = Gem::Version.create version
-      @platform     = platform
+      @original_platform = platform || Gem::Platform::RUBY
+      @platform     = Gem::Platform.new(platform)
       @spec_fetcher = spec_fetcher
       @dependencies = nil
     end
@@ -28,10 +30,10 @@ module Bundler
     end
 
     def full_name
-      if platform == Gem::Platform::RUBY || platform.nil?
+      if @original_platform == Gem::Platform::RUBY
         "#{@name}-#{@version}"
       else
-        "#{@name}-#{@version}-#{platform}"
+        "#{@name}-#{@version}-#{@original_platform}"
       end
     end
 
@@ -50,6 +52,8 @@ module Bundler
     # once the remote gem is downloaded, the backend specification will
     # be swapped out.
     def __swap__(spec)
+      raise APIResponseInvalidDependenciesError unless spec.dependencies.all? {|d| d.is_a?(Gem::Dependency) }
+
       SharedHelpers.ensure_same_dependencies(self, dependencies, spec.dependencies)
       @_remote_specification = spec
     end
@@ -76,7 +80,8 @@ module Bundler
         deps = method_missing(:dependencies)
 
         # allow us to handle when the specs dependencies are an array of array of string
-        # see https://github.com/bundler/bundler/issues/5797
+        # in order to delay the crash to `#__swap__` where it results in a friendlier error
+        # see https://github.com/rubygems/bundler/issues/5797
         deps = deps.map {|d| d.is_a?(Gem::Dependency) ? d : Gem::Dependency.new(*d) }
 
         deps
@@ -88,14 +93,14 @@ module Bundler
       " #{source.revision[0..6]}"
     end
 
-  private
+    private
 
     def to_ary
       nil
     end
 
     def _remote_specification
-      @_remote_specification ||= @spec_fetcher.fetch_spec([@name, @version, @platform])
+      @_remote_specification ||= @spec_fetcher.fetch_spec([@name, @version, @original_platform])
       @_remote_specification || raise(GemspecError, "Gemspec data for #{full_name} was" \
         " missing from the server! Try installing with `--full-index` as a workaround.")
     end
--- ruby2.7-2.7.6.orig/lib/bundler/resolver.rb
+++ ruby2.7-2.7.6/lib/bundler/resolver.rb
@@ -3,8 +3,11 @@
 module Bundler
   class Resolver
     require_relative "vendored_molinillo"
+    require_relative "resolver/base"
     require_relative "resolver/spec_group"
 
+    include GemHelpers
+
     # Figures out the best possible configuration of gems that satisfies
     # the list of passed dependencies and any child dependencies without
     # causing any gem activation errors.
@@ -15,48 +18,56 @@ module Bundler
     # ==== Returns
     # <GemBundle>,nil:: If the list of dependencies can be resolved, a
     #   collection of gemspecs is returned. Otherwise, nil is returned.
-    def self.resolve(requirements, index, source_requirements = {}, base = [], gem_version_promoter = GemVersionPromoter.new, additional_base_requirements = [], platforms = nil)
-      platforms = Set.new(platforms) if platforms
+    def self.resolve(requirements, source_requirements = {}, base = [], gem_version_promoter = GemVersionPromoter.new, additional_base_requirements = [], platforms = nil)
       base = SpecSet.new(base) unless base.is_a?(SpecSet)
-      resolver = new(index, source_requirements, base, gem_version_promoter, additional_base_requirements, platforms)
-      result = resolver.start(requirements)
-      SpecSet.new(result)
+      resolver = new(source_requirements, base, gem_version_promoter, additional_base_requirements, platforms)
+      resolver.start(requirements)
     end
 
-    def initialize(index, source_requirements, base, gem_version_promoter, additional_base_requirements, platforms)
-      @index = index
+    def initialize(source_requirements, base, gem_version_promoter, additional_base_requirements, platforms)
       @source_requirements = source_requirements
-      @base = base
+      @base = Resolver::Base.new(base, additional_base_requirements)
       @resolver = Molinillo::Resolver.new(self, self)
+      @results_for = {}
       @search_for = {}
-      @base_dg = Molinillo::DependencyGraph.new
-      @base.each do |ls|
-        dep = Dependency.new(ls.name, ls.version)
-        @base_dg.add_vertex(ls.name, DepProxy.new(dep, ls.platform), true)
-      end
-      additional_base_requirements.each {|d| @base_dg.add_vertex(d.name, d) }
       @platforms = platforms
+      @resolving_only_for_ruby = platforms == [Gem::Platform::RUBY]
       @gem_version_promoter = gem_version_promoter
-      @allow_bundler_dependency_conflicts = Bundler.feature_flag.allow_bundler_dependency_conflicts?
-      @use_gvp = Bundler.feature_flag.use_gem_version_promoter_for_major_updates? || !@gem_version_promoter.major?
-      @lockfile_uses_separate_rubygems_sources = Bundler.feature_flag.disable_multisource?
     end
 
-    def start(requirements)
+    def start(requirements, exclude_specs: [])
+      @metadata_requirements, regular_requirements = requirements.partition {|dep| dep.name.end_with?("\0") }
+
+      exclude_specs.each do |spec|
+        remove_from_candidates(spec)
+      end
+
       @gem_version_promoter.prerelease_specified = @prerelease_specified = {}
       requirements.each {|dep| @prerelease_specified[dep.name] ||= dep.prerelease? }
 
       verify_gemfile_dependencies_are_found!(requirements)
-      dg = @resolver.resolve(requirements, @base_dg)
-      dg.
-        tap {|resolved| validate_resolved_specs!(resolved) }.
+      result = @resolver.resolve(requirements).
         map(&:payload).
         reject {|sg| sg.name.end_with?("\0") }.
         map(&:to_specs).
         flatten
+
+      SpecSet.new(SpecSet.new(result).for(regular_requirements, false, @platforms))
     rescue Molinillo::VersionConflict => e
+      conflicts = e.conflicts
+
+      deps_to_unlock = conflicts.values.inject([]) do |deps, conflict|
+        deps |= conflict.requirement_trees.flatten.map {|req| base_requirements[req.name] }.compact
+      end
+
+      if deps_to_unlock.any?
+        @base.unlock_deps(deps_to_unlock)
+        reset_spec_cache
+        retry
+      end
+
       message = version_conflict_message(e)
-      raise VersionConflict.new(e.conflicts.keys.uniq, message)
+      raise VersionConflict.new(conflicts.keys.uniq, message)
     rescue Molinillo::CircularDependencyError => e
       names = e.dependencies.sort_by(&:name).map {|d| "gem '#{d.name}'" }
       raise CyclicDependencyError, "Your bundle requires gems that depend" \
@@ -75,12 +86,17 @@ module Bundler
       return unless debug?
       debug_info = yield
       debug_info = debug_info.inspect unless debug_info.is_a?(String)
-      warn debug_info.split("\n").map {|s| "  " * depth + s }
+      puts debug_info.split("\n").map {|s| depth == 0 ? "BUNDLER: #{s}" : "BUNDLER(#{depth}): #{s}" }
     end
 
     def debug?
       return @debug_mode if defined?(@debug_mode)
-      @debug_mode = ENV["DEBUG_RESOLVER"] || ENV["DEBUG_RESOLVER_TREE"] || false
+      @debug_mode =
+        ENV["BUNDLER_DEBUG_RESOLVER"] ||
+        ENV["BUNDLER_DEBUG_RESOLVER_TREE"] ||
+        ENV["DEBUG_RESOLVER"] ||
+        ENV["DEBUG_RESOLVER_TREE"] ||
+        false
     end
 
     def before_resolution
@@ -101,69 +117,62 @@ module Bundler
       specification.dependencies_for_activated_platforms
     end
 
-    def search_for(dependency)
-      platform = dependency.__platform
-      dependency = dependency.dep unless dependency.is_a? Gem::Dependency
-      search = @search_for[dependency] ||= begin
-        index = index_for(dependency)
-        results = index.search(dependency, @base[dependency.name])
-
-        if vertex = @base_dg.vertex_named(dependency.name)
-          locked_requirement = vertex.payload.requirement
-        end
+    def search_for(dependency_proxy)
+      platform = dependency_proxy.__platform
+      dependency = dependency_proxy.dep
+      name = dependency.name
+      @search_for[dependency_proxy] ||= begin
+        locked_results = @base[name].select {|spec| requirement_satisfied_by?(dependency, nil, spec) }
+        locked_requirement = base_requirements[name]
+        results = results_for(dependency) + locked_results
+        results = results.select {|spec| requirement_satisfied_by?(locked_requirement, nil, spec) } if locked_requirement
 
-        if !@prerelease_specified[dependency.name] && (!@use_gvp || locked_requirement.nil?)
+        if !@prerelease_specified[name] && locked_results.empty?
           # Move prereleases to the beginning of the list, so they're considered
           # last during resolution.
           pre, results = results.partition {|spec| spec.version.prerelease? }
           results = pre + results
         end
 
-        spec_groups = if results.any?
-          nested = []
-          results.each do |spec|
-            version, specs = nested.last
-            if version == spec.version
-              specs << spec
-            else
-              nested << [spec.version, [spec]]
+        if results.any?
+          results = @gem_version_promoter.sort_versions(dependency, results)
+
+          results.group_by(&:version).reduce([]) do |groups, (_, specs)|
+            next groups unless specs.any? {|spec| spec.match_platform(platform) }
+
+            specs_by_platform = Hash.new do |current_specs, current_platform|
+              current_specs[current_platform] = select_best_platform_match(specs, current_platform)
             end
-          end
-          nested.reduce([]) do |groups, (version, specs)|
-            next groups if locked_requirement && !locked_requirement.satisfied_by?(version)
-            spec_group = SpecGroup.new(specs)
-            spec_group.ignores_bundler_dependencies = @allow_bundler_dependency_conflicts
+
+            spec_group_ruby = SpecGroup.create_for(specs_by_platform, [Gem::Platform::RUBY], Gem::Platform::RUBY)
+            if spec_group_ruby
+              spec_group_ruby.force_ruby_platform = dependency.force_ruby_platform
+              groups << spec_group_ruby
+            end
+
+            next groups if @resolving_only_for_ruby || dependency.force_ruby_platform
+
+            spec_group = SpecGroup.create_for(specs_by_platform, @platforms, platform)
             groups << spec_group
+
+            groups
           end
         else
           []
         end
-        # GVP handles major itself, but it's still a bit risky to trust it with it
-        # until we get it settled with new behavior. For 2.x it can take over all cases.
-        if !@use_gvp
-          spec_groups
-        else
-          @gem_version_promoter.sort_versions(dependency, spec_groups)
-        end
       end
-      search.select {|sg| sg.for?(platform) }.each {|sg| sg.activate_platform!(platform) }
     end
 
     def index_for(dependency)
-      source = @source_requirements[dependency.name]
-      if source
-        source.specs
-      elsif @lockfile_uses_separate_rubygems_sources
-        Index.build do |idx|
-          if dependency.all_sources
-            dependency.all_sources.each {|s| idx.add_source(s.specs) if s }
-          else
-            idx.add_source @source_requirements[:default].specs
-          end
-        end
-      else
-        @index
-      end
+      source_for(dependency.name).specs
+    end
+
+    def source_for(name)
+      @source_requirements[name] || @source_requirements[:default]
+    end
+
+    def results_for(dependency)
+      @results_for[dependency] ||= index_for(dependency).search(dependency)
     end
 
     def name_for(dependency)
@@ -176,35 +185,20 @@ module Bundler
       "Gemfile"
     end
 
-    def name_for_locking_dependency_source
-      Bundler.default_lockfile.basename.to_s
-    rescue StandardError
-      "Gemfile.lock"
-    end
-
     def requirement_satisfied_by?(requirement, activated, spec)
-      return false unless requirement.matches_spec?(spec) || spec.source.is_a?(Source::Gemspec)
-      spec.activate_platform!(requirement.__platform) if !@platforms || @platforms.include?(requirement.__platform)
-      true
+      requirement.matches_spec?(spec) || spec.source.is_a?(Source::Gemspec)
     end
 
-    def relevant_sources_for_vertex(vertex)
-      if vertex.root?
-        [@source_requirements[vertex.name]]
-      elsif @lockfile_uses_separate_rubygems_sources
-        vertex.recursive_predecessors.map do |v|
-          @source_requirements[v.name]
-        end << @source_requirements[:default]
-      end
+    def dependencies_equal?(dependencies, other_dependencies)
+      dependencies.map(&:dep) == other_dependencies.map(&:dep)
     end
 
     def sort_dependencies(dependencies, activated, conflicts)
       dependencies.sort_by do |dependency|
-        dependency.all_sources = relevant_sources_for_vertex(activated.vertex_named(dependency.name))
         name = name_for(dependency)
         vertex = activated.vertex_named(name)
         [
-          @base_dg.vertex_named(name) ? 0 : 1,
+          @base[name].any? ? 0 : 1,
           vertex.payload ? 0 : 1,
           vertex.root? ? 0 : 1,
           amount_constrained(dependency),
@@ -215,19 +209,34 @@ module Bundler
       end
     end
 
-    # Sort platforms from most general to most specific
-    def self.sort_platforms(platforms)
-      platforms.sort_by do |platform|
-        platform_sort_key(platform)
-      end
+    def self.platform_sort_key(platform)
+      # Prefer specific platform to not specific platform
+      return ["99-LAST", "", "", ""] if Gem::Platform::RUBY == platform
+      ["00", *platform.to_a.map {|part| part || "" }]
     end
 
-    def self.platform_sort_key(platform)
-      return ["", "", ""] if Gem::Platform::RUBY == platform
-      platform.to_a.map {|part| part || "" }
+    private
+
+    def base_requirements
+      @base.base_requirements
     end
 
-  private
+    def remove_from_candidates(spec)
+      @base.delete(spec)
+
+      @results_for.keys.each do |dep|
+        next unless dep.name == spec.name
+
+        @results_for[dep].reject {|s| s.name == spec.name && s.version == spec.version }
+      end
+
+      reset_spec_cache
+    end
+
+    def reset_spec_cache
+      @search_for = {}
+      @gem_version_promoter.reset
+    end
 
     # returns an integer \in (-\infty, 0]
     # a number closer to 0 means the dependency is less constraining
@@ -237,34 +246,27 @@ module Bundler
     # before dependencies that are unconstrained
     def amount_constrained(dependency)
       @amount_constrained ||= {}
-      @amount_constrained[dependency.name] ||= begin
-        if (base = @base[dependency.name]) && !base.empty?
-          dependency.requirement.satisfied_by?(base.first.version) ? 0 : 1
-        else
-          all = index_for(dependency).search(dependency.name).size
+      @amount_constrained[dependency.name] ||= if (base = @base[dependency.name]) && !base.empty?
+        dependency.requirement.satisfied_by?(base.first.version) ? 0 : 1
+      else
+        all = index_for(dependency).search(dependency.name).size
 
-          if all <= 1
-            all - 1_000_000
-          else
-            search = search_for(dependency)
-            search = @prerelease_specified[dependency.name] ? search.count : search.count {|s| !s.version.prerelease? }
-            search - all
-          end
+        if all <= 1
+          all - 1_000_000
+        else
+          search = search_for(dependency)
+          search = @prerelease_specified[dependency.name] ? search.count : search.count {|s| !s.version.prerelease? }
+          search - all
         end
       end
     end
 
     def verify_gemfile_dependencies_are_found!(requirements)
-      requirements.each do |requirement|
+      requirements.map! do |requirement|
         name = requirement.name
-        next if name == "bundler"
-        next unless search_for(requirement).empty?
-
-        cache_message = begin
-                            " or in gems cached in #{Bundler.settings.app_cache_path}" if Bundler.app_cache.exist?
-                          rescue GemfileNotFound
-                            nil
-                          end
+        next requirement if name == "bundler"
+        next requirement unless search_for(requirement).empty?
+        next unless requirement.current_platform?
 
         if (base = @base[name]) && !base.empty?
           version = base.first.version
@@ -274,148 +276,150 @@ module Bundler
             "Try running `bundle update #{name}`\n\n" \
             "If you are updating multiple gems in your Gemfile at once,\n" \
             "try passing them all to `bundle update`"
-        elsif source = @source_requirements[name]
-          specs = source.specs[name]
-          versions_with_platforms = specs.map {|s| [s.version, s.platform] }
-          message = String.new("Could not find gem '#{SharedHelpers.pretty_dependency(requirement)}' in #{source}#{cache_message}.\n")
-          message << if versions_with_platforms.any?
-            "The source contains '#{name}' at: #{formatted_versions_with_platforms(versions_with_platforms)}"
-          else
-            "The source does not contain any versions of '#{name}'"
-          end
         else
-          message = "Could not find gem '#{requirement}' in any of the gem sources " \
-            "listed in your Gemfile#{cache_message}."
+          message = gem_not_found_message(name, requirement, source_for(name))
         end
         raise GemNotFound, message
-      end
+      end.compact!
     end
 
-    def formatted_versions_with_platforms(versions_with_platforms)
-      version_platform_strs = versions_with_platforms.map do |vwp|
-        version = vwp.first
-        platform = vwp.last
-        version_platform_str = String.new(version.to_s)
-        version_platform_str << " #{platform}" unless platform.nil? || platform == Gem::Platform::RUBY
-        version_platform_str
+    def gem_not_found_message(name, requirement, source, extra_message = "")
+      specs = source.specs.search(name)
+      matching_part = name
+      requirement_label = SharedHelpers.pretty_dependency(requirement)
+      cache_message = begin
+                          " or in gems cached in #{Bundler.settings.app_cache_path}" if Bundler.app_cache.exist?
+                        rescue GemfileNotFound
+                          nil
+                        end
+      specs_matching_requirement = specs.select {| spec| requirement.matches_spec?(spec) }
+
+      if specs_matching_requirement.any?
+        specs = specs_matching_requirement
+        matching_part = requirement_label
+        requirement_label = "#{requirement_label}' with platform '#{requirement.__platform}"
       end
-      version_platform_strs.join(", ")
+
+      message = String.new("Could not find gem '#{requirement_label}'#{extra_message} in #{source}#{cache_message}.\n")
+
+      if specs.any?
+        message << "\nThe source contains the following gems matching '#{matching_part}':\n"
+        message << specs.map {|s| "  * #{s.full_name}" }.join("\n")
+      end
+
+      message
     end
 
     def version_conflict_message(e)
       # only show essential conflicts, if possible
       conflicts = e.conflicts.dup
-      conflicts.delete_if do |_name, conflict|
-        deps = conflict.requirement_trees.map(&:last).flatten(1)
-        !Bundler::VersionRanges.empty?(*Bundler::VersionRanges.for_many(deps.map(&:requirement)))
+
+      if conflicts["bundler"]
+        conflicts.replace("bundler" => conflicts["bundler"])
+      else
+        conflicts.delete_if do |_name, conflict|
+          deps = conflict.requirement_trees.map(&:last).flatten(1)
+          !Bundler::VersionRanges.empty?(*Bundler::VersionRanges.for_many(deps.map(&:requirement)))
+        end
       end
+
       e = Molinillo::VersionConflict.new(conflicts, e.specification_provider) unless conflicts.empty?
 
-      solver_name = "Bundler"
-      possibility_type = "gem"
       e.message_with_trees(
-        :solver_name => solver_name,
-        :possibility_type => possibility_type,
-        :reduce_trees => lambda do |trees|
+        :full_message_for_conflict => lambda do |name, conflict|
+          trees = conflict.requirement_trees
+
           # called first, because we want to reduce the amount of work required to find maximal empty sets
           trees = trees.uniq {|t| t.flatten.map {|dep| [dep.name, dep.requirement] } }
 
           # bail out if tree size is too big for Array#combination to make any sense
-          return trees if trees.size > 15
-          maximal = 1.upto(trees.size).map do |size|
-            trees.map(&:last).flatten(1).combination(size).to_a
-          end.flatten(1).select do |deps|
-            Bundler::VersionRanges.empty?(*Bundler::VersionRanges.for_many(deps.map(&:requirement)))
-          end.min_by(&:size)
-
-          trees.reject! {|t| !maximal.include?(t.last) } if maximal
-
-          trees.sort_by {|t| t.reverse.map(&:name) }
-        end,
-        :printable_requirement => lambda {|req| SharedHelpers.pretty_dependency(req) },
-        :additional_message_for_conflict => lambda do |o, name, conflict|
-          if name == "bundler"
-            o << %(\n  Current Bundler version:\n    bundler (#{Bundler::VERSION}))
-            other_bundler_required = !conflict.requirement.requirement.satisfied_by?(Gem::Version.new(Bundler::VERSION))
-          end
+          if trees.size <= 15
+            maximal = 1.upto(trees.size).map do |size|
+              trees.map(&:last).flatten(1).combination(size).to_a
+            end.flatten(1).select do |deps|
+              Bundler::VersionRanges.empty?(*Bundler::VersionRanges.for_many(deps.map(&:requirement)))
+            end.min_by(&:size)
 
-          if name == "bundler" && other_bundler_required
-            o << "\n"
-            o << "This Gemfile requires a different version of Bundler.\n"
-            o << "Perhaps you need to update Bundler by running `gem install bundler`?\n"
+            trees.reject! {|t| !maximal.include?(t.last) } if maximal
+
+            trees.sort_by! {|t| t.reverse.map(&:name) }
           end
-          if conflict.locked_requirement
-            o << "\n"
-            o << %(Running `bundle update` will rebuild your snapshot from scratch, using only\n)
-            o << %(the gems in your Gemfile, which may resolve the conflict.\n)
-          elsif !conflict.existing
-            o << "\n"
 
-            relevant_sources = if conflict.requirement.source
-              [conflict.requirement.source]
-            elsif conflict.requirement.all_sources
-              conflict.requirement.all_sources
-            elsif @lockfile_uses_separate_rubygems_sources
-              # every conflict should have an explicit group of sources when we
-              # enforce strict pinning
-              raise "no source set for #{conflict}"
+          if trees.size > 1 || name == "bundler"
+            o = if name.end_with?("\0")
+              String.new("Bundler found conflicting requirements for the #{name} version:")
             else
-              []
-            end.compact.map(&:to_s).uniq.sort
+              String.new("Bundler could not find compatible versions for gem \"#{name}\":")
+            end
+            o << %(\n)
+            o << %(  In #{name_for_explicit_dependency_source}:\n)
+            o << trees.map do |tree|
+              t = "".dup
+              depth = 2
+
+              base_tree = tree.first
+              base_tree_name = base_tree.name
+
+              if base_tree_name.end_with?("\0")
+                t = nil
+              else
+                tree.each do |req|
+                  t << "  " * depth << SharedHelpers.pretty_dependency(req)
+                  unless tree.last == req
+                    if spec = conflict.activated_by_name[req.name]
+                      t << %( was resolved to #{spec.version}, which)
+                    end
+                    t << %( depends on)
+                  end
+                  t << %(\n)
+                  depth += 1
+                end
+              end
+              t
+            end.compact.join("\n")
+          else
+            o = String.new
+          end
 
-            metadata_requirement = name.end_with?("\0")
+          if name == "bundler"
+            o << %(\n  Current Bundler version:\n    bundler (#{Bundler::VERSION}))
 
-            o << "Could not find gem '" unless metadata_requirement
-            o << SharedHelpers.pretty_dependency(conflict.requirement)
-            o << "'" unless metadata_requirement
-            if conflict.requirement_trees.first.size > 1
-              o << ", which is required by "
-              o << "gem '#{SharedHelpers.pretty_dependency(conflict.requirement_trees.first[-2])}',"
+            conflict_dependency = conflict.requirement
+            conflict_requirement = conflict_dependency.requirement
+            other_bundler_required = !conflict_requirement.satisfied_by?(Gem::Version.new(Bundler::VERSION))
+
+            if other_bundler_required
+              o << "\n\n"
+
+              candidate_specs = source_for(:default_bundler).specs.search(conflict_dependency)
+              if candidate_specs.any?
+                target_version = candidate_specs.last.version
+                new_command = [File.basename($PROGRAM_NAME), "_#{target_version}_", *ARGV].join(" ")
+                o << "Your bundle requires a different version of Bundler than the one you're running.\n"
+                o << "Install the necessary version with `gem install bundler:#{target_version}` and rerun bundler using `#{new_command}`\n"
+              else
+                o << "Your bundle requires a different version of Bundler than the one you're running, and that version could not be found.\n"
+              end
             end
-            o << " "
+          elsif name.end_with?("\0")
+            o << %(\n  Current #{name} version:\n    #{SharedHelpers.pretty_dependency(@metadata_requirements.find {|req| req.name == name })}\n\n)
+          elsif !conflict.existing
+            o << "\n"
+
+            relevant_source = conflict.requirement.source || source_for(name)
 
-            o << if relevant_sources.empty?
-              "in any of the sources.\n"
-            elsif metadata_requirement
-              "is not available in #{relevant_sources.join(" or ")}"
+            extra_message = if trees.first.size > 1
+              ", which is required by gem '#{SharedHelpers.pretty_dependency(trees.first[-2])}',"
             else
-              "in any of the relevant sources:\n  #{relevant_sources * "\n  "}\n"
+              ""
             end
+
+            o << gem_not_found_message(name, conflict.requirement, relevant_source, extra_message)
           end
-        end,
-        :version_for_spec => lambda {|spec| spec.version },
-        :incompatible_version_message_for_conflict => lambda do |name, _conflict|
-          if name.end_with?("\0")
-            %(#{solver_name} found conflicting requirements for the #{name} version:)
-          else
-            %(#{solver_name} could not find compatible versions for #{possibility_type} "#{name}":)
-          end
-        end
-      )
-    end
 
-    def validate_resolved_specs!(resolved_specs)
-      resolved_specs.each do |v|
-        name = v.name
-        next unless sources = relevant_sources_for_vertex(v)
-        sources.compact!
-        if default_index = sources.index(@source_requirements[:default])
-          sources.delete_at(default_index)
+          o
         end
-        sources.reject! {|s| s.specs[name].empty? }
-        sources.uniq!
-        next if sources.size <= 1
-
-        multisource_disabled = Bundler.feature_flag.disable_multisource?
-
-        msg = ["The gem '#{name}' was found in multiple relevant sources."]
-        msg.concat sources.map {|s| "  * #{s}" }.sort
-        msg << "You #{multisource_disabled ? :must : :should} add this gem to the source block for the source you wish it to be installed from."
-        msg = msg.join("\n")
-
-        raise SecurityError, msg if multisource_disabled
-        Bundler.ui.warn "Warning: #{msg}"
-      end
+      )
     end
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/resolver/base.rb
@@ -0,0 +1,50 @@
+# frozen_string_literal: true
+
+module Bundler
+  class Resolver
+    class Base
+      def initialize(base, additional_base_requirements)
+        @base = base
+        @additional_base_requirements = additional_base_requirements
+      end
+
+      def [](name)
+        @base[name]
+      end
+
+      def delete(spec)
+        @base.delete(spec)
+      end
+
+      def base_requirements
+        @base_requirements ||= build_base_requirements
+      end
+
+      def unlock_deps(deps)
+        exact, lower_bound = deps.partition(&:specific?)
+
+        exact.each do |exact_dep|
+          @base.delete_by_name_and_version(exact_dep.name, exact_dep.requirement.requirements.first.last)
+        end
+
+        lower_bound.each do |lower_bound_dep|
+          @additional_base_requirements.delete(lower_bound_dep)
+        end
+
+        @base_requirements = nil
+      end
+
+      private
+
+      def build_base_requirements
+        base_requirements = {}
+        @base.each do |ls|
+          dep = Dependency.new(ls.name, ls.version)
+          base_requirements[ls.name] = DepProxy.get_proxy(dep, ls.platform)
+        end
+        @additional_base_requirements.each {|d| base_requirements[d.name] = d }
+        base_requirements
+      end
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/lib/bundler/resolver/spec_group.rb
+++ ruby2.7-2.7.6/lib/bundler/resolver/spec_group.rb
@@ -3,61 +3,59 @@
 module Bundler
   class Resolver
     class SpecGroup
-      include GemHelpers
-
       attr_accessor :name, :version, :source
-      attr_accessor :ignores_bundler_dependencies
+      attr_accessor :activated_platforms, :force_ruby_platform
+
+      def self.create_for(specs, all_platforms, specific_platform)
+        specific_platform_specs = specs[specific_platform]
+        return unless specific_platform_specs.any?
+
+        platforms = all_platforms.select {|p| specs[p].any? }
+
+        new(specific_platform_specs.first, specs, platforms)
+      end
 
-      def initialize(all_specs)
-        raise ArgumentError, "cannot initialize with an empty value" unless exemplary_spec = all_specs.first
+      def initialize(exemplary_spec, specs, relevant_platforms)
+        @exemplary_spec = exemplary_spec
         @name = exemplary_spec.name
         @version = exemplary_spec.version
         @source = exemplary_spec.source
 
-        @activated_platforms = []
-        @dependencies = nil
-        @specs        = Hash.new do |specs, platform|
-          specs[platform] = select_best_platform_match(all_specs, platform)
+        @activated_platforms = relevant_platforms
+        @dependencies = Hash.new do |dependencies, platforms|
+          dependencies[platforms] = dependencies_for(platforms)
         end
-        @ignores_bundler_dependencies = true
+        @specs = specs
       end
 
       def to_specs
-        @activated_platforms.map do |p|
-          next unless s = @specs[p]
-          lazy_spec = LazySpecification.new(name, version, s.platform, source)
-          lazy_spec.dependencies.replace s.dependencies
-          lazy_spec
-        end.compact
-      end
-
-      def activate_platform!(platform)
-        return unless for?(platform)
-        return if @activated_platforms.include?(platform)
-        @activated_platforms << platform
-      end
-
-      def for?(platform)
-        spec = @specs[platform]
-        !spec.nil?
+        activated_platforms.map do |p|
+          specs = @specs[p]
+          next unless specs.any?
+
+          specs.map do |s|
+            lazy_spec = LazySpecification.new(name, version, s.platform, source)
+            lazy_spec.force_ruby_platform = force_ruby_platform
+            lazy_spec.dependencies.replace s.dependencies
+            lazy_spec
+          end
+        end.flatten.compact.uniq
       end
 
       def to_s
-        @to_s ||= "#{name} (#{version})"
+        activated_platforms_string = sorted_activated_platforms.join(", ")
+        "#{name} (#{version}) (#{activated_platforms_string})"
       end
 
       def dependencies_for_activated_platforms
-        dependencies = @activated_platforms.map {|p| __dependencies[p] }
-        metadata_dependencies = @activated_platforms.map do |platform|
-          metadata_dependencies(@specs[platform], platform)
-        end
-        dependencies.concat(metadata_dependencies).flatten
+        @dependencies[activated_platforms]
       end
 
       def ==(other)
         return unless other.is_a?(SpecGroup)
         name == other.name &&
           version == other.version &&
+          sorted_activated_platforms == other.sorted_activated_platforms &&
           source == other.source
       end
 
@@ -65,43 +63,52 @@ module Bundler
         return unless other.is_a?(SpecGroup)
         name.eql?(other.name) &&
           version.eql?(other.version) &&
+          sorted_activated_platforms.eql?(other.sorted_activated_platforms) &&
           source.eql?(other.source)
       end
 
       def hash
-        to_s.hash ^ source.hash
+        name.hash ^ version.hash ^ sorted_activated_platforms.hash ^ source.hash
       end
 
-    private
+      protected
 
-      def __dependencies
-        @dependencies = Hash.new do |dependencies, platform|
-          dependencies[platform] = []
-          if spec = @specs[platform]
-            spec.dependencies.each do |dep|
-              next if dep.type == :development
-              next if @ignores_bundler_dependencies && dep.name == "bundler".freeze
-              dependencies[platform] << DepProxy.new(dep, platform)
-            end
-          end
-          dependencies[platform]
-        end
+      def sorted_activated_platforms
+        activated_platforms.sort_by(&:to_s)
       end
 
-      def metadata_dependencies(spec, platform)
-        return [] unless spec
-        # Only allow endpoint specifications since they won't hit the network to
-        # fetch the full gemspec when calling required_ruby_version
-        return [] if !spec.is_a?(EndpointSpecification) && !spec.is_a?(Gem::Specification)
+      private
+
+      def dependencies_for(platforms)
+        platforms.map do |platform|
+          __dependencies(platform) + metadata_dependencies(platform)
+        end.flatten
+      end
+
+      def __dependencies(platform)
         dependencies = []
-        if !spec.required_ruby_version.nil? && !spec.required_ruby_version.none?
-          dependencies << DepProxy.new(Gem::Dependency.new("Ruby\0", spec.required_ruby_version), platform)
-        end
-        if !spec.required_rubygems_version.nil? && !spec.required_rubygems_version.none?
-          dependencies << DepProxy.new(Gem::Dependency.new("RubyGems\0", spec.required_rubygems_version), platform)
+        @specs[platform].first.dependencies.each do |dep|
+          next if dep.type == :development
+          dependencies << DepProxy.get_proxy(Dependency.new(dep.name, dep.requirement), platform)
         end
         dependencies
       end
+
+      def metadata_dependencies(platform)
+        spec = @specs[platform].first
+        return [] if spec.is_a?(LazySpecification)
+
+        [
+          metadata_dependency("Ruby", spec.required_ruby_version, platform),
+          metadata_dependency("RubyGems", spec.required_rubygems_version, platform),
+        ].compact
+      end
+
+      def metadata_dependency(name, requirement, platform)
+        return if requirement.nil? || requirement.none?
+
+        DepProxy.get_proxy(Dependency.new("#{name}\0", requirement), platform)
+      end
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/retry.rb
+++ ruby2.7-2.7.6/lib/bundler/retry.rb
@@ -32,7 +32,7 @@ module Bundler
     end
     alias_method :attempts, :attempt
 
-  private
+    private
 
     def run(&block)
       @failed = false
@@ -49,7 +49,7 @@ module Bundler
         raise e
       end
       return true unless name
-      Bundler.ui.info "" unless Bundler.ui.debug? # Add new line incase dots preceded this
+      Bundler.ui.info "" unless Bundler.ui.debug? # Add new line in case dots preceded this
       Bundler.ui.warn "Retrying #{name} due to error (#{current_run.next}/#{total_runs}): #{e.class} #{e.message}", Bundler.ui.debug?
     end
 
--- ruby2.7-2.7.6.orig/lib/bundler/ruby_dsl.rb
+++ ruby2.7-2.7.6/lib/bundler/ruby_dsl.rb
@@ -9,7 +9,7 @@ module Bundler
       raise GemfileError, "Please define :engine" if options[:engine_version] && options[:engine].nil?
 
       if options[:engine] == "ruby" && options[:engine_version] &&
-          ruby_version != Array(options[:engine_version])
+         ruby_version != Array(options[:engine_version])
         raise GemfileEvalError, "ruby_version must match the :engine_version for MRI"
       end
       @ruby_version = RubyVersion.new(ruby_version, options[:patchlevel], options[:engine], options[:engine_version])
--- ruby2.7-2.7.6.orig/lib/bundler/ruby_version.rb
+++ ruby2.7-2.7.6/lib/bundler/ruby_version.rb
@@ -32,12 +32,12 @@ module Bundler
       @engine             = engine && engine.to_s || "ruby"
       @engine_versions    = (engine_version && Array(engine_version)) || @versions
       @engine_gem_version = Gem::Requirement.create(@engine_versions.first).requirements.first.last
-      @patchlevel         = patchlevel
+      @patchlevel         = patchlevel || (@gem_version.prerelease? ? "-1" : nil)
     end
 
     def to_s(versions = self.versions)
       output = String.new("ruby #{versions_string(versions)}")
-      output << "p#{patchlevel}" if patchlevel
+      output << "p#{patchlevel}" if patchlevel && patchlevel != "-1"
       output << " (#{engine} #{versions_string(engine_versions)})" unless engine == "ruby"
 
       output
@@ -46,7 +46,7 @@ module Bundler
     # @private
     PATTERN = /
       ruby\s
-      ([\d.]+) # ruby version
+      (\d+\.\d+\.\d+(?:\.\S+)?) # ruby version
       (?:p(-?\d+))? # optional patchlevel
       (?:\s\((\S+)\s(.+)\))? # optional engine info
     /xo.freeze
@@ -103,27 +103,14 @@ module Bundler
 
     def self.system
       ruby_engine = RUBY_ENGINE.dup
-      ruby_version = ENV.fetch("BUNDLER_SPEC_RUBY_VERSION") { RUBY_VERSION }.dup
-      ruby_engine_version = RUBY_ENGINE_VERSION.dup
+      ruby_version = Gem.ruby_version.to_s
+      ruby_engine_version = RUBY_ENGINE == "ruby" ? ruby_version : RUBY_ENGINE_VERSION.dup
       patchlevel = RUBY_PATCHLEVEL.to_s
 
       @ruby_version ||= RubyVersion.new(ruby_version, patchlevel, ruby_engine, ruby_engine_version)
     end
 
-    def to_gem_version_with_patchlevel
-      @gem_version_with_patch ||= begin
-        Gem::Version.create("#{@gem_version}.#{@patchlevel}")
-      rescue ArgumentError
-        @gem_version
-      end
-    end
-
-    def exact?
-      return @exact if defined?(@exact)
-      @exact = versions.all? {|v| Gem::Requirement.create(v).exact? }
-    end
-
-  private
+    private
 
     def matches?(requirements, version)
       # Handles RUBY_PATCHLEVEL of -1 for instances like ruby-head
--- ruby2.7-2.7.6.orig/lib/bundler/rubygems_ext.rb
+++ ruby2.7-2.7.6/lib/bundler/rubygems_ext.rb
@@ -4,14 +4,34 @@ require "pathname"
 
 require "rubygems/specification"
 
-# Possible use in Gem::Specification#source below and require
-# shouldn't be deferred.
+# We can't let `Gem::Source` be autoloaded in the `Gem::Specification#source`
+# redefinition below, so we need to load it upfront. The reason is that if
+# Bundler monkeypatches are loaded before RubyGems activates an executable (for
+# example, through `ruby -rbundler -S irb`), gem activation might end up calling
+# the redefined `Gem::Specification#source` and triggering the `Gem::Source`
+# autoload. That would result in requiring "rubygems/source" inside another
+# require, which would trigger a monitor error and cause the `autoload` to
+# eventually fail. A better solution is probably to completely avoid autoloading
+# `Gem::Source` from the redefined `Gem::Specification#source`.
 require "rubygems/source"
 
+require_relative "match_metadata"
 require_relative "match_platform"
 
+# Cherry-pick fixes to `Gem.ruby_version` to be useful for modern Bundler
+# versions and ignore patchlevels
+# (https://github.com/rubygems/rubygems/pull/5472,
+# https://github.com/rubygems/rubygems/pull/5486). May be removed once RubyGems
+# 3.3.12 support is dropped.
+unless Gem.ruby_version.to_s == RUBY_VERSION || RUBY_PATCHLEVEL == -1
+  Gem.instance_variable_set(:@ruby_version, Gem::Version.new(RUBY_VERSION))
+end
+
 module Gem
   class Specification
+    include ::Bundler::MatchMetadata
+    include ::Bundler::MatchPlatform
+
     attr_accessor :remote, :location, :relative_loaded_from
 
     remove_method :source
@@ -24,12 +44,8 @@ module Gem
     alias_method :rg_loaded_from,   :loaded_from
 
     def full_gem_path
-      # this cannot check source.is_a?(Bundler::Plugin::API::Source)
-      # because that _could_ trip the autoload, and if there are unresolved
-      # gems at that time, this method could be called inside another require,
-      # thus raising with that constant being undefined. Better to check a method
-      if source.respond_to?(:path) || (source.respond_to?(:bundler_plugin_api_source?) && source.bundler_plugin_api_source?)
-        Pathname.new(loaded_from).dirname.expand_path(source.root).to_s.tap{|x| x.untaint if RUBY_VERSION < "2.7" }
+      if source.respond_to?(:root)
+        Pathname.new(loaded_from).dirname.expand_path(source.root).to_s.tap {|x| x.untaint if RUBY_VERSION < "2.7" }
       else
         rg_full_gem_path
       end
@@ -47,14 +63,13 @@ module Gem
       full_require_paths
     end
 
-    if method_defined?(:extension_dir)
-      alias_method :rg_extension_dir, :extension_dir
-      def extension_dir
-        @bundler_extension_dir ||= if source.respond_to?(:extension_dir_name)
-          File.expand_path(File.join(extensions_dir, source.extension_dir_name))
-        else
-          rg_extension_dir
-        end
+    alias_method :rg_extension_dir, :extension_dir
+    def extension_dir
+      @bundler_extension_dir ||= if source.respond_to?(:extension_dir_name)
+        unique_extension_dir = [source.extension_dir_name, File.basename(full_gem_path)].uniq.join("-")
+        File.expand_path(File.join(extensions_dir, unique_extension_dir))
+      else
+        rg_extension_dir
       end
     end
 
@@ -63,6 +78,23 @@ module Gem
       full_gem_path
     end
 
+    unless const_defined?(:LATEST_RUBY_WITHOUT_PATCH_VERSIONS)
+      LATEST_RUBY_WITHOUT_PATCH_VERSIONS = Gem::Version.new("2.1")
+
+      alias_method :rg_required_ruby_version=, :required_ruby_version=
+      def required_ruby_version=(req)
+        self.rg_required_ruby_version = req
+
+        @required_ruby_version.requirements.map! do |op, v|
+          if v >= LATEST_RUBY_WITHOUT_PATCH_VERSIONS && v.release.segments.size == 4
+            [op == "~>" ? "=" : op, Gem::Version.new(v.segments.tap {|s| s.delete_at(3) }.join("."))]
+          else
+            [op, v]
+          end
+        end
+      end
+    end
+
     def groups
       @groups ||= []
     end
@@ -82,11 +114,26 @@ module Gem
       gemfile
     end
 
+    # Backfill missing YAML require when not defined. Fixed since 3.1.0.pre1.
+    module YamlBackfiller
+      def to_yaml(opts = {})
+        Gem.load_yaml unless defined?(::YAML)
+
+        super(opts)
+      end
+    end
+
+    prepend YamlBackfiller
+
     def nondevelopment_dependencies
       dependencies - development_dependencies
     end
 
-  private
+    def deleted_gem?
+      !default_gem? && !File.directory?(full_gem_path)
+    end
+
+    private
 
     def dependencies_to_gemfile(dependencies, group = nil)
       gemfile = String.new
@@ -106,10 +153,14 @@ module Gem
   end
 
   class Dependency
-    attr_accessor :source, :groups, :all_sources
+    attr_accessor :source, :groups
 
     alias_method :eql?, :==
 
+    def force_ruby_platform
+      false
+    end
+
     def encode_with(coder)
       to_yaml_properties.each do |ivar|
         coder[ivar.to_s.sub(/^@/, "")] = instance_variable_get(ivar)
@@ -117,7 +168,7 @@ module Gem
     end
 
     def to_yaml_properties
-      instance_variables.reject {|p| ["@source", "@groups", "@all_sources"].include?(p.to_s) }
+      instance_variables.reject {|p| ["@source", "@groups"].include?(p.to_s) }
     end
 
     def to_lock
@@ -130,25 +181,135 @@ module Gem
     end
   end
 
+  # comparison is done order independently since rubygems 3.2.0.rc.2
+  unless Gem::Requirement.new("> 1", "< 2") == Gem::Requirement.new("< 2", "> 1")
+    class Requirement
+      module OrderIndependentComparison
+        def ==(other)
+          return unless Gem::Requirement === other
+
+          if _requirements_sorted? && other._requirements_sorted?
+            super
+          else
+            _with_sorted_requirements == other._with_sorted_requirements
+          end
+        end
+
+        protected
+
+        def _requirements_sorted?
+          return @_are_requirements_sorted if defined?(@_are_requirements_sorted)
+          strings = as_list
+          @_are_requirements_sorted = strings == strings.sort
+        end
+
+        def _with_sorted_requirements
+          @_with_sorted_requirements ||= _requirements_sorted? ? self : self.class.new(as_list.sort)
+        end
+      end
+
+      prepend OrderIndependentComparison
+    end
+  end
+
+  if Gem::Requirement.new("~> 2.0").hash == Gem::Requirement.new("~> 2.0.0").hash
+    class Requirement
+      module CorrectHashForLambdaOperator
+        def hash
+          if requirements.any? {|r| r.first == "~>" }
+            requirements.map {|r| r.first == "~>" ? [r[0], r[1].to_s] : r }.sort.hash
+          else
+            super
+          end
+        end
+      end
+
+      prepend CorrectHashForLambdaOperator
+    end
+  end
+
+  require "rubygems/platform"
+
   class Platform
-    JAVA  = Gem::Platform.new("java") unless defined?(JAVA)
-    MSWIN = Gem::Platform.new("mswin32") unless defined?(MSWIN)
-    MSWIN64 = Gem::Platform.new("mswin64") unless defined?(MSWIN64)
-    MINGW = Gem::Platform.new("x86-mingw32") unless defined?(MINGW)
-    X64_MINGW = Gem::Platform.new("x64-mingw32") unless defined?(X64_MINGW)
-
-    undef_method :hash if method_defined? :hash
-    def hash
-      @cpu.hash ^ @os.hash ^ @version.hash
+    JAVA  = Gem::Platform.new("java")
+    MSWIN = Gem::Platform.new("mswin32")
+    MSWIN64 = Gem::Platform.new("mswin64")
+    MINGW = Gem::Platform.new("x86-mingw32")
+    X64_MINGW = [Gem::Platform.new("x64-mingw32"),
+                 Gem::Platform.new("x64-mingw-ucrt")].freeze
+    WINDOWS = [MSWIN, MSWIN64, MINGW, X64_MINGW].flatten.freeze
+    X64_LINUX = Gem::Platform.new("x86_64-linux")
+    X64_LINUX_MUSL = Gem::Platform.new("x86_64-linux-musl")
+
+    if X64_LINUX === X64_LINUX_MUSL
+      remove_method :===
+
+      def ===(other)
+        return nil unless Gem::Platform === other
+
+        # universal-mingw32 matches x64-mingw-ucrt
+        return true if (@cpu == "universal" || other.cpu == "universal") &&
+                       @os.start_with?("mingw") && other.os.start_with?("mingw")
+
+        # cpu
+        ([nil,"universal"].include?(@cpu) || [nil, "universal"].include?(other.cpu) || @cpu == other.cpu ||
+        (@cpu == "arm" && other.cpu.start_with?("arm"))) &&
+
+          # os
+          @os == other.os &&
+
+          # version
+          (
+            (@os != "linux" && (@version.nil? || other.version.nil?)) ||
+            (@os == "linux" && (other.version == "gnu#{@version}" || other.version == "musl#{@version}" || @version == "gnu#{other.version}")) ||
+            @version == other.version
+          )
+      end
+    end
+  end
+
+  Platform.singleton_class.module_eval do
+    unless Platform.singleton_methods.include?(:match_spec?)
+      def match_spec?(spec)
+        match_gem?(spec.platform, spec.name)
+      end
+
+      def match_gem?(platform, gem_name)
+        match_platforms?(platform, Gem.platforms)
+      end
     end
 
-    undef_method :eql? if method_defined? :eql?
-    alias_method :eql?, :==
+    match_platforms_defined = Gem::Platform.respond_to?(:match_platforms?, true)
+
+    if !match_platforms_defined || Gem::Platform.send(:match_platforms?, Gem::Platform::X64_LINUX_MUSL, [Gem::Platform::X64_LINUX])
+
+      private
+
+      remove_method :match_platforms? if match_platforms_defined
+
+      def match_platforms?(platform, platforms)
+        platforms.any? do |local_platform|
+          platform.nil? ||
+            local_platform == platform ||
+            (local_platform != Gem::Platform::RUBY && platform =~ local_platform)
+        end
+      end
+    end
   end
-end
 
-module Gem
-  class Specification
-    include ::Bundler::MatchPlatform
+  require "rubygems/util"
+
+  Util.singleton_class.module_eval do
+    if Util.singleton_methods.include?(:glob_files_in_dir) # since 3.0.0.beta.2
+      remove_method :glob_files_in_dir
+    end
+
+    def glob_files_in_dir(glob, base_path)
+      if RUBY_VERSION >= "2.5"
+        Dir.glob(glob, :base => base_path).map! {|f| File.expand_path(f, base_path) }
+      else
+        Dir.glob(File.join(base_path.to_s.gsub(/[\[\]]/, '\\\\\\&'), glob)).map! {|f| File.expand_path(f) }
+      end
+    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/rubygems_gem_installer.rb
+++ ruby2.7-2.7.6/lib/bundler/rubygems_gem_installer.rb
@@ -4,14 +4,60 @@ require "rubygems/installer"
 
 module Bundler
   class RubyGemsGemInstaller < Gem::Installer
-    unless respond_to?(:at)
-      def self.at(*args)
-        new(*args)
+    def check_executable_overwrite(filename)
+      # Bundler needs to install gems regardless of binstub overwriting
+    end
+
+    def install
+      pre_install_checks
+
+      run_pre_install_hooks
+
+      spec.loaded_from = spec_file
+
+      # Completely remove any previous gem files
+      strict_rm_rf gem_dir
+      strict_rm_rf spec.extension_dir
+
+      SharedHelpers.filesystem_access(gem_dir, :create) do
+        FileUtils.mkdir_p gem_dir, :mode => 0o755
       end
+
+      extract_files
+
+      build_extensions if spec.extensions.any?
+      write_build_info_file
+      run_post_build_hooks
+
+      generate_bin
+      generate_plugins
+
+      write_spec
+
+      SharedHelpers.filesystem_access("#{gem_home}/cache", :write) do
+        write_cache_file
+      end
+
+      say spec.post_install_message unless spec.post_install_message.nil?
+
+      run_post_install_hooks
+
+      spec
     end
 
-    def check_executable_overwrite(filename)
-      # Bundler needs to install gems regardless of binstub overwriting
+    def generate_plugins
+      return unless Gem::Installer.instance_methods(false).include?(:generate_plugins)
+
+      latest = Gem::Specification.stubs_for(spec.name).first
+      return if latest && latest.version > spec.version
+
+      ensure_writable_dir @plugins_dir
+
+      if spec.plugins.empty?
+        remove_plugins_for(spec, @plugins_dir)
+      else
+        regenerate_plugins_for(spec, @plugins_dir)
+      end
     end
 
     def pre_install_checks
@@ -20,27 +66,52 @@ module Bundler
 
     def build_extensions
       extension_cache_path = options[:bundler_extension_cache_path]
-      return super unless extension_cache_path && extension_dir = Bundler.rubygems.spec_extension_dir(spec)
+      extension_dir = spec.extension_dir
+      unless extension_cache_path && extension_dir
+        prepare_extension_build(extension_dir)
+        return super
+      end
 
-      extension_dir = Pathname.new(extension_dir)
       build_complete = SharedHelpers.filesystem_access(extension_cache_path.join("gem.build_complete"), :read, &:file?)
       if build_complete && !options[:force]
-        SharedHelpers.filesystem_access(extension_dir.parent, &:mkpath)
+        SharedHelpers.filesystem_access(File.dirname(extension_dir)) do |p|
+          FileUtils.mkpath p
+        end
         SharedHelpers.filesystem_access(extension_cache_path) do
-          FileUtils.cp_r extension_cache_path, spec.extension_dir
+          FileUtils.cp_r extension_cache_path, extension_dir
         end
       else
+        prepare_extension_build(extension_dir)
         super
-        if extension_dir.directory? # not made for gems without extensions
-          SharedHelpers.filesystem_access(extension_cache_path.parent, &:mkpath)
-          SharedHelpers.filesystem_access(extension_cache_path) do
-            FileUtils.cp_r extension_dir, extension_cache_path
-          end
+        SharedHelpers.filesystem_access(extension_cache_path.parent, &:mkpath)
+        SharedHelpers.filesystem_access(extension_cache_path) do
+          FileUtils.cp_r extension_dir, extension_cache_path
         end
       end
     end
 
-  private
+    def spec
+      if Bundler.rubygems.provides?("< 3.3.12") # RubyGems implementation rescues and re-raises errors before 3.3.12 and we don't want that
+        @package.spec
+      else
+        super
+      end
+    end
+
+    private
+
+    def prepare_extension_build(extension_dir)
+      SharedHelpers.filesystem_access(extension_dir, :create) do
+        FileUtils.mkdir_p extension_dir
+      end
+      require "shellwords" unless Bundler.rubygems.provides?(">= 3.2.25")
+    end
+
+    def strict_rm_rf(dir)
+      Bundler.rm_rf dir
+    rescue Errno::ENOTEMPTY => e
+      raise DirectoryRemovalError.new(e.cause, "Could not delete previous installation of `#{dir}`")
+    end
 
     def validate_bundler_checksum(checksum)
       return true if Bundler.settings[:disable_checksum_validation]
@@ -66,7 +137,7 @@ module Bundler
 
           If you wish to continue installing the downloaded gem, and are certain it does not pose a \
           security issue despite the mismatching checksum, do the following:
-          1. run `bundle config set disable_checksum_validation true` to turn off checksum verification
+          1. run `bundle config set --local disable_checksum_validation true` to turn off checksum verification
           2. run `bundle install`
 
           (More info: The expected SHA256 checksum was #{checksum.inspect}, but the \
--- ruby2.7-2.7.6.orig/lib/bundler/rubygems_integration.rb
+++ ruby2.7-2.7.6/lib/bundler/rubygems_integration.rb
@@ -12,32 +12,30 @@ module Bundler
       EXT_LOCK = Monitor.new
     end
 
-    def self.version
-      @version ||= Gem::Version.new(Gem::VERSION)
-    end
-
-    def self.provides?(req_str)
-      Gem::Requirement.new(req_str).satisfied_by?(version)
-    end
-
     def initialize
       @replaced_methods = {}
       backport_ext_builder_monitor
     end
 
     def version
-      self.class.version
+      @version ||= Gem.rubygems_version
     end
 
     def provides?(req_str)
-      self.class.provides?(req_str)
+      Gem::Requirement.new(req_str).satisfied_by?(version)
+    end
+
+    def supports_bundler_trampolining?
+      provides?(">= 3.3.0.a")
     end
 
     def build_args
+      require "rubygems/command"
       Gem::Command.build_args
     end
 
     def build_args=(args)
+      require "rubygems/command"
       Gem::Command.build_args = args
     end
 
@@ -84,16 +82,12 @@ module Bundler
     def spec_missing_extensions?(spec, default = true)
       return spec.missing_extensions? if spec.respond_to?(:missing_extensions?)
 
-      return false if spec_default_gem?(spec)
+      return false if spec.default_gem?
       return false if spec.extensions.empty?
 
       default
     end
 
-    def spec_default_gem?(spec)
-      spec.respond_to?(:default_gem?) && spec.default_gem?
-    end
-
     def spec_matches_for_glob(spec, glob)
       return spec.matches_for_glob(glob) if spec.respond_to?(:matches_for_glob)
 
@@ -102,11 +96,6 @@ module Bundler
       end.flatten(1)
     end
 
-    def spec_extension_dir(spec)
-      return unless spec.respond_to?(:extension_dir)
-      spec.extension_dir
-    end
-
     def stub_set_spec(stub, spec)
       stub.instance_variable_set(:@spec, spec)
     end
@@ -115,23 +104,6 @@ module Bundler
       obj.to_s
     end
 
-    def platforms
-      return [Gem::Platform::RUBY] if Bundler.settings[:force_ruby_platform]
-      Gem.platforms
-    end
-
-    def configuration
-      require_relative "psyched_yaml"
-      Gem.configuration
-    rescue Gem::SystemExitException, LoadError => e
-      Bundler.ui.error "#{e.class}: #{e.message}"
-      Bundler.ui.trace e
-      raise
-    rescue YamlLibrarySyntaxError => e
-      raise YamlSyntaxError.new(e, "Your RubyGems configuration, which is " \
-        "usually located in ~/.gemrc, contains invalid YAML syntax.")
-    end
-
     def ruby_engine
       Gem.ruby_engine
     end
@@ -141,14 +113,10 @@ module Bundler
     end
 
     def inflate(obj)
-      require "rubygems/util"
-
       Gem::Util.inflate(obj)
     end
 
     def correct_for_windows_path(path)
-      require "rubygems/util"
-
       if Gem::Util.respond_to?(:correct_for_windows_path)
         Gem::Util.correct_for_windows_path(path)
       elsif path[0].chr == "/" && path[1].chr =~ /[a-z]/i && path[2].chr == ":"
@@ -158,19 +126,6 @@ module Bundler
       end
     end
 
-    def sources=(val)
-      # Gem.configuration creates a new Gem::ConfigFile, which by default will read ~/.gemrc
-      # If that file exists, its settings (including sources) will overwrite the values we
-      # are about to set here. In order to avoid that, we force memoizing the config file now.
-      configuration
-
-      Gem.sources = val
-    end
-
-    def sources
-      Gem.sources
-    end
-
     def gem_dir
       Gem.dir
     end
@@ -223,11 +178,6 @@ module Bundler
       Gem.bin_path(gem, bin, ver)
     end
 
-    def preserve_paths
-      # this is a no-op outside of RubyGems 1.8
-      yield
-    end
-
     def loaded_gem_paths
       loaded_gem_paths = Gem.loaded_specs.map {|_, s| s.full_require_paths }
       loaded_gem_paths.flatten
@@ -241,6 +191,10 @@ module Bundler
       Gem.load_plugin_files(files) if Gem.respond_to?(:load_plugin_files)
     end
 
+    def load_env_plugins
+      Gem.load_env_plugins if Gem.respond_to?(:load_env_plugins)
+    end
+
     def ui=(obj)
       Gem::DefaultUserInteraction.ui = obj
     end
@@ -249,34 +203,9 @@ module Bundler
       EXT_LOCK
     end
 
-    def with_build_args(args)
-      ext_lock.synchronize do
-        old_args = build_args
-        begin
-          self.build_args = args
-          yield
-        ensure
-          self.build_args = old_args
-        end
-      end
-    end
-
-    def spec_from_gem(path, policy = nil)
-      require "rubygems/security"
-      require_relative "psyched_yaml"
-      gem_from_path(path, security_policies[policy]).spec
-    rescue Gem::Package::FormatError
-      raise GemspecError, "Could not read gem at #{path}. It may be corrupted."
-    rescue Exception, Gem::Exception, Gem::Security::Exception => e # rubocop:disable Lint/RescueException
-      if e.is_a?(Gem::Security::Exception) ||
-          e.message =~ /unknown trust policy|unsigned gem/i ||
-          e.message =~ /couldn't verify (meta)?data signature/i
-        raise SecurityError,
-          "The gem #{File.basename(path, ".gem")} can't be installed because " \
-          "the security policy didn't allow it, with the message: #{e.message}"
-      else
-        raise e
-      end
+    def spec_from_gem(path)
+      require "rubygems/package"
+      Gem::Package.new(path).spec
     end
 
     def build_gem(gem_dir, spec)
@@ -329,8 +258,13 @@ module Bundler
           end
 
           message = if spec.nil?
+            target_file = begin
+                            Bundler.default_gemfile.basename
+                          rescue GemfileNotFound
+                            "inline Gemfile"
+                          end
             "#{dep.name} is not part of the bundle." \
-            " Add it to your #{Bundler.default_gemfile.basename}."
+            " Add it to your #{target_file}."
           else
             "can't activate #{dep}, already activated #{spec.full_name}. " \
             "Make sure all dependencies are added to Gemfile."
@@ -346,7 +280,7 @@ module Bundler
           raise e
         end
 
-        # backwards compatibility shim, see https://github.com/bundler/bundler/issues/5102
+        # backwards compatibility shim, see https://github.com/rubygems/bundler/issues/5102
         kernel_class.send(:public, :gem) if Bundler.feature_flag.setup_makes_kernel_gem_public?
       end
     end
@@ -422,6 +356,17 @@ module Bundler
     # Replace or hook into RubyGems to provide a bundlerized view
     # of the world.
     def replace_entrypoints(specs)
+      specs_by_name = add_default_gems_to(specs)
+
+      replace_gem(specs, specs_by_name)
+      stub_rubygems(specs)
+      replace_bin_path(specs_by_name)
+
+      Gem.clear_paths
+    end
+
+    # Add default gems not already present in specs, and return them as a hash.
+    def add_default_gems_to(specs)
       specs_by_name = specs.reduce({}) do |h, s|
         h[s.name] = s
         h
@@ -436,40 +381,7 @@ module Bundler
         specs_by_name[default_spec_name] = default_spec
       end
 
-      replace_gem(specs, specs_by_name)
-      stub_rubygems(specs)
-      replace_bin_path(specs_by_name)
-
-      Gem.clear_paths
-    end
-
-    # This backports base_dir which replaces installation path
-    # RubyGems 1.8+
-    def backport_base_dir
-      redefine_method(Gem::Specification, :base_dir) do
-        return Gem.dir unless loaded_from
-        File.dirname File.dirname loaded_from
-      end
-    end
-
-    def backport_cache_file
-      redefine_method(Gem::Specification, :cache_dir) do
-        @cache_dir ||= File.join base_dir, "cache"
-      end
-
-      redefine_method(Gem::Specification, :cache_file) do
-        @cache_file ||= File.join cache_dir, "#{full_name}.gem"
-      end
-    end
-
-    def backport_spec_file
-      redefine_method(Gem::Specification, :spec_dir) do
-        @spec_dir ||= File.join base_dir, "specifications"
-      end
-
-      redefine_method(Gem::Specification, :spec_file) do
-        @spec_file ||= File.join spec_dir, "#{full_name}.gemspec"
-      end
+      specs_by_name
     end
 
     def undo_replacements
@@ -536,14 +448,15 @@ module Bundler
     end
 
     def fetch_specs(remote, name)
+      require "rubygems/remote_fetcher"
       path = remote.uri.to_s + "#{name}.#{Gem.marshal_version}.gz"
       fetcher = gem_remote_fetcher
       fetcher.headers = { "X-Gemfile-Source" => remote.original_uri.to_s } if remote.original_uri
       string = fetcher.fetch_path(path)
       Bundler.load_marshal(string)
-    rescue Gem::RemoteFetcher::FetchError => e
+    rescue Gem::RemoteFetcher::FetchError
       # it's okay for prerelease to fail
-      raise e unless name == "prerelease_specs"
+      raise unless name == "prerelease_specs"
     end
 
     def fetch_all_remote_specs(remote)
@@ -553,27 +466,41 @@ module Bundler
       specs.concat(pres)
     end
 
-    def download_gem(spec, uri, path)
+    def download_gem(spec, uri, cache_dir)
+      require "rubygems/remote_fetcher"
       uri = Bundler.settings.mirror_for(uri)
       fetcher = gem_remote_fetcher
       fetcher.headers = { "X-Gemfile-Source" => spec.remote.original_uri.to_s } if spec.remote.original_uri
       Bundler::Retry.new("download gem from #{uri}").attempts do
-        fetcher.download(spec, uri, path)
+        gem_file_name = spec.file_name
+        local_gem_path = File.join cache_dir, gem_file_name
+        return if File.exist? local_gem_path
+
+        begin
+          remote_gem_path = uri + "gems/#{gem_file_name}"
+          remote_gem_path = remote_gem_path.to_s if provides?("< 3.2.0.rc.1")
+
+          SharedHelpers.filesystem_access(local_gem_path) do
+            fetcher.cache_update_path remote_gem_path, local_gem_path
+          end
+        rescue Gem::RemoteFetcher::FetchError
+          raise if spec.original_platform == spec.platform
+
+          original_gem_file_name = "#{spec.original_name}.gem"
+          raise if gem_file_name == original_gem_file_name
+
+          gem_file_name = original_gem_file_name
+          retry
+        end
       end
+    rescue Gem::RemoteFetcher::FetchError => e
+      raise Bundler::HTTPError, "Could not download gem from #{uri} due to underlying error <#{e.message}>"
     end
 
     def gem_remote_fetcher
-      require "resolv"
-      proxy = configuration[:http_proxy]
-      dns = Resolv::DNS.new
-      Gem::RemoteFetcher.new(proxy, dns)
-    end
-
-    def gem_from_path(path, policy = nil)
-      require "rubygems/package"
-      p = Gem::Package.new(path)
-      p.security_policy = policy if policy
-      p
+      require "rubygems/remote_fetcher"
+      proxy = Gem.configuration[:http_proxy]
+      Gem::RemoteFetcher.new(proxy)
     end
 
     def build(spec, skip_validation = false)
@@ -585,16 +512,11 @@ module Bundler
       Gem::REPOSITORY_SUBDIRECTORIES
     end
 
-    def install_with_build_args(args)
-      yield
-    end
-
     def path_separator
       Gem.path_separator
     end
 
     def all_specs
-      require_relative "remote_specification"
       Gem::Specification.stubs.map do |stub|
         StubSpecification.from_stub(stub)
       end
@@ -602,10 +524,10 @@ module Bundler
 
     def backport_ext_builder_monitor
       # So we can avoid requiring "rubygems/ext" in its entirety
-      Gem.module_eval <<-RB, __FILE__, __LINE__ + 1
+      Gem.module_eval <<-RUBY, __FILE__, __LINE__ + 1
         module Ext
         end
-      RB
+      RUBY
 
       require "rubygems/ext/builder"
 
@@ -619,6 +541,10 @@ module Bundler
       end
     end
 
+    def find_bundler(version)
+      find_name("bundler").find {|s| s.version.to_s == version }
+    end
+
     def find_name(name)
       Gem::Specification.stubs_for(name).map(&:to_spec)
     end
@@ -632,14 +558,6 @@ module Bundler
         Gem::Specification.send(:default_stubs, "*.gemspec")
       end
     end
-
-    def use_gemdeps(gemfile)
-      ENV["BUNDLE_GEMFILE"] ||= File.expand_path(gemfile)
-      require_relative "gemdeps"
-      runtime = Bundler.setup
-      activated_spec_names = runtime.requested_specs.map(&:to_spec).sort_by(&:name)
-      [Gemdeps.new(runtime), activated_spec_names]
-    end
   end
 
   def self.rubygems
--- ruby2.7-2.7.6.orig/lib/bundler/runtime.rb
+++ ruby2.7-2.7.6/lib/bundler/runtime.rb
@@ -12,22 +12,16 @@ module Bundler
     def setup(*groups)
       @definition.ensure_equivalent_gemfile_and_lockfile if Bundler.frozen_bundle?
 
-      groups.map!(&:to_sym)
-
       # Has to happen first
       clean_load_path
 
-      specs = groups.any? ? @definition.specs_for(groups) : requested_specs
+      specs = @definition.specs_for(groups)
 
       SharedHelpers.set_bundle_environment
       Bundler.rubygems.replace_entrypoints(specs)
 
       # Activate the specs
       load_paths = specs.map do |spec|
-        unless spec.loaded_from
-          raise GemNotFound, "#{spec.full_name} is missing. Run `bundle install` to get it."
-        end
-
         check_for_activated_spec!(spec)
 
         Bundler.rubygems.mark_loaded(spec)
@@ -43,14 +37,6 @@ module Bundler
       self
     end
 
-    REQUIRE_ERRORS = [
-      /^no such file to load -- (.+)$/i,
-      /^Missing \w+ (?:file\s*)?([^\s]+.rb)$/i,
-      /^Missing API definition file in (.+)$/i,
-      /^cannot load such file -- (.+)$/i,
-      /^dlopen\([^)]*\): Library not loaded: (.+)$/i,
-    ].freeze
-
     def require(*groups)
       groups.map!(&:to_sym)
       groups = [:default] if groups.empty?
@@ -79,16 +65,14 @@ module Bundler
             end
           end
         rescue LoadError => e
-          REQUIRE_ERRORS.find {|r| r =~ e.message }
-          raise if dep.autorequire || $1 != required_file
+          raise if dep.autorequire || e.path != required_file
 
           if dep.autorequire.nil? && dep.name.include?("-")
             begin
               namespaced_file = dep.name.tr("-", "/")
               Kernel.require namespaced_file
             rescue LoadError => e
-              REQUIRE_ERRORS.find {|r| r =~ e.message }
-              raise if $1 != namespaced_file
+              raise if e.path != namespaced_file
             end
           end
         end
@@ -116,7 +100,7 @@ module Bundler
 
     alias_method :gems, :specs
 
-    def cache(custom_path = nil)
+    def cache(custom_path = nil, local = false)
       cache_path = Bundler.app_cache(custom_path)
       SharedHelpers.filesystem_access(cache_path) do |p|
         FileUtils.mkdir_p(p)
@@ -124,11 +108,23 @@ module Bundler
 
       Bundler.ui.info "Updating files in #{Bundler.settings.app_cache_path}"
 
-      specs_to_cache = Bundler.settings[:cache_all_platforms] ? @definition.resolve.materialized_for_all_platforms : specs
+      specs_to_cache = if Bundler.settings[:cache_all_platforms]
+        @definition.resolve.materialized_for_all_platforms
+      else
+        begin
+          specs
+        rescue GemNotFound
+          if local
+            Bundler.ui.warn "Some gems seem to be missing from your #{Bundler.settings.app_cache_path} directory."
+          end
+
+          raise
+        end
+      end
+
       specs_to_cache.each do |spec|
         next if spec.name == "bundler"
         next if spec.source.is_a?(Source::Gemspec)
-        spec.source.send(:fetch_gem, spec) if Bundler.settings[:cache_all_platforms] && spec.source.respond_to?(:fetch_gem, true)
         spec.source.cache(spec, custom_path) if spec.source.respond_to?(:cache)
       end
 
@@ -165,7 +161,7 @@ module Bundler
       spec_cache_paths     = []
       spec_gemspec_paths   = []
       spec_extension_paths = []
-      specs.each do |spec|
+      Bundler.rubygems.add_default_gems_to(specs).values.each do |spec|
         spec_gem_paths << spec.full_gem_path
         # need to check here in case gems are nested like for the rails git repo
         md = %r{(.+bundler/gems/.+-[a-f0-9]{7,12})}.match(spec.full_gem_path)
@@ -213,7 +209,7 @@ module Bundler
       output
     end
 
-  private
+    private
 
     def prune_gem_cache(resolve, cache_path)
       cached = Dir["#{cache_path}/*.gem"]
@@ -268,7 +264,7 @@ module Bundler
 
       return if manuals.empty?
       Bundler::SharedHelpers.set_env "MANPATH", manuals.concat(
-        ENV["MANPATH"].to_s.split(File::PATH_SEPARATOR)
+        ENV["MANPATH"] ? ENV["MANPATH"].to_s.split(File::PATH_SEPARATOR) : [""]
       ).uniq.join(File::PATH_SEPARATOR)
     end
 
@@ -294,7 +290,7 @@ module Bundler
       return unless activated_spec = Bundler.rubygems.loaded_specs(spec.name)
       return if activated_spec.version == spec.version
 
-      suggestion = if Bundler.rubygems.spec_default_gem?(activated_spec)
+      suggestion = if activated_spec.default_gem?
         "Since #{spec.name} is a default gem, you can either remove your dependency on it" \
         " or try updating to a newer version of bundler that supports #{spec.name} as a default gem."
       else
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/self_manager.rb
@@ -0,0 +1,168 @@
+# frozen_string_literal: true
+
+module Bundler
+  #
+  # This class handles installing and switching to the version of bundler needed
+  # by an application.
+  #
+  class SelfManager
+    def restart_with_locked_bundler_if_needed
+      return unless needs_switching? && installed?
+
+      restart_with(lockfile_version)
+    end
+
+    def install_locked_bundler_and_restart_with_it_if_needed
+      return unless needs_switching?
+
+      Bundler.ui.info \
+        "Bundler #{current_version} is running, but your lockfile was generated with #{lockfile_version}. " \
+        "Installing Bundler #{lockfile_version} and restarting using that version."
+
+      install_and_restart_with(lockfile_version)
+    end
+
+    def update_bundler_and_restart_with_it_if_needed(target)
+      return unless autoswitching_applies?
+
+      spec = resolve_update_version_from(target)
+      return unless spec
+
+      version = spec.version
+
+      Bundler.ui.info "Updating bundler to #{version}."
+
+      install(spec)
+
+      restart_with(version)
+    end
+
+    private
+
+    def install_and_restart_with(version)
+      requirement = Gem::Requirement.new(version)
+      spec = find_latest_matching_spec(requirement)
+
+      if spec.nil?
+        Bundler.ui.warn "Your lockfile is locked to a version of bundler (#{lockfile_version}) that doesn't exist at https://rubygems.org/. Going on using #{current_version}"
+        return
+      end
+
+      install(spec)
+    rescue StandardError => e
+      Bundler.ui.trace e
+      Bundler.ui.warn "There was an error installing the locked bundler version (#{lockfile_version}), rerun with the `--verbose` flag for more details. Going on using bundler #{current_version}."
+    else
+      restart_with(version)
+    end
+
+    def install(spec)
+      spec.source.install(spec)
+    end
+
+    def restart_with(version)
+      configured_gem_home = ENV["GEM_HOME"]
+      configured_gem_path = ENV["GEM_PATH"]
+
+      cmd = [$PROGRAM_NAME, *ARGV]
+      cmd.unshift(Gem.ruby) unless File.executable?($PROGRAM_NAME)
+
+      Bundler.with_original_env do
+        Kernel.exec(
+          { "GEM_HOME" => configured_gem_home, "GEM_PATH" => configured_gem_path, "BUNDLER_VERSION" => version.to_s },
+          *cmd
+        )
+      end
+    end
+
+    def needs_switching?
+      autoswitching_applies? &&
+        released?(lockfile_version) &&
+        !running?(lockfile_version) &&
+        !updating?
+    end
+
+    def autoswitching_applies?
+      ENV["BUNDLER_VERSION"].nil? &&
+        Bundler.rubygems.supports_bundler_trampolining? &&
+        SharedHelpers.in_bundle? &&
+        lockfile_version
+    end
+
+    def resolve_update_version_from(target)
+      requirement = Gem::Requirement.new(target)
+      update_candidate = find_latest_matching_spec(requirement)
+
+      if update_candidate.nil?
+        raise InvalidOption, "The `bundle update --bundler` target version (#{target}) does not exist"
+      end
+
+      resolved_version = update_candidate.version
+      needs_update = requirement.specific? ? !running?(resolved_version) : running_older_than?(resolved_version)
+
+      return unless needs_update
+
+      update_candidate
+    end
+
+    def local_specs
+      @local_specs ||= Bundler::Source::Rubygems.new("allow_local" => true).specs.select {|spec| spec.name == "bundler" }
+    end
+
+    def remote_specs
+      @remote_specs ||= begin
+        source = Bundler::Source::Rubygems.new("remotes" => "https://rubygems.org")
+        source.remote!
+        source.add_dependency_names("bundler")
+        source.specs
+      end
+    end
+
+    def find_latest_matching_spec(requirement)
+      local_result = find_latest_matching_spec_from_collection(local_specs, requirement)
+      return local_result if local_result && requirement.specific?
+
+      remote_result = find_latest_matching_spec_from_collection(remote_specs, requirement)
+      return remote_result if local_result.nil?
+
+      [local_result, remote_result].max
+    end
+
+    def find_latest_matching_spec_from_collection(specs, requirement)
+      specs.sort.reverse_each.find {|spec| requirement.satisfied_by?(spec.version) }
+    end
+
+    def running?(version)
+      version == current_version
+    end
+
+    def running_older_than?(version)
+      current_version < version
+    end
+
+    def released?(version)
+      !version.to_s.end_with?(".dev")
+    end
+
+    def updating?
+      "update".start_with?(ARGV.first || " ") && ARGV[1..-1].any? {|a| a.start_with?("--bundler") }
+    end
+
+    def installed?
+      Bundler.configure
+
+      Bundler.rubygems.find_bundler(lockfile_version.to_s)
+    end
+
+    def current_version
+      @current_version ||= Gem::Version.new(Bundler::VERSION)
+    end
+
+    def lockfile_version
+      return @lockfile_version if defined?(@lockfile_version)
+
+      parsed_version = Bundler::LockfileParser.bundled_with
+      @lockfile_version = parsed_version ? Gem::Version.new(parsed_version) : nil
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/lib/bundler/settings.rb
+++ ruby2.7-2.7.6/lib/bundler/settings.rb
@@ -7,35 +7,34 @@ module Bundler
     autoload :Validator, File.expand_path("settings/validator", __dir__)
 
     BOOL_KEYS = %w[
-      allow_bundler_dependency_conflicts
       allow_deployment_source_credential_changes
       allow_offline_install
       auto_clean_without_path
       auto_install
-      auto_config_jobs
       cache_all
       cache_all_platforms
+      clean
       default_install_uses_path
       deployment
-      deployment_means_frozen
       disable_checksum_validation
       disable_exec_load
       disable_local_branch_check
-      disable_multisource
-      disable_platform_warnings
+      disable_local_revision_check
       disable_shared_gems
       disable_version_check
       force_ruby_platform
       forget_cli_options
       frozen
+      gem.changelog
       gem.coc
       gem.mit
+      git.allow_insecure
       global_gem_cache
       ignore_messages
       init_gems_rb
+      inline
       no_install
       no_prune
-      only_update_to_newer_versions
       path_relative_to_cwd
       path.system
       plugins
@@ -44,12 +43,8 @@ module Bundler
       setup_makes_kernel_gem_public
       silence_deprecations
       silence_root_warning
-      skip_default_git_sources
-      specific_platform
       suppress_install_using_messages
-      unlock_source_unlocks_spec
       update_requires_all_flag
-      use_gem_version_promoter_for_major_updates
     ].freeze
 
     NUMBER_KEYS = %w[
@@ -61,35 +56,47 @@ module Bundler
     ].freeze
 
     ARRAY_KEYS = %w[
+      only
       with
       without
     ].freeze
 
+    STRING_KEYS = %w[
+      bin
+      cache_path
+      console
+      gem.ci
+      gem.github_username
+      gem.linter
+      gem.rubocop
+      gem.test
+      gemfile
+      path
+      shebang
+      system_bindir
+      trust-policy
+    ].freeze
+
     DEFAULT_CONFIG = {
-      :silence_deprecations => false,
-      :disable_version_check => true,
-      :prefer_patch => false,
-      :redirect => 5,
-      :retry => 3,
-      :timeout => 10,
+      "BUNDLE_SILENCE_DEPRECATIONS" => false,
+      "BUNDLE_DISABLE_VERSION_CHECK" => true,
+      "BUNDLE_PREFER_PATCH" => false,
+      "BUNDLE_REDIRECT" => 5,
+      "BUNDLE_RETRY" => 3,
+      "BUNDLE_TIMEOUT" => 10,
     }.freeze
 
     def initialize(root = nil)
       @root            = root
       @local_config    = load_config(local_config_file)
+      @env_config      = ENV.to_h.select {|key, _value| key =~ /\ABUNDLE_.+/ }
       @global_config   = load_config(global_config_file)
       @temporary       = {}
     end
 
     def [](name)
       key = key_for(name)
-      value = @temporary.fetch(key) do
-              @local_config.fetch(key) do
-              ENV.fetch(key) do
-              @global_config.fetch(key) do
-              DEFAULT_CONFIG.fetch(name) do
-                nil
-              end end end end end
+      value = configs.values.map {|config| config[key] }.compact.first
 
       converted_value(value, name)
     end
@@ -132,13 +139,11 @@ module Bundler
     end
 
     def all
-      env_keys = ENV.keys.grep(/\ABUNDLE_.+/)
-
-      keys = @temporary.keys | @global_config.keys | @local_config.keys | env_keys
+      keys = @temporary.keys | @global_config.keys | @local_config.keys | @env_config.keys
 
       keys.map do |key|
-        key.sub(/^BUNDLE_/, "").gsub(/__/, ".").downcase
-      end
+        key.sub(/^BUNDLE_/, "").gsub(/___/, "-").gsub(/__/, ".").downcase
+      end.sort
     end
 
     def local_overrides
@@ -171,13 +176,11 @@ module Bundler
 
     def locations(key)
       key = key_for(key)
-      locations = {}
-      locations[:temporary] = @temporary[key] if @temporary.key?(key)
-      locations[:local]  = @local_config[key] if @local_config.key?(key)
-      locations[:env]    = ENV[key] if ENV[key]
-      locations[:global] = @global_config[key] if @global_config.key?(key)
-      locations[:default] = DEFAULT_CONFIG[key] if DEFAULT_CONFIG.key?(key)
-      locations
+      configs.keys.inject({}) do |partial_locations, level|
+        value_on_level = configs[level][key]
+        partial_locations[level] = value_on_level unless value_on_level.nil?
+        partial_locations
+      end
     end
 
     def pretty_values_for(exposed_key)
@@ -185,39 +188,49 @@ module Bundler
 
       locations = []
 
-      if @temporary.key?(key)
-        locations << "Set for the current command: #{converted_value(@temporary[key], exposed_key).inspect}"
+      if value = @temporary[key]
+        locations << "Set for the current command: #{printable_value(value, exposed_key).inspect}"
       end
 
-      if @local_config.key?(key)
-        locations << "Set for your local app (#{local_config_file}): #{converted_value(@local_config[key], exposed_key).inspect}"
+      if value = @local_config[key]
+        locations << "Set for your local app (#{local_config_file}): #{printable_value(value, exposed_key).inspect}"
       end
 
-      if value = ENV[key]
-        locations << "Set via #{key}: #{converted_value(value, exposed_key).inspect}"
+      if value = @env_config[key]
+        locations << "Set via #{key}: #{printable_value(value, exposed_key).inspect}"
       end
 
-      if @global_config.key?(key)
-        locations << "Set for the current user (#{global_config_file}): #{converted_value(@global_config[key], exposed_key).inspect}"
+      if value = @global_config[key]
+        locations << "Set for the current user (#{global_config_file}): #{printable_value(value, exposed_key).inspect}"
       end
 
       return ["You have not configured a value for `#{exposed_key}`"] if locations.empty?
       locations
     end
 
+    def processor_count
+      require "etc"
+      Etc.nprocessors
+    rescue StandardError
+      1
+    end
+
     # for legacy reasons, in Bundler 2, we do not respect :disable_shared_gems
     def path
-      key  = key_for(:path)
-      path = ENV[key] || @global_config[key]
-      if path && !@temporary.key?(key) && !@local_config.key?(key)
-        return Path.new(path, false, false)
+      configs.each do |_level, settings|
+        path = value_for("path", settings)
+        path = "vendor/bundle" if value_for("deployment", settings) && path.nil?
+        path_system = value_for("path.system", settings)
+        disabled_shared_gems = value_for("disable_shared_gems", settings)
+        next if path.nil? && path_system.nil? && disabled_shared_gems.nil?
+        system_path = path_system || (disabled_shared_gems == false)
+        return Path.new(path, system_path)
       end
 
-      system_path = self["path.system"] || (self[:disable_shared_gems] == false)
-      Path.new(self[:path], system_path, Bundler.feature_flag.default_install_uses_path?)
+      Path.new(nil, false)
     end
 
-    Path = Struct.new(:explicit_path, :system_path, :default_install_uses_path) do
+    Path = Struct.new(:explicit_path, :system_path) do
       def path
         path = base_path
         path = File.join(path, Bundler.ruby_scope) unless use_system_gems?
@@ -227,7 +240,7 @@ module Bundler
       def use_system_gems?
         return true if system_path
         return false if explicit_path
-        !default_install_uses_path
+        !Bundler.feature_flag.default_install_uses_path?
       end
 
       def base_path
@@ -280,20 +293,32 @@ module Bundler
 
     def validate!
       all.each do |raw_key|
-        [@local_config, ENV, @global_config].each do |settings|
-          value = converted_value(settings[key_for(raw_key)], raw_key)
-          Validator.validate!(raw_key, value, settings.to_hash.dup)
+        [@local_config, @env_config, @global_config].each do |settings|
+          value = value_for(raw_key, settings)
+          Validator.validate!(raw_key, value, settings.dup)
         end
       end
     end
 
     def key_for(key)
-      key = Settings.normalize_uri(key).to_s if key.is_a?(String) && /https?:/ =~ key
-      key = key.to_s.gsub(".", "__").upcase
-      "BUNDLE_#{key}"
+      self.class.key_for(key)
     end
 
-  private
+    private
+
+    def configs
+      {
+        :temporary => @temporary,
+        :local => @local_config,
+        :env => @env_config,
+        :global => @global_config,
+        :default => DEFAULT_CONFIG,
+      }
+    end
+
+    def value_for(name, config)
+      converted_value(config[key_for(name)], name)
+    end
 
     def parent_setting_for(name)
       split_specific_setting_for(name)[0]
@@ -311,6 +336,10 @@ module Bundler
       BOOL_KEYS.include?(name.to_s) || BOOL_KEYS.include?(parent_setting_for(name.to_s))
     end
 
+    def is_string(name)
+      STRING_KEYS.include?(name.to_s) || name.to_s.start_with?("local.") || name.to_s.start_with?("mirror.") || name.to_s.start_with?("build.")
+    end
+
     def to_bool(value)
       case value
       when nil, /\A(false|f|no|n|0|)\z/i, false
@@ -328,9 +357,17 @@ module Bundler
       ARRAY_KEYS.include?(key.to_s)
     end
 
+    def is_credential(key)
+      key == "gem.push_key"
+    end
+
+    def is_userinfo(value)
+      value.include?(":")
+    end
+
     def to_array(value)
       return [] unless value
-      value.split(":").map(&:to_sym)
+      value.tr(" ", ":").split(":").map(&:to_sym)
     end
 
     def array_to_s(array)
@@ -374,15 +411,38 @@ module Bundler
       end
     end
 
+    def printable_value(value, key)
+      converted = converted_value(value, key)
+      return converted unless converted.is_a?(String)
+
+      if is_string(key)
+        converted
+      elsif is_credential(key)
+        "[REDACTED]"
+      elsif is_userinfo(converted)
+        username, pass = converted.split(":", 2)
+
+        if pass == "x-oauth-basic"
+          username = "[REDACTED]"
+        else
+          pass = "[REDACTED]"
+        end
+
+        [username, pass].join(":")
+      else
+        converted
+      end
+    end
+
     def global_config_file
       if ENV["BUNDLE_CONFIG"] && !ENV["BUNDLE_CONFIG"].empty?
         Pathname.new(ENV["BUNDLE_CONFIG"])
-      else
-        begin
-          Bundler.user_bundle_path("config")
-        rescue PermissionError, GenericSystemCallError
-          nil
-        end
+      elsif ENV["BUNDLE_USER_CONFIG"] && !ENV["BUNDLE_USER_CONFIG"].empty?
+        Pathname.new(ENV["BUNDLE_USER_CONFIG"])
+      elsif ENV["BUNDLE_USER_HOME"] && !ENV["BUNDLE_USER_HOME"].empty?
+        Pathname.new(ENV["BUNDLE_USER_HOME"]).join("config")
+      elsif Bundler.rubygems.user_home && !Bundler.rubygems.user_home.empty?
+        Pathname.new(Bundler.rubygems.user_home).join(".bundle/config")
       end
     end
 
@@ -396,7 +456,20 @@ module Bundler
         valid_file = file.exist? && !file.size.zero?
         return {} unless valid_file
         require_relative "yaml_serializer"
-        YAMLSerializer.load file.read
+        YAMLSerializer.load(file.read).inject({}) do |config, (k, v)|
+          new_k = k
+
+          if k.include?("-")
+            Bundler.ui.warn "Your #{file} config includes `#{k}`, which contains the dash character (`-`).\n" \
+              "This is deprecated, because configuration through `ENV` should be possible, but `ENV` keys cannot include dashes.\n" \
+              "Please edit #{file} and replace any dashes in configuration keys with a triple underscore (`___`)."
+
+            new_k = k.gsub("-", "___")
+          end
+
+          config[new_k] = v
+          config
+        end
       end
     end
 
@@ -413,6 +486,12 @@ module Bundler
         \z
       /ix.freeze
 
+    def self.key_for(key)
+      key = normalize_uri(key).to_s if key.is_a?(String) && key.start_with?("http", "mirror.http")
+      key = key.to_s.gsub(".", "__").gsub("-", "___").upcase
+      "BUNDLE_#{key}"
+    end
+
     # TODO: duplicates Rubygems#normalize_uri
     # TODO: is this the correct place to validate mirror URIs?
     def self.normalize_uri(uri)
--- ruby2.7-2.7.6.orig/lib/bundler/setup.rb
+++ ruby2.7-2.7.6/lib/bundler/setup.rb
@@ -9,10 +9,10 @@ if Bundler::SharedHelpers.in_bundle?
     begin
       Bundler.ui.silence { Bundler.setup }
     rescue Bundler::BundlerError => e
-      Bundler.ui.warn "\e[31m#{e.message}\e[0m"
+      Bundler.ui.error e.message
       Bundler.ui.warn e.backtrace.join("\n") if ENV["DEBUG"]
       if e.is_a?(Bundler::GemNotFound)
-        Bundler.ui.warn "\e[33mRun `bundle install` to install missing gems.\e[0m"
+        Bundler.ui.warn "Run `bundle install` to install missing gems."
       end
       exit e.status_code
     end
--- ruby2.7-2.7.6.orig/lib/bundler/shared_helpers.rb
+++ ruby2.7-2.7.6/lib/bundler/shared_helpers.rb
@@ -13,13 +13,13 @@ module Bundler
     def root
       gemfile = find_gemfile
       raise GemfileNotFound, "Could not locate Gemfile" unless gemfile
-      Pathname.new(gemfile).tap{|x| x.untaint if RUBY_VERSION < "2.7" }.expand_path.parent
+      Pathname.new(gemfile).tap {|x| x.untaint if RUBY_VERSION < "2.7" }.expand_path.parent
     end
 
     def default_gemfile
       gemfile = find_gemfile
       raise GemfileNotFound, "Could not locate Gemfile" unless gemfile
-      Pathname.new(gemfile).tap{|x| x.untaint if RUBY_VERSION < "2.7" }.expand_path
+      Pathname.new(gemfile).tap {|x| x.untaint if RUBY_VERSION < "2.7" }.expand_path
     end
 
     def default_lockfile
@@ -28,7 +28,7 @@ module Bundler
       case gemfile.basename.to_s
       when "gems.rb" then Pathname.new(gemfile.sub(/.rb$/, ".locked"))
       else Pathname.new("#{gemfile}.lock")
-      end.tap{|x| x.untaint if RUBY_VERSION < "2.7" }
+      end.tap {|x| x.untaint if RUBY_VERSION < "2.7" }
     end
 
     def default_bundle_dir
@@ -100,7 +100,7 @@ module Bundler
     #
     # @see {Bundler::PermissionError}
     def filesystem_access(path, action = :write, &block)
-      yield(path.dup.tap{|x| x.untaint if RUBY_VERSION < "2.7" })
+      yield(path.dup.tap {|x| x.untaint if RUBY_VERSION < "2.7" })
     rescue Errno::EACCES
       raise PermissionError.new(path, action)
     rescue Errno::EAGAIN
@@ -109,7 +109,7 @@ module Bundler
       raise VirtualProtocolError.new
     rescue Errno::ENOSPC
       raise NoSpaceOnDeviceError.new(path, action)
-    rescue *[const_get_safely(:ENOTSUP, Errno)].compact
+    rescue Errno::ENOTSUP
       raise OperationNotSupportedError.new(path, action)
     rescue Errno::EEXIST, Errno::ENOENT
       raise
@@ -117,13 +117,6 @@ module Bundler
       raise GenericSystemCallError.new(e, "There was an error accessing `#{path}`.")
     end
 
-    def const_get_safely(constant_name, namespace)
-      const_in_namespace = namespace.constants.include?(constant_name.to_s) ||
-        namespace.constants.include?(constant_name.to_sym)
-      return nil unless const_in_namespace
-      namespace.const_get(constant_name)
-    end
-
     def major_deprecation(major_version, message, print_caller_location: false)
       if print_caller_location
         caller_location = caller_locations(2, 2).first
@@ -148,17 +141,10 @@ module Bundler
       end
       return unless multiple_gemfiles
       message = "Multiple gemfiles (gems.rb and Gemfile) detected. " \
-                "Make sure you remove Gemfile and Gemfile.lock since bundler is ignoring them in favor of gems.rb and gems.rb.locked."
+                "Make sure you remove Gemfile and Gemfile.lock since bundler is ignoring them in favor of gems.rb and gems.locked."
       Bundler.ui.warn message
     end
 
-    def trap(signal, override = false, &block)
-      prior = Signal.trap(signal) do
-        block.call
-        prior.call unless override
-      end
-    end
-
     def ensure_same_dependencies(spec, old_deps, new_deps)
       new_deps = new_deps.reject {|d| d.type == :development }
       old_deps = old_deps.reject {|d| d.type == :development }
@@ -194,11 +180,11 @@ module Bundler
       return @md5_available if defined?(@md5_available)
       @md5_available = begin
         require "openssl"
-        OpenSSL::Digest::MD5.digest("")
+        ::OpenSSL::Digest.digest("MD5", "")
         true
       rescue LoadError
         true
-      rescue OpenSSL::Digest::DigestError
+      rescue ::OpenSSL::Digest::DigestError
         false
       end
     end
@@ -212,7 +198,7 @@ module Bundler
       filesystem_access(gemfile_path) {|g| File.open(g, "w") {|file| file.puts contents } }
     end
 
-  private
+    private
 
     def validate_bundle_path
       path_separator = Bundler.rubygems.path_separator
@@ -250,10 +236,10 @@ module Bundler
 
     def search_up(*names)
       previous = nil
-      current  = File.expand_path(SharedHelpers.pwd).tap{|x| x.untaint if RUBY_VERSION < "2.7" }
+      current  = File.expand_path(SharedHelpers.pwd).tap {|x| x.untaint if RUBY_VERSION < "2.7" }
 
       until !File.directory?(current) || current == previous
-        if ENV["BUNDLE_SPEC_RUN"]
+        if ENV["BUNDLER_SPEC_RUN"]
           # avoid stepping above the tmp directory when testing
           gemspec = if ENV["GEM_COMMAND"]
             # for Ruby Core
@@ -288,10 +274,10 @@ module Bundler
 
     def set_bundle_variables
       # bundler exe & lib folders have same root folder, typical gem installation
-      exe_file = File.expand_path("../../../exe/bundle", __FILE__)
+      exe_file = File.expand_path("../../exe/bundle", __dir__)
 
       # for Ruby core repository testing
-      exe_file = File.expand_path("../../../libexec/bundle", __FILE__) unless File.exist?(exe_file)
+      exe_file = File.expand_path("../../libexec/bundle", __dir__) unless File.exist?(exe_file)
 
       # bundler is a default gem, exe path is separate
       exe_file = Bundler.rubygems.bin_path("bundler", "bundle", VERSION) unless File.exist?(exe_file)
@@ -323,16 +309,15 @@ module Bundler
     end
 
     def bundler_ruby_lib
-      resolve_path File.expand_path("../..", __FILE__)
+      File.expand_path("..", __dir__)
     end
 
     def clean_load_path
-      bundler_lib = bundler_ruby_lib
-
       loaded_gem_paths = Bundler.rubygems.loaded_gem_paths
 
       $LOAD_PATH.reject! do |p|
-        next if resolve_path(p).start_with?(bundler_lib)
+        resolved_path = resolve_path(p)
+        next if $LOADED_FEATURES.any? {|lf| lf.start_with?(resolved_path) }
         loaded_gem_paths.delete(p)
       end
       $LOAD_PATH.uniq!
@@ -340,7 +325,7 @@ module Bundler
 
     def resolve_path(path)
       expanded = File.expand_path(path)
-      return expanded unless File.respond_to?(:realpath) && File.exist?(expanded)
+      return expanded unless File.exist?(expanded)
 
       File.realpath(expanded)
     end
--- ruby2.7-2.7.6.orig/lib/bundler/similarity_detector.rb
+++ ruby2.7-2.7.6/lib/bundler/similarity_detector.rb
@@ -26,7 +26,7 @@ module Bundler
       end
     end
 
-  protected
+    protected
 
     # https://www.informit.com/articles/article.aspx?p=683059&seqNum=36
     def levenshtein_distance(this, that, ins = 2, del = 2, sub = 1)
--- ruby2.7-2.7.6.orig/lib/bundler/source.rb
+++ ruby2.7-2.7.6/lib/bundler/source.rb
@@ -7,6 +7,7 @@ module Bundler
     autoload :Metadata, File.expand_path("source/metadata", __dir__)
     autoload :Path,     File.expand_path("source/path", __dir__)
     autoload :Rubygems, File.expand_path("source/rubygems", __dir__)
+    autoload :RubygemsAggregate, File.expand_path("source/rubygems_aggregate", __dir__)
 
     attr_accessor :dependency_names
 
@@ -14,13 +15,12 @@ module Bundler
       specs.unmet_dependency_names
     end
 
-    def version_message(spec)
+    def version_message(spec, locked_spec = nil)
       message = "#{spec.name} #{spec.version}"
       message += " (#{spec.platform})" if spec.platform != Gem::Platform::RUBY && !spec.platform.nil?
 
-      if Bundler.locked_gems
-        locked_spec = Bundler.locked_gems.specs.find {|s| s.name == spec.name }
-        locked_spec_version = locked_spec.version if locked_spec
+      if locked_spec
+        locked_spec_version = locked_spec.version
         if locked_spec_version && spec.version != locked_spec_version
           message += Bundler.ui.add_color(" (was #{locked_spec_version})", version_color(spec.version, locked_spec_version))
         end
@@ -33,6 +33,18 @@ module Bundler
       spec.source == self
     end
 
+    def local!; end
+
+    def local_only!; end
+
+    def cached!; end
+
+    def remote!; end
+
+    def add_dependency_names(names)
+      @dependency_names = Array(dependency_names) | Array(names)
+    end
+
     # it's possible that gems from one source depend on gems from some
     # other source, so now we download gemspecs and iterate over those
     # dependencies, looking for gems we don't have info on yet.
@@ -42,6 +54,10 @@ module Bundler
       specs.dependency_names
     end
 
+    def spec_names
+      specs.spec_names
+    end
+
     def include?(other)
       other == self
     end
@@ -50,6 +66,10 @@ module Bundler
       "#<#{self.class}:0x#{object_id} #{self}>"
     end
 
+    def identifier
+      to_s
+    end
+
     def path?
       instance_of?(Bundler::Source::Path)
     end
@@ -63,7 +83,7 @@ module Bundler
       )
     end
 
-  private
+    private
 
     def version_color(spec_version, locked_spec_version)
       if Gem::Version.correct?(spec_version) && Gem::Version.correct?(locked_spec_version)
--- ruby2.7-2.7.6.orig/lib/bundler/source/git.rb
+++ ruby2.7-2.7.6/lib/bundler/source/git.rb
@@ -22,7 +22,7 @@ module Bundler
         @uri        = options["uri"] || ""
         @safe_uri   = URICredentialsFilter.credential_filtered_uri(@uri)
         @branch     = options["branch"]
-        @ref        = options["ref"] || options["branch"] || options["tag"] || "master"
+        @ref        = options["ref"] || options["branch"] || options["tag"]
         @submodules = options["submodules"]
         @name       = options["name"]
         @version    = options["version"].to_s.strip.gsub("-", ".pre.")
@@ -42,7 +42,7 @@ module Bundler
         %w[ref branch tag submodules].each do |opt|
           out << "  #{opt}: #{options[opt]}\n" if options[opt]
         end
-        out << "  glob: #{@glob}\n" unless @glob == DEFAULT_GLOB
+        out << "  glob: #{@glob}\n" unless default_glob?
         out << "  specs:\n"
       end
 
@@ -60,25 +60,35 @@ module Bundler
       alias_method :==, :eql?
 
       def to_s
-        at = if local?
-          path
-        elsif user_ref = options["ref"]
-          if ref =~ /\A[a-z0-9]{4,}\z/i
-            shortref_for_display(user_ref)
+        begin
+          at = if local?
+            path
+          elsif user_ref = options["ref"]
+            if ref =~ /\A[a-z0-9]{4,}\z/i
+              shortref_for_display(user_ref)
+            else
+              user_ref
+            end
+          elsif ref
+            ref
           else
-            user_ref
+            git_proxy.branch
           end
-        else
-          ref
+
+          rev = "at #{at}@#{shortref_for_display(revision)}"
+        rescue GitError
+          ""
         end
 
-        rev = begin
-                "@#{shortref_for_display(revision)}"
-              rescue GitError
-                nil
-              end
+        specifiers = [rev, glob_for_display].compact
+        suffix =
+          if specifiers.any?
+            " (#{specifiers.join(", ")})"
+          else
+            ""
+          end
 
-        "#{@safe_uri} (at #{at}#{rev})"
+        "#{@safe_uri}#{suffix}"
       end
 
       def name
@@ -146,7 +156,7 @@ module Bundler
 
         changed = cached_revision && cached_revision != git_proxy.revision
 
-        if changed && !@unlocked && !git_proxy.contains?(cached_revision)
+        if !Bundler.settings[:disable_local_revision_check] && changed && !@unlocked && !git_proxy.contains?(cached_revision)
           raise GitError, "The Gemfile lock is pointing to revision #{shortref_for_display(cached_revision)} " \
             "but the current branch in your local override for #{name} does not contain such commit. " \
             "Please make sure your branch is up to date."
@@ -171,7 +181,7 @@ module Bundler
       def install(spec, options = {})
         force = options[:force]
 
-        print_using_message "Using #{version_message(spec)} from #{self}"
+        print_using_message "Using #{version_message(spec, options[:previous_spec])} from #{self}"
 
         if (requires_checkout? && !@copied) || force
           Bundler.ui.debug "  * Checking out revision: #{ref}"
@@ -209,13 +219,11 @@ module Bundler
       # across different projects, this cache will be shared.
       # When using local git repos, this is set to the local repo.
       def cache_path
-        @cache_path ||= begin
-          if Bundler.requires_sudo? || Bundler.feature_flag.global_gem_cache?
-            Bundler.user_cache
-          else
-            Bundler.bundle_path.join("cache", "bundler")
-          end.join("git", git_scope)
-        end
+        @cache_path ||= if Bundler.requires_sudo? || Bundler.feature_flag.global_gem_cache?
+          Bundler.user_cache
+        else
+          Bundler.bundle_path.join("cache", "bundler")
+        end.join("git", git_scope)
       end
 
       def app_cache_dirname
@@ -230,7 +238,11 @@ module Bundler
         @allow_remote || @allow_cached
       end
 
-    private
+      def local?
+        @local
+      end
+
+      private
 
       def serialize_gemspecs_in(destination)
         destination = destination.expand_path(Bundler.root) if destination.relative?
@@ -256,10 +268,6 @@ module Bundler
         cached_revision && super
       end
 
-      def local?
-        @local
-      end
-
       def requires_checkout?
         allow_git_ops? && !local? && !cached_revision_checked_out?
       end
@@ -280,6 +288,14 @@ module Bundler
         ref[0..11]
       end
 
+      def glob_for_display
+        default_glob? ? nil : "glob: #{@glob}"
+      end
+
+      def default_glob?
+        @glob == DEFAULT_GLOB
+      end
+
       def uri_hash
         if uri =~ %r{^\w+://(\w+@)?}
           # Downcase the domain component of the URI
@@ -289,7 +305,9 @@ module Bundler
           # If there is no URI scheme, assume it is an ssh/git URI
           input = uri
         end
-        SharedHelpers.digest(:SHA1).hexdigest(input)
+        # We use SHA1 here for historical reason and to preserve backward compatibility.
+        # But a transition to a simpler mangling algorithm would be welcome.
+        Bundler::Digest.sha1(input)
       end
 
       def cached_revision
@@ -316,7 +334,7 @@ module Bundler
 
       def load_gemspec(file)
         stub = Gem::StubSpecification.gemspec_stub(file, install_path.parent, install_path.parent)
-        stub.full_gem_path = Pathname.new(file).dirname.expand_path(root).to_s.tap{|x| x.untaint if RUBY_VERSION < "2.7" }
+        stub.full_gem_path = Pathname.new(file).dirname.expand_path(root).to_s.tap {|x| x.untaint if RUBY_VERSION < "2.7" }
         StubSpecification.from_stub(stub)
       end
 
--- ruby2.7-2.7.6.orig/lib/bundler/source/git/git_proxy.rb
+++ ruby2.7-2.7.6/lib/bundler/source/git/git_proxy.rb
@@ -1,7 +1,5 @@
 # frozen_string_literal: true
 
-require "shellwords"
-
 module Bundler
   class Source
     class Git
@@ -17,8 +15,8 @@ module Bundler
       class GitNotAllowedError < GitError
         def initialize(command)
           msg = String.new
-          msg << "Bundler is trying to run a `git #{command}` at runtime. You probably need to run `bundle install`. However, "
-          msg << "this error message could probably be more useful. Please submit a ticket at https://github.com/bundler/bundler/issues "
+          msg << "Bundler is trying to run `#{command}` at runtime. You probably need to run `bundle install`. However, "
+          msg << "this error message could probably be more useful. Please submit a ticket at https://github.com/rubygems/rubygems/issues/new?labels=Bundler&template=bundler-related-issue.md "
           msg << "with steps to reproduce as well as the following\n\nCALLER: #{caller.join("\n")}"
           super msg
         end
@@ -27,21 +25,21 @@ module Bundler
       class GitCommandError < GitError
         attr_reader :command
 
-        def initialize(command, path = nil, extra_info = nil)
+        def initialize(command, path, extra_info = nil)
           @command = command
 
           msg = String.new
-          msg << "Git error: command `git #{command}` in directory #{SharedHelpers.pwd} has failed."
+          msg << "Git error: command `#{command}` in directory #{path} has failed."
           msg << "\n#{extra_info}" if extra_info
-          msg << "\nIf this error persists you could try removing the cache directory '#{path}'" if path && path.exist?
+          msg << "\nIf this error persists you could try removing the cache directory '#{path}'" if path.exist?
           super msg
         end
       end
 
       class MissingGitRevisionError < GitCommandError
-        def initialize(command, path, ref, repo)
+        def initialize(command, destination_path, ref, repo)
           msg = "Revision #{ref} does not exist in the repository #{repo}. Maybe you misspelled it?"
-          super command, path, msg
+          super command, destination_path, msg
         end
       end
 
@@ -58,30 +56,21 @@ module Bundler
           @ref      = ref
           @revision = revision
           @git      = git
-          raise GitNotInstalledError.new if allow? && !Bundler.git_present?
         end
 
         def revision
-          return @revision if @revision
-
-          begin
-            @revision ||= find_local_revision
-          rescue GitCommandError => e
-            raise MissingGitRevisionError.new(e.command, path, ref, URICredentialsFilter.credential_filtered_uri(uri))
-          end
-
-          @revision
+          @revision ||= find_local_revision
         end
 
         def branch
-          @branch ||= allowed_in_path do
-            git("rev-parse --abbrev-ref HEAD").strip
+          @branch ||= allowed_with_path do
+            git("rev-parse", "--abbrev-ref", "HEAD", :dir => path).strip
           end
         end
 
         def contains?(commit)
-          allowed_in_path do
-            result, status = git_null("branch --contains #{commit}")
+          allowed_with_path do
+            result, status = git_null("branch", "--contains", commit, :dir => path)
             status.success? && result =~ /^\* (.*)$/
           end
         end
@@ -96,20 +85,22 @@ module Bundler
 
         def checkout
           return if path.exist? && has_revision_cached?
-          extra_ref = "#{Shellwords.shellescape(ref)}:#{Shellwords.shellescape(ref)}" if ref && ref.start_with?("refs/")
+          extra_ref = "#{ref}:#{ref}" if ref && ref.start_with?("refs/")
 
           Bundler.ui.info "Fetching #{URICredentialsFilter.credential_filtered_uri(uri)}"
 
+          configured_uri = configured_uri_for(uri).to_s
+
           unless path.exist?
             SharedHelpers.filesystem_access(path.dirname) do |p|
               FileUtils.mkdir_p(p)
             end
-            git_retry %(clone #{uri_escaped_with_configured_credentials} "#{path}" --bare --no-hardlinks --quiet)
+            git_retry "clone", "--bare", "--no-hardlinks", "--quiet", "--", configured_uri, path.to_s
             return unless extra_ref
           end
 
-          in_path do
-            git_retry %(fetch --force --quiet --tags #{uri_escaped_with_configured_credentials} "refs/heads/*:refs/heads/*" #{extra_ref})
+          with_path do
+            git_retry(*["fetch", "--force", "--quiet", "--tags", "--", configured_uri, "refs/heads/*:refs/heads/*", extra_ref].compact, :dir => path)
           end
         end
 
@@ -123,68 +114,69 @@ module Bundler
               SharedHelpers.filesystem_access(destination) do |p|
                 FileUtils.rm_rf(p)
               end
-              git_retry %(clone --no-checkout --quiet "#{path}" "#{destination}")
+              git_retry "clone", "--no-checkout", "--quiet", path.to_s, destination.to_s
               File.chmod(((File.stat(destination).mode | 0o777) & ~File.umask), destination)
             rescue Errno::EEXIST => e
-              file_path = e.message[%r{.*?(/.*)}, 1]
+              file_path = e.message[%r{.*?((?:[a-zA-Z]:)?/.*)}, 1]
               raise GitError, "Bundler could not install a gem because it needs to " \
                 "create a directory, but a file exists - #{file_path}. Please delete " \
                 "this file and try again."
             end
           end
           # method 2
-          SharedHelpers.chdir(destination) do
-            git_retry %(fetch --force --quiet --tags "#{path}")
+          git_retry "fetch", "--force", "--quiet", "--tags", path.to_s, :dir => destination
 
-            begin
-              git "reset --hard #{@revision}"
-            rescue GitCommandError => e
-              raise MissingGitRevisionError.new(e.command, path, @revision, URICredentialsFilter.credential_filtered_uri(uri))
-            end
+          begin
+            git "reset", "--hard", @revision, :dir => destination
+          rescue GitCommandError => e
+            raise MissingGitRevisionError.new(e.command, destination, @revision, URICredentialsFilter.credential_filtered_uri(uri))
+          end
 
-            if submodules
-              git_retry "submodule update --init --recursive"
-            elsif Gem::Version.create(version) >= Gem::Version.create("2.9.0")
-              git_retry "submodule deinit --all --force"
-            end
+          if submodules
+            git_retry "submodule", "update", "--init", "--recursive", :dir => destination
+          elsif Gem::Version.create(version) >= Gem::Version.create("2.9.0")
+            inner_command = "git -C $toplevel submodule deinit --force $sm_path"
+            git_retry "submodule", "foreach", "--quiet", inner_command, :dir => destination
           end
         end
 
-      private
+        private
 
-        def git_null(command)
-          command_with_no_credentials = URICredentialsFilter.credential_filtered_string(command, uri)
-          raise GitNotAllowedError.new(command_with_no_credentials) unless allow?
+        def git_null(*command, dir: nil)
+          check_allowed(command)
 
           out, status = SharedHelpers.with_clean_git_env do
-            capture_and_ignore_stderr("git #{command}")
+            capture_and_ignore_stderr(*capture3_args_for(command, dir))
           end
 
           [URICredentialsFilter.credential_filtered_string(out, uri), status]
         end
 
-        def git_retry(command)
-          Bundler::Retry.new("`git #{URICredentialsFilter.credential_filtered_string(command, uri)}`", GitNotAllowedError).attempts do
-            git(command)
+        def git_retry(*command, dir: nil)
+          command_with_no_credentials = check_allowed(command)
+
+          Bundler::Retry.new("`#{command_with_no_credentials}` at #{dir || SharedHelpers.pwd}").attempts do
+            git(*command, :dir => dir)
           end
         end
 
-        def git(command, check_errors = true, error_msg = nil)
-          command_with_no_credentials = URICredentialsFilter.credential_filtered_string(command, uri)
-          raise GitNotAllowedError.new(command_with_no_credentials) unless allow?
+        def git(*command, dir: nil)
+          command_with_no_credentials = check_allowed(command)
 
           out, status = SharedHelpers.with_clean_git_env do
-            capture_and_filter_stderr(uri, "git #{command}")
+            capture_and_filter_stderr(*capture3_args_for(command, dir))
           end
 
-          stdout_with_no_credentials = URICredentialsFilter.credential_filtered_string(out, uri)
-          raise GitCommandError.new(command_with_no_credentials, path, error_msg) if check_errors && !status.success?
-          stdout_with_no_credentials
+          filtered_out = URICredentialsFilter.credential_filtered_string(out, uri)
+
+          raise GitCommandError.new(command_with_no_credentials, dir || SharedHelpers.pwd, filtered_out) unless status.success?
+
+          filtered_out
         end
 
         def has_revision_cached?
           return unless @revision
-          in_path { git("cat-file -e #{@revision}") }
+          with_path { git("cat-file", "-e", @revision, :dir => path) }
           true
         rescue GitError
           false
@@ -195,23 +187,11 @@ module Bundler
         end
 
         def find_local_revision
-          allowed_in_path do
-            git("rev-parse --verify #{Shellwords.shellescape(ref)}", true).strip
-          end
-        end
-
-        # Escape the URI for git commands
-        def uri_escaped_with_configured_credentials
-          remote = configured_uri_for(uri)
-          if Bundler::WINDOWS
-            # Windows quoting requires double quotes only, with double quotes
-            # inside the string escaped by being doubled.
-            '"' + remote.gsub('"') { '""' } + '"'
-          else
-            # Bash requires single quoted strings, with the single quotes escaped
-            # by ending the string, escaping the quote, and restarting the string.
-            "'" + remote.gsub("'") { "'\\''" } + "'"
+          allowed_with_path do
+            git("rev-parse", "--verify", ref || "HEAD", :dir => path).strip
           end
+        rescue GitCommandError => e
+          raise MissingGitRevisionError.new(e.command, path, ref, URICredentialsFilter.credential_filtered_uri(uri))
         end
 
         # Adds credentials to the URI as Fetcher#configured_uri_for does
@@ -227,32 +207,56 @@ module Bundler
         end
 
         def allow?
-          @git ? @git.allow_git_ops? : true
+          allowed = @git ? @git.allow_git_ops? : true
+
+          raise GitNotInstalledError.new if allowed && !Bundler.git_present?
+
+          allowed
         end
 
-        def in_path(&blk)
+        def with_path(&blk)
           checkout unless path.exist?
-          _ = URICredentialsFilter # load it before we chdir
-          SharedHelpers.chdir(path, &blk)
+          blk.call
         end
 
-        def allowed_in_path
-          return in_path { yield } if allow?
+        def allowed_with_path
+          return with_path { yield } if allow?
           raise GitError, "The git source #{uri} is not yet checked out. Please run `bundle install` before trying to start your application"
         end
 
-        def capture_and_filter_stderr(uri, cmd)
+        def check_allowed(command)
+          require "shellwords"
+          command_with_no_credentials = URICredentialsFilter.credential_filtered_string("git #{command.shelljoin}", uri)
+          raise GitNotAllowedError.new(command_with_no_credentials) unless allow?
+          command_with_no_credentials
+        end
+
+        def capture_and_filter_stderr(*cmd)
           require "open3"
-          return_value, captured_err, status = Open3.capture3(cmd)
-          Bundler.ui.warn URICredentialsFilter.credential_filtered_string(captured_err, uri) if uri && !captured_err.empty?
+          return_value, captured_err, status = Open3.capture3(*cmd)
+          Bundler.ui.warn URICredentialsFilter.credential_filtered_string(captured_err, uri) unless captured_err.empty?
           [return_value, status]
         end
 
-        def capture_and_ignore_stderr(cmd)
+        def capture_and_ignore_stderr(*cmd)
           require "open3"
-          return_value, _, status = Open3.capture3(cmd)
+          return_value, _, status = Open3.capture3(*cmd)
           [return_value, status]
         end
+
+        def capture3_args_for(cmd, dir)
+          return ["git", *cmd] unless dir
+
+          if Bundler.feature_flag.bundler_3_mode? || supports_minus_c?
+            ["git", "-C", dir.to_s, *cmd]
+          else
+            ["git", *cmd, { :chdir => dir.to_s }]
+          end
+        end
+
+        def supports_minus_c?
+          @supports_minus_c ||= Gem::Version.new(version) >= Gem::Version.new("1.8.5")
+        end
       end
     end
   end
--- ruby2.7-2.7.6.orig/lib/bundler/source/metadata.rb
+++ ruby2.7-2.7.6/lib/bundler/source/metadata.rb
@@ -5,7 +5,7 @@ module Bundler
     class Metadata < Source
       def specs
         @specs ||= Index.build do |idx|
-          idx << Gem::Specification.new("Ruby\0", RubyVersion.system.to_gem_version_with_patchlevel)
+          idx << Gem::Specification.new("Ruby\0", Gem.ruby_version)
           idx << Gem::Specification.new("RubyGems\0", Gem::VERSION) do |s|
             s.required_rubygems_version = Gem::Requirement.default
           end
@@ -22,10 +22,10 @@ module Bundler
             s.summary  = "The best way to manage your application's dependencies"
             s.executables = %w[bundle]
             # can't point to the actual gemspec or else the require paths will be wrong
-            s.loaded_from = File.expand_path("..", __FILE__)
+            s.loaded_from = __dir__
           end
 
-          if local_spec = Bundler.rubygems.find_name("bundler").find {|s| s.version.to_s == VERSION }
+          if local_spec = Bundler.rubygems.find_bundler(VERSION)
             idx << local_spec
           end
 
@@ -33,10 +33,6 @@ module Bundler
         end
       end
 
-      def cached!; end
-
-      def remote!; end
-
       def options
         {}
       end
--- ruby2.7-2.7.6.orig/lib/bundler/source/path.rb
+++ ruby2.7-2.7.6/lib/bundler/source/path.rb
@@ -82,7 +82,9 @@ module Bundler
       end
 
       def install(spec, options = {})
-        print_using_message "Using #{version_message(spec)} from #{self}"
+        using_message = "Using #{version_message(spec, options[:previous_spec])} from #{self}"
+        using_message += " and installing its executables" unless spec.executables.empty?
+        print_using_message using_message
         generate_bin(spec, :disable_extensions => true)
         nil # no post-install message
       end
@@ -125,14 +127,18 @@ module Bundler
         @expanded_original_path ||= expand(original_path)
       end
 
-    private
+      private
 
       def expanded_path
         @expanded_path ||= expand(path)
       end
 
       def expand(somepath)
-        somepath.expand_path(root_path)
+        if Bundler.current_ruby.jruby? # TODO: Unify when https://github.com/rubygems/bundler/issues/7598 fixed upstream and all supported jrubies include the fix
+          somepath.expand_path(root_path).expand_path
+        else
+          somepath.expand_path(root_path)
+        end
       rescue ArgumentError => e
         Bundler.ui.debug(e)
         raise PathError, "There was an error while trying to use the path " \
@@ -167,7 +173,7 @@ module Bundler
 
         if File.directory?(expanded_path)
           # We sort depth-first since `<<` will override the earlier-found specs
-          Dir["#{expanded_path}/#{@glob}"].sort_by {|p| -p.split(File::SEPARATOR).size }.each do |file|
+          Gem::Util.glob_files_in_dir(@glob, expanded_path).sort_by {|p| -p.split(File::SEPARATOR).size }.each do |file|
             next unless spec = load_gemspec(file)
             spec.source = self
 
--- ruby2.7-2.7.6.orig/lib/bundler/source/path/installer.rb
+++ ruby2.7-2.7.6/lib/bundler/source/path/installer.rb
@@ -1,5 +1,7 @@
 # frozen_string_literal: true
 
+require_relative "../../rubygems_gem_installer"
+
 module Bundler
   class Source
     class Path
@@ -26,23 +28,21 @@ module Bundler
         end
 
         def post_install
-          SharedHelpers.chdir(@gem_dir) do
-            run_hooks(:pre_install)
+          run_hooks(:pre_install)
 
-            unless @disable_extensions
-              build_extensions
-              run_hooks(:post_build)
-            end
+          unless @disable_extensions
+            build_extensions
+            run_hooks(:post_build)
+          end
 
-            generate_bin unless spec.executables.nil? || spec.executables.empty?
+          generate_bin unless spec.executables.empty?
 
-            run_hooks(:post_install)
-          end
+          run_hooks(:post_install)
         ensure
           Bundler.rm_rf(@tmp_dir) if Bundler.requires_sudo?
         end
 
-      private
+        private
 
         def generate_bin
           super
--- ruby2.7-2.7.6.orig/lib/bundler/source/rubygems.rb
+++ ruby2.7-2.7.6/lib/bundler/source/rubygems.rb
@@ -20,18 +20,38 @@ module Bundler
         @dependency_names = []
         @allow_remote = false
         @allow_cached = false
+        @allow_local = options["allow_local"] || false
         @caches = [cache_path, *Bundler.rubygems.gem_cache]
 
-        Array(options["remotes"] || []).reverse_each {|r| add_remote(r) }
+        Array(options["remotes"]).reverse_each {|r| add_remote(r) }
+      end
+
+      def local_only!
+        @specs = nil
+        @allow_local = true
+        @allow_cached = false
+        @allow_remote = false
+      end
+
+      def local!
+        return if @allow_local
+
+        @specs = nil
+        @allow_local = true
       end
 
       def remote!
+        return if @allow_remote
+
         @specs = nil
         @allow_remote = true
       end
 
       def cached!
+        return if @allow_cached
+
         @specs = nil
+        @allow_local = true
         @allow_cached = true
       end
 
@@ -49,9 +69,17 @@ module Bundler
         o.is_a?(Rubygems) && (o.credless_remotes - credless_remotes).empty?
       end
 
+      def multiple_remotes?
+        @remotes.size > 1
+      end
+
+      def no_remotes?
+        @remotes.size == 0
+      end
+
       def can_lock?(spec)
-        return super if Bundler.feature_flag.disable_multisource?
-        spec.source.is_a?(Rubygems)
+        return super unless multiple_remotes?
+        include?(spec.source)
       end
 
       def options
@@ -73,12 +101,27 @@ module Bundler
       def to_s
         if remotes.empty?
           "locally installed gems"
-        else
-          remote_names = remotes.map(&:to_s).join(", ")
+        elsif @allow_remote && @allow_cached && @allow_local
+          "rubygems repository #{remote_names}, cached gems or installed locally"
+        elsif @allow_remote && @allow_local
           "rubygems repository #{remote_names} or installed locally"
+        elsif @allow_remote
+          "rubygems repository #{remote_names}"
+        elsif @allow_cached && @allow_local
+          "cached gems or installed locally"
+        else
+          "locally installed gems"
+        end
+      end
+
+      def identifier
+        if remotes.empty?
+          "locally installed gems"
+        else
+          "rubygems repository #{remote_names}"
         end
       end
-      alias_method :name, :to_s
+      alias_method :name, :identifier
 
       def specs
         @specs ||= begin
@@ -87,107 +130,109 @@ module Bundler
           # small_idx.use large_idx.
           idx = @allow_remote ? remote_specs.dup : Index.new
           idx.use(cached_specs, :override_dupes) if @allow_cached || @allow_remote
-          idx.use(installed_specs, :override_dupes)
+          idx.use(installed_specs, :override_dupes) if @allow_local
           idx
         end
       end
 
-      def install(spec, opts = {})
-        force = opts[:force]
-        ensure_builtin_gems_cached = opts[:ensure_builtin_gems_cached]
-
-        if ensure_builtin_gems_cached && builtin_gem?(spec)
-          if !cached_path(spec)
-            cached_built_in_gem(spec) unless spec.remote
-            force = true
-          else
-            spec.loaded_from = loaded_from(spec)
-          end
+      def install(spec, options = {})
+        force = options[:force]
+        ensure_builtin_gems_cached = options[:ensure_builtin_gems_cached]
+
+        if ensure_builtin_gems_cached && spec.default_gem? && !cached_path(spec)
+          cached_built_in_gem(spec) unless spec.remote
+          force = true
         end
 
-        if (installed?(spec) || Plugin.installed?(spec.name)) && !force
+        if installed?(spec) && !force
           print_using_message "Using #{version_message(spec)}"
           return nil # no post-install message
         end
 
-        # Download the gem to get the spec, because some specs that are returned
-        # by rubygems.org are broken and wrong.
         if spec.remote
           # Check for this spec from other sources
-          uris = [spec.remote.anonymized_uri]
-          uris += remotes_for_spec(spec).map(&:anonymized_uri)
-          uris.uniq!
+          uris = [spec.remote, *remotes_for_spec(spec)].map(&:anonymized_uri).uniq
           Installer.ambiguous_gems << [spec.name, *uris] if uris.length > 1
+        end
+
+        path = fetch_gem_if_possible(spec, options[:previous_spec])
+        raise GemNotFound, "Could not find #{spec.file_name} for installation" unless path
+
+        return if Bundler.settings[:no_install]
+
+        if requires_sudo?
+          install_path = Bundler.tmp(spec.full_name)
+          bin_path     = install_path.join("bin")
+        else
+          install_path = rubygems_dir
+          bin_path     = Bundler.system_bindir
+        end
+
+        Bundler.mkdir_p bin_path, :no_sudo => true unless spec.executables.empty? || Bundler.rubygems.provides?(">= 2.7.5")
 
-          path = fetch_gem(spec)
-          begin
-            s = Bundler.rubygems.spec_from_gem(path, Bundler.settings["trust-policy"])
-            spec.__swap__(s)
-          rescue StandardError
+        require_relative "../rubygems_gem_installer"
+
+        installer = Bundler::RubyGemsGemInstaller.at(
+          path,
+          :security_policy     => Bundler.rubygems.security_policies[Bundler.settings["trust-policy"]],
+          :install_dir         => install_path.to_s,
+          :bin_dir             => bin_path.to_s,
+          :ignore_dependencies => true,
+          :wrappers            => true,
+          :env_shebang         => true,
+          :build_args          => options[:build_args],
+          :bundler_expected_checksum => spec.respond_to?(:checksum) && spec.checksum,
+          :bundler_extension_cache_path => extension_cache_path(spec)
+        )
+
+        if spec.remote
+          s = begin
+            installer.spec
+          rescue Gem::Package::FormatError
             Bundler.rm_rf(path)
             raise
+          rescue Gem::Security::Exception => e
+            raise SecurityError,
+             "The gem #{File.basename(path, ".gem")} can't be installed because " \
+             "the security policy didn't allow it, with the message: #{e.message}"
           end
+
+          spec.__swap__(s)
         end
 
-        unless Bundler.settings[:no_install]
-          message = "Installing #{version_message(spec)}"
-          message += " with native extensions" if spec.extensions.any?
-          Bundler.ui.confirm message
-
-          path = cached_gem(spec)
-          if requires_sudo?
-            install_path = Bundler.tmp(spec.full_name)
-            bin_path     = install_path.join("bin")
-          else
-            install_path = rubygems_dir
-            bin_path     = Bundler.system_bindir
-          end
+        message = "Installing #{version_message(spec, options[:previous_spec])}"
+        message += " with native extensions" if spec.extensions.any?
+        Bundler.ui.confirm message
 
-          Bundler.mkdir_p bin_path, :no_sudo => true unless spec.executables.empty? || Bundler.rubygems.provides?(">= 2.7.5")
+        installed_spec = installer.install
 
-          installed_spec = nil
-          Bundler.rubygems.preserve_paths do
-            installed_spec = Bundler::RubyGemsGemInstaller.at(
-              path,
-              :install_dir         => install_path.to_s,
-              :bin_dir             => bin_path.to_s,
-              :ignore_dependencies => true,
-              :wrappers            => true,
-              :env_shebang         => true,
-              :build_args          => opts[:build_args],
-              :bundler_expected_checksum => spec.respond_to?(:checksum) && spec.checksum,
-              :bundler_extension_cache_path => extension_cache_path(spec)
-            ).install
-          end
-          spec.full_gem_path = installed_spec.full_gem_path
+        spec.full_gem_path = installed_spec.full_gem_path
+        spec.loaded_from = installed_spec.loaded_from
 
-          # SUDO HAX
-          if requires_sudo?
-            Bundler.rubygems.repository_subdirectories.each do |name|
-              src = File.join(install_path, name, "*")
-              dst = File.join(rubygems_dir, name)
-              if name == "extensions" && Dir.glob(src).any?
-                src = File.join(src, "*/*")
-                ext_src = Dir.glob(src).first
-                ext_src.gsub!(src[0..-6], "")
-                dst = File.dirname(File.join(dst, ext_src))
-              end
-              SharedHelpers.filesystem_access(dst) do |p|
-                Bundler.mkdir_p(p)
-              end
-              Bundler.sudo "cp -R #{src} #{dst}" if Dir[src].any?
+        # SUDO HAX
+        if requires_sudo?
+          Bundler.rubygems.repository_subdirectories.each do |name|
+            src = File.join(install_path, name, "*")
+            dst = File.join(rubygems_dir, name)
+            if name == "extensions" && Dir.glob(src).any?
+              src = File.join(src, "*/*")
+              ext_src = Dir.glob(src).first
+              ext_src.gsub!(src[0..-6], "")
+              dst = File.dirname(File.join(dst, ext_src))
+            end
+            SharedHelpers.filesystem_access(dst) do |p|
+              Bundler.mkdir_p(p)
             end
+            Bundler.sudo "cp -R #{src} #{dst}" if Dir[src].any?
+          end
 
-            spec.executables.each do |exe|
-              SharedHelpers.filesystem_access(Bundler.system_bindir) do |p|
-                Bundler.mkdir_p(p)
-              end
-              Bundler.sudo "cp -R #{install_path}/bin/#{exe} #{Bundler.system_bindir}/"
+          spec.executables.each do |exe|
+            SharedHelpers.filesystem_access(Bundler.system_bindir) do |p|
+              Bundler.mkdir_p(p)
             end
+            Bundler.sudo "cp -R #{install_path}/bin/#{exe} #{Bundler.system_bindir}/"
           end
-          installed_spec.loaded_from = loaded_from(spec)
         end
-        spec.loaded_from = loaded_from(spec)
 
         spec.post_install_message
       ensure
@@ -195,12 +240,8 @@ module Bundler
       end
 
       def cache(spec, custom_path = nil)
-        if builtin_gem?(spec)
-          cached_path = cached_built_in_gem(spec)
-        else
-          cached_path = cached_gem(spec)
-        end
-        raise GemNotFound, "Missing gem file '#{spec.full_name}.gem'." unless cached_path
+        cached_path = Bundler.settings[:cache_all_platforms] ? fetch_gem_if_possible(spec) : cached_gem(spec)
+        raise GemNotFound, "Missing gem file '#{spec.file_name}'." unless cached_path
         return if File.dirname(cached_path) == Bundler.app_cache.to_s
         Bundler.ui.info "  * #{File.basename(cached_path)}"
         FileUtils.cp(cached_path, Bundler.app_cache(custom_path))
@@ -227,25 +268,16 @@ module Bundler
         @remotes.unshift(uri) unless @remotes.include?(uri)
       end
 
-      def equivalent_remotes?(other_remotes)
-        other_remotes.map(&method(:remove_auth)) == @remotes.map(&method(:remove_auth))
-      end
-
-      def replace_remotes(other_remotes, allow_equivalent = false)
-        return false if other_remotes == @remotes
-
-        equivalent = allow_equivalent && equivalent_remotes?(other_remotes)
-
-        @remotes = []
-        other_remotes.reverse_each do |r|
-          add_remote r.to_s
+      def spec_names
+        if @allow_remote && dependency_api_available?
+          remote_specs.spec_names
+        else
+          []
         end
-
-        !equivalent
       end
 
       def unmet_deps
-        if @allow_remote && api_fetchers.any?
+        if @allow_remote && dependency_api_available?
           remote_specs.unmet_dependency_names
         else
           []
@@ -261,7 +293,7 @@ module Bundler
 
       def double_check_for(unmet_dependency_names)
         return unless @allow_remote
-        return unless api_fetchers.any?
+        return unless dependency_api_available?
 
         unmet_dependency_names = unmet_dependency_names.call
         unless unmet_dependency_names.nil?
@@ -283,21 +315,32 @@ module Bundler
         remote_specs.each do |spec|
           case spec
           when EndpointSpecification, Gem::Specification, StubSpecification, LazySpecification
-            names.concat(spec.runtime_dependencies)
+            names.concat(spec.runtime_dependencies.map(&:name))
           when RemoteSpecification # from the full index
             return nil
           else
             raise "unhandled spec type (#{spec.inspect})"
           end
         end
-        names.map!(&:name) if names
         names
       end
 
-    protected
+      def dependency_api_available?
+        api_fetchers.any?
+      end
+
+      protected
+
+      def remote_names
+        remotes.map(&:to_s).join(", ")
+      end
 
       def credless_remotes
-        remotes.map(&method(:suppress_configured_credentials))
+        if Bundler.settings[:allow_deployment_source_credential_changes]
+          remotes.map(&method(:remove_auth))
+        else
+          remotes.map(&method(:suppress_configured_credentials))
+        end
       end
 
       def remotes_for_spec(spec)
@@ -307,23 +350,26 @@ module Bundler
         end
       end
 
-      def loaded_from(spec)
-        "#{rubygems_dir}/specifications/#{spec.full_name}.gemspec"
-      end
-
       def cached_gem(spec)
-        cached_gem = cached_path(spec)
-        unless cached_gem
-          raise Bundler::GemNotFound, "Could not find #{spec.file_name} for installation"
+        if spec.default_gem?
+          cached_built_in_gem(spec)
+        else
+          cached_path(spec)
         end
-        cached_gem
       end
 
       def cached_path(spec)
-        possibilities = @caches.map {|p| "#{p}/#{spec.file_name}" }
+        global_cache_path = download_cache_path(spec)
+        @caches << global_cache_path if global_cache_path
+
+        possibilities = @caches.map {|p| package_path(p, spec) }
         possibilities.find {|p| File.exist?(p) }
       end
 
+      def package_path(cache_path, spec)
+        "#{cache_path}/#{spec.file_name}"
+      end
+
       def normalize_uri(uri)
         uri = uri.to_s
         uri = "#{uri}/" unless uri =~ %r{/$}
@@ -354,7 +400,6 @@ module Bundler
       def installed_specs
         @installed_specs ||= Index.build do |idx|
           Bundler.rubygems.all_specs.reverse_each do |spec|
-            next if spec.name == "bundler"
             spec.source = self
             if Bundler.rubygems.spec_missing_extensions?(spec, false)
               Bundler.ui.debug "Source #{self} is ignoring #{spec} because it is missing extensions"
@@ -367,16 +412,12 @@ module Bundler
 
       def cached_specs
         @cached_specs ||= begin
-          idx = installed_specs.dup
+          idx = @allow_local ? installed_specs.dup : Index.new
 
           Dir["#{cache_path}/*.gem"].each do |gemfile|
             next if gemfile =~ /^bundler\-[\d\.]+?\.gem/
             s ||= Bundler.rubygems.spec_from_gem(gemfile)
             s.source = self
-            if Bundler.rubygems.spec_missing_extensions?(s, false)
-              Bundler.ui.debug "Source #{self} is ignoring #{s} because it is missing extensions"
-              next
-            end
             idx << s
           end
 
@@ -409,34 +450,48 @@ module Bundler
       def fetch_names(fetchers, dependency_names, index, override_dupes)
         fetchers.each do |f|
           if dependency_names
-            Bundler.ui.info "Fetching gem metadata from #{f.uri}", Bundler.ui.debug?
+            Bundler.ui.info "Fetching gem metadata from #{URICredentialsFilter.credential_filtered_uri(f.uri)}", Bundler.ui.debug?
             index.use f.specs_with_retry(dependency_names, self), override_dupes
             Bundler.ui.info "" unless Bundler.ui.debug? # new line now that the dots are over
           else
-            Bundler.ui.info "Fetching source index from #{f.uri}"
+            Bundler.ui.info "Fetching source index from #{URICredentialsFilter.credential_filtered_uri(f.uri)}"
             index.use f.specs_with_retry(nil, self), override_dupes
           end
         end
       end
 
-      def fetch_gem(spec)
-        return false unless spec.remote
+      def fetch_gem_if_possible(spec, previous_spec = nil)
+        if spec.remote
+          fetch_gem(spec, previous_spec)
+        else
+          cached_gem(spec)
+        end
+      end
 
+      def fetch_gem(spec, previous_spec = nil)
         spec.fetch_platform
 
-        download_path = requires_sudo? ? Bundler.tmp(spec.full_name) : rubygems_dir
-        gem_path = "#{rubygems_dir}/cache/#{spec.full_name}.gem"
+        cache_path = download_cache_path(spec) || default_cache_path_for(rubygems_dir)
+        gem_path = package_path(cache_path, spec)
+        return gem_path if File.exist?(gem_path)
+
+        if requires_sudo?
+          download_path = Bundler.tmp(spec.full_name)
+          download_cache_path = default_cache_path_for(download_path)
+        else
+          download_cache_path = cache_path
+        end
 
-        SharedHelpers.filesystem_access("#{download_path}/cache") do |p|
+        SharedHelpers.filesystem_access(download_cache_path) do |p|
           FileUtils.mkdir_p(p)
         end
-        download_gem(spec, download_path)
+        download_gem(spec, download_cache_path, previous_spec)
 
         if requires_sudo?
-          SharedHelpers.filesystem_access("#{rubygems_dir}/cache") do |p|
+          SharedHelpers.filesystem_access(cache_path) do |p|
             Bundler.mkdir_p(p)
           end
-          Bundler.sudo "mv #{download_path}/cache/#{spec.full_name}.gem #{gem_path}"
+          Bundler.sudo "mv #{package_path(download_cache_path, spec)} #{gem_path}"
         end
 
         gem_path
@@ -444,16 +499,8 @@ module Bundler
         Bundler.rm_rf(download_path) if requires_sudo?
       end
 
-      def builtin_gem?(spec)
-        # Ruby 2.1, where all included gems have this summary
-        return true if spec.summary =~ /is bundled with Ruby/
-
-        # Ruby 2.0, where gemspecs are stored in specifications/default/
-        spec.loaded_from && spec.loaded_from.include?("specifications/default/")
-      end
-
       def installed?(spec)
-        installed_specs[spec].any?
+        installed_specs[spec].any? && !spec.deleted_gem?
       end
 
       def requires_sudo?
@@ -461,14 +508,18 @@ module Bundler
       end
 
       def rubygems_dir
-        Bundler.rubygems.gem_dir
+        Bundler.bundle_path
+      end
+
+      def default_cache_path_for(dir)
+        "#{dir}/cache"
       end
 
       def cache_path
         Bundler.app_cache
       end
 
-    private
+      private
 
       # Checks if the requested spec exists in the global cache. If it does,
       # we copy it to the download path, and if it does not, we download it.
@@ -476,45 +527,16 @@ module Bundler
       # @param  [Specification] spec
       #         the spec we want to download or retrieve from the cache.
       #
-      # @param  [String] download_path
+      # @param  [String] download_cache_path
       #         the local directory the .gem will end up in.
       #
-      def download_gem(spec, download_path)
-        local_path = File.join(download_path, "cache/#{spec.full_name}.gem")
-
-        if (cache_path = download_cache_path(spec)) && cache_path.file?
-          SharedHelpers.filesystem_access(local_path) do
-            FileUtils.cp(cache_path, local_path)
-          end
-        else
-          uri = spec.remote.uri
-          Bundler.ui.confirm("Fetching #{version_message(spec)}")
-          rubygems_local_path = Bundler.rubygems.download_gem(spec, uri, download_path)
-          if rubygems_local_path != local_path
-            FileUtils.mv(rubygems_local_path, local_path)
-          end
-          cache_globally(spec, local_path)
-        end
-      end
-
-      # Checks if the requested spec exists in the global cache. If it does
-      # not, we create the relevant global cache subdirectory if it does not
-      # exist and copy the spec from the local cache to the global cache.
-      #
-      # @param  [Specification] spec
-      #         the spec we want to copy to the global cache.
+      # @param  [Specification] previous_spec
+      #         the spec previously locked
       #
-      # @param  [String] local_cache_path
-      #         the local directory from which we want to copy the .gem.
-      #
-      def cache_globally(spec, local_cache_path)
-        return unless cache_path = download_cache_path(spec)
-        return if cache_path.exist?
-
-        SharedHelpers.filesystem_access(cache_path.dirname, &:mkpath)
-        SharedHelpers.filesystem_access(cache_path) do
-          FileUtils.cp(local_cache_path, cache_path)
-        end
+      def download_gem(spec, download_cache_path, previous_spec = nil)
+        uri = spec.remote.uri
+        Bundler.ui.confirm("Fetching #{version_message(spec, previous_spec)}")
+        Bundler.rubygems.download_gem(spec, uri, download_cache_path)
       end
 
       # Returns the global cache path of the calling Rubygems::Source object.
@@ -533,7 +555,7 @@ module Bundler
         return unless remote = spec.remote
         return unless cache_slug = remote.cache_slug
 
-        Bundler.user_cache.join("gems", cache_slug, spec.file_name)
+        Bundler.user_cache.join("gems", cache_slug)
       end
 
       def extension_cache_slug(spec)
--- ruby2.7-2.7.6.orig/lib/bundler/source/rubygems/remote.rb
+++ ruby2.7-2.7.6/lib/bundler/source/rubygems/remote.rb
@@ -39,7 +39,7 @@ module Bundler
           "rubygems remote at #{anonymized_uri}"
         end
 
-      private
+        private
 
         def apply_auth(uri, auth)
           if auth && uri.userinfo.nil?
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/source/rubygems_aggregate.rb
@@ -0,0 +1,68 @@
+# frozen_string_literal: true
+
+module Bundler
+  class Source
+    class RubygemsAggregate
+      attr_reader :source_map, :sources
+
+      def initialize(sources, source_map)
+        @sources = sources
+        @source_map = source_map
+
+        @index = build_index
+      end
+
+      def specs
+        @index
+      end
+
+      def identifier
+        to_s
+      end
+
+      def to_s
+        "any of the sources"
+      end
+
+      private
+
+      def build_index
+        Index.build do |idx|
+          dependency_names = source_map.pinned_spec_names
+
+          sources.all_sources.each do |source|
+            source.dependency_names = dependency_names - source_map.pinned_spec_names(source)
+            idx.add_source source.specs
+            dependency_names.concat(source.unmet_deps).uniq!
+          end
+
+          double_check_for_index(idx, dependency_names)
+        end
+      end
+
+      # Suppose the gem Foo depends on the gem Bar.  Foo exists in Source A.  Bar has some versions that exist in both
+      # sources A and B.  At this point, the API request will have found all the versions of Bar in source A,
+      # but will not have found any versions of Bar from source B, which is a problem if the requested version
+      # of Foo specifically depends on a version of Bar that is only found in source B. This ensures that for
+      # each spec we found, we add all possible versions from all sources to the index.
+      def double_check_for_index(idx, dependency_names)
+        pinned_names = source_map.pinned_spec_names
+
+        names = :names # do this so we only have to traverse to get dependency_names from the index once
+        unmet_dependency_names = lambda do
+          return names unless names == :names
+          new_names = sources.all_sources.map(&:dependency_names_to_double_check)
+          return names = nil if new_names.compact!
+          names = new_names.flatten(1).concat(dependency_names)
+          names.uniq!
+          names -= pinned_names
+          names
+        end
+
+        sources.all_sources.each do |source|
+          source.double_check_for(unmet_dependency_names)
+        end
+      end
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/lib/bundler/source_list.rb
+++ ruby2.7-2.7.6/lib/bundler/source_list.rb
@@ -1,30 +1,53 @@
 # frozen_string_literal: true
 
-require "set"
-
 module Bundler
   class SourceList
     attr_reader :path_sources,
       :git_sources,
       :plugin_sources,
-      :global_rubygems_source,
+      :global_path_source,
       :metadata_source
 
+    def global_rubygems_source
+      @global_rubygems_source ||= rubygems_aggregate_class.new("allow_local" => true)
+    end
+
     def initialize
       @path_sources           = []
       @git_sources            = []
       @plugin_sources         = []
       @global_rubygems_source = nil
-      @rubygems_aggregate     = rubygems_aggregate_class.new
+      @global_path_source     = nil
       @rubygems_sources       = []
       @metadata_source        = Source::Metadata.new
+
+      @merged_gem_lockfile_sections = false
+    end
+
+    def merged_gem_lockfile_sections?
+      @merged_gem_lockfile_sections
+    end
+
+    def merged_gem_lockfile_sections!(replacement_source)
+      @merged_gem_lockfile_sections = true
+      @global_rubygems_source = replacement_source
+    end
+
+    def aggregate_global_source?
+      global_rubygems_source.multiple_remotes?
+    end
+
+    def implicit_global_source?
+      global_rubygems_source.no_remotes?
     end
 
     def add_path_source(options = {})
       if options["gemspec"]
         add_source_to_list Source::Gemspec.new(options), path_sources
       else
-        add_source_to_list Source::Path.new(options), path_sources
+        path_source = add_source_to_list Source::Path.new(options), path_sources
+        @global_path_source ||= path_source if options["global"]
+        path_source
       end
     end
 
@@ -35,32 +58,31 @@ module Bundler
     end
 
     def add_rubygems_source(options = {})
-      add_source_to_list Source::Rubygems.new(options), @rubygems_sources
+      new_source = Source::Rubygems.new(options)
+      return @global_rubygems_source if @global_rubygems_source == new_source
+
+      add_source_to_list new_source, @rubygems_sources
     end
 
     def add_plugin_source(source, options = {})
       add_source_to_list Plugin.source(source).new(options), @plugin_sources
     end
 
-    def global_rubygems_source=(uri)
-      if Bundler.feature_flag.disable_multisource?
-        @global_rubygems_source ||= rubygems_aggregate_class.new("remotes" => uri)
-      end
-      add_rubygems_remote(uri)
-    end
-
-    def add_rubygems_remote(uri)
-      return if Bundler.feature_flag.disable_multisource?
-      @rubygems_aggregate.add_remote(uri)
-      @rubygems_aggregate
+    def add_global_rubygems_remote(uri)
+      global_rubygems_source.add_remote(uri)
+      global_rubygems_source
     end
 
     def default_source
-      global_rubygems_source || @rubygems_aggregate
+      global_path_source || global_rubygems_source
     end
 
     def rubygems_sources
-      @rubygems_sources + [default_source]
+      non_global_rubygems_sources + [global_rubygems_source]
+    end
+
+    def non_global_rubygems_sources
+      @rubygems_sources
     end
 
     def rubygems_remotes
@@ -71,37 +93,55 @@ module Bundler
       path_sources + git_sources + plugin_sources + rubygems_sources + [metadata_source]
     end
 
+    def non_default_explicit_sources
+      all_sources - [default_source, metadata_source]
+    end
+
     def get(source)
-      source_list_for(source).find {|s| equal_source?(source, s) || equivalent_source?(source, s) }
+      source_list_for(source).find {|s| equivalent_source?(source, s) }
+    end
+
+    def get_with_fallback(source)
+      get(source) || default_source
     end
 
     def lock_sources
-      lock_sources = (path_sources + git_sources + plugin_sources).sort_by(&:to_s)
-      if Bundler.feature_flag.disable_multisource?
-        lock_sources + rubygems_sources.sort_by(&:to_s)
+      lock_other_sources + lock_rubygems_sources
+    end
+
+    def lock_other_sources
+      (path_sources + git_sources + plugin_sources).sort_by(&:identifier)
+    end
+
+    def lock_rubygems_sources
+      if merged_gem_lockfile_sections?
+        [combine_rubygems_sources]
       else
-        lock_sources << combine_rubygems_sources
+        rubygems_sources.sort_by(&:identifier)
       end
     end
 
     # Returns true if there are changes
     def replace_sources!(replacement_sources)
-      return true if replacement_sources.empty?
+      return false if replacement_sources.empty?
 
-      [path_sources, git_sources, plugin_sources].each do |source_list|
-        source_list.map! do |source|
-          replacement_sources.find {|s| s == source } || source
-        end
-      end
+      @rubygems_sources, @path_sources, @git_sources, @plugin_sources = map_sources(replacement_sources)
+      @global_rubygems_source = global_replacement_source(replacement_sources)
 
-      replacement_rubygems = !Bundler.feature_flag.disable_multisource? &&
-        replacement_sources.detect {|s| s.is_a?(Source::Rubygems) }
-      @rubygems_aggregate = replacement_rubygems if replacement_rubygems
+      different_sources?(lock_sources, replacement_sources)
+    end
+
+    # Returns true if there are changes
+    def expired_sources?(replacement_sources)
+      return false if replacement_sources.empty?
 
-      return true if !equal_sources?(lock_sources, replacement_sources) && !equivalent_sources?(lock_sources, replacement_sources)
-      return true if replacement_rubygems && rubygems_remotes.to_set != replacement_rubygems.remotes.to_set
+      lock_sources = dup_with_replaced_sources(replacement_sources).lock_sources
 
-      false
+      different_sources?(lock_sources, replacement_sources)
+    end
+
+    def local_only!
+      all_sources.each(&:local_only!)
     end
 
     def cached!
@@ -112,11 +152,33 @@ module Bundler
       all_sources.each(&:remote!)
     end
 
-    def rubygems_primary_remotes
-      @rubygems_aggregate.remotes
+    private
+
+    def dup_with_replaced_sources(replacement_sources)
+      new_source_list = dup
+      new_source_list.replace_sources!(replacement_sources)
+      new_source_list
+    end
+
+    def map_sources(replacement_sources)
+      [@rubygems_sources, @path_sources, @git_sources, @plugin_sources].map do |sources|
+        sources.map do |source|
+          replacement_sources.find {|s| s == source } || source
+        end
+      end
+    end
+
+    def global_replacement_source(replacement_sources)
+      replacement_source = replacement_sources.find {|s| s == global_rubygems_source }
+      return global_rubygems_source unless replacement_source
+
+      replacement_source.local!
+      replacement_source
     end
 
-  private
+    def different_sources?(lock_sources, replacement_sources)
+      !equivalent_sources?(lock_sources, replacement_sources)
+    end
 
     def rubygems_aggregate_class
       Source::Rubygems
@@ -147,37 +209,17 @@ module Bundler
       if source.uri =~ /^git\:/
         Bundler.ui.warn "The git source `#{source.uri}` uses the `git` protocol, " \
           "which transmits data without encryption. Disable this warning with " \
-          "`bundle config set git.allow_insecure true`, or switch to the `https` " \
+          "`bundle config set --local git.allow_insecure true`, or switch to the `https` " \
           "protocol to keep your data secure."
       end
     end
 
-    def equal_sources?(lock_sources, replacement_sources)
-      lock_sources.to_set == replacement_sources.to_set
-    end
-
-    def equal_source?(source, other_source)
-      source == other_source
-    end
-
-    def equivalent_source?(source, other_source)
-      return false unless Bundler.settings[:allow_deployment_source_credential_changes] && source.is_a?(Source::Rubygems)
-
-      equivalent_rubygems_sources?([source], [other_source])
-    end
-
     def equivalent_sources?(lock_sources, replacement_sources)
-      return false unless Bundler.settings[:allow_deployment_source_credential_changes]
-
-      lock_rubygems_sources, lock_other_sources = lock_sources.partition {|s| s.is_a?(Source::Rubygems) }
-      replacement_rubygems_sources, replacement_other_sources = replacement_sources.partition {|s| s.is_a?(Source::Rubygems) }
-
-      equivalent_rubygems_sources?(lock_rubygems_sources, replacement_rubygems_sources) && equal_sources?(lock_other_sources, replacement_other_sources)
+      lock_sources.sort_by(&:identifier) == replacement_sources.sort_by(&:identifier)
     end
 
-    def equivalent_rubygems_sources?(lock_sources, replacement_sources)
-      actual_remotes = replacement_sources.map(&:remotes).flatten.uniq
-      lock_sources.all? {|s| s.equivalent_remotes?(actual_remotes) }
+    def equivalent_source?(source, other_source)
+      source == other_source
     end
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/source_map.rb
@@ -0,0 +1,71 @@
+# frozen_string_literal: true
+
+module Bundler
+  class SourceMap
+    attr_reader :sources, :dependencies, :locked_specs
+
+    def initialize(sources, dependencies, locked_specs)
+      @sources = sources
+      @dependencies = dependencies
+      @locked_specs = locked_specs
+    end
+
+    def pinned_spec_names(skip = nil)
+      direct_requirements.reject {|_, source| source == skip }.keys
+    end
+
+    def all_requirements
+      requirements = direct_requirements.dup
+
+      unmet_deps = sources.non_default_explicit_sources.map do |source|
+        (source.spec_names - pinned_spec_names).each do |indirect_dependency_name|
+          previous_source = requirements[indirect_dependency_name]
+          if previous_source.nil?
+            requirements[indirect_dependency_name] = source
+          else
+            no_ambiguous_sources = Bundler.feature_flag.bundler_3_mode?
+
+            msg = ["The gem '#{indirect_dependency_name}' was found in multiple relevant sources."]
+            msg.concat [previous_source, source].map {|s| "  * #{s}" }.sort
+            msg << "You #{no_ambiguous_sources ? :must : :should} add this gem to the source block for the source you wish it to be installed from."
+            msg = msg.join("\n")
+
+            raise SecurityError, msg if no_ambiguous_sources
+            Bundler.ui.warn "Warning: #{msg}"
+          end
+        end
+
+        source.unmet_deps
+      end
+
+      sources.default_source.add_dependency_names(unmet_deps.flatten - requirements.keys)
+
+      requirements
+    end
+
+    def direct_requirements
+      @direct_requirements ||= begin
+        requirements = {}
+        default = sources.default_source
+        dependencies.each do |dep|
+          dep_source = dep.source || default
+          dep_source.add_dependency_names(dep.name)
+          requirements[dep.name] = dep_source
+        end
+        requirements
+      end
+    end
+
+    def locked_requirements
+      @locked_requirements ||= begin
+        requirements = {}
+        locked_specs.each do |locked_spec|
+          source = locked_spec.source
+          source.add_dependency_names(locked_spec.name)
+          requirements[locked_spec.name] = source
+        end
+        requirements
+      end
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/lib/bundler/spec_set.rb
+++ ruby2.7-2.7.6/lib/bundler/spec_set.rb
@@ -1,54 +1,49 @@
 # frozen_string_literal: true
 
-require "tsort"
-require "set"
+require_relative "vendored_tsort"
 
 module Bundler
   class SpecSet
     include Enumerable
     include TSort
 
-    def initialize(specs)
+    attr_reader :incomplete_specs
+
+    def initialize(specs, incomplete_specs = [])
       @specs = specs
+      @incomplete_specs = incomplete_specs
     end
 
-    def for(dependencies, skip = [], check = false, match_current_platform = false, raise_on_missing = true)
-      handled = Set.new
-      deps = dependencies.dup
+    def for(dependencies, check = false, platforms = [nil])
+      handled = ["bundler"].product(platforms).map {|k| [k, true] }.to_h
+      deps = dependencies.product(platforms)
       specs = []
-      skip += ["bundler"]
 
       loop do
         break unless dep = deps.shift
-        next if !handled.add?(dep) || skip.include?(dep.name)
 
-        if spec = spec_for_dependency(dep, match_current_platform)
-          specs << spec
+        name = dep[0].name
+        platform = dep[1]
+
+        key = [name, platform]
+        next if handled.key?(key)
+
+        handled[key] = true
+
+        specs_for_dep = specs_for_dependency(*dep)
+        if specs_for_dep.any?
+          specs.concat(specs_for_dep)
 
-          spec.dependencies.each do |d|
+          specs_for_dep.first.dependencies.each do |d|
             next if d.type == :development
-            d = DepProxy.new(d, dep.__platform) unless match_current_platform
-            deps << d
+            deps << [d, dep[1]]
           end
         elsif check
-          return false
-        elsif raise_on_missing
-          others = lookup[dep.name] if match_current_platform
-          message = "Unable to find a spec satisfying #{dep} in the set. Perhaps the lockfile is corrupted?"
-          message += " Found #{others.join(", ")} that did not match the current platform." if others && !others.empty?
-          raise GemNotFound, message
+          @incomplete_specs += lookup[name]
         end
       end
 
-      if spec = lookup["bundler"].first
-        specs << spec
-      end
-
-      check ? true : SpecSet.new(specs)
-    end
-
-    def valid_for?(deps)
-      self.for(deps, [], true)
+      specs
     end
 
     def [](key)
@@ -62,6 +57,12 @@ module Bundler
       @sorted = nil
     end
 
+    def delete(spec)
+      @specs.delete(spec)
+      @lookup = nil
+      @sorted = nil
+    end
+
     def sort!
       self
     end
@@ -74,38 +75,35 @@ module Bundler
       lookup.dup
     end
 
-    def materialize(deps, missing_specs = nil)
-      materialized = self.for(deps, [], false, true, !missing_specs).to_a
-      deps = materialized.map(&:name).uniq
-      materialized.map! do |s|
-        next s unless s.is_a?(LazySpecification)
-        s.source.dependency_names = deps if s.source.respond_to?(:dependency_names=)
-        spec = s.__materialize__
-        unless spec
-          unless missing_specs
-            raise GemNotFound, "Could not find #{s.full_name} in any of the sources"
-          end
-          missing_specs << s
-        end
-        spec
-      end
-      SpecSet.new(missing_specs ? materialized.compact : materialized)
+    def materialize(deps)
+      materialized = self.for(deps, true)
+
+      SpecSet.new(materialized, incomplete_specs)
     end
 
     # Materialize for all the specs in the spec set, regardless of what platform they're for
     # This is in contrast to how for does platform filtering (and specifically different from how `materialize` calls `for` only for the current platform)
     # @return [Array<Gem::Specification>]
     def materialized_for_all_platforms
-      names = @specs.map(&:name).uniq
       @specs.map do |s|
         next s unless s.is_a?(LazySpecification)
-        s.source.dependency_names = names if s.source.respond_to?(:dependency_names=)
-        spec = s.__materialize__
+        s.source.remote!
+        spec = s.materialize_for_installation
         raise GemNotFound, "Could not find #{s.full_name} in any of the sources" unless spec
         spec
       end
     end
 
+    def incomplete_ruby_specs?(deps)
+      self.for(deps, true, [Gem::Platform::RUBY])
+
+      @incomplete_specs.any?
+    end
+
+    def missing_specs
+      @specs.select {|s| s.is_a?(LazySpecification) }
+    end
+
     def merge(set)
       arr = sorted.dup
       set.each do |set_spec|
@@ -116,10 +114,20 @@ module Bundler
       SpecSet.new(arr)
     end
 
+    def -(other)
+      SpecSet.new(to_a - other.to_a)
+    end
+
     def find_by_name_and_platform(name, platform)
       @specs.detect {|spec| spec.name == name && spec.match_platform(platform) }
     end
 
+    def delete_by_name_and_version(name, version)
+      @specs.reject! {|spec| spec.name == name && spec.version == version }
+      @lookup = nil
+      @sorted = nil
+    end
+
     def what_required(spec)
       unless req = find {|s| s.dependencies.any? {|d| d.type == :runtime && d.name == spec.name } }
         return [spec]
@@ -147,7 +155,7 @@ module Bundler
       sorted.each(&b)
     end
 
-  private
+    private
 
     def sorted
       rake = @specs.find {|s| s.name == "rake" }
@@ -180,16 +188,13 @@ module Bundler
       @specs.sort_by(&:name).each {|s| yield s }
     end
 
-    def spec_for_dependency(dep, match_current_platform)
-      specs_for_platforms = lookup[dep.name]
-      if match_current_platform
-        Bundler.rubygems.platforms.reverse_each do |pl|
-          match = GemHelpers.select_best_platform_match(specs_for_platforms, pl)
-          return match if match
-        end
-        nil
+    def specs_for_dependency(dep, platform)
+      specs_for_name = lookup[dep.name]
+      if platform.nil?
+        matching_specs = specs_for_name.map {|s| s.materialize_for_installation if Gem::Platform.match_spec?(s) }.compact
+        GemHelpers.sort_best_platform_match(matching_specs, Bundler.local_platform)
       else
-        GemHelpers.select_best_platform_match(specs_for_platforms, dep.__platform)
+        GemHelpers.select_best_platform_match(specs_for_name, dep.force_ruby_platform ? Gem::Platform::RUBY : platform)
       end
     end
 
--- ruby2.7-2.7.6.orig/lib/bundler/stub_specification.rb
+++ ruby2.7-2.7.6/lib/bundler/stub_specification.rb
@@ -1,7 +1,5 @@
 # frozen_string_literal: true
 
-require_relative "remote_specification"
-
 module Bundler
   class StubSpecification < RemoteSpecification
     def self.from_stub(stub)
@@ -28,9 +26,21 @@ module Bundler
 
     # @!group Stub Delegates
 
-    # This is defined directly to avoid having to load every installed spec
+    def manually_installed?
+      # This is for manually installed gems which are gems that were fixed in place after a
+      # failed installation. Once the issue was resolved, the user then manually created
+      # the gem specification using the instructions provided by `gem help install`
+      installed_by_version == Gem::Version.new(0)
+    end
+
+    # This is defined directly to avoid having to loading the full spec
     def missing_extensions?
-      stub.missing_extensions?
+      return false if default_gem?
+      return false if extensions.empty?
+      return false if File.exist? gem_build_complete_path
+      return false if manually_installed?
+
+      true
     end
 
     def activated
@@ -41,14 +51,24 @@ module Bundler
       stub.instance_variable_set(:@activated, activated)
     end
 
-    def default_gem
-      stub.default_gem
+    def extensions
+      stub.extensions
+    end
+
+    def gem_build_complete_path
+      File.join(extension_dir, "gem.build_complete")
+    end
+
+    def default_gem?
+      stub.default_gem?
     end
 
     def full_gem_path
-      # deleted gems can have their stubs return nil, so in that case grab the
-      # expired path from the full spec
-      stub.full_gem_path || method_missing(:full_gem_path)
+      stub.full_gem_path
+    end
+
+    def full_gem_path=(path)
+      stub.full_gem_path = path
     end
 
     def full_require_paths
@@ -71,7 +91,7 @@ module Bundler
       stub.raw_require_paths
     end
 
-  private
+    private
 
     def _remote_specification
       @_remote_specification ||= begin
--- ruby2.7-2.7.6.orig/lib/bundler/templates/Executable
+++ ruby2.7-2.7.6/lib/bundler/templates/Executable
@@ -8,11 +8,9 @@
 # this file is here to facilitate running it.
 #
 
-require "pathname"
-ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../<%= relative_gemfile_path %>",
-  Pathname.new(__FILE__).realpath)
+ENV["BUNDLE_GEMFILE"] ||= File.expand_path("<%= relative_gemfile_path %>", __dir__)
 
-bundle_binstub = File.expand_path("../bundle", __FILE__)
+bundle_binstub = File.expand_path("bundle", __dir__)
 
 if File.file?(bundle_binstub)
   if File.read(bundle_binstub, 300) =~ /This file was generated by Bundler/
--- ruby2.7-2.7.6.orig/lib/bundler/templates/Executable.bundler
+++ ruby2.7-2.7.6/lib/bundler/templates/Executable.bundler
@@ -41,7 +41,7 @@ m = Module.new do
     gemfile = ENV["BUNDLE_GEMFILE"]
     return gemfile if gemfile && !gemfile.empty?
 
-    File.expand_path("../<%= relative_gemfile_path %>", __FILE__)
+    File.expand_path("<%= relative_gemfile_path %>", __dir__)
   end
 
   def lockfile
@@ -60,20 +60,20 @@ m = Module.new do
     Regexp.last_match(1)
   end
 
-  def bundler_version
-    @bundler_version ||=
+  def bundler_requirement
+    @bundler_requirement ||=
       env_var_version || cli_arg_version ||
-        lockfile_version
+        bundler_requirement_for(lockfile_version)
   end
 
-  def bundler_requirement
-    return "#{Gem::Requirement.default}.a" unless bundler_version
+  def bundler_requirement_for(version)
+    return "#{Gem::Requirement.default}.a" unless version
 
-    bundler_gem_version = Gem::Version.new(bundler_version)
+    bundler_gem_version = Gem::Version.new(version)
 
     requirement = bundler_gem_version.approximate_recommendation
 
-    return requirement unless Gem::Version.new(Gem::VERSION) < Gem::Version.new("2.7.0")
+    return requirement unless Gem.rubygems_version < Gem::Version.new("2.7.0")
 
     requirement += ".a" if bundler_gem_version.prerelease?
 
--- ruby2.7-2.7.6.orig/lib/bundler/templates/Executable.standalone
+++ ruby2.7-2.7.6/lib/bundler/templates/Executable.standalone
@@ -6,9 +6,7 @@
 # this file is here to facilitate running it.
 #
 
-require "pathname"
-path = Pathname.new(__FILE__)
-$:.unshift File.expand_path "../<%= standalone_path %>", path.realpath
+$:.unshift File.expand_path "<%= standalone_path %>", __dir__
 
 require "bundler/setup"
-load File.expand_path "../<%= executable_path %>", path.realpath
+load File.expand_path "<%= executable_path %>", __dir__
--- ruby2.7-2.7.6.orig/lib/bundler/templates/Gemfile
+++ ruby2.7-2.7.6/lib/bundler/templates/Gemfile
@@ -2,6 +2,4 @@
 
 source "https://rubygems.org"
 
-git_source(:github) {|repo_name| "https://github.com/#{repo_name}" }
-
 # gem "rails"
--- ruby2.7-2.7.6.orig/lib/bundler/templates/gems.rb
+++ ruby2.7-2.7.6/lib/bundler/templates/gems.rb
@@ -1,8 +1,5 @@
 # frozen_string_literal: true
 
-# A sample gems.rb
 source "https://rubygems.org"
 
-git_source(:github) {|repo_name| "https://github.com/#{repo_name}" }
-
 # gem "rails"
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/CHANGELOG.md.tt
@@ -0,0 +1,5 @@
+## [Unreleased]
+
+## [0.1.0] - <%= Time.now.strftime('%F') %>
+
+- Initial release
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/CODE_OF_CONDUCT.md.tt
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/CODE_OF_CONDUCT.md.tt
@@ -2,73 +2,83 @@
 
 ## Our Pledge
 
-In the interest of fostering an open and welcoming environment, we as
-contributors and maintainers pledge to making participation in our project and
-our community a harassment-free experience for everyone, regardless of age, body
-size, disability, ethnicity, gender identity and expression, level of experience,
-nationality, personal appearance, race, religion, or sexual identity and
-orientation.
+We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.
+
+We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.
 
 ## Our Standards
 
-Examples of behavior that contributes to creating a positive environment
-include:
+Examples of behavior that contributes to a positive environment for our community include:
 
-* Using welcoming and inclusive language
-* Being respectful of differing viewpoints and experiences
-* Gracefully accepting constructive criticism
-* Focusing on what is best for the community
-* Showing empathy towards other community members
-
-Examples of unacceptable behavior by participants include:
-
-* The use of sexualized language or imagery and unwelcome sexual attention or
-advances
-* Trolling, insulting/derogatory comments, and personal or political attacks
+* Demonstrating empathy and kindness toward other people
+* Being respectful of differing opinions, viewpoints, and experiences
+* Giving and gracefully accepting constructive feedback
+* Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience
+* Focusing on what is best not just for us as individuals, but for the overall community
+
+Examples of unacceptable behavior include:
+
+* The use of sexualized language or imagery, and sexual attention or
+  advances of any kind
+* Trolling, insulting or derogatory comments, and personal or political attacks
 * Public or private harassment
-* Publishing others' private information, such as a physical or electronic
-  address, without explicit permission
+* Publishing others' private information, such as a physical or email
+  address, without their explicit permission
 * Other conduct which could reasonably be considered inappropriate in a
   professional setting
 
-## Our Responsibilities
+## Enforcement Responsibilities
+
+Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.
 
-Project maintainers are responsible for clarifying the standards of acceptable
-behavior and are expected to take appropriate and fair corrective action in
-response to any instances of unacceptable behavior.
-
-Project maintainers have the right and responsibility to remove, edit, or
-reject comments, commits, code, wiki edits, issues, and other contributions
-that are not aligned to this Code of Conduct, or to ban temporarily or
-permanently any contributor for other behaviors that they deem inappropriate,
-threatening, offensive, or harmful.
+Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.
 
 ## Scope
 
-This Code of Conduct applies both within project spaces and in public spaces
-when an individual is representing the project or its community. Examples of
-representing a project or community include using an official project e-mail
-address, posting via an official social media account, or acting as an appointed
-representative at an online or offline event. Representation of a project may be
-further defined and clarified by project maintainers.
+This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.
 
 ## Enforcement
 
-Instances of abusive, harassing, or otherwise unacceptable behavior may be
-reported by contacting the project team at <%= config[:email] %>. All
-complaints will be reviewed and investigated and will result in a response that
-is deemed necessary and appropriate to the circumstances. The project team is
-obligated to maintain confidentiality with regard to the reporter of an incident.
-Further details of specific enforcement policies may be posted separately.
-
-Project maintainers who do not follow or enforce the Code of Conduct in good
-faith may face temporary or permanent repercussions as determined by other
-members of the project's leadership.
+Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at <%= config[:email] %>. All complaints will be reviewed and investigated promptly and fairly.
+
+All community leaders are obligated to respect the privacy and security of the reporter of any incident.
+
+## Enforcement Guidelines
+
+Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:
+
+### 1. Correction
+
+**Community Impact**: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.
+
+**Consequence**: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.
+
+### 2. Warning
+
+**Community Impact**: A violation through a single incident or series of actions.
+
+**Consequence**: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.
+
+### 3. Temporary Ban
+
+**Community Impact**: A serious violation of community standards, including sustained inappropriate behavior.
+
+**Consequence**: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.
+
+### 4. Permanent Ban
+
+**Community Impact**: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.
+
+**Consequence**: A permanent ban from any sort of public interaction within the community.
 
 ## Attribution
 
-This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
-available at [https://contributor-covenant.org/version/1/4][version]
+This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0,
+available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.
+
+Community Impact Guidelines were inspired by [Mozilla's code of conduct enforcement ladder](https://github.com/mozilla/diversity).
+
+[homepage]: https://www.contributor-covenant.org
 
-[homepage]: https://contributor-covenant.org
-[version]: https://contributor-covenant.org/version/1/4/
+For answers to common questions about this code of conduct, see the FAQ at
+https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/Gemfile.tt
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/Gemfile.tt
@@ -1,12 +1,23 @@
+# frozen_string_literal: true
+
 source "https://rubygems.org"
 
 # Specify your gem's dependencies in <%= config[:name] %>.gemspec
 gemspec
 
-gem "rake", "~> 12.0"
+gem "rake", "~> 13.0"
 <%- if config[:ext] -%>
+
 gem "rake-compiler"
 <%- end -%>
 <%- if config[:test] -%>
+
 gem "<%= config[:test] %>", "~> <%= config[:test_framework_version] %>"
 <%- end -%>
+<%- if config[:linter] == "rubocop" -%>
+
+gem "rubocop", "~> <%= config[:linter_version] %>"
+<%- elsif config[:linter] == "standard" -%>
+
+gem "standard", "~> <%= config[:linter_version] %>"
+<%- end -%>
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/README.md.tt
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/README.md.tt
@@ -6,17 +6,11 @@ TODO: Delete this and the text above, an
 
 ## Installation
 
-Add this line to your application's Gemfile:
+Install the gem and add to the application's Gemfile by executing:
 
-```ruby
-gem '<%= config[:name] %>'
-```
+    $ bundle add <%= config[:name] %>
 
-And then execute:
-
-    $ bundle install
-
-Or install it yourself as:
+If bundler is not being used to manage dependencies, install the gem by executing:
 
     $ gem install <%= config[:name] %>
 
@@ -28,21 +22,22 @@ TODO: Write usage instructions here
 
 After checking out the repo, run `bin/setup` to install dependencies.<% if config[:test] %> Then, run `rake <%= config[:test].sub('mini', '').sub('rspec', 'spec') %>` to run the tests.<% end %> You can also run `bin/console` for an interactive prompt that will allow you to experiment.<% if config[:bin] %> Run `bundle exec <%= config[:name] %>` to use the gem in this directory, ignoring other installed copies of this gem.<% end %>
 
-To install this gem onto your local machine, run `bundle exec rake install`. To release a new version, update the version number in `version.rb`, and then run `bundle exec rake release`, which will create a git tag for the version, push git commits and tags, and push the `.gem` file to [rubygems.org](https://rubygems.org).
+To install this gem onto your local machine, run `bundle exec rake install`. To release a new version, update the version number in `version.rb`, and then run `bundle exec rake release`, which will create a git tag for the version, push git commits and the created tag, and push the `.gem` file to [rubygems.org](https://rubygems.org).
+<% if config[:git] -%>
 
 ## Contributing
 
-Bug reports and pull requests are welcome on GitHub at https://github.com/<%= config[:github_username] %>/<%= config[:name] %>.<% if config[:coc] %> This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the [code of conduct](https://github.com/<%= config[:github_username] %>/<%= config[:name] %>/blob/master/CODE_OF_CONDUCT.md).<% end %>
-
+Bug reports and pull requests are welcome on GitHub at https://github.com/<%= config[:github_username] %>/<%= config[:name] %>.<% if config[:coc] %> This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the [code of conduct](https://github.com/<%= config[:github_username] %>/<%= config[:name] %>/blob/<%= config[:git_default_branch] %>/CODE_OF_CONDUCT.md).<% end %>
+<% end -%>
 <% if config[:mit] -%>
 
 ## License
 
 The gem is available as open source under the terms of the [MIT License](https://opensource.org/licenses/MIT).
 <% end -%>
-<% if config[:coc] -%>
+<% if config[:git] && config[:coc] -%>
 
 ## Code of Conduct
 
-Everyone interacting in the <%= config[:constant_name] %> project's codebases, issue trackers, chat rooms and mailing lists is expected to follow the [code of conduct](https://github.com/<%= config[:github_username] %>/<%= config[:name] %>/blob/master/CODE_OF_CONDUCT.md).
+Everyone interacting in the <%= config[:constant_name] %> project's codebases, issue trackers, chat rooms and mailing lists is expected to follow the [code of conduct](https://github.com/<%= config[:github_username] %>/<%= config[:name] %>/blob/<%= config[:git_default_branch] %>/CODE_OF_CONDUCT.md).
 <% end -%>
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/Rakefile.tt
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/Rakefile.tt
@@ -1,5 +1,18 @@
+# frozen_string_literal: true
+
 require "bundler/gem_tasks"
-<% if config[:test] == "minitest" -%>
+<% default_task_names = [config[:test_task]].compact -%>
+<% case config[:test] -%>
+<% when "minitest" -%>
+require "rake/testtask"
+
+Rake::TestTask.new(:test) do |t|
+  t.libs << "test"
+  t.libs << "lib"
+  t.test_files = FileList["test/**/test_*.rb"]
+end
+
+<% when "test-unit" -%>
 require "rake/testtask"
 
 Rake::TestTask.new(:test) do |t|
@@ -8,22 +21,36 @@ Rake::TestTask.new(:test) do |t|
   t.test_files = FileList["test/**/*_test.rb"]
 end
 
-<% elsif config[:test] == "rspec" -%>
+<% when "rspec" -%>
 require "rspec/core/rake_task"
 
 RSpec::Core::RakeTask.new(:spec)
 
 <% end -%>
+<% if config[:linter] == "rubocop" -%>
+<% default_task_names << :rubocop -%>
+require "rubocop/rake_task"
+
+RuboCop::RakeTask.new
+
+<% elsif config[:linter] == "standard" -%>
+<% default_task_names << :standard -%>
+require "standard/rake"
+
+<% end -%>
 <% if config[:ext] -%>
+<% default_task_names.unshift(:clobber, :compile) -%>
 require "rake/extensiontask"
 
-task :build => :compile
+task build: :compile
 
 Rake::ExtensionTask.new("<%= config[:underscored_name] %>") do |ext|
   ext.lib_dir = "lib/<%= config[:namespaced_path] %>"
 end
 
-task :default => [:clobber, :compile, :<%= config[:test_task] %>]
+<% end -%>
+<% if default_task_names.size == 1 -%>
+task default: <%= default_task_names.first.inspect %>
 <% else -%>
-task :default => :<%= config[:test_task] %>
+task default: %i[<%= default_task_names.join(" ") %>]
 <% end -%>
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/bin/console.tt
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/bin/console.tt
@@ -1,4 +1,5 @@
 #!/usr/bin/env ruby
+# frozen_string_literal: true
 
 require "bundler/setup"
 require "<%= config[:namespaced_path] %>"
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/circleci/config.yml.tt
@@ -0,0 +1,13 @@
+version: 2.1
+jobs:
+  build:
+    docker:
+      - image: ruby:<%= RUBY_VERSION %>
+    steps:
+      - checkout
+      - run:
+          name: Run the default task
+          command: |
+            gem install bundler -v <%= Bundler::VERSION %>
+            bundle install
+            bundle exec rake
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/ext/newgem/extconf.rb.tt
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/ext/newgem/extconf.rb.tt
@@ -1,3 +1,5 @@
+# frozen_string_literal: true
+
 require "mkmf"
 
 create_makefile(<%= config[:makefile_path].inspect %>)
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/github/workflows/main.yml.tt
@@ -0,0 +1,27 @@
+name: Ruby
+
+on:
+  push:
+    branches:
+      - <%= config[:git_default_branch] %>
+
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ubuntu-latest
+    name: Ruby ${{ matrix.ruby }}
+    strategy:
+      matrix:
+        ruby:
+          - '<%= RUBY_VERSION %>'
+
+    steps:
+    - uses: actions/checkout@v3
+    - name: Set up Ruby
+      uses: ruby/setup-ruby@v1
+      with:
+        ruby-version: ${{ matrix.ruby }}
+        bundler-cache: true
+    - name: Run the default task
+      run: bundle exec rake
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/gitlab-ci.yml.tt
@@ -0,0 +1,9 @@
+image: ruby:<%= RUBY_VERSION %>
+
+before_script:
+  - gem install bundler -v <%= Bundler::VERSION %>
+  - bundle install
+
+example_job:
+  script:
+    - bundle exec rake
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/lib/newgem.rb.tt
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/lib/newgem.rb.tt
@@ -1,6 +1,8 @@
-require "<%= config[:namespaced_path] %>/version"
+# frozen_string_literal: true
+
+require_relative "<%= File.basename(config[:namespaced_path]) %>/version"
 <%- if config[:ext] -%>
-require "<%= config[:namespaced_path] %>/<%= config[:underscored_name] %>"
+require_relative "<%= File.basename(config[:namespaced_path]) %>/<%= config[:underscored_name] %>"
 <%- end -%>
 
 <%- config[:constant_array].each_with_index do |c, i| -%>
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/lib/newgem/version.rb.tt
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/lib/newgem/version.rb.tt
@@ -1,3 +1,5 @@
+# frozen_string_literal: true
+
 <%- config[:constant_array].each_with_index do |c, i| -%>
 <%= "  " * i %>module <%= c %>
 <%- end -%>
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/newgem.gemspec.tt
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/newgem.gemspec.tt
@@ -1,20 +1,22 @@
-require_relative 'lib/<%=config[:namespaced_path]%>/version'
+# frozen_string_literal: true
+
+require_relative "lib/<%=config[:namespaced_path]%>/version"
 
 Gem::Specification.new do |spec|
-  spec.name          = <%= config[:name].inspect %>
-  spec.version       = <%= config[:constant_name] %>::VERSION
-  spec.authors       = [<%= config[:author].inspect %>]
-  spec.email         = [<%= config[:email].inspect %>]
-
-  spec.summary       = %q{TODO: Write a short summary, because RubyGems requires one.}
-  spec.description   = %q{TODO: Write a longer description or delete this line.}
-  spec.homepage      = "TODO: Put your gem's website or public repo URL here."
+  spec.name = <%= config[:name].inspect %>
+  spec.version = <%= config[:constant_name] %>::VERSION
+  spec.authors = [<%= config[:author].inspect %>]
+  spec.email = [<%= config[:email].inspect %>]
+
+  spec.summary = "TODO: Write a short summary, because RubyGems requires one."
+  spec.description = "TODO: Write a longer description or delete this line."
+  spec.homepage = "TODO: Put your gem's website or public repo URL here."
 <%- if config[:mit] -%>
-  spec.license       = "MIT"
+  spec.license = "MIT"
 <%- end -%>
-  spec.required_ruby_version = Gem::Requirement.new(">= 2.3.0")
+  spec.required_ruby_version = ">= <%= config[:required_ruby_version] %>"
 
-  spec.metadata["allowed_push_host"] = "TODO: Set to 'http://mygemserver.com'"
+  spec.metadata["allowed_push_host"] = "TODO: Set to your gem server 'https://example.com'"
 
   spec.metadata["homepage_uri"] = spec.homepage
   spec.metadata["source_code_uri"] = "TODO: Put your gem's public repo URL here."
@@ -22,13 +24,21 @@ Gem::Specification.new do |spec|
 
   # Specify which files should be added to the gem when it is released.
   # The `git ls-files -z` loads the files in the RubyGem that have been added into git.
-  spec.files         = Dir.chdir(File.expand_path('..', __FILE__)) do
-    `git ls-files -z`.split("\x0").reject { |f| f.match(%r{^(test|spec|features)/}) }
+  spec.files = Dir.chdir(__dir__) do
+    `git ls-files -z`.split("\x0").reject do |f|
+      (f == __FILE__) || f.match(%r{\A(?:(?:bin|test|spec|features)/|\.(?:git|travis|circleci)|appveyor)})
+    end
   end
-  spec.bindir        = "exe"
-  spec.executables   = spec.files.grep(%r{^exe/}) { |f| File.basename(f) }
+  spec.bindir = "exe"
+  spec.executables = spec.files.grep(%r{\Aexe/}) { |f| File.basename(f) }
   spec.require_paths = ["lib"]
 <%- if config[:ext] -%>
-  spec.extensions    = ["ext/<%= config[:underscored_name] %>/extconf.rb"]
+  spec.extensions = ["ext/<%= config[:underscored_name] %>/extconf.rb"]
 <%- end -%>
+
+  # Uncomment to register a new dependency of your gem
+  # spec.add_dependency "example-gem", "~> 1.0"
+
+  # For more information and examples about making a new gem, check out our
+  # guide at: https://bundler.io/guides/creating_gem.html
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/rubocop.yml.tt
@@ -0,0 +1,13 @@
+AllCops:
+  TargetRubyVersion: <%= ::Gem::Version.new(config[:required_ruby_version]).segments[0..1].join(".") %>
+
+Style/StringLiterals:
+  Enabled: true
+  EnforcedStyle: double_quotes
+
+Style/StringLiteralsInInterpolation:
+  Enabled: true
+  EnforcedStyle: double_quotes
+
+Layout/LineLength:
+  Max: 120
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/sig/newgem.rbs.tt
@@ -0,0 +1,8 @@
+<%- config[:constant_array].each_with_index do |c, i| -%>
+<%= "  " * i %>module <%= c %>
+<%- end -%>
+<%= "  " * config[:constant_array].size %>VERSION: String
+<%= "  " * config[:constant_array].size %># See the writing guide of rbs: https://github.com/ruby/rbs#guides
+<%- (config[:constant_array].size-1).downto(0) do |i| -%>
+<%= "  " * i %>end
+<%- end -%>
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/spec/newgem_spec.rb.tt
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/spec/newgem_spec.rb.tt
@@ -1,3 +1,5 @@
+# frozen_string_literal: true
+
 RSpec.describe <%= config[:constant_name] %> do
   it "has a version number" do
     expect(<%= config[:constant_name] %>::VERSION).not_to be nil
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/spec/spec_helper.rb.tt
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/spec/spec_helper.rb.tt
@@ -1,4 +1,5 @@
-require "bundler/setup"
+# frozen_string_literal: true
+
 require "<%= config[:namespaced_path] %>"
 
 RSpec.configure do |config|
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/standard.yml.tt
@@ -0,0 +1,3 @@
+# For available configuration options, see:
+#   https://github.com/testdouble/standard
+ruby_version: <%= ::Gem::Version.new(config[:required_ruby_version]).segments[0..1].join(".") %>
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/test/minitest/test_helper.rb.tt
@@ -0,0 +1,6 @@
+# frozen_string_literal: true
+
+$LOAD_PATH.unshift File.expand_path("../lib", __dir__)
+require "<%= config[:namespaced_path] %>"
+
+require "minitest/autorun"
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/test/minitest/test_newgem.rb.tt
@@ -0,0 +1,13 @@
+# frozen_string_literal: true
+
+require "test_helper"
+
+class <%= config[:minitest_constant_name] %> < Minitest::Test
+  def test_that_it_has_a_version_number
+    refute_nil ::<%= config[:constant_name] %>::VERSION
+  end
+
+  def test_it_does_something_useful
+    assert false
+  end
+end
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/test/newgem_test.rb.tt
+++ /dev/null
@@ -1,11 +0,0 @@
-require "test_helper"
-
-class <%= config[:constant_name] %>Test < Minitest::Test
-  def test_that_it_has_a_version_number
-    refute_nil ::<%= config[:constant_name] %>::VERSION
-  end
-
-  def test_it_does_something_useful
-    assert false
-  end
-end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/test/test-unit/newgem_test.rb.tt
@@ -0,0 +1,15 @@
+# frozen_string_literal: true
+
+require "test_helper"
+
+class <%= config[:constant_name] %>Test < Test::Unit::TestCase
+  test "VERSION" do
+    assert do
+      ::<%= config[:constant_name] %>.const_defined?(:VERSION)
+    end
+  end
+
+  test "something useful" do
+    assert_equal("expected", "actual")
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/templates/newgem/test/test-unit/test_helper.rb.tt
@@ -0,0 +1,6 @@
+# frozen_string_literal: true
+
+$LOAD_PATH.unshift File.expand_path("../lib", __dir__)
+require "<%= config[:namespaced_path] %>"
+
+require "test-unit"
--- ruby2.7-2.7.6.orig/lib/bundler/templates/newgem/test/test_helper.rb.tt
+++ /dev/null
@@ -1,4 +0,0 @@
-$LOAD_PATH.unshift File.expand_path("../lib", __dir__)
-require "<%= config[:namespaced_path] %>"
-
-require "minitest/autorun"
--- ruby2.7-2.7.6.orig/lib/bundler/ui/shell.rb
+++ ruby2.7-2.7.6/lib/bundler/ui/shell.rb
@@ -28,17 +28,17 @@ module Bundler
         tell_me(msg, :green, newline) if level("confirm")
       end
 
-      def warn(msg, newline = nil)
+      def warn(msg, newline = nil, color = :yellow)
         return unless level("warn")
         return if @warning_history.include? msg
         @warning_history << msg
 
-        tell_err(msg, :yellow, newline)
+        tell_err(msg, color, newline)
       end
 
-      def error(msg, newline = nil)
+      def error(msg, newline = nil, color = :red)
         return unless level("error")
-        tell_err(msg, :red, newline)
+        tell_err(msg, color, newline)
       end
 
       def debug(msg, newline = nil)
@@ -81,7 +81,7 @@ module Bundler
       def trace(e, newline = nil, force = false)
         return unless debug? || force
         msg = "#{e.class}: #{e.message}\n#{e.backtrace.join("\n  ")}"
-        tell_me(msg, nil, newline)
+        tell_err(msg, nil, newline)
       end
 
       def silence(&blk)
@@ -92,7 +92,7 @@ module Bundler
         []
       end
 
-    private
+      private
 
       # valimism
       def tell_me(msg, color = nil, newline = nil)
--- ruby2.7-2.7.6.orig/lib/bundler/uri_credentials_filter.rb
+++ ruby2.7-2.7.6/lib/bundler/uri_credentials_filter.rb
@@ -2,12 +2,14 @@
 
 module Bundler
   module URICredentialsFilter
-  module_function
+    module_function
 
     def credential_filtered_uri(uri_to_anonymize)
       return uri_to_anonymize if uri_to_anonymize.nil?
       uri = uri_to_anonymize.dup
       if uri.is_a?(String)
+        return uri if File.exist?(uri)
+
         require_relative "vendored_uri"
         uri = Bundler::URI(uri)
       end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/.document
@@ -0,0 +1 @@
+# Vendored files do not need to be documented
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/connection_pool/LICENSE
@@ -0,0 +1,20 @@
+Copyright (c) 2011 Mike Perham
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/connection_pool/lib/connection_pool.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/connection_pool/lib/connection_pool.rb
@@ -1,14 +1,18 @@
-require_relative 'connection_pool/version'
-require_relative 'connection_pool/timed_stack'
+require "timeout"
+require_relative "connection_pool/version"
 
+class Bundler::ConnectionPool
+  class Error < ::RuntimeError; end
+  class PoolShuttingDownError < ::Bundler::ConnectionPool::Error; end
+  class TimeoutError < ::Timeout::Error; end
+end
 
-# Generic connection pool class for e.g. sharing a limited number of network connections
-# among many threads.  Note: Connections are lazily created.
+# Generic connection pool class for sharing a limited number of objects or network connections
+# among many threads.  Note: pool elements are lazily created.
 #
 # Example usage with block (faster):
 #
 #    @pool = Bundler::ConnectionPool.new { Redis.new }
-#
 #    @pool.with do |redis|
 #      redis.lpop('my-list') if redis.llen('my-list') > 0
 #    end
@@ -34,29 +38,23 @@ require_relative 'connection_pool/timed_
 class Bundler::ConnectionPool
   DEFAULTS = {size: 5, timeout: 5}
 
-  class Error < RuntimeError
-  end
-
   def self.wrap(options, &block)
     Wrapper.new(options, &block)
   end
 
   def initialize(options = {}, &block)
-    raise ArgumentError, 'Connection pool requires a block' unless block
+    raise ArgumentError, "Connection pool requires a block" unless block
 
     options = DEFAULTS.merge(options)
 
-    @size = options.fetch(:size)
+    @size = Integer(options.fetch(:size))
     @timeout = options.fetch(:timeout)
 
     @available = TimedStack.new(@size, &block)
-    @key = :"current-#{@available.object_id}"
-    @key_count = :"current-#{@available.object_id}-count"
+    @key = :"pool-#{@available.object_id}"
+    @key_count = :"pool-#{@available.object_id}-count"
   end
 
-if Thread.respond_to?(:handle_interrupt)
-
-  # MRI
   def with(options = {})
     Thread.handle_interrupt(Exception => :never) do
       conn = checkout(options)
@@ -69,28 +67,15 @@ if Thread.respond_to?(:handle_interrupt)
       end
     end
   end
-
-else
-
-  # jruby 1.7.x
-  def with(options = {})
-    conn = checkout(options)
-    begin
-      yield conn
-    ensure
-      checkin
-    end
-  end
-
-end
+  alias then with
 
   def checkout(options = {})
     if ::Thread.current[@key]
-      ::Thread.current[@key_count]+= 1
+      ::Thread.current[@key_count] += 1
       ::Thread.current[@key]
     else
-      ::Thread.current[@key_count]= 1
-      ::Thread.current[@key]= @available.pop(options[:timeout] || @timeout)
+      ::Thread.current[@key_count] = 1
+      ::Thread.current[@key] = @available.pop(options[:timeout] || @timeout)
     end
   end
 
@@ -98,64 +83,44 @@ end
     if ::Thread.current[@key]
       if ::Thread.current[@key_count] == 1
         @available.push(::Thread.current[@key])
-        ::Thread.current[@key]= nil
+        ::Thread.current[@key] = nil
+        ::Thread.current[@key_count] = nil
       else
-        ::Thread.current[@key_count]-= 1
+        ::Thread.current[@key_count] -= 1
       end
     else
-      raise Bundler::ConnectionPool::Error, 'no connections are checked out'
+      raise Bundler::ConnectionPool::Error, "no connections are checked out"
     end
 
     nil
   end
 
+  ##
+  # Shuts down the Bundler::ConnectionPool by passing each connection to +block+ and
+  # then removing it from the pool. Attempting to checkout a connection after
+  # shutdown will raise +Bundler::ConnectionPool::PoolShuttingDownError+.
+
   def shutdown(&block)
     @available.shutdown(&block)
   end
 
-  # Size of this connection pool
-  def size
-    @size
+  ##
+  # Reloads the Bundler::ConnectionPool by passing each connection to +block+ and then
+  # removing it the pool. Subsequent checkouts will create new connections as
+  # needed.
+
+  def reload(&block)
+    @available.shutdown(reload: true, &block)
   end
 
+  # Size of this connection pool
+  attr_reader :size
+
   # Number of pool entries available for checkout at this instant.
   def available
     @available.length
   end
-
-  private
-
-  class Wrapper < ::BasicObject
-    METHODS = [:with, :pool_shutdown]
-
-    def initialize(options = {}, &block)
-      @pool = options.fetch(:pool) { ::Bundler::ConnectionPool.new(options, &block) }
-    end
-
-    def with(&block)
-      @pool.with(&block)
-    end
-
-    def pool_shutdown(&block)
-      @pool.shutdown(&block)
-    end
-
-    def pool_size
-      @pool.size
-    end
-
-    def pool_available
-      @pool.available
-    end
-
-    def respond_to?(id, *args)
-      METHODS.include?(id) || with { |c| c.respond_to?(id, *args) }
-    end
-
-    def method_missing(name, *args, &block)
-      with do |connection|
-        connection.send(name, *args, &block)
-      end
-    end
-  end
 end
+
+require_relative "connection_pool/timed_stack"
+require_relative "connection_pool/wrapper"
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/connection_pool/lib/connection_pool/monotonic_time.rb
+++ /dev/null
@@ -1,66 +0,0 @@
-# Global monotonic clock from Concurrent Ruby 1.0.
-# Copyright (c) Jerry D'Antonio -- released under the MIT license.
-# Slightly modified; used with permission.
-# https://github.com/ruby-concurrency/concurrent-ruby
-
-require 'thread'
-
-class Bundler::ConnectionPool
-
-  class_definition = Class.new do
-
-    if defined?(Process::CLOCK_MONOTONIC)
-
-      # @!visibility private
-      def get_time
-        Process.clock_gettime(Process::CLOCK_MONOTONIC)
-      end
-
-    elsif defined?(RUBY_ENGINE) && RUBY_ENGINE == 'jruby'
-
-      # @!visibility private
-      def get_time
-        java.lang.System.nanoTime() / 1_000_000_000.0
-      end
-
-    else
-
-      # @!visibility private
-      def initialize
-        @mutex = Mutex.new
-        @last_time = Time.now.to_f
-      end
-
-      # @!visibility private
-      def get_time
-        @mutex.synchronize do
-          now = Time.now.to_f
-          if @last_time < now
-            @last_time = now
-          else # clock has moved back in time
-            @last_time += 0.000_001
-          end
-        end
-      end
-    end
-  end
-
-  ##
-  # Clock that cannot be set and represents monotonic time since
-  # some unspecified starting point.
-  #
-  # @!visibility private
-  GLOBAL_MONOTONIC_CLOCK = class_definition.new
-  private_constant :GLOBAL_MONOTONIC_CLOCK
-
-  class << self
-    ##
-    # Returns the current time a tracked by the application monotonic clock.
-    #
-    # @return [Float] The current monotonic time when `since` not given else
-    #   the elapsed monotonic time between `since` and the current time
-    def monotonic_time
-      GLOBAL_MONOTONIC_CLOCK.get_time
-    end
-  end
-end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/connection_pool/lib/connection_pool/timed_stack.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/connection_pool/lib/connection_pool/timed_stack.rb
@@ -1,13 +1,3 @@
-require 'thread'
-require 'timeout'
-require_relative 'monotonic_time'
-
-##
-# Raised when you attempt to retrieve a connection from a pool that has been
-# shut down.
-
-class Bundler::ConnectionPool::PoolShuttingDownError < RuntimeError; end
-
 ##
 # The TimedStack manages a pool of homogeneous connections (or any resource
 # you wish to manage).  Connections are created lazily up to a given maximum
@@ -25,7 +15,7 @@ class Bundler::ConnectionPool::PoolShutt
 #
 #    conn = ts.pop
 #    ts.pop timeout: 5
-#    #=> raises Timeout::Error after 5 seconds
+#    #=> raises Bundler::ConnectionPool::TimeoutError after 5 seconds
 
 class Bundler::ConnectionPool::TimedStack
   attr_reader :max
@@ -39,8 +29,8 @@ class Bundler::ConnectionPool::TimedStac
     @created = 0
     @que = []
     @max = size
-    @mutex = Mutex.new
-    @resource = ConditionVariable.new
+    @mutex = Thread::Mutex.new
+    @resource = Thread::ConditionVariable.new
     @shutdown_block = nil
   end
 
@@ -59,12 +49,12 @@ class Bundler::ConnectionPool::TimedStac
       @resource.broadcast
     end
   end
-  alias_method :<<, :push
+  alias << push
 
   ##
   # Retrieves a connection from the stack.  If a connection is available it is
   # immediately returned.  If no connection is available within the given
-  # timeout a Timeout::Error is raised.
+  # timeout a Bundler::ConnectionPool::TimeoutError is raised.
   #
   # +:timeout+ is the only checked entry in +options+ and is preferred over
   # the +timeout+ argument (which will be removed in a future release).  Other
@@ -74,7 +64,7 @@ class Bundler::ConnectionPool::TimedStac
     options, timeout = timeout, 0.5 if Hash === timeout
     timeout = options.fetch :timeout, timeout
 
-    deadline = Bundler::ConnectionPool.monotonic_time + timeout
+    deadline = current_time + timeout
     @mutex.synchronize do
       loop do
         raise Bundler::ConnectionPool::PoolShuttingDownError if @shutdown_block
@@ -83,18 +73,20 @@ class Bundler::ConnectionPool::TimedStac
         connection = try_create(options)
         return connection if connection
 
-        to_wait = deadline - Bundler::ConnectionPool.monotonic_time
-        raise Timeout::Error, "Waited #{timeout} sec" if to_wait <= 0
+        to_wait = deadline - current_time
+        raise Bundler::ConnectionPool::TimeoutError, "Waited #{timeout} sec" if to_wait <= 0
         @resource.wait(@mutex, to_wait)
       end
     end
   end
 
   ##
-  # Shuts down the TimedStack which prevents connections from being checked
-  # out.  The +block+ is called once for each connection on the stack.
+  # Shuts down the TimedStack by passing each connection to +block+ and then
+  # removing it from the pool. Attempting to checkout a connection after
+  # shutdown will raise +Bundler::ConnectionPool::PoolShuttingDownError+ unless
+  # +:reload+ is +true+.
 
-  def shutdown(&block)
+  def shutdown(reload: false, &block)
     raise ArgumentError, "shutdown must receive a block" unless block_given?
 
     @mutex.synchronize do
@@ -102,6 +94,7 @@ class Bundler::ConnectionPool::TimedStac
       @resource.broadcast
 
       shutdown_connections
+      @shutdown_block = nil if reload
     end
   end
 
@@ -121,6 +114,10 @@ class Bundler::ConnectionPool::TimedStac
 
   private
 
+  def current_time
+    Process.clock_gettime(Process::CLOCK_MONOTONIC)
+  end
+
   ##
   # This is an extension point for TimedStack and is called with a mutex.
   #
@@ -149,6 +146,7 @@ class Bundler::ConnectionPool::TimedStac
       conn = fetch_connection(options)
       @shutdown_block.call(conn)
     end
+    @created = 0
   end
 
   ##
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/connection_pool/lib/connection_pool/version.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/connection_pool/lib/connection_pool/version.rb
@@ -1,3 +1,3 @@
 class Bundler::ConnectionPool
-  VERSION = "2.2.2"
+  VERSION = "2.3.0"
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/connection_pool/lib/connection_pool/wrapper.rb
@@ -0,0 +1,57 @@
+class Bundler::ConnectionPool
+  class Wrapper < ::BasicObject
+    METHODS = [:with, :pool_shutdown, :wrapped_pool]
+
+    def initialize(options = {}, &block)
+      @pool = options.fetch(:pool) { ::Bundler::ConnectionPool.new(options, &block) }
+    end
+
+    def wrapped_pool
+      @pool
+    end
+
+    def with(&block)
+      @pool.with(&block)
+    end
+
+    def pool_shutdown(&block)
+      @pool.shutdown(&block)
+    end
+
+    def pool_size
+      @pool.size
+    end
+
+    def pool_available
+      @pool.available
+    end
+
+    def respond_to?(id, *args)
+      METHODS.include?(id) || with { |c| c.respond_to?(id, *args) }
+    end
+
+    # rubocop:disable Style/MethodMissingSuper
+    # rubocop:disable Style/MissingRespondToMissing
+    if ::RUBY_VERSION >= "3.0.0"
+      def method_missing(name, *args, **kwargs, &block)
+        with do |connection|
+          connection.send(name, *args, **kwargs, &block)
+        end
+      end
+    elsif ::RUBY_VERSION >= "2.7.0"
+      ruby2_keywords def method_missing(name, *args, &block)
+        with do |connection|
+          connection.send(name, *args, &block)
+        end
+      end
+    else
+      def method_missing(name, *args, &block)
+        with do |connection|
+          connection.send(name, *args, &block)
+        end
+      end
+    end
+    # rubocop:enable Style/MethodMissingSuper
+    # rubocop:enable Style/MissingRespondToMissing
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/fileutils/LICENSE.txt
@@ -0,0 +1,22 @@
+Copyright (C) 1993-2013 Yukihiro Matsumoto. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/fileutils/lib/fileutils/version.rb
+++ /dev/null
@@ -1,5 +0,0 @@
-# frozen_string_literal: true
-
-module Bundler::FileUtils
-  VERSION = "1.3.0"
-end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/molinillo/LICENSE
@@ -0,0 +1,9 @@
+This project is licensed under the MIT license.
+
+Copyright (c) 2014 Samuel E. Giddins segiddins@segiddins.me
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/molinillo/lib/molinillo.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/molinillo/lib/molinillo.rb
@@ -1,6 +1,5 @@
 # frozen_string_literal: true
 
-require_relative 'molinillo/compatibility'
 require_relative 'molinillo/gem_metadata'
 require_relative 'molinillo/errors'
 require_relative 'molinillo/resolver'
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/molinillo/lib/molinillo/compatibility.rb
+++ /dev/null
@@ -1,26 +0,0 @@
-# frozen_string_literal: true
-
-module Bundler::Molinillo
-  # Hacks needed for old Ruby versions.
-  module Compatibility
-    module_function
-
-    if [].respond_to?(:flat_map)
-      # Flat map
-      # @param [Enumerable] enum an enumerable object
-      # @block the block to flat-map with
-      # @return The enum, flat-mapped
-      def flat_map(enum, &blk)
-        enum.flat_map(&blk)
-      end
-    else
-      # Flat map
-      # @param [Enumerable] enum an enumerable object
-      # @block the block to flat-map with
-      # @return The enum, flat-mapped
-      def flat_map(enum, &blk)
-        enum.map(&blk).flatten(1)
-      end
-    end
-  end
-end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/molinillo/lib/molinillo/delegates/specification_provider.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/molinillo/lib/molinillo/delegates/specification_provider.rb
@@ -26,6 +26,13 @@ module Bundler::Molinillo
         end
       end
 
+      # (see Bundler::Molinillo::SpecificationProvider#dependencies_equal?)
+      def dependencies_equal?(dependencies, other_dependencies)
+        with_no_such_dependency_error_handling do
+          specification_provider.dependencies_equal?(dependencies, other_dependencies)
+        end
+      end
+
       # (see Bundler::Molinillo::SpecificationProvider#name_for)
       def name_for(dependency)
         with_no_such_dependency_error_handling do
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/molinillo/lib/molinillo/dependency_graph.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/molinillo/lib/molinillo/dependency_graph.rb
@@ -1,7 +1,6 @@
 # frozen_string_literal: true
 
-require 'set'
-require 'tsort'
+require_relative '../../../../vendored_tsort'
 
 require_relative 'dependency_graph/log'
 require_relative 'dependency_graph/vertex'
@@ -18,7 +17,7 @@ module Bundler::Molinillo
       vertices.values.each { |v| yield v }
     end
 
-    include TSort
+    include Bundler::TSort
 
     # @!visibility private
     alias tsort_each_node each
@@ -33,7 +32,7 @@ module Bundler::Molinillo
     #   all belong to the same graph.
     # @return [Array<Vertex>] The sorted vertices.
     def self.tsort(vertices)
-      TSort.tsort(
+      Bundler::TSort.tsort(
         lambda { |b| vertices.each(&b) },
         lambda { |v, &b| (v.successors & vertices).each(&b) }
       )
@@ -124,6 +123,7 @@ module Bundler::Molinillo
       dot.join("\n")
     end
 
+    # @param [DependencyGraph] other
     # @return [Boolean] whether the two dependency graphs are equal, determined
     #   by a recursive traversal of each {#root_vertices} and its
     #   {Vertex#successors}
@@ -190,7 +190,7 @@ module Bundler::Molinillo
     # @return [Edge] the added edge
     def add_edge(origin, destination, requirement)
       if destination.path_to?(origin)
-        raise CircularDependencyError.new([origin, destination])
+        raise CircularDependencyError.new(path(destination, origin))
       end
       add_edge_no_circular(origin, destination, requirement)
     end
@@ -219,5 +219,37 @@ module Bundler::Molinillo
     def add_edge_no_circular(origin, destination, requirement)
       log.add_edge_no_circular(self, origin.name, destination.name, requirement)
     end
+
+    # Returns the path between two vertices
+    # @raise [ArgumentError] if there is no path between the vertices
+    # @param [Vertex] from
+    # @param [Vertex] to
+    # @return [Array<Vertex>] the shortest path from `from` to `to`
+    def path(from, to)
+      distances = Hash.new(vertices.size + 1)
+      distances[from.name] = 0
+      predecessors = {}
+      each do |vertex|
+        vertex.successors.each do |successor|
+          if distances[successor.name] > distances[vertex.name] + 1
+            distances[successor.name] = distances[vertex.name] + 1
+            predecessors[successor] = vertex
+          end
+        end
+      end
+
+      path = [to]
+      while before = predecessors[to]
+        path << before
+        to = before
+        break if to == from
+      end
+
+      unless path.last.equal?(from)
+        raise ArgumentError, "There is no path from #{from.name} to #{to.name}"
+      end
+
+      path.reverse
+    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/molinillo/lib/molinillo/dependency_graph/tag.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/molinillo/lib/molinillo/dependency_graph/tag.rb
@@ -14,11 +14,11 @@ module Bundler::Molinillo
       end
 
       # (see Action#up)
-      def up(_graph)
+      def up(graph)
       end
 
       # (see Action#down)
-      def down(_graph)
+      def down(graph)
       end
 
       # @!group Tag
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/molinillo/lib/molinillo/dependency_graph/vertex.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/molinillo/lib/molinillo/dependency_graph/vertex.rb
@@ -59,7 +59,7 @@ module Bundler::Molinillo
       # @param [Set<Vertex>] vertices the set to add the predecessors to
       # @return [Set<Vertex>] the vertices of {#graph} where `self` is a
       #   {#descendent?}
-      def _recursive_predecessors(vertices = Set.new)
+      def _recursive_predecessors(vertices = new_vertex_set)
         incoming_edges.each do |edge|
           vertex = edge.origin
           next unless vertices.add?(vertex)
@@ -85,7 +85,7 @@ module Bundler::Molinillo
       # @param [Set<Vertex>] vertices the set to add the successors to
       # @return [Set<Vertex>] the vertices of {#graph} where `self` is an
       #   {#ancestor?}
-      def _recursive_successors(vertices = Set.new)
+      def _recursive_successors(vertices = new_vertex_set)
         outgoing_edges.each do |edge|
           vertex = edge.destination
           next unless vertices.add?(vertex)
@@ -128,7 +128,7 @@ module Bundler::Molinillo
 
       # Is there a path from `self` to `other` following edges in the
       # dependency graph?
-      # @return true iff there is a path following edges within this {#graph}
+      # @return whether there is a path following edges within this {#graph}
       def path_to?(other)
         _path_to?(other)
       end
@@ -138,7 +138,7 @@ module Bundler::Molinillo
       # @param [Vertex] other the vertex to check if there's a path to
       # @param [Set<Vertex>] visited the vertices of {#graph} that have been visited
       # @return [Boolean] whether there is a path to `other` from `self`
-      def _path_to?(other, visited = Set.new)
+      def _path_to?(other, visited = new_vertex_set)
         return false unless visited.add?(self)
         return true if equal?(other)
         successors.any? { |v| v._path_to?(other, visited) }
@@ -147,12 +147,18 @@ module Bundler::Molinillo
 
       # Is there a path from `other` to `self` following edges in the
       # dependency graph?
-      # @return true iff there is a path following edges within this {#graph}
+      # @return whether there is a path following edges within this {#graph}
       def ancestor?(other)
         other.path_to?(self)
       end
 
       alias is_reachable_from? ancestor?
+
+      def new_vertex_set
+        require 'set'
+        Set.new
+      end
+      private :new_vertex_set
     end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/molinillo/lib/molinillo/errors.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/molinillo/lib/molinillo/errors.rb
@@ -34,7 +34,7 @@ module Bundler::Molinillo
 
   # An error caused by attempting to fulfil a dependency that was circular
   #
-  # @note This exception will be thrown iff a {Vertex} is added to a
+  # @note This exception will be thrown if and only if a {Vertex} is added to a
   #   {DependencyGraph} that has a {DependencyGraph::Vertex#path_to?} an
   #   existing {DependencyGraph::Vertex}
   class CircularDependencyError < ResolverError
@@ -65,7 +65,7 @@ module Bundler::Molinillo
     # @param [SpecificationProvider] specification_provider see {#specification_provider}
     def initialize(conflicts, specification_provider)
       pairs = []
-      Compatibility.flat_map(conflicts.values.flatten, &:requirements).each do |conflicting|
+      conflicts.values.flat_map(&:requirements).each do |conflicting|
         conflicting.each do |source, conflict_requirements|
           conflict_requirements.each do |c|
             pairs << [c, source]
@@ -107,36 +107,42 @@ module Bundler::Molinillo
         end
       end
 
-      conflicts.sort.reduce(''.dup) do |o, (name, conflict)|
-        o << "\n" << incompatible_version_message_for_conflict.call(name, conflict) << "\n"
-        if conflict.locked_requirement
-          o << %(  In snapshot (#{name_for_locking_dependency_source}):\n)
-          o << %(    #{printable_requirement.call(conflict.locked_requirement)}\n)
-          o << %(\n)
-        end
-        o << %(  In #{name_for_explicit_dependency_source}:\n)
-        trees = reduce_trees.call(conflict.requirement_trees)
+      full_message_for_conflict = opts.delete(:full_message_for_conflict) do
+        proc do |name, conflict|
+          o = "\n".dup << incompatible_version_message_for_conflict.call(name, conflict) << "\n"
+          if conflict.locked_requirement
+            o << %(  In snapshot (#{name_for_locking_dependency_source}):\n)
+            o << %(    #{printable_requirement.call(conflict.locked_requirement)}\n)
+            o << %(\n)
+          end
+          o << %(  In #{name_for_explicit_dependency_source}:\n)
+          trees = reduce_trees.call(conflict.requirement_trees)
 
-        o << trees.map do |tree|
-          t = ''.dup
-          depth = 2
-          tree.each do |req|
-            t << '  ' * depth << req.to_s
-            unless tree.last == req
-              if spec = conflict.activated_by_name[name_for(req)]
-                t << %( was resolved to #{version_for_spec.call(spec)}, which)
+          o << trees.map do |tree|
+            t = ''.dup
+            depth = 2
+            tree.each do |req|
+              t << '  ' * depth << printable_requirement.call(req)
+              unless tree.last == req
+                if spec = conflict.activated_by_name[name_for(req)]
+                  t << %( was resolved to #{version_for_spec.call(spec)}, which)
+                end
+                t << %( depends on)
               end
-              t << %( depends on)
+              t << %(\n)
+              depth += 1
             end
-            t << %(\n)
-            depth += 1
-          end
-          t
-        end.join("\n")
+            t
+          end.join("\n")
 
-        additional_message_for_conflict.call(o, name, conflict)
+          additional_message_for_conflict.call(o, name, conflict)
 
-        o
+          o
+        end
+      end
+
+      conflicts.sort.reduce(''.dup) do |o, (name, conflict)|
+        o << full_message_for_conflict.call(name, conflict)
       end.strip
     end
   end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/molinillo/lib/molinillo/gem_metadata.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/molinillo/lib/molinillo/gem_metadata.rb
@@ -2,5 +2,5 @@
 
 module Bundler::Molinillo
   # The version of Bundler::Molinillo.
-  VERSION = '0.6.6'.freeze
+  VERSION = '0.8.0'.freeze
 end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/molinillo/lib/molinillo/modules/specification_provider.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/molinillo/lib/molinillo/modules/specification_provider.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
 
 module Bundler::Molinillo
-  # Provides information about specifcations and dependencies to the resolver,
+  # Provides information about specifications and dependencies to the resolver,
   # allowing the {Resolver} class to remain generic while still providing power
   # and flexibility.
   #
@@ -45,6 +45,17 @@ module Bundler::Molinillo
       true
     end
 
+    # Determines whether two arrays of dependencies are equal, and thus can be
+    # grouped.
+    #
+    # @param [Array<Object>] dependencies
+    # @param [Array<Object>] other_dependencies
+    # @return [Boolean] whether `dependencies` and `other_dependencies` should
+    #   be considered equal.
+    def dependencies_equal?(dependencies, other_dependencies)
+      dependencies == other_dependencies
+    end
+
     # Returns the name for the given `dependency`.
     # @note This method should be 'pure', i.e. the return value should depend
     #   only on the `dependency` parameter.
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb
@@ -207,7 +207,7 @@ module Bundler::Molinillo
       def start_resolution
         @started_at = Time.now
 
-        handle_missing_or_push_dependency_state(initial_state)
+        push_initial_state
 
         debug { "Starting resolution (#{@started_at})\nUser-requested dependencies: #{original_requested}" }
         resolver_ui.before_resolution
@@ -273,10 +273,10 @@ module Bundler::Molinillo
         states.last
       end
 
-      # Creates the initial state for the resolution, based upon the
+      # Creates and pushes the initial state for the resolution, based upon the
       # {#requested} dependencies
-      # @return [DependencyState] the initial state for the resolution
-      def initial_state
+      # @return [void]
+      def push_initial_state
         graph = DependencyGraph.new.tap do |dg|
           original_requested.each do |requested|
             vertex = dg.add_vertex(name_for(requested), nil, true)
@@ -285,18 +285,7 @@ module Bundler::Molinillo
           dg.tag(:initial_state)
         end
 
-        requirements = sort_dependencies(original_requested, graph, {})
-        initial_requirement = requirements.shift
-        DependencyState.new(
-          initial_requirement && name_for(initial_requirement),
-          requirements,
-          graph,
-          initial_requirement,
-          possibilities_for_requirement(initial_requirement, graph),
-          0,
-          {},
-          []
-        )
+        push_state_for_requirements(original_requested, true, graph)
       end
 
       # Unwinds the states stack because a conflict has been encountered
@@ -340,11 +329,11 @@ module Bundler::Molinillo
 
         # Look for past conflicts that could be unwound to affect the
         # requirement tree for the current conflict
+        all_reqs = last_detail_for_current_unwind.all_requirements
+        all_reqs_size = all_reqs.size
         relevant_unused_unwinds = unused_unwind_options.select do |alternative|
-          intersecting_requirements =
-            last_detail_for_current_unwind.all_requirements &
-            alternative.requirements_unwound_to_instead
-          next if intersecting_requirements.empty?
+          diff_reqs = all_reqs - alternative.requirements_unwound_to_instead
+          next if diff_reqs.size == all_reqs_size
           # Find the highest index unwind whilst looping through
           current_detail = alternative if alternative > current_detail
           alternative
@@ -355,13 +344,17 @@ module Bundler::Molinillo
         state.unused_unwind_options += unwind_details.reject { |detail| detail.state_index == -1 }
 
         # Update the requirements_unwound_to_instead on any relevant unused unwinds
-        relevant_unused_unwinds.each { |d| d.requirements_unwound_to_instead << current_detail.state_requirement }
-        unwind_details.each { |d| d.requirements_unwound_to_instead << current_detail.state_requirement }
+        relevant_unused_unwinds.each do |d|
+          (d.requirements_unwound_to_instead << current_detail.state_requirement).uniq!
+        end
+        unwind_details.each do |d|
+          (d.requirements_unwound_to_instead << current_detail.state_requirement).uniq!
+        end
 
         current_detail
       end
 
-      # @param [Array<Object>] array of requirements that combine to create a conflict
+      # @param [Array<Object>] binding_requirements array of requirements that combine to create a conflict
       # @return [Array<UnwindDetails>] array of UnwindDetails that have a chance
       #    of resolving the passed requirements
       def unwind_options_for_requirements(binding_requirements)
@@ -429,7 +422,7 @@ module Bundler::Molinillo
       end
 
       # @param [DependencyState] state
-      # @param [Array] array of requirements
+      # @param [Array] binding_requirements array of requirements
       # @return [Boolean] whether or not the given state has any possibilities
       #    that could satisfy the given requirements
       def conflict_fixing_possibilities?(state, binding_requirements)
@@ -444,7 +437,8 @@ module Bundler::Molinillo
 
       # Filter's a state's possibilities to remove any that would not fix the
       # conflict we've just rewound from
-      # @param [UnwindDetails] details of the conflict just unwound from
+      # @param [UnwindDetails] unwind_details details of the conflict just
+      #   unwound from
       # @return [void]
       def filter_possibilities_after_unwind(unwind_details)
         return unless state && !state.possibilities.empty?
@@ -458,7 +452,7 @@ module Bundler::Molinillo
 
       # Filter's a state's possibilities to remove any that would not satisfy
       # the requirements in the conflict we've just rewound from
-      # @param [UnwindDetails] details of the conflict just unwound from
+      # @param [UnwindDetails] unwind_details details of the conflict just unwound from
       # @return [void]
       def filter_possibilities_for_primary_unwind(unwind_details)
         unwinds_to_state = unused_unwind_options.select { |uw| uw.state_index == unwind_details.state_index }
@@ -491,7 +485,7 @@ module Bundler::Molinillo
 
       # Filter's a state's possibilities to remove any that would (eventually)
       # create a requirement in the conflict we've just rewound from
-      # @param [UnwindDetails] details of the conflict just unwound from
+      # @param [UnwindDetails] unwind_details details of the conflict just unwound from
       # @return [void]
       def filter_possibilities_for_parent_unwind(unwind_details)
         unwinds_to_state = unused_unwind_options.select { |uw| uw.state_index == unwind_details.state_index }
@@ -500,7 +494,7 @@ module Bundler::Molinillo
         primary_unwinds = unwinds_to_state.select(&:unwinding_to_primary_requirement?).uniq
         parent_unwinds = unwinds_to_state.uniq - primary_unwinds
 
-        allowed_possibility_sets = Compatibility.flat_map(primary_unwinds) do |unwind|
+        allowed_possibility_sets = primary_unwinds.flat_map do |unwind|
           states[unwind.state_index].possibilities.select do |possibility_set|
             possibility_set.possibilities.any? do |poss|
               possibility_satisfies_requirements?(poss, unwind.conflicting_requirements)
@@ -508,7 +502,7 @@ module Bundler::Molinillo
           end
         end
 
-        requirements_to_avoid = Compatibility.flat_map(parent_unwinds, &:sub_dependencies_to_avoid)
+        requirements_to_avoid = parent_unwinds.flat_map(&:sub_dependencies_to_avoid)
 
         state.possibilities.reject! do |possibility_set|
           !allowed_possibility_sets.include?(possibility_set) &&
@@ -524,12 +518,12 @@ module Bundler::Molinillo
 
         possible_binding_requirements = conflict.requirements.values.flatten(1).uniq
 
-        # When there’s a `CircularDependency` error the conflicting requirement
-        # (the one causing the circular) won’t be `conflict.requirement`
-        # (which won’t be for the right state, because we won’t have created it,
-        # because it’s circular).
-        # We need to make sure we have that requirement in the conflict’s list,
-        # otherwise we won’t be able to unwind properly, so we just return all
+        # When there's a `CircularDependency` error the conflicting requirement
+        # (the one causing the circular) won't be `conflict.requirement`
+        # (which won't be for the right state, because we won't have created it,
+        # because it's circular).
+        # We need to make sure we have that requirement in the conflict's list,
+        # otherwise we won't be able to unwind properly, so we just return all
         # the requirements for the conflict.
         return possible_binding_requirements if conflict.underlying_error
 
@@ -558,8 +552,8 @@ module Bundler::Molinillo
       end
 
       # @param [Object] requirement we wish to check
-      # @param [Array] array of requirements
-      # @param [Array] array of possibilities the requirements will be used to filter
+      # @param [Array] possible_binding_requirements array of requirements
+      # @param [Array] possibilities array of possibilities the requirements will be used to filter
       # @return [Boolean] whether or not the given requirement is required to filter
       #    out all elements of the array of possibilities.
       def binding_requirement_in_set?(requirement, possible_binding_requirements, possibilities)
@@ -568,6 +562,7 @@ module Bundler::Molinillo
         end
       end
 
+      # @param [Object] requirement
       # @return [Object] the requirement that led to `requirement` being added
       #   to the list of requirements.
       def parent_of(requirement)
@@ -577,6 +572,7 @@ module Bundler::Molinillo
         parent_state.requirement
       end
 
+      # @param [String] name
       # @return [Object] the requirement that led to a version of a possibility
       #   with the given name being activated.
       def requirement_for_existing_name(name)
@@ -585,6 +581,7 @@ module Bundler::Molinillo
         states.find { |s| s.name == name }.requirement
       end
 
+      # @param [Object] requirement
       # @return [ResolutionState] the state whose `requirement` is the given
       #   `requirement`.
       def find_state_for(requirement)
@@ -592,6 +589,7 @@ module Bundler::Molinillo
         states.find { |i| requirement == i.requirement }
       end
 
+      # @param [Object] underlying_error
       # @return [Conflict] a {Conflict} that reflects the failure to activate
       #   the {#possibility} in conjunction with the current {#state}
       def create_conflict(underlying_error = nil)
@@ -628,6 +626,7 @@ module Bundler::Molinillo
         vertex.requirements.map { |r| requirement_tree_for(r) }
       end
 
+      # @param [Object] requirement
       # @return [Array<Object>] the list of requirements that led to
       #   `requirement` being required.
       def requirement_tree_for(requirement)
@@ -673,9 +672,8 @@ module Bundler::Molinillo
           attempt_to_filter_existing_spec(existing_vertex)
         else
           latest = possibility.latest_version
-          # use reject!(!satisfied) for 1.8.7 compatibility
-          possibility.possibilities.reject! do |possibility|
-            !requirement_satisfied_by?(requirement, activated, possibility)
+          possibility.possibilities.select! do |possibility|
+            requirement_satisfied_by?(requirement, activated, possibility)
           end
           if possibility.latest_version.nil?
             # ensure there's a possibility for better error messages
@@ -705,7 +703,7 @@ module Bundler::Molinillo
 
       # Generates a filtered version of the existing vertex's `PossibilitySet` using the
       # current state's `requirement`
-      # @param [Object] existing vertex
+      # @param [Object] vertex existing vertex
       # @return [PossibilitySet] filtered possibility set
       def filtered_possibility_set(vertex)
         PossibilitySet.new(vertex.payload.dependencies, vertex.payload.possibilities & possibility.possibilities)
@@ -730,7 +728,7 @@ module Bundler::Molinillo
       end
 
       # Requires the dependencies that the recently activated spec has
-      # @param [Object] activated_possibility the PossibilitySet that has just been
+      # @param [Object] possibility_set the PossibilitySet that has just been
       #   activated
       # @return [void]
       def require_nested_dependencies_for(possibility_set)
@@ -749,6 +747,8 @@ module Bundler::Molinillo
       # Pushes a new {DependencyState} that encapsulates both existing and new
       # requirements
       # @param [Array] new_requirements
+      # @param [Boolean] requires_sort
+      # @param [Object] new_activated
       # @return [void]
       def push_state_for_requirements(new_requirements, requires_sort = true, new_activated = activated)
         new_requirements = sort_dependencies(new_requirements.uniq, new_activated, conflicts) if requires_sort
@@ -767,7 +767,8 @@ module Bundler::Molinillo
 
       # Checks a proposed requirement with any existing locked requirement
       # before generating an array of possibilities for it.
-      # @param [Object] the proposed requirement
+      # @param [Object] requirement the proposed requirement
+      # @param [Object] activated
       # @return [Array] possibilities
       def possibilities_for_requirement(requirement, activated = self.activated)
         return [] unless requirement
@@ -778,7 +779,8 @@ module Bundler::Molinillo
         group_possibilities(search_for(requirement))
       end
 
-      # @param [Object] the proposed requirement
+      # @param [Object] requirement the proposed requirement
+      # @param [Object] activated
       # @return [Array] possibility set containing only the locked requirement, if any
       def locked_requirement_possibility_set(requirement, activated = self.activated)
         all_possibilities = search_for(requirement)
@@ -797,15 +799,15 @@ module Bundler::Molinillo
       # Build an array of PossibilitySets, with each element representing a group of
       # dependency versions that all have the same sub-dependency version constraints
       # and are contiguous.
-      # @param [Array] an array of possibilities
-      # @return [Array] an array of possibility sets
+      # @param [Array] possibilities an array of possibilities
+      # @return [Array<PossibilitySet>] an array of possibility sets
       def group_possibilities(possibilities)
         possibility_sets = []
         current_possibility_set = nil
 
         possibilities.reverse_each do |possibility|
           dependencies = dependencies_for(possibility)
-          if current_possibility_set && current_possibility_set.dependencies == dependencies
+          if current_possibility_set && dependencies_equal?(current_possibility_set.dependencies, dependencies)
             current_possibility_set.possibilities.unshift(possibility)
           else
             possibility_sets.unshift(PossibilitySet.new(dependencies, [possibility]))
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/net-http-persistent/README.rdoc
@@ -0,0 +1,82 @@
+= net-http-persistent
+
+home :: https://github.com/drbrain/net-http-persistent
+rdoc :: http://docs.seattlerb.org/net-http-persistent
+
+== DESCRIPTION:
+
+Manages persistent connections using Net::HTTP including a thread pool for
+connecting to multiple hosts.
+
+Using persistent HTTP connections can dramatically increase the speed of HTTP.
+Creating a new HTTP connection for every request involves an extra TCP
+round-trip and causes TCP congestion avoidance negotiation to start over.
+
+Net::HTTP supports persistent connections with some API methods but does not
+make setting up a single persistent connection or managing multiple
+connections easy.  Net::HTTP::Persistent wraps Net::HTTP and allows you to
+focus on how to make HTTP requests.
+
+== FEATURES/PROBLEMS:
+
+* Supports TLS with secure defaults
+* Thread-safe
+* Pure ruby
+
+== SYNOPSIS
+
+The following example will make two requests to the same server.  The
+connection is kept alive between requests:
+
+    require 'net/http/persistent'
+
+    uri = URI 'http://example.com/awesome/web/service'
+
+    http = Net::HTTP::Persistent.new name: 'my_app_name'
+
+    # perform a GET
+    response = http.request uri
+
+    # create a POST
+    post_uri = uri + 'create'
+    post = Net::HTTP::Post.new post_uri.path
+    post.set_form_data 'some' => 'cool data'
+
+    # perform the POST, the URI is always required
+    response = http.request post_uri, post
+
+    # if you are done making http requests, or won't make requests for several
+    # minutes
+    http.shutdown
+
+Please see the documentation on Net::HTTP::Persistent for more information,
+including SSL connection verification, header handling and tunable options.
+
+== INSTALL:
+
+  gem install net-http-persistent
+
+== LICENSE:
+
+(The MIT License)
+
+Copyright (c) Eric Hodel, Aaron Patterson
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+'Software'), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb
@@ -12,15 +12,11 @@ autoload :OpenSSL, 'openssl'
 # servers you wish to talk to.  For each host:port you communicate with a
 # single persistent connection is created.
 #
-# Multiple Bundler::Persistent::Net::HTTP::Persistent objects will share the same set of
-# connections.
+# Connections will be shared across threads through a connection pool to
+# increase reuse of connections.
 #
-# For each thread you start a new connection will be created.  A
-# Bundler::Persistent::Net::HTTP::Persistent connection will not be shared across threads.
-#
-# You can shut down the HTTP connections when done by calling #shutdown.  You
-# should name your Bundler::Persistent::Net::HTTP::Persistent object if you intend to call this
-# method.
+# You can shut down any remaining HTTP connections when done by calling
+# #shutdown.
 #
 # Example:
 #
@@ -28,7 +24,7 @@ autoload :OpenSSL, 'openssl'
 #
 #   uri = Bundler::URI 'http://example.com/awesome/web/service'
 #
-#   http = Bundler::Persistent::Net::HTTP::Persistent.new name: 'my_app_name'
+#   http = Bundler::Persistent::Net::HTTP::Persistent.new
 #
 #   # perform a GET
 #   response = http.request uri
@@ -50,14 +46,14 @@ autoload :OpenSSL, 'openssl'
 # to use Bundler::URI#request_uri not Bundler::URI#path.  The request_uri contains the query
 # params which are sent in the body for other requests.
 #
-# == SSL
+# == TLS/SSL
 #
-# SSL connections are automatically created depending upon the scheme of the
-# Bundler::URI.  SSL connections are automatically verified against the default
+# TLS connections are automatically created depending upon the scheme of the
+# Bundler::URI.  TLS connections are automatically verified against the default
 # certificate store for your computer.  You can override this by changing
 # verify_mode or by specifying an alternate cert_store.
 #
-# Here are the SSL settings, see the individual methods for documentation:
+# Here are the TLS settings, see the individual methods for documentation:
 #
 # #certificate        :: This client's certificate
 # #ca_file            :: The certificate-authorities
@@ -67,7 +63,7 @@ autoload :OpenSSL, 'openssl'
 # #private_key        :: The client's SSL private key
 # #reuse_ssl_sessions :: Reuse a previously opened SSL session for a new
 #                        connection
-# #ssl_timeout        :: SSL session lifetime
+# #ssl_timeout        :: Session lifetime
 # #ssl_version        :: Which specific SSL version to use
 # #verify_callback    :: For server certificate verification
 # #verify_depth       :: Depth of certificate verification
@@ -96,14 +92,15 @@ autoload :OpenSSL, 'openssl'
 #
 # === Segregation
 #
-# By providing an application name to ::new you can separate your connections
-# from the connections of other applications.
+# Each Bundler::Persistent::Net::HTTP::Persistent instance has its own pool of connections.  There
+# is no sharing with other instances (as was true in earlier versions).
 #
 # === Idle Timeout
 #
-# If a connection hasn't been used for this number of seconds it will automatically be
-# reset upon the next use to avoid attempting to send to a closed connection.
-# The default value is 5 seconds. nil means no timeout. Set through #idle_timeout.
+# If a connection hasn't been used for this number of seconds it will
+# automatically be reset upon the next use to avoid attempting to send to a
+# closed connection.  The default value is 5 seconds. nil means no timeout.
+# Set through #idle_timeout.
 #
 # Reducing this value may help avoid the "too many connection resets" error
 # when sending non-idempotent requests while increasing this value will cause
@@ -118,8 +115,9 @@ autoload :OpenSSL, 'openssl'
 #
 # The number of requests that should be made before opening a new connection.
 # Typically many keep-alive capable servers tune this to 100 or less, so the
-# 101st request will fail with ECONNRESET. If unset (default), this value has no
-# effect, if set, connections will be reset on the request after max_requests.
+# 101st request will fail with ECONNRESET. If unset (default), this value has
+# no effect, if set, connections will be reset on the request after
+# max_requests.
 #
 # === Open Timeout
 #
@@ -131,45 +129,6 @@ autoload :OpenSSL, 'openssl'
 # Socket options may be set on newly-created connections.  See #socket_options
 # for details.
 #
-# === Non-Idempotent Requests
-#
-# By default non-idempotent requests will not be retried per RFC 2616.  By
-# setting retry_change_requests to true requests will automatically be retried
-# once.
-#
-# Only do this when you know that retrying a POST or other non-idempotent
-# request is safe for your application and will not create duplicate
-# resources.
-#
-# The recommended way to handle non-idempotent requests is the following:
-#
-#   require 'bundler/vendor/net-http-persistent/lib/net/http/persistent'
-#
-#   uri = Bundler::URI 'http://example.com/awesome/web/service'
-#   post_uri = uri + 'create'
-#
-#   http = Bundler::Persistent::Net::HTTP::Persistent.new name: 'my_app_name'
-#
-#   post = Net::HTTP::Post.new post_uri.path
-#   # ... fill in POST request
-#
-#   begin
-#     response = http.request post_uri, post
-#   rescue Bundler::Persistent::Net::HTTP::Persistent::Error
-#
-#     # POST failed, make a new request to verify the server did not process
-#     # the request
-#     exists_uri = uri + '...'
-#     response = http.get exists_uri
-#
-#     # Retry if it failed
-#     retry if response.code == '404'
-#   end
-#
-# The method of determining if the resource was created or not is unique to
-# the particular service you are using.  Of course, you will want to add
-# protection from infinite looping.
-#
 # === Connection Termination
 #
 # If you are done using the Bundler::Persistent::Net::HTTP::Persistent instance you may shut down
@@ -195,33 +154,27 @@ class Bundler::Persistent::Net::HTTP::Pe
   HAVE_OPENSSL = defined? OpenSSL::SSL # :nodoc:
 
   ##
-  # The default connection pool size is 1/4 the allowed open files.
-
-  if Gem.win_platform? then
-    DEFAULT_POOL_SIZE = 256
+  # The default connection pool size is 1/4 the allowed open files
+  # (<code>ulimit -n</code>) or 256 if your OS does not support file handle
+  # limits (typically windows).
+
+  if Process.const_defined? :RLIMIT_NOFILE
+    open_file_limits = Process.getrlimit(Process::RLIMIT_NOFILE)
+
+    # Under JRuby on Windows Process responds to `getrlimit` but returns something that does not match docs
+    if open_file_limits.respond_to?(:first)
+      DEFAULT_POOL_SIZE = open_file_limits.first / 4
+    else
+      DEFAULT_POOL_SIZE = 256
+    end
   else
-    DEFAULT_POOL_SIZE = Process.getrlimit(Process::RLIMIT_NOFILE).first / 4
+    DEFAULT_POOL_SIZE = 256
   end
 
   ##
   # The version of Bundler::Persistent::Net::HTTP::Persistent you are using
 
-  VERSION = '3.1.0'
-
-  ##
-  # Exceptions rescued for automatic retry on ruby 2.0.0.  This overlaps with
-  # the exception list for ruby 1.x.
-
-  RETRIED_EXCEPTIONS = [ # :nodoc:
-    (Net::ReadTimeout if Net.const_defined? :ReadTimeout),
-    IOError,
-    EOFError,
-    Errno::ECONNRESET,
-    Errno::ECONNABORTED,
-    Errno::EPIPE,
-    (OpenSSL::SSL::SSLError if HAVE_OPENSSL),
-    Timeout::Error,
-  ].compact
+  VERSION = '4.0.0'
 
   ##
   # Error class for errors raised by Bundler::Persistent::Net::HTTP::Persistent.  Various
@@ -349,6 +302,13 @@ class Bundler::Persistent::Net::HTTP::Pe
   attr_accessor :max_requests
 
   ##
+  # Number of retries to perform if a request fails.
+  #
+  # See also #max_retries=, Net::HTTP#max_retries=.
+
+  attr_reader :max_retries
+
+  ##
   # The value sent in the Keep-Alive header.  Defaults to 30.  Not needed for
   # HTTP/1.1 servers.
   #
@@ -360,8 +320,7 @@ class Bundler::Persistent::Net::HTTP::Pe
   attr_accessor :keep_alive
 
   ##
-  # A name for this connection.  Allows you to keep your connections apart
-  # from everybody else's.
+  # The name for this collection of persistent connections.
 
   attr_reader :name
 
@@ -491,22 +450,10 @@ class Bundler::Persistent::Net::HTTP::Pe
   attr_reader :verify_mode
 
   ##
-  # Enable retries of non-idempotent requests that change data (e.g. POST
-  # requests) when the server has disconnected.
-  #
-  # This will in the worst case lead to multiple requests with the same data,
-  # but it may be useful for some applications.  Take care when enabling
-  # this option to ensure it is safe to POST or perform other non-idempotent
-  # requests to the server.
-
-  attr_accessor :retry_change_requests
-
-  ##
   # Creates a new Bundler::Persistent::Net::HTTP::Persistent.
   #
-  # Set +name+ to keep your connections apart from everybody else's.  Not
-  # required currently, but highly recommended.  Your library name should be
-  # good enough.  This parameter will be required in a future version.
+  # Set a +name+ for fun.  Your library name should be good enough, but this
+  # otherwise has no purpose.
   #
   # +proxy+ may be set to a Bundler::URI::HTTP or :ENV to pick up proxy options from
   # the environment.  See proxy_from_env for details.
@@ -519,8 +466,9 @@ class Bundler::Persistent::Net::HTTP::Pe
   #   proxy.password = 'hunter2'
   #
   # Set +pool_size+ to limit the maximum number of connections allowed.
-  # Defaults to 1/4 the number of allowed file handles.  You can have no more
-  # than this many threads with active HTTP transactions.
+  # Defaults to 1/4 the number of allowed file handles or 256 if your OS does
+  # not support a limit on allowed file handles.  You can have no more than
+  # this many threads with active HTTP transactions.
 
   def initialize name: nil, proxy: nil, pool_size: DEFAULT_POOL_SIZE
     @name = name
@@ -537,6 +485,7 @@ class Bundler::Persistent::Net::HTTP::Pe
     @write_timeout    = nil
     @idle_timeout     = 5
     @max_requests     = nil
+    @max_retries      = 1
     @socket_options   = []
     @ssl_generation   = 0 # incremented when SSL session variables change
 
@@ -568,8 +517,6 @@ class Bundler::Persistent::Net::HTTP::Pe
       @reuse_ssl_sessions = OpenSSL::SSL.const_defined? :Session
     end
 
-    @retry_change_requests = false
-
     self.proxy = proxy if proxy
   end
 
@@ -630,7 +577,9 @@ class Bundler::Persistent::Net::HTTP::Pe
 
     net_http_args = [uri.hostname, uri.port]
 
-    if @proxy_uri and not proxy_bypass? uri.hostname, uri.port then
+    # I'm unsure if uri.host or uri.hostname should be checked against
+    # the proxy bypass list.
+    if @proxy_uri and not proxy_bypass? uri.host, uri.port then
       net_http_args.concat @proxy_args
     else
       net_http_args.concat [nil, nil, nil, nil]
@@ -650,9 +599,11 @@ class Bundler::Persistent::Net::HTTP::Pe
       reset connection
     end
 
-    http.read_timeout = @read_timeout if @read_timeout
-    http.write_timeout = @write_timeout if @write_timeout && http.respond_to?(:write_timeout=)
-    http.keep_alive_timeout = @idle_timeout if @idle_timeout
+    http.keep_alive_timeout = @idle_timeout  if @idle_timeout
+    http.max_retries        = @max_retries   if http.respond_to?(:max_retries=)
+    http.read_timeout       = @read_timeout  if @read_timeout
+    http.write_timeout      = @write_timeout if
+      @write_timeout && http.respond_to?(:write_timeout=)
 
     return yield connection
   rescue Errno::ECONNREFUSED
@@ -670,27 +621,14 @@ class Bundler::Persistent::Net::HTTP::Pe
   end
 
   ##
-  # Returns an error message containing the number of requests performed on
-  # this connection
-
-  def error_message connection
-    connection.requests -= 1 # fixup
-
-    age = Time.now - connection.last_use
-
-    "after #{connection.requests} requests on #{connection.http.object_id}, " \
-      "last used #{age} seconds ago"
-  end
-
-  ##
-  # Bundler::URI::escape wrapper
+  # CGI::escape wrapper
 
   def escape str
     CGI.escape str if str
   end
 
   ##
-  # Bundler::URI::unescape wrapper
+  # CGI::unescape wrapper
 
   def unescape str
     CGI.unescape str if str
@@ -733,6 +671,7 @@ class Bundler::Persistent::Net::HTTP::Pe
   def finish connection
     connection.finish
 
+    connection.http.instance_variable_set :@last_communicated, nil
     connection.http.instance_variable_set :@ssl_session, nil unless
       @reuse_ssl_sessions
   end
@@ -741,31 +680,31 @@ class Bundler::Persistent::Net::HTTP::Pe
   # Returns the HTTP protocol version for +uri+
 
   def http_version uri
-    @http_versions["#{uri.host}:#{uri.port}"]
+    @http_versions["#{uri.hostname}:#{uri.port}"]
   end
 
   ##
-  # Is +req+ idempotent according to RFC 2616?
+  # Adds "http://" to the String +uri+ if it is missing.
 
-  def idempotent? req
-    case req.method
-    when 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PUT', 'TRACE' then
-      true
-    end
+  def normalize_uri uri
+    (uri =~ /^https?:/) ? uri : "http://#{uri}"
   end
 
   ##
-  # Is the request +req+ idempotent or is retry_change_requests allowed.
+  # Set the maximum number of retries for a request.
+  #
+  # Defaults to one retry.
+  #
+  # Set this to 0 to disable retries.
 
-  def can_retry? req
-    @retry_change_requests && !idempotent?(req)
-  end
+  def max_retries= retries
+    retries = retries.to_int
 
-  ##
-  # Adds "http://" to the String +uri+ if it is missing.
+    raise ArgumentError, "max_retries must be positive" if retries < 0
 
-  def normalize_uri uri
-    (uri =~ /^https?:/) ? uri : "http://#{uri}"
+    @max_retries = retries
+
+    reconnect
   end
 
   ##
@@ -806,7 +745,7 @@ class Bundler::Persistent::Net::HTTP::Pe
 
     if @proxy_uri then
       @proxy_args = [
-        @proxy_uri.host,
+        @proxy_uri.hostname,
         @proxy_uri.port,
         unescape(@proxy_uri.user),
         unescape(@proxy_uri.password),
@@ -881,14 +820,15 @@ class Bundler::Persistent::Net::HTTP::Pe
   end
 
   ##
-  # Forces reconnection of HTTP connections.
+  # Forces reconnection of all HTTP connections, including TLS/SSL
+  # connections.
 
   def reconnect
     @generation += 1
   end
 
   ##
-  # Forces reconnection of SSL connections.
+  # Forces reconnection of only TLS/SSL connections.
 
   def reconnect_ssl
     @ssl_generation += 1
@@ -921,14 +861,8 @@ class Bundler::Persistent::Net::HTTP::Pe
   # the response will not have been read).
   #
   # +req+ must be a Net::HTTPGenericRequest subclass (see Net::HTTP for a list).
-  #
-  # If there is an error and the request is idempotent according to RFC 2616
-  # it will be retried automatically.
 
   def request uri, req = nil, &block
-    retried      = false
-    bad_response = false
-
     uri      = Bundler::URI uri
     req      = request_setup req || uri
     response = nil
@@ -942,37 +876,12 @@ class Bundler::Persistent::Net::HTTP::Pe
         response = http.request req, &block
 
         if req.connection_close? or
-           (response.http_version <= '1.0' and
+          (response.http_version <= '1.0' and
             not response.connection_keep_alive?) or
-           response.connection_close? then
+            response.connection_close? then
           finish connection
         end
-      rescue Net::HTTPBadResponse => e
-        message = error_message connection
-
-        finish connection
-
-        raise Error, "too many bad responses #{message}" if
-        bad_response or not can_retry? req
-
-        bad_response = true
-        retry
-      rescue *RETRIED_EXCEPTIONS => e
-        request_failed e, req, connection if
-          retried or not can_retry? req
-
-        reset connection
-
-        retried = true
-        retry
-      rescue Errno::EINVAL, Errno::ETIMEDOUT => e # not retried on ruby 2
-        request_failed e, req, connection if retried or not can_retry? req
-
-        reset connection
-
-        retried = true
-        retry
-      rescue Exception => e
+      rescue Exception # make sure to close the connection when it was interrupted
         finish connection
 
         raise
@@ -981,34 +890,19 @@ class Bundler::Persistent::Net::HTTP::Pe
       end
     end
 
-    @http_versions["#{uri.host}:#{uri.port}"] ||= response.http_version
+    @http_versions["#{uri.hostname}:#{uri.port}"] ||= response.http_version
 
     response
   end
 
   ##
-  # Raises an Error for +exception+ which resulted from attempting the request
-  # +req+ on the +connection+.
-  #
-  # Finishes the +connection+.
-
-  def request_failed exception, req, connection # :nodoc:
-    due_to = "(due to #{exception.message} - #{exception.class})"
-    message = "too many connection resets #{due_to} #{error_message connection}"
-
-    finish connection
-
-    raise Error, message, exception.backtrace
-  end
-
-  ##
   # Creates a GET request if +req_or_uri+ is a Bundler::URI and adds headers to the
   # request.
   #
   # Returns the request.
 
   def request_setup req_or_uri # :nodoc:
-    req = if Bundler::URI === req_or_uri then
+    req = if req_or_uri.respond_to? 'request_uri' then
             Net::HTTP::Get.new req_or_uri.request_uri
           else
             req_or_uri
@@ -1172,7 +1066,6 @@ application:
 
     reconnect_ssl
   end
-
 end
 
 require_relative 'persistent/connection'
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/LICENSE.md
@@ -0,0 +1,20 @@
+Copyright (c) 2008 Yehuda Katz, Eric Hodel, et al.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor.rb
@@ -1,7 +1,7 @@
-require "set"
 require_relative "thor/base"
 
 class Bundler::Thor
+  $thor_runner ||= false
   class << self
     # Allows for custom "Command" package naming.
     #
@@ -323,7 +323,7 @@ class Bundler::Thor
     # ==== Parameters
     # Symbol ...:: A list of commands that should be affected.
     def stop_on_unknown_option!(*command_names)
-      stop_on_unknown_option.merge(command_names)
+      @stop_on_unknown_option = stop_on_unknown_option | command_names
     end
 
     def stop_on_unknown_option?(command) #:nodoc:
@@ -337,29 +337,22 @@ class Bundler::Thor
     # ==== Parameters
     # Symbol ...:: A list of commands that should be affected.
     def disable_required_check!(*command_names)
-      disable_required_check.merge(command_names)
+      @disable_required_check = disable_required_check | command_names
     end
 
     def disable_required_check?(command) #:nodoc:
       command && disable_required_check.include?(command.name.to_sym)
     end
 
-    def deprecation_warning(message) #:nodoc:
-      unless ENV['THOR_SILENCE_DEPRECATION']
-        warn "Deprecation warning: #{message}\n" +
-          'You can silence deprecations warning by setting the environment variable THOR_SILENCE_DEPRECATION.'
-      end
-    end
-
   protected
 
     def stop_on_unknown_option #:nodoc:
-      @stop_on_unknown_option ||= Set.new
+      @stop_on_unknown_option ||= []
     end
 
     # help command has the required check disabled by default.
     def disable_required_check #:nodoc:
-      @disable_required_check ||= Set.new([:help])
+      @disable_required_check ||= [:help]
     end
 
     # The method responsible for dispatching given the args.
@@ -405,7 +398,6 @@ class Bundler::Thor
     # the namespace should be displayed as arguments.
     #
     def banner(command, namespace = nil, subcommand = false)
-      $thor_runner ||= false
       command.formatted_usage(self, $thor_runner, subcommand).split("\n").map do |formatted_usage|
         "#{basename} #{formatted_usage}"
       end.join("\n")
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/actions.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/actions.rb
@@ -161,6 +161,8 @@ class Bundler::Thor
     # to the block you provide. The path is set back to the previous path when
     # the method exits.
     #
+    # Returns the value yielded by the block.
+    #
     # ==== Parameters
     # dir<String>:: the directory to move to.
     # config<Hash>:: give :verbose => true to log and use padding.
@@ -179,16 +181,18 @@ class Bundler::Thor
         FileUtils.mkdir_p(destination_root)
       end
 
+      result = nil
       if pretend
         # In pretend mode, just yield down to the block
-        block.arity == 1 ? yield(destination_root) : yield
+        result = block.arity == 1 ? yield(destination_root) : yield
       else
         require "fileutils"
-        FileUtils.cd(destination_root) { block.arity == 1 ? yield(destination_root) : yield }
+        FileUtils.cd(destination_root) { result = block.arity == 1 ? yield(destination_root) : yield }
       end
 
       @destination_stack.pop
       shell.padding -= 1 if verbose
+      result
     end
 
     # Goes to the root and execute the given block.
@@ -219,7 +223,7 @@ class Bundler::Thor
 
       contents = if is_uri
         require "open-uri"
-        open(path, "Accept" => "application/x-thor-template", &:read)
+        URI.open(path, "Accept" => "application/x-thor-template", &:read)
       else
         open(path, &:read)
       end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/actions/create_link.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/actions/create_link.rb
@@ -33,7 +33,8 @@ class Bundler::Thor
       # Boolean:: true if it is identical, false otherwise.
       #
       def identical?
-        exists? && File.identical?(render, destination)
+        source = File.expand_path(render, File.dirname(destination))
+        exists? && File.identical?(source, destination)
       end
 
       def invoke!
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/actions/file_manipulation.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/actions/file_manipulation.rb
@@ -210,9 +210,9 @@ class Bundler::Thor
     #
     # ==== Examples
     #
-    #   inject_into_class "app/controllers/application_controller.rb", ApplicationController, "  filter_parameter :password\n"
+    #   inject_into_class "app/controllers/application_controller.rb", "ApplicationController", "  filter_parameter :password\n"
     #
-    #   inject_into_class "app/controllers/application_controller.rb", ApplicationController do
+    #   inject_into_class "app/controllers/application_controller.rb", "ApplicationController" do
     #     "  filter_parameter :password\n"
     #   end
     #
@@ -233,9 +233,9 @@ class Bundler::Thor
     #
     # ==== Examples
     #
-    #   inject_into_module "app/helpers/application_helper.rb", ApplicationHelper, "  def help; 'help'; end\n"
+    #   inject_into_module "app/helpers/application_helper.rb", "ApplicationHelper", "  def help; 'help'; end\n"
     #
-    #   inject_into_module "app/helpers/application_helper.rb", ApplicationHelper do
+    #   inject_into_module "app/helpers/application_helper.rb", "ApplicationHelper" do
     #     "  def help; 'help'; end\n"
     #   end
     #
@@ -251,7 +251,8 @@ class Bundler::Thor
     # path<String>:: path of the file to be changed
     # flag<Regexp|String>:: the regexp or string to be replaced
     # replacement<String>:: the replacement, can be also given as a block
-    # config<Hash>:: give :verbose => false to not log the status.
+    # config<Hash>:: give :verbose => false to not log the status, and
+    #                :force => true, to force the replacement regardles of runner behavior.
     #
     # ==== Example
     #
@@ -262,9 +263,10 @@ class Bundler::Thor
     #   end
     #
     def gsub_file(path, flag, *args, &block)
-      return unless behavior == :invoke
       config = args.last.is_a?(Hash) ? args.pop : {}
 
+      return unless behavior == :invoke || config.fetch(:force, false)
+
       path = File.expand_path(path, destination_root)
       say_status :gsub, relative_to_original_destination_root(path), config.fetch(:verbose, true)
 
@@ -329,7 +331,7 @@ class Bundler::Thor
       path = File.expand_path(path, destination_root)
 
       say_status :remove, relative_to_original_destination_root(path), config.fetch(:verbose, true)
-      if !options[:pretend] && File.exist?(path)
+      if !options[:pretend] && (File.exist?(path) || File.symlink?(path))
         require "fileutils"
         ::FileUtils.rm_rf(path)
       end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/actions/inject_into_file.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/actions/inject_into_file.rb
@@ -106,12 +106,11 @@ class Bundler::Thor
       # Adds the content to the file.
       #
       def replace!(regexp, string, force)
-        return if pretend?
         content = File.read(destination)
         if force || !content.include?(replacement)
           success = content.gsub!(regexp, string)
 
-          File.open(destination, "wb") { |file| file.write(content) }
+          File.open(destination, "wb") { |file| file.write(content) } unless pretend?
           success
         end
       end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/base.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/base.rb
@@ -22,6 +22,15 @@ class Bundler::Thor
 
   TEMPLATE_EXTNAME = ".tt"
 
+  class << self
+    def deprecation_warning(message) #:nodoc:
+      unless ENV['THOR_SILENCE_DEPRECATION']
+        warn "Deprecation warning: #{message}\n" +
+          'You can silence deprecations warning by setting the environment variable THOR_SILENCE_DEPRECATION.'
+      end
+    end
+  end
+
   module Base
     attr_accessor :options, :parent_options, :args
 
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/core_ext/hash_with_indifferent_access.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/core_ext/hash_with_indifferent_access.rb
@@ -28,6 +28,12 @@ class Bundler::Thor
         super(convert_key(key))
       end
 
+      def except(*keys)
+        dup.tap do |hash|
+          keys.each { |key| hash.delete(convert_key(key)) }
+        end
+      end
+
       def fetch(key, *args)
         super(convert_key(key), *args)
       end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/core_ext/io_binary_read.rb
+++ /dev/null
@@ -1,12 +0,0 @@
-class IO #:nodoc:
-  class << self
-    unless method_defined? :binread
-      def binread(file, *args)
-        raise ArgumentError, "wrong number of arguments (#{1 + args.size} for 1..3)" unless args.size < 3
-        File.open(file, "rb") do |f|
-          f.read(*args)
-        end
-      end
-    end
-  end
-end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/core_ext/ordered_hash.rb
+++ /dev/null
@@ -1,129 +0,0 @@
-class Bundler::Thor
-  module CoreExt
-    class OrderedHash < ::Hash
-      if RUBY_VERSION < "1.9"
-        def initialize(*args, &block)
-          super
-          @keys = []
-        end
-
-        def initialize_copy(other)
-          super
-          # make a deep copy of keys
-          @keys = other.keys
-        end
-
-        def []=(key, value)
-          @keys << key unless key?(key)
-          super
-        end
-
-        def delete(key)
-          if key? key
-            index = @keys.index(key)
-            @keys.delete_at index
-          end
-          super
-        end
-
-        def delete_if
-          super
-          sync_keys!
-          self
-        end
-
-        alias_method :reject!, :delete_if
-
-        def reject(&block)
-          dup.reject!(&block)
-        end
-
-        def keys
-          @keys.dup
-        end
-
-        def values
-          @keys.map { |key| self[key] }
-        end
-
-        def to_hash
-          self
-        end
-
-        def to_a
-          @keys.map { |key| [key, self[key]] }
-        end
-
-        def each_key
-          return to_enum(:each_key) unless block_given?
-          @keys.each { |key| yield(key) }
-          self
-        end
-
-        def each_value
-          return to_enum(:each_value) unless block_given?
-          @keys.each { |key| yield(self[key]) }
-          self
-        end
-
-        def each
-          return to_enum(:each) unless block_given?
-          @keys.each { |key| yield([key, self[key]]) }
-          self
-        end
-
-        def each_pair
-          return to_enum(:each_pair) unless block_given?
-          @keys.each { |key| yield(key, self[key]) }
-          self
-        end
-
-        alias_method :select, :find_all
-
-        def clear
-          super
-          @keys.clear
-          self
-        end
-
-        def shift
-          k = @keys.first
-          v = delete(k)
-          [k, v]
-        end
-
-        def merge!(other_hash)
-          if block_given?
-            other_hash.each { |k, v| self[k] = key?(k) ? yield(k, self[k], v) : v }
-          else
-            other_hash.each { |k, v| self[k] = v }
-          end
-          self
-        end
-
-        alias_method :update, :merge!
-
-        def merge(other_hash, &block)
-          dup.merge!(other_hash, &block)
-        end
-
-        # When replacing with another hash, the initial order of our keys must come from the other hash -ordered or not.
-        def replace(other)
-          super
-          @keys = other.keys
-          self
-        end
-
-        def inspect
-          "#<#{self.class} #{super}>"
-        end
-
-        private
-
-        def sync_keys!
-          @keys.delete_if { |k| !key?(k) }
-        end
-      end
-    end
-  end
-end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/error.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/error.rb
@@ -1,5 +1,5 @@
 class Bundler::Thor
-  Correctable = if defined?(DidYouMean::SpellChecker) && defined?(DidYouMean::Correctable)
+  Correctable = if defined?(DidYouMean::SpellChecker) && defined?(DidYouMean::Correctable) # rubocop:disable Naming/ConstantName
                   # In order to support versions of Ruby that don't have keyword
                   # arguments, we need our own spell checker class that doesn't take key
                   # words. Even though this code wouldn't be hit because of the check
@@ -102,9 +102,14 @@ class Bundler::Thor
   end
 
   if Correctable
-    DidYouMean::SPELL_CHECKERS.merge!(
-      'Bundler::Thor::UndefinedCommandError' => UndefinedCommandError::SpellChecker,
-      'Bundler::Thor::UnknownArgumentError' => UnknownArgumentError::SpellChecker
-    )
+    if DidYouMean.respond_to?(:correct_error)
+      DidYouMean.correct_error(Bundler::Thor::UndefinedCommandError, UndefinedCommandError::SpellChecker)
+      DidYouMean.correct_error(Bundler::Thor::UnknownArgumentError, UnknownArgumentError::SpellChecker)
+    else
+      DidYouMean::SPELL_CHECKERS.merge!(
+        'Bundler::Thor::UndefinedCommandError' => UndefinedCommandError::SpellChecker,
+        'Bundler::Thor::UnknownArgumentError' => UnknownArgumentError::SpellChecker
+      )
+    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/parser/arguments.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/parser/arguments.rb
@@ -30,7 +30,11 @@ class Bundler::Thor
 
       arguments.each do |argument|
         if !argument.default.nil?
-          @assigns[argument.human_name] = argument.default
+          begin
+            @assigns[argument.human_name] = argument.default.dup
+          rescue TypeError  # Compatibility shim for un-dup-able Fixnum in Ruby < 2.4
+            @assigns[argument.human_name] = argument.default
+          end
         elsif argument.required?
           @non_assigned_required << argument
         end
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/parser/options.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/parser/options.rb
@@ -45,6 +45,7 @@ class Bundler::Thor
       @switches = {}
       @extra = []
       @stopped_parsing_after_extra_index = nil
+      @is_treated_as_value = false
 
       options.each do |option|
         @switches[option.switch_name] = option
@@ -74,8 +75,19 @@ class Bundler::Thor
       end
     end
 
+    def shift
+      @is_treated_as_value = false
+      super
+    end
+
+    def unshift(arg, is_value: false)
+      @is_treated_as_value = is_value
+      super(arg)
+    end
+
     def parse(args) # rubocop:disable MethodLength
       @pile = args.dup
+      @is_treated_as_value = false
       @parsing_options = true
 
       while peek
@@ -88,7 +100,10 @@ class Bundler::Thor
             when SHORT_SQ_RE
               unshift($1.split("").map { |f| "-#{f}" })
               next
-            when EQ_RE, SHORT_NUM
+            when EQ_RE
+              unshift($2, is_value: true)
+              switch = $1
+            when SHORT_NUM
               unshift($2)
               switch = $1
             when LONG_RE, SHORT_RE
@@ -133,20 +148,22 @@ class Bundler::Thor
 
   protected
 
-  def assign_result!(option, result)
-    if option.repeatable && option.type == :hash
-      (@assigns[option.human_name] ||= {}).merge!(result)
-    elsif option.repeatable
-      (@assigns[option.human_name] ||= []) << result
-    else
-      @assigns[option.human_name] = result
+    def assign_result!(option, result)
+      if option.repeatable && option.type == :hash
+        (@assigns[option.human_name] ||= {}).merge!(result)
+      elsif option.repeatable
+        (@assigns[option.human_name] ||= []) << result
+      else
+        @assigns[option.human_name] = result
+      end
     end
-  end
+
     # Check if the current value in peek is a registered switch.
     #
     # Two booleans are returned.  The first is true if the current value
     # starts with a hyphen; the second is true if it is a registered switch.
     def current_is_switch?
+      return [false, false] if @is_treated_as_value
       case peek
       when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM
         [true, switch?($1)]
@@ -158,6 +175,7 @@ class Bundler::Thor
     end
 
     def current_is_switch_formatted?
+      return false if @is_treated_as_value
       case peek
       when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE
         true
@@ -167,6 +185,7 @@ class Bundler::Thor
     end
 
     def current_is_value?
+      return true if @is_treated_as_value
       peek && (!parsing_options? || super)
     end
 
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/shell.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/shell.rb
@@ -21,7 +21,7 @@ class Bundler::Thor
   end
 
   module Shell
-    SHELL_DELEGATED_METHODS = [:ask, :error, :set_color, :yes?, :no?, :say, :say_status, :print_in_columns, :print_table, :print_wrapped, :file_collision, :terminal_width]
+    SHELL_DELEGATED_METHODS = [:ask, :error, :set_color, :yes?, :no?, :say, :say_error, :say_status, :print_in_columns, :print_table, :print_wrapped, :file_collision, :terminal_width]
     attr_writer :shell
 
     autoload :Basic, File.expand_path("shell/basic", __dir__)
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/shell/basic.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/shell/basic.rb
@@ -94,6 +94,8 @@ class Bundler::Thor
       # say("I know you knew that.")
       #
       def say(message = "", color = nil, force_new_line = (message.to_s !~ /( |\t)\Z/))
+        return if quiet?
+
         buffer = prepare_message(message, *color)
         buffer << "\n" if force_new_line && !message.to_s.end_with?("\n")
 
@@ -101,6 +103,23 @@ class Bundler::Thor
         stdout.flush
       end
 
+      # Say (print) an error to the user. If the sentence ends with a whitespace
+      # or tab character, a new line is not appended (print + flush). Otherwise
+      # are passed straight to puts (behavior got from Highline).
+      #
+      # ==== Example
+      # say_error("error: something went wrong")
+      #
+      def say_error(message = "", color = nil, force_new_line = (message.to_s !~ /( |\t)\Z/))
+        return if quiet?
+
+        buffer = prepare_message(message, *color)
+        buffer << "\n" if force_new_line && !message.to_s.end_with?("\n")
+
+        stderr.print(buffer)
+        stderr.flush
+      end
+
       # Say a status with the given color and appends the message. Since this
       # method is used frequently by actions, it allows nil or false to be given
       # in log_status, avoiding the message from being shown. If a Symbol is
@@ -109,13 +128,14 @@ class Bundler::Thor
       def say_status(status, message, log_status = true)
         return if quiet? || log_status == false
         spaces = "  " * (padding + 1)
-        color  = log_status.is_a?(Symbol) ? log_status : :green
-
         status = status.to_s.rjust(12)
+        margin = " " * status.length + spaces
+
+        color  = log_status.is_a?(Symbol) ? log_status : :green
         status = set_color status, color, true if color
 
-        buffer = "#{status}#{spaces}#{message}"
-        buffer = "#{buffer}\n" unless buffer.end_with?("\n")
+        message = message.to_s.chomp.gsub(/(?<!\A)^/, margin)
+        buffer = "#{status}#{spaces}#{message}\n"
 
         stdout.print(buffer)
         stdout.flush
@@ -230,8 +250,9 @@ class Bundler::Thor
         paras = message.split("\n\n")
 
         paras.map! do |unwrapped|
-          counter = 0
-          unwrapped.split(" ").inject do |memo, word|
+          words = unwrapped.split(" ")
+          counter = words.first.length
+          words.inject do |memo, word|
             word = word.gsub(/\n\005/, "\n").gsub(/\005/, "\n")
             counter = 0 if word.include? "\n"
             if (counter + word.length + 1) < width
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/shell/color.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/shell/color.rb
@@ -97,7 +97,11 @@ class Bundler::Thor
     protected
 
       def can_display_colors?
-        stdout.tty? && !are_colors_disabled?
+        are_colors_supported? && !are_colors_disabled?
+      end
+
+      def are_colors_supported?
+        stdout.tty? && ENV["TERM"] != "dumb"
       end
 
       def are_colors_disabled?
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/util.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/util.rb
@@ -211,7 +211,7 @@ class Bundler::Thor
       #
       def globs_for(path)
         path = escape_globs(path)
-        ["#{path}/Thorfile", "#{path}/*.thor", "#{path}/tasks/*.thor", "#{path}/lib/tasks/*.thor"]
+        ["#{path}/Thorfile", "#{path}/*.thor", "#{path}/tasks/*.thor", "#{path}/lib/tasks/**/*.thor"]
       end
 
       # Return the path to the ruby interpreter taking into account multiple
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/thor/lib/thor/version.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/thor/lib/thor/version.rb
@@ -1,3 +1,3 @@
 class Bundler::Thor
-  VERSION = "1.0.0"
+  VERSION = "1.2.1"
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/tmpdir/lib/tmpdir.rb
@@ -0,0 +1,154 @@
+# frozen_string_literal: true
+#
+# tmpdir - retrieve temporary directory path
+#
+# $Id$
+#
+
+require_relative '../../fileutils/lib/fileutils'
+begin
+  require 'etc.so'
+rescue LoadError # rescue LoadError for miniruby
+end
+
+class Bundler::Dir < Dir
+
+  @systmpdir ||= defined?(Etc.systmpdir) ? Etc.systmpdir : '/tmp'
+
+  ##
+  # Returns the operating system's temporary file path.
+
+  def self.tmpdir
+    tmp = nil
+    ['TMPDIR', 'TMP', 'TEMP', ['system temporary path', @systmpdir], ['/tmp']*2, ['.']*2].each do |name, dir = ENV[name]|
+      next if !dir
+      dir = File.expand_path(dir)
+      stat = File.stat(dir) rescue next
+      case
+      when !stat.directory?
+        warn "#{name} is not a directory: #{dir}"
+      when !stat.writable?
+        warn "#{name} is not writable: #{dir}"
+      when stat.world_writable? && !stat.sticky?
+        warn "#{name} is world-writable: #{dir}"
+      else
+        tmp = dir
+        break
+      end
+    end
+    raise ArgumentError, "could not find a temporary directory" unless tmp
+    tmp
+  end
+
+  # Bundler::Dir.mktmpdir creates a temporary directory.
+  #
+  # The directory is created with 0700 permission.
+  # Application should not change the permission to make the temporary directory accessible from other users.
+  #
+  # The prefix and suffix of the name of the directory is specified by
+  # the optional first argument, <i>prefix_suffix</i>.
+  # - If it is not specified or nil, "d" is used as the prefix and no suffix is used.
+  # - If it is a string, it is used as the prefix and no suffix is used.
+  # - If it is an array, first element is used as the prefix and second element is used as a suffix.
+  #
+  #  Bundler::Dir.mktmpdir {|dir| dir is ".../d..." }
+  #  Bundler::Dir.mktmpdir("foo") {|dir| dir is ".../foo..." }
+  #  Bundler::Dir.mktmpdir(["foo", "bar"]) {|dir| dir is ".../foo...bar" }
+  #
+  # The directory is created under Bundler::Dir.tmpdir or
+  # the optional second argument <i>tmpdir</i> if non-nil value is given.
+  #
+  #  Bundler::Dir.mktmpdir {|dir| dir is "#{Bundler::Dir.tmpdir}/d..." }
+  #  Bundler::Dir.mktmpdir(nil, "/var/tmp") {|dir| dir is "/var/tmp/d..." }
+  #
+  # If a block is given,
+  # it is yielded with the path of the directory.
+  # The directory and its contents are removed
+  # using Bundler::FileUtils.remove_entry before Bundler::Dir.mktmpdir returns.
+  # The value of the block is returned.
+  #
+  #  Bundler::Dir.mktmpdir {|dir|
+  #    # use the directory...
+  #    open("#{dir}/foo", "w") { ... }
+  #  }
+  #
+  # If a block is not given,
+  # The path of the directory is returned.
+  # In this case, Bundler::Dir.mktmpdir doesn't remove the directory.
+  #
+  #  dir = Bundler::Dir.mktmpdir
+  #  begin
+  #    # use the directory...
+  #    open("#{dir}/foo", "w") { ... }
+  #  ensure
+  #    # remove the directory.
+  #    Bundler::FileUtils.remove_entry dir
+  #  end
+  #
+  def self.mktmpdir(prefix_suffix=nil, *rest, **options)
+    base = nil
+    path = Tmpname.create(prefix_suffix || "d", *rest, **options) {|p, _, _, d|
+      base = d
+      mkdir(p, 0700)
+    }
+    if block_given?
+      begin
+        yield path.dup
+      ensure
+        unless base
+          stat = File.stat(File.dirname(path))
+          if stat.world_writable? and !stat.sticky?
+            raise ArgumentError, "parent directory is world writable but not sticky"
+          end
+        end
+        Bundler::FileUtils.remove_entry path
+      end
+    else
+      path
+    end
+  end
+
+  module Tmpname # :nodoc:
+    module_function
+
+    def tmpdir
+      Bundler::Dir.tmpdir
+    end
+
+    UNUSABLE_CHARS = "^,-.0-9A-Z_a-z~"
+
+    class << (RANDOM = Random.new)
+      MAX = 36**6 # < 0x100000000
+      def next
+        rand(MAX).to_s(36)
+      end
+    end
+    private_constant :RANDOM
+
+    def create(basename, tmpdir=nil, max_try: nil, **opts)
+      origdir = tmpdir
+      tmpdir ||= tmpdir()
+      n = nil
+      prefix, suffix = basename
+      prefix = (String.try_convert(prefix) or
+                raise ArgumentError, "unexpected prefix: #{prefix.inspect}")
+      prefix = prefix.delete(UNUSABLE_CHARS)
+      suffix &&= (String.try_convert(suffix) or
+                  raise ArgumentError, "unexpected suffix: #{suffix.inspect}")
+      suffix &&= suffix.delete(UNUSABLE_CHARS)
+      begin
+        t = Time.now.strftime("%Y%m%d")
+        path = "#{prefix}#{t}-#{$$}-#{RANDOM.next}"\
+               "#{n ? %[-#{n}] : ''}#{suffix||''}"
+        path = File.join(tmpdir, path)
+        yield(path, n, opts, origdir)
+      rescue Errno::EEXIST
+        n ||= 0
+        n += 1
+        retry if !max_try or n < max_try
+        raise "cannot generate temporary name using `#{basename}' under `#{tmpdir}'"
+      end
+      path
+    end
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/tsort/LICENSE.txt
@@ -0,0 +1,22 @@
+Copyright (C) 1993-2013 Yukihiro Matsumoto. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/tsort/lib/tsort.rb
@@ -0,0 +1,452 @@
+# frozen_string_literal: true
+
+#--
+# tsort.rb - provides a module for topological sorting and strongly connected components.
+#++
+#
+
+#
+# Bundler::TSort implements topological sorting using Tarjan's algorithm for
+# strongly connected components.
+#
+# Bundler::TSort is designed to be able to be used with any object which can be
+# interpreted as a directed graph.
+#
+# Bundler::TSort requires two methods to interpret an object as a graph,
+# tsort_each_node and tsort_each_child.
+#
+# * tsort_each_node is used to iterate for all nodes over a graph.
+# * tsort_each_child is used to iterate for child nodes of a given node.
+#
+# The equality of nodes are defined by eql? and hash since
+# Bundler::TSort uses Hash internally.
+#
+# == A Simple Example
+#
+# The following example demonstrates how to mix the Bundler::TSort module into an
+# existing class (in this case, Hash). Here, we're treating each key in
+# the hash as a node in the graph, and so we simply alias the required
+# #tsort_each_node method to Hash's #each_key method. For each key in the
+# hash, the associated value is an array of the node's child nodes. This
+# choice in turn leads to our implementation of the required #tsort_each_child
+# method, which fetches the array of child nodes and then iterates over that
+# array using the user-supplied block.
+#
+#   require 'bundler/vendor/tsort/lib/tsort'
+#
+#   class Hash
+#     include Bundler::TSort
+#     alias tsort_each_node each_key
+#     def tsort_each_child(node, &block)
+#       fetch(node).each(&block)
+#     end
+#   end
+#
+#   {1=>[2, 3], 2=>[3], 3=>[], 4=>[]}.tsort
+#   #=> [3, 2, 1, 4]
+#
+#   {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}.strongly_connected_components
+#   #=> [[4], [2, 3], [1]]
+#
+# == A More Realistic Example
+#
+# A very simple `make' like tool can be implemented as follows:
+#
+#   require 'bundler/vendor/tsort/lib/tsort'
+#
+#   class Make
+#     def initialize
+#       @dep = {}
+#       @dep.default = []
+#     end
+#
+#     def rule(outputs, inputs=[], &block)
+#       triple = [outputs, inputs, block]
+#       outputs.each {|f| @dep[f] = [triple]}
+#       @dep[triple] = inputs
+#     end
+#
+#     def build(target)
+#       each_strongly_connected_component_from(target) {|ns|
+#         if ns.length != 1
+#           fs = ns.delete_if {|n| Array === n}
+#           raise Bundler::TSort::Cyclic.new("cyclic dependencies: #{fs.join ', '}")
+#         end
+#         n = ns.first
+#         if Array === n
+#           outputs, inputs, block = n
+#           inputs_time = inputs.map {|f| File.mtime f}.max
+#           begin
+#             outputs_time = outputs.map {|f| File.mtime f}.min
+#           rescue Errno::ENOENT
+#             outputs_time = nil
+#           end
+#           if outputs_time == nil ||
+#              inputs_time != nil && outputs_time <= inputs_time
+#             sleep 1 if inputs_time != nil && inputs_time.to_i == Time.now.to_i
+#             block.call
+#           end
+#         end
+#       }
+#     end
+#
+#     def tsort_each_child(node, &block)
+#       @dep[node].each(&block)
+#     end
+#     include Bundler::TSort
+#   end
+#
+#   def command(arg)
+#     print arg, "\n"
+#     system arg
+#   end
+#
+#   m = Make.new
+#   m.rule(%w[t1]) { command 'date > t1' }
+#   m.rule(%w[t2]) { command 'date > t2' }
+#   m.rule(%w[t3]) { command 'date > t3' }
+#   m.rule(%w[t4], %w[t1 t3]) { command 'cat t1 t3 > t4' }
+#   m.rule(%w[t5], %w[t4 t2]) { command 'cat t4 t2 > t5' }
+#   m.build('t5')
+#
+# == Bugs
+#
+# * 'tsort.rb' is wrong name because this library uses
+#   Tarjan's algorithm for strongly connected components.
+#   Although 'strongly_connected_components.rb' is correct but too long.
+#
+# == References
+#
+# R. E. Tarjan, "Depth First Search and Linear Graph Algorithms",
+# <em>SIAM Journal on Computing</em>, Vol. 1, No. 2, pp. 146-160, June 1972.
+#
+
+module Bundler::TSort
+  class Cyclic < StandardError
+  end
+
+  # Returns a topologically sorted array of nodes.
+  # The array is sorted from children to parents, i.e.
+  # the first element has no child and the last node has no parent.
+  #
+  # If there is a cycle, Bundler::TSort::Cyclic is raised.
+  #
+  #   class G
+  #     include Bundler::TSort
+  #     def initialize(g)
+  #       @g = g
+  #     end
+  #     def tsort_each_child(n, &b) @g[n].each(&b) end
+  #     def tsort_each_node(&b) @g.each_key(&b) end
+  #   end
+  #
+  #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+  #   p graph.tsort #=> [4, 2, 3, 1]
+  #
+  #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+  #   p graph.tsort # raises Bundler::TSort::Cyclic
+  #
+  def tsort
+    each_node = method(:tsort_each_node)
+    each_child = method(:tsort_each_child)
+    Bundler::TSort.tsort(each_node, each_child)
+  end
+
+  # Returns a topologically sorted array of nodes.
+  # The array is sorted from children to parents, i.e.
+  # the first element has no child and the last node has no parent.
+  #
+  # The graph is represented by _each_node_ and _each_child_.
+  # _each_node_ should have +call+ method which yields for each node in the graph.
+  # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+  #
+  # If there is a cycle, Bundler::TSort::Cyclic is raised.
+  #
+  #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+  #   each_node = lambda {|&b| g.each_key(&b) }
+  #   each_child = lambda {|n, &b| g[n].each(&b) }
+  #   p Bundler::TSort.tsort(each_node, each_child) #=> [4, 2, 3, 1]
+  #
+  #   g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+  #   each_node = lambda {|&b| g.each_key(&b) }
+  #   each_child = lambda {|n, &b| g[n].each(&b) }
+  #   p Bundler::TSort.tsort(each_node, each_child) # raises Bundler::TSort::Cyclic
+  #
+  def self.tsort(each_node, each_child)
+    tsort_each(each_node, each_child).to_a
+  end
+
+  # The iterator version of the #tsort method.
+  # <tt><em>obj</em>.tsort_each</tt> is similar to <tt><em>obj</em>.tsort.each</tt>, but
+  # modification of _obj_ during the iteration may lead to unexpected results.
+  #
+  # #tsort_each returns +nil+.
+  # If there is a cycle, Bundler::TSort::Cyclic is raised.
+  #
+  #   class G
+  #     include Bundler::TSort
+  #     def initialize(g)
+  #       @g = g
+  #     end
+  #     def tsort_each_child(n, &b) @g[n].each(&b) end
+  #     def tsort_each_node(&b) @g.each_key(&b) end
+  #   end
+  #
+  #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+  #   graph.tsort_each {|n| p n }
+  #   #=> 4
+  #   #   2
+  #   #   3
+  #   #   1
+  #
+  def tsort_each(&block) # :yields: node
+    each_node = method(:tsort_each_node)
+    each_child = method(:tsort_each_child)
+    Bundler::TSort.tsort_each(each_node, each_child, &block)
+  end
+
+  # The iterator version of the Bundler::TSort.tsort method.
+  #
+  # The graph is represented by _each_node_ and _each_child_.
+  # _each_node_ should have +call+ method which yields for each node in the graph.
+  # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+  #
+  #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+  #   each_node = lambda {|&b| g.each_key(&b) }
+  #   each_child = lambda {|n, &b| g[n].each(&b) }
+  #   Bundler::TSort.tsort_each(each_node, each_child) {|n| p n }
+  #   #=> 4
+  #   #   2
+  #   #   3
+  #   #   1
+  #
+  def self.tsort_each(each_node, each_child) # :yields: node
+    return to_enum(__method__, each_node, each_child) unless block_given?
+
+    each_strongly_connected_component(each_node, each_child) {|component|
+      if component.size == 1
+        yield component.first
+      else
+        raise Cyclic.new("topological sort failed: #{component.inspect}")
+      end
+    }
+  end
+
+  # Returns strongly connected components as an array of arrays of nodes.
+  # The array is sorted from children to parents.
+  # Each elements of the array represents a strongly connected component.
+  #
+  #   class G
+  #     include Bundler::TSort
+  #     def initialize(g)
+  #       @g = g
+  #     end
+  #     def tsort_each_child(n, &b) @g[n].each(&b) end
+  #     def tsort_each_node(&b) @g.each_key(&b) end
+  #   end
+  #
+  #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+  #   p graph.strongly_connected_components #=> [[4], [2], [3], [1]]
+  #
+  #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+  #   p graph.strongly_connected_components #=> [[4], [2, 3], [1]]
+  #
+  def strongly_connected_components
+    each_node = method(:tsort_each_node)
+    each_child = method(:tsort_each_child)
+    Bundler::TSort.strongly_connected_components(each_node, each_child)
+  end
+
+  # Returns strongly connected components as an array of arrays of nodes.
+  # The array is sorted from children to parents.
+  # Each elements of the array represents a strongly connected component.
+  #
+  # The graph is represented by _each_node_ and _each_child_.
+  # _each_node_ should have +call+ method which yields for each node in the graph.
+  # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+  #
+  #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+  #   each_node = lambda {|&b| g.each_key(&b) }
+  #   each_child = lambda {|n, &b| g[n].each(&b) }
+  #   p Bundler::TSort.strongly_connected_components(each_node, each_child)
+  #   #=> [[4], [2], [3], [1]]
+  #
+  #   g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+  #   each_node = lambda {|&b| g.each_key(&b) }
+  #   each_child = lambda {|n, &b| g[n].each(&b) }
+  #   p Bundler::TSort.strongly_connected_components(each_node, each_child)
+  #   #=> [[4], [2, 3], [1]]
+  #
+  def self.strongly_connected_components(each_node, each_child)
+    each_strongly_connected_component(each_node, each_child).to_a
+  end
+
+  # The iterator version of the #strongly_connected_components method.
+  # <tt><em>obj</em>.each_strongly_connected_component</tt> is similar to
+  # <tt><em>obj</em>.strongly_connected_components.each</tt>, but
+  # modification of _obj_ during the iteration may lead to unexpected results.
+  #
+  # #each_strongly_connected_component returns +nil+.
+  #
+  #   class G
+  #     include Bundler::TSort
+  #     def initialize(g)
+  #       @g = g
+  #     end
+  #     def tsort_each_child(n, &b) @g[n].each(&b) end
+  #     def tsort_each_node(&b) @g.each_key(&b) end
+  #   end
+  #
+  #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+  #   graph.each_strongly_connected_component {|scc| p scc }
+  #   #=> [4]
+  #   #   [2]
+  #   #   [3]
+  #   #   [1]
+  #
+  #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+  #   graph.each_strongly_connected_component {|scc| p scc }
+  #   #=> [4]
+  #   #   [2, 3]
+  #   #   [1]
+  #
+  def each_strongly_connected_component(&block) # :yields: nodes
+    each_node = method(:tsort_each_node)
+    each_child = method(:tsort_each_child)
+    Bundler::TSort.each_strongly_connected_component(each_node, each_child, &block)
+  end
+
+  # The iterator version of the Bundler::TSort.strongly_connected_components method.
+  #
+  # The graph is represented by _each_node_ and _each_child_.
+  # _each_node_ should have +call+ method which yields for each node in the graph.
+  # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+  #
+  #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+  #   each_node = lambda {|&b| g.each_key(&b) }
+  #   each_child = lambda {|n, &b| g[n].each(&b) }
+  #   Bundler::TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
+  #   #=> [4]
+  #   #   [2]
+  #   #   [3]
+  #   #   [1]
+  #
+  #   g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+  #   each_node = lambda {|&b| g.each_key(&b) }
+  #   each_child = lambda {|n, &b| g[n].each(&b) }
+  #   Bundler::TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
+  #   #=> [4]
+  #   #   [2, 3]
+  #   #   [1]
+  #
+  def self.each_strongly_connected_component(each_node, each_child) # :yields: nodes
+    return to_enum(__method__, each_node, each_child) unless block_given?
+
+    id_map = {}
+    stack = []
+    each_node.call {|node|
+      unless id_map.include? node
+        each_strongly_connected_component_from(node, each_child, id_map, stack) {|c|
+          yield c
+        }
+      end
+    }
+    nil
+  end
+
+  # Iterates over strongly connected component in the subgraph reachable from
+  # _node_.
+  #
+  # Return value is unspecified.
+  #
+  # #each_strongly_connected_component_from doesn't call #tsort_each_node.
+  #
+  #   class G
+  #     include Bundler::TSort
+  #     def initialize(g)
+  #       @g = g
+  #     end
+  #     def tsort_each_child(n, &b) @g[n].each(&b) end
+  #     def tsort_each_node(&b) @g.each_key(&b) end
+  #   end
+  #
+  #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+  #   graph.each_strongly_connected_component_from(2) {|scc| p scc }
+  #   #=> [4]
+  #   #   [2]
+  #
+  #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+  #   graph.each_strongly_connected_component_from(2) {|scc| p scc }
+  #   #=> [4]
+  #   #   [2, 3]
+  #
+  def each_strongly_connected_component_from(node, id_map={}, stack=[], &block) # :yields: nodes
+    Bundler::TSort.each_strongly_connected_component_from(node, method(:tsort_each_child), id_map, stack, &block)
+  end
+
+  # Iterates over strongly connected components in a graph.
+  # The graph is represented by _node_ and _each_child_.
+  #
+  # _node_ is the first node.
+  # _each_child_ should have +call+ method which takes a node argument
+  # and yields for each child node.
+  #
+  # Return value is unspecified.
+  #
+  # #Bundler::TSort.each_strongly_connected_component_from is a class method and
+  # it doesn't need a class to represent a graph which includes Bundler::TSort.
+  #
+  #   graph = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+  #   each_child = lambda {|n, &b| graph[n].each(&b) }
+  #   Bundler::TSort.each_strongly_connected_component_from(1, each_child) {|scc|
+  #     p scc
+  #   }
+  #   #=> [4]
+  #   #   [2, 3]
+  #   #   [1]
+  #
+  def self.each_strongly_connected_component_from(node, each_child, id_map={}, stack=[]) # :yields: nodes
+    return to_enum(__method__, node, each_child, id_map, stack) unless block_given?
+
+    minimum_id = node_id = id_map[node] = id_map.size
+    stack_length = stack.length
+    stack << node
+
+    each_child.call(node) {|child|
+      if id_map.include? child
+        child_id = id_map[child]
+        minimum_id = child_id if child_id && child_id < minimum_id
+      else
+        sub_minimum_id =
+          each_strongly_connected_component_from(child, each_child, id_map, stack) {|c|
+            yield c
+          }
+        minimum_id = sub_minimum_id if sub_minimum_id < minimum_id
+      end
+    }
+
+    if node_id == minimum_id
+      component = stack.slice!(stack_length .. -1)
+      component.each {|n| id_map[n] = nil}
+      yield component
+    end
+
+    minimum_id
+  end
+
+  # Should be implemented by a extended class.
+  #
+  # #tsort_each_node is used to iterate for all nodes over a graph.
+  #
+  def tsort_each_node # :yields: node
+    raise NotImplementedError.new
+  end
+
+  # Should be implemented by a extended class.
+  #
+  # #tsort_each_child is used to iterate for child nodes of _node_.
+  #
+  def tsort_each_child(node) # :yields: child
+    raise NotImplementedError.new
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/LICENSE.txt
@@ -0,0 +1,22 @@
+Copyright (C) 1993-2013 Yukihiro Matsumoto. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/uri/lib/uri.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri.rb
@@ -86,7 +86,6 @@
 # License::
 #  Copyright (c) 2001 akira yamada <akira@ruby-lang.org>
 #  You can redistribute it and/or modify it under the same term as Ruby.
-# Revision:: $Id$
 #
 
 module Bundler::URI
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/uri/lib/uri/common.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/common.rb
@@ -3,7 +3,6 @@
 # = uri/common.rb
 #
 # Author:: Akira Yamada <akira@ruby-lang.org>
-# Revision:: $Id$
 # License::
 #   You can redistribute it and/or modify it under the same term as Ruby.
 #
@@ -61,82 +60,6 @@ module Bundler::URI
     module_function :make_components_hash
   end
 
-  # Module for escaping unsafe characters with codes.
-  module Escape
-    #
-    # == Synopsis
-    #
-    #   Bundler::URI.escape(str [, unsafe])
-    #
-    # == Args
-    #
-    # +str+::
-    #   String to replaces in.
-    # +unsafe+::
-    #   Regexp that matches all symbols that must be replaced with codes.
-    #   By default uses <tt>UNSAFE</tt>.
-    #   When this argument is a String, it represents a character set.
-    #
-    # == Description
-    #
-    # Escapes the string, replacing all unsafe characters with codes.
-    #
-    # This method is obsolete and should not be used. Instead, use
-    # CGI.escape, Bundler::URI.encode_www_form or Bundler::URI.encode_www_form_component
-    # depending on your specific use case.
-    #
-    # == Usage
-    #
-    #   require 'bundler/vendor/uri/lib/uri'
-    #
-    #   enc_uri = Bundler::URI.escape("http://example.com/?a=\11\15")
-    #   # => "http://example.com/?a=%09%0D"
-    #
-    #   Bundler::URI.unescape(enc_uri)
-    #   # => "http://example.com/?a=\t\r"
-    #
-    #   Bundler::URI.escape("@?@!", "!?")
-    #   # => "@%3F@%21"
-    #
-    def escape(*arg)
-      warn "Bundler::URI.escape is obsolete", uplevel: 1
-      DEFAULT_PARSER.escape(*arg)
-    end
-    alias encode escape
-    #
-    # == Synopsis
-    #
-    #   Bundler::URI.unescape(str)
-    #
-    # == Args
-    #
-    # +str+::
-    #   String to unescape.
-    #
-    # == Description
-    #
-    # This method is obsolete and should not be used. Instead, use
-    # CGI.unescape, Bundler::URI.decode_www_form or Bundler::URI.decode_www_form_component
-    # depending on your specific use case.
-    #
-    # == Usage
-    #
-    #   require 'bundler/vendor/uri/lib/uri'
-    #
-    #   enc_uri = Bundler::URI.escape("http://example.com/?a=\11\15")
-    #   # => "http://example.com/?a=%09%0D"
-    #
-    #   Bundler::URI.unescape(enc_uri)
-    #   # => "http://example.com/?a=\t\r"
-    #
-    def unescape(*arg)
-      warn "Bundler::URI.unescape is obsolete", uplevel: 1
-      DEFAULT_PARSER.unescape(*arg)
-    end
-    alias decode unescape
-  end # module Escape
-
-  extend Escape
   include REGEXP
 
   @@schemes = {}
@@ -146,6 +69,20 @@ module Bundler::URI
   end
 
   #
+  # Construct a Bundler::URI instance, using the scheme to detect the appropriate class
+  # from +Bundler::URI.scheme_list+.
+  #
+  def self.for(scheme, *arguments, default: Generic)
+    if scheme
+      uri_class = @@schemes[scheme.upcase] || default
+    else
+      uri_class = default
+    end
+
+    return uri_class.new(scheme, *arguments)
+  end
+
+  #
   # Base class for all Bundler::URI exceptions.
   #
   class Error < StandardError; end
@@ -315,7 +252,7 @@ module Bundler::URI
   #
   # Returns a Regexp object which matches to Bundler::URI-like strings.
   # The Regexp object returned by this method includes arbitrary
-  # number of capture group (parentheses).  Never rely on it's number.
+  # number of capture group (parentheses).  Never rely on its number.
   #
   # == Usage
   #
@@ -362,7 +299,7 @@ module Bundler::URI
   # If +enc+ is given, convert +str+ to the encoding before percent encoding.
   #
   # This is an implementation of
-  # http://www.w3.org/TR/2013/CR-html5-20130806/forms.html#url-encoded-form-data.
+  # https://www.w3.org/TR/2013/CR-html5-20130806/forms.html#url-encoded-form-data.
   #
   # See Bundler::URI.decode_www_form_component, Bundler::URI.encode_www_form.
   def self.encode_www_form_component(str, enc=nil)
@@ -403,7 +340,7 @@ module Bundler::URI
   # This method doesn't handle files.  When you send a file, use
   # multipart/form-data.
   #
-  # This refers http://url.spec.whatwg.org/#concept-urlencoded-serializer
+  # This refers https://url.spec.whatwg.org/#concept-urlencoded-serializer
   #
   #    Bundler::URI.encode_www_form([["q", "ruby"], ["lang", "en"]])
   #    #=> "q=ruby&lang=en"
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/uri/lib/uri/ftp.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/ftp.rb
@@ -3,7 +3,6 @@
 #
 # Author:: Akira Yamada <akira@ruby-lang.org>
 # License:: You can redistribute it and/or modify it under the same term as Ruby.
-# Revision:: $Id$
 #
 # See Bundler::URI for general documentation
 #
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/uri/lib/uri/generic.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/generic.rb
@@ -4,7 +4,6 @@
 #
 # Author:: Akira Yamada <akira@ruby-lang.org>
 # License:: You can redistribute it and/or modify it under the same term as Ruby.
-# Revision:: $Id$
 #
 # See Bundler::URI for general documentation
 #
@@ -1098,7 +1097,7 @@ module Bundler::URI
     #   # => "http://my.example.com/main.rbx?page=1"
     #
     def merge(oth)
-      rel = parser.send(:convert_to_uri, oth)
+      rel = parser.__send__(:convert_to_uri, oth)
 
       if rel.absolute?
         #raise BadURIError, "both Bundler::URI are absolute" if absolute?
@@ -1183,7 +1182,7 @@ module Bundler::URI
 
     # :stopdoc:
     def route_from0(oth)
-      oth = parser.send(:convert_to_uri, oth)
+      oth = parser.__send__(:convert_to_uri, oth)
       if self.relative?
         raise BadURIError,
           "relative Bundler::URI: #{self}"
@@ -1291,7 +1290,7 @@ module Bundler::URI
     #   #=> #<Bundler::URI::Generic /main.rbx?page=1>
     #
     def route_to(oth)
-      parser.send(:convert_to_uri, oth).route_from(self)
+      parser.__send__(:convert_to_uri, oth).route_from(self)
     end
 
     #
@@ -1405,7 +1404,7 @@ module Bundler::URI
     # Returns an Array of the components defined from the COMPONENT Array.
     def component_ary
       component.collect do |x|
-        self.send(x)
+        self.__send__(x)
       end
     end
     protected :component_ary
@@ -1430,7 +1429,7 @@ module Bundler::URI
     def select(*components)
       components.collect do |c|
         if component.include?(c)
-          self.send(c)
+          self.__send__(c)
         else
           raise ArgumentError,
             "expected of components of #{self.class} (#{self.class.component.join(', ')})"
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/uri/lib/uri/http.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/http.rb
@@ -3,7 +3,6 @@
 #
 # Author:: Akira Yamada <akira@ruby-lang.org>
 # License:: You can redistribute it and/or modify it under the same term as Ruby.
-# Revision:: $Id$
 #
 # See Bundler::URI for general documentation
 #
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/uri/lib/uri/https.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/https.rb
@@ -3,7 +3,6 @@
 #
 # Author:: Akira Yamada <akira@ruby-lang.org>
 # License:: You can redistribute it and/or modify it under the same term as Ruby.
-# Revision:: $Id$
 #
 # See Bundler::URI for general documentation
 #
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/uri/lib/uri/ldap.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/ldap.rb
@@ -7,7 +7,6 @@
 # License::
 #   Bundler::URI::LDAP is copyrighted free software by Takaaki Tateishi and Akira Yamada.
 #   You can redistribute it and/or modify it under the same term as Ruby.
-# Revision:: $Id$
 #
 # See Bundler::URI for general documentation
 #
@@ -119,6 +118,7 @@ module Bundler::URI
 
     # Private method to cleanup +dn+ from using the +path+ component attribute.
     def parse_dn
+      raise InvalidURIError, 'bad LDAP URL' unless @path
       @dn = @path[1..-1]
     end
     private :parse_dn
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/uri/lib/uri/mailto.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/mailto.rb
@@ -3,7 +3,6 @@
 #
 # Author:: Akira Yamada <akira@ruby-lang.org>
 # License:: You can redistribute it and/or modify it under the same term as Ruby.
-# Revision:: $Id$
 #
 # See Bundler::URI for general documentation
 #
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/uri/lib/uri/rfc2396_parser.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/rfc2396_parser.rb
@@ -3,7 +3,6 @@
 # = uri/common.rb
 #
 # Author:: Akira Yamada <akira@ruby-lang.org>
-# Revision:: $Id$
 # License::
 #   You can redistribute it and/or modify it under the same term as Ruby.
 #
@@ -208,21 +207,9 @@ module Bundler::URI
     #   #=> #<Bundler::URI::LDAP ldap://ldap.example.com/dc=example?user=john>
     #
     def parse(uri)
-      scheme, userinfo, host, port,
-        registry, path, opaque, query, fragment = self.split(uri)
-
-      if scheme && Bundler::URI.scheme_list.include?(scheme.upcase)
-        Bundler::URI.scheme_list[scheme.upcase].new(scheme, userinfo, host, port,
-                                           registry, path, opaque, query,
-                                           fragment, self)
-      else
-        Generic.new(scheme, userinfo, host, port,
-                    registry, path, opaque, query,
-                    fragment, self)
-      end
+      Bundler::URI.for(*self.split(uri), self)
     end
 
-
     #
     # == Args
     #
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/uri/lib/uri/rfc3986_parser.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/rfc3986_parser.rb
@@ -69,18 +69,7 @@ module Bundler::URI
     end
 
     def parse(uri) # :nodoc:
-      scheme, userinfo, host, port,
-        registry, path, opaque, query, fragment = self.split(uri)
-      scheme_list = Bundler::URI.scheme_list
-      if scheme && scheme_list.include?(uc = scheme.upcase)
-        scheme_list[uc].new(scheme, userinfo, host, port,
-                            registry, path, opaque, query,
-                            fragment, self)
-      else
-        Generic.new(scheme, userinfo, host, port,
-                    registry, path, opaque, query,
-                    fragment, self)
-      end
+      Bundler::URI.for(*self.split(uri), self)
     end
 
 
--- ruby2.7-2.7.6.orig/lib/bundler/vendor/uri/lib/uri/version.rb
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/version.rb
@@ -1,6 +1,6 @@
 module Bundler::URI
   # :stopdoc:
-  VERSION_CODE = '001000'.freeze
+  VERSION_CODE = '001001'.freeze
   VERSION = VERSION_CODE.scan(/../).collect{|n| n.to_i}.join('.').freeze
   # :startdoc:
 end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/ws.rb
@@ -0,0 +1,84 @@
+# frozen_string_literal: false
+# = uri/ws.rb
+#
+# Author:: Matt Muller <mamuller@amazon.com>
+# License:: You can redistribute it and/or modify it under the same term as Ruby.
+#
+# See Bundler::URI for general documentation
+#
+
+require_relative 'generic'
+
+module Bundler::URI
+
+  #
+  # The syntax of WS URIs is defined in RFC6455 section 3.
+  #
+  # Note that the Ruby Bundler::URI library allows WS URLs containing usernames and
+  # passwords. This is not legal as per the RFC, but used to be
+  # supported in Internet Explorer 5 and 6, before the MS04-004 security
+  # update. See <URL:http://support.microsoft.com/kb/834489>.
+  #
+  class WS < Generic
+    # A Default port of 80 for Bundler::URI::WS.
+    DEFAULT_PORT = 80
+
+    # An Array of the available components for Bundler::URI::WS.
+    COMPONENT = %i[
+      scheme
+      userinfo host port
+      path
+      query
+    ].freeze
+
+    #
+    # == Description
+    #
+    # Creates a new Bundler::URI::WS object from components, with syntax checking.
+    #
+    # The components accepted are userinfo, host, port, path, and query.
+    #
+    # The components should be provided either as an Array, or as a Hash
+    # with keys formed by preceding the component names with a colon.
+    #
+    # If an Array is used, the components must be passed in the
+    # order <code>[userinfo, host, port, path, query]</code>.
+    #
+    # Example:
+    #
+    #     uri = Bundler::URI::WS.build(host: 'www.example.com', path: '/foo/bar')
+    #
+    #     uri = Bundler::URI::WS.build([nil, "www.example.com", nil, "/path", "query"])
+    #
+    # Currently, if passed userinfo components this method generates
+    # invalid WS URIs as per RFC 1738.
+    #
+    def self.build(args)
+      tmp = Util.make_components_hash(self, args)
+      super(tmp)
+    end
+
+    #
+    # == Description
+    #
+    # Returns the full path for a WS Bundler::URI, as required by Net::HTTP::Get.
+    #
+    # If the Bundler::URI contains a query, the full path is Bundler::URI#path + '?' + Bundler::URI#query.
+    # Otherwise, the path is simply Bundler::URI#path.
+    #
+    # Example:
+    #
+    #     uri = Bundler::URI::WS.build(path: '/foo/bar', query: 'test=true')
+    #     uri.request_uri #  => "/foo/bar?test=true"
+    #
+    def request_uri
+      return unless @path
+
+      url = @query ? "#@path?#@query" : @path.dup
+      url.start_with?(?/.freeze) ? url : ?/ + url
+    end
+  end
+
+  @@schemes['WS'] = WS
+
+end
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendor/uri/lib/uri/wss.rb
@@ -0,0 +1,22 @@
+# frozen_string_literal: false
+# = uri/wss.rb
+#
+# Author:: Matt Muller <mamuller@amazon.com>
+# License:: You can redistribute it and/or modify it under the same term as Ruby.
+#
+# See Bundler::URI for general documentation
+#
+
+require_relative 'ws'
+
+module Bundler::URI
+
+  # The default port for WSS URIs is 443, and the scheme is 'wss:' rather
+  # than 'ws:'. Other than that, WSS URIs are identical to WS URIs;
+  # see Bundler::URI::WS.
+  class WSS < WS
+    # A Default port of 443 for Bundler::URI::WSS
+    DEFAULT_PORT = 443
+  end
+  @@schemes['WSS'] = WSS
+end
--- ruby2.7-2.7.6.orig/lib/bundler/vendored_persistent.rb
+++ ruby2.7-2.7.6/lib/bundler/vendored_persistent.rb
@@ -1,12 +1,5 @@
 # frozen_string_literal: true
 
-# We forcibly require OpenSSL, because net/http/persistent will only autoload
-# it. On some Rubies, autoload fails but explicit require succeeds.
-begin
-  require "openssl"
-rescue LoadError
-  # some Ruby builds don't have OpenSSL
-end
 module Bundler
   module Persistent
     module Net
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendored_tmpdir.rb
@@ -0,0 +1,4 @@
+# frozen_string_literal: true
+
+module Bundler; end
+require_relative "vendor/tmpdir/lib/tmpdir"
--- /dev/null
+++ ruby2.7-2.7.6/lib/bundler/vendored_tsort.rb
@@ -0,0 +1,4 @@
+# frozen_string_literal: true
+
+module Bundler; end
+require_relative "vendor/tsort/lib/tsort"
--- ruby2.7-2.7.6.orig/lib/bundler/version.rb
+++ ruby2.7-2.7.6/lib/bundler/version.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: false
 
 module Bundler
-  VERSION = "2.1.4".freeze
+  VERSION = "2.3.22".freeze
 
   def self.bundler_major_version
     @bundler_major_version ||= VERSION.split(".").first.to_i
--- ruby2.7-2.7.6.orig/lib/bundler/worker.rb
+++ ruby2.7-2.7.6/lib/bundler/worker.rb
@@ -21,12 +21,12 @@ module Bundler
     # @param func [Proc] job to run in inside the worker pool
     def initialize(size, name, func)
       @name = name
-      @request_queue = Queue.new
-      @response_queue = Queue.new
+      @request_queue = Thread::Queue.new
+      @response_queue = Thread::Queue.new
       @func = func
       @size = size
       @threads = nil
-      SharedHelpers.trap("INT") { abort_threads }
+      @previous_interrupt_handler = nil
     end
 
     # Enqueue a request to be executed in the worker pool
@@ -48,7 +48,7 @@ module Bundler
       stop_threads
     end
 
-  private
+    private
 
     def process_queue(i)
       loop do
@@ -68,13 +68,16 @@ module Bundler
     # so as worker threads after retrieving it, shut themselves down
     def stop_threads
       return unless @threads
+
       @threads.each { @request_queue.enq POISON }
       @threads.each(&:join)
+
+      remove_interrupt_handler
+
       @threads = nil
     end
 
     def abort_threads
-      return unless @threads
       Bundler.ui.debug("\n#{caller.join("\n")}")
       @threads.each(&:exit)
       exit 1
@@ -94,11 +97,23 @@ module Bundler
         end
       end.compact
 
+      add_interrupt_handler unless @threads.empty?
+
       return if creation_errors.empty?
 
       message = "Failed to create threads for the #{name} worker: #{creation_errors.map(&:to_s).uniq.join(", ")}"
       raise ThreadCreationError, message if @threads.empty?
       Bundler.ui.info message
     end
+
+    def add_interrupt_handler
+      @previous_interrupt_handler = trap("INT") { abort_threads }
+    end
+
+    def remove_interrupt_handler
+      return unless @previous_interrupt_handler
+
+      trap "INT", @previous_interrupt_handler
+    end
   end
 end
--- ruby2.7-2.7.6.orig/lib/bundler/yaml_serializer.rb
+++ ruby2.7-2.7.6/lib/bundler/yaml_serializer.rb
@@ -3,7 +3,7 @@
 module Bundler
   # A stub yaml serializer that can handle only hashes and strings (as of now).
   module YAMLSerializer
-  module_function
+    module_function
 
     def dump(hash)
       yaml = String.new("---")
--- ruby2.7-2.7.6.orig/libexec/bundle
+++ ruby2.7-2.7.6/libexec/bundle
@@ -15,14 +15,16 @@ else
   require "bundler"
 end
 
-# Check if an older version of bundler is installed
-$LOAD_PATH.each do |path|
-  next unless path =~ %r{/bundler-0\.(\d+)} && $1.to_i < 9
-  err = String.new
-  err << "Looks like you have a version of bundler that's older than 0.9.\n"
-  err << "Please remove your old versions.\n"
-  err << "An easy way to do this is by running `gem cleanup bundler`."
-  abort(err)
+# Workaround for non-activated bundler spec due to missing https://github.com/rubygems/rubygems/commit/4e306d7bcdee924b8d80ca9db6125aa59ee4e5a3
+gem "bundler", Bundler::VERSION if Gem.rubygems_version < Gem::Version.new("2.6.2")
+
+if Gem.rubygems_version < Gem::Version.new("3.2.3") && Gem.ruby_version < Gem::Version.new("2.6.a") && !ENV["BUNDLER_NO_OLD_RUBYGEMS_WARNING"]
+  Bundler.ui.warn \
+    "Your RubyGems version (#{Gem::VERSION}) has a bug that prevents " \
+    "`required_ruby_version` from working for Bundler. Any scripts that use " \
+    "`gem install bundler` will break as soon as Bundler drops support for " \
+    "your Ruby version. Please upgrade RubyGems to avoid future breakage " \
+    "and silence this warning by running `gem update --system 3.2.3`"
 end
 
 if File.exist?(base_path)
--- ruby2.7-2.7.6.orig/libexec/bundler
+++ ruby2.7-2.7.6/libexec/bundler
@@ -1,4 +1,4 @@
 #!/usr/bin/env ruby
 # frozen_string_literal: true
 
-load File.expand_path("../bundle", __FILE__)
+load File.expand_path("bundle", __dir__)
--- ruby2.7-2.7.6.orig/man/bundle-add.1
+++ /dev/null
@@ -1,66 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-ADD" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-add\fR \- Add gem to the Gemfile and run bundle install
-.
-.SH "SYNOPSIS"
-\fBbundle add\fR \fIGEM_NAME\fR [\-\-group=GROUP] [\-\-version=VERSION] [\-\-source=SOURCE] [\-\-git=GIT] [\-\-branch=BRANCH] [\-\-skip\-install] [\-\-strict] [\-\-optimistic]
-.
-.SH "DESCRIPTION"
-Adds the named gem to the Gemfile and run \fBbundle install\fR\. \fBbundle install\fR can be avoided by using the flag \fB\-\-skip\-install\fR\.
-.
-.P
-Example:
-.
-.P
-bundle add rails
-.
-.P
-bundle add rails \-\-version "< 3\.0, > 1\.1"
-.
-.P
-bundle add rails \-\-version "~> 5\.0\.0" \-\-source "https://gems\.example\.com" \-\-group "development"
-.
-.P
-bundle add rails \-\-skip\-install
-.
-.P
-bundle add rails \-\-group "development, test"
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-version\fR, \fB\-v\fR
-Specify version requirements(s) for the added gem\.
-.
-.TP
-\fB\-\-group\fR, \fB\-g\fR
-Specify the group(s) for the added gem\. Multiple groups should be separated by commas\.
-.
-.TP
-\fB\-\-source\fR, , \fB\-s\fR
-Specify the source for the added gem\.
-.
-.TP
-\fB\-\-git\fR
-Specify the git source for the added gem\.
-.
-.TP
-\fB\-\-branch\fR
-Specify the git branch for the added gem\.
-.
-.TP
-\fB\-\-skip\-install\fR
-Adds the gem to the Gemfile but does not install it\.
-.
-.TP
-\fB\-\-optimistic\fR
-Adds optimistic declaration of version
-.
-.TP
-\fB\-\-strict\fR
-Adds strict declaration of version
-
--- ruby2.7-2.7.6.orig/man/bundle-add.1.txt
+++ /dev/null
@@ -1,58 +0,0 @@
-BUNDLE-ADD(1)							 BUNDLE-ADD(1)
-
-
-
-NAME
-       bundle-add - Add gem to the Gemfile and run bundle install
-
-SYNOPSIS
-       bundle	  add	  GEM_NAME     [--group=GROUP]	   [--version=VERSION]
-       [--source=SOURCE]   [--git=GIT]	 [--branch=BRANCH]    [--skip-install]
-       [--strict] [--optimistic]
-
-DESCRIPTION
-       Adds  the  named  gem  to  the  Gemfile	and run bundle install. bundle
-       install can be avoided by using the flag --skip-install.
-
-       Example:
-
-       bundle add rails
-
-       bundle add rails --version "< 3.0, > 1.1"
-
-       bundle add rails  --version  "~>  5.0.0"  --source  "https://gems.exam-
-       ple.com" --group "development"
-
-       bundle add rails --skip-install
-
-       bundle add rails --group "development, test"
-
-OPTIONS
-       --version, -v
-	      Specify version requirements(s) for the added gem.
-
-       --group, -g
-	      Specify  the  group(s) for the added gem. Multiple groups should
-	      be separated by commas.
-
-       --source, , -s
-	      Specify the source for the added gem.
-
-       --git  Specify the git source for the added gem.
-
-       --branch
-	      Specify the git branch for the added gem.
-
-       --skip-install
-	      Adds the gem to the Gemfile but does not install it.
-
-       --optimistic
-	      Adds optimistic declaration of version
-
-       --strict
-	      Adds strict declaration of version
-
-
-
-
-				 January 2020			 BUNDLE-ADD(1)
--- ruby2.7-2.7.6.orig/man/bundle-add.ronn
+++ /dev/null
@@ -1,46 +0,0 @@
-bundle-add(1) -- Add gem to the Gemfile and run bundle install
-================================================================
-
-## SYNOPSIS
-
-`bundle add` <GEM_NAME> [--group=GROUP] [--version=VERSION] [--source=SOURCE] [--git=GIT] [--branch=BRANCH] [--skip-install] [--strict] [--optimistic]
-
-## DESCRIPTION
-Adds the named gem to the Gemfile and run `bundle install`. `bundle install` can be avoided by using the flag `--skip-install`.
-
-Example:
-
-bundle add rails
-
-bundle add rails --version "< 3.0, > 1.1"
-
-bundle add rails --version "~> 5.0.0" --source "https://gems.example.com" --group "development"
-
-bundle add rails --skip-install
-
-bundle add rails --group "development, test"
-
-## OPTIONS
-* `--version`, `-v`:
-  Specify version requirements(s) for the added gem.
-
-* `--group`, `-g`:
-  Specify the group(s) for the added gem. Multiple groups should be separated by commas.
-
-* `--source`, , `-s`:
-  Specify the source for the added gem.
-
-* `--git`:
-  Specify the git source for the added gem.
-
-* `--branch`:
-  Specify the git branch for the added gem.
-
-* `--skip-install`:
-  Adds the gem to the Gemfile but does not install it.
-
-* `--optimistic`:
-  Adds optimistic declaration of version
-
-* `--strict`:
-  Adds strict declaration of version
--- ruby2.7-2.7.6.orig/man/bundle-binstubs.1
+++ /dev/null
@@ -1,40 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-BINSTUBS" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-binstubs\fR \- Install the binstubs of the listed gems
-.
-.SH "SYNOPSIS"
-\fBbundle binstubs\fR \fIGEM_NAME\fR [\-\-force] [\-\-path PATH] [\-\-standalone]
-.
-.SH "DESCRIPTION"
-Binstubs are scripts that wrap around executables\. Bundler creates a small Ruby file (a binstub) that loads Bundler, runs the command, and puts it into \fBbin/\fR\. Binstubs are a shortcut\-or alternative\- to always using \fBbundle exec\fR\. This gives you a file that can be run directly, and one that will always run the correct gem version used by the application\.
-.
-.P
-For example, if you run \fBbundle binstubs rspec\-core\fR, Bundler will create the file \fBbin/rspec\fR\. That file will contain enough code to load Bundler, tell it to load the bundled gems, and then run rspec\.
-.
-.P
-This command generates binstubs for executables in \fBGEM_NAME\fR\. Binstubs are put into \fBbin\fR, or the \fB\-\-path\fR directory if one has been set\. Calling binstubs with [GEM [GEM]] will create binstubs for all given gems\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-force\fR
-Overwrite existing binstubs if they exist\.
-.
-.TP
-\fB\-\-path\fR
-The location to install the specified binstubs to\. This defaults to \fBbin\fR\.
-.
-.TP
-\fB\-\-standalone\fR
-Makes binstubs that can work without depending on Rubygems or Bundler at runtime\.
-.
-.TP
-\fB\-\-shebang\fR
-Specify a different shebang executable name than the default (default \'ruby\')
-.
-.SH "BUNDLE INSTALL \-\-BINSTUBS"
-To create binstubs for all the gems in the bundle you can use the \fB\-\-binstubs\fR flag in bundle install(1) \fIbundle\-install\.1\.html\fR\.
--- ruby2.7-2.7.6.orig/man/bundle-binstubs.1.txt
+++ /dev/null
@@ -1,48 +0,0 @@
-BUNDLE-BINSTUBS(1)					    BUNDLE-BINSTUBS(1)
-
-
-
-NAME
-       bundle-binstubs - Install the binstubs of the listed gems
-
-SYNOPSIS
-       bundle binstubs GEM_NAME [--force] [--path PATH] [--standalone]
-
-DESCRIPTION
-       Binstubs  are  scripts  that wrap around executables. Bundler creates a
-       small Ruby file (a binstub) that loads Bundler, runs the  command,  and
-       puts  it  into  bin/. Binstubs are a shortcut-or alternative- to always
-       using bundle exec. This gives you a file that can be run directly,  and
-       one  that  will always run the correct gem version used by the applica-
-       tion.
-
-       For example, if you run bundle binstubs rspec-core, Bundler will create
-       the file bin/rspec. That file will contain enough code to load Bundler,
-       tell it to load the bundled gems, and then run rspec.
-
-       This command generates binstubs for executables in  GEM_NAME.  Binstubs
-       are  put into bin, or the --path directory if one has been set. Calling
-       binstubs with [GEM [GEM]] will create binstubs for all given gems.
-
-OPTIONS
-       --force
-	      Overwrite existing binstubs if they exist.
-
-       --path The location to install the specified binstubs to. This defaults
-	      to bin.
-
-       --standalone
-	      Makes  binstubs  that  can work without depending on Rubygems or
-	      Bundler at runtime.
-
-       --shebang
-	      Specify a different shebang executable  name  than  the  default
-	      (default 'ruby')
-
-BUNDLE INSTALL --BINSTUBS
-       To  create  binstubs  for  all  the  gems in the bundle you can use the
-       --binstubs flag in bundle install(1) bundle-install.1.html.
-
-
-
-				 January 2020		    BUNDLE-BINSTUBS(1)
--- ruby2.7-2.7.6.orig/man/bundle-binstubs.ronn
+++ /dev/null
@@ -1,43 +0,0 @@
-bundle-binstubs(1) -- Install the binstubs of the listed gems
-=============================================================
-
-## SYNOPSIS
-
-`bundle binstubs` <GEM_NAME> [--force] [--path PATH] [--standalone]
-
-## DESCRIPTION
-
-Binstubs are scripts that wrap around executables. Bundler creates a
-small Ruby file (a binstub) that loads Bundler, runs the command,
-and puts it into `bin/`. Binstubs are a shortcut-or alternative-
-to always using `bundle exec`. This gives you a file that can be run
-directly, and one that will always run the correct gem version
-used by the application.
-
-For example, if you run `bundle binstubs rspec-core`, Bundler will create
-the file `bin/rspec`. That file will contain enough code to load Bundler,
-tell it to load the bundled gems, and then run rspec.
-
-This command generates binstubs for executables in `GEM_NAME`.
-Binstubs are put into `bin`, or the `--path` directory if one has been set.
-Calling binstubs with [GEM [GEM]] will create binstubs for all given gems.
-
-## OPTIONS
-
-* `--force`:
-  Overwrite existing binstubs if they exist.
-
-* `--path`:
-  The location to install the specified binstubs to. This defaults to `bin`.
-
-* `--standalone`:
-  Makes binstubs that can work without depending on Rubygems or Bundler at
-  runtime.
-
-* `--shebang`:
-  Specify a different shebang executable name than the default (default 'ruby')
-
-## BUNDLE INSTALL --BINSTUBS
-
-To create binstubs for all the gems in the bundle you can use the `--binstubs`
-flag in [bundle install(1)](bundle-install.1.html).
--- ruby2.7-2.7.6.orig/man/bundle-cache.1
+++ /dev/null
@@ -1,55 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-CACHE" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-cache\fR \- Package your needed \fB\.gem\fR files into your application
-.
-.SH "SYNOPSIS"
-\fBbundle cache\fR
-.
-.SH "DESCRIPTION"
-Copy all of the \fB\.gem\fR files needed to run the application into the \fBvendor/cache\fR directory\. In the future, when running [bundle install(1)][bundle\-install], use the gems in the cache in preference to the ones on \fBrubygems\.org\fR\.
-.
-.SH "GIT AND PATH GEMS"
-The \fBbundle cache\fR command can also package \fB:git\fR and \fB:path\fR dependencies besides \.gem files\. This needs to be explicitly enabled via the \fB\-\-all\fR option\. Once used, the \fB\-\-all\fR option will be remembered\.
-.
-.SH "SUPPORT FOR MULTIPLE PLATFORMS"
-When using gems that have different packages for different platforms, Bundler supports caching of gems for other platforms where the Gemfile has been resolved (i\.e\. present in the lockfile) in \fBvendor/cache\fR\. This needs to be enabled via the \fB\-\-all\-platforms\fR option\. This setting will be remembered in your local bundler configuration\.
-.
-.SH "REMOTE FETCHING"
-By default, if you run \fBbundle install(1)\fR](bundle\-install\.1\.html) after running bundle cache(1) \fIbundle\-cache\.1\.html\fR, bundler will still connect to \fBrubygems\.org\fR to check whether a platform\-specific gem exists for any of the gems in \fBvendor/cache\fR\.
-.
-.P
-For instance, consider this Gemfile(5):
-.
-.IP "" 4
-.
-.nf
-
-source "https://rubygems\.org"
-
-gem "nokogiri"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-If you run \fBbundle cache\fR under C Ruby, bundler will retrieve the version of \fBnokogiri\fR for the \fB"ruby"\fR platform\. If you deploy to JRuby and run \fBbundle install\fR, bundler is forced to check to see whether a \fB"java"\fR platformed \fBnokogiri\fR exists\.
-.
-.P
-Even though the \fBnokogiri\fR gem for the Ruby platform is \fItechnically\fR acceptable on JRuby, it has a C extension that does not run on JRuby\. As a result, bundler will, by default, still connect to \fBrubygems\.org\fR to check whether it has a version of one of your gems more specific to your platform\.
-.
-.P
-This problem is also not limited to the \fB"java"\fR platform\. A similar (common) problem can happen when developing on Windows and deploying to Linux, or even when developing on OSX and deploying to Linux\.
-.
-.P
-If you know for sure that the gems packaged in \fBvendor/cache\fR are appropriate for the platform you are on, you can run \fBbundle install \-\-local\fR to skip checking for more appropriate gems, and use the ones in \fBvendor/cache\fR\.
-.
-.P
-One way to be sure that you have the right platformed versions of all your gems is to run \fBbundle cache\fR on an identical machine and check in the gems\. For instance, you can run \fBbundle cache\fR on an identical staging box during your staging process, and check in the \fBvendor/cache\fR before deploying to production\.
-.
-.P
-By default, bundle cache(1) \fIbundle\-cache\.1\.html\fR fetches and also installs the gems to the default location\. To package the dependencies to \fBvendor/cache\fR without installing them to the local install location, you can run \fBbundle cache \-\-no\-install\fR\.
--- ruby2.7-2.7.6.orig/man/bundle-cache.1.txt
+++ /dev/null
@@ -1,78 +0,0 @@
-BUNDLE-CACHE(1) 					       BUNDLE-CACHE(1)
-
-
-
-NAME
-       bundle-cache - Package your needed .gem files into your application
-
-SYNOPSIS
-       bundle cache
-
-DESCRIPTION
-       Copy  all of the .gem files needed to run the application into the ven-
-       dor/cache   directory.	In   the   future,   when   running    [bundle
-       install(1)][bundle-install], use the gems in the cache in preference to
-       the ones on rubygems.org.
-
-GIT AND PATH GEMS
-       The bundle cache command can also package :git and  :path  dependencies
-       besides	.gem  files. This needs to be explicitly enabled via the --all
-       option. Once used, the --all option will be remembered.
-
-SUPPORT FOR MULTIPLE PLATFORMS
-       When using gems that have different packages for  different  platforms,
-       Bundler	supports caching of gems for other platforms where the Gemfile
-       has been resolved (i.e. present in the lockfile) in vendor/cache.  This
-       needs  to  be enabled via the --all-platforms option. This setting will
-       be remembered in your local bundler configuration.
-
-REMOTE FETCHING
-       By default, if you run bundle install(1)](bundle-install.1.html)  after
-       running bundle cache(1) bundle-cache.1.html, bundler will still connect
-       to rubygems.org to check whether a platform-specific gem exists for any
-       of the gems in vendor/cache.
-
-       For instance, consider this Gemfile(5):
-
-
-
-	   source "https://rubygems.org"
-
-	   gem "nokogiri"
-
-
-
-       If you run bundle cache under C Ruby, bundler will retrieve the version
-       of nokogiri for the "ruby" platform. If you deploy  to  JRuby  and  run
-       bundle  install,  bundler  is  forced  to check to see whether a "java"
-       platformed nokogiri exists.
-
-       Even though the nokogiri gem  for  the  Ruby  platform  is  technically
-       acceptable  on  JRuby, it has a C extension that does not run on JRuby.
-       As a result, bundler will, by default, still connect to rubygems.org to
-       check  whether  it  has	a version of one of your gems more specific to
-       your platform.
-
-       This problem is also not limited to  the  "java"  platform.  A  similar
-       (common) problem can happen when developing on Windows and deploying to
-       Linux, or even when developing on OSX and deploying to Linux.
-
-       If you know for sure that the gems packaged in vendor/cache are	appro-
-       priate  for the platform you are on, you can run bundle install --local
-       to skip checking for more appropriate gems, and use the	ones  in  ven-
-       dor/cache.
-
-       One  way  to be sure that you have the right platformed versions of all
-       your gems is to run bundle cache on an identical machine and  check  in
-       the  gems. For instance, you can run bundle cache on an identical stag-
-       ing box during your staging process,  and  check  in  the  vendor/cache
-       before deploying to production.
-
-       By  default,  bundle  cache(1)  bundle-cache.1.html  fetches  and  also
-       installs the gems to the default location. To package the  dependencies
-       to  vendor/cache without installing them to the local install location,
-       you can run bundle cache --no-install.
-
-
-
-				 January 2020		       BUNDLE-CACHE(1)
--- ruby2.7-2.7.6.orig/man/bundle-cache.ronn
+++ /dev/null
@@ -1,72 +0,0 @@
-bundle-cache(1) -- Package your needed `.gem` files into your application
-===========================================================================
-
-## SYNOPSIS
-
-`bundle cache`
-
-## DESCRIPTION
-
-Copy all of the `.gem` files needed to run the application into the
-`vendor/cache` directory. In the future, when running [bundle install(1)][bundle-install],
-use the gems in the cache in preference to the ones on `rubygems.org`.
-
-## GIT AND PATH GEMS
-
-The `bundle cache` command can also package `:git` and `:path` dependencies
-besides .gem files. This needs to be explicitly enabled via the `--all` option.
-Once used, the `--all` option will be remembered.
-
-## SUPPORT FOR MULTIPLE PLATFORMS
-
-When using gems that have different packages for different platforms, Bundler
-supports caching of gems for other platforms where the Gemfile has been resolved
-(i.e. present in the lockfile) in `vendor/cache`.  This needs to be enabled via
-the `--all-platforms` option. This setting will be remembered in your local
-bundler configuration.
-
-## REMOTE FETCHING
-
-By default, if you run `bundle install(1)`](bundle-install.1.html) after running
-[bundle cache(1)](bundle-cache.1.html), bundler will still connect to `rubygems.org`
-to check whether a platform-specific gem exists for any of the gems
-in `vendor/cache`.
-
-For instance, consider this Gemfile(5):
-
-    source "https://rubygems.org"
-
-    gem "nokogiri"
-
-If you run `bundle cache` under C Ruby, bundler will retrieve
-the version of `nokogiri` for the `"ruby"` platform. If you deploy
-to JRuby and run `bundle install`, bundler is forced to check to
-see whether a `"java"` platformed `nokogiri` exists.
-
-Even though the `nokogiri` gem for the Ruby platform is
-_technically_ acceptable on JRuby, it has a C extension
-that does not run on JRuby. As a result, bundler will, by default,
-still connect to `rubygems.org` to check whether it has a version
-of one of your gems more specific to your platform.
-
-This problem is also not limited to the `"java"` platform.
-A similar (common) problem can happen when developing on Windows
-and deploying to Linux, or even when developing on OSX and
-deploying to Linux.
-
-If you know for sure that the gems packaged in `vendor/cache`
-are appropriate for the platform you are on, you can run
-`bundle install --local` to skip checking for more appropriate
-gems, and use the ones in `vendor/cache`.
-
-One way to be sure that you have the right platformed versions
-of all your gems is to run `bundle cache` on an identical
-machine and check in the gems. For instance, you can run
-`bundle cache` on an identical staging box during your
-staging process, and check in the `vendor/cache` before
-deploying to production.
-
-By default, [bundle cache(1)](bundle-cache.1.html) fetches and also
-installs the gems to the default location. To package the
-dependencies to `vendor/cache` without installing them to the
-local install location, you can run `bundle cache --no-install`.
--- ruby2.7-2.7.6.orig/man/bundle-check.1
+++ /dev/null
@@ -1,31 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-CHECK" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-check\fR \- Verifies if dependencies are satisfied by installed gems
-.
-.SH "SYNOPSIS"
-\fBbundle check\fR [\-\-dry\-run] [\-\-gemfile=FILE] [\-\-path=PATH]
-.
-.SH "DESCRIPTION"
-\fBcheck\fR searches the local machine for each of the gems requested in the Gemfile\. If all gems are found, Bundler prints a success message and exits with a status of 0\.
-.
-.P
-If not, the first missing gem is listed and Bundler exits status 1\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-dry\-run\fR
-Locks the [\fBGemfile(5)\fR][Gemfile(5)] before running the command\.
-.
-.TP
-\fB\-\-gemfile\fR
-Use the specified gemfile instead of the [\fBGemfile(5)\fR][Gemfile(5)]\.
-.
-.TP
-\fB\-\-path\fR
-Specify a different path than the system default (\fB$BUNDLE_PATH\fR or \fB$GEM_HOME\fR)\. Bundler will remember this value for future installs on this machine\.
-
--- ruby2.7-2.7.6.orig/man/bundle-check.1.txt
+++ /dev/null
@@ -1,33 +0,0 @@
-BUNDLE-CHECK(1) 					       BUNDLE-CHECK(1)
-
-
-
-NAME
-       bundle-check - Verifies if dependencies are satisfied by installed gems
-
-SYNOPSIS
-       bundle check [--dry-run] [--gemfile=FILE] [--path=PATH]
-
-DESCRIPTION
-       check  searches the local machine for each of the gems requested in the
-       Gemfile. If all gems are found, Bundler prints a  success  message  and
-       exits with a status of 0.
-
-       If not, the first missing gem is listed and Bundler exits status 1.
-
-OPTIONS
-       --dry-run
-	      Locks the [Gemfile(5)][Gemfile(5)] before running the command.
-
-       --gemfile
-	      Use  the	specified  gemfile  instead  of  the [Gemfile(5)][Gem-
-	      file(5)].
-
-       --path Specify a different path than the system	default  ($BUNDLE_PATH
-	      or  $GEM_HOME).  Bundler	will  remember	this  value for future
-	      installs on this machine.
-
-
-
-
-				 January 2020		       BUNDLE-CHECK(1)
--- ruby2.7-2.7.6.orig/man/bundle-check.ronn
+++ /dev/null
@@ -1,26 +0,0 @@
-bundle-check(1) -- Verifies if dependencies are satisfied by installed gems
-===========================================================================
-
-## SYNOPSIS
-
-`bundle check` [--dry-run]
-               [--gemfile=FILE]
-               [--path=PATH]
-
-## DESCRIPTION
-
-`check` searches the local machine for each of the gems requested in the
-Gemfile. If all gems are found, Bundler prints a success message and exits with
-a status of 0.
-
-If not, the first missing gem is listed and Bundler exits status 1.
-
-## OPTIONS
-
-* `--dry-run`:
-  Locks the [`Gemfile(5)`][Gemfile(5)] before running the command.
-* `--gemfile`:
-  Use the specified gemfile instead of the [`Gemfile(5)`][Gemfile(5)].
-* `--path`:
-  Specify a different path than the system default (`$BUNDLE_PATH` or `$GEM_HOME`).
-  Bundler will remember this value for future installs on this machine.
--- ruby2.7-2.7.6.orig/man/bundle-clean.1
+++ /dev/null
@@ -1,24 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-CLEAN" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-clean\fR \- Cleans up unused gems in your bundler directory
-.
-.SH "SYNOPSIS"
-\fBbundle clean\fR [\-\-dry\-run] [\-\-force]
-.
-.SH "DESCRIPTION"
-This command will remove all unused gems in your bundler directory\. This is useful when you have made many changes to your gem dependencies\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-dry\-run\fR
-Print the changes, but do not clean the unused gems\.
-.
-.TP
-\fB\-\-force\fR
-Force a clean even if \fB\-\-path\fR is not set\.
-
--- ruby2.7-2.7.6.orig/man/bundle-clean.1.txt
+++ /dev/null
@@ -1,26 +0,0 @@
-BUNDLE-CLEAN(1) 					       BUNDLE-CLEAN(1)
-
-
-
-NAME
-       bundle-clean - Cleans up unused gems in your bundler directory
-
-SYNOPSIS
-       bundle clean [--dry-run] [--force]
-
-DESCRIPTION
-       This  command  will  remove  all unused gems in your bundler directory.
-       This is useful when you have made many changes to  your	gem  dependen-
-       cies.
-
-OPTIONS
-       --dry-run
-	      Print the changes, but do not clean the unused gems.
-
-       --force
-	      Force a clean even if --path is not set.
-
-
-
-
-				 January 2020		       BUNDLE-CLEAN(1)
--- ruby2.7-2.7.6.orig/man/bundle-clean.ronn
+++ /dev/null
@@ -1,18 +0,0 @@
-bundle-clean(1) -- Cleans up unused gems in your bundler directory
-==================================================================
-
-## SYNOPSIS
-
-`bundle clean` [--dry-run] [--force]
-
-## DESCRIPTION
-
-This command will remove all unused gems in your bundler directory. This is
-useful when you have made many changes to your gem dependencies.
-
-## OPTIONS
-
-* `--dry-run`:
-  Print the changes, but do not clean the unused gems.
-* `--force`:
-  Force a clean even if `--path` is not set.
--- ruby2.7-2.7.6.orig/man/bundle-config.1
+++ /dev/null
@@ -1,497 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-CONFIG" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-config\fR \- Set bundler configuration options
-.
-.SH "SYNOPSIS"
-\fBbundle config\fR [list|get|set|unset] [\fIname\fR [\fIvalue\fR]]
-.
-.SH "DESCRIPTION"
-This command allows you to interact with Bundler\'s configuration system\.
-.
-.P
-Bundler loads configuration settings in this order:
-.
-.IP "1." 4
-Local config (\fBapp/\.bundle/config\fR)
-.
-.IP "2." 4
-Environmental variables (\fBENV\fR)
-.
-.IP "3." 4
-Global config (\fB~/\.bundle/config\fR)
-.
-.IP "4." 4
-Bundler default config
-.
-.IP "" 0
-.
-.P
-Executing \fBbundle config list\fR with will print a list of all bundler configuration for the current bundle, and where that configuration was set\.
-.
-.P
-Executing \fBbundle config get <name>\fR will print the value of that configuration setting, and where it was set\.
-.
-.P
-Executing \fBbundle config set <name> <value>\fR will set that configuration to the value specified for all bundles executed as the current user\. The configuration will be stored in \fB~/\.bundle/config\fR\. If \fIname\fR already is set, \fIname\fR will be overridden and user will be warned\.
-.
-.P
-Executing \fBbundle config set \-\-global <name> <value>\fR works the same as above\.
-.
-.P
-Executing \fBbundle config set \-\-local <name> <value>\fR will set that configuration to the local application\. The configuration will be stored in \fBapp/\.bundle/config\fR\.
-.
-.P
-Executing \fBbundle config unset <name>\fR will delete the configuration in both local and global sources\.
-.
-.P
-Executing \fBbundle config unset \-\-global <name>\fR will delete the configuration only from the user configuration\.
-.
-.P
-Executing \fBbundle config unset \-\-local <name> <value>\fR will delete the configuration only from the local application\.
-.
-.P
-Executing bundle with the \fBBUNDLE_IGNORE_CONFIG\fR environment variable set will cause it to ignore all configuration\.
-.
-.P
-Executing \fBbundle config set disable_multisource true\fR upgrades the warning about the Gemfile containing multiple primary sources to an error\. Executing \fBbundle config unset disable_multisource\fR downgrades this error to a warning\.
-.
-.SH "REMEMBERING OPTIONS"
-Flags passed to \fBbundle install\fR or the Bundler runtime, such as \fB\-\-path foo\fR or \fB\-\-without production\fR, are remembered between commands and saved to your local application\'s configuration (normally, \fB\./\.bundle/config\fR)\.
-.
-.P
-However, this will be changed in bundler 3, so it\'s better not to rely on this behavior\. If these options must be remembered, it\'s better to set them using \fBbundle config\fR (e\.g\., \fBbundle config set path foo\fR)\.
-.
-.P
-The options that can be configured are:
-.
-.TP
-\fBbin\fR
-Creates a directory (defaults to \fB~/bin\fR) and place any executables from the gem there\. These executables run in Bundler\'s context\. If used, you might add this directory to your environment\'s \fBPATH\fR variable\. For instance, if the \fBrails\fR gem comes with a \fBrails\fR executable, this flag will create a \fBbin/rails\fR executable that ensures that all referred dependencies will be resolved using the bundled gems\.
-.
-.TP
-\fBdeployment\fR
-In deployment mode, Bundler will \'roll\-out\' the bundle for \fBproduction\fR use\. Please check carefully if you want to have this option enabled in \fBdevelopment\fR or \fBtest\fR environments\.
-.
-.TP
-\fBpath\fR
-The location to install the specified gems to\. This defaults to Rubygems\' setting\. Bundler shares this location with Rubygems, \fBgem install \.\.\.\fR will have gem installed there, too\. Therefore, gems installed without a \fB\-\-path \.\.\.\fR setting will show up by calling \fBgem list\fR\. Accordingly, gems installed to other locations will not get listed\.
-.
-.TP
-\fBwithout\fR
-A space\-separated list of groups referencing gems to skip during installation\.
-.
-.TP
-\fBwith\fR
-A space\-separated list of groups referencing gems to include during installation\.
-.
-.SH "BUILD OPTIONS"
-You can use \fBbundle config\fR to give Bundler the flags to pass to the gem installer every time bundler tries to install a particular gem\.
-.
-.P
-A very common example, the \fBmysql\fR gem, requires Snow Leopard users to pass configuration flags to \fBgem install\fR to specify where to find the \fBmysql_config\fR executable\.
-.
-.IP "" 4
-.
-.nf
-
-gem install mysql \-\- \-\-with\-mysql\-config=/usr/local/mysql/bin/mysql_config
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Since the specific location of that executable can change from machine to machine, you can specify these flags on a per\-machine basis\.
-.
-.IP "" 4
-.
-.nf
-
-bundle config set build\.mysql \-\-with\-mysql\-config=/usr/local/mysql/bin/mysql_config
-.
-.fi
-.
-.IP "" 0
-.
-.P
-After running this command, every time bundler needs to install the \fBmysql\fR gem, it will pass along the flags you specified\.
-.
-.SH "CONFIGURATION KEYS"
-Configuration keys in bundler have two forms: the canonical form and the environment variable form\.
-.
-.P
-For instance, passing the \fB\-\-without\fR flag to bundle install(1) \fIbundle\-install\.1\.html\fR prevents Bundler from installing certain groups specified in the Gemfile(5)\. Bundler persists this value in \fBapp/\.bundle/config\fR so that calls to \fBBundler\.setup\fR do not try to find gems from the \fBGemfile\fR that you didn\'t install\. Additionally, subsequent calls to bundle install(1) \fIbundle\-install\.1\.html\fR remember this setting and skip those groups\.
-.
-.P
-The canonical form of this configuration is \fB"without"\fR\. To convert the canonical form to the environment variable form, capitalize it, and prepend \fBBUNDLE_\fR\. The environment variable form of \fB"without"\fR is \fBBUNDLE_WITHOUT\fR\.
-.
-.P
-Any periods in the configuration keys must be replaced with two underscores when setting it via environment variables\. The configuration key \fBlocal\.rack\fR becomes the environment variable \fBBUNDLE_LOCAL__RACK\fR\.
-.
-.SH "LIST OF AVAILABLE KEYS"
-The following is a list of all configuration keys and their purpose\. You can learn more about their operation in bundle install(1) \fIbundle\-install\.1\.html\fR\.
-.
-.IP "\(bu" 4
-\fBallow_bundler_dependency_conflicts\fR (\fBBUNDLE_ALLOW_BUNDLER_DEPENDENCY_CONFLICTS\fR): Allow resolving to specifications that have dependencies on \fBbundler\fR that are incompatible with the running Bundler version\.
-.
-.IP "\(bu" 4
-\fBallow_deployment_source_credential_changes\fR (\fBBUNDLE_ALLOW_DEPLOYMENT_SOURCE_CREDENTIAL_CHANGES\fR): When in deployment mode, allow changing the credentials to a gem\'s source\. Ex: \fBhttps://some\.host\.com/gems/path/\fR \-> \fBhttps://user_name:password@some\.host\.com/gems/path\fR
-.
-.IP "\(bu" 4
-\fBallow_offline_install\fR (\fBBUNDLE_ALLOW_OFFLINE_INSTALL\fR): Allow Bundler to use cached data when installing without network access\.
-.
-.IP "\(bu" 4
-\fBauto_clean_without_path\fR (\fBBUNDLE_AUTO_CLEAN_WITHOUT_PATH\fR): Automatically run \fBbundle clean\fR after installing when an explicit \fBpath\fR has not been set and Bundler is not installing into the system gems\.
-.
-.IP "\(bu" 4
-\fBauto_install\fR (\fBBUNDLE_AUTO_INSTALL\fR): Automatically run \fBbundle install\fR when gems are missing\.
-.
-.IP "\(bu" 4
-\fBbin\fR (\fBBUNDLE_BIN\fR): Install executables from gems in the bundle to the specified directory\. Defaults to \fBfalse\fR\.
-.
-.IP "\(bu" 4
-\fBcache_all\fR (\fBBUNDLE_CACHE_ALL\fR): Cache all gems, including path and git gems\.
-.
-.IP "\(bu" 4
-\fBcache_all_platforms\fR (\fBBUNDLE_CACHE_ALL_PLATFORMS\fR): Cache gems for all platforms\.
-.
-.IP "\(bu" 4
-\fBcache_path\fR (\fBBUNDLE_CACHE_PATH\fR): The directory that bundler will place cached gems in when running \fBbundle package\fR, and that bundler will look in when installing gems\. Defaults to \fBvendor/cache\fR\.
-.
-.IP "\(bu" 4
-\fBclean\fR (\fBBUNDLE_CLEAN\fR): Whether Bundler should run \fBbundle clean\fR automatically after \fBbundle install\fR\.
-.
-.IP "\(bu" 4
-\fBconsole\fR (\fBBUNDLE_CONSOLE\fR): The console that \fBbundle console\fR starts\. Defaults to \fBirb\fR\.
-.
-.IP "\(bu" 4
-\fBdefault_install_uses_path\fR (\fBBUNDLE_DEFAULT_INSTALL_USES_PATH\fR): Whether a \fBbundle install\fR without an explicit \fB\-\-path\fR argument defaults to installing gems in \fB\.bundle\fR\.
-.
-.IP "\(bu" 4
-\fBdeployment\fR (\fBBUNDLE_DEPLOYMENT\fR): Disallow changes to the \fBGemfile\fR\. When the \fBGemfile\fR is changed and the lockfile has not been updated, running Bundler commands will be blocked\.
-.
-.IP "\(bu" 4
-\fBdisable_checksum_validation\fR (\fBBUNDLE_DISABLE_CHECKSUM_VALIDATION\fR): Allow installing gems even if they do not match the checksum provided by RubyGems\.
-.
-.IP "\(bu" 4
-\fBdisable_exec_load\fR (\fBBUNDLE_DISABLE_EXEC_LOAD\fR): Stop Bundler from using \fBload\fR to launch an executable in\-process in \fBbundle exec\fR\.
-.
-.IP "\(bu" 4
-\fBdisable_local_branch_check\fR (\fBBUNDLE_DISABLE_LOCAL_BRANCH_CHECK\fR): Allow Bundler to use a local git override without a branch specified in the Gemfile\.
-.
-.IP "\(bu" 4
-\fBdisable_multisource\fR (\fBBUNDLE_DISABLE_MULTISOURCE\fR): When set, Gemfiles containing multiple sources will produce errors instead of warnings\. Use \fBbundle config unset disable_multisource\fR to unset\.
-.
-.IP "\(bu" 4
-\fBdisable_platform_warnings\fR (\fBBUNDLE_DISABLE_PLATFORM_WARNINGS\fR): Disable warnings during bundle install when a dependency is unused on the current platform\.
-.
-.IP "\(bu" 4
-\fBdisable_shared_gems\fR (\fBBUNDLE_DISABLE_SHARED_GEMS\fR): Stop Bundler from accessing gems installed to RubyGems\' normal location\.
-.
-.IP "\(bu" 4
-\fBdisable_version_check\fR (\fBBUNDLE_DISABLE_VERSION_CHECK\fR): Stop Bundler from checking if a newer Bundler version is available on rubygems\.org\.
-.
-.IP "\(bu" 4
-\fBforce_ruby_platform\fR (\fBBUNDLE_FORCE_RUBY_PLATFORM\fR): Ignore the current machine\'s platform and install only \fBruby\fR platform gems\. As a result, gems with native extensions will be compiled from source\.
-.
-.IP "\(bu" 4
-\fBfrozen\fR (\fBBUNDLE_FROZEN\fR): Disallow changes to the \fBGemfile\fR\. When the \fBGemfile\fR is changed and the lockfile has not been updated, running Bundler commands will be blocked\. Defaults to \fBtrue\fR when \fB\-\-deployment\fR is used\.
-.
-.IP "\(bu" 4
-\fBgem\.push_key\fR (\fBBUNDLE_GEM__PUSH_KEY\fR): Sets the \fB\-\-key\fR parameter for \fBgem push\fR when using the \fBrake release\fR command with a private gemstash server\.
-.
-.IP "\(bu" 4
-\fBgemfile\fR (\fBBUNDLE_GEMFILE\fR): The name of the file that bundler should use as the \fBGemfile\fR\. This location of this file also sets the root of the project, which is used to resolve relative paths in the \fBGemfile\fR, among other things\. By default, bundler will search up from the current working directory until it finds a \fBGemfile\fR\.
-.
-.IP "\(bu" 4
-\fBglobal_gem_cache\fR (\fBBUNDLE_GLOBAL_GEM_CACHE\fR): Whether Bundler should cache all gems globally, rather than locally to the installing Ruby installation\.
-.
-.IP "\(bu" 4
-\fBignore_messages\fR (\fBBUNDLE_IGNORE_MESSAGES\fR): When set, no post install messages will be printed\. To silence a single gem, use dot notation like \fBignore_messages\.httparty true\fR\.
-.
-.IP "\(bu" 4
-\fBinit_gems_rb\fR (\fBBUNDLE_INIT_GEMS_RB\fR) Generate a \fBgems\.rb\fR instead of a \fBGemfile\fR when running \fBbundle init\fR\.
-.
-.IP "\(bu" 4
-\fBjobs\fR (\fBBUNDLE_JOBS\fR): The number of gems Bundler can install in parallel\. Defaults to 1\.
-.
-.IP "\(bu" 4
-\fBno_install\fR (\fBBUNDLE_NO_INSTALL\fR): Whether \fBbundle package\fR should skip installing gems\.
-.
-.IP "\(bu" 4
-\fBno_prune\fR (\fBBUNDLE_NO_PRUNE\fR): Whether Bundler should leave outdated gems unpruned when caching\.
-.
-.IP "\(bu" 4
-\fBonly_update_to_newer_versions\fR (\fBBUNDLE_ONLY_UPDATE_TO_NEWER_VERSIONS\fR): During \fBbundle update\fR, only resolve to newer versions of the gems in the lockfile\.
-.
-.IP "\(bu" 4
-\fBpath\fR (\fBBUNDLE_PATH\fR): The location on disk where all gems in your bundle will be located regardless of \fB$GEM_HOME\fR or \fB$GEM_PATH\fR values\. Bundle gems not found in this location will be installed by \fBbundle install\fR\. Defaults to \fBGem\.dir\fR\. When \-\-deployment is used, defaults to vendor/bundle\.
-.
-.IP "\(bu" 4
-\fBpath\.system\fR (\fBBUNDLE_PATH__SYSTEM\fR): Whether Bundler will install gems into the default system path (\fBGem\.dir\fR)\.
-.
-.IP "\(bu" 4
-\fBpath_relative_to_cwd\fR (\fBBUNDLE_PATH_RELATIVE_TO_CWD\fR) Makes \fB\-\-path\fR relative to the CWD instead of the \fBGemfile\fR\.
-.
-.IP "\(bu" 4
-\fBplugins\fR (\fBBUNDLE_PLUGINS\fR): Enable Bundler\'s experimental plugin system\.
-.
-.IP "\(bu" 4
-\fBprefer_patch\fR (BUNDLE_PREFER_PATCH): Prefer updating only to next patch version during updates\. Makes \fBbundle update\fR calls equivalent to \fBbundler update \-\-patch\fR\.
-.
-.IP "\(bu" 4
-\fBprint_only_version_number\fR (\fBBUNDLE_PRINT_ONLY_VERSION_NUMBER\fR) Print only version number from \fBbundler \-\-version\fR\.
-.
-.IP "\(bu" 4
-\fBredirect\fR (\fBBUNDLE_REDIRECT\fR): The number of redirects allowed for network requests\. Defaults to \fB5\fR\.
-.
-.IP "\(bu" 4
-\fBretry\fR (\fBBUNDLE_RETRY\fR): The number of times to retry failed network requests\. Defaults to \fB3\fR\.
-.
-.IP "\(bu" 4
-\fBsetup_makes_kernel_gem_public\fR (\fBBUNDLE_SETUP_MAKES_KERNEL_GEM_PUBLIC\fR): Have \fBBundler\.setup\fR make the \fBKernel#gem\fR method public, even though RubyGems declares it as private\.
-.
-.IP "\(bu" 4
-\fBshebang\fR (\fBBUNDLE_SHEBANG\fR): The program name that should be invoked for generated binstubs\. Defaults to the ruby install name used to generate the binstub\.
-.
-.IP "\(bu" 4
-\fBsilence_deprecations\fR (\fBBUNDLE_SILENCE_DEPRECATIONS\fR): Whether Bundler should silence deprecation warnings for behavior that will be changed in the next major version\.
-.
-.IP "\(bu" 4
-\fBsilence_root_warning\fR (\fBBUNDLE_SILENCE_ROOT_WARNING\fR): Silence the warning Bundler prints when installing gems as root\.
-.
-.IP "\(bu" 4
-\fBskip_default_git_sources\fR (\fBBUNDLE_SKIP_DEFAULT_GIT_SOURCES\fR): Whether Bundler should skip adding default git source shortcuts to the Gemfile DSL\.
-.
-.IP "\(bu" 4
-\fBspecific_platform\fR (\fBBUNDLE_SPECIFIC_PLATFORM\fR): Allow bundler to resolve for the specific running platform and store it in the lockfile, instead of only using a generic platform\. A specific platform is the exact platform triple reported by \fBGem::Platform\.local\fR, such as \fBx86_64\-darwin\-16\fR or \fBuniversal\-java\-1\.8\fR\. On the other hand, generic platforms are those such as \fBruby\fR, \fBmswin\fR, or \fBjava\fR\. In this example, \fBx86_64\-darwin\-16\fR would map to \fBruby\fR and \fBuniversal\-java\-1\.8\fR to \fBjava\fR\.
-.
-.IP "\(bu" 4
-\fBssl_ca_cert\fR (\fBBUNDLE_SSL_CA_CERT\fR): Path to a designated CA certificate file or folder containing multiple certificates for trusted CAs in PEM format\.
-.
-.IP "\(bu" 4
-\fBssl_client_cert\fR (\fBBUNDLE_SSL_CLIENT_CERT\fR): Path to a designated file containing a X\.509 client certificate and key in PEM format\.
-.
-.IP "\(bu" 4
-\fBssl_verify_mode\fR (\fBBUNDLE_SSL_VERIFY_MODE\fR): The SSL verification mode Bundler uses when making HTTPS requests\. Defaults to verify peer\.
-.
-.IP "\(bu" 4
-\fBsuppress_install_using_messages\fR (\fBBUNDLE_SUPPRESS_INSTALL_USING_MESSAGES\fR): Avoid printing \fBUsing \.\.\.\fR messages during installation when the version of a gem has not changed\.
-.
-.IP "\(bu" 4
-\fBsystem_bindir\fR (\fBBUNDLE_SYSTEM_BINDIR\fR): The location where RubyGems installs binstubs\. Defaults to \fBGem\.bindir\fR\.
-.
-.IP "\(bu" 4
-\fBtimeout\fR (\fBBUNDLE_TIMEOUT\fR): The seconds allowed before timing out for network requests\. Defaults to \fB10\fR\.
-.
-.IP "\(bu" 4
-\fBunlock_source_unlocks_spec\fR (\fBBUNDLE_UNLOCK_SOURCE_UNLOCKS_SPEC\fR): Whether running \fBbundle update \-\-source NAME\fR unlocks a gem with the given name\. Defaults to \fBtrue\fR\.
-.
-.IP "\(bu" 4
-\fBupdate_requires_all_flag\fR (\fBBUNDLE_UPDATE_REQUIRES_ALL_FLAG\fR) Require passing \fB\-\-all\fR to \fBbundle update\fR when everything should be updated, and disallow passing no options to \fBbundle update\fR\.
-.
-.IP "\(bu" 4
-\fBuser_agent\fR (\fBBUNDLE_USER_AGENT\fR): The custom user agent fragment Bundler includes in API requests\.
-.
-.IP "\(bu" 4
-\fBwith\fR (\fBBUNDLE_WITH\fR): A \fB:\fR\-separated list of groups whose gems bundler should install\.
-.
-.IP "\(bu" 4
-\fBwithout\fR (\fBBUNDLE_WITHOUT\fR): A \fB:\fR\-separated list of groups whose gems bundler should not install\.
-.
-.IP "" 0
-.
-.P
-In general, you should set these settings per\-application by using the applicable flag to the bundle install(1) \fIbundle\-install\.1\.html\fR or bundle package(1) \fIbundle\-package\.1\.html\fR command\.
-.
-.P
-You can set them globally either via environment variables or \fBbundle config\fR, whichever is preferable for your setup\. If you use both, environment variables will take preference over global settings\.
-.
-.SH "LOCAL GIT REPOS"
-Bundler also allows you to work against a git repository locally instead of using the remote version\. This can be achieved by setting up a local override:
-.
-.IP "" 4
-.
-.nf
-
-bundle config set local\.GEM_NAME /path/to/local/git/repository
-.
-.fi
-.
-.IP "" 0
-.
-.P
-For example, in order to use a local Rack repository, a developer could call:
-.
-.IP "" 4
-.
-.nf
-
-bundle config set local\.rack ~/Work/git/rack
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Now instead of checking out the remote git repository, the local override will be used\. Similar to a path source, every time the local git repository change, changes will be automatically picked up by Bundler\. This means a commit in the local git repo will update the revision in the \fBGemfile\.lock\fR to the local git repo revision\. This requires the same attention as git submodules\. Before pushing to the remote, you need to ensure the local override was pushed, otherwise you may point to a commit that only exists in your local machine\. You\'ll also need to CGI escape your usernames and passwords as well\.
-.
-.P
-Bundler does many checks to ensure a developer won\'t work with invalid references\. Particularly, we force a developer to specify a branch in the \fBGemfile\fR in order to use this feature\. If the branch specified in the \fBGemfile\fR and the current branch in the local git repository do not match, Bundler will abort\. This ensures that a developer is always working against the correct branches, and prevents accidental locking to a different branch\.
-.
-.P
-Finally, Bundler also ensures that the current revision in the \fBGemfile\.lock\fR exists in the local git repository\. By doing this, Bundler forces you to fetch the latest changes in the remotes\.
-.
-.SH "MIRRORS OF GEM SOURCES"
-Bundler supports overriding gem sources with mirrors\. This allows you to configure rubygems\.org as the gem source in your Gemfile while still using your mirror to fetch gems\.
-.
-.IP "" 4
-.
-.nf
-
-bundle config set mirror\.SOURCE_URL MIRROR_URL
-.
-.fi
-.
-.IP "" 0
-.
-.P
-For example, to use a mirror of rubygems\.org hosted at rubygems\-mirror\.org:
-.
-.IP "" 4
-.
-.nf
-
-bundle config set mirror\.http://rubygems\.org http://rubygems\-mirror\.org
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Each mirror also provides a fallback timeout setting\. If the mirror does not respond within the fallback timeout, Bundler will try to use the original server instead of the mirror\.
-.
-.IP "" 4
-.
-.nf
-
-bundle config set mirror\.SOURCE_URL\.fallback_timeout TIMEOUT
-.
-.fi
-.
-.IP "" 0
-.
-.P
-For example, to fall back to rubygems\.org after 3 seconds:
-.
-.IP "" 4
-.
-.nf
-
-bundle config set mirror\.https://rubygems\.org\.fallback_timeout 3
-.
-.fi
-.
-.IP "" 0
-.
-.P
-The default fallback timeout is 0\.1 seconds, but the setting can currently only accept whole seconds (for example, 1, 15, or 30)\.
-.
-.SH "CREDENTIALS FOR GEM SOURCES"
-Bundler allows you to configure credentials for any gem source, which allows you to avoid putting secrets into your Gemfile\.
-.
-.IP "" 4
-.
-.nf
-
-bundle config set SOURCE_HOSTNAME USERNAME:PASSWORD
-.
-.fi
-.
-.IP "" 0
-.
-.P
-For example, to save the credentials of user \fBclaudette\fR for the gem source at \fBgems\.longerous\.com\fR, you would run:
-.
-.IP "" 4
-.
-.nf
-
-bundle config set gems\.longerous\.com claudette:s00pers3krit
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Or you can set the credentials as an environment variable like this:
-.
-.IP "" 4
-.
-.nf
-
-export BUNDLE_GEMS__LONGEROUS__COM="claudette:s00pers3krit"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-For gems with a git source with HTTP(S) URL you can specify credentials like so:
-.
-.IP "" 4
-.
-.nf
-
-bundle config set https://github\.com/bundler/bundler\.git username:password
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Or you can set the credentials as an environment variable like so:
-.
-.IP "" 4
-.
-.nf
-
-export BUNDLE_GITHUB__COM=username:password
-.
-.fi
-.
-.IP "" 0
-.
-.P
-This is especially useful for private repositories on hosts such as Github, where you can use personal OAuth tokens:
-.
-.IP "" 4
-.
-.nf
-
-export BUNDLE_GITHUB__COM=abcd0123generatedtoken:x\-oauth\-basic
-.
-.fi
-.
-.IP "" 0
-.
-.SH "CONFIGURE BUNDLER DIRECTORIES"
-Bundler\'s home, config, cache and plugin directories are able to be configured through environment variables\. The default location for Bundler\'s home directory is \fB~/\.bundle\fR, which all directories inherit from by default\. The following outlines the available environment variables and their default values
-.
-.IP "" 4
-.
-.nf
-
-BUNDLE_USER_HOME : $HOME/\.bundle
-BUNDLE_USER_CACHE : $BUNDLE_USER_HOME/cache
-BUNDLE_USER_CONFIG : $BUNDLE_USER_HOME/config
-BUNDLE_USER_PLUGIN : $BUNDLE_USER_HOME/plugin
-.
-.fi
-.
-.IP "" 0
-
--- ruby2.7-2.7.6.orig/man/bundle-config.1.txt
+++ /dev/null
@@ -1,528 +0,0 @@
-BUNDLE-CONFIG(1)					      BUNDLE-CONFIG(1)
-
-
-
-NAME
-       bundle-config - Set bundler configuration options
-
-SYNOPSIS
-       bundle config [list|get|set|unset] [name [value]]
-
-DESCRIPTION
-       This  command  allows you to interact with Bundler's configuration sys-
-       tem.
-
-       Bundler loads configuration settings in this order:
-
-       1.  Local config (app/.bundle/config)
-
-       2.  Environmental variables (ENV)
-
-       3.  Global config (~/.bundle/config)
-
-       4.  Bundler default config
-
-
-
-       Executing bundle config list with will print a list of all bundler con-
-       figuration  for	the  current  bundle, and where that configuration was
-       set.
-
-       Executing bundle config get <name> will print the value of that config-
-       uration setting, and where it was set.
-
-       Executing  bundle config set <name> <value> will set that configuration
-       to the value specified for all bundles executed as  the	current  user.
-       The  configuration  will be stored in ~/.bundle/config. If name already
-       is set, name will be overridden and user will be warned.
-
-       Executing bundle config set --global <name> <value> works the  same  as
-       above.
-
-       Executing  bundle  config set --local <name> <value> will set that con-
-       figuration to the local application. The configuration will  be	stored
-       in app/.bundle/config.
-
-       Executing  bundle  config unset <name> will delete the configuration in
-       both local and global sources.
-
-       Executing bundle config unset --global <name> will delete the  configu-
-       ration only from the user configuration.
-
-       Executing  bundle  config  unset --local <name> <value> will delete the
-       configuration only from the local application.
-
-       Executing bundle with the BUNDLE_IGNORE_CONFIG environment variable set
-       will cause it to ignore all configuration.
-
-       Executing bundle config set disable_multisource true upgrades the warn-
-       ing about the Gemfile containing multiple primary sources to an	error.
-       Executing bundle config unset disable_multisource downgrades this error
-       to a warning.
-
-REMEMBERING OPTIONS
-       Flags passed to bundle install or the Bundler runtime, such  as	--path
-       foo  or --without production, are remembered between commands and saved
-       to your local application's configuration (normally, ./.bundle/config).
-
-       However, this will be changed in bundler 3, so it's better not to  rely
-       on  this  behavior. If these options must be remembered, it's better to
-       set them using bundle config (e.g., bundle config set path foo).
-
-       The options that can be configured are:
-
-       bin    Creates a directory (defaults to ~/bin) and place  any  executa-
-	      bles from the gem there. These executables run in Bundler's con-
-	      text. If used, you might add this  directory  to	your  environ-
-	      ment's  PATH variable. For instance, if the rails gem comes with
-	      a rails executable, this flag will create a bin/rails executable
-	      that  ensures  that  all	referred dependencies will be resolved
-	      using the bundled gems.
-
-       deployment
-	      In deployment mode, Bundler will 'roll-out' the bundle for  pro-
-	      duction  use.  Please  check  carefully if you want to have this
-	      option enabled in development or test environments.
-
-       path   The location to install the specified gems to. This defaults  to
-	      Rubygems'  setting.  Bundler shares this location with Rubygems,
-	      gem install ... will have gem installed there,  too.  Therefore,
-	      gems  installed  without	a  --path  ... setting will show up by
-	      calling gem list. Accordingly, gems installed to other locations
-	      will not get listed.
-
-       without
-	      A space-separated list of groups referencing gems to skip during
-	      installation.
-
-       with   A space-separated list of groups	referencing  gems  to  include
-	      during installation.
-
-BUILD OPTIONS
-       You  can use bundle config to give Bundler the flags to pass to the gem
-       installer every time bundler tries to install a particular gem.
-
-       A very common example, the mysql gem, requires Snow  Leopard  users  to
-       pass  configuration  flags  to gem install to specify where to find the
-       mysql_config executable.
-
-
-
-	   gem install mysql -- --with-mysql-config=/usr/local/mysql/bin/mysql_config
-
-
-
-       Since the specific location of that executable can change from  machine
-       to machine, you can specify these flags on a per-machine basis.
-
-
-
-	   bundle config set build.mysql --with-mysql-config=/usr/local/mysql/bin/mysql_config
-
-
-
-       After  running  this  command,  every time bundler needs to install the
-       mysql gem, it will pass along the flags you specified.
-
-CONFIGURATION KEYS
-       Configuration keys in bundler have two forms: the  canonical  form  and
-       the environment variable form.
-
-       For  instance,  passing	the  --without	flag to bundle install(1) bun-
-       dle-install.1.html prevents  Bundler  from  installing  certain	groups
-       specified  in  the Gemfile(5). Bundler persists this value in app/.bun-
-       dle/config so that calls to Bundler.setup do not try to find gems  from
-       the  Gemfile that you didn't install. Additionally, subsequent calls to
-       bundle install(1) bundle-install.1.html remember this setting and  skip
-       those groups.
-
-       The  canonical  form of this configuration is "without". To convert the
-       canonical form to the environment variable  form,  capitalize  it,  and
-       prepend	BUNDLE_.  The  environment  variable form of "without" is BUN-
-       DLE_WITHOUT.
-
-       Any periods in the configuration keys must be replaced with two	under-
-       scores when setting it via environment variables. The configuration key
-       local.rack becomes the environment variable BUNDLE_LOCAL__RACK.
-
-LIST OF AVAILABLE KEYS
-       The following is a list of all configuration keys  and  their  purpose.
-       You  can  learn	more  about  their operation in bundle install(1) bun-
-       dle-install.1.html.
-
-       o   allow_bundler_dependency_conflicts	  (BUNDLE_ALLOW_BUNDLER_DEPEN-
-	   DENCY_CONFLICTS):  Allow  resolving	to  specifications  that  have
-	   dependencies on bundler that  are  incompatible  with  the  running
-	   Bundler version.
-
-       o   allow_deployment_source_credential_changes	 (BUNDLE_ALLOW_DEPLOY-
-	   MENT_SOURCE_CREDENTIAL_CHANGES): When  in  deployment  mode,  allow
-	   changing    the    credentials    to    a	gem's	 source.   Ex:
-	   https://some.host.com/gems/path/	->     https://user_name:pass-
-	   word@some.host.com/gems/path
-
-       o   allow_offline_install (BUNDLE_ALLOW_OFFLINE_INSTALL): Allow Bundler
-	   to use cached data when installing without network access.
-
-       o   auto_clean_without_path (BUNDLE_AUTO_CLEAN_WITHOUT_PATH): Automati-
-	   cally  run  bundle clean after installing when an explicit path has
-	   not been set and Bundler is not installing into the system gems.
-
-       o   auto_install  (BUNDLE_AUTO_INSTALL):   Automatically   run	bundle
-	   install when gems are missing.
-
-       o   bin	(BUNDLE_BIN):  Install	executables from gems in the bundle to
-	   the specified directory. Defaults to false.
-
-       o   cache_all (BUNDLE_CACHE_ALL): Cache all gems,  including  path  and
-	   git gems.
-
-       o   cache_all_platforms	(BUNDLE_CACHE_ALL_PLATFORMS):  Cache  gems for
-	   all platforms.
-
-       o   cache_path (BUNDLE_CACHE_PATH): The	directory  that  bundler  will
-	   place  cached gems in when running bundle package, and that bundler
-	   will look in when installing gems. Defaults to vendor/cache.
-
-       o   clean (BUNDLE_CLEAN): Whether Bundler should run bundle clean auto-
-	   matically after bundle install.
-
-       o   console  (BUNDLE_CONSOLE):  The console that bundle console starts.
-	   Defaults to irb.
-
-       o   default_install_uses_path	   (BUNDLE_DEFAULT_INSTALL_USES_PATH):
-	   Whether  a  bundle  install	without  an  explicit  --path argument
-	   defaults to installing gems in .bundle.
-
-       o   deployment (BUNDLE_DEPLOYMENT): Disallow changes  to  the  Gemfile.
-	   When  the Gemfile is changed and the lockfile has not been updated,
-	   running Bundler commands will be blocked.
-
-       o   disable_checksum_validation	 (BUNDLE_DISABLE_CHECKSUM_VALIDATION):
-	   Allow  installing  gems even if they do not match the checksum pro-
-	   vided by RubyGems.
-
-       o   disable_exec_load  (BUNDLE_DISABLE_EXEC_LOAD):  Stop  Bundler  from
-	   using load to launch an executable in-process in bundle exec.
-
-       o   disable_local_branch_check	  (BUNDLE_DISABLE_LOCAL_BRANCH_CHECK):
-	   Allow Bundler to use a local git override without a	branch	speci-
-	   fied in the Gemfile.
-
-       o   disable_multisource	(BUNDLE_DISABLE_MULTISOURCE):  When  set, Gem-
-	   files containing multiple sources will produce  errors  instead  of
-	   warnings. Use bundle config unset disable_multisource to unset.
-
-       o   disable_platform_warnings  (BUNDLE_DISABLE_PLATFORM_WARNINGS): Dis-
-	   able warnings during bundle install when a dependency is unused  on
-	   the current platform.
-
-       o   disable_shared_gems (BUNDLE_DISABLE_SHARED_GEMS): Stop Bundler from
-	   accessing gems installed to RubyGems' normal location.
-
-       o   disable_version_check (BUNDLE_DISABLE_VERSION_CHECK): Stop  Bundler
-	   from   checking   if  a  newer  Bundler  version  is  available  on
-	   rubygems.org.
-
-       o   force_ruby_platform (BUNDLE_FORCE_RUBY_PLATFORM): Ignore  the  cur-
-	   rent  machine's  platform and install only ruby platform gems. As a
-	   result, gems with native extensions will be compiled from source.
-
-       o   frozen (BUNDLE_FROZEN): Disallow changes to the Gemfile.  When  the
-	   Gemfile  is	changed and the lockfile has not been updated, running
-	   Bundler commands will be blocked. Defaults to true  when  --deploy-
-	   ment is used.
-
-       o   gem.push_key  (BUNDLE_GEM__PUSH_KEY):  Sets the --key parameter for
-	   gem push when using the rake release command with  a  private  gem-
-	   stash server.
-
-       o   gemfile  (BUNDLE_GEMFILE): The name of the file that bundler should
-	   use as the Gemfile. This location of this file also sets  the  root
-	   of the project, which is used to resolve relative paths in the Gem-
-	   file, among other things. By default, bundler will search  up  from
-	   the current working directory until it finds a Gemfile.
-
-       o   global_gem_cache  (BUNDLE_GLOBAL_GEM_CACHE): Whether Bundler should
-	   cache all gems globally, rather than locally to the installing Ruby
-	   installation.
-
-       o   ignore_messages (BUNDLE_IGNORE_MESSAGES): When set, no post install
-	   messages will be printed. To silence a single gem, use dot notation
-	   like ignore_messages.httparty true.
-
-       o   init_gems_rb  (BUNDLE_INIT_GEMS_RB) Generate a gems.rb instead of a
-	   Gemfile when running bundle init.
-
-       o   jobs (BUNDLE_JOBS): The number of gems Bundler can install in  par-
-	   allel. Defaults to 1.
-
-       o   no_install  (BUNDLE_NO_INSTALL): Whether bundle package should skip
-	   installing gems.
-
-       o   no_prune (BUNDLE_NO_PRUNE): Whether Bundler should  leave  outdated
-	   gems unpruned when caching.
-
-       o   only_update_to_newer_versions     (BUNDLE_ONLY_UPDATE_TO_NEWER_VER-
-	   SIONS): During bundle update, only resolve to newer versions of the
-	   gems in the lockfile.
-
-       o   path  (BUNDLE_PATH):  The  location	on disk where all gems in your
-	   bundle will be located regardless of $GEM_HOME or $GEM_PATH values.
-	   Bundle  gems not found in this location will be installed by bundle
-	   install. Defaults to Gem.dir. When --deployment is  used,  defaults
-	   to vendor/bundle.
-
-       o   path.system	(BUNDLE_PATH__SYSTEM):	Whether  Bundler  will install
-	   gems into the default system path (Gem.dir).
-
-       o   path_relative_to_cwd  (BUNDLE_PATH_RELATIVE_TO_CWD)	Makes	--path
-	   relative to the CWD instead of the Gemfile.
-
-       o   plugins (BUNDLE_PLUGINS): Enable Bundler's experimental plugin sys-
-	   tem.
-
-       o   prefer_patch (BUNDLE_PREFER_PATCH): Prefer updating	only  to  next
-	   patch  version during updates. Makes bundle update calls equivalent
-	   to bundler update --patch.
-
-       o   print_only_version_number (BUNDLE_PRINT_ONLY_VERSION_NUMBER)  Print
-	   only version number from bundler --version.
-
-       o   redirect  (BUNDLE_REDIRECT):  The  number  of redirects allowed for
-	   network requests. Defaults to 5.
-
-       o   retry (BUNDLE_RETRY): The number of times to retry  failed  network
-	   requests. Defaults to 3.
-
-       o   setup_makes_kernel_gem_public   (BUNDLE_SETUP_MAKES_KERNEL_GEM_PUB-
-	   LIC): Have Bundler.setup make the Kernel#gem  method  public,  even
-	   though RubyGems declares it as private.
-
-       o   shebang  (BUNDLE_SHEBANG):  The program name that should be invoked
-	   for generated binstubs. Defaults to the ruby install name  used  to
-	   generate the binstub.
-
-       o   silence_deprecations (BUNDLE_SILENCE_DEPRECATIONS): Whether Bundler
-	   should silence deprecation  warnings  for  behavior	that  will  be
-	   changed in the next major version.
-
-       o   silence_root_warning   (BUNDLE_SILENCE_ROOT_WARNING):  Silence  the
-	   warning Bundler prints when installing gems as root.
-
-       o   skip_default_git_sources (BUNDLE_SKIP_DEFAULT_GIT_SOURCES): Whether
-	   Bundler should skip adding default git source shortcuts to the Gem-
-	   file DSL.
-
-       o   specific_platform  (BUNDLE_SPECIFIC_PLATFORM):  Allow  bundler   to
-	   resolve for the specific running platform and store it in the lock-
-	   file, instead of only using a generic platform. A specific platform
-	   is  the exact platform triple reported by Gem::Platform.local, such
-	   as x86_64-darwin-16	or  universal-java-1.8.  On  the  other  hand,
-	   generic  platforms  are those such as ruby, mswin, or java. In this
-	   example, x86_64-darwin-16 would map to ruby and  universal-java-1.8
-	   to java.
-
-       o   ssl_ca_cert	(BUNDLE_SSL_CA_CERT): Path to a designated CA certifi-
-	   cate file or folder containing multiple  certificates  for  trusted
-	   CAs in PEM format.
-
-       o   ssl_client_cert (BUNDLE_SSL_CLIENT_CERT): Path to a designated file
-	   containing a X.509 client certificate and key in PEM format.
-
-       o   ssl_verify_mode (BUNDLE_SSL_VERIFY_MODE): The SSL verification mode
-	   Bundler uses when making HTTPS requests. Defaults to verify peer.
-
-       o   suppress_install_using_messages (BUNDLE_SUPPRESS_INSTALL_USING_MES-
-	   SAGES): Avoid printing Using ... messages during installation  when
-	   the version of a gem has not changed.
-
-       o   system_bindir  (BUNDLE_SYSTEM_BINDIR):  The location where RubyGems
-	   installs binstubs. Defaults to Gem.bindir.
-
-       o   timeout (BUNDLE_TIMEOUT): The seconds allowed before timing out for
-	   network requests. Defaults to 10.
-
-       o   unlock_source_unlocks_spec	  (BUNDLE_UNLOCK_SOURCE_UNLOCKS_SPEC):
-	   Whether running bundle update --source NAME unlocks a gem with  the
-	   given name. Defaults to true.
-
-       o   update_requires_all_flag  (BUNDLE_UPDATE_REQUIRES_ALL_FLAG) Require
-	   passing --all to bundle update when everything should  be  updated,
-	   and disallow passing no options to bundle update.
-
-       o   user_agent  (BUNDLE_USER_AGENT):  The  custom  user	agent fragment
-	   Bundler includes in API requests.
-
-       o   with (BUNDLE_WITH): A :-separated list of groups whose gems bundler
-	   should install.
-
-       o   without  (BUNDLE_WITHOUT):  A :-separated list of groups whose gems
-	   bundler should not install.
-
-
-
-       In general, you should set these settings per-application by using  the
-       applicable  flag to the bundle install(1) bundle-install.1.html or bun-
-       dle package(1) bundle-package.1.html command.
-
-       You can set them globally either via environment  variables  or	bundle
-       config,	whichever is preferable for your setup. If you use both, envi-
-       ronment variables will take preference over global settings.
-
-LOCAL GIT REPOS
-       Bundler also allows you	to  work  against  a  git  repository  locally
-       instead of using the remote version. This can be achieved by setting up
-       a local override:
-
-
-
-	   bundle config set local.GEM_NAME /path/to/local/git/repository
-
-
-
-       For example, in order to use a local Rack repository, a developer could
-       call:
-
-
-
-	   bundle config set local.rack ~/Work/git/rack
-
-
-
-       Now  instead of checking out the remote git repository, the local over-
-       ride will be used. Similar to a path source, every time the  local  git
-       repository  change, changes will be automatically picked up by Bundler.
-       This means a commit in the local git repo will update the  revision  in
-       the Gemfile.lock to the local git repo revision. This requires the same
-       attention as git submodules. Before pushing to the remote, you need  to
-       ensure the local override was pushed, otherwise you may point to a com-
-       mit that only exists in your local machine. You'll  also  need  to  CGI
-       escape your usernames and passwords as well.
-
-       Bundler	does many checks to ensure a developer won't work with invalid
-       references. Particularly, we force a developer to specify a  branch  in
-       the  Gemfile  in  order to use this feature. If the branch specified in
-       the Gemfile and the current branch in the local git repository  do  not
-       match,  Bundler	will  abort.  This  ensures that a developer is always
-       working against the correct branches, and prevents  accidental  locking
-       to a different branch.
-
-       Finally,  Bundler  also	ensures  that the current revision in the Gem-
-       file.lock exists in the local git repository. By  doing	this,  Bundler
-       forces you to fetch the latest changes in the remotes.
-
-MIRRORS OF GEM SOURCES
-       Bundler	supports  overriding gem sources with mirrors. This allows you
-       to configure rubygems.org as the gem source in your Gemfile while still
-       using your mirror to fetch gems.
-
-
-
-	   bundle config set mirror.SOURCE_URL MIRROR_URL
-
-
-
-       For  example,  to  use a mirror of rubygems.org hosted at rubygems-mir-
-       ror.org:
-
-
-
-	   bundle config set mirror.http://rubygems.org http://rubygems-mirror.org
-
-
-
-       Each mirror also provides a fallback timeout  setting.  If  the	mirror
-       does  not  respond within the fallback timeout, Bundler will try to use
-       the original server instead of the mirror.
-
-
-
-	   bundle config set mirror.SOURCE_URL.fallback_timeout TIMEOUT
-
-
-
-       For example, to fall back to rubygems.org after 3 seconds:
-
-
-
-	   bundle config set mirror.https://rubygems.org.fallback_timeout 3
-
-
-
-       The default fallback timeout is 0.1 seconds, but the setting  can  cur-
-       rently only accept whole seconds (for example, 1, 15, or 30).
-
-CREDENTIALS FOR GEM SOURCES
-       Bundler	allows	you to configure credentials for any gem source, which
-       allows you to avoid putting secrets into your Gemfile.
-
-
-
-	   bundle config set SOURCE_HOSTNAME USERNAME:PASSWORD
-
-
-
-       For example, to save the credentials of	user  claudette  for  the  gem
-       source at gems.longerous.com, you would run:
-
-
-
-	   bundle config set gems.longerous.com claudette:s00pers3krit
-
-
-
-       Or you can set the credentials as an environment variable like this:
-
-
-
-	   export BUNDLE_GEMS__LONGEROUS__COM="claudette:s00pers3krit"
-
-
-
-       For gems with a git source with HTTP(S) URL you can specify credentials
-       like so:
-
-
-
-	   bundle config set https://github.com/bundler/bundler.git username:password
-
-
-
-       Or you can set the credentials as an environment variable like so:
-
-
-
-	   export BUNDLE_GITHUB__COM=username:password
-
-
-
-       This is especially useful for private repositories  on  hosts  such  as
-       Github, where you can use personal OAuth tokens:
-
-
-
-	   export BUNDLE_GITHUB__COM=abcd0123generatedtoken:x-oauth-basic
-
-
-
-CONFIGURE BUNDLER DIRECTORIES
-       Bundler's  home,  config,  cache  and plugin directories are able to be
-       configured through environment  variables.  The	default  location  for
-       Bundler's  home	directory  is ~/.bundle, which all directories inherit
-       from by default. The following outlines the available environment vari-
-       ables and their default values
-
-
-
-	   BUNDLE_USER_HOME : $HOME/.bundle
-	   BUNDLE_USER_CACHE : $BUNDLE_USER_HOME/cache
-	   BUNDLE_USER_CONFIG : $BUNDLE_USER_HOME/config
-	   BUNDLE_USER_PLUGIN : $BUNDLE_USER_HOME/plugin
-
-
-
-
-
-
-				 January 2020		      BUNDLE-CONFIG(1)
--- ruby2.7-2.7.6.orig/man/bundle-config.ronn
+++ /dev/null
@@ -1,399 +0,0 @@
-bundle-config(1) -- Set bundler configuration options
-=====================================================
-
-## SYNOPSIS
-
-`bundle config` [list|get|set|unset] [<name> [<value>]]
-
-## DESCRIPTION
-
-This command allows you to interact with Bundler's configuration system.
-
-Bundler loads configuration settings in this order:
-
-1. Local config (`app/.bundle/config`)
-2. Environmental variables (`ENV`)
-3. Global config (`~/.bundle/config`)
-4. Bundler default config
-
-Executing `bundle config list` with will print a list of all bundler
-configuration for the current bundle, and where that configuration
-was set.
-
-Executing `bundle config get <name>` will print the value of that configuration
-setting, and where it was set.
-
-Executing `bundle config set <name> <value>` will set that configuration to the
-value specified for all bundles executed as the current user. The configuration
-will be stored in `~/.bundle/config`. If <name> already is set, <name> will be
-overridden and user will be warned.
-
-Executing `bundle config set --global <name> <value>` works the same as above.
-
-Executing `bundle config set --local <name> <value>` will set that configuration to
-the local application. The configuration will be stored in `app/.bundle/config`.
-
-Executing `bundle config unset <name>` will delete the configuration in both
-local and global sources.
-
-Executing `bundle config unset --global <name>` will delete the configuration
-only from the user configuration.
-
-Executing `bundle config unset --local <name> <value>` will delete the
-configuration only from the local application.
-
-Executing bundle with the `BUNDLE_IGNORE_CONFIG` environment variable set will
-cause it to ignore all configuration.
-
-Executing `bundle config set disable_multisource true` upgrades the warning about
-the Gemfile containing multiple primary sources to an error. Executing `bundle
-config unset disable_multisource` downgrades this error to a warning.
-
-## REMEMBERING OPTIONS
-
-Flags passed to `bundle install` or the Bundler runtime, such as `--path foo` or
-`--without production`, are remembered between commands and saved to your local
-application's configuration (normally, `./.bundle/config`).
-
-However, this will be changed in bundler 3, so it's better not to rely on this
-behavior. If these options must be remembered, it's better to set them using
-`bundle config` (e.g., `bundle config set path foo`).
-
-The options that can be configured are:
-
-* `bin`:
-   Creates a directory (defaults to `~/bin`) and place any executables from the
-   gem there. These executables run in Bundler's context. If used, you might add
-   this directory to your environment's `PATH` variable. For instance, if the
-   `rails` gem comes with a `rails` executable, this flag will create a
-   `bin/rails` executable that ensures that all referred dependencies will be
-   resolved using the bundled gems.
-
-* `deployment`:
-   In deployment mode, Bundler will 'roll-out' the bundle for
-   `production` use. Please check carefully if you want to have this option
-   enabled in `development` or `test` environments.
-
-* `path`:
-   The location to install the specified gems to. This defaults to Rubygems'
-   setting. Bundler shares this location with Rubygems, `gem install ...` will
-   have gem installed there, too. Therefore, gems installed without a
-   `--path ...` setting will show up by calling `gem list`. Accordingly, gems
-   installed to other locations will not get listed.
-
-* `without`:
-   A space-separated list of groups referencing gems to skip during installation.
-
-* `with`:
-  A space-separated list of groups referencing gems to include during installation.
-
-## BUILD OPTIONS
-
-You can use `bundle config` to give Bundler the flags to pass to the gem
-installer every time bundler tries to install a particular gem.
-
-A very common example, the `mysql` gem, requires Snow Leopard users to
-pass configuration flags to `gem install` to specify where to find the
-`mysql_config` executable.
-
-    gem install mysql -- --with-mysql-config=/usr/local/mysql/bin/mysql_config
-
-Since the specific location of that executable can change from machine
-to machine, you can specify these flags on a per-machine basis.
-
-    bundle config set build.mysql --with-mysql-config=/usr/local/mysql/bin/mysql_config
-
-After running this command, every time bundler needs to install the
-`mysql` gem, it will pass along the flags you specified.
-
-## CONFIGURATION KEYS
-
-Configuration keys in bundler have two forms: the canonical form and the
-environment variable form.
-
-For instance, passing the `--without` flag to [bundle install(1)](bundle-install.1.html)
-prevents Bundler from installing certain groups specified in the Gemfile(5). Bundler
-persists this value in `app/.bundle/config` so that calls to `Bundler.setup`
-do not try to find gems from the `Gemfile` that you didn't install. Additionally,
-subsequent calls to [bundle install(1)](bundle-install.1.html) remember this setting
-and skip those groups.
-
-The canonical form of this configuration is `"without"`. To convert the canonical
-form to the environment variable form, capitalize it, and prepend `BUNDLE_`. The
-environment variable form of `"without"` is `BUNDLE_WITHOUT`.
-
-Any periods in the configuration keys must be replaced with two underscores when
-setting it via environment variables. The configuration key `local.rack` becomes
-the environment variable `BUNDLE_LOCAL__RACK`.
-
-## LIST OF AVAILABLE KEYS
-
-The following is a list of all configuration keys and their purpose. You can
-learn more about their operation in [bundle install(1)](bundle-install.1.html).
-
-* `allow_bundler_dependency_conflicts` (`BUNDLE_ALLOW_BUNDLER_DEPENDENCY_CONFLICTS`):
-   Allow resolving to specifications that have dependencies on `bundler` that
-   are incompatible with the running Bundler version.
-* `allow_deployment_source_credential_changes` (`BUNDLE_ALLOW_DEPLOYMENT_SOURCE_CREDENTIAL_CHANGES`):
-   When in deployment mode, allow changing the credentials to a gem's source.
-   Ex: `https://some.host.com/gems/path/` -> `https://user_name:password@some.host.com/gems/path`
-* `allow_offline_install` (`BUNDLE_ALLOW_OFFLINE_INSTALL`):
-   Allow Bundler to use cached data when installing without network access.
-* `auto_clean_without_path` (`BUNDLE_AUTO_CLEAN_WITHOUT_PATH`):
-   Automatically run `bundle clean` after installing when an explicit `path`
-   has not been set and Bundler is not installing into the system gems.
-* `auto_install` (`BUNDLE_AUTO_INSTALL`):
-   Automatically run `bundle install` when gems are missing.
-* `bin` (`BUNDLE_BIN`):
-   Install executables from gems in the bundle to the specified directory.
-   Defaults to `false`.
-* `cache_all` (`BUNDLE_CACHE_ALL`):
-   Cache all gems, including path and git gems.
-* `cache_all_platforms` (`BUNDLE_CACHE_ALL_PLATFORMS`):
-   Cache gems for all platforms.
-* `cache_path` (`BUNDLE_CACHE_PATH`):
-   The directory that bundler will place cached gems in when running
-   <code>bundle package</code>, and that bundler will look in when installing gems.
-   Defaults to `vendor/cache`.
-* `clean` (`BUNDLE_CLEAN`):
-   Whether Bundler should run `bundle clean` automatically after
-   `bundle install`.
-* `console` (`BUNDLE_CONSOLE`):
-   The console that `bundle console` starts. Defaults to `irb`.
-* `default_install_uses_path` (`BUNDLE_DEFAULT_INSTALL_USES_PATH`):
-   Whether a `bundle install` without an explicit `--path` argument defaults
-   to installing gems in `.bundle`.
-* `deployment` (`BUNDLE_DEPLOYMENT`):
-   Disallow changes to the `Gemfile`. When the `Gemfile` is changed and the
-   lockfile has not been updated, running Bundler commands will be blocked.
-* `disable_checksum_validation` (`BUNDLE_DISABLE_CHECKSUM_VALIDATION`):
-   Allow installing gems even if they do not match the checksum provided by
-   RubyGems.
-* `disable_exec_load` (`BUNDLE_DISABLE_EXEC_LOAD`):
-   Stop Bundler from using `load` to launch an executable in-process in
-   `bundle exec`.
-* `disable_local_branch_check` (`BUNDLE_DISABLE_LOCAL_BRANCH_CHECK`):
-   Allow Bundler to use a local git override without a branch specified in the
-   Gemfile.
-* `disable_multisource` (`BUNDLE_DISABLE_MULTISOURCE`):
-   When set, Gemfiles containing multiple sources will produce errors
-   instead of warnings.
-   Use `bundle config unset disable_multisource` to unset.
-* `disable_platform_warnings` (`BUNDLE_DISABLE_PLATFORM_WARNINGS`):
-   Disable warnings during bundle install when a dependency is unused on the current platform.
-* `disable_shared_gems` (`BUNDLE_DISABLE_SHARED_GEMS`):
-   Stop Bundler from accessing gems installed to RubyGems' normal location.
-* `disable_version_check` (`BUNDLE_DISABLE_VERSION_CHECK`):
-   Stop Bundler from checking if a newer Bundler version is available on
-   rubygems.org.
-* `force_ruby_platform` (`BUNDLE_FORCE_RUBY_PLATFORM`):
-   Ignore the current machine's platform and install only `ruby` platform gems.
-   As a result, gems with native extensions will be compiled from source.
-* `frozen` (`BUNDLE_FROZEN`):
-   Disallow changes to the `Gemfile`. When the `Gemfile` is changed and the
-   lockfile has not been updated, running Bundler commands will be blocked.
-   Defaults to `true` when `--deployment` is used.
-* `gem.push_key` (`BUNDLE_GEM__PUSH_KEY`):
-   Sets the `--key` parameter for `gem push` when using the `rake release`
-   command with a private gemstash server.
-* `gemfile` (`BUNDLE_GEMFILE`):
-   The name of the file that bundler should use as the `Gemfile`. This location
-   of this file also sets the root of the project, which is used to resolve
-   relative paths in the `Gemfile`, among other things. By default, bundler
-   will search up from the current working directory until it finds a
-   `Gemfile`.
-* `global_gem_cache` (`BUNDLE_GLOBAL_GEM_CACHE`):
-   Whether Bundler should cache all gems globally, rather than locally to the
-   installing Ruby installation.
-* `ignore_messages` (`BUNDLE_IGNORE_MESSAGES`): When set, no post install
-   messages will be printed. To silence a single gem, use dot notation like
-   `ignore_messages.httparty true`.
-* `init_gems_rb` (`BUNDLE_INIT_GEMS_RB`)
-   Generate a `gems.rb` instead of a `Gemfile` when running `bundle init`.
-* `jobs` (`BUNDLE_JOBS`):
-   The number of gems Bundler can install in parallel. Defaults to 1.
-* `no_install` (`BUNDLE_NO_INSTALL`):
-   Whether `bundle package` should skip installing gems.
-* `no_prune` (`BUNDLE_NO_PRUNE`):
-   Whether Bundler should leave outdated gems unpruned when caching.
-* `only_update_to_newer_versions` (`BUNDLE_ONLY_UPDATE_TO_NEWER_VERSIONS`):
-   During `bundle update`, only resolve to newer versions of the gems in the
-   lockfile.
-* `path` (`BUNDLE_PATH`):
-   The location on disk where all gems in your bundle will be located regardless
-   of `$GEM_HOME` or `$GEM_PATH` values. Bundle gems not found in this location
-   will be installed by `bundle install`. Defaults to `Gem.dir`. When --deployment
-   is used, defaults to vendor/bundle.
-* `path.system` (`BUNDLE_PATH__SYSTEM`):
-   Whether Bundler will install gems into the default system path (`Gem.dir`).
-* `path_relative_to_cwd` (`BUNDLE_PATH_RELATIVE_TO_CWD`)
-   Makes `--path` relative to the CWD instead of the `Gemfile`.
-* `plugins` (`BUNDLE_PLUGINS`):
-   Enable Bundler's experimental plugin system.
-* `prefer_patch` (BUNDLE_PREFER_PATCH):
-   Prefer updating only to next patch version during updates. Makes `bundle update` calls equivalent to `bundler update --patch`.
-* `print_only_version_number` (`BUNDLE_PRINT_ONLY_VERSION_NUMBER`)
-   Print only version number from `bundler --version`.
-* `redirect` (`BUNDLE_REDIRECT`):
-   The number of redirects allowed for network requests. Defaults to `5`.
-* `retry` (`BUNDLE_RETRY`):
-   The number of times to retry failed network requests. Defaults to `3`.
-* `setup_makes_kernel_gem_public` (`BUNDLE_SETUP_MAKES_KERNEL_GEM_PUBLIC`):
-   Have `Bundler.setup` make the `Kernel#gem` method public, even though
-   RubyGems declares it as private.
-* `shebang` (`BUNDLE_SHEBANG`):
-   The program name that should be invoked for generated binstubs. Defaults to
-   the ruby install name used to generate the binstub.
-* `silence_deprecations` (`BUNDLE_SILENCE_DEPRECATIONS`):
-   Whether Bundler should silence deprecation warnings for behavior that will
-   be changed in the next major version.
-* `silence_root_warning` (`BUNDLE_SILENCE_ROOT_WARNING`):
-   Silence the warning Bundler prints when installing gems as root.
-* `skip_default_git_sources` (`BUNDLE_SKIP_DEFAULT_GIT_SOURCES`):
-   Whether Bundler should skip adding default git source shortcuts to the
-   Gemfile DSL.
-* `specific_platform` (`BUNDLE_SPECIFIC_PLATFORM`):
-   Allow bundler to resolve for the specific running platform and store it in
-   the lockfile, instead of only using a generic platform.
-   A specific platform is the exact platform triple reported by
-   `Gem::Platform.local`, such as `x86_64-darwin-16` or `universal-java-1.8`.
-   On the other hand, generic platforms are those such as `ruby`, `mswin`, or
-   `java`. In this example, `x86_64-darwin-16` would map to `ruby` and
-   `universal-java-1.8` to `java`.
-* `ssl_ca_cert` (`BUNDLE_SSL_CA_CERT`):
-   Path to a designated CA certificate file or folder containing multiple
-   certificates for trusted CAs in PEM format.
-* `ssl_client_cert` (`BUNDLE_SSL_CLIENT_CERT`):
-   Path to a designated file containing a X.509 client certificate
-   and key in PEM format.
-* `ssl_verify_mode` (`BUNDLE_SSL_VERIFY_MODE`):
-   The SSL verification mode Bundler uses when making HTTPS requests.
-   Defaults to verify peer.
-* `suppress_install_using_messages` (`BUNDLE_SUPPRESS_INSTALL_USING_MESSAGES`):
-   Avoid printing `Using ...` messages during installation when the version of
-   a gem has not changed.
-* `system_bindir` (`BUNDLE_SYSTEM_BINDIR`):
-   The location where RubyGems installs binstubs. Defaults to `Gem.bindir`.
-* `timeout` (`BUNDLE_TIMEOUT`):
-   The seconds allowed before timing out for network requests. Defaults to `10`.
-* `unlock_source_unlocks_spec` (`BUNDLE_UNLOCK_SOURCE_UNLOCKS_SPEC`):
-   Whether running `bundle update --source NAME` unlocks a gem with the given
-   name. Defaults to `true`.
-* `update_requires_all_flag` (`BUNDLE_UPDATE_REQUIRES_ALL_FLAG`)
-   Require passing `--all` to `bundle update` when everything should be updated,
-   and disallow passing no options to `bundle update`.
-* `user_agent` (`BUNDLE_USER_AGENT`):
-   The custom user agent fragment Bundler includes in API requests.
-* `with` (`BUNDLE_WITH`):
-   A `:`-separated list of groups whose gems bundler should install.
-* `without` (`BUNDLE_WITHOUT`):
-   A `:`-separated list of groups whose gems bundler should not install.
-
-In general, you should set these settings per-application by using the applicable
-flag to the [bundle install(1)](bundle-install.1.html) or [bundle package(1)](bundle-package.1.html) command.
-
-You can set them globally either via environment variables or `bundle config`,
-whichever is preferable for your setup. If you use both, environment variables
-will take preference over global settings.
-
-## LOCAL GIT REPOS
-
-Bundler also allows you to work against a git repository locally
-instead of using the remote version. This can be achieved by setting
-up a local override:
-
-    bundle config set local.GEM_NAME /path/to/local/git/repository
-
-For example, in order to use a local Rack repository, a developer could call:
-
-    bundle config set local.rack ~/Work/git/rack
-
-Now instead of checking out the remote git repository, the local
-override will be used. Similar to a path source, every time the local
-git repository change, changes will be automatically picked up by
-Bundler. This means a commit in the local git repo will update the
-revision in the `Gemfile.lock` to the local git repo revision. This
-requires the same attention as git submodules. Before pushing to
-the remote, you need to ensure the local override was pushed, otherwise
-you may point to a commit that only exists in your local machine.
-You'll also need to CGI escape your usernames and passwords as well.
-
-Bundler does many checks to ensure a developer won't work with
-invalid references. Particularly, we force a developer to specify
-a branch in the `Gemfile` in order to use this feature. If the branch
-specified in the `Gemfile` and the current branch in the local git
-repository do not match, Bundler will abort. This ensures that
-a developer is always working against the correct branches, and prevents
-accidental locking to a different branch.
-
-Finally, Bundler also ensures that the current revision in the
-`Gemfile.lock` exists in the local git repository. By doing this, Bundler
-forces you to fetch the latest changes in the remotes.
-
-## MIRRORS OF GEM SOURCES
-
-Bundler supports overriding gem sources with mirrors. This allows you to
-configure rubygems.org as the gem source in your Gemfile while still using your
-mirror to fetch gems.
-
-    bundle config set mirror.SOURCE_URL MIRROR_URL
-
-For example, to use a mirror of rubygems.org hosted at rubygems-mirror.org:
-
-    bundle config set mirror.http://rubygems.org http://rubygems-mirror.org
-
-Each mirror also provides a fallback timeout setting. If the mirror does not
-respond within the fallback timeout, Bundler will try to use the original
-server instead of the mirror.
-
-    bundle config set mirror.SOURCE_URL.fallback_timeout TIMEOUT
-
-For example, to fall back to rubygems.org after 3 seconds:
-
-    bundle config set mirror.https://rubygems.org.fallback_timeout 3
-
-The default fallback timeout is 0.1 seconds, but the setting can currently
-only accept whole seconds (for example, 1, 15, or 30).
-
-## CREDENTIALS FOR GEM SOURCES
-
-Bundler allows you to configure credentials for any gem source, which allows
-you to avoid putting secrets into your Gemfile.
-
-    bundle config set SOURCE_HOSTNAME USERNAME:PASSWORD
-
-For example, to save the credentials of user `claudette` for the gem source at
-`gems.longerous.com`, you would run:
-
-    bundle config set gems.longerous.com claudette:s00pers3krit
-
-Or you can set the credentials as an environment variable like this:
-
-    export BUNDLE_GEMS__LONGEROUS__COM="claudette:s00pers3krit"
-
-For gems with a git source with HTTP(S) URL you can specify credentials like so:
-
-    bundle config set https://github.com/bundler/bundler.git username:password
-
-Or you can set the credentials as an environment variable like so:
-
-    export BUNDLE_GITHUB__COM=username:password
-
-This is especially useful for private repositories on hosts such as Github,
-where you can use personal OAuth tokens:
-
-    export BUNDLE_GITHUB__COM=abcd0123generatedtoken:x-oauth-basic
-
-
-## CONFIGURE BUNDLER DIRECTORIES
-
-Bundler's home, config, cache and plugin directories are able to be configured
-through environment variables. The default location for Bundler's home directory is
-`~/.bundle`, which all directories inherit from by default. The following
-outlines the available environment variables and their default values
-
-    BUNDLE_USER_HOME : $HOME/.bundle
-    BUNDLE_USER_CACHE : $BUNDLE_USER_HOME/cache
-    BUNDLE_USER_CONFIG : $BUNDLE_USER_HOME/config
-    BUNDLE_USER_PLUGIN : $BUNDLE_USER_HOME/plugin
-
--- ruby2.7-2.7.6.orig/man/bundle-doctor.1
+++ /dev/null
@@ -1,44 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-DOCTOR" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-doctor\fR \- Checks the bundle for common problems
-.
-.SH "SYNOPSIS"
-\fBbundle doctor\fR [\-\-quiet] [\-\-gemfile=GEMFILE]
-.
-.SH "DESCRIPTION"
-Checks your Gemfile and gem environment for common problems\. If issues are detected, Bundler prints them and exits status 1\. Otherwise, Bundler prints a success message and exits status 0\.
-.
-.P
-Examples of common problems caught by bundle\-doctor include:
-.
-.IP "\(bu" 4
-Invalid Bundler settings
-.
-.IP "\(bu" 4
-Mismatched Ruby versions
-.
-.IP "\(bu" 4
-Mismatched platforms
-.
-.IP "\(bu" 4
-Uninstalled gems
-.
-.IP "\(bu" 4
-Missing dependencies
-.
-.IP "" 0
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-quiet\fR
-Only output warnings and errors\.
-.
-.TP
-\fB\-\-gemfile=<gemfile>\fR
-The location of the Gemfile(5) which Bundler should use\. This defaults to a Gemfile(5) in the current working directory\. In general, Bundler will assume that the location of the Gemfile(5) is also the project\'s root and will try to find \fBGemfile\.lock\fR and \fBvendor/cache\fR relative to this location\.
-
--- ruby2.7-2.7.6.orig/man/bundle-doctor.1.txt
+++ /dev/null
@@ -1,44 +0,0 @@
-BUNDLE-DOCTOR(1)					      BUNDLE-DOCTOR(1)
-
-
-
-NAME
-       bundle-doctor - Checks the bundle for common problems
-
-SYNOPSIS
-       bundle doctor [--quiet] [--gemfile=GEMFILE]
-
-DESCRIPTION
-       Checks  your Gemfile and gem environment for common problems. If issues
-       are detected, Bundler  prints  them  and  exits	status	1.  Otherwise,
-       Bundler prints a success message and exits status 0.
-
-       Examples of common problems caught by bundle-doctor include:
-
-       o   Invalid Bundler settings
-
-       o   Mismatched Ruby versions
-
-       o   Mismatched platforms
-
-       o   Uninstalled gems
-
-       o   Missing dependencies
-
-
-
-OPTIONS
-       --quiet
-	      Only output warnings and errors.
-
-       --gemfile=<gemfile>
-	      The  location  of  the Gemfile(5) which Bundler should use. This
-	      defaults to a Gemfile(5) in the current  working	directory.  In
-	      general, Bundler will assume that the location of the Gemfile(5)
-	      is also the project's root and will try to find Gemfile.lock and
-	      vendor/cache relative to this location.
-
-
-
-
-				 January 2020		      BUNDLE-DOCTOR(1)
--- ruby2.7-2.7.6.orig/man/bundle-doctor.ronn
+++ /dev/null
@@ -1,33 +0,0 @@
-bundle-doctor(1) -- Checks the bundle for common problems
-=========================================================
-
-## SYNOPSIS
-
-`bundle doctor` [--quiet]
-                [--gemfile=GEMFILE]
-
-## DESCRIPTION
-
-Checks your Gemfile and gem environment for common problems. If issues
-are detected, Bundler prints them and exits status 1. Otherwise,
-Bundler prints a success message and exits status 0.
-
-Examples of common problems caught by bundle-doctor include:
-
-* Invalid Bundler settings
-* Mismatched Ruby versions
-* Mismatched platforms
-* Uninstalled gems
-* Missing dependencies
-
-## OPTIONS
-
-* `--quiet`:
-  Only output warnings and errors.
-
-* `--gemfile=<gemfile>`:
-  The location of the Gemfile(5) which Bundler should use. This defaults
-  to a Gemfile(5) in the current working directory. In general, Bundler
-  will assume that the location of the Gemfile(5) is also the project's
-  root and will try to find `Gemfile.lock` and `vendor/cache` relative
-  to this location.
--- ruby2.7-2.7.6.orig/man/bundle-exec.1
+++ /dev/null
@@ -1,165 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-EXEC" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-exec\fR \- Execute a command in the context of the bundle
-.
-.SH "SYNOPSIS"
-\fBbundle exec\fR [\-\-keep\-file\-descriptors] \fIcommand\fR
-.
-.SH "DESCRIPTION"
-This command executes the command, making all gems specified in the [\fBGemfile(5)\fR][Gemfile(5)] available to \fBrequire\fR in Ruby programs\.
-.
-.P
-Essentially, if you would normally have run something like \fBrspec spec/my_spec\.rb\fR, and you want to use the gems specified in the [\fBGemfile(5)\fR][Gemfile(5)] and installed via bundle install(1) \fIbundle\-install\.1\.html\fR, you should run \fBbundle exec rspec spec/my_spec\.rb\fR\.
-.
-.P
-Note that \fBbundle exec\fR does not require that an executable is available on your shell\'s \fB$PATH\fR\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-keep\-file\-descriptors\fR
-Exec in Ruby 2\.0 began discarding non\-standard file descriptors\. When this flag is passed, exec will revert to the 1\.9 behaviour of passing all file descriptors to the new process\.
-.
-.SH "BUNDLE INSTALL \-\-BINSTUBS"
-If you use the \fB\-\-binstubs\fR flag in bundle install(1) \fIbundle\-install\.1\.html\fR, Bundler will automatically create a directory (which defaults to \fBapp_root/bin\fR) containing all of the executables available from gems in the bundle\.
-.
-.P
-After using \fB\-\-binstubs\fR, \fBbin/rspec spec/my_spec\.rb\fR is identical to \fBbundle exec rspec spec/my_spec\.rb\fR\.
-.
-.SH "ENVIRONMENT MODIFICATIONS"
-\fBbundle exec\fR makes a number of changes to the shell environment, then executes the command you specify in full\.
-.
-.IP "\(bu" 4
-make sure that it\'s still possible to shell out to \fBbundle\fR from inside a command invoked by \fBbundle exec\fR (using \fB$BUNDLE_BIN_PATH\fR)
-.
-.IP "\(bu" 4
-put the directory containing executables (like \fBrails\fR, \fBrspec\fR, \fBrackup\fR) for your bundle on \fB$PATH\fR
-.
-.IP "\(bu" 4
-make sure that if bundler is invoked in the subshell, it uses the same \fBGemfile\fR (by setting \fBBUNDLE_GEMFILE\fR)
-.
-.IP "\(bu" 4
-add \fB\-rbundler/setup\fR to \fB$RUBYOPT\fR, which makes sure that Ruby programs invoked in the subshell can see the gems in the bundle
-.
-.IP "" 0
-.
-.P
-It also modifies Rubygems:
-.
-.IP "\(bu" 4
-disallow loading additional gems not in the bundle
-.
-.IP "\(bu" 4
-modify the \fBgem\fR method to be a no\-op if a gem matching the requirements is in the bundle, and to raise a \fBGem::LoadError\fR if it\'s not
-.
-.IP "\(bu" 4
-Define \fBGem\.refresh\fR to be a no\-op, since the source index is always frozen when using bundler, and to prevent gems from the system leaking into the environment
-.
-.IP "\(bu" 4
-Override \fBGem\.bin_path\fR to use the gems in the bundle, making system executables work
-.
-.IP "\(bu" 4
-Add all gems in the bundle into Gem\.loaded_specs
-.
-.IP "" 0
-.
-.P
-Finally, \fBbundle exec\fR also implicitly modifies \fBGemfile\.lock\fR if the lockfile and the Gemfile do not match\. Bundler needs the Gemfile to determine things such as a gem\'s groups, \fBautorequire\fR, and platforms, etc\., and that information isn\'t stored in the lockfile\. The Gemfile and lockfile must be synced in order to \fBbundle exec\fR successfully, so \fBbundle exec\fR updates the lockfile beforehand\.
-.
-.SS "Loading"
-By default, when attempting to \fBbundle exec\fR to a file with a ruby shebang, Bundler will \fBKernel\.load\fR that file instead of using \fBKernel\.exec\fR\. For the vast majority of cases, this is a performance improvement\. In a rare few cases, this could cause some subtle side\-effects (such as dependence on the exact contents of \fB$0\fR or \fB__FILE__\fR) and the optimization can be disabled by enabling the \fBdisable_exec_load\fR setting\.
-.
-.SS "Shelling out"
-Any Ruby code that opens a subshell (like \fBsystem\fR, backticks, or \fB%x{}\fR) will automatically use the current Bundler environment\. If you need to shell out to a Ruby command that is not part of your current bundle, use the \fBwith_clean_env\fR method with a block\. Any subshells created inside the block will be given the environment present before Bundler was activated\. For example, Homebrew commands run Ruby, but don\'t work inside a bundle:
-.
-.IP "" 4
-.
-.nf
-
-Bundler\.with_clean_env do
-  `brew install wget`
-end
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Using \fBwith_clean_env\fR is also necessary if you are shelling out to a different bundle\. Any Bundler commands run in a subshell will inherit the current Gemfile, so commands that need to run in the context of a different bundle also need to use \fBwith_clean_env\fR\.
-.
-.IP "" 4
-.
-.nf
-
-Bundler\.with_clean_env do
-  Dir\.chdir "/other/bundler/project" do
-    `bundle exec \./script`
-  end
-end
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Bundler provides convenience helpers that wrap \fBsystem\fR and \fBexec\fR, and they can be used like this:
-.
-.IP "" 4
-.
-.nf
-
-Bundler\.clean_system(\'brew install wget\')
-Bundler\.clean_exec(\'brew install wget\')
-.
-.fi
-.
-.IP "" 0
-.
-.SH "RUBYGEMS PLUGINS"
-At present, the Rubygems plugin system requires all files named \fBrubygems_plugin\.rb\fR on the load path of \fIany\fR installed gem when any Ruby code requires \fBrubygems\.rb\fR\. This includes executables installed into the system, like \fBrails\fR, \fBrackup\fR, and \fBrspec\fR\.
-.
-.P
-Since Rubygems plugins can contain arbitrary Ruby code, they commonly end up activating themselves or their dependencies\.
-.
-.P
-For instance, the \fBgemcutter 0\.5\fR gem depended on \fBjson_pure\fR\. If you had that version of gemcutter installed (even if you \fIalso\fR had a newer version without this problem), Rubygems would activate \fBgemcutter 0\.5\fR and \fBjson_pure <latest>\fR\.
-.
-.P
-If your Gemfile(5) also contained \fBjson_pure\fR (or a gem with a dependency on \fBjson_pure\fR), the latest version on your system might conflict with the version in your Gemfile(5), or the snapshot version in your \fBGemfile\.lock\fR\.
-.
-.P
-If this happens, bundler will say:
-.
-.IP "" 4
-.
-.nf
-
-You have already activated json_pure 1\.4\.6 but your Gemfile
-requires json_pure 1\.4\.3\. Consider using bundle exec\.
-.
-.fi
-.
-.IP "" 0
-.
-.P
-In this situation, you almost certainly want to remove the underlying gem with the problematic gem plugin\. In general, the authors of these plugins (in this case, the \fBgemcutter\fR gem) have released newer versions that are more careful in their plugins\.
-.
-.P
-You can find a list of all the gems containing gem plugins by running
-.
-.IP "" 4
-.
-.nf
-
-ruby \-rrubygems \-e "puts Gem\.find_files(\'rubygems_plugin\.rb\')"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-At the very least, you should remove all but the newest version of each gem plugin, and also remove all gem plugins that you aren\'t using (\fBgem uninstall gem_name\fR)\.
--- ruby2.7-2.7.6.orig/man/bundle-exec.1.txt
+++ /dev/null
@@ -1,178 +0,0 @@
-BUNDLE-EXEC(1)							BUNDLE-EXEC(1)
-
-
-
-NAME
-       bundle-exec - Execute a command in the context of the bundle
-
-SYNOPSIS
-       bundle exec [--keep-file-descriptors] command
-
-DESCRIPTION
-       This  command  executes	the  command, making all gems specified in the
-       [Gemfile(5)][Gemfile(5)] available to require in Ruby programs.
-
-       Essentially, if you  would  normally  have  run	something  like  rspec
-       spec/my_spec.rb,  and  you  want to use the gems specified in the [Gem-
-       file(5)][Gemfile(5)]  and  installed   via   bundle   install(1)   bun-
-       dle-install.1.html, you should run bundle exec rspec spec/my_spec.rb.
-
-       Note  that bundle exec does not require that an executable is available
-       on your shell's $PATH.
-
-OPTIONS
-       --keep-file-descriptors
-	      Exec in Ruby 2.0 began discarding non-standard file descriptors.
-	      When  this flag is passed, exec will revert to the 1.9 behaviour
-	      of passing all file descriptors to the new process.
-
-BUNDLE INSTALL --BINSTUBS
-       If  you	use  the   --binstubs	flag   in   bundle   install(1)   bun-
-       dle-install.1.html,  Bundler  will  automatically  create  a  directory
-       (which defaults to app_root/bin)  containing  all  of  the  executables
-       available from gems in the bundle.
-
-       After  using --binstubs, bin/rspec spec/my_spec.rb is identical to bun-
-       dle exec rspec spec/my_spec.rb.
-
-ENVIRONMENT MODIFICATIONS
-       bundle exec makes a number of changes to the  shell  environment,  then
-       executes the command you specify in full.
-
-       o   make  sure  that  it's  still  possible to shell out to bundle from
-	   inside a command invoked by bundle exec (using $BUNDLE_BIN_PATH)
-
-       o   put	the  directory	containing  executables  (like	rails,	rspec,
-	   rackup) for your bundle on $PATH
-
-       o   make  sure  that if bundler is invoked in the subshell, it uses the
-	   same Gemfile (by setting BUNDLE_GEMFILE)
-
-       o   add -rbundler/setup to $RUBYOPT, which makes sure  that  Ruby  pro-
-	   grams invoked in the subshell can see the gems in the bundle
-
-
-
-       It also modifies Rubygems:
-
-       o   disallow loading additional gems not in the bundle
-
-       o   modify  the gem method to be a no-op if a gem matching the require-
-	   ments is in the bundle, and to raise a Gem::LoadError if it's not
-
-       o   Define Gem.refresh to be a no-op, since the source index is	always
-	   frozen  when  using	bundler,  and  to prevent gems from the system
-	   leaking into the environment
-
-       o   Override Gem.bin_path to use the gems in the bundle, making	system
-	   executables work
-
-       o   Add all gems in the bundle into Gem.loaded_specs
-
-
-
-       Finally, bundle exec also implicitly modifies Gemfile.lock if the lock-
-       file and the Gemfile do not match. Bundler needs the Gemfile to	deter-
-       mine  things  such as a gem's groups, autorequire, and platforms, etc.,
-       and that information isn't stored in  the  lockfile.  The  Gemfile  and
-       lockfile must be synced in order to bundle exec successfully, so bundle
-       exec updates the lockfile beforehand.
-
-   Loading
-       By default, when attempting to bundle exec to a file with a  ruby  she-
-       bang,  Bundler will Kernel.load that file instead of using Kernel.exec.
-       For the vast majority of cases, this is a performance improvement. In a
-       rare  few  cases,  this	could  cause some subtle side-effects (such as
-       dependence on the exact contents of $0 or __FILE__) and	the  optimiza-
-       tion can be disabled by enabling the disable_exec_load setting.
-
-   Shelling out
-       Any  Ruby  code that opens a subshell (like system, backticks, or %x{})
-       will automatically use the current Bundler environment. If you need  to
-       shell  out  to  a Ruby command that is not part of your current bundle,
-       use the with_clean_env method  with  a  block.  Any  subshells  created
-       inside  the  block will be given the environment present before Bundler
-       was activated. For example, Homebrew commands run Ruby, but don't  work
-       inside a bundle:
-
-
-
-	   Bundler.with_clean_env do
-	     `brew install wget`
-	   end
-
-
-
-       Using  with_clean_env  is  also	necessary if you are shelling out to a
-       different bundle. Any Bundler commands run in a subshell  will  inherit
-       the  current  Gemfile, so commands that need to run in the context of a
-       different bundle also need to use with_clean_env.
-
-
-
-	   Bundler.with_clean_env do
-	     Dir.chdir "/other/bundler/project" do
-	       `bundle exec ./script`
-	     end
-	   end
-
-
-
-       Bundler provides convenience helpers that wrap  system  and  exec,  and
-       they can be used like this:
-
-
-
-	   Bundler.clean_system('brew install wget')
-	   Bundler.clean_exec('brew install wget')
-
-
-
-RUBYGEMS PLUGINS
-       At  present,  the  Rubygems  plugin  system  requires  all  files named
-       rubygems_plugin.rb on the load path of any installed gem when any  Ruby
-       code requires rubygems.rb. This includes executables installed into the
-       system, like rails, rackup, and rspec.
-
-       Since Rubygems plugins can contain arbitrary Ruby code,	they  commonly
-       end up activating themselves or their dependencies.
-
-       For  instance,  the gemcutter 0.5 gem depended on json_pure. If you had
-       that version of gemcutter installed (even if you also had a newer  ver-
-       sion  without  this problem), Rubygems would activate gemcutter 0.5 and
-       json_pure <latest>.
-
-       If your Gemfile(5) also contained json_pure (or a gem with a dependency
-       on  json_pure),	the  latest version on your system might conflict with
-       the version in your Gemfile(5), or the snapshot version	in  your  Gem-
-       file.lock.
-
-       If this happens, bundler will say:
-
-
-
-	   You have already activated json_pure 1.4.6 but your Gemfile
-	   requires json_pure 1.4.3. Consider using bundle exec.
-
-
-
-       In  this  situation, you almost certainly want to remove the underlying
-       gem with the problematic gem plugin. In general, the authors  of  these
-       plugins	(in this case, the gemcutter gem) have released newer versions
-       that are more careful in their plugins.
-
-       You can find a list of all the gems containing gem plugins by running
-
-
-
-	   ruby -rrubygems -e "puts Gem.find_files('rubygems_plugin.rb')"
-
-
-
-       At the very least, you should remove all but the newest version of each
-       gem  plugin, and also remove all gem plugins that you aren't using (gem
-       uninstall gem_name).
-
-
-
-				 January 2020			BUNDLE-EXEC(1)
--- ruby2.7-2.7.6.orig/man/bundle-exec.ronn
+++ /dev/null
@@ -1,152 +0,0 @@
-bundle-exec(1) -- Execute a command in the context of the bundle
-================================================================
-
-## SYNOPSIS
-
-`bundle exec` [--keep-file-descriptors] <command>
-
-## DESCRIPTION
-
-This command executes the command, making all gems specified in the
-[`Gemfile(5)`][Gemfile(5)] available to `require` in Ruby programs.
-
-Essentially, if you would normally have run something like
-`rspec spec/my_spec.rb`, and you want to use the gems specified
-in the [`Gemfile(5)`][Gemfile(5)] and installed via [bundle install(1)](bundle-install.1.html), you
-should run `bundle exec rspec spec/my_spec.rb`.
-
-Note that `bundle exec` does not require that an executable is
-available on your shell's `$PATH`.
-
-## OPTIONS
-
-* `--keep-file-descriptors`:
-  Exec in Ruby 2.0 began discarding non-standard file descriptors. When this
-  flag is passed, exec will revert to the 1.9 behaviour of passing all file
-  descriptors to the new process.
-
-## BUNDLE INSTALL --BINSTUBS
-
-If you use the `--binstubs` flag in [bundle install(1)](bundle-install.1.html), Bundler will
-automatically create a directory (which defaults to `app_root/bin`)
-containing all of the executables available from gems in the bundle.
-
-After using `--binstubs`, `bin/rspec spec/my_spec.rb` is identical
-to `bundle exec rspec spec/my_spec.rb`.
-
-## ENVIRONMENT MODIFICATIONS
-
-`bundle exec` makes a number of changes to the shell environment,
-then executes the command you specify in full.
-
-* make sure that it's still possible to shell out to `bundle`
-  from inside a command invoked by `bundle exec` (using
-  `$BUNDLE_BIN_PATH`)
-* put the directory containing executables (like `rails`, `rspec`,
-  `rackup`) for your bundle on `$PATH`
-* make sure that if bundler is invoked in the subshell, it uses
-  the same `Gemfile` (by setting `BUNDLE_GEMFILE`)
-* add `-rbundler/setup` to `$RUBYOPT`, which makes sure that
-  Ruby programs invoked in the subshell can see the gems in
-  the bundle
-
-It also modifies Rubygems:
-
-* disallow loading additional gems not in the bundle
-* modify the `gem` method to be a no-op if a gem matching
-  the requirements is in the bundle, and to raise a
-  `Gem::LoadError` if it's not
-* Define `Gem.refresh` to be a no-op, since the source
-  index is always frozen when using bundler, and to
-  prevent gems from the system leaking into the environment
-* Override `Gem.bin_path` to use the gems in the bundle,
-  making system executables work
-* Add all gems in the bundle into Gem.loaded_specs
-
-Finally, `bundle exec` also implicitly modifies `Gemfile.lock` if the lockfile
-and the Gemfile do not match. Bundler needs the Gemfile to determine things
-such as a gem's groups, `autorequire`, and platforms, etc., and that
-information isn't stored in the lockfile. The Gemfile and lockfile must be
-synced in order to `bundle exec` successfully, so `bundle exec`
-updates the lockfile beforehand.
-
-### Loading
-
-By default, when attempting to `bundle exec` to a file with a ruby shebang,
-Bundler will `Kernel.load` that file instead of using `Kernel.exec`. For the
-vast majority of cases, this is a performance improvement. In a rare few cases,
-this could cause some subtle side-effects (such as dependence on the exact
-contents of `$0` or `__FILE__`) and the optimization can be disabled by enabling
-the `disable_exec_load` setting.
-
-### Shelling out
-
-Any Ruby code that opens a subshell (like `system`, backticks, or `%x{}`) will
-automatically use the current Bundler environment. If you need to shell out to
-a Ruby command that is not part of your current bundle, use the
-`with_clean_env` method with a block. Any subshells created inside the block
-will be given the environment present before Bundler was activated. For
-example, Homebrew commands run Ruby, but don't work inside a bundle:
-
-    Bundler.with_clean_env do
-      `brew install wget`
-    end
-
-Using `with_clean_env` is also necessary if you are shelling out to a different
-bundle. Any Bundler commands run in a subshell will inherit the current
-Gemfile, so commands that need to run in the context of a different bundle also
-need to use `with_clean_env`.
-
-    Bundler.with_clean_env do
-      Dir.chdir "/other/bundler/project" do
-        `bundle exec ./script`
-      end
-    end
-
-Bundler provides convenience helpers that wrap `system` and `exec`, and they
-can be used like this:
-
-    Bundler.clean_system('brew install wget')
-    Bundler.clean_exec('brew install wget')
-
-
-## RUBYGEMS PLUGINS
-
-At present, the Rubygems plugin system requires all files
-named `rubygems_plugin.rb` on the load path of _any_ installed
-gem when any Ruby code requires `rubygems.rb`. This includes
-executables installed into the system, like `rails`, `rackup`,
-and `rspec`.
-
-Since Rubygems plugins can contain arbitrary Ruby code, they
-commonly end up activating themselves or their dependencies.
-
-For instance, the `gemcutter 0.5` gem depended on `json_pure`.
-If you had that version of gemcutter installed (even if
-you _also_ had a newer version without this problem), Rubygems
-would activate `gemcutter 0.5` and `json_pure <latest>`.
-
-If your Gemfile(5) also contained `json_pure` (or a gem
-with a dependency on `json_pure`), the latest version on
-your system might conflict with the version in your
-Gemfile(5), or the snapshot version in your `Gemfile.lock`.
-
-If this happens, bundler will say:
-
-    You have already activated json_pure 1.4.6 but your Gemfile
-    requires json_pure 1.4.3. Consider using bundle exec.
-
-In this situation, you almost certainly want to remove the
-underlying gem with the problematic gem plugin. In general,
-the authors of these plugins (in this case, the `gemcutter`
-gem) have released newer versions that are more careful in
-their plugins.
-
-You can find a list of all the gems containing gem plugins
-by running
-
-    ruby -rrubygems -e "puts Gem.find_files('rubygems_plugin.rb')"
-
-At the very least, you should remove all but the newest
-version of each gem plugin, and also remove all gem plugins
-that you aren't using (`gem uninstall gem_name`).
--- ruby2.7-2.7.6.orig/man/bundle-gem.1
+++ /dev/null
@@ -1,80 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-GEM" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-gem\fR \- Generate a project skeleton for creating a rubygem
-.
-.SH "SYNOPSIS"
-\fBbundle gem\fR \fIGEM_NAME\fR \fIOPTIONS\fR
-.
-.SH "DESCRIPTION"
-Generates a directory named \fBGEM_NAME\fR with a \fBRakefile\fR, \fBGEM_NAME\.gemspec\fR, and other supporting files and directories that can be used to develop a rubygem with that name\.
-.
-.P
-Run \fBrake \-T\fR in the resulting project for a list of Rake tasks that can be used to test and publish the gem to rubygems\.org\.
-.
-.P
-The generated project skeleton can be customized with OPTIONS, as explained below\. Note that these options can also be specified via Bundler\'s global configuration file using the following names:
-.
-.IP "\(bu" 4
-\fBgem\.coc\fR
-.
-.IP "\(bu" 4
-\fBgem\.mit\fR
-.
-.IP "\(bu" 4
-\fBgem\.test\fR
-.
-.IP "" 0
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-exe\fR or \fB\-b\fR or \fB\-\-bin\fR
-Specify that Bundler should create a binary executable (as \fBexe/GEM_NAME\fR) in the generated rubygem project\. This binary will also be added to the \fBGEM_NAME\.gemspec\fR manifest\. This behavior is disabled by default\.
-.
-.TP
-\fB\-\-no\-exe\fR
-Do not create a binary (overrides \fB\-\-exe\fR specified in the global config)\.
-.
-.TP
-\fB\-\-coc\fR
-Add a \fBCODE_OF_CONDUCT\.md\fR file to the root of the generated project\. If this option is unspecified, an interactive prompt will be displayed and the answer will be saved in Bundler\'s global config for future \fBbundle gem\fR use\.
-.
-.TP
-\fB\-\-no\-coc\fR
-Do not create a \fBCODE_OF_CONDUCT\.md\fR (overrides \fB\-\-coc\fR specified in the global config)\.
-.
-.TP
-\fB\-\-ext\fR
-Add boilerplate for C extension code to the generated project\. This behavior is disabled by default\.
-.
-.TP
-\fB\-\-no\-ext\fR
-Do not add C extension code (overrides \fB\-\-ext\fR specified in the global config)\.
-.
-.TP
-\fB\-\-mit\fR
-Add an MIT license to a \fBLICENSE\.txt\fR file in the root of the generated project\. Your name from the global git config is used for the copyright statement\. If this option is unspecified, an interactive prompt will be displayed and the answer will be saved in Bundler\'s global config for future \fBbundle gem\fR use\.
-.
-.TP
-\fB\-\-no\-mit\fR
-Do not create a \fBLICENSE\.txt\fR (overrides \fB\-\-mit\fR specified in the global config)\.
-.
-.TP
-\fB\-t\fR, \fB\-\-test=minitest\fR, \fB\-\-test=rspec\fR
-Specify the test framework that Bundler should use when generating the project\. Acceptable values are \fBminitest\fR and \fBrspec\fR\. The \fBGEM_NAME\.gemspec\fR will be configured and a skeleton test/spec directory will be created based on this option\. If this option is unspecified, an interactive prompt will be displayed and the answer will be saved in Bundler\'s global config for future \fBbundle gem\fR use\. If no option is specified, the default testing framework is RSpec\.
-.
-.TP
-\fB\-e\fR, \fB\-\-edit[=EDITOR]\fR
-Open the resulting GEM_NAME\.gemspec in EDITOR, or the default editor if not specified\. The default is \fB$BUNDLER_EDITOR\fR, \fB$VISUAL\fR, or \fB$EDITOR\fR\.
-.
-.SH "SEE ALSO"
-.
-.IP "\(bu" 4
-bundle config(1) \fIbundle\-config\.1\.html\fR
-.
-.IP "" 0
-
--- ruby2.7-2.7.6.orig/man/bundle-gem.1.txt
+++ /dev/null
@@ -1,91 +0,0 @@
-BUNDLE-GEM(1)							 BUNDLE-GEM(1)
-
-
-
-NAME
-       bundle-gem - Generate a project skeleton for creating a rubygem
-
-SYNOPSIS
-       bundle gem GEM_NAME OPTIONS
-
-DESCRIPTION
-       Generates a directory named GEM_NAME with a Rakefile, GEM_NAME.gemspec,
-       and other supporting files and directories that can be used to  develop
-       a rubygem with that name.
-
-       Run  rake -T in the resulting project for a list of Rake tasks that can
-       be used to test and publish the gem to rubygems.org.
-
-       The generated project skeleton  can  be	customized  with  OPTIONS,  as
-       explained  below.  Note	that  these  options can also be specified via
-       Bundler's global configuration file using the following names:
-
-       o   gem.coc
-
-       o   gem.mit
-
-       o   gem.test
-
-
-
-OPTIONS
-       --exe or -b or --bin
-	      Specify that Bundler  should  create  a  binary  executable  (as
-	      exe/GEM_NAME) in the generated rubygem project. This binary will
-	      also be added to the GEM_NAME.gemspec manifest. This behavior is
-	      disabled by default.
-
-       --no-exe
-	      Do  not create a binary (overrides --exe specified in the global
-	      config).
-
-       --coc  Add a CODE_OF_CONDUCT.md file  to  the  root  of	the  generated
-	      project.	If  this  option is unspecified, an interactive prompt
-	      will be displayed and the answer	will  be  saved  in  Bundler's
-	      global config for future bundle gem use.
-
-       --no-coc
-	      Do not create a CODE_OF_CONDUCT.md (overrides --coc specified in
-	      the global config).
-
-       --ext  Add boilerplate for C extension code to the  generated  project.
-	      This behavior is disabled by default.
-
-       --no-ext
-	      Do  not  add  C extension code (overrides --ext specified in the
-	      global config).
-
-       --mit  Add an MIT license to a LICENSE.txt file in the root of the gen-
-	      erated project. Your name from the global git config is used for
-	      the copyright statement.	If  this  option  is  unspecified,  an
-	      interactive  prompt  will  be  displayed	and the answer will be
-	      saved in Bundler's global config for future bundle gem use.
-
-       --no-mit
-	      Do not create a LICENSE.txt (overrides --mit  specified  in  the
-	      global config).
-
-       -t, --test=minitest, --test=rspec
-	      Specify the test framework that Bundler should use when generat-
-	      ing the project. Acceptable values are minitest and  rspec.  The
-	      GEM_NAME.gemspec	will  be  configured  and a skeleton test/spec
-	      directory will be created based on this option. If  this	option
-	      is  unspecified, an interactive prompt will be displayed and the
-	      answer will be saved in Bundler's global config for future  bun-
-	      dle  gem	use.  If  no  option is specified, the default testing
-	      framework is RSpec.
-
-       -e, --edit[=EDITOR]
-	      Open the resulting GEM_NAME.gemspec in EDITOR,  or  the  default
-	      editor  if  not specified. The default is $BUNDLER_EDITOR, $VIS-
-	      UAL, or $EDITOR.
-
-SEE ALSO
-       o   bundle config(1) bundle-config.1.html
-
-
-
-
-
-
-				 January 2020			 BUNDLE-GEM(1)
--- ruby2.7-2.7.6.orig/man/bundle-gem.ronn
+++ /dev/null
@@ -1,78 +0,0 @@
-bundle-gem(1) -- Generate a project skeleton for creating a rubygem
-====================================================================
-
-## SYNOPSIS
-
-`bundle gem` <GEM_NAME> [OPTIONS]
-
-## DESCRIPTION
-
-Generates a directory named `GEM_NAME` with a `Rakefile`, `GEM_NAME.gemspec`,
-and other supporting files and directories that can be used to develop a
-rubygem with that name.
-
-Run `rake -T` in the resulting project for a list of Rake tasks that can be used
-to test and publish the gem to rubygems.org.
-
-The generated project skeleton can be customized with OPTIONS, as explained
-below. Note that these options can also be specified via Bundler's global
-configuration file using the following names:
-
-* `gem.coc`
-* `gem.mit`
-* `gem.test`
-
-## OPTIONS
-
-* `--exe` or `-b` or `--bin`:
-  Specify that Bundler should create a binary executable (as `exe/GEM_NAME`)
-  in the generated rubygem project. This binary will also be added to the
-  `GEM_NAME.gemspec` manifest. This behavior is disabled by default.
-
-* `--no-exe`:
-  Do not create a binary (overrides `--exe` specified in the global config).
-
-* `--coc`:
-  Add a `CODE_OF_CONDUCT.md` file to the root of the generated project. If
-  this option is unspecified, an interactive prompt will be displayed and the
-  answer will be saved in Bundler's global config for future `bundle gem` use.
-
-* `--no-coc`:
-  Do not create a `CODE_OF_CONDUCT.md` (overrides `--coc` specified in the
-  global config).
-
-* `--ext`:
-  Add boilerplate for C extension code to the generated project. This behavior
-  is disabled by default.
-
-* `--no-ext`:
-  Do not add C extension code (overrides `--ext` specified in the global
-  config).
-
-* `--mit`:
-  Add an MIT license to a `LICENSE.txt` file in the root of the generated
-  project. Your name from the global git config is used for the copyright
-  statement. If this option is unspecified, an interactive prompt will be
-  displayed and the answer will be saved in Bundler's global config for future
-  `bundle gem` use.
-
-* `--no-mit`:
-  Do not create a `LICENSE.txt` (overrides `--mit` specified in the global
-  config).
-
-* `-t`, `--test=minitest`, `--test=rspec`:
-  Specify the test framework that Bundler should use when generating the
-  project. Acceptable values are `minitest` and `rspec`. The `GEM_NAME.gemspec`
-  will be configured and a skeleton test/spec directory will be created based
-  on this option. If this option is unspecified, an interactive prompt will be
-  displayed and the answer will be saved in Bundler's global config for future
-  `bundle gem` use.
-  If no option is specified, the default testing framework is RSpec.
-
-* `-e`, `--edit[=EDITOR]`:
-  Open the resulting GEM_NAME.gemspec in EDITOR, or the default editor if not
-  specified. The default is `$BUNDLER_EDITOR`, `$VISUAL`, or `$EDITOR`.
-
-## SEE ALSO
-
-* [bundle config(1)](bundle-config.1.html)
--- ruby2.7-2.7.6.orig/man/bundle-info.1
+++ /dev/null
@@ -1,20 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-INFO" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-info\fR \- Show information for the given gem in your bundle
-.
-.SH "SYNOPSIS"
-\fBbundle info\fR [GEM] [\-\-path]
-.
-.SH "DESCRIPTION"
-Print the basic information about the provided GEM such as homepage, version, path and summary\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-path\fR
-Print the path of the given gem
-
--- ruby2.7-2.7.6.orig/man/bundle-info.1.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-BUNDLE-INFO(1)							BUNDLE-INFO(1)
-
-
-
-NAME
-       bundle-info - Show information for the given gem in your bundle
-
-SYNOPSIS
-       bundle info [GEM] [--path]
-
-DESCRIPTION
-       Print  the  basic  information about the provided GEM such as homepage,
-       version, path and summary.
-
-OPTIONS
-       --path Print the path of the given gem
-
-
-
-
-				 January 2020			BUNDLE-INFO(1)
--- ruby2.7-2.7.6.orig/man/bundle-info.ronn
+++ /dev/null
@@ -1,17 +0,0 @@
-bundle-info(1) -- Show information for the given gem in your bundle
-=========================================================================
-
-## SYNOPSIS
-
-`bundle info` [GEM]
-              [--path]
-
-## DESCRIPTION
-
-Print the basic information about the provided GEM such as homepage, version,
-path and summary.
-
-## OPTIONS
-
-* `--path`:
-Print the path of the given gem
--- ruby2.7-2.7.6.orig/man/bundle-init.1
+++ /dev/null
@@ -1,25 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-INIT" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-init\fR \- Generates a Gemfile into the current working directory
-.
-.SH "SYNOPSIS"
-\fBbundle init\fR [\-\-gemspec=FILE]
-.
-.SH "DESCRIPTION"
-Init generates a default [\fBGemfile(5)\fR][Gemfile(5)] in the current working directory\. When adding a [\fBGemfile(5)\fR][Gemfile(5)] to a gem with a gemspec, the \fB\-\-gemspec\fR option will automatically add each dependency listed in the gemspec file to the newly created [\fBGemfile(5)\fR][Gemfile(5)]\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-gemspec\fR
-Use the specified \.gemspec to create the [\fBGemfile(5)\fR][Gemfile(5)]
-.
-.SH "FILES"
-Included in the default [\fBGemfile(5)\fR][Gemfile(5)] generated is the line \fB# frozen_string_literal: true\fR\. This is a magic comment supported for the first time in Ruby 2\.3\. The presence of this line results in all string literals in the file being implicitly frozen\.
-.
-.SH "SEE ALSO"
-Gemfile(5) \fIhttps://bundler\.io/man/gemfile\.5\.html\fR
--- ruby2.7-2.7.6.orig/man/bundle-init.1.txt
+++ /dev/null
@@ -1,34 +0,0 @@
-BUNDLE-INIT(1)							BUNDLE-INIT(1)
-
-
-
-NAME
-       bundle-init - Generates a Gemfile into the current working directory
-
-SYNOPSIS
-       bundle init [--gemspec=FILE]
-
-DESCRIPTION
-       Init  generates a default [Gemfile(5)][Gemfile(5)] in the current work-
-       ing directory. When adding a [Gemfile(5)][Gemfile(5)] to a gem  with  a
-       gemspec,  the  --gemspec  option will automatically add each dependency
-       listed in the gemspec  file  to	the  newly  created  [Gemfile(5)][Gem-
-       file(5)].
-
-OPTIONS
-       --gemspec
-	      Use  the	specified  .gemspec  to  create  the [Gemfile(5)][Gem-
-	      file(5)]
-
-FILES
-       Included in the default [Gemfile(5)][Gemfile(5)] generated is the  line
-       #  frozen_string_literal:  true.  This is a magic comment supported for
-       the first time in Ruby 2.3. The presence of this line  results  in  all
-       string literals in the file being implicitly frozen.
-
-SEE ALSO
-       Gemfile(5) https://bundler.io/man/gemfile.5.html
-
-
-
-				 January 2020			BUNDLE-INIT(1)
--- ruby2.7-2.7.6.orig/man/bundle-init.ronn
+++ /dev/null
@@ -1,29 +0,0 @@
-bundle-init(1) -- Generates a Gemfile into the current working directory
-========================================================================
-
-## SYNOPSIS
-
-`bundle init` [--gemspec=FILE]
-
-## DESCRIPTION
-
-Init generates a default [`Gemfile(5)`][Gemfile(5)] in the current working directory. When
-adding a [`Gemfile(5)`][Gemfile(5)] to a gem with a gemspec, the `--gemspec` option will
-automatically add each dependency listed in the gemspec file to the newly
-created [`Gemfile(5)`][Gemfile(5)].
-
-## OPTIONS
-
-* `--gemspec`:
-  Use the specified .gemspec to create the [`Gemfile(5)`][Gemfile(5)]
-
-## FILES
-
-Included in the default [`Gemfile(5)`][Gemfile(5)]
-generated is the line `# frozen_string_literal: true`. This is a magic comment
-supported for the first time in Ruby 2.3. The presence of this line
-results in all string literals in the file being implicitly frozen.
-
-## SEE ALSO
-
-[Gemfile(5)](https://bundler.io/man/gemfile.5.html)
--- ruby2.7-2.7.6.orig/man/bundle-inject.1
+++ /dev/null
@@ -1,33 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-INJECT" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-inject\fR \- Add named gem(s) with version requirements to Gemfile
-.
-.SH "SYNOPSIS"
-\fBbundle inject\fR [GEM] [VERSION]
-.
-.SH "DESCRIPTION"
-Adds the named gem(s) with their version requirements to the resolved [\fBGemfile(5)\fR][Gemfile(5)]\.
-.
-.P
-This command will add the gem to both your [\fBGemfile(5)\fR][Gemfile(5)] and Gemfile\.lock if it isn\'t listed yet\.
-.
-.P
-Example:
-.
-.IP "" 4
-.
-.nf
-
-bundle install
-bundle inject \'rack\' \'> 0\'
-.
-.fi
-.
-.IP "" 0
-.
-.P
-This will inject the \'rack\' gem with a version greater than 0 in your [\fBGemfile(5)\fR][Gemfile(5)] and Gemfile\.lock
--- ruby2.7-2.7.6.orig/man/bundle-inject.1.txt
+++ /dev/null
@@ -1,32 +0,0 @@
-BUNDLE-INJECT(1)					      BUNDLE-INJECT(1)
-
-
-
-NAME
-       bundle-inject - Add named gem(s) with version requirements to Gemfile
-
-SYNOPSIS
-       bundle inject [GEM] [VERSION]
-
-DESCRIPTION
-       Adds  the  named gem(s) with their version requirements to the resolved
-       [Gemfile(5)][Gemfile(5)].
-
-       This command will add the gem to both your [Gemfile(5)][Gemfile(5)] and
-       Gemfile.lock if it isn't listed yet.
-
-       Example:
-
-
-
-	   bundle install
-	   bundle inject 'rack' '> 0'
-
-
-
-       This  will  inject the 'rack' gem with a version greater than 0 in your
-       [Gemfile(5)][Gemfile(5)] and Gemfile.lock
-
-
-
-				 January 2020		      BUNDLE-INJECT(1)
--- ruby2.7-2.7.6.orig/man/bundle-inject.ronn
+++ /dev/null
@@ -1,22 +0,0 @@
-bundle-inject(1) -- Add named gem(s) with version requirements to Gemfile
-=========================================================================
-
-## SYNOPSIS
-
-`bundle inject` [GEM] [VERSION]
-
-## DESCRIPTION
-
-Adds the named gem(s) with their version requirements to the resolved
-[`Gemfile(5)`][Gemfile(5)].
-
-This command will add the gem to both your [`Gemfile(5)`][Gemfile(5)] and Gemfile.lock if it
-isn't listed yet.
-
-Example:
-
-    bundle install
-    bundle inject 'rack' '> 0'
-
-This will inject the 'rack' gem with a version greater than 0 in your
-[`Gemfile(5)`][Gemfile(5)] and Gemfile.lock
--- ruby2.7-2.7.6.orig/man/bundle-install.1
+++ /dev/null
@@ -1,311 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-INSTALL" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-install\fR \- Install the dependencies specified in your Gemfile
-.
-.SH "SYNOPSIS"
-\fBbundle install\fR [\-\-binstubs[=DIRECTORY]] [\-\-clean] [\-\-deployment] [\-\-frozen] [\-\-full\-index] [\-\-gemfile=GEMFILE] [\-\-jobs=NUMBER] [\-\-local] [\-\-no\-cache] [\-\-no\-prune] [\-\-path PATH] [\-\-quiet] [\-\-redownload] [\-\-retry=NUMBER] [\-\-shebang] [\-\-standalone[=GROUP[ GROUP\.\.\.]]] [\-\-system] [\-\-trust\-policy=POLICY] [\-\-with=GROUP[ GROUP\.\.\.]] [\-\-without=GROUP[ GROUP\.\.\.]]
-.
-.SH "DESCRIPTION"
-Install the gems specified in your Gemfile(5)\. If this is the first time you run bundle install (and a \fBGemfile\.lock\fR does not exist), Bundler will fetch all remote sources, resolve dependencies and install all needed gems\.
-.
-.P
-If a \fBGemfile\.lock\fR does exist, and you have not updated your Gemfile(5), Bundler will fetch all remote sources, but use the dependencies specified in the \fBGemfile\.lock\fR instead of resolving dependencies\.
-.
-.P
-If a \fBGemfile\.lock\fR does exist, and you have updated your Gemfile(5), Bundler will use the dependencies in the \fBGemfile\.lock\fR for all gems that you did not update, but will re\-resolve the dependencies of gems that you did update\. You can find more information about this update process below under \fICONSERVATIVE UPDATING\fR\.
-.
-.SH "OPTIONS"
-To apply any of \fB\-\-binstubs\fR, \fB\-\-deployment\fR, \fB\-\-path\fR, or \fB\-\-without\fR every time \fBbundle install\fR is run, use \fBbundle config\fR (see bundle\-config(1))\.
-.
-.TP
-\fB\-\-binstubs[=<directory>]\fR
-Binstubs are scripts that wrap around executables\. Bundler creates a small Ruby file (a binstub) that loads Bundler, runs the command, and puts it in \fBbin/\fR\. This lets you link the binstub inside of an application to the exact gem version the application needs\.
-.
-.IP
-Creates a directory (defaults to \fB~/bin\fR) and places any executables from the gem there\. These executables run in Bundler\'s context\. If used, you might add this directory to your environment\'s \fBPATH\fR variable\. For instance, if the \fBrails\fR gem comes with a \fBrails\fR executable, this flag will create a \fBbin/rails\fR executable that ensures that all referred dependencies will be resolved using the bundled gems\.
-.
-.TP
-\fB\-\-clean\fR
-On finishing the installation Bundler is going to remove any gems not present in the current Gemfile(5)\. Don\'t worry, gems currently in use will not be removed\.
-.
-.TP
-\fB\-\-deployment\fR
-In \fIdeployment mode\fR, Bundler will \'roll\-out\' the bundle for production or CI use\. Please check carefully if you want to have this option enabled in your development environment\.
-.
-.TP
-\fB\-\-redownload\fR
-Force download every gem, even if the required versions are already available locally\.
-.
-.TP
-\fB\-\-frozen\fR
-Do not allow the Gemfile\.lock to be updated after this install\. Exits non\-zero if there are going to be changes to the Gemfile\.lock\.
-.
-.TP
-\fB\-\-full\-index\fR
-Bundler will not call Rubygems\' API endpoint (default) but download and cache a (currently big) index file of all gems\. Performance can be improved for large bundles that seldom change by enabling this option\.
-.
-.TP
-\fB\-\-gemfile=<gemfile>\fR
-The location of the Gemfile(5) which Bundler should use\. This defaults to a Gemfile(5) in the current working directory\. In general, Bundler will assume that the location of the Gemfile(5) is also the project\'s root and will try to find \fBGemfile\.lock\fR and \fBvendor/cache\fR relative to this location\.
-.
-.TP
-\fB\-\-jobs=[<number>]\fR, \fB\-j[<number>]\fR
-The maximum number of parallel download and install jobs\. The default is \fB1\fR\.
-.
-.TP
-\fB\-\-local\fR
-Do not attempt to connect to \fBrubygems\.org\fR\. Instead, Bundler will use the gems already present in Rubygems\' cache or in \fBvendor/cache\fR\. Note that if a appropriate platform\-specific gem exists on \fBrubygems\.org\fR it will not be found\.
-.
-.TP
-\fB\-\-no\-cache\fR
-Do not update the cache in \fBvendor/cache\fR with the newly bundled gems\. This does not remove any gems in the cache but keeps the newly bundled gems from being cached during the install\.
-.
-.TP
-\fB\-\-no\-prune\fR
-Don\'t remove stale gems from the cache when the installation finishes\.
-.
-.TP
-\fB\-\-path=<path>\fR
-The location to install the specified gems to\. This defaults to Rubygems\' setting\. Bundler shares this location with Rubygems, \fBgem install \.\.\.\fR will have gem installed there, too\. Therefore, gems installed without a \fB\-\-path \.\.\.\fR setting will show up by calling \fBgem list\fR\. Accordingly, gems installed to other locations will not get listed\.
-.
-.TP
-\fB\-\-quiet\fR
-Do not print progress information to the standard output\. Instead, Bundler will exit using a status code (\fB$?\fR)\.
-.
-.TP
-\fB\-\-retry=[<number>]\fR
-Retry failed network or git requests for \fInumber\fR times\.
-.
-.TP
-\fB\-\-shebang=<ruby\-executable>\fR
-Uses the specified ruby executable (usually \fBruby\fR) to execute the scripts created with \fB\-\-binstubs\fR\. In addition, if you use \fB\-\-binstubs\fR together with \fB\-\-shebang jruby\fR these executables will be changed to execute \fBjruby\fR instead\.
-.
-.TP
-\fB\-\-standalone[=<list>]\fR
-Makes a bundle that can work without depending on Rubygems or Bundler at runtime\. A space separated list of groups to install has to be specified\. Bundler creates a directory named \fBbundle\fR and installs the bundle there\. It also generates a \fBbundle/bundler/setup\.rb\fR file to replace Bundler\'s own setup in the manner required\. Using this option implicitly sets \fBpath\fR, which is a [remembered option][REMEMBERED OPTIONS]\.
-.
-.TP
-\fB\-\-system\fR
-Installs the gems specified in the bundle to the system\'s Rubygems location\. This overrides any previous configuration of \fB\-\-path\fR\.
-.
-.TP
-\fB\-\-trust\-policy=[<policy>]\fR
-Apply the Rubygems security policy \fIpolicy\fR, where policy is one of \fBHighSecurity\fR, \fBMediumSecurity\fR, \fBLowSecurity\fR, \fBAlmostNoSecurity\fR, or \fBNoSecurity\fR\. For more details, please see the Rubygems signing documentation linked below in \fISEE ALSO\fR\.
-.
-.TP
-\fB\-\-with=<list>\fR
-A space\-separated list of groups referencing gems to install\. If an optional group is given it is installed\. If a group is given that is in the remembered list of groups given to \-\-without, it is removed from that list\.
-.
-.TP
-\fB\-\-without=<list>\fR
-A space\-separated list of groups referencing gems to skip during installation\. If a group is given that is in the remembered list of groups given to \-\-with, it is removed from that list\.
-.
-.SH "DEPLOYMENT MODE"
-Bundler\'s defaults are optimized for development\. To switch to defaults optimized for deployment and for CI, use the \fB\-\-deployment\fR flag\. Do not activate deployment mode on development machines, as it will cause an error when the Gemfile(5) is modified\.
-.
-.IP "1." 4
-A \fBGemfile\.lock\fR is required\.
-.
-.IP
-To ensure that the same versions of the gems you developed with and tested with are also used in deployments, a \fBGemfile\.lock\fR is required\.
-.
-.IP
-This is mainly to ensure that you remember to check your \fBGemfile\.lock\fR into version control\.
-.
-.IP "2." 4
-The \fBGemfile\.lock\fR must be up to date
-.
-.IP
-In development, you can modify your Gemfile(5) and re\-run \fBbundle install\fR to \fIconservatively update\fR your \fBGemfile\.lock\fR snapshot\.
-.
-.IP
-In deployment, your \fBGemfile\.lock\fR should be up\-to\-date with changes made in your Gemfile(5)\.
-.
-.IP "3." 4
-Gems are installed to \fBvendor/bundle\fR not your default system location
-.
-.IP
-In development, it\'s convenient to share the gems used in your application with other applications and other scripts that run on the system\.
-.
-.IP
-In deployment, isolation is a more important default\. In addition, the user deploying the application may not have permission to install gems to the system, or the web server may not have permission to read them\.
-.
-.IP
-As a result, \fBbundle install \-\-deployment\fR installs gems to the \fBvendor/bundle\fR directory in the application\. This may be overridden using the \fB\-\-path\fR option\.
-.
-.IP "" 0
-.
-.SH "SUDO USAGE"
-By default, Bundler installs gems to the same location as \fBgem install\fR\.
-.
-.P
-In some cases, that location may not be writable by your Unix user\. In that case, Bundler will stage everything in a temporary directory, then ask you for your \fBsudo\fR password in order to copy the gems into their system location\.
-.
-.P
-From your perspective, this is identical to installing the gems directly into the system\.
-.
-.P
-You should never use \fBsudo bundle install\fR\. This is because several other steps in \fBbundle install\fR must be performed as the current user:
-.
-.IP "\(bu" 4
-Updating your \fBGemfile\.lock\fR
-.
-.IP "\(bu" 4
-Updating your \fBvendor/cache\fR, if necessary
-.
-.IP "\(bu" 4
-Checking out private git repositories using your user\'s SSH keys
-.
-.IP "" 0
-.
-.P
-Of these three, the first two could theoretically be performed by \fBchown\fRing the resulting files to \fB$SUDO_USER\fR\. The third, however, can only be performed by invoking the \fBgit\fR command as the current user\. Therefore, git gems are downloaded and installed into \fB~/\.bundle\fR rather than $GEM_HOME or $BUNDLE_PATH\.
-.
-.P
-As a result, you should run \fBbundle install\fR as the current user, and Bundler will ask for your password if it is needed to put the gems into their final location\.
-.
-.SH "INSTALLING GROUPS"
-By default, \fBbundle install\fR will install all gems in all groups in your Gemfile(5), except those declared for a different platform\.
-.
-.P
-However, you can explicitly tell Bundler to skip installing certain groups with the \fB\-\-without\fR option\. This option takes a space\-separated list of groups\.
-.
-.P
-While the \fB\-\-without\fR option will skip \fIinstalling\fR the gems in the specified groups, it will still \fIdownload\fR those gems and use them to resolve the dependencies of every gem in your Gemfile(5)\.
-.
-.P
-This is so that installing a different set of groups on another machine (such as a production server) will not change the gems and versions that you have already developed and tested against\.
-.
-.P
-\fBBundler offers a rock\-solid guarantee that the third\-party code you are running in development and testing is also the third\-party code you are running in production\. You can choose to exclude some of that code in different environments, but you will never be caught flat\-footed by different versions of third\-party code being used in different environments\.\fR
-.
-.P
-For a simple illustration, consider the following Gemfile(5):
-.
-.IP "" 4
-.
-.nf
-
-source \'https://rubygems\.org\'
-
-gem \'sinatra\'
-
-group :production do
-  gem \'rack\-perftools\-profiler\'
-end
-.
-.fi
-.
-.IP "" 0
-.
-.P
-In this case, \fBsinatra\fR depends on any version of Rack (\fB>= 1\.0\fR), while \fBrack\-perftools\-profiler\fR depends on 1\.x (\fB~> 1\.0\fR)\.
-.
-.P
-When you run \fBbundle install \-\-without production\fR in development, we look at the dependencies of \fBrack\-perftools\-profiler\fR as well\. That way, you do not spend all your time developing against Rack 2\.0, using new APIs unavailable in Rack 1\.x, only to have Bundler switch to Rack 1\.2 when the \fBproduction\fR group \fIis\fR used\.
-.
-.P
-This should not cause any problems in practice, because we do not attempt to \fBinstall\fR the gems in the excluded groups, and only evaluate as part of the dependency resolution process\.
-.
-.P
-This also means that you cannot include different versions of the same gem in different groups, because doing so would result in different sets of dependencies used in development and production\. Because of the vagaries of the dependency resolution process, this usually affects more than the gems you list in your Gemfile(5), and can (surprisingly) radically change the gems you are using\.
-.
-.SH "THE GEMFILE\.LOCK"
-When you run \fBbundle install\fR, Bundler will persist the full names and versions of all gems that you used (including dependencies of the gems specified in the Gemfile(5)) into a file called \fBGemfile\.lock\fR\.
-.
-.P
-Bundler uses this file in all subsequent calls to \fBbundle install\fR, which guarantees that you always use the same exact code, even as your application moves across machines\.
-.
-.P
-Because of the way dependency resolution works, even a seemingly small change (for instance, an update to a point\-release of a dependency of a gem in your Gemfile(5)) can result in radically different gems being needed to satisfy all dependencies\.
-.
-.P
-As a result, you \fBSHOULD\fR check your \fBGemfile\.lock\fR into version control, in both applications and gems\. If you do not, every machine that checks out your repository (including your production server) will resolve all dependencies again, which will result in different versions of third\-party code being used if \fBany\fR of the gems in the Gemfile(5) or any of their dependencies have been updated\.
-.
-.P
-When Bundler first shipped, the \fBGemfile\.lock\fR was included in the \fB\.gitignore\fR file included with generated gems\. Over time, however, it became clear that this practice forces the pain of broken dependencies onto new contributors, while leaving existing contributors potentially unaware of the problem\. Since \fBbundle install\fR is usually the first step towards a contribution, the pain of broken dependencies would discourage new contributors from contributing\. As a result, we have revised our guidance for gem authors to now recommend checking in the lock for gems\.
-.
-.SH "CONSERVATIVE UPDATING"
-When you make a change to the Gemfile(5) and then run \fBbundle install\fR, Bundler will update only the gems that you modified\.
-.
-.P
-In other words, if a gem that you \fBdid not modify\fR worked before you called \fBbundle install\fR, it will continue to use the exact same versions of all dependencies as it used before the update\.
-.
-.P
-Let\'s take a look at an example\. Here\'s your original Gemfile(5):
-.
-.IP "" 4
-.
-.nf
-
-source \'https://rubygems\.org\'
-
-gem \'actionpack\', \'2\.3\.8\'
-gem \'activemerchant\'
-.
-.fi
-.
-.IP "" 0
-.
-.P
-In this case, both \fBactionpack\fR and \fBactivemerchant\fR depend on \fBactivesupport\fR\. The \fBactionpack\fR gem depends on \fBactivesupport 2\.3\.8\fR and \fBrack ~> 1\.1\.0\fR, while the \fBactivemerchant\fR gem depends on \fBactivesupport >= 2\.3\.2\fR, \fBbraintree >= 2\.0\.0\fR, and \fBbuilder >= 2\.0\.0\fR\.
-.
-.P
-When the dependencies are first resolved, Bundler will select \fBactivesupport 2\.3\.8\fR, which satisfies the requirements of both gems in your Gemfile(5)\.
-.
-.P
-Next, you modify your Gemfile(5) to:
-.
-.IP "" 4
-.
-.nf
-
-source \'https://rubygems\.org\'
-
-gem \'actionpack\', \'3\.0\.0\.rc\'
-gem \'activemerchant\'
-.
-.fi
-.
-.IP "" 0
-.
-.P
-The \fBactionpack 3\.0\.0\.rc\fR gem has a number of new dependencies, and updates the \fBactivesupport\fR dependency to \fB= 3\.0\.0\.rc\fR and the \fBrack\fR dependency to \fB~> 1\.2\.1\fR\.
-.
-.P
-When you run \fBbundle install\fR, Bundler notices that you changed the \fBactionpack\fR gem, but not the \fBactivemerchant\fR gem\. It evaluates the gems currently being used to satisfy its requirements:
-.
-.TP
-\fBactivesupport 2\.3\.8\fR
-also used to satisfy a dependency in \fBactivemerchant\fR, which is not being updated
-.
-.TP
-\fBrack ~> 1\.1\.0\fR
-not currently being used to satisfy another dependency
-.
-.P
-Because you did not explicitly ask to update \fBactivemerchant\fR, you would not expect it to suddenly stop working after updating \fBactionpack\fR\. However, satisfying the new \fBactivesupport 3\.0\.0\.rc\fR dependency of actionpack requires updating one of its dependencies\.
-.
-.P
-Even though \fBactivemerchant\fR declares a very loose dependency that theoretically matches \fBactivesupport 3\.0\.0\.rc\fR, Bundler treats gems in your Gemfile(5) that have not changed as an atomic unit together with their dependencies\. In this case, the \fBactivemerchant\fR dependency is treated as \fBactivemerchant 1\.7\.1 + activesupport 2\.3\.8\fR, so \fBbundle install\fR will report that it cannot update \fBactionpack\fR\.
-.
-.P
-To explicitly update \fBactionpack\fR, including its dependencies which other gems in the Gemfile(5) still depend on, run \fBbundle update actionpack\fR (see \fBbundle update(1)\fR)\.
-.
-.P
-\fBSummary\fR: In general, after making a change to the Gemfile(5) , you should first try to run \fBbundle install\fR, which will guarantee that no other gem in the Gemfile(5) is impacted by the change\. If that does not work, run bundle update(1) \fIbundle\-update\.1\.html\fR\.
-.
-.SH "SEE ALSO"
-.
-.IP "\(bu" 4
-Gem install docs \fIhttp://guides\.rubygems\.org/rubygems\-basics/#installing\-gems\fR
-.
-.IP "\(bu" 4
-Rubygems signing docs \fIhttp://guides\.rubygems\.org/security/\fR
-.
-.IP "" 0
-
--- ruby2.7-2.7.6.orig/man/bundle-install.1.txt
+++ /dev/null
@@ -1,401 +0,0 @@
-BUNDLE-INSTALL(1)					     BUNDLE-INSTALL(1)
-
-
-
-NAME
-       bundle-install - Install the dependencies specified in your Gemfile
-
-SYNOPSIS
-       bundle	install   [--binstubs[=DIRECTORY]]   [--clean]	[--deployment]
-       [--frozen] [--full-index] [--gemfile=GEMFILE] [--jobs=NUMBER] [--local]
-       [--no-cache]   [--no-prune]   [--path  PATH]  [--quiet]	[--redownload]
-       [--retry=NUMBER] [--shebang] [--standalone[=GROUP[ GROUP...]]]  [--sys-
-       tem]   [--trust-policy=POLICY]	[--with=GROUP[	 GROUP...]]   [--with-
-       out=GROUP[ GROUP...]]
-
-DESCRIPTION
-       Install the gems specified in your Gemfile(5). If  this	is  the  first
-       time  you  run  bundle  install	(and  a  Gemfile.lock does not exist),
-       Bundler will fetch all remote sources, resolve dependencies and install
-       all needed gems.
-
-       If a Gemfile.lock does exist, and you have not updated your Gemfile(5),
-       Bundler will fetch all remote sources, but use the dependencies	speci-
-       fied in the Gemfile.lock instead of resolving dependencies.
-
-       If  a  Gemfile.lock  does  exist, and you have updated your Gemfile(5),
-       Bundler will use the dependencies in the Gemfile.lock for all gems that
-       you  did  not update, but will re-resolve the dependencies of gems that
-       you did update. You can find more information about this update process
-       below under CONSERVATIVE UPDATING.
-
-OPTIONS
-       To  apply  any  of --binstubs, --deployment, --path, or --without every
-       time bundle install is run, use bundle config (see bundle-config(1)).
-
-       --binstubs[=<directory>]
-	      Binstubs are scripts that wrap around executables. Bundler  cre-
-	      ates  a small Ruby file (a binstub) that loads Bundler, runs the
-	      command, and puts it in bin/. This lets  you  link  the  binstub
-	      inside  of  an application to the exact gem version the applica-
-	      tion needs.
-
-	      Creates a directory (defaults to ~/bin) and places any  executa-
-	      bles from the gem there. These executables run in Bundler's con-
-	      text. If used, you might add this  directory  to	your  environ-
-	      ment's  PATH variable. For instance, if the rails gem comes with
-	      a rails executable, this flag will create a bin/rails executable
-	      that  ensures  that  all	referred dependencies will be resolved
-	      using the bundled gems.
-
-       --clean
-	      On finishing the installation Bundler is	going  to  remove  any
-	      gems  not  present  in the current Gemfile(5). Don't worry, gems
-	      currently in use will not be removed.
-
-       --deployment
-	      In deployment mode, Bundler will 'roll-out' the bundle for  pro-
-	      duction  or  CI  use. Please check carefully if you want to have
-	      this option enabled in your development environment.
-
-       --redownload
-	      Force download every gem, even  if  the  required  versions  are
-	      already available locally.
-
-       --frozen
-	      Do  not allow the Gemfile.lock to be updated after this install.
-	      Exits non-zero if there are going to  be	changes  to  the  Gem-
-	      file.lock.
-
-       --full-index
-	      Bundler will not call Rubygems' API endpoint (default) but down-
-	      load and cache a (currently big) index file of all gems. Perfor-
-	      mance  can  be  improved for large bundles that seldom change by
-	      enabling this option.
-
-       --gemfile=<gemfile>
-	      The location of the Gemfile(5) which Bundler  should  use.  This
-	      defaults	to  a  Gemfile(5) in the current working directory. In
-	      general, Bundler will assume that the location of the Gemfile(5)
-	      is also the project's root and will try to find Gemfile.lock and
-	      vendor/cache relative to this location.
-
-       --jobs=[<number>], -j[<number>]
-	      The maximum number of parallel download and  install  jobs.  The
-	      default is 1.
-
-       --local
-	      Do not attempt to connect to rubygems.org. Instead, Bundler will
-	      use the gems already present  in	Rubygems'  cache  or  in  ven-
-	      dor/cache.  Note	that  if  a  appropriate platform-specific gem
-	      exists on rubygems.org it will not be found.
-
-       --no-cache
-	      Do not update the cache in vendor/cache with the	newly  bundled
-	      gems.  This  does not remove any gems in the cache but keeps the
-	      newly bundled gems from being cached during the install.
-
-       --no-prune
-	      Don't remove stale gems from the	cache  when  the  installation
-	      finishes.
-
-       --path=<path>
-	      The  location to install the specified gems to. This defaults to
-	      Rubygems' setting. Bundler shares this location  with  Rubygems,
-	      gem  install  ... will have gem installed there, too. Therefore,
-	      gems installed without a --path ...  setting  will  show	up  by
-	      calling gem list. Accordingly, gems installed to other locations
-	      will not get listed.
-
-       --quiet
-	      Do not  print  progress  information  to	the  standard  output.
-	      Instead, Bundler will exit using a status code ($?).
-
-       --retry=[<number>]
-	      Retry failed network or git requests for number times.
-
-       --shebang=<ruby-executable>
-	      Uses the specified ruby executable (usually ruby) to execute the
-	      scripts created with --binstubs. In addition, if you use	--bin-
-	      stubs  together  with  --shebang jruby these executables will be
-	      changed to execute jruby instead.
-
-       --standalone[=<list>]
-	      Makes a bundle that can work without depending  on  Rubygems  or
-	      Bundler  at runtime. A space separated list of groups to install
-	      has to be specified. Bundler creates a  directory  named	bundle
-	      and  installs  the  bundle  there.  It  also  generates  a  bun-
-	      dle/bundler/setup.rb file to replace Bundler's own setup in  the
-	      manner  required.  Using this option implicitly sets path, which
-	      is a [remembered option][REMEMBERED OPTIONS].
-
-       --system
-	      Installs the gems  specified  in	the  bundle  to  the  system's
-	      Rubygems	location. This overrides any previous configuration of
-	      --path.
-
-       --trust-policy=[<policy>]
-	      Apply the Rubygems security policy policy, where policy  is  one
-	      of  HighSecurity, MediumSecurity, LowSecurity, AlmostNoSecurity,
-	      or NoSecurity. For more details, please see the Rubygems signing
-	      documentation linked below in SEE ALSO.
-
-       --with=<list>
-	      A space-separated list of groups referencing gems to install. If
-	      an optional group is given it is installed. If a group is  given
-	      that  is in the remembered list of groups given to --without, it
-	      is removed from that list.
-
-       --without=<list>
-	      A space-separated list of groups referencing gems to skip during
-	      installation. If a group is given that is in the remembered list
-	      of groups given to --with, it is removed from that list.
-
-DEPLOYMENT MODE
-       Bundler's defaults are optimized for development. To switch to defaults
-       optimized  for deployment and for CI, use the --deployment flag. Do not
-       activate deployment mode on development machines, as it will  cause  an
-       error when the Gemfile(5) is modified.
-
-       1.  A Gemfile.lock is required.
-
-	   To ensure that the same versions of the gems you developed with and
-	   tested with	are  also  used  in  deployments,  a  Gemfile.lock  is
-	   required.
-
-	   This  is  mainly  to  ensure  that  you remember to check your Gem-
-	   file.lock into version control.
-
-       2.  The Gemfile.lock must be up to date
-
-	   In development, you can modify your Gemfile(5)  and	re-run	bundle
-	   install to conservatively update your Gemfile.lock snapshot.
-
-	   In  deployment, your Gemfile.lock should be up-to-date with changes
-	   made in your Gemfile(5).
-
-       3.  Gems are installed to vendor/bundle not your default  system  loca-
-	   tion
-
-	   In  development,  it's  convenient  to  share the gems used in your
-	   application with other applications and other scripts that  run  on
-	   the system.
-
-	   In  deployment, isolation is a more important default. In addition,
-	   the user deploying the  application	may  not  have	permission  to
-	   install  gems to the system, or the web server may not have permis-
-	   sion to read them.
-
-	   As a result, bundle install --deployment installs gems to the  ven-
-	   dor/bundle  directory  in  the  application. This may be overridden
-	   using the --path option.
-
-
-
-SUDO USAGE
-       By default, Bundler installs gems to the same location as gem install.
-
-       In some cases, that location may not be writable by your Unix user.  In
-       that case, Bundler will stage everything in a temporary directory, then
-       ask you for your sudo password in order to copy	the  gems  into  their
-       system location.
-
-       From  your  perspective,  this  is  identical  to  installing  the gems
-       directly into the system.
-
-       You should never use sudo bundle install. This is because several other
-       steps in bundle install must be performed as the current user:
-
-       o   Updating your Gemfile.lock
-
-       o   Updating your vendor/cache, if necessary
-
-       o   Checking out private git repositories using your user's SSH keys
-
-
-
-       Of  these  three,  the  first  two  could theoretically be performed by
-       chowning the resulting files to $SUDO_USER.  The  third,  however,  can
-       only  be  performed  by	invoking  the git command as the current user.
-       Therefore, git gems are downloaded and installed into ~/.bundle	rather
-       than $GEM_HOME or $BUNDLE_PATH.
-
-       As  a  result,  you  should run bundle install as the current user, and
-       Bundler will ask for your password if it is needed to put the gems into
-       their final location.
-
-INSTALLING GROUPS
-       By  default, bundle install will install all gems in all groups in your
-       Gemfile(5), except those declared for a different platform.
-
-       However, you can explicitly tell Bundler  to  skip  installing  certain
-       groups  with  the --without option. This option takes a space-separated
-       list of groups.
-
-       While the --without option will skip installing the gems in the	speci-
-       fied  groups, it will still download those gems and use them to resolve
-       the dependencies of every gem in your Gemfile(5).
-
-       This is so that installing a different set of groups on another machine
-       (such  as  a  production  server) will not change the gems and versions
-       that you have already developed and tested against.
-
-       Bundler offers a rock-solid guarantee that the third-party code you are
-       running in development and testing is also the third-party code you are
-       running in production. You can choose to exclude some of that  code  in
-       different  environments,  but  you  will never be caught flat-footed by
-       different versions of third-party code being used in different environ-
-       ments.
-
-       For a simple illustration, consider the following Gemfile(5):
-
-
-
-	   source 'https://rubygems.org'
-
-	   gem 'sinatra'
-
-	   group :production do
-	     gem 'rack-perftools-profiler'
-	   end
-
-
-
-       In  this  case,	sinatra depends on any version of Rack (>= 1.0), while
-       rack-perftools-profiler depends on 1.x (~> 1.0).
-
-       When you run bundle install --without  production  in  development,  we
-       look  at the dependencies of rack-perftools-profiler as well. That way,
-       you do not spend all your time developing against Rack 2.0,  using  new
-       APIs  unavailable  in Rack 1.x, only to have Bundler switch to Rack 1.2
-       when the production group is used.
-
-       This should not cause any problems  in  practice,  because  we  do  not
-       attempt	to  install the gems in the excluded groups, and only evaluate
-       as part of the dependency resolution process.
-
-       This also means that you cannot include different versions of the  same
-       gem  in	different  groups,  because doing so would result in different
-       sets of dependencies used in development and production. Because of the
-       vagaries  of  the  dependency  resolution process, this usually affects
-       more than the gems you list in your Gemfile(5), and can	(surprisingly)
-       radically change the gems you are using.
-
-THE GEMFILE.LOCK
-       When  you  run  bundle install, Bundler will persist the full names and
-       versions of all gems that you used (including dependencies of the  gems
-       specified in the Gemfile(5)) into a file called Gemfile.lock.
-
-       Bundler uses this file in all subsequent calls to bundle install, which
-       guarantees that you always use the same exact code, even as your appli-
-       cation moves across machines.
-
-       Because	of the way dependency resolution works, even a seemingly small
-       change (for instance, an update to a point-release of a dependency of a
-       gem  in	your  Gemfile(5)) can result in radically different gems being
-       needed to satisfy all dependencies.
-
-       As a result, you SHOULD check your Gemfile.lock into  version  control,
-       in both applications and gems. If you do not, every machine that checks
-       out your repository (including your production server) will resolve all
-       dependencies   again,  which  will  result  in  different  versions  of
-       third-party code being used if any of the gems in the Gemfile(5) or any
-       of their dependencies have been updated.
-
-       When  Bundler first shipped, the Gemfile.lock was included in the .git-
-       ignore file included with generated gems. Over time, however, it became
-       clear  that  this  practice forces the pain of broken dependencies onto
-       new  contributors,  while  leaving  existing  contributors  potentially
-       unaware	of the problem. Since bundle install is usually the first step
-       towards a contribution, the pain of broken dependencies would  discour-
-       age  new  contributors  from contributing. As a result, we have revised
-       our guidance for gem authors to now recommend checking in the lock  for
-       gems.
-
-CONSERVATIVE UPDATING
-       When  you  make a change to the Gemfile(5) and then run bundle install,
-       Bundler will update only the gems that you modified.
-
-       In other words, if a gem that you did  not  modify  worked  before  you
-       called  bundle install, it will continue to use the exact same versions
-       of all dependencies as it used before the update.
-
-       Let's take a look at an example. Here's your original Gemfile(5):
-
-
-
-	   source 'https://rubygems.org'
-
-	   gem 'actionpack', '2.3.8'
-	   gem 'activemerchant'
-
-
-
-       In this case, both actionpack and activemerchant depend	on  activesup-
-       port.  The  actionpack  gem  depends on activesupport 2.3.8 and rack ~>
-       1.1.0, while the activemerchant gem depends on activesupport >=	2.3.2,
-       braintree >= 2.0.0, and builder >= 2.0.0.
-
-       When   the   dependencies  are  first  resolved,  Bundler  will	select
-       activesupport 2.3.8, which satisfies the requirements of both  gems  in
-       your Gemfile(5).
-
-       Next, you modify your Gemfile(5) to:
-
-
-
-	   source 'https://rubygems.org'
-
-	   gem 'actionpack', '3.0.0.rc'
-	   gem 'activemerchant'
-
-
-
-       The  actionpack	3.0.0.rc  gem  has  a  number of new dependencies, and
-       updates the activesupport dependency to = 3.0.0.rc and the rack	depen-
-       dency to ~> 1.2.1.
-
-       When  you  run  bundle  install,  Bundler  notices that you changed the
-       actionpack gem, but not the activemerchant gem. It evaluates  the  gems
-       currently being used to satisfy its requirements:
-
-       activesupport 2.3.8
-	      also  used  to  satisfy a dependency in activemerchant, which is
-	      not being updated
-
-       rack ~> 1.1.0
-	      not currently being used to satisfy another dependency
-
-       Because you did not explicitly ask to update activemerchant, you  would
-       not  expect it to suddenly stop working after updating actionpack. How-
-       ever, satisfying the new activesupport 3.0.0.rc dependency  of  action-
-       pack requires updating one of its dependencies.
-
-       Even  though activemerchant declares a very loose dependency that theo-
-       retically matches activesupport 3.0.0.rc, Bundler treats gems  in  your
-       Gemfile(5)  that have not changed as an atomic unit together with their
-       dependencies. In this case, the activemerchant dependency is treated as
-       activemerchant  1.7.1  +  activesupport	2.3.8,	so bundle install will
-       report that it cannot update actionpack.
-
-       To explicitly update actionpack, including its dependencies which other
-       gems  in  the  Gemfile(5) still depend on, run bundle update actionpack
-       (see bundle update(1)).
-
-       Summary: In general, after making a change  to  the  Gemfile(5)	,  you
-       should  first  try  to run bundle install, which will guarantee that no
-       other gem in the Gemfile(5) is impacted by the change. If that does not
-       work, run bundle update(1) bundle-update.1.html.
-
-SEE ALSO
-       o   Gem				 install			  docs
-	   http://guides.rubygems.org/rubygems-basics/#installing-gems
-
-       o   Rubygems signing docs http://guides.rubygems.org/security/
-
-
-
-
-
-
-				 January 2020		     BUNDLE-INSTALL(1)
--- ruby2.7-2.7.6.orig/man/bundle-install.ronn
+++ /dev/null
@@ -1,383 +0,0 @@
-bundle-install(1) -- Install the dependencies specified in your Gemfile
-=======================================================================
-
-## SYNOPSIS
-
-`bundle install` [--binstubs[=DIRECTORY]]
-                 [--clean]
-                 [--deployment]
-                 [--frozen]
-                 [--full-index]
-                 [--gemfile=GEMFILE]
-                 [--jobs=NUMBER]
-                 [--local]
-                 [--no-cache]
-                 [--no-prune]
-                 [--path PATH]
-                 [--quiet]
-                 [--redownload]
-                 [--retry=NUMBER]
-                 [--shebang]
-                 [--standalone[=GROUP[ GROUP...]]]
-                 [--system]
-                 [--trust-policy=POLICY]
-                 [--with=GROUP[ GROUP...]]
-                 [--without=GROUP[ GROUP...]]
-
-## DESCRIPTION
-
-Install the gems specified in your Gemfile(5). If this is the first
-time you run bundle install (and a `Gemfile.lock` does not exist),
-Bundler will fetch all remote sources, resolve dependencies and
-install all needed gems.
-
-If a `Gemfile.lock` does exist, and you have not updated your Gemfile(5),
-Bundler will fetch all remote sources, but use the dependencies
-specified in the `Gemfile.lock` instead of resolving dependencies.
-
-If a `Gemfile.lock` does exist, and you have updated your Gemfile(5),
-Bundler will use the dependencies in the `Gemfile.lock` for all gems
-that you did not update, but will re-resolve the dependencies of
-gems that you did update. You can find more information about this
-update process below under [CONSERVATIVE UPDATING][].
-
-## OPTIONS
-
-To apply any of `--binstubs`, `--deployment`, `--path`, or `--without` every
-time `bundle install` is run, use `bundle config` (see bundle-config(1)).
-
-* `--binstubs[=<directory>]`:
-  Binstubs are scripts that wrap around executables. Bundler creates a small Ruby
-  file (a binstub) that loads Bundler, runs the command, and puts it in `bin/`.
-  This lets you link the binstub inside of an application to the exact gem
-  version the application needs.
-
-  Creates a directory (defaults to `~/bin`) and places any executables from the
-  gem there. These executables run in Bundler's context. If used, you might add
-  this directory to your environment's `PATH` variable. For instance, if the
-  `rails` gem comes with a `rails` executable, this flag will create a
-  `bin/rails` executable that ensures that all referred dependencies will be
-  resolved using the bundled gems.
-
-* `--clean`:
-  On finishing the installation Bundler is going to remove any gems not present
-  in the current Gemfile(5). Don't worry, gems currently in use will not be
-  removed.
-
-* `--deployment`:
-  In [deployment mode][DEPLOYMENT MODE], Bundler will 'roll-out' the bundle for
-  production or CI use. Please check carefully if you want to have this option
-  enabled in your development environment.
-
-* `--redownload`:
-  Force download every gem, even if the required versions are already available
-  locally.
-
-* `--frozen`:
-  Do not allow the Gemfile.lock to be updated after this install. Exits
-  non-zero if there are going to be changes to the Gemfile.lock.
-
-* `--full-index`:
-  Bundler will not call Rubygems' API endpoint (default) but download and cache
-  a (currently big) index file of all gems. Performance can be improved for
-  large bundles that seldom change by enabling this option.
-
-* `--gemfile=<gemfile>`:
-  The location of the Gemfile(5) which Bundler should use. This defaults
-  to a Gemfile(5) in the current working directory. In general, Bundler
-  will assume that the location of the Gemfile(5) is also the project's
-  root and will try to find `Gemfile.lock` and `vendor/cache` relative
-  to this location.
-
-* `--jobs=[<number>]`, `-j[<number>]`:
-  The maximum number of parallel download and install jobs. The default
-  is `1`.
-
-* `--local`:
-  Do not attempt to connect to `rubygems.org`. Instead, Bundler will use the
-  gems already present in Rubygems' cache or in `vendor/cache`. Note that if a
-  appropriate platform-specific gem exists on `rubygems.org` it will not be
-  found.
-
-* `--no-cache`:
-  Do not update the cache in `vendor/cache` with the newly bundled gems. This
-  does not remove any gems in the cache but keeps the newly bundled gems from
-  being cached during the install.
-
-* `--no-prune`:
-  Don't remove stale gems from the cache when the installation finishes.
-
-* `--path=<path>`:
-  The location to install the specified gems to. This defaults to Rubygems'
-  setting. Bundler shares this location with Rubygems, `gem install ...` will
-  have gem installed there, too. Therefore, gems installed without a
-  `--path ...` setting will show up by calling `gem list`. Accordingly, gems
-  installed to other locations will not get listed.
-
-* `--quiet`:
-  Do not print progress information to the standard output. Instead, Bundler
-  will exit using a status code (`$?`).
-
-* `--retry=[<number>]`:
-  Retry failed network or git requests for <number> times.
-
-* `--shebang=<ruby-executable>`:
-  Uses the specified ruby executable (usually `ruby`) to execute the scripts
-  created with `--binstubs`. In addition, if you use `--binstubs` together with
-  `--shebang jruby` these executables will be changed to execute `jruby`
-  instead.
-
-* `--standalone[=<list>]`:
-  Makes a bundle that can work without depending on Rubygems or Bundler at
-  runtime. A space separated list of groups to install has to be specified.
-  Bundler creates a directory named `bundle` and installs the bundle there. It
-  also generates a `bundle/bundler/setup.rb` file to replace Bundler's own setup
-  in the manner required. Using this option implicitly sets `path`, which is a
-  [remembered option][REMEMBERED OPTIONS].
-
-* `--system`:
-  Installs the gems specified in the bundle to the system's Rubygems location.
-  This overrides any previous configuration of `--path`.
-
-* `--trust-policy=[<policy>]`:
-  Apply the Rubygems security policy <policy>, where policy is one of
-  `HighSecurity`, `MediumSecurity`, `LowSecurity`, `AlmostNoSecurity`, or
-  `NoSecurity`. For more details, please see the Rubygems signing documentation
-  linked below in [SEE ALSO][].
-
-* `--with=<list>`:
-  A space-separated list of groups referencing gems to install. If an
-  optional group is given it is installed. If a group is given that is
-  in the remembered list of groups given to --without, it is removed
-  from that list.
-
-* `--without=<list>`:
-  A space-separated list of groups referencing gems to skip during installation.
-  If a group is given that is in the remembered list of groups given
-  to --with, it is removed from that list.
-
-## DEPLOYMENT MODE
-
-Bundler's defaults are optimized for development. To switch to
-defaults optimized for deployment and for CI, use the `--deployment`
-flag. Do not activate deployment mode on development machines, as it
-will cause an error when the Gemfile(5) is modified.
-
-1. A `Gemfile.lock` is required.
-
-   To ensure that the same versions of the gems you developed with
-   and tested with are also used in deployments, a `Gemfile.lock`
-   is required.
-
-   This is mainly to ensure that you remember to check your
-   `Gemfile.lock` into version control.
-
-2. The `Gemfile.lock` must be up to date
-
-   In development, you can modify your Gemfile(5) and re-run
-   `bundle install` to [conservatively update][CONSERVATIVE UPDATING]
-   your `Gemfile.lock` snapshot.
-
-   In deployment, your `Gemfile.lock` should be up-to-date with
-   changes made in your Gemfile(5).
-
-3. Gems are installed to `vendor/bundle` not your default system location
-
-   In development, it's convenient to share the gems used in your
-   application with other applications and other scripts that run on
-   the system.
-
-   In deployment, isolation is a more important default. In addition,
-   the user deploying the application may not have permission to install
-   gems to the system, or the web server may not have permission to
-   read them.
-
-   As a result, `bundle install --deployment` installs gems to
-   the `vendor/bundle` directory in the application. This may be
-   overridden using the `--path` option.
-
-## SUDO USAGE
-
-By default, Bundler installs gems to the same location as `gem install`.
-
-In some cases, that location may not be writable by your Unix user. In
-that case, Bundler will stage everything in a temporary directory,
-then ask you for your `sudo` password in order to copy the gems into
-their system location.
-
-From your perspective, this is identical to installing the gems
-directly into the system.
-
-You should never use `sudo bundle install`. This is because several
-other steps in `bundle install` must be performed as the current user:
-
-* Updating your `Gemfile.lock`
-* Updating your `vendor/cache`, if necessary
-* Checking out private git repositories using your user's SSH keys
-
-Of these three, the first two could theoretically be performed by
-`chown`ing the resulting files to `$SUDO_USER`. The third, however,
-can only be performed by invoking the `git` command as
-the current user. Therefore, git gems are downloaded and installed
-into `~/.bundle` rather than $GEM_HOME or $BUNDLE_PATH.
-
-As a result, you should run `bundle install` as the current user,
-and Bundler will ask for your password if it is needed to put the
-gems into their final location.
-
-## INSTALLING GROUPS
-
-By default, `bundle install` will install all gems in all groups
-in your Gemfile(5), except those declared for a different platform.
-
-However, you can explicitly tell Bundler to skip installing
-certain groups with the `--without` option. This option takes
-a space-separated list of groups.
-
-While the `--without` option will skip _installing_ the gems in the
-specified groups, it will still _download_ those gems and use them to
-resolve the dependencies of every gem in your Gemfile(5).
-
-This is so that installing a different set of groups on another
- machine (such as a production server) will not change the
-gems and versions that you have already developed and tested against.
-
-`Bundler offers a rock-solid guarantee that the third-party
-code you are running in development and testing is also the
-third-party code you are running in production. You can choose
-to exclude some of that code in different environments, but you
-will never be caught flat-footed by different versions of
-third-party code being used in different environments.`
-
-For a simple illustration, consider the following Gemfile(5):
-
-    source 'https://rubygems.org'
-
-    gem 'sinatra'
-
-    group :production do
-      gem 'rack-perftools-profiler'
-    end
-
-In this case, `sinatra` depends on any version of Rack (`>= 1.0`), while
-`rack-perftools-profiler` depends on 1.x (`~> 1.0`).
-
-When you run `bundle install --without production` in development, we
-look at the dependencies of `rack-perftools-profiler` as well. That way,
-you do not spend all your time developing against Rack 2.0, using new
-APIs unavailable in Rack 1.x, only to have Bundler switch to Rack 1.2
-when the `production` group _is_ used.
-
-This should not cause any problems in practice, because we do not
-attempt to `install` the gems in the excluded groups, and only evaluate
-as part of the dependency resolution process.
-
-This also means that you cannot include different versions of the same
-gem in different groups, because doing so would result in different
-sets of dependencies used in development and production. Because of
-the vagaries of the dependency resolution process, this usually
-affects more than the gems you list in your Gemfile(5), and can
-(surprisingly) radically change the gems you are using.
-
-## THE GEMFILE.LOCK
-
-When you run `bundle install`, Bundler will persist the full names
-and versions of all gems that you used (including dependencies of
-the gems specified in the Gemfile(5)) into a file called `Gemfile.lock`.
-
-Bundler uses this file in all subsequent calls to `bundle install`,
-which guarantees that you always use the same exact code, even
-as your application moves across machines.
-
-Because of the way dependency resolution works, even a
-seemingly small change (for instance, an update to a point-release
-of a dependency of a gem in your Gemfile(5)) can result in radically
-different gems being needed to satisfy all dependencies.
-
-As a result, you `SHOULD` check your `Gemfile.lock` into version
-control, in both applications and gems. If you do not, every machine that
-checks out your repository (including your production server) will resolve all
-dependencies again, which will result in different versions of
-third-party code being used if `any` of the gems in the Gemfile(5)
-or any of their dependencies have been updated.
-
-When Bundler first shipped, the `Gemfile.lock` was included in the `.gitignore`
-file included with generated gems.  Over time, however, it became clear that
-this practice forces the pain of broken dependencies onto new contributors,
-while leaving existing contributors potentially unaware of the problem. Since
-`bundle install` is usually the first step towards a contribution, the pain of
-broken dependencies would discourage new contributors from contributing. As a
-result, we have revised our guidance for gem authors to now recommend checking
-in the lock for gems.
-
-## CONSERVATIVE UPDATING
-
-When you make a change to the Gemfile(5) and then run `bundle install`,
-Bundler will update only the gems that you modified.
-
-In other words, if a gem that you `did not modify` worked before
-you called `bundle install`, it will continue to use the exact
-same versions of all dependencies as it used before the update.
-
-Let's take a look at an example. Here's your original Gemfile(5):
-
-    source 'https://rubygems.org'
-
-    gem 'actionpack', '2.3.8'
-    gem 'activemerchant'
-
-In this case, both `actionpack` and `activemerchant` depend on
-`activesupport`. The `actionpack` gem depends on `activesupport 2.3.8`
-and `rack ~> 1.1.0`, while the `activemerchant` gem depends on
-`activesupport >= 2.3.2`, `braintree >= 2.0.0`, and `builder >= 2.0.0`.
-
-When the dependencies are first resolved, Bundler will select
-`activesupport 2.3.8`, which satisfies the requirements of both
-gems in your Gemfile(5).
-
-Next, you modify your Gemfile(5) to:
-
-    source 'https://rubygems.org'
-
-    gem 'actionpack', '3.0.0.rc'
-    gem 'activemerchant'
-
-The `actionpack 3.0.0.rc` gem has a number of new dependencies,
-and updates the `activesupport` dependency to `= 3.0.0.rc` and
-the `rack` dependency to `~> 1.2.1`.
-
-When you run `bundle install`, Bundler notices that you changed
-the `actionpack` gem, but not the `activemerchant` gem. It
-evaluates the gems currently being used to satisfy its requirements:
-
-  * `activesupport 2.3.8`:
-    also used to satisfy a dependency in `activemerchant`,
-    which is not being updated
-  * `rack ~> 1.1.0`:
-    not currently being used to satisfy another dependency
-
-Because you did not explicitly ask to update `activemerchant`,
-you would not expect it to suddenly stop working after updating
-`actionpack`. However, satisfying the new `activesupport 3.0.0.rc`
-dependency of actionpack requires updating one of its dependencies.
-
-Even though `activemerchant` declares a very loose dependency
-that theoretically matches `activesupport 3.0.0.rc`, Bundler treats
-gems in your Gemfile(5) that have not changed as an atomic unit
-together with their dependencies. In this case, the `activemerchant`
-dependency is treated as `activemerchant 1.7.1 + activesupport 2.3.8`,
-so `bundle install` will report that it cannot update `actionpack`.
-
-To explicitly update `actionpack`, including its dependencies
-which other gems in the Gemfile(5) still depend on, run
-`bundle update actionpack` (see `bundle update(1)`).
-
-`Summary`: In general, after making a change to the Gemfile(5) , you
-should first try to run `bundle install`, which will guarantee that no
-other gem in the Gemfile(5) is impacted by the change. If that
-does not work, run [bundle update(1)](bundle-update.1.html).
-
-## SEE ALSO
-
-* [Gem install docs](http://guides.rubygems.org/rubygems-basics/#installing-gems)
-* [Rubygems signing docs](http://guides.rubygems.org/security/)
--- ruby2.7-2.7.6.orig/man/bundle-list.1
+++ /dev/null
@@ -1,50 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-LIST" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-list\fR \- List all the gems in the bundle
-.
-.SH "SYNOPSIS"
-\fBbundle list\fR [\-\-name\-only] [\-\-paths] [\-\-without\-group=GROUP] [\-\-only\-group=GROUP]
-.
-.SH "DESCRIPTION"
-Prints a list of all the gems in the bundle including their version\.
-.
-.P
-Example:
-.
-.P
-bundle list \-\-name\-only
-.
-.P
-bundle list \-\-paths
-.
-.P
-bundle list \-\-without\-group test
-.
-.P
-bundle list \-\-only\-group dev
-.
-.P
-bundle list \-\-only\-group dev \-\-paths
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-name\-only\fR
-Print only the name of each gem\.
-.
-.TP
-\fB\-\-paths\fR
-Print the path to each gem in the bundle\.
-.
-.TP
-\fB\-\-without\-group\fR
-Print all gems expect from a group\.
-.
-.TP
-\fB\-\-only\-group\fR
-Print gems from a particular group\.
-
--- ruby2.7-2.7.6.orig/man/bundle-list.1.txt
+++ /dev/null
@@ -1,43 +0,0 @@
-BUNDLE-LIST(1)							BUNDLE-LIST(1)
-
-
-
-NAME
-       bundle-list - List all the gems in the bundle
-
-SYNOPSIS
-       bundle	 list	 [--name-only]	  [--paths]    [--without-group=GROUP]
-       [--only-group=GROUP]
-
-DESCRIPTION
-       Prints a list of all the gems in the bundle including their version.
-
-       Example:
-
-       bundle list --name-only
-
-       bundle list --paths
-
-       bundle list --without-group test
-
-       bundle list --only-group dev
-
-       bundle list --only-group dev --paths
-
-OPTIONS
-       --name-only
-	      Print only the name of each gem.
-
-       --paths
-	      Print the path to each gem in the bundle.
-
-       --without-group
-	      Print all gems expect from a group.
-
-       --only-group
-	      Print gems from a particular group.
-
-
-
-
-				 January 2020			BUNDLE-LIST(1)
--- ruby2.7-2.7.6.orig/man/bundle-list.ronn
+++ /dev/null
@@ -1,33 +0,0 @@
-bundle-list(1) -- List all the gems in the bundle
-=========================================================================
-
-## SYNOPSIS
-
-`bundle list` [--name-only] [--paths] [--without-group=GROUP] [--only-group=GROUP]
-
-## DESCRIPTION
-
-Prints a list of all the gems in the bundle including their version.
-
-Example:
-
-bundle list --name-only
-
-bundle list --paths
-
-bundle list --without-group test
-
-bundle list --only-group dev
-
-bundle list --only-group dev --paths
-
-## OPTIONS
-
-* `--name-only`:
-  Print only the name of each gem.
-* `--paths`:
-  Print the path to each gem in the bundle.
-* `--without-group`:
-  Print all gems expect from a group.
-* `--only-group`:
-  Print gems from a particular group.
--- ruby2.7-2.7.6.orig/man/bundle-lock.1
+++ /dev/null
@@ -1,84 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-LOCK" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-lock\fR \- Creates / Updates a lockfile without installing
-.
-.SH "SYNOPSIS"
-\fBbundle lock\fR [\-\-update] [\-\-local] [\-\-print] [\-\-lockfile=PATH] [\-\-full\-index] [\-\-add\-platform] [\-\-remove\-platform] [\-\-patch] [\-\-minor] [\-\-major] [\-\-strict] [\-\-conservative]
-.
-.SH "DESCRIPTION"
-Lock the gems specified in Gemfile\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-update=<*gems>\fR
-Ignores the existing lockfile\. Resolve then updates lockfile\. Taking a list of gems or updating all gems if no list is given\.
-.
-.TP
-\fB\-\-local\fR
-Do not attempt to connect to \fBrubygems\.org\fR\. Instead, Bundler will use the gems already present in Rubygems\' cache or in \fBvendor/cache\fR\. Note that if a appropriate platform\-specific gem exists on \fBrubygems\.org\fR it will not be found\.
-.
-.TP
-\fB\-\-print\fR
-Prints the lockfile to STDOUT instead of writing to the file system\.
-.
-.TP
-\fB\-\-lockfile=<path>\fR
-The path where the lockfile should be written to\.
-.
-.TP
-\fB\-\-full\-index\fR
-Fall back to using the single\-file index of all gems\.
-.
-.TP
-\fB\-\-add\-platform\fR
-Add a new platform to the lockfile, re\-resolving for the addition of that platform\.
-.
-.TP
-\fB\-\-remove\-platform\fR
-Remove a platform from the lockfile\.
-.
-.TP
-\fB\-\-patch\fR
-If updating, prefer updating only to next patch version\.
-.
-.TP
-\fB\-\-minor\fR
-If updating, prefer updating only to next minor version\.
-.
-.TP
-\fB\-\-major\fR
-If updating, prefer updating to next major version (default)\.
-.
-.TP
-\fB\-\-strict\fR
-If updating, do not allow any gem to be updated past latest \-\-patch | \-\-minor | \-\-major\.
-.
-.TP
-\fB\-\-conservative\fR
-If updating, use bundle install conservative update behavior and do not allow shared dependencies to be updated\.
-.
-.SH "UPDATING ALL GEMS"
-If you run \fBbundle lock\fR with \fB\-\-update\fR option without list of gems, bundler will ignore any previously installed gems and resolve all dependencies again based on the latest versions of all gems available in the sources\.
-.
-.SH "UPDATING A LIST OF GEMS"
-Sometimes, you want to update a single gem in the Gemfile(5), and leave the rest of the gems that you specified locked to the versions in the \fBGemfile\.lock\fR\.
-.
-.P
-For instance, you only want to update \fBnokogiri\fR, run \fBbundle lock \-\-update nokogiri\fR\.
-.
-.P
-Bundler will update \fBnokogiri\fR and any of its dependencies, but leave the rest of the gems that you specified locked to the versions in the \fBGemfile\.lock\fR\.
-.
-.SH "SUPPORTING OTHER PLATFORMS"
-If you want your bundle to support platforms other than the one you\'re running locally, you can run \fBbundle lock \-\-add\-platform PLATFORM\fR to add PLATFORM to the lockfile, force bundler to re\-resolve and consider the new platform when picking gems, all without needing to have a machine that matches PLATFORM handy to install those platform\-specific gems on\.
-.
-.P
-For a full explanation of gem platforms, see \fBgem help platform\fR\.
-.
-.SH "PATCH LEVEL OPTIONS"
-See bundle update(1) \fIbundle\-update\.1\.html\fR for details\.
--- ruby2.7-2.7.6.orig/man/bundle-lock.1.txt
+++ /dev/null
@@ -1,93 +0,0 @@
-BUNDLE-LOCK(1)							BUNDLE-LOCK(1)
-
-
-
-NAME
-       bundle-lock - Creates / Updates a lockfile without installing
-
-SYNOPSIS
-       bundle	 lock	[--update]   [--local]	 [--print]   [--lockfile=PATH]
-       [--full-index] [--add-platform] [--remove-platform] [--patch] [--minor]
-       [--major] [--strict] [--conservative]
-
-DESCRIPTION
-       Lock the gems specified in Gemfile.
-
-OPTIONS
-       --update=<*gems>
-	      Ignores  the  existing  lockfile. Resolve then updates lockfile.
-	      Taking a list of gems or updating all gems if no list is given.
-
-       --local
-	      Do not attempt to connect to rubygems.org. Instead, Bundler will
-	      use  the	gems  already  present	in  Rubygems' cache or in ven-
-	      dor/cache. Note that  if	a  appropriate	platform-specific  gem
-	      exists on rubygems.org it will not be found.
-
-       --print
-	      Prints  the  lockfile  to  STDOUT instead of writing to the file
-	      system.
-
-       --lockfile=<path>
-	      The path where the lockfile should be written to.
-
-       --full-index
-	      Fall back to using the single-file index of all gems.
-
-       --add-platform
-	      Add a new platform to the lockfile, re-resolving for  the  addi-
-	      tion of that platform.
-
-       --remove-platform
-	      Remove a platform from the lockfile.
-
-       --patch
-	      If updating, prefer updating only to next patch version.
-
-       --minor
-	      If updating, prefer updating only to next minor version.
-
-       --major
-	      If updating, prefer updating to next major version (default).
-
-       --strict
-	      If  updating,  do  not  allow  any gem to be updated past latest
-	      --patch | --minor | --major.
-
-       --conservative
-	      If updating, use bundle install conservative update behavior and
-	      do not allow shared dependencies to be updated.
-
-UPDATING ALL GEMS
-       If  you	run  bundle  lock  with  --update option without list of gems,
-       bundler will ignore any	previously  installed  gems  and  resolve  all
-       dependencies  again  based on the latest versions of all gems available
-       in the sources.
-
-UPDATING A LIST OF GEMS
-       Sometimes, you want to update a single gem in the Gemfile(5), and leave
-       the  rest  of the gems that you specified locked to the versions in the
-       Gemfile.lock.
-
-       For instance, you  only	want  to  update  nokogiri,  run  bundle  lock
-       --update nokogiri.
-
-       Bundler will update nokogiri and any of its dependencies, but leave the
-       rest of the gems that you specified locked to the versions in the  Gem-
-       file.lock.
-
-SUPPORTING OTHER PLATFORMS
-       If  you want your bundle to support platforms other than the one you're
-       running locally, you can run bundle lock --add-platform PLATFORM to add
-       PLATFORM  to the lockfile, force bundler to re-resolve and consider the
-       new platform when picking gems, all without needing to have  a  machine
-       that matches PLATFORM handy to install those platform-specific gems on.
-
-       For a full explanation of gem platforms, see gem help platform.
-
-PATCH LEVEL OPTIONS
-       See bundle update(1) bundle-update.1.html for details.
-
-
-
-				 January 2020			BUNDLE-LOCK(1)
--- ruby2.7-2.7.6.orig/man/bundle-lock.ronn
+++ /dev/null
@@ -1,94 +0,0 @@
-bundle-lock(1) -- Creates / Updates a lockfile without installing
-=================================================================
-
-## SYNOPSIS
-
-`bundle lock` [--update]
-              [--local]
-              [--print]
-              [--lockfile=PATH]
-              [--full-index]
-              [--add-platform]
-              [--remove-platform]
-              [--patch]
-              [--minor]
-              [--major]
-              [--strict]
-              [--conservative]
-
-## DESCRIPTION
-
-Lock the gems specified in Gemfile.
-
-## OPTIONS
-
-* `--update=<*gems>`:
-  Ignores the existing lockfile. Resolve then updates lockfile. Taking a list
-  of gems or updating all gems if no list is given.
-
-* `--local`:
-  Do not attempt to connect to `rubygems.org`. Instead, Bundler will use the
-  gems already present in Rubygems' cache or in `vendor/cache`. Note that if a
-  appropriate platform-specific gem exists on `rubygems.org` it will not be
-  found.
-
-* `--print`:
-  Prints the lockfile to STDOUT instead of writing to the file system.
-
-* `--lockfile=<path>`:
-  The path where the lockfile should be written to.
-
-* `--full-index`:
-  Fall back to using the single-file index of all gems.
-
-* `--add-platform`:
-  Add a new platform to the lockfile, re-resolving for the addition of that
-  platform.
-
-* `--remove-platform`:
-  Remove a platform from the lockfile.
-
-* `--patch`:
-  If updating, prefer updating only to next patch version.
-
-* `--minor`:
-  If updating, prefer updating only to next minor version.
-
-* `--major`:
-  If updating, prefer updating to next major version (default).
-
-* `--strict`:
-  If updating, do not allow any gem to be updated past latest --patch | --minor | --major.
-
-* `--conservative`:
-  If updating, use bundle install conservative update behavior and do not allow shared dependencies to be updated.
-
-## UPDATING ALL GEMS
-
-If you run `bundle lock` with `--update` option without list of gems, bundler will
-ignore any previously installed gems and resolve all dependencies again based
-on the latest versions of all gems available in the sources.
-
-## UPDATING A LIST OF GEMS
-
-Sometimes, you want to update a single gem in the Gemfile(5), and leave the rest of
-the gems that you specified locked to the versions in the `Gemfile.lock`.
-
-For instance, you only want to update `nokogiri`, run `bundle lock --update nokogiri`.
-
-Bundler will update `nokogiri` and any of its dependencies, but leave the rest of the
-gems that you specified locked to the versions in the `Gemfile.lock`.
-
-## SUPPORTING OTHER PLATFORMS
-
-If you want your bundle to support platforms other than the one you're running
-locally, you can run `bundle lock --add-platform PLATFORM` to add PLATFORM to
-the lockfile, force bundler to re-resolve and consider the new platform when
-picking gems, all without needing to have a machine that matches PLATFORM handy
-to install those platform-specific gems on.
-
-For a full explanation of gem platforms, see `gem help platform`.
-
-## PATCH LEVEL OPTIONS
-
-See [bundle update(1)](bundle-update.1.html) for details.
--- ruby2.7-2.7.6.orig/man/bundle-open.1
+++ /dev/null
@@ -1,32 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-OPEN" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-open\fR \- Opens the source directory for a gem in your bundle
-.
-.SH "SYNOPSIS"
-\fBbundle open\fR [GEM]
-.
-.SH "DESCRIPTION"
-Opens the source directory of the provided GEM in your editor\.
-.
-.P
-For this to work the \fBEDITOR\fR or \fBBUNDLER_EDITOR\fR environment variable has to be set\.
-.
-.P
-Example:
-.
-.IP "" 4
-.
-.nf
-
-bundle open \'rack\'
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Will open the source directory for the \'rack\' gem in your bundle\.
--- ruby2.7-2.7.6.orig/man/bundle-open.1.txt
+++ /dev/null
@@ -1,29 +0,0 @@
-BUNDLE-OPEN(1)							BUNDLE-OPEN(1)
-
-
-
-NAME
-       bundle-open - Opens the source directory for a gem in your bundle
-
-SYNOPSIS
-       bundle open [GEM]
-
-DESCRIPTION
-       Opens the source directory of the provided GEM in your editor.
-
-       For  this to work the EDITOR or BUNDLER_EDITOR environment variable has
-       to be set.
-
-       Example:
-
-
-
-	   bundle open 'rack'
-
-
-
-       Will open the source directory for the 'rack' gem in your bundle.
-
-
-
-				 January 2020			BUNDLE-OPEN(1)
--- ruby2.7-2.7.6.orig/man/bundle-open.ronn
+++ /dev/null
@@ -1,19 +0,0 @@
-bundle-open(1) -- Opens the source directory for a gem in your bundle
-=====================================================================
-
-## SYNOPSIS
-
-`bundle open` [GEM]
-
-## DESCRIPTION
-
-Opens the source directory of the provided GEM in your editor.
-
-For this to work the `EDITOR` or `BUNDLER_EDITOR` environment variable has to
-be set.
-
-Example:
-
-    bundle open 'rack'
-
-Will open the source directory for the 'rack' gem in your bundle.
--- ruby2.7-2.7.6.orig/man/bundle-outdated.1
+++ /dev/null
@@ -1,155 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-OUTDATED" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-outdated\fR \- List installed gems with newer versions available
-.
-.SH "SYNOPSIS"
-\fBbundle outdated\fR [GEM] [\-\-local] [\-\-pre] [\-\-source] [\-\-strict] [\-\-parseable | \-\-porcelain] [\-\-group=GROUP] [\-\-groups] [\-\-update\-strict] [\-\-patch|\-\-minor|\-\-major] [\-\-filter\-major] [\-\-filter\-minor] [\-\-filter\-patch] [\-\-only\-explicit]
-.
-.SH "DESCRIPTION"
-Outdated lists the names and versions of gems that have a newer version available in the given source\. Calling outdated with [GEM [GEM]] will only check for newer versions of the given gems\. Prerelease gems are ignored by default\. If your gems are up to date, Bundler will exit with a status of 0\. Otherwise, it will exit 1\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-local\fR
-Do not attempt to fetch gems remotely and use the gem cache instead\.
-.
-.TP
-\fB\-\-pre\fR
-Check for newer pre\-release gems\.
-.
-.TP
-\fB\-\-source\fR
-Check against a specific source\.
-.
-.TP
-\fB\-\-strict\fR
-Only list newer versions allowed by your Gemfile requirements\.
-.
-.TP
-\fB\-\-parseable\fR, \fB\-\-porcelain\fR
-Use minimal formatting for more parseable output\.
-.
-.TP
-\fB\-\-group\fR
-List gems from a specific group\.
-.
-.TP
-\fB\-\-groups\fR
-List gems organized by groups\.
-.
-.TP
-\fB\-\-update\-strict\fR
-Strict conservative resolution, do not allow any gem to be updated past latest \-\-patch | \-\-minor| \-\-major\.
-.
-.TP
-\fB\-\-minor\fR
-Prefer updating only to next minor version\.
-.
-.TP
-\fB\-\-major\fR
-Prefer updating to next major version (default)\.
-.
-.TP
-\fB\-\-patch\fR
-Prefer updating only to next patch version\.
-.
-.TP
-\fB\-\-filter\-major\fR
-Only list major newer versions\.
-.
-.TP
-\fB\-\-filter\-minor\fR
-Only list minor newer versions\.
-.
-.TP
-\fB\-\-filter\-patch\fR
-Only list patch newer versions\.
-.
-.TP
-\fB\-\-only\-explicit\fR
-Only list gems specified in your Gemfile, not their dependencies\.
-.
-.SH "PATCH LEVEL OPTIONS"
-See bundle update(1) \fIbundle\-update\.1\.html\fR for details\.
-.
-.P
-One difference between the patch level options in \fBbundle update\fR and here is the \fB\-\-strict\fR option\. \fB\-\-strict\fR was already an option on outdated before the patch level options were added\. \fB\-\-strict\fR wasn\'t altered, and the \fB\-\-update\-strict\fR option on \fBoutdated\fR reflects what \fB\-\-strict\fR does on \fBbundle update\fR\.
-.
-.SH "FILTERING OUTPUT"
-The 3 filtering options do not affect the resolution of versions, merely what versions are shown in the output\.
-.
-.P
-If the regular output shows the following:
-.
-.IP "" 4
-.
-.nf
-
-* faker (newest 1\.6\.6, installed 1\.6\.5, requested ~> 1\.4) in groups "development, test"
-* hashie (newest 3\.4\.6, installed 1\.2\.0, requested = 1\.2\.0) in groups "default"
-* headless (newest 2\.3\.1, installed 2\.2\.3) in groups "test"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-\fB\-\-filter\-major\fR would only show:
-.
-.IP "" 4
-.
-.nf
-
-* hashie (newest 3\.4\.6, installed 1\.2\.0, requested = 1\.2\.0) in groups "default"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-\fB\-\-filter\-minor\fR would only show:
-.
-.IP "" 4
-.
-.nf
-
-* headless (newest 2\.3\.1, installed 2\.2\.3) in groups "test"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-\fB\-\-filter\-patch\fR would only show:
-.
-.IP "" 4
-.
-.nf
-
-* faker (newest 1\.6\.6, installed 1\.6\.5, requested ~> 1\.4) in groups "development, test"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Filter options can be combined\. \fB\-\-filter\-minor\fR and \fB\-\-filter\-patch\fR would show:
-.
-.IP "" 4
-.
-.nf
-
-* faker (newest 1\.6\.6, installed 1\.6\.5, requested ~> 1\.4) in groups "development, test"
-* headless (newest 2\.3\.1, installed 2\.2\.3) in groups "test"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Combining all three \fBfilter\fR options would be the same result as providing none of them\.
--- ruby2.7-2.7.6.orig/man/bundle-outdated.1.txt
+++ /dev/null
@@ -1,131 +0,0 @@
-BUNDLE-OUTDATED(1)					    BUNDLE-OUTDATED(1)
-
-
-
-NAME
-       bundle-outdated - List installed gems with newer versions available
-
-SYNOPSIS
-       bundle	outdated   [GEM]   [--local]   [--pre]	[--source]  [--strict]
-       [--parseable	|     --porcelain]     [--group=GROUP]	    [--groups]
-       [--update-strict]  [--patch|--minor|--major]  [--filter-major]  [--fil-
-       ter-minor] [--filter-patch] [--only-explicit]
-
-DESCRIPTION
-       Outdated lists the names and versions of gems that have a newer version
-       available  in  the given source. Calling outdated with [GEM [GEM]] will
-       only check for newer versions of the given gems.  Prerelease  gems  are
-       ignored by default. If your gems are up to date, Bundler will exit with
-       a status of 0. Otherwise, it will exit 1.
-
-OPTIONS
-       --local
-	      Do not attempt to fetch gems remotely  and  use  the  gem  cache
-	      instead.
-
-       --pre  Check for newer pre-release gems.
-
-       --source
-	      Check against a specific source.
-
-       --strict
-	      Only list newer versions allowed by your Gemfile requirements.
-
-       --parseable, --porcelain
-	      Use minimal formatting for more parseable output.
-
-       --group
-	      List gems from a specific group.
-
-       --groups
-	      List gems organized by groups.
-
-       --update-strict
-	      Strict  conservative  resolution,  do  not  allow  any gem to be
-	      updated past latest --patch | --minor| --major.
-
-       --minor
-	      Prefer updating only to next minor version.
-
-       --major
-	      Prefer updating to next major version (default).
-
-       --patch
-	      Prefer updating only to next patch version.
-
-       --filter-major
-	      Only list major newer versions.
-
-       --filter-minor
-	      Only list minor newer versions.
-
-       --filter-patch
-	      Only list patch newer versions.
-
-       --only-explicit
-	      Only list gems specified in your Gemfile,  not  their  dependen-
-	      cies.
-
-PATCH LEVEL OPTIONS
-       See bundle update(1) bundle-update.1.html for details.
-
-       One  difference	between  the  patch level options in bundle update and
-       here is the --strict option. --strict was already an option on outdated
-       before the patch level options were added. --strict wasn't altered, and
-       the --update-strict option on outdated reflects what --strict  does  on
-       bundle update.
-
-FILTERING OUTPUT
-       The  3  filtering  options  do  not  affect the resolution of versions,
-       merely what versions are shown in the output.
-
-       If the regular output shows the following:
-
-
-
-	   * faker (newest 1.6.6, installed 1.6.5, requested ~> 1.4) in groups "development, test"
-	   * hashie (newest 3.4.6, installed 1.2.0, requested = 1.2.0) in groups "default"
-	   * headless (newest 2.3.1, installed 2.2.3) in groups "test"
-
-
-
-       --filter-major would only show:
-
-
-
-	   * hashie (newest 3.4.6, installed 1.2.0, requested = 1.2.0) in groups "default"
-
-
-
-       --filter-minor would only show:
-
-
-
-	   * headless (newest 2.3.1, installed 2.2.3) in groups "test"
-
-
-
-       --filter-patch would only show:
-
-
-
-	   * faker (newest 1.6.6, installed 1.6.5, requested ~> 1.4) in groups "development, test"
-
-
-
-       Filter options can be combined. --filter-minor and --filter-patch would
-       show:
-
-
-
-	   * faker (newest 1.6.6, installed 1.6.5, requested ~> 1.4) in groups "development, test"
-	   * headless (newest 2.3.1, installed 2.2.3) in groups "test"
-
-
-
-       Combining  all three filter options would be the same result as provid-
-       ing none of them.
-
-
-
-				 January 2020		    BUNDLE-OUTDATED(1)
--- ruby2.7-2.7.6.orig/man/bundle-outdated.ronn
+++ /dev/null
@@ -1,111 +0,0 @@
-bundle-outdated(1) -- List installed gems with newer versions available
-=======================================================================
-
-## SYNOPSIS
-
-`bundle outdated` [GEM] [--local]
-                        [--pre]
-                        [--source]
-                        [--strict]
-                        [--parseable | --porcelain]
-                        [--group=GROUP]
-                        [--groups]
-                        [--update-strict]
-                        [--patch|--minor|--major]
-                        [--filter-major]
-                        [--filter-minor]
-                        [--filter-patch]
-                        [--only-explicit]
-
-## DESCRIPTION
-
-Outdated lists the names and versions of gems that have a newer version available
-in the given source. Calling outdated with [GEM [GEM]] will only check for newer
-versions of the given gems. Prerelease gems are ignored by default. If your gems
-are up to date, Bundler will exit with a status of 0. Otherwise, it will exit 1.
-
-## OPTIONS
-
-* `--local`:
-  Do not attempt to fetch gems remotely and use the gem cache instead.
-
-* `--pre`:
-  Check for newer pre-release gems.
-
-* `--source`:
-  Check against a specific source.
-
-* `--strict`:
-  Only list newer versions allowed by your Gemfile requirements.
-
-* `--parseable`, `--porcelain`:
-   Use minimal formatting for more parseable output.
-
-* `--group`:
-  List gems from a specific group.
-
-* `--groups`:
-  List gems organized by groups.
-
-* `--update-strict`:
-  Strict conservative resolution, do not allow any gem to be updated past latest --patch | --minor| --major.
-
-* `--minor`:
-  Prefer updating only to next minor version.
-
-* `--major`:
-  Prefer updating to next major version (default).
-
-* `--patch`:
-  Prefer updating only to next patch version.
-
-* `--filter-major`:
-  Only list major newer versions.
-
-* `--filter-minor`:
-  Only list minor newer versions.
-
-* `--filter-patch`:
-  Only list patch newer versions.
-
-* `--only-explicit`:
-  Only list gems specified in your Gemfile, not their dependencies.
-
-## PATCH LEVEL OPTIONS
-
-See [bundle update(1)](bundle-update.1.html) for details.
-
-One difference between the patch level options in `bundle update` and here is the `--strict` option.
-`--strict` was already an option on outdated before the patch level options were added. `--strict`
-wasn't altered, and the `--update-strict` option on `outdated` reflects what `--strict` does on
-`bundle update`.
-
-## FILTERING OUTPUT
-
-The 3 filtering options do not affect the resolution of versions, merely what versions are shown
-in the output.
-
-If the regular output shows the following:
-
-    * faker (newest 1.6.6, installed 1.6.5, requested ~> 1.4) in groups "development, test"
-    * hashie (newest 3.4.6, installed 1.2.0, requested = 1.2.0) in groups "default"
-    * headless (newest 2.3.1, installed 2.2.3) in groups "test"
-
-`--filter-major` would only show:
-
-    * hashie (newest 3.4.6, installed 1.2.0, requested = 1.2.0) in groups "default"
-
-`--filter-minor` would only show:
-
-    * headless (newest 2.3.1, installed 2.2.3) in groups "test"
-
-`--filter-patch` would only show:
-
-    * faker (newest 1.6.6, installed 1.6.5, requested ~> 1.4) in groups "development, test"
-
-Filter options can be combined. `--filter-minor` and `--filter-patch` would show:
-
-    * faker (newest 1.6.6, installed 1.6.5, requested ~> 1.4) in groups "development, test"
-    * headless (newest 2.3.1, installed 2.2.3) in groups "test"
-
-Combining all three `filter` options would be the same result as providing none of them.
--- ruby2.7-2.7.6.orig/man/bundle-package.1
+++ /dev/null
@@ -1,55 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-PACKAGE" "1" "September 2019" "" ""
-.
-.SH "NAME"
-\fBbundle\-package\fR \- Package your needed \fB\.gem\fR files into your application
-.
-.SH "SYNOPSIS"
-\fBbundle package\fR
-.
-.SH "DESCRIPTION"
-Copy all of the \fB\.gem\fR files needed to run the application into the \fBvendor/cache\fR directory\. In the future, when running [bundle install(1)][bundle\-install], use the gems in the cache in preference to the ones on \fBrubygems\.org\fR\.
-.
-.SH "GIT AND PATH GEMS"
-Since Bundler 1\.2, the \fBbundle package\fR command can also package \fB:git\fR and \fB:path\fR dependencies besides \.gem files\. This needs to be explicitly enabled via the \fB\-\-all\fR option\. Once used, the \fB\-\-all\fR option will be remembered\.
-.
-.SH "SUPPORT FOR MULTIPLE PLATFORMS"
-When using gems that have different packages for different platforms, Bundler 1\.8 and newer support caching of gems for other platforms where the Gemfile has been resolved (i\.e\. present in the lockfile) in \fBvendor/cache\fR\. This needs to be enabled via the \fB\-\-all\-platforms\fR option\. This setting will be remembered in your local bundler configuration\.
-.
-.SH "REMOTE FETCHING"
-By default, if you run \fBbundle install(1)\fR](bundle\-install\.1\.html) after running bundle package(1) \fIbundle\-package\.1\.html\fR, bundler will still connect to \fBrubygems\.org\fR to check whether a platform\-specific gem exists for any of the gems in \fBvendor/cache\fR\.
-.
-.P
-For instance, consider this Gemfile(5):
-.
-.IP "" 4
-.
-.nf
-
-source "https://rubygems\.org"
-
-gem "nokogiri"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-If you run \fBbundle package\fR under C Ruby, bundler will retrieve the version of \fBnokogiri\fR for the \fB"ruby"\fR platform\. If you deploy to JRuby and run \fBbundle install\fR, bundler is forced to check to see whether a \fB"java"\fR platformed \fBnokogiri\fR exists\.
-.
-.P
-Even though the \fBnokogiri\fR gem for the Ruby platform is \fItechnically\fR acceptable on JRuby, it has a C extension that does not run on JRuby\. As a result, bundler will, by default, still connect to \fBrubygems\.org\fR to check whether it has a version of one of your gems more specific to your platform\.
-.
-.P
-This problem is also not limited to the \fB"java"\fR platform\. A similar (common) problem can happen when developing on Windows and deploying to Linux, or even when developing on OSX and deploying to Linux\.
-.
-.P
-If you know for sure that the gems packaged in \fBvendor/cache\fR are appropriate for the platform you are on, you can run \fBbundle install \-\-local\fR to skip checking for more appropriate gems, and use the ones in \fBvendor/cache\fR\.
-.
-.P
-One way to be sure that you have the right platformed versions of all your gems is to run \fBbundle package\fR on an identical machine and check in the gems\. For instance, you can run \fBbundle package\fR on an identical staging box during your staging process, and check in the \fBvendor/cache\fR before deploying to production\.
-.
-.P
-By default, bundle package(1) \fIbundle\-package\.1\.html\fR fetches and also installs the gems to the default location\. To package the dependencies to \fBvendor/cache\fR without installing them to the local install location, you can run \fBbundle package \-\-no\-install\fR\.
--- ruby2.7-2.7.6.orig/man/bundle-package.1.txt
+++ /dev/null
@@ -1,79 +0,0 @@
-BUNDLE-PACKAGE(1)					     BUNDLE-PACKAGE(1)
-
-
-
-NAME
-       bundle-package - Package your needed .gem files into your application
-
-SYNOPSIS
-       bundle package
-
-DESCRIPTION
-       Copy  all of the .gem files needed to run the application into the ven-
-       dor/cache   directory.	In   the   future,   when   running    [bundle
-       install(1)][bundle-install], use the gems in the cache in preference to
-       the ones on rubygems.org.
-
-GIT AND PATH GEMS
-       Since Bundler 1.2, the bundle package command can also package :git and
-       :path  dependencies  besides  .gem  files.  This needs to be explicitly
-       enabled via the --all option. Once  used,  the  --all  option  will  be
-       remembered.
-
-SUPPORT FOR MULTIPLE PLATFORMS
-       When  using  gems that have different packages for different platforms,
-       Bundler 1.8 and newer support caching of gems for other platforms where
-       the  Gemfile  has  been resolved (i.e. present in the lockfile) in ven-
-       dor/cache. This needs to be enabled  via  the  --all-platforms  option.
-       This setting will be remembered in your local bundler configuration.
-
-REMOTE FETCHING
-       By  default, if you run bundle install(1)](bundle-install.1.html) after
-       running bundle package(1)  bundle-package.1.html,  bundler  will  still
-       connect to rubygems.org to check whether a platform-specific gem exists
-       for any of the gems in vendor/cache.
-
-       For instance, consider this Gemfile(5):
-
-
-
-	   source "https://rubygems.org"
-
-	   gem "nokogiri"
-
-
-
-       If you run bundle package under C Ruby, bundler will retrieve the  ver-
-       sion  of  nokogiri  for the "ruby" platform. If you deploy to JRuby and
-       run bundle install, bundler is forced to check to see whether a	"java"
-       platformed nokogiri exists.
-
-       Even  though  the  nokogiri  gem  for  the Ruby platform is technically
-       acceptable on JRuby, it has a C extension that does not run  on	JRuby.
-       As a result, bundler will, by default, still connect to rubygems.org to
-       check whether it has a version of one of your  gems  more  specific  to
-       your platform.
-
-       This  problem  is  also	not  limited to the "java" platform. A similar
-       (common) problem can happen when developing on Windows and deploying to
-       Linux, or even when developing on OSX and deploying to Linux.
-
-       If  you know for sure that the gems packaged in vendor/cache are appro-
-       priate for the platform you are on, you can run bundle install  --local
-       to  skip  checking  for more appropriate gems, and use the ones in ven-
-       dor/cache.
-
-       One way to be sure that you have the right platformed versions  of  all
-       your gems is to run bundle package on an identical machine and check in
-       the gems. For instance, you can run  bundle  package  on  an  identical
-       staging	box during your staging process, and check in the vendor/cache
-       before deploying to production.
-
-       By default, bundle package(1) bundle-package.1.html  fetches  and  also
-       installs  the gems to the default location. To package the dependencies
-       to vendor/cache without installing them to the local install  location,
-       you can run bundle package --no-install.
-
-
-
-				September 2019		     BUNDLE-PACKAGE(1)
--- ruby2.7-2.7.6.orig/man/bundle-package.ronn
+++ /dev/null
@@ -1,72 +0,0 @@
-bundle-package(1) -- Package your needed `.gem` files into your application
-===========================================================================
-
-## SYNOPSIS
-
-`bundle package`
-
-## DESCRIPTION
-
-Copy all of the `.gem` files needed to run the application into the
-`vendor/cache` directory. In the future, when running [bundle install(1)][bundle-install],
-use the gems in the cache in preference to the ones on `rubygems.org`.
-
-## GIT AND PATH GEMS
-
-Since Bundler 1.2, the `bundle package` command can also package `:git` and
-`:path` dependencies besides .gem files. This needs to be explicitly enabled
-via the `--all` option. Once used, the `--all` option will be remembered.
-
-## SUPPORT FOR MULTIPLE PLATFORMS
-
-When using gems that have different packages for different platforms, Bundler
-1.8 and newer support caching of gems for other platforms where the Gemfile
-has been resolved (i.e. present in the lockfile) in `vendor/cache`.  This needs
-to be enabled via the `--all-platforms` option. This setting will be remembered
-in your local bundler configuration.
-
-## REMOTE FETCHING
-
-By default, if you run `bundle install(1)`](bundle-install.1.html) after running
-[bundle package(1)](bundle-package.1.html), bundler will still connect to `rubygems.org`
-to check whether a platform-specific gem exists for any of the gems
-in `vendor/cache`.
-
-For instance, consider this Gemfile(5):
-
-    source "https://rubygems.org"
-
-    gem "nokogiri"
-
-If you run `bundle package` under C Ruby, bundler will retrieve
-the version of `nokogiri` for the `"ruby"` platform. If you deploy
-to JRuby and run `bundle install`, bundler is forced to check to
-see whether a `"java"` platformed `nokogiri` exists.
-
-Even though the `nokogiri` gem for the Ruby platform is
-_technically_ acceptable on JRuby, it has a C extension
-that does not run on JRuby. As a result, bundler will, by default,
-still connect to `rubygems.org` to check whether it has a version
-of one of your gems more specific to your platform.
-
-This problem is also not limited to the `"java"` platform.
-A similar (common) problem can happen when developing on Windows
-and deploying to Linux, or even when developing on OSX and
-deploying to Linux.
-
-If you know for sure that the gems packaged in `vendor/cache`
-are appropriate for the platform you are on, you can run
-`bundle install --local` to skip checking for more appropriate
-gems, and use the ones in `vendor/cache`.
-
-One way to be sure that you have the right platformed versions
-of all your gems is to run `bundle package` on an identical
-machine and check in the gems. For instance, you can run
-`bundle package` on an identical staging box during your
-staging process, and check in the `vendor/cache` before
-deploying to production.
-
-By default, [bundle package(1)](bundle-package.1.html) fetches and also
-installs the gems to the default location. To package the
-dependencies to `vendor/cache` without installing them to the
-local install location, you can run `bundle package --no-install`.
--- ruby2.7-2.7.6.orig/man/bundle-platform.1
+++ /dev/null
@@ -1,61 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-PLATFORM" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-platform\fR \- Displays platform compatibility information
-.
-.SH "SYNOPSIS"
-\fBbundle platform\fR [\-\-ruby]
-.
-.SH "DESCRIPTION"
-\fBplatform\fR will display information from your Gemfile, Gemfile\.lock, and Ruby VM about your platform\.
-.
-.P
-For instance, using this Gemfile(5):
-.
-.IP "" 4
-.
-.nf
-
-source "https://rubygems\.org"
-
-ruby "1\.9\.3"
-
-gem "rack"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-If you run \fBbundle platform\fR on Ruby 1\.9\.3, it will display the following output:
-.
-.IP "" 4
-.
-.nf
-
-Your platform is: x86_64\-linux
-
-Your app has gems that work on these platforms:
-* ruby
-
-Your Gemfile specifies a Ruby version requirement:
-* ruby 1\.9\.3
-
-Your current platform satisfies the Ruby version requirement\.
-.
-.fi
-.
-.IP "" 0
-.
-.P
-\fBplatform\fR will list all the platforms in your \fBGemfile\.lock\fR as well as the \fBruby\fR directive if applicable from your Gemfile(5)\. It will also let you know if the \fBruby\fR directive requirement has been met\. If \fBruby\fR directive doesn\'t match the running Ruby VM, it will tell you what part does not\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-ruby\fR
-It will display the ruby directive information, so you don\'t have to parse it from the Gemfile(5)\.
-
--- ruby2.7-2.7.6.orig/man/bundle-platform.1.txt
+++ /dev/null
@@ -1,57 +0,0 @@
-BUNDLE-PLATFORM(1)					    BUNDLE-PLATFORM(1)
-
-
-
-NAME
-       bundle-platform - Displays platform compatibility information
-
-SYNOPSIS
-       bundle platform [--ruby]
-
-DESCRIPTION
-       platform  will display information from your Gemfile, Gemfile.lock, and
-       Ruby VM about your platform.
-
-       For instance, using this Gemfile(5):
-
-
-
-	   source "https://rubygems.org"
-
-	   ruby "1.9.3"
-
-	   gem "rack"
-
-
-
-       If you run bundle platform on Ruby 1.9.3, it will display the following
-       output:
-
-
-
-	   Your platform is: x86_64-linux
-
-	   Your app has gems that work on these platforms:
-	   * ruby
-
-	   Your Gemfile specifies a Ruby version requirement:
-	   * ruby 1.9.3
-
-	   Your current platform satisfies the Ruby version requirement.
-
-
-
-       platform  will  list  all the platforms in your Gemfile.lock as well as
-       the ruby directive if applicable from your Gemfile(5). It will also let
-       you know if the ruby directive requirement has been met. If ruby direc-
-       tive doesn't match the running Ruby VM, it will tell you what part does
-       not.
-
-OPTIONS
-       --ruby It  will	display  the  ruby directive information, so you don't
-	      have to parse it from the Gemfile(5).
-
-
-
-
-				 January 2020		    BUNDLE-PLATFORM(1)
--- ruby2.7-2.7.6.orig/man/bundle-platform.ronn
+++ /dev/null
@@ -1,42 +0,0 @@
-bundle-platform(1) -- Displays platform compatibility information
-=================================================================
-
-## SYNOPSIS
-
-`bundle platform` [--ruby]
-
-## DESCRIPTION
-
-`platform` will display information from your Gemfile, Gemfile.lock, and Ruby
-VM about your platform.
-
-For instance, using this Gemfile(5):
-
-    source "https://rubygems.org"
-
-    ruby "1.9.3"
-
-    gem "rack"
-
-If you run `bundle platform` on Ruby 1.9.3, it will display the following output:
-
-    Your platform is: x86_64-linux
-
-    Your app has gems that work on these platforms:
-    * ruby
-
-    Your Gemfile specifies a Ruby version requirement:
-    * ruby 1.9.3
-
-    Your current platform satisfies the Ruby version requirement.
-
-`platform` will list all the platforms in your `Gemfile.lock` as well as the
-`ruby` directive if applicable from your Gemfile(5). It will also let you know
-if the `ruby` directive requirement has been met. If `ruby` directive doesn't
-match the running Ruby VM, it will tell you what part does not.
-
-## OPTIONS
-
-* `--ruby`:
-  It will display the ruby directive information, so you don't have to
-  parse it from the Gemfile(5).
--- ruby2.7-2.7.6.orig/man/bundle-pristine.1
+++ /dev/null
@@ -1,34 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-PRISTINE" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-pristine\fR \- Restores installed gems to their pristine condition
-.
-.SH "SYNOPSIS"
-\fBbundle pristine\fR
-.
-.SH "DESCRIPTION"
-\fBpristine\fR restores the installed gems in the bundle to their pristine condition using the local gem cache from RubyGems\. For git gems, a forced checkout will be performed\.
-.
-.P
-For further explanation, \fBbundle pristine\fR ignores unpacked files on disk\. In other words, this command utilizes the local \fB\.gem\fR cache or the gem\'s git repository as if one were installing from scratch\.
-.
-.P
-Note: the Bundler gem cannot be restored to its original state with \fBpristine\fR\. One also cannot use \fBbundle pristine\fR on gems with a \'path\' option in the Gemfile, because bundler has no original copy it can restore from\.
-.
-.P
-When is it practical to use \fBbundle pristine\fR?
-.
-.P
-It comes in handy when a developer is debugging a gem\. \fBbundle pristine\fR is a great way to get rid of experimental changes to a gem that one may not want\.
-.
-.P
-Why use \fBbundle pristine\fR over \fBgem pristine \-\-all\fR?
-.
-.P
-Both commands are very similar\. For context: \fBbundle pristine\fR, without arguments, cleans all gems from the lockfile\. Meanwhile, \fBgem pristine \-\-all\fR cleans all installed gems for that Ruby version\.
-.
-.P
-If a developer forgets which gems in their project they might have been debugging, the Rubygems \fBgem pristine [GEMNAME]\fR command may be inconvenient\. One can avoid waiting for \fBgem pristine \-\-all\fR, and instead run \fBbundle pristine\fR\.
--- ruby2.7-2.7.6.orig/man/bundle-pristine.1.txt
+++ /dev/null
@@ -1,44 +0,0 @@
-BUNDLE-PRISTINE(1)					    BUNDLE-PRISTINE(1)
-
-
-
-NAME
-       bundle-pristine - Restores installed gems to their pristine condition
-
-SYNOPSIS
-       bundle pristine
-
-DESCRIPTION
-       pristine  restores  the	installed gems in the bundle to their pristine
-       condition using the local gem cache from  RubyGems.  For  git  gems,  a
-       forced checkout will be performed.
-
-       For  further  explanation,  bundle  pristine  ignores unpacked files on
-       disk. In other words, this command utilizes the local .gem cache or the
-       gem's git repository as if one were installing from scratch.
-
-       Note:  the  Bundler  gem  cannot be restored to its original state with
-       pristine. One also cannot use bundle pristine on  gems  with  a	'path'
-       option  in  the	Gemfile,  because  bundler has no original copy it can
-       restore from.
-
-       When is it practical to use bundle pristine?
-
-       It comes in handy when a developer is debugging a gem. bundle  pristine
-       is a great way to get rid of experimental changes to a gem that one may
-       not want.
-
-       Why use bundle pristine over gem pristine --all?
-
-       Both commands are very similar. For context: bundle  pristine,  without
-       arguments,  cleans  all gems from the lockfile. Meanwhile, gem pristine
-       --all cleans all installed gems for that Ruby version.
-
-       If a developer forgets which gems in their project they might have been
-       debugging,  the Rubygems gem pristine [GEMNAME] command may be inconve-
-       nient. One can avoid waiting for gem pristine --all,  and  instead  run
-       bundle pristine.
-
-
-
-				 January 2020		    BUNDLE-PRISTINE(1)
--- ruby2.7-2.7.6.orig/man/bundle-pristine.ronn
+++ /dev/null
@@ -1,34 +0,0 @@
-bundle-pristine(1) -- Restores installed gems to their pristine condition
-===========================================================================
-
-## SYNOPSIS
-
-`bundle pristine`
-
-## DESCRIPTION
-
-`pristine` restores the installed gems in the bundle to their pristine condition
-using the local gem cache from RubyGems. For git gems, a forced checkout will be performed.
-
-For further explanation, `bundle pristine` ignores unpacked files on disk. In other
-words, this command utilizes the local `.gem` cache or the gem's git repository
-as if one were installing from scratch.
-
-Note: the Bundler gem cannot be restored to its original state with `pristine`.
-One also cannot use `bundle pristine` on gems with a 'path' option in the Gemfile,
-because bundler has no original copy it can restore from.
-
-When is it practical to use `bundle pristine`?
-
-It comes in handy when a developer is debugging a gem. `bundle pristine` is a
-great way to get rid of experimental changes to a gem that one may not want.
-
-Why use `bundle pristine` over `gem pristine --all`?
-
-Both commands are very similar.
-For context: `bundle pristine`, without arguments, cleans all gems from the lockfile.
-Meanwhile, `gem pristine --all` cleans all installed gems for that Ruby version.
-
-If a developer forgets which gems in their project they might
-have been debugging, the Rubygems `gem pristine [GEMNAME]` command may be inconvenient.
-One can avoid waiting for `gem pristine --all`, and instead run `bundle pristine`.
--- ruby2.7-2.7.6.orig/man/bundle-remove.1
+++ /dev/null
@@ -1,31 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-REMOVE" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-remove\fR \- Removes gems from the Gemfile
-.
-.SH "SYNOPSIS"
-\fBbundle remove [GEM [GEM \.\.\.]] [\-\-install]\fR
-.
-.SH "DESCRIPTION"
-Removes the given gems from the Gemfile while ensuring that the resulting Gemfile is still valid\. If a gem cannot be removed, a warning is printed\. If a gem is already absent from the Gemfile, and error is raised\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-install\fR
-Runs \fBbundle install\fR after the given gems have been removed from the Gemfile, which ensures that both the lockfile and the installed gems on disk are also updated to remove the given gem(s)\.
-.
-.P
-Example:
-.
-.P
-bundle remove rails
-.
-.P
-bundle remove rails rack
-.
-.P
-bundle remove rails rack \-\-install
--- ruby2.7-2.7.6.orig/man/bundle-remove.1.txt
+++ /dev/null
@@ -1,34 +0,0 @@
-BUNDLE-REMOVE(1)					      BUNDLE-REMOVE(1)
-
-
-
-NAME
-       bundle-remove - Removes gems from the Gemfile
-
-SYNOPSIS
-       bundle remove [GEM [GEM ...]] [--install]
-
-DESCRIPTION
-       Removes the given gems from the Gemfile while ensuring that the result-
-       ing Gemfile is still valid. If a gem cannot be removed,	a  warning  is
-       printed.  If  a	gem  is  already absent from the Gemfile, and error is
-       raised.
-
-OPTIONS
-       --install
-	      Runs bundle install after the given gems have been removed  from
-	      the  Gemfile,  which  ensures  that  both  the  lockfile and the
-	      installed gems on disk are also  updated	to  remove  the  given
-	      gem(s).
-
-       Example:
-
-       bundle remove rails
-
-       bundle remove rails rack
-
-       bundle remove rails rack --install
-
-
-
-				 January 2020		      BUNDLE-REMOVE(1)
--- ruby2.7-2.7.6.orig/man/bundle-remove.ronn
+++ /dev/null
@@ -1,23 +0,0 @@
-bundle-remove(1) -- Removes gems from the Gemfile
-===========================================================================
-
-## SYNOPSIS
-
-`bundle remove [GEM [GEM ...]] [--install]`
-
-## DESCRIPTION
-
-Removes the given gems from the Gemfile while ensuring that the resulting Gemfile is still valid. If a gem cannot be removed, a warning is printed. If a gem is already absent from the Gemfile, and error is raised.
-
-## OPTIONS
-
-* `--install`:
-  Runs `bundle install` after the given gems have been removed from the Gemfile, which ensures that both the lockfile and the installed gems on disk are also updated to remove the given gem(s).
-
-Example:
-
-bundle remove rails
-
-bundle remove rails rack
-
-bundle remove rails rack --install
--- ruby2.7-2.7.6.orig/man/bundle-show.1
+++ /dev/null
@@ -1,23 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-SHOW" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-show\fR \- Shows all the gems in your bundle, or the path to a gem
-.
-.SH "SYNOPSIS"
-\fBbundle show\fR [GEM] [\-\-paths]
-.
-.SH "DESCRIPTION"
-Without the [GEM] option, \fBshow\fR will print a list of the names and versions of all gems that are required by your [\fBGemfile(5)\fR][Gemfile(5)], sorted by name\.
-.
-.P
-Calling show with [GEM] will list the exact location of that gem on your machine\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-paths\fR
-List the paths of all gems that are required by your [\fBGemfile(5)\fR][Gemfile(5)], sorted by gem name\.
-
--- ruby2.7-2.7.6.orig/man/bundle-show.1.txt
+++ /dev/null
@@ -1,27 +0,0 @@
-BUNDLE-SHOW(1)							BUNDLE-SHOW(1)
-
-
-
-NAME
-       bundle-show - Shows all the gems in your bundle, or the path to a gem
-
-SYNOPSIS
-       bundle show [GEM] [--paths]
-
-DESCRIPTION
-       Without	the [GEM] option, show will print a list of the names and ver-
-       sions of all gems that are required by  your  [Gemfile(5)][Gemfile(5)],
-       sorted by name.
-
-       Calling	show  with  [GEM]  will list the exact location of that gem on
-       your machine.
-
-OPTIONS
-       --paths
-	      List the paths of all gems  that	are  required  by  your  [Gem-
-	      file(5)][Gemfile(5)], sorted by gem name.
-
-
-
-
-				 January 2020			BUNDLE-SHOW(1)
--- ruby2.7-2.7.6.orig/man/bundle-show.ronn
+++ /dev/null
@@ -1,21 +0,0 @@
-bundle-show(1) -- Shows all the gems in your bundle, or the path to a gem
-=========================================================================
-
-## SYNOPSIS
-
-`bundle show` [GEM]
-              [--paths]
-
-## DESCRIPTION
-
-Without the [GEM] option, `show` will print a list of the names and versions of
-all gems that are required by your [`Gemfile(5)`][Gemfile(5)], sorted by name.
-
-Calling show with [GEM] will list the exact location of that gem on your
-machine.
-
-## OPTIONS
-
-* `--paths`:
-  List the paths of all gems that are required by your [`Gemfile(5)`][Gemfile(5)],
-  sorted by gem name.
--- ruby2.7-2.7.6.orig/man/bundle-update.1
+++ /dev/null
@@ -1,394 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-UPDATE" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-update\fR \- Update your gems to the latest available versions
-.
-.SH "SYNOPSIS"
-\fBbundle update\fR \fI*gems\fR [\-\-all] [\-\-group=NAME] [\-\-source=NAME] [\-\-local] [\-\-ruby] [\-\-bundler[=VERSION]] [\-\-full\-index] [\-\-jobs=JOBS] [\-\-quiet] [\-\-patch|\-\-minor|\-\-major] [\-\-redownload] [\-\-strict] [\-\-conservative]
-.
-.SH "DESCRIPTION"
-Update the gems specified (all gems, if \fB\-\-all\fR flag is used), ignoring the previously installed gems specified in the \fBGemfile\.lock\fR\. In general, you should use bundle install(1) \fIbundle\-install\.1\.html\fR to install the same exact gems and versions across machines\.
-.
-.P
-You would use \fBbundle update\fR to explicitly update the version of a gem\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-all\fR
-Update all gems specified in Gemfile\.
-.
-.TP
-\fB\-\-group=<name>\fR, \fB\-g=[<name>]\fR
-Only update the gems in the specified group\. For instance, you can update all gems in the development group with \fBbundle update \-\-group development\fR\. You can also call \fBbundle update rails \-\-group test\fR to update the rails gem and all gems in the test group, for example\.
-.
-.TP
-\fB\-\-source=<name>\fR
-The name of a \fB:git\fR or \fB:path\fR source used in the Gemfile(5)\. For instance, with a \fB:git\fR source of \fBhttp://github\.com/rails/rails\.git\fR, you would call \fBbundle update \-\-source rails\fR
-.
-.TP
-\fB\-\-local\fR
-Do not attempt to fetch gems remotely and use the gem cache instead\.
-.
-.TP
-\fB\-\-ruby\fR
-Update the locked version of Ruby to the current version of Ruby\.
-.
-.TP
-\fB\-\-bundler\fR
-Update the locked version of bundler to the invoked bundler version\.
-.
-.TP
-\fB\-\-full\-index\fR
-Fall back to using the single\-file index of all gems\.
-.
-.TP
-\fB\-\-jobs=[<number>]\fR, \fB\-j[<number>]\fR
-Specify the number of jobs to run in parallel\. The default is \fB1\fR\.
-.
-.TP
-\fB\-\-retry=[<number>]\fR
-Retry failed network or git requests for \fInumber\fR times\.
-.
-.TP
-\fB\-\-quiet\fR
-Only output warnings and errors\.
-.
-.TP
-\fB\-\-redownload\fR
-Force downloading every gem\.
-.
-.TP
-\fB\-\-patch\fR
-Prefer updating only to next patch version\.
-.
-.TP
-\fB\-\-minor\fR
-Prefer updating only to next minor version\.
-.
-.TP
-\fB\-\-major\fR
-Prefer updating to next major version (default)\.
-.
-.TP
-\fB\-\-strict\fR
-Do not allow any gem to be updated past latest \fB\-\-patch\fR | \fB\-\-minor\fR | \fB\-\-major\fR\.
-.
-.TP
-\fB\-\-conservative\fR
-Use bundle install conservative update behavior and do not allow shared dependencies to be updated\.
-.
-.SH "UPDATING ALL GEMS"
-If you run \fBbundle update \-\-all\fR, bundler will ignore any previously installed gems and resolve all dependencies again based on the latest versions of all gems available in the sources\.
-.
-.P
-Consider the following Gemfile(5):
-.
-.IP "" 4
-.
-.nf
-
-source "https://rubygems\.org"
-
-gem "rails", "3\.0\.0\.rc"
-gem "nokogiri"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-When you run bundle install(1) \fIbundle\-install\.1\.html\fR the first time, bundler will resolve all of the dependencies, all the way down, and install what you need:
-.
-.IP "" 4
-.
-.nf
-
-Fetching gem metadata from https://rubygems\.org/\.\.\.\.\.\.\.\.\.
-Resolving dependencies\.\.\.
-Installing builder 2\.1\.2
-Installing abstract 1\.0\.0
-Installing rack 1\.2\.8
-Using bundler 1\.7\.6
-Installing rake 10\.4\.0
-Installing polyglot 0\.3\.5
-Installing mime\-types 1\.25\.1
-Installing i18n 0\.4\.2
-Installing mini_portile 0\.6\.1
-Installing tzinfo 0\.3\.42
-Installing rack\-mount 0\.6\.14
-Installing rack\-test 0\.5\.7
-Installing treetop 1\.4\.15
-Installing thor 0\.14\.6
-Installing activesupport 3\.0\.0\.rc
-Installing erubis 2\.6\.6
-Installing activemodel 3\.0\.0\.rc
-Installing arel 0\.4\.0
-Installing mail 2\.2\.20
-Installing activeresource 3\.0\.0\.rc
-Installing actionpack 3\.0\.0\.rc
-Installing activerecord 3\.0\.0\.rc
-Installing actionmailer 3\.0\.0\.rc
-Installing railties 3\.0\.0\.rc
-Installing rails 3\.0\.0\.rc
-Installing nokogiri 1\.6\.5
-
-Bundle complete! 2 Gemfile dependencies, 26 gems total\.
-Use `bundle show [gemname]` to see where a bundled gem is installed\.
-.
-.fi
-.
-.IP "" 0
-.
-.P
-As you can see, even though you have two gems in the Gemfile(5), your application needs 26 different gems in order to run\. Bundler remembers the exact versions it installed in \fBGemfile\.lock\fR\. The next time you run bundle install(1) \fIbundle\-install\.1\.html\fR, bundler skips the dependency resolution and installs the same gems as it installed last time\.
-.
-.P
-After checking in the \fBGemfile\.lock\fR into version control and cloning it on another machine, running bundle install(1) \fIbundle\-install\.1\.html\fR will \fIstill\fR install the gems that you installed last time\. You don\'t need to worry that a new release of \fBerubis\fR or \fBmail\fR changes the gems you use\.
-.
-.P
-However, from time to time, you might want to update the gems you are using to the newest versions that still match the gems in your Gemfile(5)\.
-.
-.P
-To do this, run \fBbundle update \-\-all\fR, which will ignore the \fBGemfile\.lock\fR, and resolve all the dependencies again\. Keep in mind that this process can result in a significantly different set of the 25 gems, based on the requirements of new gems that the gem authors released since the last time you ran \fBbundle update \-\-all\fR\.
-.
-.SH "UPDATING A LIST OF GEMS"
-Sometimes, you want to update a single gem in the Gemfile(5), and leave the rest of the gems that you specified locked to the versions in the \fBGemfile\.lock\fR\.
-.
-.P
-For instance, in the scenario above, imagine that \fBnokogiri\fR releases version \fB1\.4\.4\fR, and you want to update it \fIwithout\fR updating Rails and all of its dependencies\. To do this, run \fBbundle update nokogiri\fR\.
-.
-.P
-Bundler will update \fBnokogiri\fR and any of its dependencies, but leave alone Rails and its dependencies\.
-.
-.SH "OVERLAPPING DEPENDENCIES"
-Sometimes, multiple gems declared in your Gemfile(5) are satisfied by the same second\-level dependency\. For instance, consider the case of \fBthin\fR and \fBrack\-perftools\-profiler\fR\.
-.
-.IP "" 4
-.
-.nf
-
-source "https://rubygems\.org"
-
-gem "thin"
-gem "rack\-perftools\-profiler"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-The \fBthin\fR gem depends on \fBrack >= 1\.0\fR, while \fBrack\-perftools\-profiler\fR depends on \fBrack ~> 1\.0\fR\. If you run bundle install, you get:
-.
-.IP "" 4
-.
-.nf
-
-Fetching source index for https://rubygems\.org/
-Installing daemons (1\.1\.0)
-Installing eventmachine (0\.12\.10) with native extensions
-Installing open4 (1\.0\.1)
-Installing perftools\.rb (0\.4\.7) with native extensions
-Installing rack (1\.2\.1)
-Installing rack\-perftools_profiler (0\.0\.2)
-Installing thin (1\.2\.7) with native extensions
-Using bundler (1\.0\.0\.rc\.3)
-.
-.fi
-.
-.IP "" 0
-.
-.P
-In this case, the two gems have their own set of dependencies, but they share \fBrack\fR in common\. If you run \fBbundle update thin\fR, bundler will update \fBdaemons\fR, \fBeventmachine\fR and \fBrack\fR, which are dependencies of \fBthin\fR, but not \fBopen4\fR or \fBperftools\.rb\fR, which are dependencies of \fBrack\-perftools_profiler\fR\. Note that \fBbundle update thin\fR will update \fBrack\fR even though it\'s \fIalso\fR a dependency of \fBrack\-perftools_profiler\fR\.
-.
-.P
-In short, by default, when you update a gem using \fBbundle update\fR, bundler will update all dependencies of that gem, including those that are also dependencies of another gem\.
-.
-.P
-To prevent updating shared dependencies, prior to version 1\.14 the only option was the \fBCONSERVATIVE UPDATING\fR behavior in bundle install(1) \fIbundle\-install\.1\.html\fR:
-.
-.P
-In this scenario, updating the \fBthin\fR version manually in the Gemfile(5), and then running bundle install(1) \fIbundle\-install\.1\.html\fR will only update \fBdaemons\fR and \fBeventmachine\fR, but not \fBrack\fR\. For more information, see the \fBCONSERVATIVE UPDATING\fR section of bundle install(1) \fIbundle\-install\.1\.html\fR\.
-.
-.P
-Starting with 1\.14, specifying the \fB\-\-conservative\fR option will also prevent shared dependencies from being updated\.
-.
-.SH "PATCH LEVEL OPTIONS"
-Version 1\.14 introduced 4 patch\-level options that will influence how gem versions are resolved\. One of the following options can be used: \fB\-\-patch\fR, \fB\-\-minor\fR or \fB\-\-major\fR\. \fB\-\-strict\fR can be added to further influence resolution\.
-.
-.TP
-\fB\-\-patch\fR
-Prefer updating only to next patch version\.
-.
-.TP
-\fB\-\-minor\fR
-Prefer updating only to next minor version\.
-.
-.TP
-\fB\-\-major\fR
-Prefer updating to next major version (default)\.
-.
-.TP
-\fB\-\-strict\fR
-Do not allow any gem to be updated past latest \fB\-\-patch\fR | \fB\-\-minor\fR | \fB\-\-major\fR\.
-.
-.P
-When Bundler is resolving what versions to use to satisfy declared requirements in the Gemfile or in parent gems, it looks up all available versions, filters out any versions that don\'t satisfy the requirement, and then, by default, sorts them from newest to oldest, considering them in that order\.
-.
-.P
-Providing one of the patch level options (e\.g\. \fB\-\-patch\fR) changes the sort order of the satisfying versions, causing Bundler to consider the latest \fB\-\-patch\fR or \fB\-\-minor\fR version available before other versions\. Note that versions outside the stated patch level could still be resolved to if necessary to find a suitable dependency graph\.
-.
-.P
-For example, if gem \'foo\' is locked at 1\.0\.2, with no gem requirement defined in the Gemfile, and versions 1\.0\.3, 1\.0\.4, 1\.1\.0, 1\.1\.1, 2\.0\.0 all exist, the default order of preference by default (\fB\-\-major\fR) will be "2\.0\.0, 1\.1\.1, 1\.1\.0, 1\.0\.4, 1\.0\.3, 1\.0\.2"\.
-.
-.P
-If the \fB\-\-patch\fR option is used, the order of preference will change to "1\.0\.4, 1\.0\.3, 1\.0\.2, 1\.1\.1, 1\.1\.0, 2\.0\.0"\.
-.
-.P
-If the \fB\-\-minor\fR option is used, the order of preference will change to "1\.1\.1, 1\.1\.0, 1\.0\.4, 1\.0\.3, 1\.0\.2, 2\.0\.0"\.
-.
-.P
-Combining the \fB\-\-strict\fR option with any of the patch level options will remove any versions beyond the scope of the patch level option, to ensure that no gem is updated that far\.
-.
-.P
-To continue the previous example, if both \fB\-\-patch\fR and \fB\-\-strict\fR options are used, the available versions for resolution would be "1\.0\.4, 1\.0\.3, 1\.0\.2"\. If \fB\-\-minor\fR and \fB\-\-strict\fR are used, it would be "1\.1\.1, 1\.1\.0, 1\.0\.4, 1\.0\.3, 1\.0\.2"\.
-.
-.P
-Gem requirements as defined in the Gemfile will still be the first determining factor for what versions are available\. If the gem requirement for \fBfoo\fR in the Gemfile is \'~> 1\.0\', that will accomplish the same thing as providing the \fB\-\-minor\fR and \fB\-\-strict\fR options\.
-.
-.SH "PATCH LEVEL EXAMPLES"
-Given the following gem specifications:
-.
-.IP "" 4
-.
-.nf
-
-foo 1\.4\.3, requires: ~> bar 2\.0
-foo 1\.4\.4, requires: ~> bar 2\.0
-foo 1\.4\.5, requires: ~> bar 2\.1
-foo 1\.5\.0, requires: ~> bar 2\.1
-foo 1\.5\.1, requires: ~> bar 3\.0
-bar with versions 2\.0\.3, 2\.0\.4, 2\.1\.0, 2\.1\.1, 3\.0\.0
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Gemfile:
-.
-.IP "" 4
-.
-.nf
-
-gem \'foo\'
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Gemfile\.lock:
-.
-.IP "" 4
-.
-.nf
-
-foo (1\.4\.3)
-  bar (~> 2\.0)
-bar (2\.0\.3)
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Cases:
-.
-.IP "" 4
-.
-.nf
-
-#  Command Line                     Result
-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
-1  bundle update \-\-patch            \'foo 1\.4\.5\', \'bar 2\.1\.1\'
-2  bundle update \-\-patch foo        \'foo 1\.4\.5\', \'bar 2\.1\.1\'
-3  bundle update \-\-minor            \'foo 1\.5\.1\', \'bar 3\.0\.0\'
-4  bundle update \-\-minor \-\-strict   \'foo 1\.5\.0\', \'bar 2\.1\.1\'
-5  bundle update \-\-patch \-\-strict   \'foo 1\.4\.4\', \'bar 2\.0\.4\'
-.
-.fi
-.
-.IP "" 0
-.
-.P
-In case 1, bar is upgraded to 2\.1\.1, a minor version increase, because the dependency from foo 1\.4\.5 required it\.
-.
-.P
-In case 2, only foo is requested to be unlocked, but bar is also allowed to move because it\'s not a declared dependency in the Gemfile\.
-.
-.P
-In case 3, bar goes up a whole major release, because a minor increase is preferred now for foo, and when it goes to 1\.5\.1, it requires 3\.0\.0 of bar\.
-.
-.P
-In case 4, foo is preferred up to a minor version, but 1\.5\.1 won\'t work because the \-\-strict flag removes bar 3\.0\.0 from consideration since it\'s a major increment\.
-.
-.P
-In case 5, both foo and bar have any minor or major increments removed from consideration because of the \-\-strict flag, so the most they can move is up to 1\.4\.4 and 2\.0\.4\.
-.
-.SH "RECOMMENDED WORKFLOW"
-In general, when working with an application managed with bundler, you should use the following workflow:
-.
-.IP "\(bu" 4
-After you create your Gemfile(5) for the first time, run
-.
-.IP
-$ bundle install
-.
-.IP "\(bu" 4
-Check the resulting \fBGemfile\.lock\fR into version control
-.
-.IP
-$ git add Gemfile\.lock
-.
-.IP "\(bu" 4
-When checking out this repository on another development machine, run
-.
-.IP
-$ bundle install
-.
-.IP "\(bu" 4
-When checking out this repository on a deployment machine, run
-.
-.IP
-$ bundle install \-\-deployment
-.
-.IP "\(bu" 4
-After changing the Gemfile(5) to reflect a new or update dependency, run
-.
-.IP
-$ bundle install
-.
-.IP "\(bu" 4
-Make sure to check the updated \fBGemfile\.lock\fR into version control
-.
-.IP
-$ git add Gemfile\.lock
-.
-.IP "\(bu" 4
-If bundle install(1) \fIbundle\-install\.1\.html\fR reports a conflict, manually update the specific gems that you changed in the Gemfile(5)
-.
-.IP
-$ bundle update rails thin
-.
-.IP "\(bu" 4
-If you want to update all the gems to the latest possible versions that still match the gems listed in the Gemfile(5), run
-.
-.IP
-$ bundle update \-\-all
-.
-.IP "" 0
-
--- ruby2.7-2.7.6.orig/man/bundle-update.1.txt
+++ /dev/null
@@ -1,390 +0,0 @@
-BUNDLE-UPDATE(1)					      BUNDLE-UPDATE(1)
-
-
-
-NAME
-       bundle-update - Update your gems to the latest available versions
-
-SYNOPSIS
-       bundle  update  *gems  [--all] [--group=NAME] [--source=NAME] [--local]
-       [--ruby] [--bundler[=VERSION]] [--full-index]  [--jobs=JOBS]  [--quiet]
-       [--patch|--minor|--major] [--redownload] [--strict] [--conservative]
-
-DESCRIPTION
-       Update  the  gems specified (all gems, if --all flag is used), ignoring
-       the previously installed gems specified in the  Gemfile.lock.  In  gen-
-       eral, you should use bundle install(1) bundle-install.1.html to install
-       the same exact gems and versions across machines.
-
-       You would use bundle update to explicitly update the version of a gem.
-
-OPTIONS
-       --all  Update all gems specified in Gemfile.
-
-       --group=<name>, -g=[<name>]
-	      Only update the gems in the specified group. For	instance,  you
-	      can  update all gems in the development group with bundle update
-	      --group development. You	can  also  call  bundle  update  rails
-	      --group  test  to  update the rails gem and all gems in the test
-	      group, for example.
-
-       --source=<name>
-	      The name of a :git or :path source used in the  Gemfile(5).  For
-	      instance,        with	   a	    :git       source	    of
-	      http://github.com/rails/rails.git, you would call bundle	update
-	      --source rails
-
-       --local
-	      Do  not  attempt	to  fetch  gems remotely and use the gem cache
-	      instead.
-
-       --ruby Update the locked version of Ruby  to  the  current  version  of
-	      Ruby.
-
-       --bundler
-	      Update the locked version of bundler to the invoked bundler ver-
-	      sion.
-
-       --full-index
-	      Fall back to using the single-file index of all gems.
-
-       --jobs=[<number>], -j[<number>]
-	      Specify the number of jobs to run in parallel. The default is 1.
-
-       --retry=[<number>]
-	      Retry failed network or git requests for number times.
-
-       --quiet
-	      Only output warnings and errors.
-
-       --redownload
-	      Force downloading every gem.
-
-       --patch
-	      Prefer updating only to next patch version.
-
-       --minor
-	      Prefer updating only to next minor version.
-
-       --major
-	      Prefer updating to next major version (default).
-
-       --strict
-	      Do not allow any gem to be updated past latest --patch | --minor
-	      | --major.
-
-       --conservative
-	      Use bundle install conservative update behavior and do not allow
-	      shared dependencies to be updated.
-
-UPDATING ALL GEMS
-       If you run bundle update --all,	bundler  will  ignore  any  previously
-       installed  gems	and resolve all dependencies again based on the latest
-       versions of all gems available in the sources.
-
-       Consider the following Gemfile(5):
-
-
-
-	   source "https://rubygems.org"
-
-	   gem "rails", "3.0.0.rc"
-	   gem "nokogiri"
-
-
-
-       When you run bundle install(1) bundle-install.1.html  the  first  time,
-       bundler	will  resolve  all  of the dependencies, all the way down, and
-       install what you need:
-
-
-
-	   Fetching gem metadata from https://rubygems.org/.........
-	   Resolving dependencies...
-	   Installing builder 2.1.2
-	   Installing abstract 1.0.0
-	   Installing rack 1.2.8
-	   Using bundler 1.7.6
-	   Installing rake 10.4.0
-	   Installing polyglot 0.3.5
-	   Installing mime-types 1.25.1
-	   Installing i18n 0.4.2
-	   Installing mini_portile 0.6.1
-	   Installing tzinfo 0.3.42
-	   Installing rack-mount 0.6.14
-	   Installing rack-test 0.5.7
-	   Installing treetop 1.4.15
-	   Installing thor 0.14.6
-	   Installing activesupport 3.0.0.rc
-	   Installing erubis 2.6.6
-	   Installing activemodel 3.0.0.rc
-	   Installing arel 0.4.0
-	   Installing mail 2.2.20
-	   Installing activeresource 3.0.0.rc
-	   Installing actionpack 3.0.0.rc
-	   Installing activerecord 3.0.0.rc
-	   Installing actionmailer 3.0.0.rc
-	   Installing railties 3.0.0.rc
-	   Installing rails 3.0.0.rc
-	   Installing nokogiri 1.6.5
-
-	   Bundle complete! 2 Gemfile dependencies, 26 gems total.
-	   Use `bundle show [gemname]` to see where a bundled gem is installed.
-
-
-
-       As you can see, even though you have two gems in the  Gemfile(5),  your
-       application  needs 26 different gems in order to run. Bundler remembers
-       the exact versions it installed in Gemfile.lock. The next time you  run
-       bundle  install(1)  bundle-install.1.html, bundler skips the dependency
-       resolution and installs the same gems as it installed last time.
-
-       After checking in the Gemfile.lock into version control and cloning  it
-       on  another  machine,  running  bundle install(1) bundle-install.1.html
-       will still install the gems that you installed  last  time.  You  don't
-       need to worry that a new release of erubis or mail changes the gems you
-       use.
-
-       However, from time to time, you might want to update the gems  you  are
-       using  to  the  newest  versions that still match the gems in your Gem-
-       file(5).
-
-       To do this, run	bundle	update	--all,	which  will  ignore  the  Gem-
-       file.lock,  and	resolve  all the dependencies again. Keep in mind that
-       this process can result in a significantly  different  set  of  the  25
-       gems,  based  on  the  requirements  of	new  gems that the gem authors
-       released since the last time you ran bundle update --all.
-
-UPDATING A LIST OF GEMS
-       Sometimes, you want to update a single gem in the Gemfile(5), and leave
-       the  rest  of the gems that you specified locked to the versions in the
-       Gemfile.lock.
-
-       For instance, in the scenario above,  imagine  that  nokogiri  releases
-       version 1.4.4, and you want to update it without updating Rails and all
-       of its dependencies. To do this, run bundle update nokogiri.
-
-       Bundler will update nokogiri and any of	its  dependencies,  but  leave
-       alone Rails and its dependencies.
-
-OVERLAPPING DEPENDENCIES
-       Sometimes,  multiple  gems declared in your Gemfile(5) are satisfied by
-       the same second-level dependency. For instance, consider  the  case  of
-       thin and rack-perftools-profiler.
-
-
-
-	   source "https://rubygems.org"
-
-	   gem "thin"
-	   gem "rack-perftools-profiler"
-
-
-
-       The  thin  gem  depends	on  rack >= 1.0, while rack-perftools-profiler
-       depends on rack ~> 1.0. If you run bundle install, you get:
-
-
-
-	   Fetching source index for https://rubygems.org/
-	   Installing daemons (1.1.0)
-	   Installing eventmachine (0.12.10) with native extensions
-	   Installing open4 (1.0.1)
-	   Installing perftools.rb (0.4.7) with native extensions
-	   Installing rack (1.2.1)
-	   Installing rack-perftools_profiler (0.0.2)
-	   Installing thin (1.2.7) with native extensions
-	   Using bundler (1.0.0.rc.3)
-
-
-
-       In this case, the two gems have their own set of dependencies, but they
-       share  rack  in	common.  If  you  run bundle update thin, bundler will
-       update daemons, eventmachine and rack, which are dependencies of  thin,
-       but   not   open4   or	perftools.rb,	which	are   dependencies  of
-       rack-perftools_profiler. Note that bundle update thin will update  rack
-       even though it's also a dependency of rack-perftools_profiler.
-
-       In  short,  by  default,  when  you  update  a gem using bundle update,
-       bundler will update all dependencies of that gem, including those  that
-       are also dependencies of another gem.
-
-       To prevent updating shared dependencies, prior to version 1.14 the only
-       option was the CONSERVATIVE UPDATING behavior in bundle install(1) bun-
-       dle-install.1.html:
-
-       In this scenario, updating the thin version manually in the Gemfile(5),
-       and then running  bundle  install(1)  bundle-install.1.html  will  only
-       update  daemons	and  eventmachine, but not rack. For more information,
-       see  the  CONSERVATIVE  UPDATING  section  of  bundle  install(1)  bun-
-       dle-install.1.html.
-
-       Starting with 1.14, specifying the --conservative option will also pre-
-       vent shared dependencies from being updated.
-
-PATCH LEVEL OPTIONS
-       Version 1.14 introduced 4 patch-level options that will	influence  how
-       gem  versions  are  resolved. One of the following options can be used:
-       --patch, --minor or --major. --strict can be added to further influence
-       resolution.
-
-       --patch
-	      Prefer updating only to next patch version.
-
-       --minor
-	      Prefer updating only to next minor version.
-
-       --major
-	      Prefer updating to next major version (default).
-
-       --strict
-	      Do not allow any gem to be updated past latest --patch | --minor
-	      | --major.
-
-       When Bundler is resolving what versions	to  use  to  satisfy  declared
-       requirements  in  the Gemfile or in parent gems, it looks up all avail-
-       able versions, filters out any versions that don't satisfy the require-
-       ment, and then, by default, sorts them from newest to oldest, consider-
-       ing them in that order.
-
-       Providing one of the patch level options  (e.g.	--patch)  changes  the
-       sort  order of the satisfying versions, causing Bundler to consider the
-       latest --patch or --minor version available before other versions. Note
-       that versions outside the stated patch level could still be resolved to
-       if necessary to find a suitable dependency graph.
-
-       For example, if gem 'foo' is locked at 1.0.2, with no  gem  requirement
-       defined	in the Gemfile, and versions 1.0.3, 1.0.4, 1.1.0, 1.1.1, 2.0.0
-       all exist, the default order of preference by default (--major) will be
-       "2.0.0, 1.1.1, 1.1.0, 1.0.4, 1.0.3, 1.0.2".
-
-       If  the	--patch option is used, the order of preference will change to
-       "1.0.4, 1.0.3, 1.0.2, 1.1.1, 1.1.0, 2.0.0".
-
-       If the --minor option is used, the order of preference will  change  to
-       "1.1.1, 1.1.0, 1.0.4, 1.0.3, 1.0.2, 2.0.0".
-
-       Combining  the --strict option with any of the patch level options will
-       remove any versions beyond the scope of	the  patch  level  option,  to
-       ensure that no gem is updated that far.
-
-       To  continue the previous example, if both --patch and --strict options
-       are used, the available versions for resolution would be "1.0.4, 1.0.3,
-       1.0.2".	If  --minor  and --strict are used, it would be "1.1.1, 1.1.0,
-       1.0.4, 1.0.3, 1.0.2".
-
-       Gem requirements as defined in the Gemfile  will  still	be  the  first
-       determining factor for what versions are available. If the gem require-
-       ment for foo in the Gemfile is '~> 1.0', that will accomplish the  same
-       thing as providing the --minor and --strict options.
-
-PATCH LEVEL EXAMPLES
-       Given the following gem specifications:
-
-
-
-	   foo 1.4.3, requires: ~> bar 2.0
-	   foo 1.4.4, requires: ~> bar 2.0
-	   foo 1.4.5, requires: ~> bar 2.1
-	   foo 1.5.0, requires: ~> bar 2.1
-	   foo 1.5.1, requires: ~> bar 3.0
-	   bar with versions 2.0.3, 2.0.4, 2.1.0, 2.1.1, 3.0.0
-
-
-
-       Gemfile:
-
-
-
-	   gem 'foo'
-
-
-
-       Gemfile.lock:
-
-
-
-	   foo (1.4.3)
-	     bar (~> 2.0)
-	   bar (2.0.3)
-
-
-
-       Cases:
-
-
-
-	   #  Command Line		       Result
-	   ------------------------------------------------------------
-	   1  bundle update --patch	       'foo 1.4.5', 'bar 2.1.1'
-	   2  bundle update --patch foo        'foo 1.4.5', 'bar 2.1.1'
-	   3  bundle update --minor	       'foo 1.5.1', 'bar 3.0.0'
-	   4  bundle update --minor --strict   'foo 1.5.0', 'bar 2.1.1'
-	   5  bundle update --patch --strict   'foo 1.4.4', 'bar 2.0.4'
-
-
-
-       In  case 1, bar is upgraded to 2.1.1, a minor version increase, because
-       the dependency from foo 1.4.5 required it.
-
-       In case 2, only foo is requested  to  be  unlocked,  but  bar  is  also
-       allowed to move because it's not a declared dependency in the Gemfile.
-
-       In  case 3, bar goes up a whole major release, because a minor increase
-       is preferred now for foo, and when it goes to 1.5.1, it requires  3.0.0
-       of bar.
-
-       In case 4, foo is preferred up to a minor version, but 1.5.1 won't work
-       because the --strict flag removes bar 3.0.0  from  consideration  since
-       it's a major increment.
-
-       In  case 5, both foo and bar have any minor or major increments removed
-       from consideration because of the --strict flag, so the most  they  can
-       move is up to 1.4.4 and 2.0.4.
-
-RECOMMENDED WORKFLOW
-       In  general, when working with an application managed with bundler, you
-       should use the following workflow:
-
-       o   After you create your Gemfile(5) for the first time, run
-
-	   $ bundle install
-
-       o   Check the resulting Gemfile.lock into version control
-
-	   $ git add Gemfile.lock
-
-       o   When checking out this repository on another  development  machine,
-	   run
-
-	   $ bundle install
-
-       o   When checking out this repository on a deployment machine, run
-
-	   $ bundle install --deployment
-
-       o   After  changing  the  Gemfile(5)  to reflect a new or update depen-
-	   dency, run
-
-	   $ bundle install
-
-       o   Make sure to check the updated Gemfile.lock into version control
-
-	   $ git add Gemfile.lock
-
-       o   If bundle install(1) bundle-install.1.html reports a conflict, man-
-	   ually update the specific gems that you changed in the Gemfile(5)
-
-	   $ bundle update rails thin
-
-       o   If  you want to update all the gems to the latest possible versions
-	   that still match the gems listed in the Gemfile(5), run
-
-	   $ bundle update --all
-
-
-
-
-
-
-				 January 2020		      BUNDLE-UPDATE(1)
--- ruby2.7-2.7.6.orig/man/bundle-update.ronn
+++ /dev/null
@@ -1,350 +0,0 @@
-bundle-update(1) -- Update your gems to the latest available versions
-=====================================================================
-
-## SYNOPSIS
-
-`bundle update` <*gems> [--all]
-                        [--group=NAME]
-                        [--source=NAME]
-                        [--local]
-                        [--ruby]
-                        [--bundler[=VERSION]]
-                        [--full-index]
-                        [--jobs=JOBS]
-                        [--quiet]
-                        [--patch|--minor|--major]
-                        [--redownload]
-                        [--strict]
-                        [--conservative]
-
-## DESCRIPTION
-
-Update the gems specified (all gems, if `--all` flag is used), ignoring
-the previously installed gems specified in the `Gemfile.lock`. In
-general, you should use [bundle install(1)](bundle-install.1.html) to install the same exact
-gems and versions across machines.
-
-You would use `bundle update` to explicitly update the version of a
-gem.
-
-## OPTIONS
-
-* `--all`:
-  Update all gems specified in Gemfile.
-
-* `--group=<name>`, `-g=[<name>]`:
-  Only update the gems in the specified group. For instance, you can update all gems
-  in the development group with `bundle update --group development`. You can also
-  call `bundle update rails --group test` to update the rails gem and all gems in
-  the test group, for example.
-
-* `--source=<name>`:
-  The name of a `:git` or `:path` source used in the Gemfile(5). For
-  instance, with a `:git` source of `http://github.com/rails/rails.git`,
-  you would call `bundle update --source rails`
-
-* `--local`:
-  Do not attempt to fetch gems remotely and use the gem cache instead.
-
-* `--ruby`:
-  Update the locked version of Ruby to the current version of Ruby.
-
-* `--bundler`:
-  Update the locked version of bundler to the invoked bundler version.
-
-* `--full-index`:
-  Fall back to using the single-file index of all gems.
-
-* `--jobs=[<number>]`, `-j[<number>]`:
-  Specify the number of jobs to run in parallel. The default is `1`.
-
-* `--retry=[<number>]`:
-  Retry failed network or git requests for <number> times.
-
-* `--quiet`:
-  Only output warnings and errors.
-
-* `--redownload`:
-  Force downloading every gem.
-
-* `--patch`:
-  Prefer updating only to next patch version.
-
-* `--minor`:
-  Prefer updating only to next minor version.
-
-* `--major`:
-  Prefer updating to next major version (default).
-
-* `--strict`:
-  Do not allow any gem to be updated past latest `--patch` | `--minor` | `--major`.
-
-* `--conservative`:
-  Use bundle install conservative update behavior and do not allow shared dependencies to be updated.
-
-## UPDATING ALL GEMS
-
-If you run `bundle update --all`, bundler will ignore
-any previously installed gems and resolve all dependencies again
-based on the latest versions of all gems available in the sources.
-
-Consider the following Gemfile(5):
-
-    source "https://rubygems.org"
-
-    gem "rails", "3.0.0.rc"
-    gem "nokogiri"
-
-When you run [bundle install(1)](bundle-install.1.html) the first time, bundler will resolve
-all of the dependencies, all the way down, and install what you need:
-
-    Fetching gem metadata from https://rubygems.org/.........
-    Resolving dependencies...
-    Installing builder 2.1.2
-    Installing abstract 1.0.0
-    Installing rack 1.2.8
-    Using bundler 1.7.6
-    Installing rake 10.4.0
-    Installing polyglot 0.3.5
-    Installing mime-types 1.25.1
-    Installing i18n 0.4.2
-    Installing mini_portile 0.6.1
-    Installing tzinfo 0.3.42
-    Installing rack-mount 0.6.14
-    Installing rack-test 0.5.7
-    Installing treetop 1.4.15
-    Installing thor 0.14.6
-    Installing activesupport 3.0.0.rc
-    Installing erubis 2.6.6
-    Installing activemodel 3.0.0.rc
-    Installing arel 0.4.0
-    Installing mail 2.2.20
-    Installing activeresource 3.0.0.rc
-    Installing actionpack 3.0.0.rc
-    Installing activerecord 3.0.0.rc
-    Installing actionmailer 3.0.0.rc
-    Installing railties 3.0.0.rc
-    Installing rails 3.0.0.rc
-    Installing nokogiri 1.6.5
-
-    Bundle complete! 2 Gemfile dependencies, 26 gems total.
-    Use `bundle show [gemname]` to see where a bundled gem is installed.
-
-As you can see, even though you have two gems in the Gemfile(5), your application
-needs 26 different gems in order to run. Bundler remembers the exact versions
-it installed in `Gemfile.lock`. The next time you run [bundle install(1)](bundle-install.1.html), bundler skips
-the dependency resolution and installs the same gems as it installed last time.
-
-After checking in the `Gemfile.lock` into version control and cloning it on another
-machine, running [bundle install(1)](bundle-install.1.html) will _still_ install the gems that you installed
-last time. You don't need to worry that a new release of `erubis` or `mail` changes
-the gems you use.
-
-However, from time to time, you might want to update the gems you are using to the
-newest versions that still match the gems in your Gemfile(5).
-
-To do this, run `bundle update --all`, which will ignore the `Gemfile.lock`, and resolve
-all the dependencies again. Keep in mind that this process can result in a significantly
-different set of the 25 gems, based on the requirements of new gems that the gem
-authors released since the last time you ran `bundle update --all`.
-
-## UPDATING A LIST OF GEMS
-
-Sometimes, you want to update a single gem in the Gemfile(5), and leave the rest of the
-gems that you specified locked to the versions in the `Gemfile.lock`.
-
-For instance, in the scenario above, imagine that `nokogiri` releases version `1.4.4`, and
-you want to update it _without_ updating Rails and all of its dependencies. To do this,
-run `bundle update nokogiri`.
-
-Bundler will update `nokogiri` and any of its dependencies, but leave alone Rails and
-its dependencies.
-
-## OVERLAPPING DEPENDENCIES
-
-Sometimes, multiple gems declared in your Gemfile(5) are satisfied by the same
-second-level dependency. For instance, consider the case of `thin` and
-`rack-perftools-profiler`.
-
-    source "https://rubygems.org"
-
-    gem "thin"
-    gem "rack-perftools-profiler"
-
-The `thin` gem depends on `rack >= 1.0`, while `rack-perftools-profiler` depends
-on `rack ~> 1.0`. If you run bundle install, you get:
-
-    Fetching source index for https://rubygems.org/
-    Installing daemons (1.1.0)
-    Installing eventmachine (0.12.10) with native extensions
-    Installing open4 (1.0.1)
-    Installing perftools.rb (0.4.7) with native extensions
-    Installing rack (1.2.1)
-    Installing rack-perftools_profiler (0.0.2)
-    Installing thin (1.2.7) with native extensions
-    Using bundler (1.0.0.rc.3)
-
-In this case, the two gems have their own set of dependencies, but they share
-`rack` in common. If you run `bundle update thin`, bundler will update `daemons`,
-`eventmachine` and `rack`, which are dependencies of `thin`, but not `open4` or
-`perftools.rb`, which are dependencies of `rack-perftools_profiler`. Note that
-`bundle update thin` will update `rack` even though it's _also_ a dependency of
-`rack-perftools_profiler`.
-
-In short, by default, when you update a gem using `bundle update`, bundler will
-update all dependencies of that gem, including those that are also dependencies
-of another gem.
-
-To prevent updating shared dependencies, prior to version 1.14 the only option
-was the `CONSERVATIVE UPDATING` behavior in [bundle install(1)](bundle-install.1.html):
-
-In this scenario, updating the `thin` version manually in the Gemfile(5),
-and then running [bundle install(1)](bundle-install.1.html) will only update `daemons` and `eventmachine`,
-but not `rack`. For more information, see the `CONSERVATIVE UPDATING` section
-of [bundle install(1)](bundle-install.1.html).
-
-Starting with 1.14, specifying the `--conservative` option will also prevent shared
-dependencies from being updated.
-
-## PATCH LEVEL OPTIONS
-
-Version 1.14 introduced 4 patch-level options that will influence how gem
-versions are resolved. One of the following options can be used: `--patch`,
-`--minor` or `--major`. `--strict` can be added to further influence resolution.
-
-* `--patch`:
-  Prefer updating only to next patch version.
-
-* `--minor`:
-  Prefer updating only to next minor version.
-
-* `--major`:
-  Prefer updating to next major version (default).
-
-* `--strict`:
-  Do not allow any gem to be updated past latest `--patch` | `--minor` | `--major`.
-
-When Bundler is resolving what versions to use to satisfy declared
-requirements in the Gemfile or in parent gems, it looks up all
-available versions, filters out any versions that don't satisfy
-the requirement, and then, by default, sorts them from newest to
-oldest, considering them in that order.
-
-Providing one of the patch level options (e.g. `--patch`) changes the
-sort order of the satisfying versions, causing Bundler to consider the
-latest `--patch` or `--minor` version available before other versions.
-Note that versions outside the stated patch level could still be
-resolved to if necessary to find a suitable dependency graph.
-
-For example, if gem 'foo' is locked at 1.0.2, with no gem requirement
-defined in the Gemfile, and versions 1.0.3, 1.0.4, 1.1.0, 1.1.1, 2.0.0
-all exist, the default order of preference by default (`--major`) will
-be "2.0.0, 1.1.1, 1.1.0, 1.0.4, 1.0.3, 1.0.2".
-
-If the `--patch` option is used, the order of preference will change to
-"1.0.4, 1.0.3, 1.0.2, 1.1.1, 1.1.0, 2.0.0".
-
-If the `--minor` option is used, the order of preference will change to
-"1.1.1, 1.1.0, 1.0.4, 1.0.3, 1.0.2, 2.0.0".
-
-Combining the `--strict` option with any of the patch level options
-will remove any versions beyond the scope of the patch level option,
-to ensure that no gem is updated that far.
-
-To continue the previous example, if both `--patch` and `--strict`
-options are used, the available versions for resolution would be
-"1.0.4, 1.0.3, 1.0.2". If `--minor` and `--strict` are used, it would
-be "1.1.1, 1.1.0, 1.0.4, 1.0.3, 1.0.2".
-
-Gem requirements as defined in the Gemfile will still be the first
-determining factor for what versions are available. If the gem
-requirement for `foo` in the Gemfile is '~> 1.0', that will accomplish
-the same thing as providing the `--minor` and `--strict` options.
-
-## PATCH LEVEL EXAMPLES
-
-Given the following gem specifications:
-
-    foo 1.4.3, requires: ~> bar 2.0
-    foo 1.4.4, requires: ~> bar 2.0
-    foo 1.4.5, requires: ~> bar 2.1
-    foo 1.5.0, requires: ~> bar 2.1
-    foo 1.5.1, requires: ~> bar 3.0
-    bar with versions 2.0.3, 2.0.4, 2.1.0, 2.1.1, 3.0.0
-
-Gemfile:
-
-    gem 'foo'
-
-Gemfile.lock:
-
-    foo (1.4.3)
-      bar (~> 2.0)
-    bar (2.0.3)
-
-Cases:
-
-    #  Command Line                     Result
-    ------------------------------------------------------------
-    1  bundle update --patch            'foo 1.4.5', 'bar 2.1.1'
-    2  bundle update --patch foo        'foo 1.4.5', 'bar 2.1.1'
-    3  bundle update --minor            'foo 1.5.1', 'bar 3.0.0'
-    4  bundle update --minor --strict   'foo 1.5.0', 'bar 2.1.1'
-    5  bundle update --patch --strict   'foo 1.4.4', 'bar 2.0.4'
-
-In case 1, bar is upgraded to 2.1.1, a minor version increase, because
-the dependency from foo 1.4.5 required it.
-
-In case 2, only foo is requested to be unlocked, but bar is also
-allowed to move because it's not a declared dependency in the Gemfile.
-
-In case 3, bar goes up a whole major release, because a minor increase
-is preferred now for foo, and when it goes to 1.5.1, it requires 3.0.0
-of bar.
-
-In case 4, foo is preferred up to a minor version, but 1.5.1 won't work
-because the --strict flag removes bar 3.0.0 from consideration since
-it's a major increment.
-
-In case 5, both foo and bar have any minor or major increments removed
-from consideration because of the --strict flag, so the most they can
-move is up to 1.4.4 and 2.0.4.
-
-## RECOMMENDED WORKFLOW
-
-In general, when working with an application managed with bundler, you should
-use the following workflow:
-
-* After you create your Gemfile(5) for the first time, run
-
-    $ bundle install
-
-* Check the resulting `Gemfile.lock` into version control
-
-    $ git add Gemfile.lock
-
-* When checking out this repository on another development machine, run
-
-    $ bundle install
-
-* When checking out this repository on a deployment machine, run
-
-    $ bundle install --deployment
-
-* After changing the Gemfile(5) to reflect a new or update dependency, run
-
-    $ bundle install
-
-* Make sure to check the updated `Gemfile.lock` into version control
-
-    $ git add Gemfile.lock
-
-* If [bundle install(1)](bundle-install.1.html) reports a conflict, manually update the specific
-  gems that you changed in the Gemfile(5)
-
-    $ bundle update rails thin
-
-* If you want to update all the gems to the latest possible versions that
-  still match the gems listed in the Gemfile(5), run
-
-    $ bundle update --all
--- ruby2.7-2.7.6.orig/man/bundle-viz.1
+++ /dev/null
@@ -1,39 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE\-VIZ" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\-viz\fR \- Generates a visual dependency graph for your Gemfile
-.
-.SH "SYNOPSIS"
-\fBbundle viz\fR [\-\-file=FILE] [\-\-format=FORMAT] [\-\-requirements] [\-\-version] [\-\-without=GROUP GROUP]
-.
-.SH "DESCRIPTION"
-\fBviz\fR generates a PNG file of the current \fBGemfile(5)\fR as a dependency graph\. \fBviz\fR requires the ruby\-graphviz gem (and its dependencies)\.
-.
-.P
-The associated gems must also be installed via \fBbundle install(1)\fR \fIbundle\-install\.1\.html\fR\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-file\fR, \fB\-f\fR
-The name to use for the generated file\. See \fB\-\-format\fR option
-.
-.TP
-\fB\-\-format\fR, \fB\-F\fR
-This is output format option\. Supported format is png, jpg, svg, dot \.\.\.
-.
-.TP
-\fB\-\-requirements\fR, \fB\-R\fR
-Set to show the version of each required dependency\.
-.
-.TP
-\fB\-\-version\fR, \fB\-v\fR
-Set to show each gem version\.
-.
-.TP
-\fB\-\-without\fR, \fB\-W\fR
-Exclude gems that are part of the specified named group\.
-
--- ruby2.7-2.7.6.orig/man/bundle-viz.1.txt
+++ /dev/null
@@ -1,39 +0,0 @@
-BUNDLE-VIZ(1)							 BUNDLE-VIZ(1)
-
-
-
-NAME
-       bundle-viz - Generates a visual dependency graph for your Gemfile
-
-SYNOPSIS
-       bundle viz [--file=FILE] [--format=FORMAT] [--requirements] [--version]
-       [--without=GROUP GROUP]
-
-DESCRIPTION
-       viz generates a PNG file of the	current  Gemfile(5)  as  a  dependency
-       graph. viz requires the ruby-graphviz gem (and its dependencies).
-
-       The  associated	gems must also be installed via bundle install(1) bun-
-       dle-install.1.html.
-
-OPTIONS
-       --file, -f
-	      The name to use for the generated file. See --format option
-
-       --format, -F
-	      This is output format option. Supported format is png, jpg, svg,
-	      dot ...
-
-       --requirements, -R
-	      Set to show the version of each required dependency.
-
-       --version, -v
-	      Set to show each gem version.
-
-       --without, -W
-	      Exclude gems that are part of the specified named group.
-
-
-
-
-				 January 2020			 BUNDLE-VIZ(1)
--- ruby2.7-2.7.6.orig/man/bundle-viz.ronn
+++ /dev/null
@@ -1,30 +0,0 @@
-bundle-viz(1) -- Generates a visual dependency graph for your Gemfile
-=====================================================================
-
-## SYNOPSIS
-
-`bundle viz` [--file=FILE]
-             [--format=FORMAT]
-             [--requirements]
-             [--version]
-             [--without=GROUP GROUP]
-
-## DESCRIPTION
-
-`viz` generates a PNG file of the current `Gemfile(5)` as a dependency graph.
-`viz` requires the ruby-graphviz gem (and its dependencies).
-
-The associated gems must also be installed via [`bundle install(1)`](bundle-install.1.html).
-
-## OPTIONS
-
-* `--file`, `-f`:
-  The name to use for the generated file. See `--format` option
-* `--format`, `-F`:
-  This is output format option. Supported format is png, jpg, svg, dot ...
-* `--requirements`, `-R`:
-  Set to show the version of each required dependency.
-* `--version`, `-v`:
-  Set to show each gem version.
-* `--without`, `-W`:
-  Exclude gems that are part of the specified named group.
--- ruby2.7-2.7.6.orig/man/bundle.1
+++ /dev/null
@@ -1,136 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "BUNDLE" "1" "January 2020" "" ""
-.
-.SH "NAME"
-\fBbundle\fR \- Ruby Dependency Management
-.
-.SH "SYNOPSIS"
-\fBbundle\fR COMMAND [\-\-no\-color] [\-\-verbose] [ARGS]
-.
-.SH "DESCRIPTION"
-Bundler manages an \fBapplication\'s dependencies\fR through its entire life across many machines systematically and repeatably\.
-.
-.P
-See the bundler website \fIhttps://bundler\.io\fR for information on getting started, and Gemfile(5) for more information on the \fBGemfile\fR format\.
-.
-.SH "OPTIONS"
-.
-.TP
-\fB\-\-no\-color\fR
-Print all output without color
-.
-.TP
-\fB\-\-retry\fR, \fB\-r\fR
-Specify the number of times you wish to attempt network commands
-.
-.TP
-\fB\-\-verbose\fR, \fB\-V\fR
-Print out additional logging information
-.
-.SH "BUNDLE COMMANDS"
-We divide \fBbundle\fR subcommands into primary commands and utilities:
-.
-.SH "PRIMARY COMMANDS"
-.
-.TP
-\fBbundle install(1)\fR \fIbundle\-install\.1\.html\fR
-Install the gems specified by the \fBGemfile\fR or \fBGemfile\.lock\fR
-.
-.TP
-\fBbundle update(1)\fR \fIbundle\-update\.1\.html\fR
-Update dependencies to their latest versions
-.
-.TP
-\fBbundle package(1)\fR \fIbundle\-package\.1\.html\fR
-Package the \.gem files required by your application into the \fBvendor/cache\fR directory
-.
-.TP
-\fBbundle exec(1)\fR \fIbundle\-exec\.1\.html\fR
-Execute a script in the current bundle
-.
-.TP
-\fBbundle config(1)\fR \fIbundle\-config\.1\.html\fR
-Specify and read configuration options for Bundler
-.
-.TP
-\fBbundle help(1)\fR
-Display detailed help for each subcommand
-.
-.SH "UTILITIES"
-.
-.TP
-\fBbundle add(1)\fR \fIbundle\-add\.1\.html\fR
-Add the named gem to the Gemfile and run \fBbundle install\fR
-.
-.TP
-\fBbundle binstubs(1)\fR \fIbundle\-binstubs\.1\.html\fR
-Generate binstubs for executables in a gem
-.
-.TP
-\fBbundle check(1)\fR \fIbundle\-check\.1\.html\fR
-Determine whether the requirements for your application are installed and available to Bundler
-.
-.TP
-\fBbundle show(1)\fR \fIbundle\-show\.1\.html\fR
-Show the source location of a particular gem in the bundle
-.
-.TP
-\fBbundle outdated(1)\fR \fIbundle\-outdated\.1\.html\fR
-Show all of the outdated gems in the current bundle
-.
-.TP
-\fBbundle console(1)\fR
-Start an IRB session in the current bundle
-.
-.TP
-\fBbundle open(1)\fR \fIbundle\-open\.1\.html\fR
-Open an installed gem in the editor
-.
-.TP
-\fBbundle lock(1)\fR \fIbundle\-lock\.1\.html\fR
-Generate a lockfile for your dependencies
-.
-.TP
-\fBbundle viz(1)\fR \fIbundle\-viz\.1\.html\fR
-Generate a visual representation of your dependencies
-.
-.TP
-\fBbundle init(1)\fR \fIbundle\-init\.1\.html\fR
-Generate a simple \fBGemfile\fR, placed in the current directory
-.
-.TP
-\fBbundle gem(1)\fR \fIbundle\-gem\.1\.html\fR
-Create a simple gem, suitable for development with Bundler
-.
-.TP
-\fBbundle platform(1)\fR \fIbundle\-platform\.1\.html\fR
-Display platform compatibility information
-.
-.TP
-\fBbundle clean(1)\fR \fIbundle\-clean\.1\.html\fR
-Clean up unused gems in your Bundler directory
-.
-.TP
-\fBbundle doctor(1)\fR \fIbundle\-doctor\.1\.html\fR
-Display warnings about common problems
-.
-.TP
-\fBbundle remove(1)\fR \fIbundle\-remove\.1\.html\fR
-Removes gems from the Gemfile
-.
-.SH "PLUGINS"
-When running a command that isn\'t listed in PRIMARY COMMANDS or UTILITIES, Bundler will try to find an executable on your path named \fBbundler\-<command>\fR and execute it, passing down any extra arguments to it\.
-.
-.SH "OBSOLETE"
-These commands are obsolete and should no longer be used:
-.
-.IP "\(bu" 4
-\fBbundle cache(1)\fR
-.
-.IP "\(bu" 4
-\fBbundle show(1)\fR
-.
-.IP "" 0
-
--- ruby2.7-2.7.6.orig/man/bundle.1.txt
+++ /dev/null
@@ -1,116 +0,0 @@
-BUNDLE(1)							     BUNDLE(1)
-
-
-
-NAME
-       bundle - Ruby Dependency Management
-
-SYNOPSIS
-       bundle COMMAND [--no-color] [--verbose] [ARGS]
-
-DESCRIPTION
-       Bundler	manages  an application's dependencies through its entire life
-       across many machines systematically and repeatably.
-
-       See the bundler website https://bundler.io for information  on  getting
-       started, and Gemfile(5) for more information on the Gemfile format.
-
-OPTIONS
-       --no-color
-	      Print all output without color
-
-       --retry, -r
-	      Specify the number of times you wish to attempt network commands
-
-       --verbose, -V
-	      Print out additional logging information
-
-BUNDLE COMMANDS
-       We divide bundle subcommands into primary commands and utilities:
-
-PRIMARY COMMANDS
-       bundle install(1) bundle-install.1.html
-	      Install the gems specified by the Gemfile or Gemfile.lock
-
-       bundle update(1) bundle-update.1.html
-	      Update dependencies to their latest versions
-
-       bundle package(1) bundle-package.1.html
-	      Package  the  .gem  files  required by your application into the
-	      vendor/cache directory
-
-       bundle exec(1) bundle-exec.1.html
-	      Execute a script in the current bundle
-
-       bundle config(1) bundle-config.1.html
-	      Specify and read configuration options for Bundler
-
-       bundle help(1)
-	      Display detailed help for each subcommand
-
-UTILITIES
-       bundle add(1) bundle-add.1.html
-	      Add the named gem to the Gemfile and run bundle install
-
-       bundle binstubs(1) bundle-binstubs.1.html
-	      Generate binstubs for executables in a gem
-
-       bundle check(1) bundle-check.1.html
-	      Determine whether the  requirements  for	your  application  are
-	      installed and available to Bundler
-
-       bundle show(1) bundle-show.1.html
-	      Show the source location of a particular gem in the bundle
-
-       bundle outdated(1) bundle-outdated.1.html
-	      Show all of the outdated gems in the current bundle
-
-       bundle console(1)
-	      Start an IRB session in the current bundle
-
-       bundle open(1) bundle-open.1.html
-	      Open an installed gem in the editor
-
-       bundle lock(1) bundle-lock.1.html
-	      Generate a lockfile for your dependencies
-
-       bundle viz(1) bundle-viz.1.html
-	      Generate a visual representation of your dependencies
-
-       bundle init(1) bundle-init.1.html
-	      Generate a simple Gemfile, placed in the current directory
-
-       bundle gem(1) bundle-gem.1.html
-	      Create a simple gem, suitable for development with Bundler
-
-       bundle platform(1) bundle-platform.1.html
-	      Display platform compatibility information
-
-       bundle clean(1) bundle-clean.1.html
-	      Clean up unused gems in your Bundler directory
-
-       bundle doctor(1) bundle-doctor.1.html
-	      Display warnings about common problems
-
-       bundle remove(1) bundle-remove.1.html
-	      Removes gems from the Gemfile
-
-PLUGINS
-       When  running a command that isn't listed in PRIMARY COMMANDS or UTILI-
-       TIES, Bundler will try  to  find  an  executable  on  your  path  named
-       bundler-<command>  and  execute it, passing down any extra arguments to
-       it.
-
-OBSOLETE
-       These commands are obsolete and should no longer be used:
-
-       o   bundle cache(1)
-
-       o   bundle show(1)
-
-
-
-
-
-
-				 January 2020			     BUNDLE(1)
--- ruby2.7-2.7.6.orig/man/bundle.ronn
+++ /dev/null
@@ -1,111 +0,0 @@
-bundle(1) -- Ruby Dependency Management
-=======================================
-
-## SYNOPSIS
-
-`bundle` COMMAND [--no-color] [--verbose] [ARGS]
-
-## DESCRIPTION
-
-Bundler manages an `application's dependencies` through its entire life
-across many machines systematically and repeatably.
-
-See [the bundler website](https://bundler.io) for information on getting
-started, and Gemfile(5) for more information on the `Gemfile` format.
-
-## OPTIONS
-
-* `--no-color`:
-  Print all output without color
-
-* `--retry`, `-r`:
-  Specify the number of times you wish to attempt network commands
-
-* `--verbose`, `-V`:
-  Print out additional logging information
-
-## BUNDLE COMMANDS
-
-We divide `bundle` subcommands into primary commands and utilities:
-
-## PRIMARY COMMANDS
-
-* [`bundle install(1)`](bundle-install.1.html):
-  Install the gems specified by the `Gemfile` or `Gemfile.lock`
-
-* [`bundle update(1)`](bundle-update.1.html):
-  Update dependencies to their latest versions
-
-* [`bundle package(1)`](bundle-package.1.html):
-  Package the .gem files required by your application into the
-  `vendor/cache` directory
-
-* [`bundle exec(1)`](bundle-exec.1.html):
-  Execute a script in the current bundle
-
-* [`bundle config(1)`](bundle-config.1.html):
-  Specify and read configuration options for Bundler
-
-* `bundle help(1)`:
-  Display detailed help for each subcommand
-
-## UTILITIES
-
-* [`bundle add(1)`](bundle-add.1.html):
-  Add the named gem to the Gemfile and run `bundle install`
-
-* [`bundle binstubs(1)`](bundle-binstubs.1.html):
-  Generate binstubs for executables in a gem
-
-* [`bundle check(1)`](bundle-check.1.html):
-  Determine whether the requirements for your application are installed
-  and available to Bundler
-
-* [`bundle show(1)`](bundle-show.1.html):
-  Show the source location of a particular gem in the bundle
-
-* [`bundle outdated(1)`](bundle-outdated.1.html):
-  Show all of the outdated gems in the current bundle
-
-* `bundle console(1)`:
-  Start an IRB session in the current bundle
-
-* [`bundle open(1)`](bundle-open.1.html):
-  Open an installed gem in the editor
-
-* [`bundle lock(1)`](bundle-lock.1.html):
-  Generate a lockfile for your dependencies
-
-* [`bundle viz(1)`](bundle-viz.1.html):
-  Generate a visual representation of your dependencies
-
-* [`bundle init(1)`](bundle-init.1.html):
-  Generate a simple `Gemfile`, placed in the current directory
-
-* [`bundle gem(1)`](bundle-gem.1.html):
-  Create a simple gem, suitable for development with Bundler
-
-* [`bundle platform(1)`](bundle-platform.1.html):
-  Display platform compatibility information
-
-* [`bundle clean(1)`](bundle-clean.1.html):
-  Clean up unused gems in your Bundler directory
-
-* [`bundle doctor(1)`](bundle-doctor.1.html):
-  Display warnings about common problems
-
-* [`bundle remove(1)`](bundle-remove.1.html):
-  Removes gems from the Gemfile
-
-## PLUGINS
-
-When running a command that isn't listed in PRIMARY COMMANDS or UTILITIES,
-Bundler will try to find an executable on your path named `bundler-<command>`
-and execute it, passing down any extra arguments to it.
-
-## OBSOLETE
-
-These commands are obsolete and should no longer be used:
-
-* `bundle cache(1)`
-* `bundle show(1)`
--- ruby2.7-2.7.6.orig/man/gemfile.5
+++ /dev/null
@@ -1,686 +0,0 @@
-.\" generated with Ronn/v0.7.3
-.\" http://github.com/rtomayko/ronn/tree/0.7.3
-.
-.TH "GEMFILE" "5" "January 2020" "" ""
-.
-.SH "NAME"
-\fBGemfile\fR \- A format for describing gem dependencies for Ruby programs
-.
-.SH "SYNOPSIS"
-A \fBGemfile\fR describes the gem dependencies required to execute associated Ruby code\.
-.
-.P
-Place the \fBGemfile\fR in the root of the directory containing the associated code\. For instance, in a Rails application, place the \fBGemfile\fR in the same directory as the \fBRakefile\fR\.
-.
-.SH "SYNTAX"
-A \fBGemfile\fR is evaluated as Ruby code, in a context which makes available a number of methods used to describe the gem requirements\.
-.
-.SH "GLOBAL SOURCES"
-At the top of the \fBGemfile\fR, add a line for the \fBRubygems\fR source that contains the gems listed in the \fBGemfile\fR\.
-.
-.IP "" 4
-.
-.nf
-
-source "https://rubygems\.org"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-It is possible, but not recommended as of Bundler 1\.7, to add multiple global \fBsource\fR lines\. Each of these \fBsource\fRs \fBMUST\fR be a valid Rubygems repository\.
-.
-.P
-Sources are checked for gems following the heuristics described in \fISOURCE PRIORITY\fR\. If a gem is found in more than one global source, Bundler will print a warning after installing the gem indicating which source was used, and listing the other sources where the gem is available\. A specific source can be selected for gems that need to use a non\-standard repository, suppressing this warning, by using the \fI\fB:source\fR option\fR or a \fI\fBsource\fR block\fR\.
-.
-.SS "CREDENTIALS"
-Some gem sources require a username and password\. Use bundle config(1) \fIbundle\-config\.1\.html\fR to set the username and password for any of the sources that need it\. The command must be run once on each computer that will install the Gemfile, but this keeps the credentials from being stored in plain text in version control\.
-.
-.IP "" 4
-.
-.nf
-
-bundle config gems\.example\.com user:password
-.
-.fi
-.
-.IP "" 0
-.
-.P
-For some sources, like a company Gemfury account, it may be easier to include the credentials in the Gemfile as part of the source URL\.
-.
-.IP "" 4
-.
-.nf
-
-source "https://user:password@gems\.example\.com"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Credentials in the source URL will take precedence over credentials set using \fBconfig\fR\.
-.
-.SH "RUBY"
-If your application requires a specific Ruby version or engine, specify your requirements using the \fBruby\fR method, with the following arguments\. All parameters are \fBOPTIONAL\fR unless otherwise specified\.
-.
-.SS "VERSION (required)"
-The version of Ruby that your application requires\. If your application requires an alternate Ruby engine, such as JRuby, Rubinius or TruffleRuby, this should be the Ruby version that the engine is compatible with\.
-.
-.IP "" 4
-.
-.nf
-
-ruby "1\.9\.3"
-.
-.fi
-.
-.IP "" 0
-.
-.SS "ENGINE"
-Each application \fImay\fR specify a Ruby engine\. If an engine is specified, an engine version \fImust\fR also be specified\.
-.
-.P
-What exactly is an Engine? \- A Ruby engine is an implementation of the Ruby language\.
-.
-.IP "\(bu" 4
-For background: the reference or original implementation of the Ruby programming language is called Matz\'s Ruby Interpreter \fIhttps://en\.wikipedia\.org/wiki/Ruby_MRI\fR, or MRI for short\. This is named after Ruby creator Yukihiro Matsumoto, also known as Matz\. MRI is also known as CRuby, because it is written in C\. MRI is the most widely used Ruby engine\.
-.
-.IP "\(bu" 4
-Other implementations \fIhttps://www\.ruby\-lang\.org/en/about/\fR of Ruby exist\. Some of the more well\-known implementations include Rubinius \fIhttps://rubinius\.com/\fR, and JRuby \fIhttp://jruby\.org/\fR\. Rubinius is an alternative implementation of Ruby written in Ruby\. JRuby is an implementation of Ruby on the JVM, short for Java Virtual Machine\.
-.
-.IP "" 0
-.
-.SS "ENGINE VERSION"
-Each application \fImay\fR specify a Ruby engine version\. If an engine version is specified, an engine \fImust\fR also be specified\. If the engine is "ruby" the engine version specified \fImust\fR match the Ruby version\.
-.
-.IP "" 4
-.
-.nf
-
-ruby "1\.8\.7", :engine => "jruby", :engine_version => "1\.6\.7"
-.
-.fi
-.
-.IP "" 0
-.
-.SS "PATCHLEVEL"
-Each application \fImay\fR specify a Ruby patchlevel\.
-.
-.IP "" 4
-.
-.nf
-
-ruby "2\.0\.0", :patchlevel => "247"
-.
-.fi
-.
-.IP "" 0
-.
-.SH "GEMS"
-Specify gem requirements using the \fBgem\fR method, with the following arguments\. All parameters are \fBOPTIONAL\fR unless otherwise specified\.
-.
-.SS "NAME (required)"
-For each gem requirement, list a single \fIgem\fR line\.
-.
-.IP "" 4
-.
-.nf
-
-gem "nokogiri"
-.
-.fi
-.
-.IP "" 0
-.
-.SS "VERSION"
-Each \fIgem\fR \fBMAY\fR have one or more version specifiers\.
-.
-.IP "" 4
-.
-.nf
-
-gem "nokogiri", ">= 1\.4\.2"
-gem "RedCloth", ">= 4\.1\.0", "< 4\.2\.0"
-.
-.fi
-.
-.IP "" 0
-.
-.SS "REQUIRE AS"
-Each \fIgem\fR \fBMAY\fR specify files that should be used when autorequiring via \fBBundler\.require\fR\. You may pass an array with multiple files or \fBtrue\fR if file you want \fBrequired\fR has same name as \fIgem\fR or \fBfalse\fR to prevent any file from being autorequired\.
-.
-.IP "" 4
-.
-.nf
-
-gem "redis", :require => ["redis/connection/hiredis", "redis"]
-gem "webmock", :require => false
-gem "byebug", :require => true
-.
-.fi
-.
-.IP "" 0
-.
-.P
-The argument defaults to the name of the gem\. For example, these are identical:
-.
-.IP "" 4
-.
-.nf
-
-gem "nokogiri"
-gem "nokogiri", :require => "nokogiri"
-gem "nokogiri", :require => true
-.
-.fi
-.
-.IP "" 0
-.
-.SS "GROUPS"
-Each \fIgem\fR \fBMAY\fR specify membership in one or more groups\. Any \fIgem\fR that does not specify membership in any group is placed in the \fBdefault\fR group\.
-.
-.IP "" 4
-.
-.nf
-
-gem "rspec", :group => :test
-gem "wirble", :groups => [:development, :test]
-.
-.fi
-.
-.IP "" 0
-.
-.P
-The Bundler runtime allows its two main methods, \fBBundler\.setup\fR and \fBBundler\.require\fR, to limit their impact to particular groups\.
-.
-.IP "" 4
-.
-.nf
-
-# setup adds gems to Ruby\'s load path
-Bundler\.setup                    # defaults to all groups
-require "bundler/setup"          # same as Bundler\.setup
-Bundler\.setup(:default)          # only set up the _default_ group
-Bundler\.setup(:test)             # only set up the _test_ group (but `not` _default_)
-Bundler\.setup(:default, :test)   # set up the _default_ and _test_ groups, but no others
-
-# require requires all of the gems in the specified groups
-Bundler\.require                  # defaults to the _default_ group
-Bundler\.require(:default)        # identical
-Bundler\.require(:default, :test) # requires the _default_ and _test_ groups
-Bundler\.require(:test)           # requires the _test_ group
-.
-.fi
-.
-.IP "" 0
-.
-.P
-The Bundler CLI allows you to specify a list of groups whose gems \fBbundle install\fR should not install with the \fBwithout\fR configuration\.
-.
-.P
-To specify multiple groups to ignore, specify a list of groups separated by spaces\.
-.
-.IP "" 4
-.
-.nf
-
-bundle config set without test
-bundle config set without development test
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Also, calling \fBBundler\.setup\fR with no parameters, or calling \fBrequire "bundler/setup"\fR will setup all groups except for the ones you excluded via \fB\-\-without\fR (since they are not available)\.
-.
-.P
-Note that on \fBbundle install\fR, bundler downloads and evaluates all gems, in order to create a single canonical list of all of the required gems and their dependencies\. This means that you cannot list different versions of the same gems in different groups\. For more details, see Understanding Bundler \fIhttps://bundler\.io/rationale\.html\fR\.
-.
-.SS "PLATFORMS"
-If a gem should only be used in a particular platform or set of platforms, you can specify them\. Platforms are essentially identical to groups, except that you do not need to use the \fB\-\-without\fR install\-time flag to exclude groups of gems for other platforms\.
-.
-.P
-There are a number of \fBGemfile\fR platforms:
-.
-.TP
-\fBruby\fR
-C Ruby (MRI), Rubinius or TruffleRuby, but \fBNOT\fR Windows
-.
-.TP
-\fBmri\fR
-Same as \fIruby\fR, but only C Ruby (MRI)
-.
-.TP
-\fBmingw\fR
-Windows 32 bit \'mingw32\' platform (aka RubyInstaller)
-.
-.TP
-\fBx64_mingw\fR
-Windows 64 bit \'mingw32\' platform (aka RubyInstaller x64)
-.
-.TP
-\fBrbx\fR
-Rubinius
-.
-.TP
-\fBjruby\fR
-JRuby
-.
-.TP
-\fBtruffleruby\fR
-TruffleRuby
-.
-.TP
-\fBmswin\fR
-Windows
-.
-.P
-You can restrict further by platform and version for all platforms \fIexcept\fR for \fBrbx\fR, \fBjruby\fR, \fBtruffleruby\fR and \fBmswin\fR\.
-.
-.P
-To specify a version in addition to a platform, append the version number without the delimiter to the platform\. For example, to specify that a gem should only be used on platforms with Ruby 2\.3, use:
-.
-.IP "" 4
-.
-.nf
-
-ruby_23
-.
-.fi
-.
-.IP "" 0
-.
-.P
-The full list of platforms and supported versions includes:
-.
-.TP
-\fBruby\fR
-1\.8, 1\.9, 2\.0, 2\.1, 2\.2, 2\.3, 2\.4, 2\.5, 2\.6
-.
-.TP
-\fBmri\fR
-1\.8, 1\.9, 2\.0, 2\.1, 2\.2, 2\.3, 2\.4, 2\.5, 2\.6
-.
-.TP
-\fBmingw\fR
-1\.8, 1\.9, 2\.0, 2\.1, 2\.2, 2\.3, 2\.4, 2\.5, 2\.6
-.
-.TP
-\fBx64_mingw\fR
-2\.0, 2\.1, 2\.2, 2\.3, 2\.4, 2\.5, 2\.6
-.
-.P
-As with groups, you can specify one or more platforms:
-.
-.IP "" 4
-.
-.nf
-
-gem "weakling",   :platforms => :jruby
-gem "ruby\-debug", :platforms => :mri_18
-gem "nokogiri",   :platforms => [:mri_18, :jruby]
-.
-.fi
-.
-.IP "" 0
-.
-.P
-All operations involving groups (\fBbundle install\fR \fIbundle\-install\.1\.html\fR, \fBBundler\.setup\fR, \fBBundler\.require\fR) behave exactly the same as if any groups not matching the current platform were explicitly excluded\.
-.
-.SS "SOURCE"
-You can select an alternate Rubygems repository for a gem using the \':source\' option\.
-.
-.IP "" 4
-.
-.nf
-
-gem "some_internal_gem", :source => "https://gems\.example\.com"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-This forces the gem to be loaded from this source and ignores any global sources declared at the top level of the file\. If the gem does not exist in this source, it will not be installed\.
-.
-.P
-Bundler will search for child dependencies of this gem by first looking in the source selected for the parent, but if they are not found there, it will fall back on global sources using the ordering described in \fISOURCE PRIORITY\fR\.
-.
-.P
-Selecting a specific source repository this way also suppresses the ambiguous gem warning described above in \fIGLOBAL SOURCES (#source)\fR\.
-.
-.P
-Using the \fB:source\fR option for an individual gem will also make that source available as a possible global source for any other gems which do not specify explicit sources\. Thus, when adding gems with explicit sources, it is recommended that you also ensure all other gems in the Gemfile are using explicit sources\.
-.
-.SS "GIT"
-If necessary, you can specify that a gem is located at a particular git repository using the \fB:git\fR parameter\. The repository can be accessed via several protocols:
-.
-.TP
-\fBHTTP(S)\fR
-gem "rails", :git => "https://github\.com/rails/rails\.git"
-.
-.TP
-\fBSSH\fR
-gem "rails", :git => "git@github\.com:rails/rails\.git"
-.
-.TP
-\fBgit\fR
-gem "rails", :git => "git://github\.com/rails/rails\.git"
-.
-.P
-If using SSH, the user that you use to run \fBbundle install\fR \fBMUST\fR have the appropriate keys available in their \fB$HOME/\.ssh\fR\.
-.
-.P
-\fBNOTE\fR: \fBhttp://\fR and \fBgit://\fR URLs should be avoided if at all possible\. These protocols are unauthenticated, so a man\-in\-the\-middle attacker can deliver malicious code and compromise your system\. HTTPS and SSH are strongly preferred\.
-.
-.P
-The \fBgroup\fR, \fBplatforms\fR, and \fBrequire\fR options are available and behave exactly the same as they would for a normal gem\.
-.
-.P
-A git repository \fBSHOULD\fR have at least one file, at the root of the directory containing the gem, with the extension \fB\.gemspec\fR\. This file \fBMUST\fR contain a valid gem specification, as expected by the \fBgem build\fR command\.
-.
-.P
-If a git repository does not have a \fB\.gemspec\fR, bundler will attempt to create one, but it will not contain any dependencies, executables, or C extension compilation instructions\. As a result, it may fail to properly integrate into your application\.
-.
-.P
-If a git repository does have a \fB\.gemspec\fR for the gem you attached it to, a version specifier, if provided, means that the git repository is only valid if the \fB\.gemspec\fR specifies a version matching the version specifier\. If not, bundler will print a warning\.
-.
-.IP "" 4
-.
-.nf
-
-gem "rails", "2\.3\.8", :git => "https://github\.com/rails/rails\.git"
-# bundle install will fail, because the \.gemspec in the rails
-# repository\'s master branch specifies version 3\.0\.0
-.
-.fi
-.
-.IP "" 0
-.
-.P
-If a git repository does \fBnot\fR have a \fB\.gemspec\fR for the gem you attached it to, a version specifier \fBMUST\fR be provided\. Bundler will use this version in the simple \fB\.gemspec\fR it creates\.
-.
-.P
-Git repositories support a number of additional options\.
-.
-.TP
-\fBbranch\fR, \fBtag\fR, and \fBref\fR
-You \fBMUST\fR only specify at most one of these options\. The default is \fB:branch => "master"\fR\. For example:
-.
-.IP
-gem "rails", :git => "https://github\.com/rails/rails\.git", :branch => "5\-0\-stable"
-.
-.IP
-gem "rails", :git => "https://github\.com/rails/rails\.git", :tag => "v5\.0\.0"
-.
-.IP
-gem "rails", :git => "https://github\.com/rails/rails\.git", :ref => "4aded"
-.
-.TP
-\fBsubmodules\fR
-For reference, a git submodule \fIhttps://git\-scm\.com/book/en/v2/Git\-Tools\-Submodules\fR lets you have another git repository within a subfolder of your repository\. Specify \fB:submodules => true\fR to cause bundler to expand any submodules included in the git repository
-.
-.P
-If a git repository contains multiple \fB\.gemspecs\fR, each \fB\.gemspec\fR represents a gem located at the same place in the file system as the \fB\.gemspec\fR\.
-.
-.IP "" 4
-.
-.nf
-
-|~rails                   [git root]
-| |\-rails\.gemspec         [rails gem located here]
-|~actionpack
-| |\-actionpack\.gemspec    [actionpack gem located here]
-|~activesupport
-| |\-activesupport\.gemspec [activesupport gem located here]
-|\.\.\.
-.
-.fi
-.
-.IP "" 0
-.
-.P
-To install a gem located in a git repository, bundler changes to the directory containing the gemspec, runs \fBgem build name\.gemspec\fR and then installs the resulting gem\. The \fBgem build\fR command, which comes standard with Rubygems, evaluates the \fB\.gemspec\fR in the context of the directory in which it is located\.
-.
-.SS "GIT SOURCE"
-A custom git source can be defined via the \fBgit_source\fR method\. Provide the source\'s name as an argument, and a block which receives a single argument and interpolates it into a string to return the full repo address:
-.
-.IP "" 4
-.
-.nf
-
-git_source(:stash){ |repo_name| "https://stash\.corp\.acme\.pl/#{repo_name}\.git" }
-gem \'rails\', :stash => \'forks/rails\'
-.
-.fi
-.
-.IP "" 0
-.
-.P
-In addition, if you wish to choose a specific branch:
-.
-.IP "" 4
-.
-.nf
-
-gem "rails", :stash => "forks/rails", :branch => "branch_name"
-.
-.fi
-.
-.IP "" 0
-.
-.SS "GITHUB"
-\fBNOTE\fR: This shorthand should be avoided until Bundler 2\.0, since it currently expands to an insecure \fBgit://\fR URL\. This allows a man\-in\-the\-middle attacker to compromise your system\.
-.
-.P
-If the git repository you want to use is hosted on GitHub and is public, you can use the :github shorthand to specify the github username and repository name (without the trailing "\.git"), separated by a slash\. If both the username and repository name are the same, you can omit one\.
-.
-.IP "" 4
-.
-.nf
-
-gem "rails", :github => "rails/rails"
-gem "rails", :github => "rails"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Are both equivalent to
-.
-.IP "" 4
-.
-.nf
-
-gem "rails", :git => "git://github\.com/rails/rails\.git"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Since the \fBgithub\fR method is a specialization of \fBgit_source\fR, it accepts a \fB:branch\fR named argument\.
-.
-.SS "GIST"
-If the git repository you want to use is hosted as a Github Gist and is public, you can use the :gist shorthand to specify the gist identifier (without the trailing "\.git")\.
-.
-.IP "" 4
-.
-.nf
-
-gem "the_hatch", :gist => "4815162342"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Is equivalent to:
-.
-.IP "" 4
-.
-.nf
-
-gem "the_hatch", :git => "https://gist\.github\.com/4815162342\.git"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Since the \fBgist\fR method is a specialization of \fBgit_source\fR, it accepts a \fB:branch\fR named argument\.
-.
-.SS "BITBUCKET"
-If the git repository you want to use is hosted on Bitbucket and is public, you can use the :bitbucket shorthand to specify the bitbucket username and repository name (without the trailing "\.git"), separated by a slash\. If both the username and repository name are the same, you can omit one\.
-.
-.IP "" 4
-.
-.nf
-
-gem "rails", :bitbucket => "rails/rails"
-gem "rails", :bitbucket => "rails"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Are both equivalent to
-.
-.IP "" 4
-.
-.nf
-
-gem "rails", :git => "https://rails@bitbucket\.org/rails/rails\.git"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-Since the \fBbitbucket\fR method is a specialization of \fBgit_source\fR, it accepts a \fB:branch\fR named argument\.
-.
-.SS "PATH"
-You can specify that a gem is located in a particular location on the file system\. Relative paths are resolved relative to the directory containing the \fBGemfile\fR\.
-.
-.P
-Similar to the semantics of the \fB:git\fR option, the \fB:path\fR option requires that the directory in question either contains a \fB\.gemspec\fR for the gem, or that you specify an explicit version that bundler should use\.
-.
-.P
-Unlike \fB:git\fR, bundler does not compile C extensions for gems specified as paths\.
-.
-.IP "" 4
-.
-.nf
-
-gem "rails", :path => "vendor/rails"
-.
-.fi
-.
-.IP "" 0
-.
-.P
-If you would like to use multiple local gems directly from the filesystem, you can set a global \fBpath\fR option to the path containing the gem\'s files\. This will automatically load gemspec files from subdirectories\.
-.
-.IP "" 4
-.
-.nf
-
-path \'components\' do
-  gem \'admin_ui\'
-  gem \'public_ui\'
-end
-.
-.fi
-.
-.IP "" 0
-.
-.SH "BLOCK FORM OF SOURCE, GIT, PATH, GROUP and PLATFORMS"
-The \fB:source\fR, \fB:git\fR, \fB:path\fR, \fB:group\fR, and \fB:platforms\fR options may be applied to a group of gems by using block form\.
-.
-.IP "" 4
-.
-.nf
-
-source "https://gems\.example\.com" do
-  gem "some_internal_gem"
-  gem "another_internal_gem"
-end
-
-git "https://github\.com/rails/rails\.git" do
-  gem "activesupport"
-  gem "actionpack"
-end
-
-platforms :ruby do
-  gem "ruby\-debug"
-  gem "sqlite3"
-end
-
-group :development, :optional => true do
-  gem "wirble"
-  gem "faker"
-end
-.
-.fi
-.
-.IP "" 0
-.
-.P
-In the case of the group block form the :optional option can be given to prevent a group from being installed unless listed in the \fB\-\-with\fR option given to the \fBbundle install\fR command\.
-.
-.P
-In the case of the \fBgit\fR block form, the \fB:ref\fR, \fB:branch\fR, \fB:tag\fR, and \fB:submodules\fR options may be passed to the \fBgit\fR method, and all gems in the block will inherit those options\.
-.
-.P
-The presence of a \fBsource\fR block in a Gemfile also makes that source available as a possible global source for any other gems which do not specify explicit sources\. Thus, when defining source blocks, it is recommended that you also ensure all other gems in the Gemfile are using explicit sources, either via source blocks or \fB:source\fR directives on individual gems\.
-.
-.SH "INSTALL_IF"
-The \fBinstall_if\fR method allows gems to be installed based on a proc or lambda\. This is especially useful for optional gems that can only be used if certain software is installed or some other conditions are met\.
-.
-.IP "" 4
-.
-.nf
-
-install_if \-> { RUBY_PLATFORM =~ /darwin/ } do
-  gem "pasteboard"
-end
-.
-.fi
-.
-.IP "" 0
-.
-.SH "GEMSPEC"
-The \fB\.gemspec\fR \fIhttp://guides\.rubygems\.org/specification\-reference/\fR file is where you provide metadata about your gem to Rubygems\. Some required Gemspec attributes include the name, description, and homepage of your gem\. This is also where you specify the dependencies your gem needs to run\.
-.
-.P
-If you wish to use Bundler to help install dependencies for a gem while it is being developed, use the \fBgemspec\fR method to pull in the dependencies listed in the \fB\.gemspec\fR file\.
-.
-.P
-The \fBgemspec\fR method adds any runtime dependencies as gem requirements in the default group\. It also adds development dependencies as gem requirements in the \fBdevelopment\fR group\. Finally, it adds a gem requirement on your project (\fB:path => \'\.\'\fR)\. In conjunction with \fBBundler\.setup\fR, this allows you to require project files in your test code as you would if the project were installed as a gem; you need not manipulate the load path manually or require project files via relative paths\.
-.
-.P
-The \fBgemspec\fR method supports optional \fB:path\fR, \fB:glob\fR, \fB:name\fR, and \fB:development_group\fR options, which control where bundler looks for the \fB\.gemspec\fR, the glob it uses to look for the gemspec (defaults to: "{,\fI,\fR/*}\.gemspec"), what named \fB\.gemspec\fR it uses (if more than one is present), and which group development dependencies are included in\.
-.
-.P
-When a \fBgemspec\fR dependency encounters version conflicts during resolution, the local version under development will always be selected \-\- even if there are remote versions that better match other requirements for the \fBgemspec\fR gem\.
-.
-.SH "SOURCE PRIORITY"
-When attempting to locate a gem to satisfy a gem requirement, bundler uses the following priority order:
-.
-.IP "1." 4
-The source explicitly attached to the gem (using \fB:source\fR, \fB:path\fR, or \fB:git\fR)
-.
-.IP "2." 4
-For implicit gems (dependencies of explicit gems), any source, git, or path repository declared on the parent\. This results in bundler prioritizing the ActiveSupport gem from the Rails git repository over ones from \fBrubygems\.org\fR
-.
-.IP "3." 4
-The sources specified via global \fBsource\fR lines, searching each source in your \fBGemfile\fR from last added to first added\.
-.
-.IP "" 0
-
--- ruby2.7-2.7.6.orig/man/gemfile.5.ronn
+++ /dev/null
@@ -1,517 +0,0 @@
-Gemfile(5) -- A format for describing gem dependencies for Ruby programs
-========================================================================
-
-## SYNOPSIS
-
-A `Gemfile` describes the gem dependencies required to execute associated
-Ruby code.
-
-Place the `Gemfile` in the root of the directory containing the associated
-code. For instance, in a Rails application, place the `Gemfile` in the same
-directory as the `Rakefile`.
-
-## SYNTAX
-
-A `Gemfile` is evaluated as Ruby code, in a context which makes available
-a number of methods used to describe the gem requirements.
-
-## GLOBAL SOURCES
-
-At the top of the `Gemfile`, add a line for the `Rubygems` source that contains
-the gems listed in the `Gemfile`.
-
-    source "https://rubygems.org"
-
-It is possible, but not recommended as of Bundler 1.7, to add multiple global
-`source` lines. Each of these `source`s `MUST` be a valid Rubygems repository.
-
-Sources are checked for gems following the heuristics described in
-[SOURCE PRIORITY][]. If a gem is found in more than one global source, Bundler
-will print a warning after installing the gem indicating which source was used,
-and listing the other sources where the gem is available. A specific source can
-be selected for gems that need to use a non-standard repository, suppressing
-this warning, by using the [`:source` option](#SOURCE) or a
-[`source` block](#BLOCK-FORM-OF-SOURCE-GIT-PATH-GROUP-and-PLATFORMS).
-
-### CREDENTIALS
-
-Some gem sources require a username and password. Use [bundle config(1)](bundle-config.1.html) to set
-the username and password for any of the sources that need it. The command must
-be run once on each computer that will install the Gemfile, but this keeps the
-credentials from being stored in plain text in version control.
-
-    bundle config gems.example.com user:password
-
-For some sources, like a company Gemfury account, it may be easier to
-include the credentials in the Gemfile as part of the source URL.
-
-    source "https://user:password@gems.example.com"
-
-Credentials in the source URL will take precedence over credentials set using
-`config`.
-
-## RUBY
-
-If your application requires a specific Ruby version or engine, specify your
-requirements using the `ruby` method, with the following arguments.
-All parameters are `OPTIONAL` unless otherwise specified.
-
-### VERSION (required)
-
-The version of Ruby that your application requires. If your application
-requires an alternate Ruby engine, such as JRuby, Rubinius or TruffleRuby, this
-should be the Ruby version that the engine is compatible with.
-
-    ruby "1.9.3"
-
-### ENGINE
-
-Each application _may_ specify a Ruby engine. If an engine is specified, an
-engine version _must_ also be specified.
-
-What exactly is an Engine?
-  - A Ruby engine is an implementation of the Ruby language.
-
-  - For background: the reference or original implementation of the Ruby
-    programming language is called
-    [Matz's Ruby Interpreter](https://en.wikipedia.org/wiki/Ruby_MRI), or  MRI
-    for short. This is named after Ruby creator Yukihiro Matsumoto,
-    also known as Matz. MRI is also known as CRuby, because it is written in C.
-    MRI is the most widely used Ruby engine.
-
-  - [Other implementations](https://www.ruby-lang.org/en/about/) of Ruby exist.
-    Some of the more well-known implementations include
-    [Rubinius](https://rubinius.com/), and [JRuby](http://jruby.org/).
-    Rubinius is an alternative implementation of Ruby written in Ruby.
-    JRuby is an implementation of Ruby on the JVM, short for Java Virtual Machine.
-
-### ENGINE VERSION
-
-Each application _may_ specify a Ruby engine version. If an engine version is
-specified, an engine _must_ also be specified. If the engine is "ruby" the
-engine version specified _must_ match the Ruby version.
-
-    ruby "1.8.7", :engine => "jruby", :engine_version => "1.6.7"
-
-### PATCHLEVEL
-
-Each application _may_ specify a Ruby patchlevel.
-
-    ruby "2.0.0", :patchlevel => "247"
-
-## GEMS
-
-Specify gem requirements using the `gem` method, with the following arguments.
-All parameters are `OPTIONAL` unless otherwise specified.
-
-### NAME (required)
-
-For each gem requirement, list a single _gem_ line.
-
-    gem "nokogiri"
-
-### VERSION
-
-Each _gem_ `MAY` have one or more version specifiers.
-
-    gem "nokogiri", ">= 1.4.2"
-    gem "RedCloth", ">= 4.1.0", "< 4.2.0"
-
-### REQUIRE AS
-
-Each _gem_ `MAY` specify files that should be used when autorequiring via
-`Bundler.require`. You may pass an array with multiple files or `true` if file
-you want `required` has same name as _gem_ or `false` to
-prevent any file from being autorequired.
-
-    gem "redis", :require => ["redis/connection/hiredis", "redis"]
-    gem "webmock", :require => false
-    gem "byebug", :require => true
-
-The argument defaults to the name of the gem. For example, these are identical:
-
-    gem "nokogiri"
-    gem "nokogiri", :require => "nokogiri"
-    gem "nokogiri", :require => true
-
-### GROUPS
-
-Each _gem_ `MAY` specify membership in one or more groups. Any _gem_ that does
-not specify membership in any group is placed in the `default` group.
-
-    gem "rspec", :group => :test
-    gem "wirble", :groups => [:development, :test]
-
-The Bundler runtime allows its two main methods, `Bundler.setup` and
-`Bundler.require`, to limit their impact to particular groups.
-
-    # setup adds gems to Ruby's load path
-    Bundler.setup                    # defaults to all groups
-    require "bundler/setup"          # same as Bundler.setup
-    Bundler.setup(:default)          # only set up the _default_ group
-    Bundler.setup(:test)             # only set up the _test_ group (but `not` _default_)
-    Bundler.setup(:default, :test)   # set up the _default_ and _test_ groups, but no others
-
-    # require requires all of the gems in the specified groups
-    Bundler.require                  # defaults to the _default_ group
-    Bundler.require(:default)        # identical
-    Bundler.require(:default, :test) # requires the _default_ and _test_ groups
-    Bundler.require(:test)           # requires the _test_ group
-
-The Bundler CLI allows you to specify a list of groups whose gems `bundle install` should
-not install with the `without` configuration.
-
-To specify multiple groups to ignore, specify a list of groups separated by spaces.
-
-    bundle config set without test
-    bundle config set without development test
-
-Also, calling `Bundler.setup` with no parameters, or calling `require "bundler/setup"`
-will setup all groups except for the ones you excluded via `--without` (since they
-are not available).
-
-Note that on `bundle install`, bundler downloads and evaluates all gems, in order to
-create a single canonical list of all of the required gems and their dependencies.
-This means that you cannot list different versions of the same gems in different
-groups. For more details, see [Understanding Bundler](https://bundler.io/rationale.html).
-
-### PLATFORMS
-
-If a gem should only be used in a particular platform or set of platforms, you can
-specify them. Platforms are essentially identical to groups, except that you do not
-need to use the `--without` install-time flag to exclude groups of gems for other
-platforms.
-
-There are a number of `Gemfile` platforms:
-
-  * `ruby`:
-    C Ruby (MRI), Rubinius or TruffleRuby, but `NOT` Windows
-  * `mri`:
-    Same as _ruby_, but only C Ruby (MRI)
-  * `mingw`:
-    Windows 32 bit 'mingw32' platform (aka RubyInstaller)
-  * `x64_mingw`:
-    Windows 64 bit 'mingw32' platform (aka RubyInstaller x64)
-  * `rbx`:
-    Rubinius
-  * `jruby`:
-    JRuby
-  * `truffleruby`:
-    TruffleRuby
-  * `mswin`:
-    Windows
-
-You can restrict further by platform and version for all platforms *except* for
-`rbx`, `jruby`, `truffleruby` and `mswin`.
-
-To specify a version in addition to a platform, append the version number without
-the delimiter to the platform. For example, to specify that a gem should only be
-used on platforms with Ruby 2.3, use:
-
-    ruby_23
-
-The full list of platforms and supported versions includes:
-
-  * `ruby`:
-    1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6
-  * `mri`:
-    1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6
-  * `mingw`:
-    1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6
-  * `x64_mingw`:
-    2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6
-
-As with groups, you can specify one or more platforms:
-
-    gem "weakling",   :platforms => :jruby
-    gem "ruby-debug", :platforms => :mri_18
-    gem "nokogiri",   :platforms => [:mri_18, :jruby]
-
-All operations involving groups ([`bundle install`](bundle-install.1.html), `Bundler.setup`,
-`Bundler.require`) behave exactly the same as if any groups not
-matching the current platform were explicitly excluded.
-
-### SOURCE
-
-You can select an alternate Rubygems repository for a gem using the ':source'
-option.
-
-    gem "some_internal_gem", :source => "https://gems.example.com"
-
-This forces the gem to be loaded from this source and ignores any global sources
-declared at the top level of the file. If the gem does not exist in this source,
-it will not be installed.
-
-Bundler will search for child dependencies of this gem by first looking in the
-source selected for the parent, but if they are not found there, it will fall
-back on global sources using the ordering described in [SOURCE PRIORITY][].
-
-Selecting a specific source repository this way also suppresses the ambiguous
-gem warning described above in
-[GLOBAL SOURCES (#source)](#GLOBAL-SOURCES).
-
-Using the `:source` option for an individual gem will also make that source
-available as a possible global source for any other gems which do not specify
-explicit sources. Thus, when adding gems with explicit sources, it is
-recommended that you also ensure all other gems in the Gemfile are using
-explicit sources.
-
-### GIT
-
-If necessary, you can specify that a gem is located at a particular
-git repository using the `:git` parameter. The repository can be accessed via
-several protocols:
-
-  * `HTTP(S)`:
-    gem "rails", :git => "https://github.com/rails/rails.git"
-  * `SSH`:
-    gem "rails", :git => "git@github.com:rails/rails.git"
-  * `git`:
-    gem "rails", :git => "git://github.com/rails/rails.git"
-
-If using SSH, the user that you use to run `bundle install` `MUST` have the
-appropriate keys available in their `$HOME/.ssh`.
-
-`NOTE`: `http://` and `git://` URLs should be avoided if at all possible. These
-protocols are unauthenticated, so a man-in-the-middle attacker can deliver
-malicious code and compromise your system. HTTPS and SSH are strongly
-preferred.
-
-The `group`, `platforms`, and `require` options are available and behave
-exactly the same as they would for a normal gem.
-
-A git repository `SHOULD` have at least one file, at the root of the
-directory containing the gem, with the extension `.gemspec`. This file
-`MUST` contain a valid gem specification, as expected by the `gem build`
-command.
-
-If a git repository does not have a `.gemspec`, bundler will attempt to
-create one, but it will not contain any dependencies, executables, or
-C extension compilation instructions. As a result, it may fail to properly
-integrate into your application.
-
-If a git repository does have a `.gemspec` for the gem you attached it
-to, a version specifier, if provided, means that the git repository is
-only valid if the `.gemspec` specifies a version matching the version
-specifier. If not, bundler will print a warning.
-
-    gem "rails", "2.3.8", :git => "https://github.com/rails/rails.git"
-    # bundle install will fail, because the .gemspec in the rails
-    # repository's master branch specifies version 3.0.0
-
-If a git repository does `not` have a `.gemspec` for the gem you attached
-it to, a version specifier `MUST` be provided. Bundler will use this
-version in the simple `.gemspec` it creates.
-
-Git repositories support a number of additional options.
-
-  * `branch`, `tag`, and `ref`:
-    You `MUST` only specify at most one of these options. The default
-    is `:branch => "master"`.  For example:
-
-      gem "rails", :git => "https://github.com/rails/rails.git", :branch => "5-0-stable"
-
-      gem "rails", :git => "https://github.com/rails/rails.git", :tag => "v5.0.0"
-
-      gem "rails", :git => "https://github.com/rails/rails.git", :ref => "4aded"
-
-  * `submodules`:
-    For reference, a [git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules)
-    lets you have another git repository within a subfolder of your repository.
-    Specify `:submodules => true` to cause bundler to expand any
-    submodules included in the git repository
-
-If a git repository contains multiple `.gemspecs`, each `.gemspec`
-represents a gem located at the same place in the file system as
-the `.gemspec`.
-
-    |~rails                   [git root]
-    | |-rails.gemspec         [rails gem located here]
-    |~actionpack
-    | |-actionpack.gemspec    [actionpack gem located here]
-    |~activesupport
-    | |-activesupport.gemspec [activesupport gem located here]
-    |...
-
-To install a gem located in a git repository, bundler changes to
-the directory containing the gemspec, runs `gem build name.gemspec`
-and then installs the resulting gem. The `gem build` command,
-which comes standard with Rubygems, evaluates the `.gemspec` in
-the context of the directory in which it is located.
-
-### GIT SOURCE
-
-A custom git source can be defined via the `git_source` method. Provide the source's name
-as an argument, and a block which receives a single argument and interpolates it into a
-string to return the full repo address:
-
-    git_source(:stash){ |repo_name| "https://stash.corp.acme.pl/#{repo_name}.git" }
-    gem 'rails', :stash => 'forks/rails'
-
-In addition, if you wish to choose a specific branch:
-
-    gem "rails", :stash => "forks/rails", :branch => "branch_name"
-
-### GITHUB
-
-`NOTE`: This shorthand should be avoided until Bundler 2.0, since it
-currently expands to an insecure `git://` URL. This allows a
-man-in-the-middle attacker to compromise your system.
-
-If the git repository you want to use is hosted on GitHub and is public, you can use the
-:github shorthand to specify the github username and repository name (without the
-trailing ".git"), separated by a slash. If both the username and repository name are the
-same, you can omit one.
-
-    gem "rails", :github => "rails/rails"
-    gem "rails", :github => "rails"
-
-Are both equivalent to
-
-    gem "rails", :git => "git://github.com/rails/rails.git"
-
-Since the `github` method is a specialization of `git_source`, it accepts a `:branch` named argument.
-
-### GIST
-
-If the git repository you want to use is hosted as a Github Gist and is public, you can use
-the :gist shorthand to specify the gist identifier (without the trailing ".git").
-
-    gem "the_hatch", :gist => "4815162342"
-
-Is equivalent to:
-
-    gem "the_hatch", :git => "https://gist.github.com/4815162342.git"
-
-Since the `gist` method is a specialization of `git_source`, it accepts a `:branch` named argument.
-
-### BITBUCKET
-
-If the git repository you want to use is hosted on Bitbucket and is public, you can use the
-:bitbucket shorthand to specify the bitbucket username and repository name (without the
-trailing ".git"), separated by a slash. If both the username and repository name are the
-same, you can omit one.
-
-    gem "rails", :bitbucket => "rails/rails"
-    gem "rails", :bitbucket => "rails"
-
-Are both equivalent to
-
-    gem "rails", :git => "https://rails@bitbucket.org/rails/rails.git"
-
-Since the `bitbucket` method is a specialization of `git_source`, it accepts a `:branch` named argument.
-
-### PATH
-
-You can specify that a gem is located in a particular location
-on the file system. Relative paths are resolved relative to the
-directory containing the `Gemfile`.
-
-Similar to the semantics of the `:git` option, the `:path`
-option requires that the directory in question either contains
-a `.gemspec` for the gem, or that you specify an explicit
-version that bundler should use.
-
-Unlike `:git`, bundler does not compile C extensions for
-gems specified as paths.
-
-    gem "rails", :path => "vendor/rails"
-
-If you would like to use multiple local gems directly from the filesystem, you can set a global `path` option to the path containing the gem's files. This will automatically load gemspec files from subdirectories.
-
-    path 'components' do
-      gem 'admin_ui'
-      gem 'public_ui'
-    end
-
-## BLOCK FORM OF SOURCE, GIT, PATH, GROUP and PLATFORMS
-
-The `:source`, `:git`, `:path`, `:group`, and `:platforms` options may be
-applied to a group of gems by using block form.
-
-    source "https://gems.example.com" do
-      gem "some_internal_gem"
-      gem "another_internal_gem"
-    end
-
-    git "https://github.com/rails/rails.git" do
-      gem "activesupport"
-      gem "actionpack"
-    end
-
-    platforms :ruby do
-      gem "ruby-debug"
-      gem "sqlite3"
-    end
-
-    group :development, :optional => true do
-      gem "wirble"
-      gem "faker"
-    end
-
-In the case of the group block form the :optional option can be given
-to prevent a group from being installed unless listed in the `--with`
-option given to the `bundle install` command.
-
-In the case of the `git` block form, the `:ref`, `:branch`, `:tag`,
-and `:submodules` options may be passed to the `git` method, and
-all gems in the block will inherit those options.
-
-The presence of a `source` block in a Gemfile also makes that source
-available as a possible global source for any other gems which do not specify
-explicit sources. Thus, when defining source blocks, it is
-recommended that you also ensure all other gems in the Gemfile are using
-explicit sources, either via source blocks or `:source` directives on
-individual gems.
-
-## INSTALL_IF
-
-The `install_if` method allows gems to be installed based on a proc or lambda.
-This is especially useful for optional gems that can only be used if certain
-software is installed or some other conditions are met.
-
-    install_if -> { RUBY_PLATFORM =~ /darwin/ } do
-      gem "pasteboard"
-    end
-
-## GEMSPEC
-
-The [`.gemspec`](http://guides.rubygems.org/specification-reference/) file is where
- you provide metadata about your gem to Rubygems. Some required Gemspec
- attributes include the name, description, and homepage of your gem. This is
- also where you specify the dependencies your gem needs to run.
-
-If you wish to use Bundler to help install dependencies for a gem while it is
-being developed, use the `gemspec` method to pull in the dependencies listed in
-the `.gemspec` file.
-
-The `gemspec` method adds any runtime dependencies as gem requirements in the
-default group. It also adds development dependencies as gem requirements in the
-`development` group. Finally, it adds a gem requirement on your project (`:path
-=> '.'`). In conjunction with `Bundler.setup`, this allows you to require project
-files in your test code as you would if the project were installed as a gem; you
-need not manipulate the load path manually or require project files via relative
-paths.
-
-The `gemspec` method supports optional `:path`, `:glob`, `:name`, and `:development_group`
-options, which control where bundler looks for the `.gemspec`, the glob it uses to look
-for the gemspec (defaults to: "{,*,*/*}.gemspec"), what named `.gemspec` it uses
-(if more than one is present), and which group development dependencies are included in.
-
-When a `gemspec` dependency encounters version conflicts during resolution, the
-local version under development will always be selected -- even if there are
-remote versions that better match other requirements for the `gemspec` gem.
-
-## SOURCE PRIORITY
-
-When attempting to locate a gem to satisfy a gem requirement,
-bundler uses the following priority order:
-
-  1. The source explicitly attached to the gem (using `:source`, `:path`, or
-     `:git`)
-  2. For implicit gems (dependencies of explicit gems), any source, git, or path
-     repository declared on the parent. This results in bundler prioritizing the
-     ActiveSupport gem from the Rails git repository over ones from
-     `rubygems.org`
-  3. The sources specified via global `source` lines, searching each source in
-     your `Gemfile` from last added to first added.
--- ruby2.7-2.7.6.orig/man/gemfile.5.txt
+++ /dev/null
@@ -1,649 +0,0 @@
-GEMFILE(5)							    GEMFILE(5)
-
-
-
-NAME
-       Gemfile - A format for describing gem dependencies for Ruby programs
-
-SYNOPSIS
-       A Gemfile describes the gem dependencies required to execute associated
-       Ruby code.
-
-       Place the Gemfile in the root of the directory containing  the  associ-
-       ated  code.  For instance, in a Rails application, place the Gemfile in
-       the same directory as the Rakefile.
-
-SYNTAX
-       A Gemfile is evaluated as Ruby code, in a context which makes available
-       a number of methods used to describe the gem requirements.
-
-GLOBAL SOURCES
-       At the top of the Gemfile, add a line for the Rubygems source that con-
-       tains the gems listed in the Gemfile.
-
-
-
-	   source "https://rubygems.org"
-
-
-
-       It is possible, but not recommended as of Bundler 1.7, to add  multiple
-       global  source  lines.  Each  of these sources MUST be a valid Rubygems
-       repository.
-
-       Sources are checked for gems  following	the  heuristics  described  in
-       SOURCE  PRIORITY.  If  a  gem  is found in more than one global source,
-       Bundler will print a warning after installing the gem indicating  which
-       source  was used, and listing the other sources where the gem is avail-
-       able. A specific source can be selected for gems that  need  to	use  a
-       non-standard repository, suppressing this warning, by using the :source
-       option or a source block.
-
-   CREDENTIALS
-       Some gem sources require a username and password. Use bundle  config(1)
-       bundle-config.1.html  to  set  the username and password for any of the
-       sources that need it. The command must be run  once  on	each  computer
-       that  will  install  the  Gemfile,  but this keeps the credentials from
-       being stored in plain text in version control.
-
-
-
-	   bundle config gems.example.com user:password
-
-
-
-       For some sources, like a company Gemfury account, it may be  easier  to
-       include the credentials in the Gemfile as part of the source URL.
-
-
-
-	   source "https://user:password@gems.example.com"
-
-
-
-       Credentials in the source URL will take precedence over credentials set
-       using config.
-
-RUBY
-       If your application requires a specific Ruby version or engine, specify
-       your  requirements using the ruby method, with the following arguments.
-       All parameters are OPTIONAL unless otherwise specified.
-
-   VERSION (required)
-       The version of Ruby that your application requires. If your application
-       requires  an  alternate	Ruby  engine, such as JRuby, Rubinius or Truf-
-       fleRuby, this should be the Ruby version that the engine is  compatible
-       with.
-
-
-
-	   ruby "1.9.3"
-
-
-
-   ENGINE
-       Each  application may specify a Ruby engine. If an engine is specified,
-       an engine version must also be specified.
-
-       What exactly is an Engine? - A Ruby engine is an implementation of  the
-       Ruby language.
-
-       o   For	background:  the  reference  or original implementation of the
-	   Ruby  programming  language	is  called  Matz's  Ruby   Interpreter
-	   https://en.wikipedia.org/wiki/Ruby_MRI,  or	MRI for short. This is
-	   named after Ruby creator Yukihiro Matsumoto, also  known  as  Matz.
-	   MRI	is also known as CRuby, because it is written in C. MRI is the
-	   most widely used Ruby engine.
-
-       o   Other implementations https://www.ruby-lang.org/en/about/  of  Ruby
-	   exist. Some of the more well-known implementations include Rubinius
-	   https://rubinius.com/, and JRuby http://jruby.org/. Rubinius is  an
-	   alternative	implementation	of  Ruby  written in Ruby. JRuby is an
-	   implementation of Ruby on the JVM, short for Java Virtual Machine.
-
-
-
-   ENGINE VERSION
-       Each application may specify a Ruby engine version. If an  engine  ver-
-       sion  is  specified, an engine must also be specified. If the engine is
-       "ruby" the engine version specified must match the Ruby version.
-
-
-
-	   ruby "1.8.7", :engine => "jruby", :engine_version => "1.6.7"
-
-
-
-   PATCHLEVEL
-       Each application may specify a Ruby patchlevel.
-
-
-
-	   ruby "2.0.0", :patchlevel => "247"
-
-
-
-GEMS
-       Specify gem requirements using the gem method, with the following argu-
-       ments. All parameters are OPTIONAL unless otherwise specified.
-
-   NAME (required)
-       For each gem requirement, list a single gem line.
-
-
-
-	   gem "nokogiri"
-
-
-
-   VERSION
-       Each gem MAY have one or more version specifiers.
-
-
-
-	   gem "nokogiri", ">= 1.4.2"
-	   gem "RedCloth", ">= 4.1.0", "< 4.2.0"
-
-
-
-   REQUIRE AS
-       Each  gem  MAY specify files that should be used when autorequiring via
-       Bundler.require. You may pass an array with multiple files or  true  if
-       file  you  want	required  has same name as gem or false to prevent any
-       file from being autorequired.
-
-
-
-	   gem "redis", :require => ["redis/connection/hiredis", "redis"]
-	   gem "webmock", :require => false
-	   gem "byebug", :require => true
-
-
-
-       The argument defaults to the name of the gem. For  example,  these  are
-       identical:
-
-
-
-	   gem "nokogiri"
-	   gem "nokogiri", :require => "nokogiri"
-	   gem "nokogiri", :require => true
-
-
-
-   GROUPS
-       Each  gem  MAY  specify	membership in one or more groups. Any gem that
-       does not specify membership in any  group  is  placed  in  the  default
-       group.
-
-
-
-	   gem "rspec", :group => :test
-	   gem "wirble", :groups => [:development, :test]
-
-
-
-       The  Bundler  runtime  allows  its  two main methods, Bundler.setup and
-       Bundler.require, to limit their impact to particular groups.
-
-
-
-	   # setup adds gems to Ruby's load path
-	   Bundler.setup		    # defaults to all groups
-	   require "bundler/setup"	    # same as Bundler.setup
-	   Bundler.setup(:default)	    # only set up the _default_ group
-	   Bundler.setup(:test) 	    # only set up the _test_ group (but `not` _default_)
-	   Bundler.setup(:default, :test)   # set up the _default_ and _test_ groups, but no others
-
-	   # require requires all of the gems in the specified groups
-	   Bundler.require		    # defaults to the _default_ group
-	   Bundler.require(:default)	    # identical
-	   Bundler.require(:default, :test) # requires the _default_ and _test_ groups
-	   Bundler.require(:test)	    # requires the _test_ group
-
-
-
-       The Bundler CLI allows you to specify a list of groups whose gems  bun-
-       dle install should not install with the without configuration.
-
-       To  specify  multiple  groups to ignore, specify a list of groups sepa-
-       rated by spaces.
-
-
-
-	   bundle config set without test
-	   bundle config set without development test
-
-
-
-       Also, calling Bundler.setup with  no  parameters,  or  calling  require
-       "bundler/setup"	will setup all groups except for the ones you excluded
-       via --without (since they are not available).
-
-       Note that on bundle install, bundler downloads and evaluates all  gems,
-       in  order to create a single canonical list of all of the required gems
-       and their dependencies. This means that you cannot list different  ver-
-       sions  of  the  same  gems  in  different groups. For more details, see
-       Understanding Bundler https://bundler.io/rationale.html.
-
-   PLATFORMS
-       If a gem should only be used in a particular platform or set  of  plat-
-       forms,  you  can  specify  them. Platforms are essentially identical to
-       groups, except that you do not need to use the  --without  install-time
-       flag to exclude groups of gems for other platforms.
-
-       There are a number of Gemfile platforms:
-
-       ruby   C Ruby (MRI), Rubinius or TruffleRuby, but NOT Windows
-
-       mri    Same as ruby, but only C Ruby (MRI)
-
-       mingw  Windows 32 bit 'mingw32' platform (aka RubyInstaller)
-
-       x64_mingw
-	      Windows 64 bit 'mingw32' platform (aka RubyInstaller x64)
-
-       rbx    Rubinius
-
-       jruby  JRuby
-
-       truffleruby
-	      TruffleRuby
-
-       mswin  Windows
-
-       You  can  restrict  further  by	platform and version for all platforms
-       except for rbx, jruby, truffleruby and mswin.
-
-       To specify a version in addition to a platform, append the version num-
-       ber without the delimiter to the platform. For example, to specify that
-       a gem should only be used on platforms with Ruby 2.3, use:
-
-
-
-	   ruby_23
-
-
-
-       The full list of platforms and supported versions includes:
-
-       ruby   1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6
-
-       mri    1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6
-
-       mingw  1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6
-
-       x64_mingw
-	      2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6
-
-       As with groups, you can specify one or more platforms:
-
-
-
-	   gem "weakling",   :platforms => :jruby
-	   gem "ruby-debug", :platforms => :mri_18
-	   gem "nokogiri",   :platforms => [:mri_18, :jruby]
-
-
-
-       All operations involving groups (bundle install	bundle-install.1.html,
-       Bundler.setup,  Bundler.require)  behave  exactly  the  same  as if any
-       groups not matching the current platform were explicitly excluded.
-
-   SOURCE
-       You can select an alternate Rubygems repository for  a  gem  using  the
-       ':source' option.
-
-
-
-	   gem "some_internal_gem", :source => "https://gems.example.com"
-
-
-
-       This  forces  the  gem  to  be  loaded from this source and ignores any
-       global sources declared at the top level of the file. If the  gem  does
-       not exist in this source, it will not be installed.
-
-       Bundler will search for child dependencies of this gem by first looking
-       in the source selected for the parent, but if they are not found there,
-       it  will  fall  back  on global sources using the ordering described in
-       SOURCE PRIORITY.
-
-       Selecting a specific source repository this  way  also  suppresses  the
-       ambiguous gem warning described above in GLOBAL SOURCES (#source).
-
-       Using  the  :source  option  for  an individual gem will also make that
-       source available as a possible global source for any other  gems  which
-       do  not	specify explicit sources. Thus, when adding gems with explicit
-       sources, it is recommended that you also ensure all other gems  in  the
-       Gemfile are using explicit sources.
-
-   GIT
-       If necessary, you can specify that a gem is located at a particular git
-       repository using the :git parameter. The repository can be accessed via
-       several protocols:
-
-       HTTP(S)
-	      gem "rails", :git => "https://github.com/rails/rails.git"
-
-       SSH    gem "rails", :git => "git@github.com:rails/rails.git"
-
-       git    gem "rails", :git => "git://github.com/rails/rails.git"
-
-       If using SSH, the user that you use to run bundle install MUST have the
-       appropriate keys available in their $HOME/.ssh.
-
-       NOTE: http:// and git:// URLs should be avoided	if  at	all  possible.
-       These  protocols  are  unauthenticated, so a man-in-the-middle attacker
-       can deliver malicious code and compromise your system.  HTTPS  and  SSH
-       are strongly preferred.
-
-       The  group,  platforms,	and  require  options are available and behave
-       exactly the same as they would for a normal gem.
-
-       A git repository SHOULD have at least one file,	at  the  root  of  the
-       directory  containing  the  gem, with the extension .gemspec. This file
-       MUST contain a valid gem specification, as expected by  the  gem  build
-       command.
-
-       If  a  git repository does not have a .gemspec, bundler will attempt to
-       create one, but it will not contain any dependencies, executables, or C
-       extension  compilation  instructions. As a result, it may fail to prop-
-       erly integrate into your application.
-
-       If a git repository does have a .gemspec for the gem  you  attached  it
-       to,  a version specifier, if provided, means that the git repository is
-       only valid if the .gemspec specifies a  version	matching  the  version
-       specifier. If not, bundler will print a warning.
-
-
-
-	   gem "rails", "2.3.8", :git => "https://github.com/rails/rails.git"
-	   # bundle install will fail, because the .gemspec in the rails
-	   # repository's master branch specifies version 3.0.0
-
-
-
-       If  a  git repository does not have a .gemspec for the gem you attached
-       it to, a version specifier MUST be provided. Bundler will use this ver-
-       sion in the simple .gemspec it creates.
-
-       Git repositories support a number of additional options.
-
-       branch, tag, and ref
-	      You  MUST only specify at most one of these options. The default
-	      is :branch => "master". For example:
-
-	      gem  "rails",  :git   =>	 "https://github.com/rails/rails.git",
-	      :branch => "5-0-stable"
-
-	      gem  "rails", :git => "https://github.com/rails/rails.git", :tag
-	      => "v5.0.0"
-
-	      gem "rails", :git => "https://github.com/rails/rails.git",  :ref
-	      => "4aded"
-
-       submodules
-	      For	   reference,	       a	 git	     submodule
-	      https://git-scm.com/book/en/v2/Git-Tools-Submodules   lets   you
-	      have  another  git repository within a subfolder of your reposi-
-	      tory. Specify :submodules => true to cause bundler to expand any
-	      submodules included in the git repository
-
-       If  a  git repository contains multiple .gemspecs, each .gemspec repre-
-       sents a gem located at the same place in the file system as  the  .gem-
-       spec.
-
-
-
-	   |~rails		     [git root]
-	   | |-rails.gemspec	     [rails gem located here]
-	   |~actionpack
-	   | |-actionpack.gemspec    [actionpack gem located here]
-	   |~activesupport
-	   | |-activesupport.gemspec [activesupport gem located here]
-	   |...
-
-
-
-       To  install  a  gem located in a git repository, bundler changes to the
-       directory containing the gemspec, runs gem build name.gemspec and  then
-       installs the resulting gem. The gem build command, which comes standard
-       with Rubygems, evaluates the .gemspec in the context of	the  directory
-       in which it is located.
-
-   GIT SOURCE
-       A  custom  git source can be defined via the git_source method. Provide
-       the source's name as an argument, and a block which receives  a	single
-       argument  and  interpolates  it	into  a string to return the full repo
-       address:
-
-
-
-	   git_source(:stash){ |repo_name| "https://stash.corp.acme.pl/#{repo_name}.git" }
-	   gem 'rails', :stash => 'forks/rails'
-
-
-
-       In addition, if you wish to choose a specific branch:
-
-
-
-	   gem "rails", :stash => "forks/rails", :branch => "branch_name"
-
-
-
-   GITHUB
-       NOTE: This shorthand should be avoided until Bundler 2.0, since it cur-
-       rently expands to an insecure git:// URL. This allows a man-in-the-mid-
-       dle attacker to compromise your system.
-
-       If the git repository you want to use is hosted on GitHub and  is  pub-
-       lic,  you  can use the :github shorthand to specify the github username
-       and repository name (without  the  trailing  ".git"),  separated  by  a
-       slash.  If  both the username and repository name are the same, you can
-       omit one.
-
-
-
-	   gem "rails", :github => "rails/rails"
-	   gem "rails", :github => "rails"
-
-
-
-       Are both equivalent to
-
-
-
-	   gem "rails", :git => "git://github.com/rails/rails.git"
-
-
-
-       Since the github method is a specialization of git_source, it accepts a
-       :branch named argument.
-
-   GIST
-       If the git repository you want to use is hosted as a Github Gist and is
-       public, you can use the :gist shorthand to specify the gist  identifier
-       (without the trailing ".git").
-
-
-
-	   gem "the_hatch", :gist => "4815162342"
-
-
-
-       Is equivalent to:
-
-
-
-	   gem "the_hatch", :git => "https://gist.github.com/4815162342.git"
-
-
-
-       Since  the  gist method is a specialization of git_source, it accepts a
-       :branch named argument.
-
-   BITBUCKET
-       If the git repository you want to use is hosted	on  Bitbucket  and  is
-       public,	you  can use the :bitbucket shorthand to specify the bitbucket
-       username and repository name (without the trailing  ".git"),  separated
-       by  a slash. If both the username and repository name are the same, you
-       can omit one.
-
-
-
-	   gem "rails", :bitbucket => "rails/rails"
-	   gem "rails", :bitbucket => "rails"
-
-
-
-       Are both equivalent to
-
-
-
-	   gem "rails", :git => "https://rails@bitbucket.org/rails/rails.git"
-
-
-
-       Since the bitbucket  method  is	a  specialization  of  git_source,  it
-       accepts a :branch named argument.
-
-   PATH
-       You  can  specify that a gem is located in a particular location on the
-       file system. Relative paths are resolved relative to the directory con-
-       taining the Gemfile.
-
-       Similar	to the semantics of the :git option, the :path option requires
-       that the directory in question either contains a .gemspec for the  gem,
-       or that you specify an explicit version that bundler should use.
-
-       Unlike  :git,  bundler does not compile C extensions for gems specified
-       as paths.
-
-
-
-	   gem "rails", :path => "vendor/rails"
-
-
-
-       If you would like to use multiple local gems directly from the filesys-
-       tem,  you can set a global path option to the path containing the gem's
-       files. This will automatically load gemspec files from subdirectories.
-
-
-
-	   path 'components' do
-	     gem 'admin_ui'
-	     gem 'public_ui'
-	   end
-
-
-
-BLOCK FORM OF SOURCE, GIT, PATH, GROUP and PLATFORMS
-       The :source, :git, :path, :group, and :platforms options may be applied
-       to a group of gems by using block form.
-
-
-
-	   source "https://gems.example.com" do
-	     gem "some_internal_gem"
-	     gem "another_internal_gem"
-	   end
-
-	   git "https://github.com/rails/rails.git" do
-	     gem "activesupport"
-	     gem "actionpack"
-	   end
-
-	   platforms :ruby do
-	     gem "ruby-debug"
-	     gem "sqlite3"
-	   end
-
-	   group :development, :optional => true do
-	     gem "wirble"
-	     gem "faker"
-	   end
-
-
-
-       In  the	case of the group block form the :optional option can be given
-       to prevent a group from being installed unless  listed  in  the	--with
-       option given to the bundle install command.
-
-       In  the	case of the git block form, the :ref, :branch, :tag, and :sub-
-       modules options may be passed to the git method, and all  gems  in  the
-       block will inherit those options.
-
-       The  presence  of  a  source  block in a Gemfile also makes that source
-       available as a possible global source for any other gems which  do  not
-       specify explicit sources. Thus, when defining source blocks, it is rec-
-       ommended that you also ensure all other gems in the Gemfile  are  using
-       explicit  sources,  either  via	source blocks or :source directives on
-       individual gems.
-
-INSTALL_IF
-       The install_if method allows gems to be installed based on  a  proc  or
-       lambda.	This  is  especially useful for optional gems that can only be
-       used if certain software is installed or some other conditions are met.
-
-
-
-	   install_if -> { RUBY_PLATFORM =~ /darwin/ } do
-	     gem "pasteboard"
-	   end
-
-
-
-GEMSPEC
-       The .gemspec  http://guides.rubygems.org/specification-reference/  file
-       is where you provide metadata about your gem to Rubygems. Some required
-       Gemspec attributes include the name, description, and homepage of  your
-       gem.  This is also where you specify the dependencies your gem needs to
-       run.
-
-       If you wish to use Bundler to help install dependencies for a gem while
-       it  is being developed, use the gemspec method to pull in the dependen-
-       cies listed in the .gemspec file.
-
-       The gemspec method adds any runtime dependencies as gem requirements in
-       the  default  group.  It  also  adds  development  dependencies	as gem
-       requirements in the development group. Finally, it adds a gem  require-
-       ment on your project (:path => '.'). In conjunction with Bundler.setup,
-       this allows you to require project files in your test code as you would
-       if  the	project  were  installed as a gem; you need not manipulate the
-       load path manually or require project files via relative paths.
-
-       The gemspec method supports optional :path, :glob, :name, and :develop-
-       ment_group options, which control where bundler looks for the .gemspec,
-       the glob it uses to look for the  gemspec  (defaults  to:  "{,,/*}.gem-
-       spec"),	what named .gemspec it uses (if more than one is present), and
-       which group development dependencies are included in.
-
-       When a gemspec dependency encounters version conflicts  during  resolu-
-       tion,  the  local  version under development will always be selected --
-       even if there are remote versions that better match other  requirements
-       for the gemspec gem.
-
-SOURCE PRIORITY
-       When  attempting  to locate a gem to satisfy a gem requirement, bundler
-       uses the following priority order:
-
-       1.  The source explicitly attached to the gem (using :source, :path, or
-	   :git)
-
-       2.  For implicit gems (dependencies of explicit gems), any source, git,
-	   or path repository declared on the parent. This results in  bundler
-	   prioritizing  the  ActiveSupport  gem from the Rails git repository
-	   over ones from rubygems.org
-
-       3.  The sources specified  via  global  source  lines,  searching  each
-	   source in your Gemfile from last added to first added.
-
-
-
-
-
-
-				 January 2020			    GEMFILE(5)
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/bundler_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/bundler_spec.rb
@@ -21,30 +21,6 @@ RSpec.describe Bundler do
       it "catches YAML syntax errors" do
         expect { subject }.to raise_error(Bundler::GemspecError, /error while loading `test.gemspec`/)
       end
-
-      context "on Rubies with a settable YAML engine", :if => defined?(YAML::ENGINE) do
-        context "with Syck as YAML::Engine" do
-          it "raises a GemspecError after YAML load throws ArgumentError" do
-            orig_yamler = YAML::ENGINE.yamler
-            YAML::ENGINE.yamler = "syck"
-
-            expect { subject }.to raise_error(Bundler::GemspecError)
-
-            YAML::ENGINE.yamler = orig_yamler
-          end
-        end
-
-        context "with Psych as YAML::Engine" do
-          it "raises a GemspecError after YAML load throws Psych::SyntaxError" do
-            orig_yamler = YAML::ENGINE.yamler
-            YAML::ENGINE.yamler = "psych"
-
-            expect { subject }.to raise_error(Bundler::GemspecError)
-
-            YAML::ENGINE.yamler = orig_yamler
-          end
-        end
-      end
     end
 
     context "with correct YAML file", :if => defined?(Encoding) do
@@ -124,7 +100,15 @@ RSpec.describe Bundler do
 
   describe "#which" do
     let(:executable) { "executable" }
-    let(:path) { %w[/a /b c ../d /e] }
+
+    let(:path) do
+      if Gem.win_platform?
+        %w[C:/a C:/b C:/c C:/../d C:/e]
+      else
+        %w[/a /b c ../d /e]
+      end
+    end
+
     let(:expected) { "executable" }
 
     before do
@@ -149,7 +133,13 @@ RSpec.describe Bundler do
     it_behaves_like "it returns the correct executable"
 
     context "when the executable in inside a quoted path" do
-      let(:expected) { "/e/executable" }
+      let(:expected) do
+        if Gem.win_platform?
+          "C:/e/executable"
+        else
+          "/e/executable"
+        end
+      end
       it_behaves_like "it returns the correct executable"
     end
 
@@ -162,11 +152,9 @@ RSpec.describe Bundler do
   describe "configuration" do
     context "disable_shared_gems" do
       it "should unset GEM_PATH with empty string" do
-        env = {}
         expect(Bundler).to receive(:use_system_gems?).and_return(false)
-        Bundler.send(:configure_gem_path, env)
-        expect(env.keys).to include("GEM_PATH")
-        expect(env["GEM_PATH"]).to eq ""
+        Bundler.send(:configure_gem_path)
+        expect(ENV["GEM_PATH"]).to eq ""
       end
     end
   end
@@ -179,9 +167,9 @@ RSpec.describe Bundler do
         allow(::Bundler::FileUtils).to receive(:remove_entry_secure).and_raise(ArgumentError)
         allow(File).to receive(:world_writable?).and_return(true)
         message = <<EOF
-It is a security vulnerability to allow your home directory to be world-writable, and bundler can not continue.
+It is a security vulnerability to allow your home directory to be world-writable, and bundler cannot continue.
 You should probably consider fixing this issue by running `chmod o-w ~` on *nix.
-Please refer to https://ruby-doc.org/stdlib-2.1.2/libdoc/fileutils/rdoc/FileUtils.html#method-c-remove_entry_secure for details.
+Please refer to https://ruby-doc.org/stdlib-3.1.2/libdoc/fileutils/rdoc/FileUtils.html#method-c-remove_entry_secure for details.
 EOF
         expect(bundler_ui).to receive(:warn).with(message)
         expect { Bundler.send(:rm_rf, bundled_app) }.to raise_error(Bundler::PathError)
@@ -196,6 +184,8 @@ EOF
         gem "rack"
       G
 
+      allow(Bundler).to receive(:root).and_return(bundled_app)
+
       Bundler.mkdir_p(bundled_app.join("foo", "bar"))
       expect(bundled_app.join("foo", "bar")).to exist
     end
@@ -233,11 +223,8 @@ EOF
           allow(Bundler.rubygems).to receive(:user_home).and_return(path)
           allow(File).to receive(:directory?).with(path).and_return false
           allow(Bundler).to receive(:tmp).and_return(Pathname.new("/tmp/trulyrandom"))
-          message = <<EOF
-`/home/oggy` is not a directory.
-Bundler will use `/tmp/trulyrandom' as your home directory temporarily.
-EOF
-          expect(Bundler.ui).to receive(:warn).with(message)
+          expect(Bundler.ui).to receive(:warn).with("`/home/oggy` is not a directory.\n")
+          expect(Bundler.ui).to receive(:warn).with("Bundler will use `/tmp/trulyrandom' as your home directory temporarily.\n")
           expect(Bundler.user_home).to eq(Pathname("/tmp/trulyrandom"))
         end
       end
@@ -252,11 +239,8 @@ EOF
           allow(File).to receive(:writable?).with(path).and_return false
           allow(File).to receive(:directory?).with(dotbundle).and_return false
           allow(Bundler).to receive(:tmp).and_return(Pathname.new("/tmp/trulyrandom"))
-          message = <<EOF
-`/home/oggy` is not writable.
-Bundler will use `/tmp/trulyrandom' as your home directory temporarily.
-EOF
-          expect(Bundler.ui).to receive(:warn).with(message)
+          expect(Bundler.ui).to receive(:warn).with("`/home/oggy` is not writable.\n")
+          expect(Bundler.ui).to receive(:warn).with("Bundler will use `/tmp/trulyrandom' as your home directory temporarily.\n")
           expect(Bundler.user_home).to eq(Pathname("/tmp/trulyrandom"))
         end
 
@@ -277,11 +261,8 @@ EOF
       it "should issue warning and return a temporary user home" do
         allow(Bundler.rubygems).to receive(:user_home).and_return(nil)
         allow(Bundler).to receive(:tmp).and_return(Pathname.new("/tmp/trulyrandom"))
-        message = <<EOF
-Your home directory is not set.
-Bundler will use `/tmp/trulyrandom' as your home directory temporarily.
-EOF
-        expect(Bundler.ui).to receive(:warn).with(message)
+        expect(Bundler.ui).to receive(:warn).with("Your home directory is not set.\n")
+        expect(Bundler.ui).to receive(:warn).with("Bundler will use `/tmp/trulyrandom' as your home directory temporarily.\n")
         expect(Bundler.user_home).to eq(Pathname("/tmp/trulyrandom"))
       end
     end
@@ -322,7 +303,7 @@ EOF
       end
 
       context "with unwritable files in a parent dir" do
-        # Regression test for https://github.com/bundler/bundler/pull/6316
+        # Regression test for https://github.com/rubygems/bundler/pull/6316
         # It doesn't matter if there are other unwritable files so long as
         # bundle_path can be created
         before do
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/cli_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/cli_spec.rb
@@ -4,16 +4,18 @@ require "bundler/cli"
 
 RSpec.describe "bundle executable" do
   it "returns non-zero exit status when passed unrecognized options" do
-    bundle "--invalid_argument"
-    expect(exitstatus).to_not be_zero if exitstatus
+    bundle "--invalid_argument", :raise_on_error => false
+    expect(exitstatus).to_not be_zero
   end
 
   it "returns non-zero exit status when passed unrecognized task" do
-    bundle "unrecognized-task"
-    expect(exitstatus).to_not be_zero if exitstatus
+    bundle "unrecognized-task", :raise_on_error => false
+    expect(exitstatus).to_not be_zero
   end
 
   it "looks for a binary and executes it if it's named bundler-<task>" do
+    skip "Could not find command testtasks, probably because not a windows friendly executable" if Gem.win_platform?
+
     File.open(tmp("bundler-testtasks"), "w", 0o755) do |f|
       ruby = ENV["RUBY"] || "/usr/bin/env ruby"
       f.puts "#!#{ruby}\nputs 'Hello, world'\n"
@@ -23,7 +25,6 @@ RSpec.describe "bundle executable" do
       bundle "testtasks"
     end
 
-    expect(exitstatus).to be_zero if exitstatus
     expect(out).to eq("Hello, world")
   end
 
@@ -31,55 +32,63 @@ RSpec.describe "bundle executable" do
     it "aliases e to exec" do
       bundle "e --help"
 
-      expect(out).to include("BUNDLE-EXEC")
+      expect(out_with_macos_man_workaround).to include("bundle-exec")
     end
 
     it "aliases ex to exec" do
       bundle "ex --help"
 
-      expect(out).to include("BUNDLE-EXEC")
+      expect(out_with_macos_man_workaround).to include("bundle-exec")
     end
 
     it "aliases exe to exec" do
       bundle "exe --help"
 
-      expect(out).to include("BUNDLE-EXEC")
+      expect(out_with_macos_man_workaround).to include("bundle-exec")
     end
 
     it "aliases c to check" do
       bundle "c --help"
 
-      expect(out).to include("BUNDLE-CHECK")
+      expect(out_with_macos_man_workaround).to include("bundle-check")
     end
 
     it "aliases i to install" do
       bundle "i --help"
 
-      expect(out).to include("BUNDLE-INSTALL")
+      expect(out_with_macos_man_workaround).to include("bundle-install")
     end
 
     it "aliases ls to list" do
       bundle "ls --help"
 
-      expect(out).to include("BUNDLE-LIST")
+      expect(out_with_macos_man_workaround).to include("bundle-list")
     end
 
     it "aliases package to cache" do
       bundle "package --help"
 
-      expect(out).to include("BUNDLE-CACHE")
+      expect(out_with_macos_man_workaround).to include("bundle-cache")
     end
 
     it "aliases pack to cache" do
       bundle "pack --help"
 
-      expect(out).to include("BUNDLE-CACHE")
+      expect(out_with_macos_man_workaround).to include("bundle-cache")
+    end
+
+    private
+
+    # Some `man` (e.g., on macOS) always highlights the output even to
+    # non-tty.
+    def out_with_macos_man_workaround
+      out.gsub(/.[\b]/, "")
     end
   end
 
   context "with no arguments" do
     it "prints a concise help message", :bundler => "3" do
-      bundle! ""
+      bundle ""
       expect(err).to be_empty
       expect(out).to include("Bundler version #{Bundler::VERSION}").
         and include("\n\nBundler commands:\n\n").
@@ -91,7 +100,7 @@ RSpec.describe "bundle executable" do
 
   context "when ENV['BUNDLE_GEMFILE'] is set to an empty string" do
     it "ignores it" do
-      gemfile bundled_app("Gemfile"), <<-G
+      gemfile bundled_app_gemfile, <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem 'rack'
       G
@@ -102,54 +111,38 @@ RSpec.describe "bundle executable" do
     end
   end
 
-  context "when ENV['RUBYGEMS_GEMDEPS'] is set" do
-    it "displays a warning" do
-      gemfile bundled_app("Gemfile"), <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem 'rack'
-      G
-
-      bundle :install, :env => { "RUBYGEMS_GEMDEPS" => "foo" }
-      expect(err).to include("RUBYGEMS_GEMDEPS")
-      expect(err).to include("conflict with Bundler")
-
-      bundle :install, :env => { "RUBYGEMS_GEMDEPS" => "" }
-      expect(err).not_to include("RUBYGEMS_GEMDEPS")
-    end
-  end
-
   context "with --verbose" do
     it "prints the running command" do
-      gemfile ""
-      bundle! "info bundler", :verbose => true
+      gemfile "source \"#{file_uri_for(gem_repo1)}\""
+      bundle "info bundler", :verbose => true
       expect(out).to start_with("Running `bundle info bundler --verbose` with bundler #{Bundler::VERSION}")
     end
 
     it "doesn't print defaults" do
-      install_gemfile! "", :verbose => true
-      expect(out).to start_with("Running `bundle install --retry 0 --verbose` with bundler #{Bundler::VERSION}")
+      install_gemfile "source \"#{file_uri_for(gem_repo1)}\"", :verbose => true
+      expect(out).to start_with("Running `bundle install --verbose` with bundler #{Bundler::VERSION}")
     end
 
     it "doesn't print defaults" do
-      install_gemfile! "", :verbose => true
-      expect(out).to start_with("Running `bundle install --retry 0 --verbose` with bundler #{Bundler::VERSION}")
+      install_gemfile "source \"#{file_uri_for(gem_repo1)}\"", :verbose => true
+      expect(out).to start_with("Running `bundle install --verbose` with bundler #{Bundler::VERSION}")
     end
   end
 
   describe "printing the outdated warning" do
     shared_examples_for "no warning" do
       it "prints no warning" do
-        bundle "fail"
+        bundle "fail", :env => { "BUNDLER_VERSION" => bundler_version }, :raise_on_error => false
         expect(last_command.stdboth).to eq("Could not find command \"fail\".")
       end
     end
 
-    let(:bundler_version) { "1.1" }
+    let(:bundler_version) { "2.0" }
     let(:latest_version) { nil }
     before do
-      bundle! "config set --global disable_version_check false"
+      bundle "config set --global disable_version_check false"
 
-      simulate_bundler_version(bundler_version)
+      pristine_system_gems "bundler-#{bundler_version}"
       if latest_version
         info_path = home(".bundle/cache/compact_index/rubygems.org.443.29b0360b937aa4d161703e6160654e47/info/bundler")
         info_path.parent.mkpath
@@ -174,24 +167,24 @@ RSpec.describe "bundle executable" do
     context "when the latest version is greater than the current version" do
       let(:latest_version) { "222.0" }
       it "prints the version warning" do
-        bundle "fail"
+        bundle "fail", :env => { "BUNDLER_VERSION" => bundler_version }, :raise_on_error => false
         expect(err).to start_with(<<-EOS.strip)
 The latest bundler is #{latest_version}, but you are currently running #{bundler_version}.
-To install the latest version, run `gem install bundler`
+To update to the most recent version, run `bundle update --bundler`
         EOS
       end
 
       context "and disable_version_check is set" do
-        before { bundle! "config set disable_version_check true" }
+        before { bundle "config set disable_version_check true", :env => { "BUNDLER_VERSION" => bundler_version } }
         include_examples "no warning"
       end
 
       context "running a parseable command" do
         it "prints no warning" do
-          bundle! "config get --parseable foo"
+          bundle "config get --parseable foo", :env => { "BUNDLER_VERSION" => bundler_version }
           expect(last_command.stdboth).to eq ""
 
-          bundle "platform --ruby"
+          bundle "platform --ruby", :env => { "BUNDLER_VERSION" => bundler_version }, :raise_on_error => false
           expect(last_command.stdboth).to eq "Could not locate Gemfile"
         end
       end
@@ -199,10 +192,10 @@ To install the latest version, run `gem 
       context "and is a pre-release" do
         let(:latest_version) { "222.0.0.pre.4" }
         it "prints the version warning" do
-          bundle "fail"
+          bundle "fail", :env => { "BUNDLER_VERSION" => bundler_version }, :raise_on_error => false
           expect(err).to start_with(<<-EOS.strip)
 The latest bundler is #{latest_version}, but you are currently running #{bundler_version}.
-To install the latest version, run `gem install bundler --pre`
+To update to the most recent version, run `bundle update --bundler`
           EOS
         end
       end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/compact_index_client/updater_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/compact_index_client/updater_spec.rb
@@ -3,28 +3,24 @@
 require "net/http"
 require "bundler/compact_index_client"
 require "bundler/compact_index_client/updater"
+require "tmpdir"
 
 RSpec.describe Bundler::CompactIndexClient::Updater do
   let(:fetcher) { double(:fetcher) }
-  let(:local_path) { Pathname("/tmp/localpath") }
+  let(:local_path) { Pathname.new Dir.mktmpdir("localpath") }
   let(:remote_path) { double(:remote_path) }
 
-  subject(:updater) { described_class.new(fetcher) }
+  let!(:updater) { described_class.new(fetcher) }
 
   context "when the ETag header is missing" do
-    # Regression test for https://github.com/bundler/bundler/issues/5463
+    # Regression test for https://github.com/rubygems/bundler/issues/5463
+    let(:response) { double(:response, :body => "abc123") }
 
-    let(:response) { double(:response, :body => "") }
-
-    it "MisMatchedChecksumError is raised" do
-      # Twice: #update retries on failure
-      expect(response).to receive(:[]).with("Content-Encoding").twice { "" }
-      expect(response).to receive(:[]).with("ETag").twice { nil }
-      expect(fetcher).to receive(:call).twice { response }
+    it "treats the response as an update" do
+      expect(response).to receive(:[]).with("ETag") { nil }
+      expect(fetcher).to receive(:call) { response }
 
-      expect do
-        updater.update(local_path, remote_path)
-      end.to raise_error(Bundler::CompactIndexClient::Updater::MisMatchedChecksumError)
+      updater.update(local_path, remote_path)
     end
   end
 
@@ -32,8 +28,7 @@ RSpec.describe Bundler::CompactIndexClie
     let(:response) { double(:response, :body => "") }
 
     it "raises HTTPError" do
-      expect(response).to receive(:[]).with("Content-Encoding") { "gzip" }
-      expect(fetcher).to receive(:call) { response }
+      expect(fetcher).to receive(:call).and_raise(Zlib::GzipFile::Error)
 
       expect do
         updater.update(local_path, remote_path)
@@ -41,15 +36,24 @@ RSpec.describe Bundler::CompactIndexClie
     end
   end
 
-  context "when bundler doesn't have permissions on Dir.tmpdir" do
-    let(:response) { double(:response, :body => "") }
+  context "when receiving non UTF-8 data and default internal encoding set to ASCII" do
+    let(:response) { double(:response, :body => "\x8B".b) }
 
-    it "Errno::EACCES is raised" do
-      allow(Dir).to receive(:mktmpdir) { raise Errno::EACCES }
+    it "works just fine" do
+      old_verbose = $VERBOSE
+      previous_internal_encoding = Encoding.default_internal
+
+      begin
+        $VERBOSE = false
+        Encoding.default_internal = "ASCII"
+        expect(response).to receive(:[]).with("ETag") { nil }
+        expect(fetcher).to receive(:call) { response }
 
-      expect do
         updater.update(local_path, remote_path)
-      end.to raise_error(Bundler::PermissionError)
+      ensure
+        Encoding.default_internal = previous_internal_encoding
+        $VERBOSE = old_verbose
+      end
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/definition_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/definition_spec.rb
@@ -31,48 +31,20 @@ RSpec.describe Bundler::Definition do
           to raise_error(Bundler::TemporaryResourceError, /temporarily unavailable/)
       end
     end
-  end
-
-  describe "detects changes" do
-    it "for a path gem with changes", :bundler => "< 3" do
-      build_lib "foo", "1.0", :path => lib_path("foo")
-
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "foo", :path => "#{lib_path("foo")}"
-      G
-
-      build_lib "foo", "1.0", :path => lib_path("foo") do |s|
-        s.add_dependency "rack", "1.0"
+    context "when Bundler::Definition.no_lock is set to true" do
+      subject { Bundler::Definition.new(nil, [], Bundler::SourceList.new, []) }
+      before { Bundler::Definition.no_lock = true }
+      after { Bundler::Definition.no_lock = false }
+
+      it "does not create a lock file" do
+        subject.lock("Gemfile.lock")
+        expect(File.file?("Gemfile.lock")).to eq false
       end
-
-      bundle :install, :env => { "DEBUG" => "1" }
-
-      expect(out).to match(/re-resolving dependencies/)
-      lockfile_should_be <<-G
-        PATH
-          remote: #{lib_path("foo")}
-          specs:
-            foo (1.0)
-              rack (= 1.0)
-
-        GEM
-          remote: #{file_uri_for(gem_repo1)}/
-          specs:
-            rack (1.0.0)
-
-        PLATFORMS
-          #{lockfile_platforms}
-
-        DEPENDENCIES
-          foo!
-
-        BUNDLED WITH
-           #{Bundler::VERSION}
-      G
     end
+  end
 
-    it "for a path gem with changes", :bundler => "3" do
+  describe "detects changes" do
+    it "for a path gem with changes" do
       build_lib "foo", "1.0", :path => lib_path("foo")
 
       install_gemfile <<-G
@@ -87,7 +59,7 @@ RSpec.describe Bundler::Definition do
       bundle :install, :env => { "DEBUG" => "1" }
 
       expect(out).to match(/re-resolving dependencies/)
-      lockfile_should_be <<-G
+      expect(lockfile).to eq <<~G
         PATH
           remote: #{lib_path("foo")}
           specs:
@@ -124,7 +96,7 @@ RSpec.describe Bundler::Definition do
       bundle :check, :env => { "DEBUG" => "1" }
 
       expect(out).to match(/using resolution from the lockfile/)
-      lockfile_should_be <<-G
+      expect(lockfile).to eq <<~G
         PATH
           remote: #{lib_path("foo")}
           specs:
@@ -157,15 +129,14 @@ RSpec.describe Bundler::Definition do
       bundle :check, :env => { "DEBUG" => "1" }
 
       expect(out).to match(/using resolution from the lockfile/)
-      lockfile_should_be <<-G
+      expect(lockfile).to eq <<~G
         GEM
           remote: #{file_uri_for(gem_repo1)}/
           specs:
             only_java (1.1-java)
 
         PLATFORMS
-          java
-          #{lockfile_platforms}
+          #{lockfile_platforms_for(["java", specific_local_platform])}
 
         DEPENDENCIES
           only_java
@@ -184,7 +155,7 @@ RSpec.describe Bundler::Definition do
       bundle :check, :env => { "DEBUG" => "1" }
 
       expect(out).to match(/using resolution from the lockfile/)
-      lockfile_should_be <<-G
+      expect(lockfile).to eq <<~G
         GEM
           remote: #{file_uri_for(gem_repo1)}/
           specs:
@@ -210,10 +181,12 @@ RSpec.describe Bundler::Definition do
           source "#{file_uri_for(gem_repo1)}"
           gem "foo"
           G
+
+          allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
         end
 
         it "should get a locked specs list when updating all" do
-          definition = Bundler::Definition.new(bundled_app("Gemfile.lock"), [], Bundler::SourceList.new, true)
+          definition = Bundler::Definition.new(bundled_app_lock, [], Bundler::SourceList.new, true)
           locked_specs = definition.gem_version_promoter.locked_specs
           expect(locked_specs.to_a.map(&:name)).to eq ["foo"]
           expect(definition.instance_variable_get("@locked_specs").empty?).to eq true
@@ -230,7 +203,7 @@ RSpec.describe Bundler::Definition do
       context "eager unlock" do
         let(:source_list) do
           Bundler::SourceList.new.tap do |source_list|
-            source_list.global_rubygems_source = file_uri_for(gem_repo4)
+            source_list.add_global_rubygems_remote(file_uri_for(gem_repo4))
           end
         end
 
@@ -267,6 +240,8 @@ RSpec.describe Bundler::Definition do
             BUNDLED WITH
                1.13.0
           L
+
+          allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
         end
 
         it "should not eagerly unlock shared dependency with bundle install conservative updating behavior" do
@@ -275,7 +250,7 @@ RSpec.describe Bundler::Definition do
                                      Bundler::Dependency.new("shared_owner_b", ">= 0")]
           unlock_hash_for_bundle_install = {}
           definition = Bundler::Definition.new(
-            bundled_app("Gemfile.lock"),
+            bundled_app_lock,
             updated_deps_in_gemfile,
             source_list,
             unlock_hash_for_bundle_install
@@ -289,10 +264,10 @@ RSpec.describe Bundler::Definition do
                                      Bundler::Dependency.new("shared_owner_a", ">= 0"),
                                      Bundler::Dependency.new("shared_owner_b", ">= 0")]
           definition = Bundler::Definition.new(
-            bundled_app("Gemfile.lock"),
+            bundled_app_lock,
             updated_deps_in_gemfile,
             source_list,
-            :gems => ["shared_owner_a"], :lock_shared_dependencies => true
+            :gems => ["shared_owner_a"], :conservative => true
           )
           locked = definition.send(:converge_locked_specs).map(&:name)
           expect(locked).to eq %w[isolated_dep isolated_owner shared_dep shared_owner_b]
@@ -302,33 +277,6 @@ RSpec.describe Bundler::Definition do
     end
   end
 
-  describe "find_resolved_spec" do
-    it "with no platform set in SpecSet" do
-      ss = Bundler::SpecSet.new([build_stub_spec("a", "1.0"), build_stub_spec("b", "1.0")])
-      dfn = Bundler::Definition.new(nil, [], mock_source_list, true)
-      dfn.instance_variable_set("@specs", ss)
-      found = dfn.find_resolved_spec(build_spec("a", "0.9", "ruby").first)
-      expect(found.name).to eq "a"
-      expect(found.version.to_s).to eq "1.0"
-    end
-  end
-
-  describe "find_indexed_specs" do
-    it "with no platform set in indexed specs" do
-      index = Bundler::Index.new
-      %w[1.0.0 1.0.1 1.1.0].each {|v| index << build_stub_spec("foo", v) }
-
-      dfn = Bundler::Definition.new(nil, [], mock_source_list, true)
-      dfn.instance_variable_set("@index", index)
-      found = dfn.find_indexed_specs(build_spec("foo", "0.9", "ruby").first)
-      expect(found.length).to eq 3
-    end
-  end
-
-  def build_stub_spec(name, version)
-    Bundler::StubSpecification.new(name, version, nil, nil)
-  end
-
   def mock_source_list
     Class.new do
       def all_sources
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/dep_proxy_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/dep_proxy_spec.rb
@@ -2,10 +2,10 @@
 
 RSpec.describe Bundler::DepProxy do
   let(:dep) { Bundler::Dependency.new("rake", ">= 0") }
-  subject { described_class.new(dep, Gem::Platform::RUBY) }
+  subject { described_class.get_proxy(dep, Gem::Platform::RUBY) }
   let(:same) { subject }
-  let(:other) { subject.dup }
-  let(:different) { described_class.new(dep, Gem::Platform::JAVA) }
+  let(:other) { described_class.get_proxy(dep, Gem::Platform::RUBY) }
+  let(:different) { described_class.get_proxy(dep, Gem::Platform::JAVA) }
 
   describe "#eql?" do
     it { expect(subject.eql?(same)).to be true }
@@ -15,8 +15,18 @@ RSpec.describe Bundler::DepProxy do
     it { expect(subject.eql?("foobar")).to be false }
   end
 
-  describe "#hash" do
-    it { expect(subject.hash).to eq(same.hash) }
-    it { expect(subject.hash).to eq(other.hash) }
+  describe "must use factory methods" do
+    it { expect { described_class.new(dep, Gem::Platform::RUBY) }.to raise_error NoMethodError }
+    it { expect { subject.dup }.to raise_error NoMethodError }
+    it { expect { subject.clone }.to raise_error NoMethodError }
+  end
+
+  describe "frozen" do
+    if Gem.ruby_version >= Gem::Version.new("2.5.0")
+      error = Object.const_get("FrozenError")
+    else
+      error = RuntimeError
+    end
+    it { expect { subject.instance_variable_set(:@__platform, {}) }.to raise_error error }
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/bundler/dependency_spec.rb
@@ -0,0 +1,143 @@
+# frozen_string_literal: true
+
+RSpec.describe Bundler::Dependency do
+  let(:options) do
+    {}
+  end
+  let(:dependency) do
+    described_class.new(
+      "test_gem",
+      "1.0.0",
+      options
+    )
+  end
+
+  describe "to_lock" do
+    it "returns formatted string" do
+      expect(dependency.to_lock).to eq("  test_gem (= 1.0.0)")
+    end
+
+    it "matches format of Gem::Dependency#to_lock" do
+      gem_dependency = Gem::Dependency.new("test_gem", "1.0.0")
+      expect(dependency.to_lock).to eq(gem_dependency.to_lock)
+    end
+
+    context "when source is passed" do
+      let(:options) do
+        {
+          "source" => Bundler::Source::Git.new({}),
+        }
+      end
+
+      it "returns formatted string with exclamation mark" do
+        expect(dependency.to_lock).to eq("  test_gem (= 1.0.0)!")
+      end
+    end
+  end
+
+  describe "PLATFORM_MAP" do
+    subject { described_class::PLATFORM_MAP }
+
+    # rubocop:disable Naming/VariableNumber
+    let(:platforms) do
+      { :ruby => Gem::Platform::RUBY,
+        :ruby_18 => Gem::Platform::RUBY,
+        :ruby_19 => Gem::Platform::RUBY,
+        :ruby_20 => Gem::Platform::RUBY,
+        :ruby_21 => Gem::Platform::RUBY,
+        :ruby_22 => Gem::Platform::RUBY,
+        :ruby_23 => Gem::Platform::RUBY,
+        :ruby_24 => Gem::Platform::RUBY,
+        :ruby_25 => Gem::Platform::RUBY,
+        :ruby_26 => Gem::Platform::RUBY,
+        :ruby_27 => Gem::Platform::RUBY,
+        :ruby_30 => Gem::Platform::RUBY,
+        :ruby_31 => Gem::Platform::RUBY,
+        :mri => Gem::Platform::RUBY,
+        :mri_18 => Gem::Platform::RUBY,
+        :mri_19 => Gem::Platform::RUBY,
+        :mri_20 => Gem::Platform::RUBY,
+        :mri_21 => Gem::Platform::RUBY,
+        :mri_22 => Gem::Platform::RUBY,
+        :mri_23 => Gem::Platform::RUBY,
+        :mri_24 => Gem::Platform::RUBY,
+        :mri_25 => Gem::Platform::RUBY,
+        :mri_26 => Gem::Platform::RUBY,
+        :mri_27 => Gem::Platform::RUBY,
+        :mri_30 => Gem::Platform::RUBY,
+        :mri_31 => Gem::Platform::RUBY,
+        :rbx => Gem::Platform::RUBY,
+        :truffleruby => Gem::Platform::RUBY,
+        :jruby => Gem::Platform::JAVA,
+        :jruby_18 => Gem::Platform::JAVA,
+        :jruby_19 => Gem::Platform::JAVA,
+        :windows => Gem::Platform::WINDOWS,
+        :windows_18 => Gem::Platform::WINDOWS,
+        :windows_19 => Gem::Platform::WINDOWS,
+        :windows_20 => Gem::Platform::WINDOWS,
+        :windows_21 => Gem::Platform::WINDOWS,
+        :windows_22 => Gem::Platform::WINDOWS,
+        :windows_23 => Gem::Platform::WINDOWS,
+        :windows_24 => Gem::Platform::WINDOWS,
+        :windows_25 => Gem::Platform::WINDOWS,
+        :windows_26 => Gem::Platform::WINDOWS,
+        :windows_27 => Gem::Platform::WINDOWS,
+        :windows_30 => Gem::Platform::WINDOWS,
+        :windows_31 => Gem::Platform::WINDOWS,
+        :mswin => Gem::Platform::MSWIN,
+        :mswin_18 => Gem::Platform::MSWIN,
+        :mswin_19 => Gem::Platform::MSWIN,
+        :mswin_20 => Gem::Platform::MSWIN,
+        :mswin_21 => Gem::Platform::MSWIN,
+        :mswin_22 => Gem::Platform::MSWIN,
+        :mswin_23 => Gem::Platform::MSWIN,
+        :mswin_24 => Gem::Platform::MSWIN,
+        :mswin_25 => Gem::Platform::MSWIN,
+        :mswin_26 => Gem::Platform::MSWIN,
+        :mswin_27 => Gem::Platform::MSWIN,
+        :mswin_30 => Gem::Platform::MSWIN,
+        :mswin_31 => Gem::Platform::MSWIN,
+        :mswin64 => Gem::Platform::MSWIN64,
+        :mswin64_19 => Gem::Platform::MSWIN64,
+        :mswin64_20 => Gem::Platform::MSWIN64,
+        :mswin64_21 => Gem::Platform::MSWIN64,
+        :mswin64_22 => Gem::Platform::MSWIN64,
+        :mswin64_23 => Gem::Platform::MSWIN64,
+        :mswin64_24 => Gem::Platform::MSWIN64,
+        :mswin64_25 => Gem::Platform::MSWIN64,
+        :mswin64_26 => Gem::Platform::MSWIN64,
+        :mswin64_27 => Gem::Platform::MSWIN64,
+        :mswin64_30 => Gem::Platform::MSWIN64,
+        :mswin64_31 => Gem::Platform::MSWIN64,
+        :mingw => Gem::Platform::MINGW,
+        :mingw_18 => Gem::Platform::MINGW,
+        :mingw_19 => Gem::Platform::MINGW,
+        :mingw_20 => Gem::Platform::MINGW,
+        :mingw_21 => Gem::Platform::MINGW,
+        :mingw_22 => Gem::Platform::MINGW,
+        :mingw_23 => Gem::Platform::MINGW,
+        :mingw_24 => Gem::Platform::MINGW,
+        :mingw_25 => Gem::Platform::MINGW,
+        :mingw_26 => Gem::Platform::MINGW,
+        :mingw_27 => Gem::Platform::MINGW,
+        :mingw_30 => Gem::Platform::MINGW,
+        :mingw_31 => Gem::Platform::MINGW,
+        :x64_mingw => Gem::Platform::X64_MINGW,
+        :x64_mingw_20 => Gem::Platform::X64_MINGW,
+        :x64_mingw_21 => Gem::Platform::X64_MINGW,
+        :x64_mingw_22 => Gem::Platform::X64_MINGW,
+        :x64_mingw_23 => Gem::Platform::X64_MINGW,
+        :x64_mingw_24 => Gem::Platform::X64_MINGW,
+        :x64_mingw_25 => Gem::Platform::X64_MINGW,
+        :x64_mingw_26 => Gem::Platform::X64_MINGW,
+        :x64_mingw_27 => Gem::Platform::X64_MINGW,
+        :x64_mingw_30 => Gem::Platform::X64_MINGW,
+        :x64_mingw_31 => Gem::Platform::X64_MINGW }
+    end
+    # rubocop:enable Naming/VariableNumber
+
+    it "includes all platforms" do
+      expect(subject).to eq(platforms)
+    end
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/bundler/digest_spec.rb
@@ -0,0 +1,17 @@
+# frozen_string_literal: true
+
+require "digest"
+require "bundler/digest"
+
+RSpec.describe Bundler::Digest do
+  context "SHA1" do
+    subject { Bundler::Digest }
+    let(:stdlib) { ::Digest::SHA1 }
+
+    it "is compatible with stdlib" do
+      ["foo", "skfjsdlkfjsdf", "3924m", "ldskfj"].each do |payload|
+        expect(subject.sha1(payload)).to be == stdlib.hexdigest(payload)
+      end
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/dsl_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/dsl_spec.rb
@@ -25,7 +25,46 @@ RSpec.describe Bundler::Dsl do
       expect { subject.git_source(:example) }.to raise_error(Bundler::InvalidOption)
     end
 
-    context "default hosts", :bundler => "2" do
+    it "converts :github PR to URI using https" do
+      subject.gem("sparks", :github => "https://github.com/indirect/sparks/pull/5")
+      github_uri = "https://github.com/indirect/sparks.git"
+      expect(subject.dependencies.first.source.uri).to eq(github_uri)
+      expect(subject.dependencies.first.source.branch).to eq("refs/pull/5/head")
+    end
+
+    it "rejects :github PR URI with a branch, ref or tag" do
+      expect do
+        subject.gem("sparks", :github => "https://github.com/indirect/sparks/pull/5", :branch => "foo")
+      end.to raise_error(
+        Bundler::GemfileError,
+        %(The :branch option can't be used with `github: "https://github.com/indirect/sparks/pull/5"`),
+      )
+
+      expect do
+        subject.gem("sparks", :github => "https://github.com/indirect/sparks/pull/5", :ref => "foo")
+      end.to raise_error(
+        Bundler::GemfileError,
+        %(The :ref option can't be used with `github: "https://github.com/indirect/sparks/pull/5"`),
+      )
+
+      expect do
+        subject.gem("sparks", :github => "https://github.com/indirect/sparks/pull/5", :tag => "foo")
+      end.to raise_error(
+        Bundler::GemfileError,
+        %(The :tag option can't be used with `github: "https://github.com/indirect/sparks/pull/5"`),
+      )
+    end
+
+    it "rejects :github with :git" do
+      expect do
+        subject.gem("sparks", :github => "indirect/sparks", :git => "https://github.com/indirect/sparks.git")
+      end.to raise_error(
+        Bundler::GemfileError,
+        %(The :git option can't be used with `github: "indirect/sparks"`),
+      )
+    end
+
+    context "default hosts", :bundler => "< 3" do
       it "converts :github to URI using https" do
         subject.gem("sparks", :github => "indirect/sparks")
         github_uri = "https://github.com/indirect/sparks.git"
@@ -63,16 +102,16 @@ RSpec.describe Bundler::Dsl do
       end
     end
 
-    context "default git sources", :bundler => "3" do
-      it "has none" do
-        expect(subject.instance_variable_get(:@git_sources)).to eq({})
+    context "default git sources" do
+      it "has bitbucket, gist, and github" do
+        expect(subject.instance_variable_get(:@git_sources).keys.sort).to eq(%w[bitbucket gist github])
       end
     end
   end
 
   describe "#method_missing" do
     it "raises an error for unknown DSL methods" do
-      expect(Bundler).to receive(:read_file).with(bundled_app("Gemfile").to_s).
+      expect(Bundler).to receive(:read_file).with(source_root.join("Gemfile").to_s).
         and_return("unknown")
 
       error_msg = "There was an error parsing `Gemfile`: Undefined local variable or method `unknown' for Gemfile. Bundler cannot continue."
@@ -83,13 +122,13 @@ RSpec.describe Bundler::Dsl do
 
   describe "#eval_gemfile" do
     it "handles syntax errors with a useful message" do
-      expect(Bundler).to receive(:read_file).with(bundled_app("Gemfile").to_s).and_return("}")
+      expect(Bundler).to receive(:read_file).with(source_root.join("Gemfile").to_s).and_return("}")
       expect { subject.eval_gemfile("Gemfile") }.
         to raise_error(Bundler::GemfileError, /There was an error parsing `Gemfile`: (syntax error, unexpected tSTRING_DEND|(compile error - )?syntax error, unexpected '\}'). Bundler cannot continue./)
     end
 
     it "distinguishes syntax errors from evaluation errors" do
-      expect(Bundler).to receive(:read_file).with(bundled_app("Gemfile").to_s).and_return(
+      expect(Bundler).to receive(:read_file).with(source_root.join("Gemfile").to_s).and_return(
         "ruby '2.1.5', :engine => 'ruby', :engine_version => '1.2.4'"
       )
       expect { subject.eval_gemfile("Gemfile") }.
@@ -98,12 +137,15 @@ RSpec.describe Bundler::Dsl do
   end
 
   describe "#gem" do
-    [:ruby, :ruby_18, :ruby_19, :ruby_20, :ruby_21, :ruby_22, :ruby_23, :ruby_24, :ruby_25, :ruby_26, :mri, :mri_18, :mri_19,
-     :mri_20, :mri_21, :mri_22, :mri_23, :mri_24, :mri_25, :mri_26, :jruby, :rbx, :truffleruby].each do |platform|
+    # rubocop:disable Naming/VariableNumber
+    [:ruby, :ruby_18, :ruby_19, :ruby_20, :ruby_21, :ruby_22, :ruby_23, :ruby_24, :ruby_25, :ruby_26, :ruby_27,
+     :ruby_30, :ruby_31, :mri, :mri_18, :mri_19, :mri_20, :mri_21, :mri_22, :mri_23, :mri_24, :mri_25, :mri_26,
+     :mri_27, :mri_30, :mri_31, :jruby, :rbx, :truffleruby].each do |platform|
       it "allows #{platform} as a valid platform" do
         subject.gem("foo", :platform => platform)
       end
     end
+    # rubocop:enable Naming/VariableNumber
 
     it "rejects invalid platforms" do
       expect { subject.gem("foo", :platform => :bogus) }.
@@ -174,40 +216,6 @@ RSpec.describe Bundler::Dsl do
     end
   end
 
-  describe "#gemspec" do
-    let(:spec) do
-      Gem::Specification.new do |gem|
-        gem.name = "example"
-        gem.platform = platform
-      end
-    end
-
-    before do
-      allow(Dir).to receive(:[]).and_return(["spec_path"])
-      allow(Bundler).to receive(:load_gemspec).with("spec_path").and_return(spec)
-      allow(Bundler).to receive(:default_gemfile).and_return(Pathname.new("./Gemfile"))
-    end
-
-    context "with a ruby platform" do
-      let(:platform) { "ruby" }
-
-      it "keeps track of the ruby platforms in the dependency" do
-        subject.gemspec
-        expect(subject.dependencies.last.platforms).to eq(Bundler::Dependency::REVERSE_PLATFORM_MAP[Gem::Platform::RUBY])
-      end
-    end
-
-    context "with a jruby platform" do
-      let(:platform) { "java" }
-
-      it "keeps track of the jruby platforms in the dependency" do
-        allow(Gem::Platform).to receive(:local).and_return(java)
-        subject.gemspec
-        expect(subject.dependencies.last.platforms).to eq(Bundler::Dependency::REVERSE_PLATFORM_MAP[Gem::Platform::JAVA])
-      end
-    end
-  end
-
   context "can bundle groups of gems with" do
     # git "https://github.com/rails/rails.git" do
     #   gem "railties"
@@ -229,7 +237,7 @@ RSpec.describe Bundler::Dsl do
     #   gem 'spree_api'
     #   gem 'spree_backend'
     # end
-    describe "#github", :bundler => "< 3" do
+    describe "#github" do
       it "from github" do
         spree_gems = %w[spree_core spree_api spree_backend]
         subject.github "spree" do
@@ -241,36 +249,12 @@ RSpec.describe Bundler::Dsl do
         end
       end
     end
-
-    describe "#github", :bundler => "2" do
-      it "from github" do
-        spree_gems = %w[spree_core spree_api spree_backend]
-        subject.github "spree" do
-          spree_gems.each {|spree_gem| subject.send :gem, spree_gem }
-        end
-
-        subject.dependencies.each do |d|
-          expect(d.source.uri).to eq("https://github.com/spree/spree.git")
-        end
-      end
-    end
-
-    describe "#github", :bundler => "3" do
-      it "from github" do
-        expect do
-          spree_gems = %w[spree_core spree_api spree_backend]
-          subject.github "spree" do
-            spree_gems.each {|spree_gem| subject.send :gem, spree_gem }
-          end
-        end.to raise_error(Bundler::DeprecatedError, /github method has been removed/)
-      end
-    end
   end
 
   describe "syntax errors" do
     it "will raise a Bundler::GemfileError" do
       gemfile "gem 'foo', :path => /unquoted/string/syntax/error"
-      expect { Bundler::Dsl.evaluate(bundled_app("Gemfile"), nil, true) }.
+      expect { Bundler::Dsl.evaluate(bundled_app_gemfile, nil, true) }.
         to raise_error(Bundler::GemfileError, /There was an error parsing `Gemfile`:( compile error -)? unknown regexp options - trg.+ Bundler cannot continue./)
     end
   end
@@ -278,7 +262,7 @@ RSpec.describe Bundler::Dsl do
   describe "Runtime errors" do
     it "will raise a Bundler::GemfileError" do
       gemfile "raise RuntimeError, 'foo'"
-      expect { Bundler::Dsl.evaluate(bundled_app("Gemfile"), nil, true) }.
+      expect { Bundler::Dsl.evaluate(bundled_app_gemfile, nil, true) }.
         to raise_error(Bundler::GemfileError, /There was an error parsing `Gemfile`: foo. Bundler cannot continue./i)
     end
   end
@@ -299,4 +283,21 @@ RSpec.describe Bundler::Dsl do
       end
     end
   end
+
+  describe "#check_primary_source_safety" do
+    context "when a global source is not defined implicitly" do
+      it "will raise a major deprecation warning" do
+        not_a_global_source = double("not-a-global-source", :no_remotes? => true)
+        allow(Bundler::Source::Rubygems).to receive(:new).and_return(not_a_global_source)
+
+        warning = "This Gemfile does not include an explicit global source. " \
+          "Not using an explicit global source may result in a different lockfile being generated depending on " \
+          "the gems you have installed locally before bundler is run. " \
+          "Instead, define a global source in your Gemfile like this: source \"https://rubygems.org\"."
+        expect(Bundler::SharedHelpers).to receive(:major_deprecation).with(2, warning)
+
+        subject.check_primary_source_safety
+      end
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/endpoint_specification_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/endpoint_specification_spec.rb
@@ -5,9 +5,10 @@ RSpec.describe Bundler::EndpointSpecific
   let(:version)      { "1.0.0" }
   let(:platform)     { Gem::Platform::RUBY }
   let(:dependencies) { [] }
+  let(:spec_fetcher) { double(:spec_fetcher) }
   let(:metadata)     { nil }
 
-  subject(:spec) { described_class.new(name, version, platform, dependencies, metadata) }
+  subject(:spec) { described_class.new(name, version, platform, spec_fetcher, dependencies, metadata) }
 
   describe "#build_dependency" do
     let(:name)           { "foo" }
@@ -32,22 +33,6 @@ RSpec.describe Bundler::EndpointSpecific
         )
       end
     end
-
-    context "when there is an ill formed requirement" do
-      before do
-        allow(Gem::Dependency).to receive(:new).with(name, [requirement1, requirement2]) {
-          raise ArgumentError.new("Ill-formed requirement [\"#<YAML::Syck::DefaultKey")
-        }
-        # Eliminate extra line break in rspec output due to `puts` in `#build_dependency`
-        allow(subject).to receive(:puts) {}
-      end
-
-      it "should raise a Bundler::GemspecError with invalid gemspec message" do
-        expect { subject.send(:build_dependency, name, [requirement1, requirement2]) }.to raise_error(
-          Bundler::GemspecError, /Unfortunately, the gem foo \(1\.0\.0\) has an invalid gemspec/
-        )
-      end
-    end
   end
 
   describe "#parse_metadata" do
@@ -63,8 +48,37 @@ RSpec.describe Bundler::EndpointSpecific
     end
   end
 
+  describe "#required_ruby_version" do
+    context "required_ruby_version is already set on endpoint specification" do
+      existing_value = "already set value"
+      let(:required_ruby_version) { existing_value }
+
+      it "should return the current value when already set on endpoint specification" do
+        remote_spec = double(:remote_spec, :required_ruby_version => "remote_value", :required_rubygems_version => nil)
+
+        expect(spec.required_ruby_version). eql?(existing_value)
+      end
+    end
+
+    it "should return the remote spec value when not set on endpoint specification and remote spec has one" do
+      remote_value = "remote_value"
+      remote_spec = double(:remote_spec, :required_ruby_version => remote_value, :required_rubygems_version => nil)
+      allow(spec_fetcher).to receive(:fetch_spec).and_return(remote_spec)
+
+      expect(spec.required_ruby_version). eql?(remote_value)
+    end
+
+    it "should use the default Gem Requirement value when not set on endpoint specification and not set on remote spec" do
+      remote_spec = double(:remote_spec, :required_ruby_version => nil, :required_rubygems_version => nil)
+      allow(spec_fetcher).to receive(:fetch_spec).and_return(remote_spec)
+      expect(spec.required_ruby_version). eql?(Gem::Requirement.default)
+    end
+  end
+
   it "supports equality comparison" do
-    other_spec = described_class.new("bar", version, platform, dependencies, metadata)
+    remote_spec = double(:remote_spec, :required_ruby_version => nil, :required_rubygems_version => nil)
+    allow(spec_fetcher).to receive(:fetch_spec).and_return(remote_spec)
+    other_spec = described_class.new("bar", version, platform, spec_fetcher, dependencies, metadata)
     expect(spec).to eql(spec)
     expect(spec).to_not eql(other_spec)
   end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/env_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/env_spec.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
 
-require "openssl"
 require "bundler/settings"
+require "openssl"
 
 RSpec.describe Bundler::Env do
   let(:git_proxy_stub) { Bundler::Source::Git::GitProxy.new(nil, nil, nil) }
@@ -34,6 +34,8 @@ RSpec.describe Bundler::Env do
       end
 
       it "prints user home" do
+        skip "needs to use a valid HOME" if Gem.win_platform? && RUBY_VERSION < "2.6.0"
+
         with_clear_paths("HOME", "/a/b/c") do
           out = described_class.report
           expect(out).to include("User Home   /a/b/c")
@@ -41,7 +43,11 @@ RSpec.describe Bundler::Env do
       end
 
       it "prints user path" do
+        skip "needs to use a valid HOME" if Gem.win_platform? && RUBY_VERSION < "2.6.0"
+
         with_clear_paths("HOME", "/a/b/c") do
+          allow(File).to receive(:exist?)
+          allow(File).to receive(:exist?).with("/a/b/c/.gem").and_return(true)
           out = described_class.report
           expect(out).to include("User Path   /a/b/c/.gem")
         end
@@ -54,7 +60,7 @@ RSpec.describe Bundler::Env do
         end
       end
 
-    private
+      private
 
       def with_clear_paths(env_var, env_value)
         old_env_var = ENV[env_var]
@@ -68,7 +74,7 @@ RSpec.describe Bundler::Env do
 
     context "when there is a Gemfile and a lockfile and print_gemfile is true" do
       before do
-        gemfile "gem 'rack', '1.0.0'"
+        gemfile "source \"#{file_uri_for(gem_repo1)}\"; gem 'rack', '1.0.0'"
 
         lockfile <<-L
           GEM
@@ -82,6 +88,8 @@ RSpec.describe Bundler::Env do
           BUNDLED WITH
              1.10.0
         L
+
+        allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
       end
 
       let(:output) { described_class.report(:print_gemfile => true) }
@@ -105,6 +113,34 @@ RSpec.describe Bundler::Env do
       end
     end
 
+    context "when there's bundler config with credentials" do
+      before do
+        bundle "config set https://localgemserver.test/ user:pass"
+      end
+
+      let(:output) { described_class.report(:print_gemfile => true) }
+
+      it "prints the config with redacted values" do
+        expect(output).to include("https://localgemserver.test")
+        expect(output).to include("user:[REDACTED]")
+        expect(output).to_not include("user:pass")
+      end
+    end
+
+    context "when there's bundler config with OAuth token credentials" do
+      before do
+        bundle "config set https://localgemserver.test/ api_token:x-oauth-basic"
+      end
+
+      let(:output) { described_class.report(:print_gemfile => true) }
+
+      it "prints the config with redacted values" do
+        expect(output).to include("https://localgemserver.test")
+        expect(output).to include("[REDACTED]:x-oauth-basic")
+        expect(output).to_not include("api_token:x-oauth-basic")
+      end
+    end
+
     context "when Gemfile contains a gemspec and print_gemspecs is true" do
       let(:gemspec) do
         strip_whitespace(<<-GEMSPEC)
@@ -116,11 +152,13 @@ RSpec.describe Bundler::Env do
       end
 
       before do
-        gemfile("gemspec")
+        gemfile("source \"#{file_uri_for(gem_repo1)}\"; gemspec")
 
         File.open(bundled_app.join("foo.gemspec"), "wb") do |f|
           f.write(gemspec)
         end
+
+        allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
       end
 
       it "prints the gemspec" do
@@ -133,13 +171,15 @@ RSpec.describe Bundler::Env do
 
     context "when eval_gemfile is used" do
       it "prints all gemfiles" do
-        create_file "other/Gemfile-other", "gem 'rack'"
-        create_file "other/Gemfile", "eval_gemfile 'Gemfile-other'"
-        create_file "Gemfile-alt", <<-G
+        create_file bundled_app("other/Gemfile-other"), "gem 'rack'"
+        create_file bundled_app("other/Gemfile"), "eval_gemfile 'Gemfile-other'"
+        create_file bundled_app("Gemfile-alt"), <<-G
           source "#{file_uri_for(gem_repo1)}"
           eval_gemfile "other/Gemfile"
         G
-        gemfile "eval_gemfile #{File.expand_path("Gemfile-alt").dump}"
+        gemfile "eval_gemfile #{bundled_app("Gemfile-alt").to_s.dump}"
+        allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+        allow(Bundler::SharedHelpers).to receive(:pwd).and_return(bundled_app)
 
         output = described_class.report(:print_gemspecs => true)
         expect(output).to include(strip_whitespace(<<-ENV))
@@ -148,7 +188,7 @@ RSpec.describe Bundler::Env do
           ### Gemfile
 
           ```ruby
-          eval_gemfile #{File.expand_path("Gemfile-alt").dump}
+          eval_gemfile #{bundled_app("Gemfile-alt").to_s.dump}
           ```
 
           ### Gemfile-alt
@@ -173,7 +213,7 @@ RSpec.describe Bundler::Env do
           ### Gemfile.lock
 
           ```
-          <No #{bundled_app("Gemfile.lock")} found>
+          <No #{bundled_app_lock} found>
           ```
         ENV
       end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/fetcher/compact_index_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/fetcher/compact_index_spec.rb
@@ -1,5 +1,8 @@
 # frozen_string_literal: true
 
+# load CompactIndexClient upfront to prevent thread safety issues during parallel specs
+require "bundler/compact_index_client"
+
 RSpec.describe Bundler::Fetcher::CompactIndex do
   let(:downloader)  { double(:downloader) }
   let(:display_uri) { Bundler::URI("http://sampleuri.com") }
@@ -62,7 +65,7 @@ RSpec.describe Bundler::Fetcher::Compact
 
         context "when FIPS-mode is active" do
           before do
-            allow(OpenSSL::Digest::MD5).to receive(:digest).
+            allow(OpenSSL::Digest).to receive(:digest).with("MD5", "").
               and_raise(OpenSSL::Digest::DigestError)
           end
 
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/fetcher/downloader_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/fetcher/downloader_spec.rb
@@ -83,6 +83,11 @@ RSpec.describe Bundler::Fetcher::Downloa
           /Authentication is required for www.uri-to-fetch.com/)
       end
 
+      it "should raise a Bundler::Fetcher::AuthenticationRequiredError with advices" do
+        expect { subject.fetch(uri, options, counter) }.to raise_error(Bundler::Fetcher::AuthenticationRequiredError,
+          /`bundle config set --global www\.uri-to-fetch\.com username:password`.*`BUNDLE_WWW__URI___TO___FETCH__COM`/m)
+      end
+
       context "when the there are credentials provided in the request" do
         let(:uri) { Bundler::URI("http://user:password@www.uri-to-fetch.com") }
 
@@ -188,7 +193,7 @@ RSpec.describe Bundler::Fetcher::Downloa
         let(:message) { "undefined method 'undefined_method_call'" }
 
         it "should raise the original NoMethodError" do
-          expect { subject.request(uri, options) }.to raise_error(NoMethodError, "undefined method 'undefined_method_call'")
+          expect { subject.request(uri, options) }.to raise_error(NoMethodError, /undefined method 'undefined_method_call'/)
         end
       end
     end
@@ -226,16 +231,7 @@ RSpec.describe Bundler::Fetcher::Downloa
         end
       end
 
-      context "when error message is about getaddrinfo issues" do
-        let(:message) { "getaddrinfo: nodename nor servname provided for http://www.uri-to-fetch.com" }
-
-        it "should raise a Bundler::Fetcher::NetworkDownError" do
-          expect { subject.request(uri, options) }.to raise_error(Bundler::Fetcher::NetworkDownError,
-            /Could not reach host www.uri-to-fetch.com/)
-        end
-      end
-
-      context "when error message is about neither host down or getaddrinfo" do
+      context "when error message is not about host down" do
         let(:message) { "other error about network" }
 
         it "should raise a Bundler::HTTPError" do
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/fetcher/index_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/fetcher/index_spec.rb
@@ -1,5 +1,7 @@
 # frozen_string_literal: true
 
+require "rubygems/remote_fetcher"
+
 RSpec.describe Bundler::Fetcher::Index do
   let(:downloader)  { nil }
   let(:remote)      { nil }
@@ -17,100 +19,81 @@ RSpec.describe Bundler::Fetcher::Index d
   end
 
   context "error handling" do
-    shared_examples_for "the error is properly handled" do
-      let(:remote_uri) { Bundler::URI("http://remote-uri.org") }
-      before do
-        allow(subject).to receive(:remote_uri).and_return(remote_uri)
-      end
+    let(:remote_uri) { Bundler::URI("http://remote-uri.org") }
+    before do
+      allow(rubygems).to receive(:fetch_all_remote_specs) { raise Gem::RemoteFetcher::FetchError.new(error_message, display_uri) }
+      allow(subject).to receive(:remote_uri).and_return(remote_uri)
+    end
 
-      context "when certificate verify failed" do
-        let(:error_message) { "certificate verify failed" }
+    context "when certificate verify failed" do
+      let(:error_message) { "certificate verify failed" }
 
-        it "should raise a Bundler::Fetcher::CertificateFailureError" do
-          expect { subject.specs(gem_names) }.to raise_error(Bundler::Fetcher::CertificateFailureError,
-            %r{Could not verify the SSL certificate for http://sample_uri.com})
-        end
+      it "should raise a Bundler::Fetcher::CertificateFailureError" do
+        expect { subject.specs(gem_names) }.to raise_error(Bundler::Fetcher::CertificateFailureError,
+          %r{Could not verify the SSL certificate for http://sample_uri.com})
       end
+    end
 
-      context "when a 401 response occurs" do
-        let(:error_message) { "401" }
-
-        before do
-          allow(remote_uri).to receive(:userinfo).and_return(userinfo)
-        end
-
-        context "and there was userinfo" do
-          let(:userinfo) { double(:userinfo) }
+    context "when a 401 response occurs" do
+      let(:error_message) { "401" }
 
-          it "should raise a Bundler::Fetcher::BadAuthenticationError" do
-            expect { subject.specs(gem_names) }.to raise_error(Bundler::Fetcher::BadAuthenticationError,
-              %r{Bad username or password for http://remote-uri.org})
-          end
-        end
+      before do
+        allow(remote_uri).to receive(:userinfo).and_return(userinfo)
+      end
 
-        context "and there was no userinfo" do
-          let(:userinfo) { nil }
+      context "and there was userinfo" do
+        let(:userinfo) { double(:userinfo) }
 
-          it "should raise a Bundler::Fetcher::AuthenticationRequiredError" do
-            expect { subject.specs(gem_names) }.to raise_error(Bundler::Fetcher::AuthenticationRequiredError,
-              %r{Authentication is required for http://remote-uri.org})
-          end
+        it "should raise a Bundler::Fetcher::BadAuthenticationError" do
+          expect { subject.specs(gem_names) }.to raise_error(Bundler::Fetcher::BadAuthenticationError,
+            %r{Bad username or password for http://remote-uri.org})
         end
       end
 
-      context "when a 403 response occurs" do
-        let(:error_message) { "403" }
+      context "and there was no userinfo" do
+        let(:userinfo) { nil }
 
-        before do
-          allow(remote_uri).to receive(:userinfo).and_return(userinfo)
+        it "should raise a Bundler::Fetcher::AuthenticationRequiredError" do
+          expect { subject.specs(gem_names) }.to raise_error(Bundler::Fetcher::AuthenticationRequiredError,
+            %r{Authentication is required for http://remote-uri.org})
         end
+      end
+    end
 
-        context "and there was userinfo" do
-          let(:userinfo) { double(:userinfo) }
+    context "when a 403 response occurs" do
+      let(:error_message) { "403" }
 
-          it "should raise a Bundler::Fetcher::BadAuthenticationError" do
-            expect { subject.specs(gem_names) }.to raise_error(Bundler::Fetcher::BadAuthenticationError,
-              %r{Bad username or password for http://remote-uri.org})
-          end
-        end
+      before do
+        allow(remote_uri).to receive(:userinfo).and_return(userinfo)
+      end
 
-        context "and there was no userinfo" do
-          let(:userinfo) { nil }
+      context "and there was userinfo" do
+        let(:userinfo) { double(:userinfo) }
 
-          it "should raise a Bundler::Fetcher::AuthenticationRequiredError" do
-            expect { subject.specs(gem_names) }.to raise_error(Bundler::Fetcher::AuthenticationRequiredError,
-              %r{Authentication is required for http://remote-uri.org})
-          end
+        it "should raise a Bundler::Fetcher::BadAuthenticationError" do
+          expect { subject.specs(gem_names) }.to raise_error(Bundler::Fetcher::BadAuthenticationError,
+            %r{Bad username or password for http://remote-uri.org})
         end
       end
 
-      context "any other message is returned" do
-        let(:error_message) { "You get an error, you get an error!" }
-
-        before { allow(Bundler).to receive(:ui).and_return(double(:trace => nil)) }
+      context "and there was no userinfo" do
+        let(:userinfo) { nil }
 
-        it "should raise a Bundler::HTTPError" do
-          expect { subject.specs(gem_names) }.to raise_error(Bundler::HTTPError, "Could not fetch specs from http://sample_uri.com")
+        it "should raise a Bundler::Fetcher::AuthenticationRequiredError" do
+          expect { subject.specs(gem_names) }.to raise_error(Bundler::Fetcher::AuthenticationRequiredError,
+            %r{Authentication is required for http://remote-uri.org})
         end
       end
     end
 
-    context "when a Gem::RemoteFetcher::FetchError occurs" do
-      before { allow(rubygems).to receive(:fetch_all_remote_specs) { raise Gem::RemoteFetcher::FetchError.new(error_message, nil) } }
+    context "any other message is returned" do
+      let(:error_message) { "You get an error, you get an error!" }
 
-      it_behaves_like "the error is properly handled"
-    end
-
-    context "when a OpenSSL::SSL::SSLError occurs" do
-      before { allow(rubygems).to receive(:fetch_all_remote_specs) { raise OpenSSL::SSL::SSLError.new(error_message) } }
-
-      it_behaves_like "the error is properly handled"
-    end
-
-    context "when a Net::HTTPFatalError occurs" do
-      before { allow(rubygems).to receive(:fetch_all_remote_specs) { raise Net::HTTPFatalError.new(error_message, 404) } }
+      before { allow(Bundler).to receive(:ui).and_return(double(:trace => nil)) }
 
-      it_behaves_like "the error is properly handled"
+      it "should raise a Bundler::HTTPError" do
+        expect { subject.specs(gem_names) }.to raise_error(Bundler::HTTPError, "Could not fetch specs from http://sample_uri.com due to underlying error <You get an error, you get an error! (http://sample_uri.com)>")
+      end
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/fetcher_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/fetcher_spec.rb
@@ -26,7 +26,7 @@ RSpec.describe Bundler::Fetcher do
     context "when Gem.configuration specifies http_proxy " do
       let(:proxy) { "http://proxy-example2.com" }
       before do
-        allow(Bundler.rubygems.configuration).to receive(:[]).with(:http_proxy).and_return(proxy)
+        allow(Gem.configuration).to receive(:[]).with(:http_proxy).and_return(proxy)
       end
       it "consider Gem.configuration when determine proxy" do
         expect(fetcher.http_proxy).to match("http://proxy-example2.com")
@@ -113,7 +113,7 @@ RSpec.describe Bundler::Fetcher do
 
     context "when gem ssl configuration is set" do
       before do
-        allow(Bundler.rubygems.configuration).to receive_messages(
+        allow(Gem.configuration).to receive_messages(
           :http_proxy => nil,
           :ssl_client_cert => "cert",
           :ssl_ca_cert => "ca"
@@ -150,9 +150,10 @@ RSpec.describe Bundler::Fetcher do
       end
 
       it "from many CI" do
-        with_env_vars("TRAVIS" => "foo", "CI_NAME" => "my_ci") do
+        with_env_vars("TRAVIS" => "foo", "GITLAB_CI" => "gitlab", "CI_NAME" => "my_ci") do
           ci_part = fetcher.user_agent.split(" ").find {|x| x.start_with?("ci/") }
           expect(ci_part).to match("travis")
+          expect(ci_part).to match("gitlab")
           expect(ci_part).to match("my_ci")
         end
       end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/friendly_errors_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/friendly_errors_spec.rb
@@ -7,13 +7,13 @@ require "cgi"
 RSpec.describe Bundler, "friendly errors" do
   context "with invalid YAML in .gemrc" do
     before do
-      File.open(Gem.configuration.config_file_name, "w") do |f|
+      File.open(home(".gemrc"), "w") do |f|
         f.write "invalid: yaml: hah"
       end
     end
 
     after do
-      FileUtils.rm(Gem.configuration.config_file_name)
+      FileUtils.rm(home(".gemrc"))
     end
 
     it "reports a relevant friendly error message" do
@@ -25,7 +25,6 @@ RSpec.describe Bundler, "friendly errors
       bundle :install, :env => { "DEBUG" => "true" }
 
       expect(err).to include("Failed to load #{home(".gemrc")}")
-      expect(exitstatus).to eq(0) if exitstatus
     end
   end
 
@@ -105,7 +104,6 @@ RSpec.describe Bundler, "friendly errors
         expect(Bundler.ui).to receive(:error).with(error.message, :wrap => true)
         Bundler::FriendlyErrors.log_error(error)
       end
-      it_behaves_like "Bundler.ui receive trace", Bundler::BundlerError.new
     end
 
     context "Thor::Error" do
@@ -115,18 +113,12 @@ RSpec.describe Bundler, "friendly errors
     context "LoadError" do
       let(:error) { LoadError.new("cannot load such file -- openssl") }
 
-      it "Bundler.ui receive error" do
-        expect(Bundler.ui).to receive(:error).with("\nCould not load OpenSSL.")
-        Bundler::FriendlyErrors.log_error(error)
-      end
-
-      it "Bundler.ui receive warn" do
-        expect(Bundler.ui).to receive(:warn).with(any_args, :wrap => true)
-        Bundler::FriendlyErrors.log_error(error)
+      before do
+        allow(error).to receive(:backtrace).and_return(["backtrace"])
       end
 
-      it "Bundler.ui receive trace" do
-        expect(Bundler.ui).to receive(:trace).with(error)
+      it "Bundler.ui receive error" do
+        expect(Bundler.ui).to receive(:error).with("\nCould not load OpenSSL. LoadError: cannot load such file -- openssl\nbacktrace")
         Bundler::FriendlyErrors.log_error(error)
       end
     end
@@ -200,9 +192,9 @@ RSpec.describe Bundler, "friendly errors
 
   describe "#request_issue_report_for" do
     it "calls relevant methods for Bundler.ui" do
-      expect(Bundler.ui).to receive(:info)
-      expect(Bundler.ui).to receive(:error)
-      expect(Bundler.ui).to receive(:warn)
+      expect(Bundler.ui).not_to receive(:info)
+      expect(Bundler.ui).to receive(:error).exactly(3).times
+      expect(Bundler.ui).not_to receive(:warn)
       Bundler::FriendlyErrors.request_issue_report_for(StandardError.new)
     end
 
@@ -221,7 +213,7 @@ RSpec.describe Bundler, "friendly errors
     it "generates a search URL for the exception message" do
       exception = Exception.new("Exception message")
 
-      expect(Bundler::FriendlyErrors.issues_url(exception)).to eq("https://github.com/bundler/bundler/search?q=Exception+message&type=Issues")
+      expect(Bundler::FriendlyErrors.issues_url(exception)).to eq("https://github.com/rubygems/rubygems/search?q=Exception+message&type=Issues")
     end
 
     it "generates a search URL for only the first line of a multi-line exception message" do
@@ -230,7 +222,7 @@ First line of the exception message
 Second line of the exception message
 END
 
-      expect(Bundler::FriendlyErrors.issues_url(exception)).to eq("https://github.com/bundler/bundler/search?q=First+line+of+the+exception+message&type=Issues")
+      expect(Bundler::FriendlyErrors.issues_url(exception)).to eq("https://github.com/rubygems/rubygems/search?q=First+line+of+the+exception+message&type=Issues")
     end
 
     it "generates the url without colons" do
@@ -239,7 +231,7 @@ Exception ::: with ::: colons :::
 END
       issues_url = Bundler::FriendlyErrors.issues_url(exception)
       expect(issues_url).not_to include("%3A")
-      expect(issues_url).to eq("https://github.com/bundler/bundler/search?q=#{CGI.escape("Exception     with     colons    ")}&type=Issues")
+      expect(issues_url).to eq("https://github.com/rubygems/rubygems/search?q=#{CGI.escape("Exception     with     colons    ")}&type=Issues")
     end
 
     it "removes information after - for Errono::EACCES" do
@@ -249,7 +241,7 @@ END
       allow(exception).to receive(:is_a?).with(Errno).and_return(true)
       issues_url = Bundler::FriendlyErrors.issues_url(exception)
       expect(issues_url).not_to include("/Users/foo/bar")
-      expect(issues_url).to eq("https://github.com/bundler/bundler/search?q=#{CGI.escape("Errno  EACCES  Permission denied @ dir_s_mkdir ")}&type=Issues")
+      expect(issues_url).to eq("https://github.com/rubygems/rubygems/search?q=#{CGI.escape("Errno  EACCES  Permission denied @ dir_s_mkdir ")}&type=Issues")
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/gem_helper_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/gem_helper_spec.rb
@@ -9,7 +9,9 @@ RSpec.describe Bundler::GemHelper do
   let(:app_gemspec_path) { app_path.join("#{app_name}.gemspec") }
 
   before(:each) do
-    global_config "BUNDLE_GEM__MIT" => "false", "BUNDLE_GEM__TEST" => "false", "BUNDLE_GEM__COC" => "false"
+    global_config "BUNDLE_GEM__MIT" => "false", "BUNDLE_GEM__TEST" => "false", "BUNDLE_GEM__COC" => "false", "BUNDLE_GEM__LINTER" => "false",
+                  "BUNDLE_GEM__CI" => "false", "BUNDLE_GEM__CHANGELOG" => "false"
+    sys_exec("git config --global init.defaultBranch main")
     bundle "gem #{app_name}"
     prepare_gemspec(app_gemspec_path)
   end
@@ -60,10 +62,20 @@ RSpec.describe Bundler::GemHelper do
       mock_confirm_message message
     end
 
+    def mock_checksum_message(name, version)
+      message = "#{name} #{version} checksum written to checksums/#{name}-#{version}.gem.sha512."
+      mock_confirm_message message
+    end
+
+    def sha512_hexdigest(path)
+      Digest::SHA512.file(path).hexdigest
+    end
+
     subject! { Bundler::GemHelper.new(app_path) }
     let(:app_version) { "0.1.0" }
     let(:app_gem_dir) { app_path.join("pkg") }
     let(:app_gem_path) { app_gem_dir.join("#{app_name}-#{app_version}.gem") }
+    let(:app_sha_path) { app_path.join("checksums", "#{app_name}-#{app_version}.gem.sha512") }
     let(:app_gemspec_content) { File.read(app_gemspec_path) }
 
     before(:each) do
@@ -97,6 +109,7 @@ RSpec.describe Bundler::GemHelper do
         context "before installation" do
           it "raises an error with appropriate message" do
             task_names.each do |name|
+              skip "Rake::FileTask '#{name}' exists" if File.exist?(name)
               expect { Rake.application[name] }.
                 to raise_error(/^Don't know how to build task '#{name}'/)
             end
@@ -138,6 +151,68 @@ RSpec.describe Bundler::GemHelper do
           expect(app_gem_path).to exist
         end
       end
+
+      context "when building in the current working directory" do
+        it "creates .gem file" do
+          mock_build_message app_name, app_version
+          Dir.chdir app_path do
+            Bundler::GemHelper.new.build_gem
+          end
+          expect(app_gem_path).to exist
+        end
+      end
+
+      context "when building in a location relative to the current working directory" do
+        it "creates .gem file" do
+          mock_build_message app_name, app_version
+          Dir.chdir File.dirname(app_path) do
+            Bundler::GemHelper.new(File.basename(app_path)).build_gem
+          end
+          expect(app_gem_path).to exist
+        end
+      end
+    end
+
+    describe "#build_checksum" do
+      it "calculates SHA512 of the content" do
+        FileUtils.mkdir_p(app_gem_dir)
+        File.write(app_gem_path, "")
+        mock_checksum_message app_name, app_version
+        subject.build_checksum(app_gem_path)
+        expect(File.read(app_sha_path).chomp).to eql(Digest::SHA512.hexdigest(""))
+      end
+
+      context "when build was successful" do
+        it "creates .sha512 file" do
+          mock_build_message app_name, app_version
+          mock_checksum_message app_name, app_version
+          subject.build_checksum
+          expect(app_sha_path).to exist
+          expect(File.read(app_sha_path).chomp).to eql(sha512_hexdigest(app_gem_path))
+        end
+      end
+      context "when building in the current working directory" do
+        it "creates a .sha512 file" do
+          mock_build_message app_name, app_version
+          mock_checksum_message app_name, app_version
+          Dir.chdir app_path do
+            Bundler::GemHelper.new.build_checksum
+          end
+          expect(app_sha_path).to exist
+          expect(File.read(app_sha_path).chomp).to eql(sha512_hexdigest(app_gem_path))
+        end
+      end
+      context "when building in a location relative to the current working directory" do
+        it "creates a .sha512 file" do
+          mock_build_message app_name, app_version
+          mock_checksum_message app_name, app_version
+          Dir.chdir File.dirname(app_path) do
+            Bundler::GemHelper.new(File.basename(app_path)).build_checksum
+          end
+          expect(app_sha_path).to exist
+          expect(File.read(app_sha_path).chomp).to eql(sha512_hexdigest(app_gem_path))
+        end
+      end
     end
 
     describe "#install_gem" do
@@ -147,7 +222,7 @@ RSpec.describe Bundler::GemHelper do
           mock_confirm_message "#{app_name} (#{app_version}) installed."
           subject.install_gem(nil, :local)
           expect(app_gem_path).to exist
-          gem_command! :list
+          gem_command :list
           expect(out).to include("#{app_name} (#{app_version})")
         end
       end
@@ -160,7 +235,7 @@ RSpec.describe Bundler::GemHelper do
             FileUtils.touch app_gem_path
             app_gem_path
           end
-          expect { subject.install_gem }.to raise_error(/Couldn't install gem/)
+          expect { subject.install_gem }.to raise_error(/Running `#{gem_bin} install #{app_gem_path}` failed/)
         end
       end
     end
@@ -178,13 +253,11 @@ RSpec.describe Bundler::GemHelper do
       end
 
       before do
-        Dir.chdir(app_path) do
-          `git init`
-          `git config user.email "you@example.com"`
-          `git config user.name "name"`
-          `git config commit.gpgsign false`
-          `git config push.default simple`
-        end
+        sys_exec("git init", :dir => app_path)
+        sys_exec("git config user.email \"you@example.com\"", :dir => app_path)
+        sys_exec("git config user.name \"name\"", :dir => app_path)
+        sys_exec("git config commit.gpgsign false", :dir => app_path)
+        sys_exec("git config push.default simple", :dir => app_path)
 
         # silence messages
         allow(Bundler.ui).to receive(:confirm)
@@ -198,13 +271,13 @@ RSpec.describe Bundler::GemHelper do
         end
 
         it "when there are uncommitted files" do
-          Dir.chdir(app_path) { `git add .` }
+          sys_exec("git add .", :dir => app_path)
           expect { Rake.application["release"].invoke }.
             to raise_error("There are files that need to be committed first.")
         end
 
         it "when there is no git remote" do
-          Dir.chdir(app_path) { `git commit -a -m "initial commit"` }
+          sys_exec("git commit -a -m \"initial commit\"", :dir => app_path)
           expect { Rake.application["release"].invoke }.to raise_error(RuntimeError)
         end
       end
@@ -213,19 +286,17 @@ RSpec.describe Bundler::GemHelper do
         let(:repo) { build_git("foo", :bare => true) }
 
         before do
-          Dir.chdir(app_path) do
-            sys_exec("git remote add origin #{file_uri_for(repo.path)}")
-            sys_exec('git commit -a -m "initial commit"')
-          end
+          sys_exec("git remote add origin #{file_uri_for(repo.path)}", :dir => app_path)
+          sys_exec('git commit -a -m "initial commit"', :dir => app_path)
         end
 
         context "on releasing" do
           before do
             mock_build_message app_name, app_version
             mock_confirm_message "Tagged v#{app_version}."
-            mock_confirm_message "Pushed git commits and tags."
+            mock_confirm_message "Pushed git commits and release tag."
 
-            Dir.chdir(app_path) { sys_exec("git push -u origin master") }
+            sys_exec("git push -u origin main", :dir => app_path)
           end
 
           it "calls rubygem_push with proper arguments" do
@@ -235,7 +306,43 @@ RSpec.describe Bundler::GemHelper do
           end
 
           it "uses Kernel.system" do
-            expect(Kernel).to receive(:system).with(gem_bin, "push", app_gem_path.to_s, "--host", "http://example.org").and_return(true)
+            cmd = gem_bin.shellsplit
+            expect(Kernel).to receive(:system).with(*cmd, "push", app_gem_path.to_s, "--host", "http://example.org").and_return(true)
+
+            Rake.application["release"].invoke
+          end
+
+          it "also works when releasing from an ambiguous reference" do
+            # Create a branch with the same name as the tag
+            sys_exec("git checkout -b v#{app_version}", :dir => app_path)
+            sys_exec("git push -u origin v#{app_version}", :dir => app_path)
+
+            expect(subject).to receive(:rubygem_push).with(app_gem_path.to_s)
+
+            Rake.application["release"].invoke
+          end
+
+          it "also works with releasing from a branch not yet pushed" do
+            sys_exec("git checkout -b module_function", :dir => app_path)
+
+            expect(subject).to receive(:rubygem_push).with(app_gem_path.to_s)
+
+            Rake.application["release"].invoke
+          end
+        end
+
+        context "on releasing with a custom tag prefix" do
+          before do
+            Bundler::GemHelper.tag_prefix = "foo-"
+            mock_build_message app_name, app_version
+            mock_confirm_message "Pushed git commits and release tag."
+
+            sys_exec("git push -u origin main", :dir => app_path)
+            expect(subject).to receive(:rubygem_push).with(app_gem_path.to_s)
+          end
+
+          it "prepends the custom prefix to the tag" do
+            mock_confirm_message "Tagged foo-v#{app_version}."
 
             Rake.application["release"].invoke
           end
@@ -246,9 +353,7 @@ RSpec.describe Bundler::GemHelper do
           mock_confirm_message "Tag v#{app_version} has already been created."
           expect(subject).to receive(:rubygem_push).with(app_gem_path.to_s)
 
-          Dir.chdir(app_path) do
-            `git tag -a -m \"Version #{app_version}\" v#{app_version}`
-          end
+          sys_exec("git tag -a -m \"Version #{app_version}\" v#{app_version}", :dir => app_path)
 
           Rake.application["release"].invoke
         end
@@ -269,12 +374,10 @@ RSpec.describe Bundler::GemHelper do
       end
 
       before do
-        Dir.chdir(app_path) do
-          `git init`
-          `git config user.email "you@example.com"`
-          `git config user.name "name"`
-          `git config push.default simple`
-        end
+        sys_exec("git init", :dir => app_path)
+        sys_exec("git config user.email \"you@example.com\"", :dir => app_path)
+        sys_exec("git config user.name \"name\"", :dir => app_path)
+        sys_exec("git config push.gpgsign simple", :dir => app_path)
 
         # silence messages
         allow(Bundler.ui).to receive(:confirm)
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/gem_version_promoter_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/gem_version_promoter_spec.rb
@@ -28,7 +28,7 @@ RSpec.describe Bundler::GemVersionPromot
 
     def build_spec_groups(name, versions)
       versions.map do |v|
-        Bundler::Resolver::SpecGroup.new(build_spec(name, v))
+        Bundler::Resolver::SpecGroup.create_for({ Gem::Platform::RUBY => build_spec(name, v) }, [Gem::Platform::RUBY], Gem::Platform::RUBY)
       end
     end
 
@@ -166,14 +166,5 @@ RSpec.describe Bundler::GemVersionPromot
         end
       end
     end
-
-    context "debug output" do
-      it "should not kerblooie on its own debug output" do
-        gvp = unlocking(:level => :patch)
-        dep = Bundler::DepProxy.new(dep("foo", "1.2.0").first, "ruby")
-        result = gvp.send(:debug_format_result, dep, build_spec_groups("foo", %w[1.2.0 1.3.0]))
-        expect(result.class).to eq Array
-      end
-    end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/installer/gem_installer_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/installer/gem_installer_spec.rb
@@ -3,7 +3,8 @@
 require "bundler/installer/gem_installer"
 
 RSpec.describe Bundler::GemInstaller do
-  let(:installer) { instance_double("Installer") }
+  let(:definition) { instance_double("Definition", :locked_gems => nil) }
+  let(:installer) { instance_double("Installer", :definition => definition) }
   let(:spec_source) { instance_double("SpecSource") }
   let(:spec) { instance_double("Specification", :name => "dummy", :version => "0.0.1", :loaded_from => "dummy", :source => spec_source) }
 
@@ -11,7 +12,7 @@ RSpec.describe Bundler::GemInstaller do
 
   context "spec_settings is nil" do
     it "invokes install method with empty build_args" do
-      allow(spec_source).to receive(:install).with(spec, :force => false, :ensure_builtin_gems_cached => false, :build_args => [])
+      allow(spec_source).to receive(:install).with(spec, :force => false, :ensure_builtin_gems_cached => false, :build_args => [], :previous_spec => nil)
       subject.install_from_spec
     end
   end
@@ -22,7 +23,7 @@ RSpec.describe Bundler::GemInstaller do
       allow(Bundler.settings).to receive(:[]).with(:inline)
       allow(Bundler.settings).to receive(:[]).with(:forget_cli_options)
       allow(Bundler.settings).to receive(:[]).with("build.dummy").and_return("--with-dummy-config=dummy")
-      expect(spec_source).to receive(:install).with(spec, :force => false, :ensure_builtin_gems_cached => false, :build_args => ["--with-dummy-config=dummy"])
+      expect(spec_source).to receive(:install).with(spec, :force => false, :ensure_builtin_gems_cached => false, :build_args => ["--with-dummy-config=dummy"], :previous_spec => nil)
       subject.install_from_spec
     end
   end
@@ -33,7 +34,13 @@ RSpec.describe Bundler::GemInstaller do
       allow(Bundler.settings).to receive(:[]).with(:inline)
       allow(Bundler.settings).to receive(:[]).with(:forget_cli_options)
       allow(Bundler.settings).to receive(:[]).with("build.dummy").and_return("--with-dummy-config=dummy --with-another-dummy-config")
-      expect(spec_source).to receive(:install).with(spec, :force => false, :ensure_builtin_gems_cached => false, :build_args => ["--with-dummy-config=dummy", "--with-another-dummy-config"])
+      expect(spec_source).to receive(:install).with(
+        spec,
+        :force => false,
+        :ensure_builtin_gems_cached => false,
+        :build_args => ["--with-dummy-config=dummy", "--with-another-dummy-config"],
+        :previous_spec => nil
+      )
       subject.install_from_spec
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/installer/parallel_installer_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/installer/parallel_installer_spec.rb
@@ -44,4 +44,37 @@ The missing gems are:
       end
     end
   end
+
+  context "when the spec set is not a valid resolution" do
+    let(:all_specs) do
+      [
+        build_spec("cucumber", "4.1.0") {|s| s.runtime "diff-lcs", "< 1.4" },
+        build_spec("diff-lcs", "1.4.4"),
+      ].flatten
+    end
+
+    it "prints a warning" do
+      expect(Bundler.ui).to receive(:warn).with(<<-W.strip)
+Your lockfile doesn't include a valid resolution.
+You can fix this by regenerating your lockfile or trying to manually editing the bad locked gems to a version that satisfies all dependencies.
+The unmet dependencies are:
+* diff-lcs (< 1.4), depended upon cucumber-4.1.0, unsatisfied by diff-lcs-1.4.4
+      W
+      subject.check_for_unmet_dependencies
+    end
+  end
+
+  context "when the spec set is a valid resolution" do
+    let(:all_specs) do
+      [
+        build_spec("cucumber", "4.1.0") {|s| s.runtime "diff-lcs", "< 1.4" },
+        build_spec("diff-lcs", "1.3"),
+      ].flatten
+    end
+
+    it "doesn't print a warning" do
+      expect(Bundler.ui).not_to receive(:warn)
+      subject.check_for_unmet_dependencies
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/installer/spec_installation_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/installer/spec_installation_spec.rb
@@ -8,6 +8,10 @@ RSpec.describe Bundler::ParallelInstalle
     def a_spec.name
       "I like tests"
     end
+
+    def a_spec.full_name
+      "I really like tests"
+    end
     a_spec
   end
 
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/mirror_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/mirror_spec.rb
@@ -305,6 +305,8 @@ RSpec.describe Bundler::Settings::TCPSoc
     end
 
     it "probes the server correctly" do
+      skip "obscure error" if Gem.win_platform?
+
       with_server_and_mirror do |server, mirror|
         expect(server.closed?).to be_falsey
         expect(probe.replies?(mirror)).to be_truthy
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/plugin/api/source_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/plugin/api/source_spec.rb
@@ -79,4 +79,10 @@ RSpec.describe Bundler::Plugin::API::Sou
       end
     end
   end
+
+  describe "to_s" do
+    it "returns the string with type and uri" do
+      expect(source.to_s).to eq("plugin source for spec_type with uri uri://to/test")
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/plugin/dsl_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/plugin/dsl_spec.rb
@@ -28,7 +28,7 @@ RSpec.describe Bundler::Plugin::DSL do
       expect(dsl.inferred_plugins).to eq(["bundler-source-news"])
     end
 
-    it "registers a source type plugin only once for multiple declataions" do
+    it "registers a source type plugin only once for multiple declarations" do
       expect(dsl).to receive(:plugin).with("bundler-source-news").and_call_original.once
 
       dsl.source("some_random_url", :type => "news") {}
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/plugin/index_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/plugin/index_spec.rb
@@ -4,7 +4,8 @@ RSpec.describe Bundler::Plugin::Index do
   Index = Bundler::Plugin::Index
 
   before do
-    gemfile ""
+    allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+    gemfile "source \"#{file_uri_for(gem_repo1)}\""
     path = lib_path(plugin_name)
     index.register_plugin("new-plugin", path.to_s, [path.join("lib").to_s], commands, sources, hooks)
   end
@@ -21,7 +22,7 @@ RSpec.describe Bundler::Plugin::Index do
       expect(index.plugin_path(plugin_name)).to eq(lib_path(plugin_name))
     end
 
-    it "load_paths is available for retrival" do
+    it "load_paths is available for retrieval" do
       expect(index.load_paths(plugin_name)).to eq([lib_path(plugin_name).join("lib").to_s])
     end
 
@@ -97,7 +98,13 @@ RSpec.describe Bundler::Plugin::Index do
       expect(index.hook_plugins("after-bar")).to eq([plugin_name])
     end
 
-    context "that are not registered", :focused do
+    it "is gone after unregistration" do
+      expect(index.index_file.read).to include("after-bar:\n  - \"new-plugin\"\n")
+      index.unregister_plugin(plugin_name)
+      expect(index.index_file.read).to_not include("after-bar:\n  - \n")
+    end
+
+    context "that are not registered" do
       let(:file) { double("index-file") }
 
       before do
@@ -117,11 +124,11 @@ RSpec.describe Bundler::Plugin::Index do
 
   describe "global index" do
     before do
-      Dir.chdir(tmp) do
-        Bundler::Plugin.reset!
-        path = lib_path("gplugin")
-        index.register_plugin("gplugin", path.to_s, [path.join("lib").to_s], [], ["glb_source"], [])
-      end
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(nil)
+
+      Bundler::Plugin.reset!
+      path = lib_path("gplugin")
+      index.register_plugin("gplugin", path.to_s, [path.join("lib").to_s], [], ["glb_source"], [])
     end
 
     it "skips sources" do
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/plugin/installer_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/plugin/installer_spec.rb
@@ -7,7 +7,7 @@ RSpec.describe Bundler::Plugin::Installe
     it "uses Gem.sources when non of the source is provided" do
       sources = double(:sources)
       Bundler.settings # initialize it before we have to touch rubygems.ext_lock
-      allow(Bundler).to receive_message_chain("rubygems.sources") { sources }
+      allow(Gem).to receive(:sources) { sources }
 
       allow(installer).to receive(:install_rubygems).
         with("new-plugin", [">= 0"], sources).once
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/plugin_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/plugin_spec.rb
@@ -1,7 +1,5 @@
 # frozen_string_literal: true
 
-require_relative "../support/streams"
-
 RSpec.describe Bundler::Plugin do
   Plugin = Bundler::Plugin
 
@@ -67,6 +65,8 @@ RSpec.describe Bundler::Plugin do
     end
 
     it "passes the name and options to installer" do
+      allow(index).to receive(:installed?).
+        with("new-plugin")
       allow(installer).to receive(:install).with(["new-plugin"], opts) do
         { "new-plugin" => spec }
       end.once
@@ -75,6 +75,8 @@ RSpec.describe Bundler::Plugin do
     end
 
     it "validates the installed plugin" do
+      allow(index).to receive(:installed?).
+        with("new-plugin")
       allow(subject).
         to receive(:validate_plugin!).with(lib_path("new-plugin")).once
 
@@ -82,6 +84,8 @@ RSpec.describe Bundler::Plugin do
     end
 
     it "registers the plugin with index" do
+      allow(index).to receive(:installed?).
+        with("new-plugin")
       allow(index).to receive(:register_plugin).
         with("new-plugin", lib_path("new-plugin").to_s, [lib_path("new-plugin").join("lib").to_s], []).once
       subject.install ["new-plugin"], opts
@@ -98,6 +102,7 @@ RSpec.describe Bundler::Plugin do
         end.once
 
         allow(subject).to receive(:validate_plugin!).twice
+        allow(index).to receive(:installed?).twice
         allow(index).to receive(:register_plugin).twice
         subject.install ["new-plugin", "another-plugin"], opts
       end
@@ -107,11 +112,12 @@ RSpec.describe Bundler::Plugin do
   describe "evaluate gemfile for plugins" do
     let(:definition) { double("definition") }
     let(:builder) { double("builder") }
-    let(:gemfile) { bundled_app("Gemfile") }
+    let(:gemfile) { bundled_app_gemfile }
 
     before do
       allow(Plugin::DSL).to receive(:new) { builder }
       allow(builder).to receive(:eval_gemfile).with(gemfile)
+      allow(builder).to receive(:check_primary_source_safety)
       allow(builder).to receive(:to_definition) { definition }
       allow(builder).to receive(:inferred_plugins) { [] }
     end
@@ -237,7 +243,7 @@ RSpec.describe Bundler::Plugin do
   describe "#root" do
     context "in app dir" do
       before do
-        gemfile ""
+        allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
       end
 
       it "returns plugin dir in app .bundle path" do
@@ -246,8 +252,11 @@ RSpec.describe Bundler::Plugin do
     end
 
     context "outside app dir" do
+      before do
+        allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(nil)
+      end
+
       it "returns plugin dir in global bundle path" do
-        Dir.chdir tmp
         expect(subject.root).to eq(home.join(".bundle/plugin"))
       end
     end
@@ -271,12 +280,12 @@ RSpec.describe Bundler::Plugin do
       end
 
       Bundler::Plugin::Events.send(:reset)
-      Bundler::Plugin::Events.send(:define, :EVENT_1, "event-1")
-      Bundler::Plugin::Events.send(:define, :EVENT_2, "event-2")
+      Bundler::Plugin::Events.send(:define, :EVENT1, "event-1")
+      Bundler::Plugin::Events.send(:define, :EVENT2, "event-2")
 
-      allow(index).to receive(:hook_plugins).with(Bundler::Plugin::Events::EVENT_1).
-        and_return(["foo-plugin"])
-      allow(index).to receive(:hook_plugins).with(Bundler::Plugin::Events::EVENT_2).
+      allow(index).to receive(:hook_plugins).with(Bundler::Plugin::Events::EVENT1).
+        and_return(["foo-plugin", "", nil])
+      allow(index).to receive(:hook_plugins).with(Bundler::Plugin::Events::EVENT2).
         and_return(["foo-plugin"])
       allow(index).to receive(:plugin_path).with("foo-plugin").and_return(path)
       allow(index).to receive(:load_paths).with("foo-plugin").and_return([])
@@ -293,41 +302,35 @@ RSpec.describe Bundler::Plugin do
     end
 
     it "executes the hook" do
-      out = capture(:stdout) do
-        Plugin.hook(Bundler::Plugin::Events::EVENT_1)
-      end.strip
-
-      expect(out).to eq("hook for event 1")
+      expect do
+        Plugin.hook(Bundler::Plugin::Events::EVENT1)
+      end.to output("hook for event 1\n").to_stdout
     end
 
     context "single plugin declaring more than one hook" do
       let(:code) { <<-RUBY }
-        Bundler::Plugin::API.hook(Bundler::Plugin::Events::EVENT_1) {}
-        Bundler::Plugin::API.hook(Bundler::Plugin::Events::EVENT_2) {}
+        Bundler::Plugin::API.hook(Bundler::Plugin::Events::EVENT1) {}
+        Bundler::Plugin::API.hook(Bundler::Plugin::Events::EVENT2) {}
         puts "loaded"
       RUBY
 
       it "evals plugins.rb once" do
-        out = capture(:stdout) do
-          Plugin.hook(Bundler::Plugin::Events::EVENT_1)
-          Plugin.hook(Bundler::Plugin::Events::EVENT_2)
-        end.strip
-
-        expect(out).to eq("loaded")
+        expect do
+          Plugin.hook(Bundler::Plugin::Events::EVENT1)
+          Plugin.hook(Bundler::Plugin::Events::EVENT2)
+        end.to output("loaded\n").to_stdout
       end
     end
 
     context "a block is passed" do
       let(:code) { <<-RUBY }
-        Bundler::Plugin::API.hook(Bundler::Plugin::Events::EVENT_1) { |&blk| blk.call }
+        Bundler::Plugin::API.hook(Bundler::Plugin::Events::EVENT1) { |&blk| blk.call }
       RUBY
 
       it "is passed to the hook" do
-        out = capture(:stdout) do
-          Plugin.hook(Bundler::Plugin::Events::EVENT_1) { puts "win" }
-        end.strip
-
-        expect(out).to eq("win")
+        expect do
+          Plugin.hook(Bundler::Plugin::Events::EVENT1) { puts "win" }
+        end.to output("win\n").to_stdout
       end
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/psyched_yaml_spec.rb
+++ /dev/null
@@ -1,9 +0,0 @@
-# frozen_string_literal: true
-
-require "bundler/psyched_yaml"
-
-RSpec.describe "Bundler::YamlLibrarySyntaxError" do
-  it "is raised on YAML parse errors" do
-    expect { YAML.parse "{foo" }.to raise_error(Bundler::YamlLibrarySyntaxError)
-  end
-end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/ruby_version_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/ruby_version_spec.rb
@@ -427,9 +427,8 @@ RSpec.describe "Bundler::RubyVersion and
       end
 
       describe "#version" do
-        it "should return a copy of the value of RUBY_VERSION" do
-          expect(subject.versions).to eq([RUBY_VERSION])
-          expect(subject.versions.first).to_not be(RUBY_VERSION)
+        it "should return the value of Gem.ruby_version as a string" do
+          expect(subject.versions).to eq([Gem.ruby_version.to_s])
         end
       end
 
@@ -446,13 +445,12 @@ RSpec.describe "Bundler::RubyVersion and
       describe "#engine_version" do
         context "engine is ruby" do
           before do
-            stub_const("RUBY_ENGINE_VERSION", "2.2.4")
+            allow(Gem).to receive(:ruby_version).and_return(Gem::Version.new("2.2.4"))
             stub_const("RUBY_ENGINE", "ruby")
           end
 
-          it "should return a copy of the value of RUBY_ENGINE_VERSION" do
+          it "should return the value of Gem.ruby_version as a string" do
             expect(bundler_system_ruby_version.engine_versions).to eq(["2.2.4"])
-            expect(bundler_system_ruby_version.engine_versions.first).to_not be(RUBY_ENGINE_VERSION)
           end
         end
 
@@ -498,31 +496,5 @@ RSpec.describe "Bundler::RubyVersion and
         end
       end
     end
-
-    describe "#to_gem_version_with_patchlevel" do
-      shared_examples_for "the patchlevel is omitted" do
-        it "does not include a patch level" do
-          expect(subject.to_gem_version_with_patchlevel.to_s).to eq(version)
-        end
-      end
-
-      context "with nil patch number" do
-        let(:patchlevel) { nil }
-
-        it_behaves_like "the patchlevel is omitted"
-      end
-
-      context "with negative patch number" do
-        let(:patchlevel) { -1 }
-
-        it_behaves_like "the patchlevel is omitted"
-      end
-
-      context "with a valid patch number" do
-        it "uses the specified patchlevel as patchlevel" do
-          expect(subject.to_gem_version_with_patchlevel.to_s).to eq("#{version}.#{patchlevel}")
-        end
-      end
-    end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/rubygems_integration_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/rubygems_integration_spec.rb
@@ -34,21 +34,12 @@ RSpec.describe Bundler::RubygemsIntegrat
     end
   end
 
-  describe "#configuration" do
-    it "handles Gem::SystemExitException errors" do
-      allow(Gem).to receive(:configuration) { raise Gem::SystemExitException.new(1) }
-      expect { Bundler.rubygems.configuration }.to raise_error(Gem::SystemExitException)
-    end
-  end
-
   describe "#download_gem" do
     let(:bundler_retry) { double(Bundler::Retry) }
-    let(:retry) { double("Bundler::Retry") }
-    let(:uri) {  Bundler::URI.parse("https://foo.bar") }
-    let(:path) { Gem.path.first }
+    let(:uri) { Bundler::URI.parse("https://foo.bar") }
+    let(:cache_dir) { "#{Gem.path.first}/cache" }
     let(:spec) do
-      spec = Bundler::RemoteSpecification.new("Foo", Gem::Version.new("2.5.2"),
-        Gem::Platform::RUBY, nil)
+      spec = Gem::Specification.new("Foo", Gem::Version.new("2.5.2"))
       spec.remote = Bundler::Source::Rubygems::Remote.new(uri.to_s)
       spec
     end
@@ -56,13 +47,13 @@ RSpec.describe Bundler::RubygemsIntegrat
 
     it "successfully downloads gem with retries" do
       expect(Bundler.rubygems).to receive(:gem_remote_fetcher).and_return(fetcher)
-      expect(fetcher).to receive(:headers=).with("X-Gemfile-Source" => "https://foo.bar")
+      expect(fetcher).to receive(:headers=).with({ "X-Gemfile-Source" => "https://foo.bar" })
       expect(Bundler::Retry).to receive(:new).with("download gem from #{uri}/").
         and_return(bundler_retry)
       expect(bundler_retry).to receive(:attempts).and_yield
-      expect(fetcher).to receive(:download).with(spec, uri, path)
+      expect(fetcher).to receive(:cache_update_path)
 
-      Bundler.rubygems.download_gem(spec, uri, path)
+      Bundler.rubygems.download_gem(spec, uri, cache_dir)
     end
   end
 
@@ -78,7 +69,7 @@ RSpec.describe Bundler::RubygemsIntegrat
 
       it "sets the 'X-Gemfile-Source' header containing the original source" do
         expect(Bundler.rubygems).to receive(:gem_remote_fetcher).twice.and_return(fetcher)
-        expect(fetcher).to receive(:headers=).with("X-Gemfile-Source" => "http://zombo.com").twice
+        expect(fetcher).to receive(:headers=).with({ "X-Gemfile-Source" => "http://zombo.com" }).twice
         expect(fetcher).to receive(:fetch_path).with(uri + "specs.4.8.gz").and_return(specs_response)
         expect(fetcher).to receive(:fetch_path).with(uri + "prerelease_specs.4.8.gz").and_return(prerelease_specs_response)
         result = Bundler.rubygems.fetch_all_remote_specs(remote_with_mirror)
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/settings_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/settings_spec.rb
@@ -64,13 +64,10 @@ that would suck --ehhh=oh geez it looks 
 
   describe "#global_config_file" do
     context "when $HOME is not accessible" do
-      context "when $TMPDIR is not writable" do
-        it "does not raise" do
-          expect(Bundler.rubygems).to receive(:user_home).twice.and_return(nil)
-          expect(Bundler).to receive(:tmp).twice.and_raise(Errno::EROFS, "Read-only file system @ dir_s_mkdir - /tmp/bundler")
+      it "does not raise" do
+        expect(Bundler.rubygems).to receive(:user_home).twice.and_return(nil)
 
-          expect(subject.send(:global_config_file)).to be_nil
-        end
+        expect(subject.send(:global_config_file)).to be_nil
       end
     end
   end
@@ -130,6 +127,8 @@ that would suck --ehhh=oh geez it looks 
 
   describe "#temporary" do
     it "reset after used" do
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+
       Bundler.settings.set_command_option :no_install, true
 
       Bundler.settings.temporary(:no_install => false) do
@@ -310,16 +309,26 @@ that would suck --ehhh=oh geez it looks 
   describe "BUNDLE_ keys format" do
     let(:settings) { described_class.new(bundled_app(".bundle")) }
 
-    it "converts older keys without double dashes" do
+    it "converts older keys without double underscore" do
       config("BUNDLE_MY__PERSONAL.RACK" => "~/Work/git/rack")
       expect(settings["my.personal.rack"]).to eq("~/Work/git/rack")
     end
 
-    it "converts older keys without trailing slashes and double dashes" do
+    it "converts older keys without trailing slashes and double underscore" do
       config("BUNDLE_MIRROR__HTTPS://RUBYGEMS.ORG" => "http://rubygems-mirror.org")
       expect(settings["mirror.https://rubygems.org/"]).to eq("http://rubygems-mirror.org")
     end
 
+    it "converts older keys with dashes" do
+      config("BUNDLE_MY-PERSONAL-SERVER__ORG" => "my-personal-server.org")
+      expect(Bundler.ui).to receive(:warn).with(
+        "Your #{bundled_app(".bundle/config")} config includes `BUNDLE_MY-PERSONAL-SERVER__ORG`, which contains the dash character (`-`).\n" \
+        "This is deprecated, because configuration through `ENV` should be possible, but `ENV` keys cannot include dashes.\n" \
+        "Please edit #{bundled_app(".bundle/config")} and replace any dashes in configuration keys with a triple underscore (`___`)."
+      )
+      expect(settings["my-personal-server.org"]).to eq("my-personal-server.org")
+    end
+
     it "reads newer keys format properly" do
       config("BUNDLE_MIRROR__HTTPS://RUBYGEMS__ORG/" => "http://rubygems-mirror.org")
       expect(settings["mirror.https://rubygems.org/"]).to eq("http://rubygems-mirror.org")
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/shared_helpers_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/shared_helpers_spec.rb
@@ -4,10 +4,13 @@ RSpec.describe Bundler::SharedHelpers do
   let(:ext_lock_double) { double(:ext_lock) }
 
   before do
+    pwd_stub
     allow(Bundler.rubygems).to receive(:ext_lock).and_return(ext_lock_double)
     allow(ext_lock_double).to receive(:synchronize) {|&block| block.call }
   end
 
+  let(:pwd_stub) { allow(subject).to receive(:pwd).and_return(bundled_app) }
+
   subject { Bundler::SharedHelpers }
 
   describe "#default_gemfile" do
@@ -77,7 +80,7 @@ RSpec.describe Bundler::SharedHelpers do
       let(:global_rubygems_dir) { Pathname.new(bundled_app) }
 
       before do
-        Dir.mkdir ".bundle"
+        Dir.mkdir bundled_app(".bundle")
         allow(Bundler.rubygems).to receive(:user_home).and_return(global_rubygems_dir)
       end
 
@@ -91,7 +94,7 @@ RSpec.describe Bundler::SharedHelpers do
       let(:expected_bundle_dir_path) { Pathname.new("#{bundled_app}/.bundle") }
 
       before do
-        Dir.mkdir ".bundle"
+        Dir.mkdir bundled_app(".bundle")
         allow(Bundler.rubygems).to receive(:user_home).and_return(global_rubygems_dir)
       end
 
@@ -109,7 +112,8 @@ RSpec.describe Bundler::SharedHelpers do
 
     shared_examples_for "correctly determines whether to return a Gemfile path" do
       context "currently in directory with a Gemfile" do
-        before { File.new("Gemfile", "w") }
+        before { FileUtils.touch(bundled_app_gemfile) }
+        after { FileUtils.rm(bundled_app_gemfile) }
 
         it "returns path of the bundle Gemfile" do
           expect(subject.in_bundle?).to eq("#{bundled_app}/Gemfile")
@@ -147,22 +151,24 @@ RSpec.describe Bundler::SharedHelpers do
   describe "#chdir" do
     let(:op_block) { proc { Dir.mkdir "nested_dir" } }
 
-    before { Dir.mkdir "chdir_test_dir" }
+    before { Dir.mkdir bundled_app("chdir_test_dir") }
 
     it "executes the passed block while in the specified directory" do
-      subject.chdir("chdir_test_dir", &op_block)
-      expect(Pathname.new("chdir_test_dir/nested_dir")).to exist
+      subject.chdir(bundled_app("chdir_test_dir"), &op_block)
+      expect(bundled_app("chdir_test_dir/nested_dir")).to exist
     end
   end
 
   describe "#pwd" do
+    let(:pwd_stub) { nil }
+
     it "returns the current absolute path" do
-      expect(subject.pwd).to eq(bundled_app)
+      expect(subject.pwd).to eq(source_root)
     end
   end
 
   describe "#with_clean_git_env" do
-    let(:with_clean_git_env_block) { proc { Dir.mkdir "with_clean_git_env_test_dir" } }
+    let(:with_clean_git_env_block) { proc { Dir.mkdir bundled_app("with_clean_git_env_test_dir") } }
 
     before do
       ENV["GIT_DIR"] = "ORIGINAL_ENV_GIT_DIR"
@@ -171,20 +177,20 @@ RSpec.describe Bundler::SharedHelpers do
 
     it "executes the passed block" do
       subject.with_clean_git_env(&with_clean_git_env_block)
-      expect(Pathname.new("with_clean_git_env_test_dir")).to exist
+      expect(bundled_app("with_clean_git_env_test_dir")).to exist
     end
 
     context "when a block is passed" do
       let(:with_clean_git_env_block) do
         proc do
-          Dir.mkdir "git_dir_test_dir" unless ENV["GIT_DIR"].nil?
-          Dir.mkdir "git_work_tree_test_dir" unless ENV["GIT_WORK_TREE"].nil?
+          Dir.mkdir bundled_app("git_dir_test_dir") unless ENV["GIT_DIR"].nil?
+          Dir.mkdir bundled_app("git_work_tree_test_dir") unless ENV["GIT_WORK_TREE"].nil?
         end end
 
       it "uses a fresh git env for execution" do
         subject.with_clean_git_env(&with_clean_git_env_block)
-        expect(Pathname.new("git_dir_test_dir")).to_not exist
-        expect(Pathname.new("git_work_tree_test_dir")).to_not exist
+        expect(bundled_app("git_dir_test_dir")).to_not exist
+        expect(bundled_app("git_work_tree_test_dir")).to_not exist
       end
     end
 
@@ -224,7 +230,7 @@ RSpec.describe Bundler::SharedHelpers do
     end
 
     shared_examples_for "ENV['PATH'] gets set correctly" do
-      before { Dir.mkdir ".bundle" }
+      before { Dir.mkdir bundled_app(".bundle") }
 
       it "ensures bundle bin path is in ENV['PATH']" do
         subject.set_bundle_environment
@@ -236,7 +242,7 @@ RSpec.describe Bundler::SharedHelpers do
     shared_examples_for "ENV['RUBYOPT'] gets set correctly" do
       it "ensures -rbundler/setup is at the beginning of ENV['RUBYOPT']" do
         subject.set_bundle_environment
-        expect(ENV["RUBYOPT"].split(" ")).to start_with("-r#{lib_dir}/bundler/setup")
+        expect(ENV["RUBYOPT"].split(" ")).to start_with("-r#{source_lib_dir}/bundler/setup")
       end
     end
 
@@ -244,7 +250,7 @@ RSpec.describe Bundler::SharedHelpers do
       let(:ruby_lib_path) { "stubbed_ruby_lib_dir" }
 
       before do
-        allow(Bundler::SharedHelpers).to receive(:bundler_ruby_lib).and_return(ruby_lib_path)
+        allow(subject).to receive(:bundler_ruby_lib).and_return(ruby_lib_path)
       end
 
       it "ensures bundler's ruby version lib path is in ENV['RUBYLIB']" do
@@ -263,7 +269,7 @@ RSpec.describe Bundler::SharedHelpers do
     end
 
     it "ignores if bundler_ruby_lib is same as rubylibdir" do
-      allow(Bundler::SharedHelpers).to receive(:bundler_ruby_lib).and_return(RbConfig::CONFIG["rubylibdir"])
+      allow(subject).to receive(:bundler_ruby_lib).and_return(RbConfig::CONFIG["rubylibdir"])
 
       subject.set_bundle_environment
 
@@ -422,8 +428,8 @@ RSpec.describe Bundler::SharedHelpers do
       let(:file_op_block) { proc {|path| FileUtils.mkdir_p(path) } }
 
       it "performs the operation in the passed block" do
-        subject.filesystem_access("./test_dir", &file_op_block)
-        expect(Pathname.new("test_dir")).to exist
+        subject.filesystem_access(bundled_app("test_dir"), &file_op_block)
+        expect(bundled_app("test_dir")).to exist
       end
     end
 
@@ -488,28 +494,4 @@ RSpec.describe Bundler::SharedHelpers do
       end
     end
   end
-
-  describe "#const_get_safely" do
-    module TargetNamespace
-      VALID_CONSTANT = 1
-    end
-
-    context "when the namespace does have the requested constant" do
-      it "returns the value of the requested constant" do
-        expect(subject.const_get_safely(:VALID_CONSTANT, TargetNamespace)).to eq(1)
-      end
-    end
-
-    context "when the requested constant is passed as a string" do
-      it "returns the value of the requested constant" do
-        expect(subject.const_get_safely("VALID_CONSTANT", TargetNamespace)).to eq(1)
-      end
-    end
-
-    context "when the namespace does not have the requested constant" do
-      it "returns nil" do
-        expect(subject.const_get_safely("INVALID_CONSTANT", TargetNamespace)).to be_nil
-      end
-    end
-  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/source/git/git_proxy_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/source/git/git_proxy_spec.rb
@@ -2,7 +2,7 @@
 
 RSpec.describe Bundler::Source::Git::GitProxy do
   let(:path) { Pathname("path") }
-  let(:uri) { "https://github.com/bundler/bundler.git" }
+  let(:uri) { "https://github.com/rubygems/rubygems.git" }
   let(:ref) { "HEAD" }
   let(:revision) { nil }
   let(:git_source) { nil }
@@ -11,30 +11,30 @@ RSpec.describe Bundler::Source::Git::Git
   context "with configured credentials" do
     it "adds username and password to URI" do
       Bundler.settings.temporary(uri => "u:p") do
-        expect(subject).to receive(:git_retry).with(match("https://u:p@github.com/bundler/bundler.git"))
+        expect(subject).to receive(:git_retry).with("clone", "--bare", "--no-hardlinks", "--quiet", "--", "https://u:p@github.com/rubygems/rubygems.git", path.to_s)
         subject.checkout
       end
     end
 
     it "adds username and password to URI for host" do
       Bundler.settings.temporary("github.com" => "u:p") do
-        expect(subject).to receive(:git_retry).with(match("https://u:p@github.com/bundler/bundler.git"))
+        expect(subject).to receive(:git_retry).with("clone", "--bare", "--no-hardlinks", "--quiet", "--", "https://u:p@github.com/rubygems/rubygems.git", path.to_s)
         subject.checkout
       end
     end
 
     it "does not add username and password to mismatched URI" do
-      Bundler.settings.temporary("https://u:p@github.com/bundler/bundler-mismatch.git" => "u:p") do
-        expect(subject).to receive(:git_retry).with(match(uri))
+      Bundler.settings.temporary("https://u:p@github.com/rubygems/rubygems-mismatch.git" => "u:p") do
+        expect(subject).to receive(:git_retry).with("clone", "--bare", "--no-hardlinks", "--quiet", "--", uri, path.to_s)
         subject.checkout
       end
     end
 
     it "keeps original userinfo" do
       Bundler.settings.temporary("github.com" => "u:p") do
-        original = "https://orig:info@github.com/bundler/bundler.git"
+        original = "https://orig:info@github.com/rubygems/rubygems.git"
         subject = described_class.new(Pathname("path"), original, "HEAD")
-        expect(subject).to receive(:git_retry).with(match(original))
+        expect(subject).to receive(:git_retry).with("clone", "--bare", "--no-hardlinks", "--quiet", "--", original, path.to_s)
         subject.checkout
       end
     end
@@ -123,26 +123,49 @@ RSpec.describe Bundler::Source::Git::Git
   end
 
   describe "#copy_to" do
+    let(:cache) { tmpdir("cache_path") }
     let(:destination) { tmpdir("copy_to_path") }
     let(:submodules) { false }
 
     context "when given a SHA as a revision" do
       let(:revision) { "abcd" * 10 }
-      let(:command) { "reset --hard #{revision}" }
+      let(:command) { ["reset", "--hard", revision] }
+      let(:command_for_display) { "git #{command.shelljoin}" }
 
       it "fails gracefully when resetting to the revision fails" do
-        expect(subject).to receive(:git_retry).with(start_with("clone ")) { destination.mkpath }
-        expect(subject).to receive(:git_retry).with(start_with("fetch "))
-        expect(subject).to receive(:git).with(command).and_raise(Bundler::Source::Git::GitCommandError, command)
+        expect(subject).to receive(:git_retry).with("clone", any_args) { destination.mkpath }
+        expect(subject).to receive(:git_retry).with("fetch", any_args, :dir => destination)
+        expect(subject).to receive(:git).with(*command, :dir => destination).and_raise(Bundler::Source::Git::GitCommandError.new(command_for_display, destination))
         expect(subject).not_to receive(:git)
 
         expect { subject.copy_to(destination, submodules) }.
           to raise_error(
             Bundler::Source::Git::MissingGitRevisionError,
-            "Git error: command `git #{command}` in directory #{destination} has failed.\n" \
-            "Revision #{revision} does not exist in the repository #{uri}. Maybe you misspelled it?" \
+            "Git error: command `#{command_for_display}` in directory #{destination} has failed.\n" \
+            "Revision #{revision} does not exist in the repository #{uri}. Maybe you misspelled it?\n" \
+            "If this error persists you could try removing the cache directory '#{destination}'"
           )
       end
     end
   end
+
+  it "doesn't allow arbitrary code execution through Gemfile uris with a leading dash" do
+    gemfile <<~G
+      gem "poc", git: "-u./pay:load.sh"
+    G
+
+    file = bundled_app("pay:load.sh")
+
+    create_file file, <<~RUBY
+      #!/bin/sh
+
+      touch #{bundled_app("canary")}
+    RUBY
+
+    FileUtils.chmod("+x", file)
+
+    bundle :lock, :raise_on_error => false
+
+    expect(Pathname.new(bundled_app("canary"))).not_to exist
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/source/git_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/source/git_spec.rb
@@ -14,14 +14,59 @@ RSpec.describe Bundler::Source::Git do
 
   describe "#to_s" do
     it "returns a description" do
-      expect(subject.to_s).to eq "https://github.com/foo/bar.git (at master)"
+      expect(subject.to_s).to eq "https://github.com/foo/bar.git"
     end
 
     context "when the URI contains credentials" do
       let(:uri) { "https://my-secret-token:x-oauth-basic@github.com/foo/bar.git" }
 
       it "filters credentials" do
-        expect(subject.to_s).to eq "https://x-oauth-basic@github.com/foo/bar.git (at master)"
+        expect(subject.to_s).to eq "https://x-oauth-basic@github.com/foo/bar.git"
+      end
+    end
+
+    context "when the source has a glob specifier" do
+      let(:glob) { "bar/baz/*.gemspec" }
+      let(:options) do
+        { "uri" => uri, "glob" => glob }
+      end
+
+      it "includes it" do
+        expect(subject.to_s).to eq "https://github.com/foo/bar.git (glob: bar/baz/*.gemspec)"
+      end
+    end
+
+    context "when the source has a reference" do
+      let(:git_proxy_stub) do
+        instance_double(Bundler::Source::Git::GitProxy, :revision => "123abc", :branch => "v1.0.0")
+      end
+      let(:options) do
+        { "uri" => uri, "ref" => "v1.0.0" }
+      end
+
+      before do
+        allow(Bundler::Source::Git::GitProxy).to receive(:new).and_return(git_proxy_stub)
+      end
+
+      it "includes it" do
+        expect(subject.to_s).to eq "https://github.com/foo/bar.git (at v1.0.0@123abc)"
+      end
+    end
+
+    context "when the source has both reference and glob specifiers" do
+      let(:git_proxy_stub) do
+        instance_double(Bundler::Source::Git::GitProxy, :revision => "123abc", :branch => "v1.0.0")
+      end
+      let(:options) do
+        { "uri" => uri, "ref" => "v1.0.0", "glob" => "gems/foo/*.gemspec" }
+      end
+
+      before do
+        allow(Bundler::Source::Git::GitProxy).to receive(:new).and_return(git_proxy_stub)
+      end
+
+      it "includes both" do
+        expect(subject.to_s).to eq "https://github.com/foo/bar.git (at v1.0.0@123abc, glob: gems/foo/*.gemspec)"
       end
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/source/rubygems_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/source/rubygems_spec.rb
@@ -30,4 +30,18 @@ RSpec.describe Bundler::Source::Rubygems
       end
     end
   end
+
+  describe "#no_remotes?" do
+    context "when no remote provided" do
+      it "returns a truthy value" do
+        expect(described_class.new("remotes" => []).no_remotes?).to be_truthy
+      end
+    end
+
+    context "when a remote provided" do
+      it "returns a falsey value" do
+        expect(described_class.new("remotes" => ["https://rubygems.org"]).no_remotes?).to be_falsey
+      end
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/source_list_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/source_list_spec.rb
@@ -75,7 +75,7 @@ RSpec.describe Bundler::SourceList do
         let(:msg) do
           "The git source `git://existing-git.org/path.git` " \
           "uses the `git` protocol, which transmits data without encryption. " \
-          "Disable this warning with `bundle config set git.allow_insecure true`, " \
+          "Disable this warning with `bundle config set --local git.allow_insecure true`, " \
           "or switch to the `https` protocol to keep your data secure."
         end
 
@@ -115,15 +115,15 @@ RSpec.describe Bundler::SourceList do
       end
     end
 
-    describe "#add_rubygems_remote", :bundler => "< 3" do
-      let!(:returned_source) { source_list.add_rubygems_remote("https://rubygems.org/") }
+    describe "#add_global_rubygems_remote" do
+      let!(:returned_source) { source_list.add_global_rubygems_remote("https://rubygems.org/") }
 
       it "returns the aggregate rubygems source" do
         expect(returned_source).to be_instance_of(Bundler::Source::Rubygems)
       end
 
       it "adds the provided remote to the beginning of the aggregate source" do
-        source_list.add_rubygems_remote("https://othersource.org")
+        source_list.add_global_rubygems_remote("https://othersource.org")
         expect(returned_source.remotes).to eq [
           Bundler::URI("https://othersource.org/"),
           Bundler::URI("https://rubygems.org/"),
@@ -212,22 +212,22 @@ RSpec.describe Bundler::SourceList do
 
   describe "#path_sources" do
     it "returns an empty array when no path sources have been added" do
-      source_list.add_rubygems_remote("https://rubygems.org")
+      source_list.add_global_rubygems_remote("https://rubygems.org")
       source_list.add_git_source("uri" => "git://host/path.git")
       expect(source_list.path_sources).to be_empty
     end
 
     it "returns path sources in the reverse order that they were added" do
       source_list.add_git_source("uri" => "git://third-git.org/path.git")
-      source_list.add_rubygems_remote("https://fifth-rubygems.org")
+      source_list.add_global_rubygems_remote("https://fifth-rubygems.org")
       source_list.add_path_source("path" => "/third/path/to/gem")
-      source_list.add_rubygems_remote("https://fourth-rubygems.org")
+      source_list.add_global_rubygems_remote("https://fourth-rubygems.org")
       source_list.add_path_source("path" => "/second/path/to/gem")
-      source_list.add_rubygems_remote("https://third-rubygems.org")
+      source_list.add_global_rubygems_remote("https://third-rubygems.org")
       source_list.add_git_source("uri" => "git://second-git.org/path.git")
-      source_list.add_rubygems_remote("https://second-rubygems.org")
+      source_list.add_global_rubygems_remote("https://second-rubygems.org")
       source_list.add_path_source("path" => "/first/path/to/gem")
-      source_list.add_rubygems_remote("https://first-rubygems.org")
+      source_list.add_global_rubygems_remote("https://first-rubygems.org")
       source_list.add_git_source("uri" => "git://first-git.org/path.git")
 
       expect(source_list.path_sources).to eq [
@@ -240,7 +240,7 @@ RSpec.describe Bundler::SourceList do
 
   describe "#git_sources" do
     it "returns an empty array when no git sources have been added" do
-      source_list.add_rubygems_remote("https://rubygems.org")
+      source_list.add_global_rubygems_remote("https://rubygems.org")
       source_list.add_path_source("path" => "/path/to/gem")
 
       expect(source_list.git_sources).to be_empty
@@ -248,15 +248,15 @@ RSpec.describe Bundler::SourceList do
 
     it "returns git sources in the reverse order that they were added" do
       source_list.add_git_source("uri" => "git://third-git.org/path.git")
-      source_list.add_rubygems_remote("https://fifth-rubygems.org")
+      source_list.add_global_rubygems_remote("https://fifth-rubygems.org")
       source_list.add_path_source("path" => "/third/path/to/gem")
-      source_list.add_rubygems_remote("https://fourth-rubygems.org")
+      source_list.add_global_rubygems_remote("https://fourth-rubygems.org")
       source_list.add_path_source("path" => "/second/path/to/gem")
-      source_list.add_rubygems_remote("https://third-rubygems.org")
+      source_list.add_global_rubygems_remote("https://third-rubygems.org")
       source_list.add_git_source("uri" => "git://second-git.org/path.git")
-      source_list.add_rubygems_remote("https://second-rubygems.org")
+      source_list.add_global_rubygems_remote("https://second-rubygems.org")
       source_list.add_path_source("path" => "/first/path/to/gem")
-      source_list.add_rubygems_remote("https://first-rubygems.org")
+      source_list.add_global_rubygems_remote("https://first-rubygems.org")
       source_list.add_git_source("uri" => "git://first-git.org/path.git")
 
       expect(source_list.git_sources).to eq [
@@ -269,7 +269,7 @@ RSpec.describe Bundler::SourceList do
 
   describe "#plugin_sources" do
     it "returns an empty array when no plugin sources have been added" do
-      source_list.add_rubygems_remote("https://rubygems.org")
+      source_list.add_global_rubygems_remote("https://rubygems.org")
       source_list.add_path_source("path" => "/path/to/gem")
 
       expect(source_list.plugin_sources).to be_empty
@@ -279,13 +279,13 @@ RSpec.describe Bundler::SourceList do
       source_list.add_plugin_source("new_source", "uri" => "https://third-git.org/path.git")
       source_list.add_git_source("https://new-git.org")
       source_list.add_path_source("path" => "/third/path/to/gem")
-      source_list.add_rubygems_remote("https://fourth-rubygems.org")
+      source_list.add_global_rubygems_remote("https://fourth-rubygems.org")
       source_list.add_path_source("path" => "/second/path/to/gem")
-      source_list.add_rubygems_remote("https://third-rubygems.org")
+      source_list.add_global_rubygems_remote("https://third-rubygems.org")
       source_list.add_plugin_source("new_source", "uri" => "git://second-git.org/path.git")
-      source_list.add_rubygems_remote("https://second-rubygems.org")
+      source_list.add_global_rubygems_remote("https://second-rubygems.org")
       source_list.add_path_source("path" => "/first/path/to/gem")
-      source_list.add_rubygems_remote("https://first-rubygems.org")
+      source_list.add_global_rubygems_remote("https://first-rubygems.org")
       source_list.add_plugin_source("new_source", "uri" => "git://first-git.org/path.git")
 
       expect(source_list.plugin_sources).to eq [
@@ -339,7 +339,7 @@ RSpec.describe Bundler::SourceList do
   describe "#get" do
     context "when it includes an equal source" do
       let(:rubygems_source) { Bundler::Source::Rubygems.new("remotes" => ["https://rubygems.org"]) }
-      before { @equal_source = source_list.add_rubygems_remote("https://rubygems.org") }
+      before { @equal_source = source_list.add_global_rubygems_remote("https://rubygems.org") }
 
       it "returns the equal source" do
         expect(source_list.get(rubygems_source)).to be @equal_source
@@ -372,26 +372,7 @@ RSpec.describe Bundler::SourceList do
       source_list.add_git_source("uri" => "git://first-git.org/path.git")
     end
 
-    it "combines the rubygems sources into a single instance, removing duplicate remotes from the end", :bundler => "< 3" do
-      expect(source_list.lock_sources).to eq [
-        Bundler::Source::Git.new("uri" => "git://first-git.org/path.git"),
-        Bundler::Source::Git.new("uri" => "git://second-git.org/path.git"),
-        Bundler::Source::Git.new("uri" => "git://third-git.org/path.git"),
-        ASourcePlugin.new("uri" => "https://second-plugin.org/random"),
-        ASourcePlugin.new("uri" => "https://third-bar.org/foo"),
-        Bundler::Source::Path.new("path" => "/first/path/to/gem"),
-        Bundler::Source::Path.new("path" => "/second/path/to/gem"),
-        Bundler::Source::Path.new("path" => "/third/path/to/gem"),
-        Bundler::Source::Rubygems.new("remotes" => [
-          "https://duplicate-rubygems.org",
-          "https://first-rubygems.org",
-          "https://second-rubygems.org",
-          "https://third-rubygems.org",
-        ]),
-      ]
-    end
-
-    it "returns all sources, without combining rubygems sources", :bundler => "3" do
+    it "returns all sources, without combining rubygems sources" do
       expect(source_list.lock_sources).to eq [
         Bundler::Source::Git.new("uri" => "git://first-git.org/path.git"),
         Bundler::Source::Git.new("uri" => "git://second-git.org/path.git"),
@@ -460,4 +441,19 @@ RSpec.describe Bundler::SourceList do
       source_list.remote!
     end
   end
+
+  describe "implicit_global_source?" do
+    context "when a global rubygem source provided" do
+      it "returns a falsy value" do
+        source_list.add_global_rubygems_remote("https://rubygems.org")
+
+        expect(source_list.implicit_global_source?).to be_falsey
+      end
+    end
+    context "when no global rubygem source provided" do
+      it "returns a truthy value" do
+        expect(source_list.implicit_global_source?).to be_truthy
+      end
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/source_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/source_spec.rb
@@ -30,17 +30,7 @@ RSpec.describe Bundler::Source do
     end
 
     context "when there are locked gems" do
-      let(:locked_gems) { double(:locked_gems) }
-
-      before { allow(Bundler).to receive(:locked_gems).and_return(locked_gems) }
-
       context "that contain the relevant gem spec" do
-        before do
-          specs = double(:specs)
-          allow(locked_gems).to receive(:specs).and_return(specs)
-          allow(specs).to receive(:find).and_return(locked_gem)
-        end
-
         context "without a version" do
           let(:locked_gem) { double(:locked_gem, :name => "nokogiri", :version => nil) }
 
@@ -62,7 +52,7 @@ RSpec.describe Bundler::Source do
             end
 
             it "should return a string with the spec name and version and locked spec version" do
-              expect(subject.version_message(spec)).to eq("nokogiri >= 1.6\e[32m (was < 1.5)\e[0m")
+              expect(subject.version_message(spec, locked_gem)).to eq("nokogiri >= 1.6\e[32m (was < 1.5)\e[0m")
             end
           end
 
@@ -74,7 +64,7 @@ RSpec.describe Bundler::Source do
             end
 
             it "should return a string with the spec name and version and locked spec version" do
-              expect(subject.version_message(spec)).to eq("nokogiri >= 1.6 (was < 1.5)")
+              expect(subject.version_message(spec, locked_gem)).to eq("nokogiri >= 1.6 (was < 1.5)")
             end
           end
         end
@@ -89,7 +79,7 @@ RSpec.describe Bundler::Source do
             end
 
             it "should return a string with the locked spec version in yellow" do
-              expect(subject.version_message(spec)).to eq("nokogiri 1.6.1\e[33m (was 1.7.0)\e[0m")
+              expect(subject.version_message(spec, locked_gem)).to eq("nokogiri 1.6.1\e[33m (was 1.7.0)\e[0m")
             end
           end
 
@@ -101,7 +91,7 @@ RSpec.describe Bundler::Source do
             end
 
             it "should return a string with the locked spec version in yellow" do
-              expect(subject.version_message(spec)).to eq("nokogiri 1.6.1 (was 1.7.0)")
+              expect(subject.version_message(spec, locked_gem)).to eq("nokogiri 1.6.1 (was 1.7.0)")
             end
           end
         end
@@ -116,7 +106,7 @@ RSpec.describe Bundler::Source do
             end
 
             it "should return a string with the locked spec version in green" do
-              expect(subject.version_message(spec)).to eq("nokogiri 1.7.1\e[32m (was 1.7.0)\e[0m")
+              expect(subject.version_message(spec, locked_gem)).to eq("nokogiri 1.7.1\e[32m (was 1.7.0)\e[0m")
             end
           end
 
@@ -128,27 +118,11 @@ RSpec.describe Bundler::Source do
             end
 
             it "should return a string with the locked spec version in yellow" do
-              expect(subject.version_message(spec)).to eq("nokogiri 1.7.1 (was 1.7.0)")
+              expect(subject.version_message(spec, locked_gem)).to eq("nokogiri 1.7.1 (was 1.7.0)")
             end
           end
         end
       end
-
-      context "that do not contain the relevant gem spec" do
-        before do
-          specs = double(:specs)
-          allow(locked_gems).to receive(:specs).and_return(specs)
-          allow(specs).to receive(:find).and_return(nil)
-        end
-
-        it_behaves_like "the lockfile specs are not relevant"
-      end
-    end
-
-    context "when there are no locked gems" do
-      before { allow(Bundler).to receive(:locked_gems).and_return(nil) }
-
-      it_behaves_like "the lockfile specs are not relevant"
     end
   end
 
@@ -188,7 +162,7 @@ RSpec.describe Bundler::Source do
     end
   end
 
-private
+  private
 
   def with_ui(ui)
     old_ui = Bundler.ui
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/stub_specification_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/stub_specification_spec.rb
@@ -1,15 +1,14 @@
 # frozen_string_literal: true
 
 RSpec.describe Bundler::StubSpecification do
-  let(:gemspec) do
-    Gem::Specification.new do |s|
+  let(:with_bundler_stub_spec) do
+    gemspec = Gem::Specification.new do |s|
       s.name = "gemname"
       s.version = "1.0.0"
       s.loaded_from = __FILE__
+      s.extensions = "ext/gemname"
     end
-  end
 
-  let(:with_bundler_stub_spec) do
     described_class.from_stub(gemspec)
   end
 
@@ -19,4 +18,30 @@ RSpec.describe Bundler::StubSpecificatio
       expect(stub).to be(with_bundler_stub_spec)
     end
   end
+
+  describe "#manually_installed?" do
+    it "returns true if installed_by_version is nil or 0" do
+      stub = described_class.from_stub(with_bundler_stub_spec)
+      expect(stub.manually_installed?).to be true
+    end
+
+    it "returns false if installed_by_version is greater than 0" do
+      stub = described_class.from_stub(with_bundler_stub_spec)
+      stub.installed_by_version = Gem::Version.new(1)
+      expect(stub.manually_installed?).to be false
+    end
+  end
+
+  describe "#missing_extensions?" do
+    it "returns false if manually_installed?" do
+      stub = described_class.from_stub(with_bundler_stub_spec)
+      expect(stub.missing_extensions?).to be false
+    end
+
+    it "returns true if not manually_installed?" do
+      stub = described_class.from_stub(with_bundler_stub_spec)
+      stub.installed_by_version = Gem::Version.new(1)
+      expect(stub.missing_extensions?).to be true
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/ui/shell_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/ui/shell_spec.rb
@@ -1,7 +1,5 @@
 # frozen_string_literal: true
 
-require_relative "../../support/streams"
-
 RSpec.describe Bundler::UI::Shell do
   subject { described_class.new }
 
@@ -43,10 +41,19 @@ RSpec.describe Bundler::UI::Shell do
 
     context "when stderr is closed" do
       it "doesn't report anything" do
-        output = capture(:stderr, :closed => true) do
-          subject.error("Something went wrong")
-        end
-        expect(output).to_not eq("Something went wrong\n")
+        output = begin
+                   result = StringIO.new
+                   result.close
+
+                   $stderr = result
+
+                   subject.error("Something went wrong")
+
+                   result.string
+                 ensure
+                   $stderr = STDERR
+                 end
+        expect(output).to_not eq("Something went wrong")
       end
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/bundler/worker_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/bundler/worker_spec.rb
@@ -19,4 +19,51 @@ RSpec.describe Bundler::Worker do
       end
     end
   end
+
+  describe "handling interrupts" do
+    let(:status) do
+      pid = Process.fork do
+        $stderr.reopen File.new("/dev/null", "w")
+        Signal.trap "INT", previous_interrupt_handler
+        subject.enq "a"
+        subject.stop unless interrupt_before_stopping
+        Process.kill "INT", Process.pid
+      end
+
+      Process.wait2(pid).last
+    end
+
+    before do
+      skip "requires Process.fork" unless Process.respond_to?(:fork)
+    end
+
+    context "when interrupted before stopping" do
+      let(:interrupt_before_stopping) { true }
+      let(:previous_interrupt_handler) { ->(*) { exit 0 } }
+
+      it "aborts" do
+        expect(status.exitstatus).to eq(1)
+      end
+    end
+
+    context "when interrupted after stopping" do
+      let(:interrupt_before_stopping) { false }
+
+      context "when the previous interrupt handler was the default" do
+        let(:previous_interrupt_handler) { "DEFAULT" }
+
+        it "uses the default interrupt handler" do
+          expect(status).to be_signaled
+        end
+      end
+
+      context "when the previous interrupt handler was customized" do
+        let(:previous_interrupt_handler) { ->(*) { exit 42 } }
+
+        it "restores the custom interrupt handler after stopping" do
+          expect(status.exitstatus).to eq(42)
+        end
+      end
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/cache/gems_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/cache/gems_spec.rb
@@ -4,11 +4,12 @@ RSpec.describe "bundle cache" do
   shared_examples_for "when there are only gemsources" do
     before :each do
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem 'rack'
       G
 
-      system_gems "rack-1.0.0", :path => :bundle_path
-      bundle! :cache
+      system_gems "rack-1.0.0", :path => path
+      bundle :cache
     end
 
     it "copies the .gem file to vendor/cache" do
@@ -27,7 +28,7 @@ RSpec.describe "bundle cache" do
     end
 
     it "uses the cache as a source when installing gems with --local" do
-      system_gems [], :path => :bundle_path
+      system_gems [], :path => default_bundle_path
       bundle "install --local"
 
       expect(the_bundle).to include_gems("rack 1.0.0")
@@ -39,6 +40,7 @@ RSpec.describe "bundle cache" do
       end
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
 
@@ -46,9 +48,10 @@ RSpec.describe "bundle cache" do
     end
 
     it "does not reinstall gems from the cache if they exist in the bundle" do
-      system_gems "rack-1.0.0", :path => :bundle_path
+      system_gems "rack-1.0.0", :path => default_bundle_path
 
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
 
@@ -56,7 +59,7 @@ RSpec.describe "bundle cache" do
         s.write "lib/rack.rb", "RACK = 'FAIL'"
       end
 
-      bundle! :install, :local => true
+      bundle :install, :local => true
       expect(the_bundle).to include_gems("rack 1.0.0")
     end
 
@@ -64,54 +67,67 @@ RSpec.describe "bundle cache" do
       cache_gems "rack-1.0.0"
 
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
 
       bundle "cache"
 
-      expect(bundled_app("Gemfile.lock")).to exist
+      expect(bundled_app_lock).to exist
     end
   end
 
   context "using system gems" do
-    before { bundle! "config set path.system true" }
+    before { bundle "config set path.system true" }
+    let(:path) { system_gem_path }
     it_behaves_like "when there are only gemsources"
   end
 
   context "installing into a local path" do
-    before { bundle! "config set path ./.bundle" }
+    before { bundle "config set path ./.bundle" }
+    let(:path) { local_gem_path }
     it_behaves_like "when there are only gemsources"
   end
 
-  describe "when there is a built-in gem" do
+  describe "when there is a built-in gem", :ruby_repo do
+    let(:default_json_version) { ruby "gem 'json'; require 'json'; puts JSON::VERSION" }
+
     before :each do
       build_repo2 do
-        build_gem "builtin_gem", "1.0.2"
+        build_gem "json", default_json_version
       end
 
-      build_gem "builtin_gem", "1.0.2", :to_system => true do |s|
-        s.summary = "This builtin_gem is bundled with Ruby"
-      end
-
-      FileUtils.rm("#{system_gem_path}/cache/builtin_gem-1.0.2.gem")
+      build_gem "json", default_json_version, :to_system => true, :default => true
     end
 
     it "uses builtin gems when installing to system gems" do
-      bundle! "config set path.system true"
-      install_gemfile %(gem 'builtin_gem', '1.0.2')
-      expect(the_bundle).to include_gems("builtin_gem 1.0.2")
+      bundle "config set path.system true"
+      install_gemfile %(source "#{file_uri_for(gem_repo1)}"; gem 'json', '#{default_json_version}'), :verbose => true
+      expect(out).to include("Using json #{default_json_version}")
     end
 
     it "caches remote and builtin gems" do
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
-        gem 'builtin_gem', '1.0.2'
+        gem 'json', '#{default_json_version}'
         gem 'rack', '1.0.0'
       G
 
       bundle :cache
       expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
-      expect(bundled_app("vendor/cache/builtin_gem-1.0.2.gem")).to exist
+      expect(bundled_app("vendor/cache/json-#{default_json_version}.gem")).to exist
+    end
+
+    it "caches builtin gems when cache_all_platforms is set" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "json"
+      G
+
+      bundle "config set cache_all_platforms true"
+
+      bundle :cache
+      expect(bundled_app("vendor/cache/json-#{default_json_version}.gem")).to exist
     end
 
     it "doesn't make remote request after caching the gem" do
@@ -129,15 +145,16 @@ RSpec.describe "bundle cache" do
     end
 
     it "errors if the builtin gem isn't available to cache" do
-      bundle! "config set path.system true"
+      bundle "config set path.system true"
 
       install_gemfile <<-G
-        gem 'builtin_gem', '1.0.2'
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'json', '#{default_json_version}'
       G
 
-      bundle :cache
-      expect(exitstatus).to_not eq(0) if exitstatus
-      expect(err).to include("builtin_gem-1.0.2 is built in to Ruby, and can't be cached")
+      bundle :cache, :raise_on_error => false
+      expect(exitstatus).to_not eq(0)
+      expect(err).to include("json-#{default_json_version} is built in to Ruby, and can't be cached")
     end
   end
 
@@ -165,11 +182,11 @@ RSpec.describe "bundle cache" do
     end
 
     it "should not explode if the lockfile is not present" do
-      FileUtils.rm(bundled_app("Gemfile.lock"))
+      FileUtils.rm(bundled_app_lock)
 
       bundle :cache
 
-      expect(bundled_app("Gemfile.lock")).to exist
+      expect(bundled_app_lock).to exist
     end
   end
 
@@ -195,7 +212,12 @@ RSpec.describe "bundle cache" do
     end
 
     it "adds and removes when gems are updated" do
-      update_repo2
+      update_repo2 do
+        build_gem "rack", "1.2" do |s|
+          s.executables = "rackup"
+        end
+      end
+
       bundle "update", :all => true
       expect(cached_gem("rack-1.2")).to exist
       expect(cached_gem("rack-1.0.0")).not_to exist
@@ -295,6 +317,7 @@ RSpec.describe "bundle cache" do
         :path => bundled_app("vendor/cache")
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo-bundler"
       G
 
--- ruby2.7-2.7.6.orig/spec/bundler/cache/git_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/cache/git_spec.rb
@@ -15,9 +15,10 @@ end
 RSpec.describe "bundle cache with git" do
   it "copies repository to vendor cache and uses it" do
     git = build_git "foo"
-    ref = git.ref_for("master", 11)
+    ref = git.ref_for("main", 11)
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => '#{lib_path("foo-1.0")}'
     G
 
@@ -31,15 +32,17 @@ RSpec.describe "bundle cache with git" d
     expect(the_bundle).to include_gems "foo 1.0"
   end
 
-  it "copies repository to vendor cache and uses it even when installed with bundle --path" do
+  it "copies repository to vendor cache and uses it even when configured with `path`" do
     git = build_git "foo"
-    ref = git.ref_for("master", 11)
+    ref = git.ref_for("main", 11)
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => '#{lib_path("foo-1.0")}'
     G
 
-    bundle "install --path vendor/bundle"
+    bundle "config set --local path vendor/bundle"
+    bundle "install"
     bundle "config set cache_all true"
     bundle :cache
 
@@ -53,13 +56,14 @@ RSpec.describe "bundle cache with git" d
   it "runs twice without exploding" do
     build_git "foo"
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => '#{lib_path("foo-1.0")}'
     G
 
     bundle "config set cache_all true"
-    bundle! :cache
-    bundle! :cache
+    bundle :cache
+    bundle :cache
 
     expect(out).to include "Updating files in vendor/cache"
     FileUtils.rm_rf lib_path("foo-1.0")
@@ -68,9 +72,10 @@ RSpec.describe "bundle cache with git" d
 
   it "tracks updates" do
     git = build_git "foo"
-    old_ref = git.ref_for("master", 11)
+    old_ref = git.ref_for("main", 11)
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => '#{lib_path("foo-1.0")}'
     G
 
@@ -81,37 +86,38 @@ RSpec.describe "bundle cache with git" d
       s.write "lib/foo.rb", "puts :CACHE"
     end
 
-    ref = git.ref_for("master", 11)
+    ref = git.ref_for("main", 11)
     expect(ref).not_to eq(old_ref)
 
-    bundle! "update", :all => true
+    bundle "update", :all => true
     bundle "config set cache_all true"
-    bundle! :cache
+    bundle :cache
 
     expect(bundled_app("vendor/cache/foo-1.0-#{ref}")).to exist
     expect(bundled_app("vendor/cache/foo-1.0-#{old_ref}")).not_to exist
 
     FileUtils.rm_rf lib_path("foo-1.0")
-    run! "require 'foo'"
+    run "require 'foo'"
     expect(out).to eq("CACHE")
   end
 
   it "tracks updates when specifying the gem" do
     git = build_git "foo"
-    old_ref = git.ref_for("master", 11)
+    old_ref = git.ref_for("main", 11)
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => '#{lib_path("foo-1.0")}'
     G
 
     bundle "config set cache_all true"
-    bundle! :cache
+    bundle :cache
 
     update_git "foo" do |s|
       s.write "lib/foo.rb", "puts :CACHE"
     end
 
-    ref = git.ref_for("master", 11)
+    ref = git.ref_for("main", 11)
     expect(ref).not_to eq(old_ref)
 
     bundle "update foo"
@@ -126,10 +132,11 @@ RSpec.describe "bundle cache with git" d
 
   it "uses the local repository to generate the cache" do
     git = build_git "foo"
-    ref = git.ref_for("master", 11)
+    ref = git.ref_for("main", 11)
 
     gemfile <<-G
-      gem "foo", :git => '#{lib_path("foo-invalid")}', :branch => :master
+      source "#{file_uri_for(gem_repo1)}"
+      gem "foo", :git => '#{lib_path("foo-invalid")}', :branch => :main
     G
 
     bundle %(config set local.foo #{lib_path("foo-1.0")})
@@ -155,18 +162,17 @@ RSpec.describe "bundle cache with git" d
       s.add_dependency "submodule"
     end
 
-    Dir.chdir(lib_path("has_submodule-1.0")) do
-      sys_exec "git submodule add #{lib_path("submodule-1.0")} submodule-1.0"
-      `git commit -m "submodulator"`
-    end
+    sys_exec "git submodule add #{lib_path("submodule-1.0")} submodule-1.0", :dir => lib_path("has_submodule-1.0")
+    sys_exec "git commit -m \"submodulator\"", :dir => lib_path("has_submodule-1.0")
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       git "#{lib_path("has_submodule-1.0")}", :submodules => true do
         gem "has_submodule"
       end
     G
 
-    ref = git.ref_for("master", 11)
+    ref = git.ref_for("main", 11)
     bundle "config set cache_all true"
     bundle :cache
 
@@ -175,32 +181,6 @@ RSpec.describe "bundle cache with git" d
     expect(the_bundle).to include_gems "has_submodule 1.0"
   end
 
-  it "displays warning message when detecting git repo in Gemfile", :bundler => "< 3" do
-    build_git "foo"
-
-    install_gemfile <<-G
-      gem "foo", :git => '#{lib_path("foo-1.0")}'
-    G
-
-    bundle :cache
-
-    expect(err).to include("Your Gemfile contains path and git dependencies.")
-  end
-
-  it "does not display warning message if cache_all is set in bundle config" do
-    build_git "foo"
-
-    install_gemfile <<-G
-      gem "foo", :git => '#{lib_path("foo-1.0")}'
-    G
-
-    bundle "config set cache_all true"
-    bundle :cache
-    bundle :cache
-
-    expect(err).not_to include("Your Gemfile contains path and git dependencies.")
-  end
-
   it "caches pre-evaluated gemspecs" do
     git = build_git "foo"
 
@@ -210,12 +190,13 @@ RSpec.describe "bundle cache with git" d
     update_git("foo") {|s| s.write "foo.gemspec", spec_lines.join("\n") }
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => '#{lib_path("foo-1.0")}'
     G
     bundle "config set cache_all true"
     bundle :cache
 
-    ref = git.ref_for("master", 11)
+    ref = git.ref_for("main", 11)
     gemspec = bundled_app("vendor/cache/foo-1.0-#{ref}/foo.gemspec").read
     expect(gemspec).to_not match("`echo bob`")
   end
@@ -224,15 +205,16 @@ RSpec.describe "bundle cache with git" d
     build_git "foo"
 
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => '#{lib_path("foo-1.0")}'
     G
-    bundle! "config set cache_all true"
-    bundle! :cache, "all-platforms" => true, :install => false, :path => "./vendor/cache"
+    bundle "config set cache_all true"
+    bundle :cache, "all-platforms" => true, :install => false
 
     simulate_new_machine
     with_path_as "" do
-      bundle! "config set deployment true"
-      bundle! :install, :local => true
+      bundle "config set deployment true"
+      bundle :install, :local => true
       expect(the_bundle).to include_gem "foo 1.0"
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/cache/path_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/cache/path_spec.rb
@@ -5,6 +5,7 @@ RSpec.describe "bundle cache with path" 
     build_lib "foo", :path => bundled_app("lib/foo")
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => '#{bundled_app("lib/foo")}'
     G
 
@@ -18,6 +19,7 @@ RSpec.describe "bundle cache with path" 
     build_lib "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => '#{lib_path("foo-1.0")}'
     G
 
@@ -26,17 +28,17 @@ RSpec.describe "bundle cache with path" 
     expect(bundled_app("vendor/cache/foo-1.0")).to exist
     expect(bundled_app("vendor/cache/foo-1.0/.bundlecache")).to be_file
 
-    FileUtils.rm_rf lib_path("foo-1.0")
     expect(the_bundle).to include_gems "foo 1.0"
   end
 
   it "copies when the path is outside the bundle and the paths intersect" do
-    libname = File.basename(Dir.pwd) + "_gem"
-    libpath = File.join(File.dirname(Dir.pwd), libname)
+    libname = File.basename(bundled_app) + "_gem"
+    libpath = File.join(File.dirname(bundled_app), libname)
 
     build_lib libname, :path => libpath
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "#{libname}", :path => '#{libpath}'
     G
 
@@ -45,7 +47,6 @@ RSpec.describe "bundle cache with path" 
     expect(bundled_app("vendor/cache/#{libname}")).to exist
     expect(bundled_app("vendor/cache/#{libname}/.bundlecache")).to be_file
 
-    FileUtils.rm_rf libpath
     expect(the_bundle).to include_gems "#{libname} 1.0"
   end
 
@@ -53,6 +54,7 @@ RSpec.describe "bundle cache with path" 
     build_lib "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => '#{lib_path("foo-1.0")}'
     G
 
@@ -66,7 +68,6 @@ RSpec.describe "bundle cache with path" 
     bundle :cache
 
     expect(bundled_app("vendor/cache/foo-1.0")).to exist
-    FileUtils.rm_rf lib_path("foo-1.0")
 
     run "require 'foo'"
     expect(out).to eq("CACHE")
@@ -76,36 +77,57 @@ RSpec.describe "bundle cache with path" 
     build_lib "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => '#{lib_path("foo-1.0")}'
     G
 
     bundle "config set cache_all true"
     bundle :cache
 
+    expect(bundled_app("vendor/cache/foo-1.0")).to exist
+
+    build_lib "bar"
+
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "bar", :path => '#{lib_path("bar-1.0")}'
     G
 
     bundle :cache
-    expect(bundled_app("vendor/cache/bar-1.0")).not_to exist
+    expect(bundled_app("vendor/cache/foo-1.0")).not_to exist
   end
 
-  it "raises a warning without --all", :bundler => "< 3" do
+  it "does not cache path gems by default", :bundler => "< 3" do
     build_lib "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => '#{lib_path("foo-1.0")}'
     G
 
     bundle :cache
-    expect(err).to match(/please pass the \-\-all flag/)
+    expect(err).to be_empty
     expect(bundled_app("vendor/cache/foo-1.0")).not_to exist
   end
 
+  it "caches path gems by default", :bundler => "3" do
+    build_lib "foo"
+
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "foo", :path => '#{lib_path("foo-1.0")}'
+    G
+
+    bundle :cache
+    expect(err).to be_empty
+    expect(bundled_app("vendor/cache/foo-1.0")).to exist
+  end
+
   it "stores the given flag" do
     build_lib "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => '#{lib_path("foo-1.0")}'
     G
 
@@ -114,6 +136,7 @@ RSpec.describe "bundle cache with path" 
     build_lib "bar"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => '#{lib_path("foo-1.0")}'
       gem "bar", :path => '#{lib_path("bar-1.0")}'
     G
@@ -126,6 +149,7 @@ RSpec.describe "bundle cache with path" 
     build_lib "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => '#{lib_path("foo-1.0")}'
     G
 
@@ -134,11 +158,12 @@ RSpec.describe "bundle cache with path" 
     build_lib "baz"
 
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => '#{lib_path("foo-1.0")}'
       gem "baz", :path => '#{lib_path("baz-1.0")}'
     G
 
-    bundle "cache --no-all"
+    bundle "cache --no-all", :raise_on_error => false
     expect(bundled_app("vendor/cache/baz-1.0")).not_to exist
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/cache/platform_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/cache/platform_spec.rb
@@ -34,14 +34,14 @@ RSpec.describe "bundle cache with multip
   end
 
   it "ensures that a successful bundle install does not delete gems for other platforms" do
-    bundle! "install"
+    bundle "install"
 
     expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
     expect(bundled_app("vendor/cache/activesupport-2.3.5.gem")).to exist
   end
 
   it "ensures that a successful bundle update does not delete gems for other platforms" do
-    bundle! "update", :all => true
+    bundle "update", :all => true
 
     expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
     expect(bundled_app("vendor/cache/activesupport-2.3.5.gem")).to exist
--- ruby2.7-2.7.6.orig/spec/bundler/commands/add_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/add_spec.rb
@@ -13,7 +13,7 @@ RSpec.describe "bundle add" do
 
     build_git "foo", "2.0"
 
-    install_gemfile <<-G
+    gemfile <<-G
       source "#{file_uri_for(gem_repo2)}"
       gem "weakling", "~> 0.0.1"
     G
@@ -21,7 +21,7 @@ RSpec.describe "bundle add" do
 
   context "when no gems are specified" do
     it "shows error" do
-      bundle "add"
+      bundle "add", :raise_on_error => false
 
       expect(err).to include("Please specify gems to add")
     end
@@ -30,25 +30,25 @@ RSpec.describe "bundle add" do
   describe "without version specified" do
     it "version requirement becomes ~> major.minor.patch when resolved version is < 1.0" do
       bundle "add 'bar'"
-      expect(bundled_app("Gemfile").read).to match(/gem "bar", "~> 0.12.3"/)
+      expect(bundled_app_gemfile.read).to match(/gem "bar", "~> 0.12.3"/)
       expect(the_bundle).to include_gems "bar 0.12.3"
     end
 
     it "version requirement becomes ~> major.minor when resolved version is > 1.0" do
       bundle "add 'baz'"
-      expect(bundled_app("Gemfile").read).to match(/gem "baz", "~> 1.2"/)
+      expect(bundled_app_gemfile.read).to match(/gem "baz", "~> 1.2"/)
       expect(the_bundle).to include_gems "baz 1.2.3"
     end
 
     it "version requirement becomes ~> major.minor.patch.pre when resolved version is < 1.0" do
       bundle "add 'cat'"
-      expect(bundled_app("Gemfile").read).to match(/gem "cat", "~> 0.12.3.pre"/)
+      expect(bundled_app_gemfile.read).to match(/gem "cat", "~> 0.12.3.pre"/)
       expect(the_bundle).to include_gems "cat 0.12.3.pre"
     end
 
     it "version requirement becomes ~> major.minor.pre when resolved version is > 1.0.pre" do
       bundle "add 'dog'"
-      expect(bundled_app("Gemfile").read).to match(/gem "dog", "~> 1.1.pre"/)
+      expect(bundled_app_gemfile.read).to match(/gem "dog", "~> 1.1.pre"/)
       expect(the_bundle).to include_gems "dog 1.1.3.pre"
     end
   end
@@ -56,28 +56,40 @@ RSpec.describe "bundle add" do
   describe "with --version" do
     it "adds dependency of specified version and runs install" do
       bundle "add 'foo' --version='~> 1.0'"
-      expect(bundled_app("Gemfile").read).to match(/gem "foo", "~> 1.0"/)
+      expect(bundled_app_gemfile.read).to match(/gem "foo", "~> 1.0"/)
       expect(the_bundle).to include_gems "foo 1.1"
     end
 
     it "adds multiple version constraints when specified" do
       requirements = ["< 3.0", "> 1.0"]
       bundle "add 'foo' --version='#{requirements.join(", ")}'"
-      expect(bundled_app("Gemfile").read).to match(/gem "foo", #{Gem::Requirement.new(requirements).as_list.map(&:dump).join(', ')}/)
+      expect(bundled_app_gemfile.read).to match(/gem "foo", #{Gem::Requirement.new(requirements).as_list.map(&:dump).join(', ')}/)
       expect(the_bundle).to include_gems "foo 2.0"
     end
   end
 
+  describe "with --require" do
+    it "adds the require param for the gem" do
+      bundle "add 'foo' --require=foo/engine"
+      expect(bundled_app_gemfile.read).to match(%r{gem "foo",(?: .*,) :require => "foo\/engine"})
+    end
+
+    it "converts false to a boolean" do
+      bundle "add 'foo' --require=false"
+      expect(bundled_app_gemfile.read).to match(/gem "foo",(?: .*,) :require => false/)
+    end
+  end
+
   describe "with --group" do
     it "adds dependency for the specified group" do
       bundle "add 'foo' --group='development'"
-      expect(bundled_app("Gemfile").read).to match(/gem "foo", "~> 2.0", :group => :development/)
+      expect(bundled_app_gemfile.read).to match(/gem "foo", "~> 2.0", :group => :development/)
       expect(the_bundle).to include_gems "foo 2.0"
     end
 
     it "adds dependency to more than one group" do
       bundle "add 'foo' --group='development, test'"
-      expect(bundled_app("Gemfile").read).to match(/gem "foo", "~> 2.0", :groups => \[:development, :test\]/)
+      expect(bundled_app_gemfile.read).to match(/gem "foo", "~> 2.0", :groups => \[:development, :test\]/)
       expect(the_bundle).to include_gems "foo 2.0"
     end
   end
@@ -86,16 +98,25 @@ RSpec.describe "bundle add" do
     it "adds dependency with specified source" do
       bundle "add 'foo' --source='#{file_uri_for(gem_repo2)}'"
 
-      expect(bundled_app("Gemfile").read).to match(/gem "foo", "~> 2.0", :source => "#{file_uri_for(gem_repo2)}"/)
+      expect(bundled_app_gemfile.read).to match(/gem "foo", "~> 2.0", :source => "#{file_uri_for(gem_repo2)}"/)
+      expect(the_bundle).to include_gems "foo 2.0"
+    end
+  end
+
+  describe "with --path" do
+    it "adds dependency with specified path" do
+      bundle "add 'foo' --path='#{lib_path("foo-2.0")}'"
+
+      expect(bundled_app_gemfile.read).to match(/gem "foo", "~> 2.0", :path => "#{lib_path("foo-2.0")}"/)
       expect(the_bundle).to include_gems "foo 2.0"
     end
   end
 
   describe "with --git" do
-    it "adds dependency with specified github source" do
+    it "adds dependency with specified git source" do
       bundle "add foo --git=#{lib_path("foo-2.0")}"
 
-      expect(bundled_app("Gemfile").read).to match(/gem "foo", "~> 2.0", :git => "#{lib_path("foo-2.0")}"/)
+      expect(bundled_app_gemfile.read).to match(/gem "foo", "~> 2.0", :git => "#{lib_path("foo-2.0")}"/)
       expect(the_bundle).to include_gems "foo 2.0"
     end
   end
@@ -105,78 +126,111 @@ RSpec.describe "bundle add" do
       update_git "foo", "2.0", :branch => "test"
     end
 
-    it "adds dependency with specified github source and branch" do
+    it "adds dependency with specified git source and branch" do
       bundle "add foo --git=#{lib_path("foo-2.0")} --branch=test"
 
-      expect(bundled_app("Gemfile").read).to match(/gem "foo", "~> 2.0", :git => "#{lib_path("foo-2.0")}", :branch => "test"/)
+      expect(bundled_app_gemfile.read).to match(/gem "foo", "~> 2.0", :git => "#{lib_path("foo-2.0")}", :branch => "test"/)
       expect(the_bundle).to include_gems "foo 2.0"
     end
   end
 
+  describe "with --git and --ref" do
+    it "adds dependency with specified git source and branch" do
+      bundle "add foo --git=#{lib_path("foo-2.0")} --ref=#{revision_for(lib_path("foo-2.0"))}"
+
+      expect(bundled_app_gemfile.read).to match(/gem "foo", "~> 2\.0", :git => "#{lib_path("foo-2.0")}", :ref => "#{revision_for(lib_path("foo-2.0"))}"/)
+      expect(the_bundle).to include_gems "foo 2.0"
+    end
+  end
+
+  describe "with --github" do
+    it "adds dependency with specified github source" do
+      bundle "add rake --github=ruby/rake"
+
+      expect(bundled_app_gemfile.read).to match(%r{gem "rake", "~> 13\.0", :github => "ruby\/rake"})
+    end
+  end
+
+  describe "with --github and --branch" do
+    it "adds dependency with specified github source and branch" do
+      bundle "add rake --github=ruby/rake --branch=master"
+
+      expect(bundled_app_gemfile.read).to match(%r{gem "rake", "~> 13\.0", :github => "ruby\/rake", :branch => "master"})
+    end
+  end
+
+  describe "with --github and --ref" do
+    it "adds dependency with specified github source and ref" do
+      bundle "add rake --github=ruby/rake --ref=5c60da8"
+
+      expect(bundled_app_gemfile.read).to match(%r{gem "rake", "~> 13\.0", :github => "ruby\/rake", :ref => "5c60da8"})
+    end
+  end
+
   describe "with --skip-install" do
     it "adds gem to Gemfile but is not installed" do
       bundle "add foo --skip-install --version=2.0"
 
-      expect(bundled_app("Gemfile").read).to match(/gem "foo", "= 2.0"/)
+      expect(bundled_app_gemfile.read).to match(/gem "foo", "= 2.0"/)
       expect(the_bundle).to_not include_gems "foo 2.0"
     end
   end
 
   it "using combination of short form options works like long form" do
     bundle "add 'foo' -s='#{file_uri_for(gem_repo2)}' -g='development' -v='~>1.0'"
-    expect(bundled_app("Gemfile").read).to include %(gem "foo", "~> 1.0", :group => :development, :source => "#{file_uri_for(gem_repo2)}")
+    expect(bundled_app_gemfile.read).to include %(gem "foo", "~> 1.0", :group => :development, :source => "#{file_uri_for(gem_repo2)}")
     expect(the_bundle).to include_gems "foo 1.1"
   end
 
   it "shows error message when version is not formatted correctly" do
-    bundle "add 'foo' -v='~>1 . 0'"
+    bundle "add 'foo' -v='~>1 . 0'", :raise_on_error => false
     expect(err).to match("Invalid gem requirement pattern '~>1 . 0'")
   end
 
   it "shows error message when gem cannot be found" do
     bundle "config set force_ruby_platform true"
-    bundle "add 'werk_it'"
+    bundle "add 'werk_it'", :raise_on_error => false
     expect(err).to match("Could not find gem 'werk_it' in")
 
-    bundle "add 'werk_it' -s='#{file_uri_for(gem_repo2)}'"
+    bundle "add 'werk_it' -s='#{file_uri_for(gem_repo2)}'", :raise_on_error => false
     expect(err).to match("Could not find gem 'werk_it' in rubygems repository")
   end
 
   it "shows error message when source cannot be reached" do
-    bundle "add 'baz' --source='http://badhostasdf'"
+    bundle "add 'baz' --source='http://badhostasdf'", :raise_on_error => false
     expect(err).to include("Could not reach host badhostasdf. Check your network connection and try again.")
 
-    bundle "add 'baz' --source='file://does/not/exist'"
+    bundle "add 'baz' --source='file://does/not/exist'", :raise_on_error => false
     expect(err).to include("Could not fetch specs from file://does/not/exist/")
   end
 
   describe "with --optimistic" do
     it "adds optimistic version" do
-      bundle! "add 'foo' --optimistic"
-      expect(bundled_app("Gemfile").read).to include %(gem "foo", ">= 2.0")
+      bundle "add 'foo' --optimistic"
+      expect(bundled_app_gemfile.read).to include %(gem "foo", ">= 2.0")
       expect(the_bundle).to include_gems "foo 2.0"
     end
   end
 
   describe "with --strict option" do
     it "adds strict version" do
-      bundle! "add 'foo' --strict"
-      expect(bundled_app("Gemfile").read).to include %(gem "foo", "= 2.0")
+      bundle "add 'foo' --strict"
+      expect(bundled_app_gemfile.read).to include %(gem "foo", "= 2.0")
       expect(the_bundle).to include_gems "foo 2.0"
     end
   end
 
   describe "with no option" do
     it "adds pessimistic version" do
-      bundle! "add 'foo'"
-      expect(bundled_app("Gemfile").read).to include %(gem "foo", "~> 2.0")
+      bundle "add 'foo'"
+      expect(bundled_app_gemfile.read).to include %(gem "foo", "~> 2.0")
       expect(the_bundle).to include_gems "foo 2.0"
     end
   end
 
   describe "with --optimistic and --strict" do
     it "throws error" do
-      bundle "add 'foo' --strict --optimistic"
+      bundle "add 'foo' --strict --optimistic", :raise_on_error => false
 
       expect(err).to include("You can not specify `--strict` and `--optimistic` at the same time")
     end
@@ -184,14 +238,14 @@ RSpec.describe "bundle add" do
 
   context "multiple gems" do
     it "adds multiple gems to gemfile" do
-      bundle! "add bar baz"
+      bundle "add bar baz"
 
-      expect(bundled_app("Gemfile").read).to match(/gem "bar", "~> 0.12.3"/)
-      expect(bundled_app("Gemfile").read).to match(/gem "baz", "~> 1.2"/)
+      expect(bundled_app_gemfile.read).to match(/gem "bar", "~> 0.12.3"/)
+      expect(bundled_app_gemfile.read).to match(/gem "baz", "~> 1.2"/)
     end
 
     it "throws error if any of the specified gems are present in the gemfile with different version" do
-      bundle "add weakling bar"
+      bundle "add weakling bar", :raise_on_error => false
 
       expect(err).to include("You cannot specify the same gem twice with different version requirements")
       expect(err).to include("You specified: weakling (~> 0.0.1) and weakling (>= 0).")
@@ -205,7 +259,7 @@ RSpec.describe "bundle add" do
         gem "rack", "1.0"
       G
 
-      bundle "add 'rack' --version=1.1"
+      bundle "add 'rack' --version=1.1", :raise_on_error => false
 
       expect(err).to include("You cannot specify the same gem twice with different version requirements")
       expect(err).to include("If you want to update the gem version, run `bundle update rack`. You may also need to change the version requirement specified in the Gemfile if it's too restrictive")
@@ -217,7 +271,7 @@ RSpec.describe "bundle add" do
         gem "rack", "1.0"
       G
 
-      bundle "add 'rack'"
+      bundle "add 'rack'", :raise_on_error => false
 
       expect(err).to include("Gem already added.")
       expect(err).to include("You cannot specify the same gem twice with different version requirements")
@@ -232,7 +286,7 @@ RSpec.describe "bundle add" do
         gem "rack"
       G
 
-      bundle "add 'rack' --version=1.1"
+      bundle "add 'rack' --version=1.1", :raise_on_error => false
 
       expect(err).to include("You cannot specify the same gem twice with different version requirements")
       expect(err).to include("If you want to update the gem version, run `bundle update rack`.")
@@ -242,7 +296,7 @@ RSpec.describe "bundle add" do
 
   describe "when a gem is added and cache exists" do
     it "caches all new dependencies added for the specified gem" do
-      bundle! :cache
+      bundle :cache
 
       bundle "add 'rack' --version=1.0.0"
       expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
--- ruby2.7-2.7.6.orig/spec/bundler/commands/binstubs_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/binstubs_spec.rb
@@ -40,25 +40,37 @@ RSpec.describe "bundle binstubs <gem>" d
     end
 
     it "allows installing all binstubs" do
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rails"
       G
 
-      bundle! :binstubs, :all => true
+      bundle :binstubs, :all => true
 
       expect(bundled_app("bin/rails")).to exist
       expect(bundled_app("bin/rake")).to exist
     end
 
+    it "allows installing binstubs for all platforms" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      bundle "binstubs rack --all-platforms"
+
+      expect(bundled_app("bin/rackup")).to exist
+      expect(bundled_app("bin/rackup.cmd")).to exist
+    end
+
     it "displays an error when used without any gem" do
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
 
-      bundle "binstubs"
-      expect(exitstatus).to eq(1) if exitstatus
+      bundle "binstubs", :raise_on_error => false
+      expect(exitstatus).to eq(1)
       expect(err).to include("`bundle binstubs` needs at least one gem to run.")
     end
 
@@ -68,7 +80,7 @@ RSpec.describe "bundle binstubs <gem>" d
         gem "rack"
       G
 
-      bundle "binstubs rack", :all => true
+      bundle "binstubs rack", :all => true, :raise_on_error => false
       expect(last_command).to be_failure
       expect(err).to include("Cannot specify --all with specific gems")
     end
@@ -82,11 +94,11 @@ RSpec.describe "bundle binstubs <gem>" d
 
         bundle "binstubs rack"
 
-        File.open("bin/bundle", "wb") do |file|
+        File.open(bundled_app("bin/bundle"), "wb") do |file|
           file.print "OMG"
         end
 
-        sys_exec "bin/rackup"
+        sys_exec "bin/rackup", :raise_on_error => false
 
         expect(err).to include("was not generated by Bundler")
       end
@@ -94,49 +106,49 @@ RSpec.describe "bundle binstubs <gem>" d
 
     context "the bundle binstub" do
       before do
-        if system_bundler_version == :bundler
-          system_gems :bundler
-        elsif system_bundler_version
-          build_repo4 do
-            build_gem "bundler", system_bundler_version do |s|
-              s.executables = "bundle"
-              s.bindir = "exe"
-              s.write "exe/bundle", "puts %(system bundler #{system_bundler_version}\\n\#{ARGV.inspect})"
-            end
-          end
-          system_gems "bundler-#{system_bundler_version}", :gem_repo => gem_repo4
-        end
+        pristine_system_gems "bundler-#{system_bundler_version}"
         build_repo2 do
+          build_gem "rack", "1.2" do |s|
+            s.executables = "rackup"
+          end
+
           build_gem "prints_loaded_gems", "1.0" do |s|
             s.executables = "print_loaded_gems"
             s.bindir = "exe"
             s.write "exe/print_loaded_gems", <<-R
-              specs = Gem.loaded_specs.values.reject {|s| Bundler.rubygems.spec_default_gem?(s) }
+              specs = Gem.loaded_specs.values.reject {|s| s.default_gem? }
               puts specs.map(&:full_name).sort.inspect
             R
           end
         end
-        install_gemfile! <<-G
+        install_gemfile <<-G
           source "#{file_uri_for(gem_repo2)}"
           gem "rack"
           gem "prints_loaded_gems"
         G
-        bundle! "binstubs bundler rack prints_loaded_gems"
+        bundle "binstubs bundler rack prints_loaded_gems"
       end
 
       let(:system_bundler_version) { Bundler::VERSION }
 
       it "runs bundler" do
-        sys_exec! "#{bundled_app("bin/bundle")} install"
-        expect(out).to eq %(system bundler #{system_bundler_version}\n["install"])
+        sys_exec "bin/bundle install", :env => { "DEBUG" => "1" }
+        expect(out).to include %(Using bundler #{system_bundler_version}\n)
       end
 
       context "when BUNDLER_VERSION is set" do
         it "runs the correct version of bundler" do
-          sys_exec "#{bundled_app("bin/bundle")} install", "BUNDLER_VERSION" => "999.999.999"
-          expect(exitstatus).to eq(42) if exitstatus
-          expect(err).to include("Activating bundler (~> 999.999) failed:").
-            and include("To install the version of bundler this project requires, run `gem install bundler -v '~> 999.999'`")
+          sys_exec "bin/bundle install", :env => { "BUNDLER_VERSION" => "999.999.999" }, :raise_on_error => false
+          expect(exitstatus).to eq(42)
+          expect(err).to include("Activating bundler (999.999.999) failed:").
+            and include("To install the version of bundler this project requires, run `gem install bundler -v '999.999.999'`")
+        end
+
+        it "runs the correct version of bundler even if a higher version is installed" do
+          system_gems "bundler-999.999.998", "bundler-999.999.999"
+
+          sys_exec "bin/bundle install", :env => { "BUNDLER_VERSION" => "999.999.998", "DEBUG" => "1" }, :raise_on_error => false
+          expect(out).to include %(Using bundler 999.999.998\n)
         end
       end
 
@@ -147,8 +159,8 @@ RSpec.describe "bundle binstubs <gem>" d
           end
 
           it "runs the correct version of bundler" do
-            sys_exec "#{bundled_app("bin/bundle")} install"
-            expect(exitstatus).to eq(42) if exitstatus
+            sys_exec "bin/bundle install", :raise_on_error => false
+            expect(exitstatus).to eq(42)
             expect(err).to include("Activating bundler (~> 999.999) failed:").
               and include("To install the version of bundler this project requires, run `gem install bundler -v '~> 999.999'`")
           end
@@ -162,24 +174,34 @@ RSpec.describe "bundle binstubs <gem>" d
           end
 
           it "runs the correct version of bundler" do
-            sys_exec "#{bundled_app("bin/bundle")} install"
-            expect(exitstatus).to eq(42) if exitstatus
+            sys_exec "bin/bundle install", :raise_on_error => false
+            expect(exitstatus).to eq(42)
             expect(err).to include("Activating bundler (~> 44.0) failed:").
               and include("To install the version of bundler this project requires, run `gem install bundler -v '~> 44.0'`")
           end
         end
 
         context "and the version is older and the same major" do
-          let(:system_bundler_version) { "55.1" }
+          let(:system_bundler_version) { "2.999.999" }
 
           before do
-            lockfile lockfile.gsub(/BUNDLED WITH\n   .*$/m, "BUNDLED WITH\n   55.0")
+            lockfile lockfile.gsub(/BUNDLED WITH\n   .*$/m, "BUNDLED WITH\n   2.3.0")
           end
 
-          it "runs the available version of bundler when the version is older and the same major" do
-            sys_exec "#{bundled_app("bin/bundle")} install"
-            expect(exitstatus).not_to eq(42) if exitstatus
-            expect(err).not_to include("Activating bundler (~> 55.0) failed:")
+          it "installs and runs the exact version of bundler", :rubygems => ">= 3.3.0.dev" do
+            sys_exec "bin/bundle install --verbose", :artifice => "vcr"
+            expect(exitstatus).not_to eq(42)
+            expect(out).to include("Bundler 2.999.999 is running, but your lockfile was generated with 2.3.0. Installing Bundler 2.3.0 and restarting using that version.")
+            expect(out).to include("Using bundler 2.3.0")
+            expect(err).not_to include("Activating bundler (~> 2.3.0) failed:")
+          end
+
+          it "runs the available version of bundler", :rubygems => "< 3.3.0.dev" do
+            sys_exec "bin/bundle install --verbose"
+            expect(exitstatus).not_to eq(42)
+            expect(out).not_to include("Bundler 2.999.999 is running, but your lockfile was generated with 2.3.0. Installing Bundler 2.3.0 and restarting using that version.")
+            expect(out).to include("Using bundler 2.999.999")
+            expect(err).not_to include("Activating bundler (~> 2.3.0) failed:")
           end
         end
 
@@ -191,8 +213,8 @@ RSpec.describe "bundle binstubs <gem>" d
           end
 
           it "runs the correct version of bundler when the version is a pre-release" do
-            sys_exec "#{bundled_app("bin/bundle")} install"
-            expect(exitstatus).to eq(42) if exitstatus
+            sys_exec "bin/bundle install", :raise_on_error => false
+            expect(exitstatus).to eq(42)
             expect(err).to include("Activating bundler (~> 2.12.a) failed:").
               and include("To install the version of bundler this project requires, run `gem install bundler -v '~> 2.12.a'`")
           end
@@ -203,30 +225,32 @@ RSpec.describe "bundle binstubs <gem>" d
         before { lockfile.gsub(system_bundler_version, "1.1.1") }
 
         it "calls through to the latest bundler version" do
-          sys_exec! "#{bundled_app("bin/bundle")} update --bundler"
-          expect(out).to eq %(system bundler #{system_bundler_version}\n["update", "--bundler"])
+          sys_exec "bin/bundle update --bundler", :env => { "DEBUG" => "1" }
+          using_bundler_line = /Using bundler ([\w\.]+)\n/.match(out)
+          expect(using_bundler_line).to_not be_nil
+          latest_version = using_bundler_line[1]
+          expect(Gem::Version.new(latest_version)).to be >= Gem::Version.new(system_bundler_version)
         end
 
         it "calls through to the explicit bundler version" do
-          sys_exec "#{bundled_app("bin/bundle")} update --bundler=999.999.999"
-          expect(exitstatus).to eq(42) if exitstatus
-          expect(err).to include("Activating bundler (~> 999.999) failed:").
-            and include("To install the version of bundler this project requires, run `gem install bundler -v '~> 999.999'`")
+          sys_exec "bin/bundle update --bundler=999.999.999", :raise_on_error => false
+          expect(exitstatus).to eq(42)
+          expect(err).to include("Activating bundler (999.999.999) failed:").
+            and include("To install the version of bundler this project requires, run `gem install bundler -v '999.999.999'`")
         end
       end
 
       context "without a lockfile" do
         it "falls back to the latest installed bundler" do
-          FileUtils.rm bundled_app("Gemfile.lock")
-          sys_exec! bundled_app("bin/bundle").to_s
-          expect(out).to eq "system bundler #{system_bundler_version}\n[]"
+          FileUtils.rm bundled_app_lock
+          sys_exec "bin/bundle install", :env => { "DEBUG" => "1" }
+          expect(out).to include "Using bundler #{system_bundler_version}\n"
         end
       end
 
       context "using another binstub" do
-        let(:system_bundler_version) { :bundler }
         it "loads all gems" do
-          sys_exec! bundled_app("bin/print_loaded_gems").to_s
+          sys_exec bundled_app("bin/print_loaded_gems").to_s
           expect(out).to eq %(["bundler-#{Bundler::VERSION}", "prints_loaded_gems-1.0", "rack-1.2"])
         end
 
@@ -234,8 +258,8 @@ RSpec.describe "bundle binstubs <gem>" d
           before { lockfile lockfile.gsub(Bundler::VERSION, "999.999.999") }
 
           it "attempts to load that version" do
-            sys_exec bundled_app("bin/rackup").to_s
-            expect(exitstatus).to eq(42) if exitstatus
+            sys_exec bundled_app("bin/rackup").to_s, :raise_on_error => false
+            expect(exitstatus).to eq(42)
             expect(err).to include("Activating bundler (~> 999.999) failed:").
               and include("To install the version of bundler this project requires, run `gem install bundler -v '~> 999.999'`")
           end
@@ -250,6 +274,7 @@ RSpec.describe "bundle binstubs <gem>" d
         s.executables = %w[foo]
       end
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{lib_path("foo")}"
       G
 
@@ -265,6 +290,7 @@ RSpec.describe "bundle binstubs <gem>" d
         s.executables = %w[foo]
       end
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :path => "#{lib_path("foo")}"
       G
 
@@ -282,7 +308,7 @@ RSpec.describe "bundle binstubs <gem>" d
 
         bundle "binstubs rack"
         binary = bundled_app("bin/rackup")
-        expect(File.stat(binary).mode.to_s(8)).to eq("100775")
+        expect(File.stat(binary).mode.to_s(8)).to eq(Gem.win_platform? ? "100644" : "100775")
       end
     end
 
@@ -294,8 +320,7 @@ RSpec.describe "bundle binstubs <gem>" d
         G
 
         bundle "binstubs rack --shebang jruby"
-
-        expect(File.open("bin/rackup").gets).to eq("#!/usr/bin/env jruby\n")
+        expect(File.readlines(bundled_app("bin/rackup")).first).to eq("#!/usr/bin/env jruby\n")
       end
     end
   end
@@ -306,9 +331,9 @@ RSpec.describe "bundle binstubs <gem>" d
         source "#{file_uri_for(gem_repo1)}"
       G
 
-      bundle "binstubs doesnt_exist"
+      bundle "binstubs doesnt_exist", :raise_on_error => false
 
-      expect(exitstatus).to eq(7) if exitstatus
+      expect(exitstatus).to eq(7)
       expect(err).to include("Could not find gem 'doesnt_exist'.")
     end
   end
@@ -332,8 +357,8 @@ RSpec.describe "bundle binstubs <gem>" d
         gem "rails"
       G
 
-      bundle! "binstubs rack", :path => "exec"
-      bundle! :install
+      bundle "binstubs rack", :path => "exec"
+      bundle :install
 
       expect(bundled_app("exec/rails")).to exist
     end
@@ -348,21 +373,29 @@ RSpec.describe "bundle binstubs <gem>" d
     end
 
     it "generates a standalone binstub" do
-      bundle! "binstubs rack --standalone"
+      bundle "binstubs rack --standalone"
       expect(bundled_app("bin/rackup")).to exist
     end
 
     it "generates a binstub that does not depend on rubygems or bundler" do
-      bundle! "binstubs rack --standalone"
+      bundle "binstubs rack --standalone"
       expect(File.read(bundled_app("bin/rackup"))).to_not include("Gem.bin_path")
     end
 
     context "when specified --path option" do
       it "generates a standalone binstub at the given path" do
-        bundle! "binstubs rack --standalone --path foo"
+        bundle "binstubs rack --standalone --path foo"
         expect(bundled_app("foo/rackup")).to exist
       end
     end
+
+    context "when specified --all-platforms option" do
+      it "generates standalone binstubs for all platforms" do
+        bundle "binstubs rack --standalone --all-platforms"
+        expect(bundled_app("bin/rackup")).to exist
+        expect(bundled_app("bin/rackup.cmd")).to exist
+      end
+    end
   end
 
   context "when the bin already exists" do
@@ -428,8 +461,14 @@ RSpec.describe "bundle binstubs <gem>" d
     end
 
     it "works if the gem has development dependencies" do
+      build_repo2 do
+        build_gem "with_development_dependency" do |s|
+          s.add_development_dependency "activesupport", "= 2.3.5"
+        end
+      end
+
       install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
+        source "#{file_uri_for(gem_repo2)}"
         gem "with_development_dependency"
       G
 
--- ruby2.7-2.7.6.orig/spec/bundler/commands/cache_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/cache_spec.rb
@@ -1,6 +1,19 @@
 # frozen_string_literal: true
 
 RSpec.describe "bundle cache" do
+  it "doesn't update the cache multiple times, even if it already exists" do
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "rack"
+    G
+
+    bundle :cache
+    expect(out).to include("Updating files in vendor/cache").once
+
+    bundle :cache
+    expect(out).to include("Updating files in vendor/cache").once
+  end
+
   context "with --gemfile" do
     it "finds the gemfile" do
       gemfile bundled_app("NotGemfile"), <<-G
@@ -56,7 +69,7 @@ RSpec.describe "bundle cache" do
           D
 
           bundle "config set cache_all true"
-          bundle! :cache
+          bundle :cache
 
           expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
           expect(bundled_app("vendor/cache/nokogiri-1.4.2.gem")).to exist
@@ -88,7 +101,7 @@ RSpec.describe "bundle cache" do
           D
 
           bundle "config set cache_all true"
-          bundle! :cache
+          bundle :cache
 
           expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
           expect(bundled_app("vendor/cache/nokogiri-1.4.2.gem")).to exist
@@ -133,7 +146,7 @@ RSpec.describe "bundle cache" do
         D
 
         bundle "config set cache_all true"
-        bundle! :cache
+        bundle :cache
 
         expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
         expect(bundled_app("vendor/cache/nokogiri-1.4.2.gem")).to exist
@@ -152,7 +165,7 @@ RSpec.describe "bundle cache" do
         gem 'rack'
       D
 
-      bundle! :cache, forgotten_command_line_options(:path => bundled_app("test"))
+      bundle "cache --path #{bundled_app("test")}"
 
       expect(the_bundle).to include_gems "rack 1.0.0"
       expect(bundled_app("test/vendor/cache/")).to exist
@@ -166,7 +179,7 @@ RSpec.describe "bundle cache" do
         gem 'rack'
       D
 
-      bundle! "cache --no-install"
+      bundle "cache --no-install"
 
       expect(the_bundle).not_to include_gems "rack 1.0.0"
       expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
@@ -178,8 +191,8 @@ RSpec.describe "bundle cache" do
         gem 'rack'
       D
 
-      bundle! "cache --no-install"
-      bundle! "install"
+      bundle "cache --no-install"
+      bundle "install"
 
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
@@ -190,8 +203,8 @@ RSpec.describe "bundle cache" do
         gem "rack", "1.0.0"
       D
 
-      bundle! "cache --no-install"
-      bundle! "update --all"
+      bundle "cache --no-install"
+      bundle "update --all"
 
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
@@ -201,7 +214,7 @@ RSpec.describe "bundle cache" do
     it "puts the gems in vendor/cache even for other rubies" do
       gemfile <<-D
         source "#{file_uri_for(gem_repo1)}"
-        gem 'rack', :platforms => :ruby_19
+        gem 'rack', :platforms => [:ruby_20, :x64_mingw_20]
       D
 
       bundle "cache --all-platforms"
@@ -217,28 +230,45 @@ RSpec.describe "bundle cache" do
         end
       end
 
-      install_gemfile! <<-G, forgotten_command_line_options(:without => "wo")
-        source "file:#{gem_repo1}"
+      bundle "config set --local without wo"
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "rack"
         group :wo do
           gem "weakling"
-          gem "uninstallable", :source => "file:#{gem_repo4}"
+          gem "uninstallable", :source => "#{file_uri_for(gem_repo4)}"
         end
       G
 
-      bundle! :cache, "all-platforms" => true
+      bundle :cache, "all-platforms" => true
       expect(bundled_app("vendor/cache/weakling-0.0.3.gem")).to exist
       expect(bundled_app("vendor/cache/uninstallable-2.0.gem")).to exist
       expect(the_bundle).to include_gem "rack 1.0"
       expect(the_bundle).not_to include_gems "weakling", "uninstallable"
 
-      bundle! :install, forgotten_command_line_options(:without => "wo")
+      bundle "config set --local without wo"
+      bundle :install
       expect(the_bundle).to include_gem "rack 1.0"
       expect(the_bundle).not_to include_gems "weakling", "uninstallable"
     end
+
+    it "does not fail to cache gems in excluded groups when there's a lockfile but gems not previously installed" do
+      bundle "config set --local without wo"
+      gemfile <<-G
+        source "https://my.gem.repo.1"
+        gem "rack"
+        group :wo do
+          gem "weakling"
+        end
+      G
+
+      bundle :lock, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo1.to_s }
+      bundle :cache, "all-platforms" => true, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo1.to_s }
+      expect(bundled_app("vendor/cache/weakling-0.0.3.gem")).to exist
+    end
   end
 
-  context "with --frozen" do
+  context "with frozen configured" do
     before do
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
@@ -247,17 +277,20 @@ RSpec.describe "bundle cache" do
       bundle "install"
     end
 
-    subject { bundle :cache, forgotten_command_line_options(:frozen => true) }
+    subject do
+      bundle "config set --local frozen true"
+      bundle :cache, :raise_on_error => false
+    end
 
     it "tries to install with frozen" do
-      bundle! "config set deployment true"
+      bundle "config set deployment true"
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
         gem "rack-obama"
       G
       subject
-      expect(exitstatus).to eq(16) if exitstatus
+      expect(exitstatus).to eq(16)
       expect(err).to include("deployment mode")
       expect(err).to include("You have added to the Gemfile")
       expect(err).to include("* rack-obama")
@@ -265,6 +298,30 @@ RSpec.describe "bundle cache" do
       expect(out).to include("frozen").or include("deployment")
     end
   end
+
+  context "with gems with extensions" do
+    before do
+      build_repo2 do
+        build_gem "racc", "2.0" do |s|
+          s.add_dependency "rake"
+          s.extensions << "Rakefile"
+          s.write "Rakefile", "task(:default) { puts 'INSTALLING rack' }"
+        end
+      end
+
+      gemfile <<~G
+        source "#{file_uri_for(gem_repo2)}"
+
+        gem "racc"
+      G
+    end
+
+    it "installs them properly from cache to a different path" do
+      bundle "cache"
+      bundle "config set --local path vendor/bundle"
+      bundle "install --local"
+    end
+  end
 end
 
 RSpec.describe "bundle install with gem sources" do
@@ -284,18 +341,38 @@ RSpec.describe "bundle install with gem 
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
-    it "does not hit the remote at all" do
+    it "does not hit the remote at all in frozen mode" do
+      build_repo2
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "rack"
+      G
+
+      bundle :cache
+      simulate_new_machine
+      FileUtils.rm_rf gem_repo2
+
+      bundle "config set --local deployment true"
+      bundle "config set --local path vendor/bundle"
+      bundle :install
+      expect(the_bundle).to include_gems "rack 1.0.0"
+    end
+
+    it "does not hit the remote at all when cache_all_platforms configured" do
       build_repo2
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
         gem "rack"
       G
 
-      bundle! :cache
+      bundle :cache
       simulate_new_machine
       FileUtils.rm_rf gem_repo2
 
-      bundle! :install, forgotten_command_line_options(:deployment => true, :path => "vendor/bundle")
+      bundle "config set --local cache_all_platforms true"
+      bundle "config set --local path vendor/bundle"
+      bundle "install --local"
+      expect(out).not_to include("Fetching gem metadata")
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
@@ -326,14 +403,14 @@ RSpec.describe "bundle install with gem 
 
       simulate_new_machine
 
-      simulate_platform "ruby" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "platform_specific"
-        G
-        run "require 'platform_specific' ; puts PLATFORM_SPECIFIC"
-        expect(out).to eq("1.0.0 RUBY")
-      end
+      bundle "config set --local force_ruby_platform true"
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "platform_specific"
+      G
+      run "require 'platform_specific' ; puts PLATFORM_SPECIFIC"
+      expect(out).to eq("1.0.0 RUBY")
     end
 
     it "does not update the cache if --no-cache is passed" do
--- ruby2.7-2.7.6.orig/spec/bundler/commands/check_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/check_spec.rb
@@ -8,7 +8,6 @@ RSpec.describe "bundle check" do
     G
 
     bundle :check
-    expect(exitstatus).to eq(0) if exitstatus
     expect(out).to include("The Gemfile's dependencies are satisfied")
   end
 
@@ -18,8 +17,7 @@ RSpec.describe "bundle check" do
       gem "rails"
     G
 
-    Dir.chdir tmp
-    bundle "check --gemfile bundled_app/Gemfile"
+    bundle "check --gemfile bundled_app/Gemfile", :dir => tmp
     expect(out).to include("The Gemfile's dependencies are satisfied")
   end
 
@@ -29,11 +27,11 @@ RSpec.describe "bundle check" do
       gem "rails"
     G
 
-    FileUtils.rm("Gemfile.lock")
+    FileUtils.rm(bundled_app_lock)
 
     bundle "check"
 
-    expect(bundled_app("Gemfile.lock")).to exist
+    expect(bundled_app_lock).to exist
   end
 
   it "does not create a Gemfile.lock if --dry-run was passed" do
@@ -42,11 +40,11 @@ RSpec.describe "bundle check" do
       gem "rails"
     G
 
-    FileUtils.rm("Gemfile.lock")
+    FileUtils.rm(bundled_app_lock)
 
     bundle "check --dry-run"
 
-    expect(bundled_app("Gemfile.lock")).not_to exist
+    expect(bundled_app_lock).not_to exist
   end
 
   it "prints a generic error if the missing gems are unresolvable" do
@@ -57,7 +55,7 @@ RSpec.describe "bundle check" do
       gem "rails"
     G
 
-    bundle :check
+    bundle :check, :raise_on_error => false
     expect(err).to include("Bundler can't satisfy your Gemfile's dependencies.")
   end
 
@@ -67,28 +65,30 @@ RSpec.describe "bundle check" do
       gem "rails"
     G
 
-    bundle :check
-    expect(exitstatus).to be > 0 if exitstatus
+    bundle :check, :raise_on_error => false
+    expect(exitstatus).to be > 0
     expect(err).to include("Bundler can't satisfy your Gemfile's dependencies.")
   end
 
   it "prints a generic message if you changed your lockfile" do
+    build_repo2 do
+      build_gem "rails_pinned_to_old_activesupport" do |s|
+        s.add_dependency "activesupport", "= 1.2.3"
+      end
+    end
+
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+      source "#{file_uri_for(gem_repo2)}"
       gem 'rails'
     G
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
-      gem 'rails_fail'
-    G
 
     gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+      source "#{file_uri_for(gem_repo2)}"
       gem "rails"
-      gem "rails_fail"
+      gem "rails_pinned_to_old_activesupport"
     G
 
-    bundle :check
+    bundle :check, :raise_on_error => false
     expect(err).to include("Bundler can't satisfy your Gemfile's dependencies.")
   end
 
@@ -100,21 +100,21 @@ RSpec.describe "bundle check" do
       end
     G
 
-    bundle! "install --without foo"
-    bundle! "check"
+    bundle "install --without foo"
+    bundle "check"
     expect(out).to include("The Gemfile's dependencies are satisfied")
   end
 
   it "uses the without setting" do
-    bundle! "config set without foo"
-    install_gemfile! <<-G
+    bundle "config set without foo"
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       group :foo do
         gem "rack"
       end
     G
 
-    bundle! "check"
+    bundle "check"
     expect(out).to include("The Gemfile's dependencies are satisfied")
   end
 
@@ -124,16 +124,33 @@ RSpec.describe "bundle check" do
       gem "rack", :group => :foo
     G
 
-    bundle :install, forgotten_command_line_options(:without => "foo")
+    bundle "config set --local without foo"
+    bundle :install
 
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
 
-    bundle "check"
+    bundle "check", :raise_on_error => false
+    expect(err).to include("* rack (1.0.0)")
+    expect(exitstatus).to eq(1)
+  end
+
+  it "ensures that gems are actually installed and not just cached in applications' cache" do
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "rack"
+    G
+
+    bundle "config set --local path vendor/bundle"
+    bundle :cache
+
+    gem_command "uninstall rack", :env => { "GEM_HOME" => vendored_gems.to_s }
+
+    bundle "check", :raise_on_error => false
     expect(err).to include("* rack (1.0.0)")
-    expect(exitstatus).to eq(1) if exitstatus
+    expect(exitstatus).to eq(1)
   end
 
   it "ignores missing gems restricted to other platforms" do
@@ -145,7 +162,7 @@ RSpec.describe "bundle check" do
       end
     G
 
-    system_gems "rack-1.0.0", :path => :bundle_path
+    system_gems "rack-1.0.0", :path => default_bundle_path
 
     lockfile <<-G
       GEM
@@ -176,7 +193,7 @@ RSpec.describe "bundle check" do
       end
     G
 
-    system_gems "rack-1.0.0", :path => :bundle_path
+    system_gems "rack-1.0.0", :path => default_bundle_path
 
     lockfile <<-G
       GEM
@@ -199,42 +216,28 @@ RSpec.describe "bundle check" do
   end
 
   it "outputs an error when the default Gemfile is not found" do
-    bundle :check
-    expect(exitstatus).to eq(10) if exitstatus
+    bundle :check, :raise_on_error => false
+    expect(exitstatus).to eq(10)
     expect(err).to include("Could not locate Gemfile")
   end
 
   it "does not output fatal error message" do
-    bundle :check
-    expect(exitstatus).to eq(10) if exitstatus
+    bundle :check, :raise_on_error => false
+    expect(exitstatus).to eq(10)
     expect(err).not_to include("Unfortunately, a fatal error has occurred. ")
   end
 
-  it "should not crash when called multiple times on a new machine" do
-    gemfile <<-G
-      gem 'rails', '3.0.0.beta3'
-      gem 'paperclip', :git => 'git://github.com/thoughtbot/paperclip.git'
-    G
-
-    simulate_new_machine
-    bundle "check"
-    last_out = out
-    3.times do
-      bundle :check
-      expect(out).to eq(last_out)
-    end
-  end
-
   it "fails when there's no lock file and frozen is set" do
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "foo"
     G
 
-    bundle! "install", forgotten_command_line_options(:deployment => true)
-    FileUtils.rm(bundled_app("Gemfile.lock"))
+    bundle "config set --local deployment true"
+    bundle "install"
+    FileUtils.rm(bundled_app_lock)
 
-    bundle :check
+    bundle :check, :raise_on_error => false
     expect(last_command).to be_failure
   end
 
@@ -251,13 +254,13 @@ RSpec.describe "bundle check" do
       end
 
       it "returns success" do
-        bundle! "check --path vendor/bundle"
+        bundle "check --path vendor/bundle"
         expect(out).to include("The Gemfile's dependencies are satisfied")
       end
 
       it "should write to .bundle/config" do
         bundle "check --path vendor/bundle"
-        bundle! "check"
+        bundle "check"
       end
     end
 
@@ -268,11 +271,11 @@ RSpec.describe "bundle check" do
           gem "rails"
         G
 
-        bundle "check --path vendor/bundle"
+        bundle "check --path vendor/bundle", :raise_on_error => false
       end
 
       it "returns false" do
-        expect(exitstatus).to eq(1) if exitstatus
+        expect(exitstatus).to eq(1)
         expect(err).to match(/The following gems are missing/)
       end
     end
@@ -290,21 +293,210 @@ RSpec.describe "bundle check" do
     it "returns success when the Gemfile is satisfied" do
       bundle :install
       bundle :check
-      expect(exitstatus).to eq(0) if exitstatus
       expect(out).to include("The Gemfile's dependencies are satisfied")
     end
 
     it "shows what is missing with the current Gemfile if it is not satisfied" do
       simulate_new_machine
-      bundle :check
+      bundle :check, :raise_on_error => false
       expect(err).to match(/The following gems are missing/)
       expect(err).to include("* rack (1.0")
     end
   end
 
+  describe "when locked with multiple dependents with different requirements" do
+    before :each do
+      build_repo4 do
+        build_gem "depends_on_rack" do |s|
+          s.add_dependency "rack", ">= 1.0"
+        end
+        build_gem "also_depends_on_rack" do |s|
+          s.add_dependency "rack", "~> 1.0"
+        end
+        build_gem "rack"
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "depends_on_rack"
+        gem "also_depends_on_rack"
+      G
+
+      bundle "lock"
+    end
+
+    it "shows what is missing with the current Gemfile without duplications" do
+      bundle :check, :raise_on_error => false
+      expect(err).to match(/The following gems are missing/)
+      expect(err).to include("* rack (1.0").once
+    end
+  end
+
+  describe "when locked under multiple platforms" do
+    before :each do
+      build_repo4 do
+        build_gem "rack"
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "rack"
+      G
+
+      lockfile <<-L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            rack (1.0)
+
+        PLATFORMS
+          ruby
+          #{specific_local_platform}
+
+        DEPENDENCIES
+          rack
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+
+    it "shows what is missing with the current Gemfile without duplications" do
+      bundle :check, :raise_on_error => false
+      expect(err).to match(/The following gems are missing/)
+      expect(err).to include("* rack (1.0").once
+    end
+  end
+
+  describe "when using only scoped rubygems sources" do
+    before do
+      gemfile <<~G
+        source "#{file_uri_for(gem_repo2)}"
+        source "#{file_uri_for(gem_repo1)}" do
+          gem "rack"
+        end
+      G
+    end
+
+    it "returns success when the Gemfile is satisfied" do
+      system_gems "rack-1.0.0", :path => default_bundle_path
+      bundle :check
+      expect(out).to include("The Gemfile's dependencies are satisfied")
+    end
+  end
+
+  describe "when using only scoped rubygems sources with indirect dependencies" do
+    before do
+      build_repo4 do
+        build_gem "depends_on_rack" do |s|
+          s.add_dependency "rack"
+        end
+
+        build_gem "rack"
+      end
+
+      gemfile <<~G
+        source "#{file_uri_for(gem_repo1)}"
+        source "#{file_uri_for(gem_repo4)}" do
+          gem "depends_on_rack"
+        end
+      G
+    end
+
+    it "returns success when the Gemfile is satisfied and generates a correct lockfile" do
+      system_gems "depends_on_rack-1.0", "rack-1.0", :gem_repo => gem_repo4, :path => default_bundle_path
+      bundle :check
+      expect(out).to include("The Gemfile's dependencies are satisfied")
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo1)}/
+          specs:
+
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            depends_on_rack (1.0)
+              rack
+            rack (1.0)
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          depends_on_rack!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+  end
+
+  context "with gemspec directive and scoped sources" do
+    before do
+      build_repo4 do
+        build_gem "awesome_print"
+      end
+
+      build_repo2 do
+        build_gem "dex-dispatch-engine"
+      end
+
+      build_lib("bundle-check-issue", :path => tmp.join("bundle-check-issue")) do |s|
+        s.write "Gemfile", <<-G
+          source "https://localgemserver.test"
+
+          gemspec
+
+          source "https://localgemserver.test/extra" do
+            gem "dex-dispatch-engine"
+          end
+        G
+
+        s.add_dependency "awesome_print"
+      end
+
+      bundle "install", :artifice => "compact_index_extra", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }, :dir => tmp.join("bundle-check-issue")
+    end
+
+    it "does not corrupt lockfile when changing version" do
+      version_file = tmp.join("bundle-check-issue/bundle-check-issue.gemspec")
+      File.write(version_file, File.read(version_file).gsub(/s\.version = .+/, "s.version = '9999'"))
+
+      bundle "check --verbose", :dir => tmp.join("bundle-check-issue")
+
+      expect(File.read(tmp.join("bundle-check-issue/Gemfile.lock"))).to eq <<~L
+        PATH
+          remote: .
+          specs:
+            bundle-check-issue (9999)
+              awesome_print
+
+        GEM
+          remote: https://localgemserver.test/
+          specs:
+            awesome_print (1.0)
+
+        GEM
+          remote: https://localgemserver.test/extra/
+          specs:
+            dex-dispatch-engine (1.0)
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          bundle-check-issue!
+          dex-dispatch-engine!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+  end
+
   describe "BUNDLED WITH" do
     def lock_with(bundler_version = nil)
-      lock = <<-L
+      lock = <<~L
         GEM
           remote: #{file_uri_for(gem_repo1)}/
           specs:
@@ -318,13 +510,15 @@ RSpec.describe "bundle check" do
       L
 
       if bundler_version
-        lock += "\n        BUNDLED WITH\n           #{bundler_version}\n"
+        lock += "\nBUNDLED WITH\n   #{bundler_version}\n"
       end
 
       lock
     end
 
     before do
+      bundle "config set --local path vendor/bundle"
+
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
@@ -335,24 +529,25 @@ RSpec.describe "bundle check" do
       it "does not change the lock" do
         lockfile lock_with(nil)
         bundle :check
-        lockfile_should_be lock_with(nil)
+        expect(lockfile).to eq lock_with(nil)
       end
     end
 
     context "is newer" do
-      it "does not change the lock but warns" do
+      it "does not change the lock and does not warn" do
         lockfile lock_with(Bundler::VERSION.succ)
-        bundle! :check
-        expect(err).to include("the running version of Bundler (#{Bundler::VERSION}) is older than the version that created the lockfile (#{Bundler::VERSION.succ})")
-        lockfile_should_be lock_with(Bundler::VERSION.succ)
+        bundle :check
+        expect(err).to be_empty
+        expect(lockfile).to eq lock_with(Bundler::VERSION.succ)
       end
     end
 
     context "is older" do
       it "does not change the lock" do
-        lockfile lock_with("1.10.1")
+        system_gems "bundler-1.18.0"
+        lockfile lock_with("1.18.0")
         bundle :check
-        lockfile_should_be lock_with("1.10.1")
+        expect(lockfile).to eq lock_with("1.18.0")
       end
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/clean_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/clean_spec.rb
@@ -27,16 +27,16 @@ RSpec.describe "bundle clean" do
 
     bundle "config set path vendor/bundle"
     bundle "config set clean false"
-    bundle! "install"
+    bundle "install"
 
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
 
       gem "thin"
     G
-    bundle! "install"
+    bundle "install"
 
-    bundle! :clean
+    bundle :clean
 
     expect(out).to include("Removing foo (1.0)")
 
@@ -86,7 +86,7 @@ RSpec.describe "bundle clean" do
 
     bundle "config set path vendor/bundle"
     bundle "config set clean false"
-    bundle! "install"
+    bundle "install"
 
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
@@ -94,9 +94,9 @@ RSpec.describe "bundle clean" do
       gem "rack", "0.9.1"
       gem "foo"
     G
-    bundle! "update rack"
+    bundle "update rack"
 
-    bundle! :clean
+    bundle :clean
 
     expect(out).to include("Removing rack (1.0.0)")
 
@@ -199,7 +199,7 @@ RSpec.describe "bundle clean" do
     revision = revision_for(git_path)
 
     gemfile <<-G
-      source "file://#{gem_repo1}"
+      source "#{file_uri_for(gem_repo1)}"
 
       gem "rack", "1.0.0"
       git "#{git_path}", :ref => "#{revision}" do
@@ -208,7 +208,7 @@ RSpec.describe "bundle clean" do
     G
 
     FileUtils.mkdir_p(bundled_app("real-path"))
-    FileUtils.ln_sf(bundled_app("real-path"), bundled_app("symlink-path"))
+    File.symlink(bundled_app("real-path"), bundled_app("symlink-path"))
 
     bundle "config set path #{bundled_app("symlink-path")}"
     bundle "install"
@@ -234,13 +234,13 @@ RSpec.describe "bundle clean" do
     G
 
     bundle "config set path vendor/bundle"
-    bundle! "install"
+    bundle "install"
 
-    update_git "foo", :path => lib_path("foo-bar")
+    update_git "foo-bar", :path => lib_path("foo-bar")
     revision2 = revision_for(lib_path("foo-bar"))
 
-    bundle! "update", :all => true
-    bundle! :clean
+    bundle "update", :all => true
+    bundle :clean
 
     expect(out).to include("Removing foo-bar (#{revision[0..11]})")
 
@@ -261,6 +261,7 @@ RSpec.describe "bundle clean" do
     revision = revision_for(lib_path("rails"))
 
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "activesupport", :git => "#{lib_path("rails")}", :ref => '#{revision}'
     G
 
@@ -315,20 +316,19 @@ RSpec.describe "bundle clean" do
     bundle "install"
 
     bundle :clean
-    expect(exitstatus).to eq(0) if exitstatus
   end
 
   it "displays an error when used without --path" do
-    bundle! "config set path.system true"
+    bundle "config set path.system true"
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
 
       gem "rack", "1.0.0"
     G
 
-    bundle :clean
+    bundle :clean, :raise_on_error => false
 
-    expect(exitstatus).to eq(15) if exitstatus
+    expect(exitstatus).to eq(15)
     expect(err).to include("--force")
   end
 
@@ -364,22 +364,22 @@ RSpec.describe "bundle clean" do
   end
 
   it "does not call clean automatically when using system gems" do
-    bundle! "config set path.system true"
+    bundle "config set path.system true"
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
 
       gem "thin"
       gem "rack"
     G
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
 
       gem "rack"
     G
 
-    gem_command! :list
+    gem_command :list
     expect(out).to include("rack (1.0.0)").and include("thin (1.0)")
   end
 
@@ -421,7 +421,7 @@ RSpec.describe "bundle clean" do
       build_gem "foo", "1.0.1"
     end
 
-    bundle! "update", :all => true
+    bundle "update", :all => true
 
     should_have_gems "foo-1.0.1"
     should_not_have_gems "foo-1.0"
@@ -430,7 +430,7 @@ RSpec.describe "bundle clean" do
   it "automatically cleans when path has not been set", :bundler => "3" do
     build_repo2
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo2)}"
 
       gem "foo"
@@ -440,7 +440,7 @@ RSpec.describe "bundle clean" do
       build_gem "foo", "1.0.1"
     end
 
-    bundle! "update", :all => true
+    bundle "update", :all => true
 
     files = Pathname.glob(bundled_app(".bundle", Bundler.ruby_scope, "*", "*"))
     files.map! {|f| f.to_s.sub(bundled_app(".bundle", Bundler.ruby_scope).to_s, "") }
@@ -480,18 +480,18 @@ RSpec.describe "bundle clean" do
       gem "foo"
     G
     bundle "config set path vendor/bundle"
-    bundle! "install"
+    bundle "install"
 
     update_repo2 do
       build_gem "foo", "1.0.1"
     end
 
-    bundle! :update, :all => true
+    bundle :update, :all => true
     should_have_gems "foo-1.0", "foo-1.0.1"
   end
 
   it "does not clean on bundle update when using --system" do
-    bundle! "config set path.system true"
+    bundle "config set path.system true"
 
     build_repo2
 
@@ -500,19 +500,19 @@ RSpec.describe "bundle clean" do
 
       gem "foo"
     G
-    bundle! "install"
+    bundle "install"
 
     update_repo2 do
       build_gem "foo", "1.0.1"
     end
-    bundle! :update, :all => true
+    bundle :update, :all => true
 
-    gem_command! :list
+    gem_command :list
     expect(out).to include("foo (1.0.1, 1.0)")
   end
 
   it "cleans system gems when --force is used" do
-    bundle! "config set path.system true"
+    bundle "config set path.system true"
 
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
@@ -531,12 +531,12 @@ RSpec.describe "bundle clean" do
     bundle "clean --force"
 
     expect(out).to include("Removing foo (1.0)")
-    gem_command! :list
+    gem_command :list
     expect(out).not_to include("foo (1.0)")
     expect(out).to include("rack (1.0.0)")
   end
 
-  describe "when missing permissions" do
+  describe "when missing permissions", :permissions do
     before { ENV["BUNDLE_PATH__SYSTEM"] = "true" }
     let(:system_cache_path) { system_gem_path("cache") }
     after do
@@ -560,12 +560,12 @@ RSpec.describe "bundle clean" do
 
       FileUtils.chmod(0o500, system_cache_path)
 
-      bundle :clean, :force => true
+      bundle :clean, :force => true, :raise_on_error => false
 
       expect(err).to include(system_gem_path.to_s)
       expect(err).to include("grant write permissions")
 
-      gem_command! :list
+      gem_command :list
       expect(out).to include("foo (1.0)")
       expect(out).to include("rack (1.0.0)")
     end
@@ -585,11 +585,11 @@ RSpec.describe "bundle clean" do
     bundle "install"
 
     # mimic 7 length git revisions in Gemfile.lock
-    gemfile_lock = File.read(bundled_app("Gemfile.lock")).split("\n")
+    gemfile_lock = File.read(bundled_app_lock).split("\n")
     gemfile_lock.each_with_index do |line, index|
       gemfile_lock[index] = line[0..(11 + 7)] if line.include?("  revision:")
     end
-    lockfile(bundled_app("Gemfile.lock"), gemfile_lock.join("\n"))
+    lockfile(bundled_app_lock, gemfile_lock.join("\n"))
 
     bundle "config set path vendor/bundle"
     bundle "install"
@@ -602,10 +602,9 @@ RSpec.describe "bundle clean" do
   end
 
   it "when using --force on system gems, it doesn't remove binaries" do
-    bundle! "config set path.system true"
+    bundle "config set path.system true"
 
-    build_repo2
-    update_repo2 do
+    build_repo2 do
       build_gem "bindir" do |s|
         s.bindir = "exe"
         s.executables = "foo"
@@ -623,10 +622,33 @@ RSpec.describe "bundle clean" do
 
     sys_exec "foo"
 
-    expect(exitstatus).to eq(0) if exitstatus
     expect(out).to eq("1.0")
   end
 
+  it "when using --force, it doesn't remove default gem binaries" do
+    skip "does not work on old rubies because the realworld gems that need to be installed don't support them" if RUBY_VERSION < "2.7.0"
+
+    skip "does not work on rubygems versions where `--install_dir` doesn't respect --default" unless Gem::Installer.for_spec(loaded_gemspec, :install_dir => "/foo").default_spec_file == "/foo/specifications/default/bundler-#{Bundler::VERSION}.gemspec" # Since rubygems 3.2.0.rc.2
+
+    default_irb_version = ruby "gem 'irb', '< 999999'; require 'irb'; puts IRB::VERSION", :raise_on_error => false
+    skip "irb isn't a default gem" if default_irb_version.empty?
+
+    # simulate executable for default gem
+    build_gem "irb", default_irb_version, :to_system => true, :default => true do |s|
+      s.executables = "irb"
+    end
+
+    realworld_system_gems "tsort --version 0.1.0", "pathname --version 0.1.0", "set --version 1.0.1"
+
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo2)}"
+    G
+
+    bundle "clean --force", :env => { "BUNDLER_GEM_DEFAULT_DIR" => system_gem_path.to_s }
+
+    expect(out).not_to include("Removing irb")
+  end
+
   it "doesn't blow up on path gems without a .gemspec" do
     relative_path = "vendor/private_gems/bar-1.0"
     absolute_path = bundled_app(relative_path)
@@ -644,7 +666,7 @@ RSpec.describe "bundle clean" do
 
     bundle "config set path vendor/bundle"
     bundle "install"
-    bundle! :clean
+    bundle :clean
   end
 
   it "doesn't remove gems in dry-run mode with path set" do
@@ -749,7 +771,7 @@ RSpec.describe "bundle clean" do
 
     bundle "config set path vendor/bundle"
     bundle "config set clean false"
-    bundle! "install"
+    bundle "install"
 
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
@@ -758,14 +780,14 @@ RSpec.describe "bundle clean" do
       gem "weakling"
     G
 
-    bundle! "config set auto_install 1"
-    bundle! :clean
+    bundle "config set auto_install 1"
+    bundle :clean
     expect(out).to include("Installing weakling 0.0.3")
     should_have_gems "thin-1.0", "rack-1.0.0", "weakling-0.0.3"
     should_not_have_gems "foo-1.0"
   end
 
-  it "doesn't remove extensions artifacts from bundled git gems after clean", :ruby_repo do
+  it "doesn't remove extensions artifacts from bundled git gems after clean" do
     build_git "very_simple_git_binary", &:add_c_extension
 
     revision = revision_for(lib_path("very_simple_git_binary-1.0"))
@@ -777,18 +799,18 @@ RSpec.describe "bundle clean" do
     G
 
     bundle "config set path vendor/bundle"
-    bundle! "install"
+    bundle "install"
     expect(vendored_gems("bundler/gems/extensions")).to exist
     expect(vendored_gems("bundler/gems/very_simple_git_binary-1.0-#{revision[0..11]}")).to exist
 
-    bundle! :clean
+    bundle :clean
     expect(out).to be_empty
 
     expect(vendored_gems("bundler/gems/extensions")).to exist
     expect(vendored_gems("bundler/gems/very_simple_git_binary-1.0-#{revision[0..11]}")).to exist
   end
 
-  it "removes extension directories", :ruby_repo do
+  it "removes extension directories" do
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
 
@@ -798,7 +820,7 @@ RSpec.describe "bundle clean" do
     G
 
     bundle "config set path vendor/bundle"
-    bundle! "install"
+    bundle "install"
 
     very_simple_binary_extensions_dir =
       Pathname.glob("#{vendored_gems}/extensions/*/*/very_simple_binary-1.0").first
@@ -816,15 +838,15 @@ RSpec.describe "bundle clean" do
       gem "simple_binary"
     G
 
-    bundle! "install"
-    bundle! :clean
+    bundle "install"
+    bundle :clean
     expect(out).to eq("Removing very_simple_binary (1.0)")
 
     expect(very_simple_binary_extensions_dir).not_to exist
     expect(simple_binary_extensions_dir).to exist
   end
 
-  it "removes git extension directories", :ruby_repo do
+  it "removes git extension directories" do
     build_git "very_simple_git_binary", &:add_c_extension
 
     revision = revision_for(lib_path("very_simple_git_binary-1.0"))
@@ -838,7 +860,7 @@ RSpec.describe "bundle clean" do
     G
 
     bundle "config set path vendor/bundle"
-    bundle! "install"
+    bundle "install"
 
     very_simple_binary_extensions_dir =
       Pathname.glob("#{vendored_gems}/bundler/gems/extensions/*/*/very_simple_git_binary-1.0-#{short_revision}").first
@@ -846,25 +868,27 @@ RSpec.describe "bundle clean" do
     expect(very_simple_binary_extensions_dir).to exist
 
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "very_simple_git_binary", :git => "#{lib_path("very_simple_git_binary-1.0")}", :ref => "#{revision}"
     G
 
-    bundle! "install"
-    bundle! :clean
+    bundle "install"
+    bundle :clean
     expect(out).to include("Removing thin (1.0)")
     expect(very_simple_binary_extensions_dir).to exist
 
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
     G
 
-    bundle! "install"
-    bundle! :clean
+    bundle "install"
+    bundle :clean
     expect(out).to eq("Removing very_simple_git_binary-1.0 (#{short_revision})")
 
     expect(very_simple_binary_extensions_dir).not_to exist
   end
 
-  it "keeps git extension directories when excluded by group", :ruby_repo do
+  it "keeps git extension directories when excluded by group" do
     build_git "very_simple_git_binary", &:add_c_extension
 
     revision = revision_for(lib_path("very_simple_git_binary-1.0"))
@@ -881,8 +905,8 @@ RSpec.describe "bundle clean" do
     bundle :lock
     bundle "config set without development"
     bundle "config set path vendor/bundle"
-    bundle! "install"
-    bundle! :clean
+    bundle "install"
+    bundle :clean
 
     very_simple_binary_extensions_dir =
       Pathname.glob("#{vendored_gems}/bundler/gems/extensions/*/*/very_simple_git_binary-1.0-#{short_revision}").first
--- ruby2.7-2.7.6.orig/spec/bundler/commands/config_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/config_spec.rb
@@ -35,7 +35,7 @@ RSpec.describe ".bundle/config" do
     end
   end
 
-  describe "location" do
+  describe "location with a gemfile" do
     before :each do
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
@@ -43,9 +43,16 @@ RSpec.describe ".bundle/config" do
       G
     end
 
+    it "is local by default" do
+      bundle "config set foo bar"
+      expect(bundled_app(".bundle/config")).to exist
+      expect(home(".bundle/config")).not_to exist
+    end
+
     it "can be moved with an environment variable" do
       ENV["BUNDLE_APP_CONFIG"] = tmp("foo/bar").to_s
-      bundle "install", forgotten_command_line_options(:path => "vendor/bundle")
+      bundle "config set --local path vendor/bundle"
+      bundle "install"
 
       expect(bundled_app(".bundle")).not_to exist
       expect(tmp("foo/bar/config")).to exist
@@ -54,14 +61,54 @@ RSpec.describe ".bundle/config" do
 
     it "can provide a relative path with the environment variable" do
       FileUtils.mkdir_p bundled_app("omg")
-      Dir.chdir bundled_app("omg")
 
       ENV["BUNDLE_APP_CONFIG"] = "../foo"
-      bundle "install", forgotten_command_line_options(:path => "vendor/bundle")
+      bundle "config set --local path vendor/bundle"
+      bundle "install", :dir => bundled_app("omg")
 
       expect(bundled_app(".bundle")).not_to exist
       expect(bundled_app("../foo/config")).to exist
-      expect(the_bundle).to include_gems "rack 1.0.0"
+      expect(the_bundle).to include_gems "rack 1.0.0", :dir => bundled_app("omg")
+    end
+  end
+
+  describe "location without a gemfile" do
+    it "is global by default" do
+      bundle "config set foo bar"
+      expect(bundled_app(".bundle/config")).not_to exist
+      expect(home(".bundle/config")).to exist
+    end
+
+    it "works with an absolute path" do
+      ENV["BUNDLE_APP_CONFIG"] = tmp("foo/bar").to_s
+      bundle "config set --local path vendor/bundle"
+
+      expect(bundled_app(".bundle")).not_to exist
+      expect(tmp("foo/bar/config")).to exist
+    end
+  end
+
+  describe "config location" do
+    let(:bundle_user_config) { File.join(Dir.home, ".config/bundler") }
+
+    before do
+      Dir.mkdir File.dirname(bundle_user_config)
+    end
+
+    it "can be configured through BUNDLE_USER_CONFIG" do
+      bundle "config set path vendor", :env => { "BUNDLE_USER_CONFIG" => bundle_user_config }
+      bundle "config get path", :env => { "BUNDLE_USER_CONFIG" => bundle_user_config }
+      expect(out).to include("Set for the current user (#{bundle_user_config}): \"vendor\"")
+    end
+
+    context "when not explicitly configured, but BUNDLE_USER_HOME set" do
+      let(:bundle_user_home) { bundled_app(".bundle").to_s }
+
+      it "uses the right location" do
+        bundle "config set path vendor", :env => { "BUNDLE_USER_HOME" => bundle_user_home }
+        bundle "config get path", :env => { "BUNDLE_USER_HOME" => bundle_user_home }
+        expect(out).to include("Set for the current user (#{bundle_user_home}/config): \"vendor\"")
+      end
     end
   end
 
@@ -80,8 +127,8 @@ RSpec.describe ".bundle/config" do
     end
 
     it "can also be set explicitly" do
-      bundle! "config set --global foo global"
-      run! "puts Bundler.settings[:foo]"
+      bundle "config set --global foo global"
+      run "puts Bundler.settings[:foo]"
       expect(out).to eq("global")
     end
 
@@ -138,7 +185,7 @@ RSpec.describe ".bundle/config" do
     it "expands the path at time of setting" do
       bundle "config set --global local.foo .."
       run "puts Bundler.settings['local.foo']"
-      expect(out).to eq(File.expand_path(Dir.pwd + "/.."))
+      expect(out).to eq(File.expand_path(bundled_app.to_s + "/.."))
     end
 
     it "saves with parseable option" do
@@ -205,7 +252,7 @@ RSpec.describe ".bundle/config" do
     it "expands the path at time of setting" do
       bundle "config set --local local.foo .."
       run "puts Bundler.settings['local.foo']"
-      expect(out).to eq(File.expand_path(Dir.pwd + "/.."))
+      expect(out).to eq(File.expand_path(bundled_app.to_s + "/.."))
     end
 
     it "can be deleted with parseable option" do
@@ -310,7 +357,7 @@ E
   end
 
   describe "quoting" do
-    before(:each) { gemfile "# no gems" }
+    before(:each) { gemfile "source \"#{file_uri_for(gem_repo1)}\"" }
     let(:long_string) do
       "--with-xml2-include=/usr/pkg/include/libxml2 --with-xml2-lib=/usr/pkg/lib " \
       "--with-xslt-dir=/usr/pkg"
@@ -324,7 +371,7 @@ E
 
     it "doesn't return quotes around values" do
       bundle "config set foo '1'"
-      run "puts Bundler.settings.send(:global_config_file).read"
+      run "puts Bundler.settings.send(:local_config_file).read"
       expect(out).to include('"1"')
       run "puts Bundler.settings[:foo]"
       expect(out).to eq("1")
@@ -388,87 +435,131 @@ E
     end
   end
 
+  describe "commented out settings with urls" do
+    before do
+      bundle "config set #mirror.https://rails-assets.org http://localhost:9292"
+    end
+
+    it "does not make bundler crash and ignores the configuration" do
+      bundle "config list --parseable"
+
+      expect(out).to eq("#mirror.https://rails-assets.org/=http://localhost:9292")
+      expect(err).to be_empty
+
+      ruby(<<~RUBY)
+        require "#{entrypoint}"
+        print Bundler.settings.mirror_for("https://rails-assets.org")
+      RUBY
+      expect(out).to eq("https://rails-assets.org/")
+      expect(err).to be_empty
+
+      bundle "config set mirror.all http://localhost:9293"
+      ruby(<<~RUBY)
+        require "#{entrypoint}"
+        print Bundler.settings.mirror_for("https://rails-assets.org")
+      RUBY
+      expect(out).to eq("http://localhost:9293/")
+      expect(err).to be_empty
+    end
+  end
+
   describe "subcommands" do
     it "list" do
-      bundle! "config list"
-      expect(out).to eq "Settings are listed in order of priority. The top value will be used.\nspec_run\nSet via BUNDLE_SPEC_RUN: \"true\""
+      bundle "config list", :env => { "BUNDLE_FOO" => "bar" }
+      expect(out).to eq "Settings are listed in order of priority. The top value will be used.\nfoo\nSet via BUNDLE_FOO: \"bar\""
 
-      bundle! "config list", :parseable => true
-      expect(out).to eq "spec_run=true"
+      bundle "config list", :env => { "BUNDLE_FOO" => "bar" }, :parseable => true
+      expect(out).to eq "foo=bar"
+    end
+
+    it "list with credentials" do
+      bundle "config list", :env => { "BUNDLE_GEMS__MYSERVER__COM" => "user:password" }
+      expect(out).to eq "Settings are listed in order of priority. The top value will be used.\ngems.myserver.com\nSet via BUNDLE_GEMS__MYSERVER__COM: \"user:[REDACTED]\""
+
+      bundle "config list", :parseable => true, :env => { "BUNDLE_GEMS__MYSERVER__COM" => "user:password" }
+      expect(out).to eq "gems.myserver.com=user:password"
+    end
+
+    it "list with API token credentials" do
+      bundle "config list", :env => { "BUNDLE_GEMS__MYSERVER__COM" => "api_token:x-oauth-basic" }
+      expect(out).to eq "Settings are listed in order of priority. The top value will be used.\ngems.myserver.com\nSet via BUNDLE_GEMS__MYSERVER__COM: \"[REDACTED]:x-oauth-basic\""
+
+      bundle "config list", :parseable => true, :env => { "BUNDLE_GEMS__MYSERVER__COM" => "api_token:x-oauth-basic" }
+      expect(out).to eq "gems.myserver.com=api_token:x-oauth-basic"
     end
 
     it "get" do
       ENV["BUNDLE_BAR"] = "bar_val"
 
-      bundle! "config get foo"
+      bundle "config get foo"
       expect(out).to eq "Settings for `foo` in order of priority. The top value will be used\nYou have not configured a value for `foo`"
 
       ENV["BUNDLE_FOO"] = "foo_val"
 
-      bundle! "config get foo --parseable"
+      bundle "config get foo --parseable"
       expect(out).to eq "foo=foo_val"
 
-      bundle! "config get foo"
+      bundle "config get foo"
       expect(out).to eq "Settings for `foo` in order of priority. The top value will be used\nSet via BUNDLE_FOO: \"foo_val\""
     end
 
     it "set" do
-      bundle! "config set foo 1"
+      bundle "config set foo 1"
       expect(out).to eq ""
 
-      bundle! "config set --local foo 2"
+      bundle "config set --local foo 2"
       expect(out).to eq ""
 
-      bundle! "config set --global foo 3"
+      bundle "config set --global foo 3"
       expect(out).to eq "Your application has set foo to \"2\". This will override the global value you are currently setting"
 
-      bundle! "config set --parseable --local foo 4"
+      bundle "config set --parseable --local foo 4"
       expect(out).to eq "foo=4"
 
-      bundle! "config set --local foo 4.1"
+      bundle "config set --local foo 4.1"
       expect(out).to eq "You are replacing the current local value of foo, which is currently \"4\""
 
-      bundle "config set --global --local foo 5"
+      bundle "config set --global --local foo 5", :raise_on_error => false
       expect(last_command).to be_failure
       expect(err).to eq "The options global and local were specified. Please only use one of the switches at a time."
     end
 
     it "unset" do
-      bundle! "config unset foo"
+      bundle "config unset foo"
       expect(out).to eq ""
 
-      bundle! "config set foo 1"
-      bundle! "config unset foo --parseable"
+      bundle "config set foo 1"
+      bundle "config unset foo --parseable"
       expect(out).to eq ""
 
-      bundle! "config set --local foo 1"
-      bundle! "config set --global foo 2"
+      bundle "config set --local foo 1"
+      bundle "config set --global foo 2"
 
-      bundle! "config unset foo"
+      bundle "config unset foo"
       expect(out).to eq ""
-      expect(bundle!("config get foo")).to eq "Settings for `foo` in order of priority. The top value will be used\nYou have not configured a value for `foo`"
+      expect(bundle("config get foo")).to eq "Settings for `foo` in order of priority. The top value will be used\nYou have not configured a value for `foo`"
 
-      bundle! "config set --local foo 1"
-      bundle! "config set --global foo 2"
+      bundle "config set --local foo 1"
+      bundle "config set --global foo 2"
 
-      bundle! "config unset foo --local"
+      bundle "config unset foo --local"
       expect(out).to eq ""
-      expect(bundle!("config get foo")).to eq "Settings for `foo` in order of priority. The top value will be used\nSet for the current user (#{home(".bundle/config")}): \"2\""
-      bundle! "config unset foo --global"
+      expect(bundle("config get foo")).to eq "Settings for `foo` in order of priority. The top value will be used\nSet for the current user (#{home(".bundle/config")}): \"2\""
+      bundle "config unset foo --global"
       expect(out).to eq ""
-      expect(bundle!("config get foo")).to eq "Settings for `foo` in order of priority. The top value will be used\nYou have not configured a value for `foo`"
+      expect(bundle("config get foo")).to eq "Settings for `foo` in order of priority. The top value will be used\nYou have not configured a value for `foo`"
 
-      bundle! "config set --local foo 1"
-      bundle! "config set --global foo 2"
+      bundle "config set --local foo 1"
+      bundle "config set --global foo 2"
 
-      bundle! "config unset foo --global"
+      bundle "config unset foo --global"
       expect(out).to eq ""
-      expect(bundle!("config get foo")).to eq "Settings for `foo` in order of priority. The top value will be used\nSet for your local app (#{bundled_app(".bundle/config")}): \"1\""
-      bundle! "config unset foo --local"
+      expect(bundle("config get foo")).to eq "Settings for `foo` in order of priority. The top value will be used\nSet for your local app (#{bundled_app(".bundle/config")}): \"1\""
+      bundle "config unset foo --local"
       expect(out).to eq ""
-      expect(bundle!("config get foo")).to eq "Settings for `foo` in order of priority. The top value will be used\nYou have not configured a value for `foo`"
+      expect(bundle("config get foo")).to eq "Settings for `foo` in order of priority. The top value will be used\nYou have not configured a value for `foo`"
 
-      bundle "config unset foo --local --global"
+      bundle "config unset foo --local --global", :raise_on_error => false
       expect(last_command).to be_failure
       expect(err).to eq "The options global and local were specified. Please only use one of the switches at a time."
     end
@@ -484,7 +575,7 @@ RSpec.describe "setting gemfile via conf
       G
 
       bundle "config set --local gemfile #{bundled_app("NotGemfile")}"
-      expect(File.exist?(".bundle/config")).to eq(true)
+      expect(File.exist?(bundled_app(".bundle/config"))).to eq(true)
 
       bundle "config list"
       expect(out).to include("NotGemfile")
--- ruby2.7-2.7.6.orig/spec/bundler/commands/console_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/console_spec.rb
@@ -1,9 +1,44 @@
 # frozen_string_literal: true
 
-RSpec.describe "bundle console", :bundler => "< 3" do
+RSpec.describe "bundle console", :bundler => "< 3", :readline => true do
   before :each do
+    build_repo2 do
+      # A minimal fake pry console
+      build_gem "pry" do |s|
+        s.write "lib/pry.rb", <<-RUBY
+          class Pry
+            class << self
+              def toplevel_binding
+                unless defined?(@toplevel_binding) && @toplevel_binding
+                  TOPLEVEL_BINDING.eval %{
+                    def self.__pry__; binding; end
+                    Pry.instance_variable_set(:@toplevel_binding, __pry__)
+                    class << self; undef __pry__; end
+                  }
+                end
+                @toplevel_binding.eval('private')
+                @toplevel_binding
+              end
+
+              def __pry__
+                while line = gets
+                  begin
+                    puts eval(line, toplevel_binding).inspect.sub(/^"(.*)"$/, '=> \\1')
+                  rescue Exception => e
+                    puts "\#{e.class}: \#{e.message}"
+                    puts e.backtrace.first
+                  end
+                end
+              end
+              alias start __pry__
+            end
+          end
+        RUBY
+      end
+    end
+
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+      source "#{file_uri_for(gem_repo2)}"
       gem "rack"
       gem "activesupport", :group => :test
       gem "rack_middleware", :group => :development
@@ -20,15 +55,15 @@ RSpec.describe "bundle console", :bundle
 
   it "uses IRB as default console" do
     bundle "console" do |input, _, _|
-      input.puts("__method__")
+      input.puts("__FILE__")
       input.puts("exit")
     end
-    expect(out).to include(":irb_binding")
+    expect(out).to include("(irb)")
   end
 
   it "starts another REPL if configured as such" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+      source "#{file_uri_for(gem_repo2)}"
       gem "pry"
     G
     bundle "config set console pry"
@@ -45,10 +80,10 @@ RSpec.describe "bundle console", :bundle
     # make sure pry isn't there
 
     bundle "console" do |input, _, _|
-      input.puts("__method__")
+      input.puts("__FILE__")
       input.puts("exit")
     end
-    expect(out).to include(":irb_binding")
+    expect(out).to include("(irb)")
   end
 
   it "doesn't load any other groups" do
@@ -87,7 +122,7 @@ RSpec.describe "bundle console", :bundle
 
   it "performs an automatic bundle install" do
     gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+      source "#{file_uri_for(gem_repo2)}"
       gem "rack"
       gem "activesupport", :group => :test
       gem "rack_middleware", :group => :development
--- ruby2.7-2.7.6.orig/spec/bundler/commands/doctor_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/doctor_spec.rb
@@ -7,7 +7,7 @@ require "bundler/cli/doctor"
 
 RSpec.describe "bundle doctor" do
   before(:each) do
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
@@ -24,15 +24,16 @@ RSpec.describe "bundle doctor" do
 
   it "succeeds on a sane installation" do
     bundle :doctor
-
-    expect(exitstatus).to eq(0)
   end
 
   context "when all files in home are readable/writable" do
     before(:each) do
       stat = double("stat")
       unwritable_file = double("file")
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
       allow(Find).to receive(:find).with(Bundler.bundle_path.to_s) { [unwritable_file] }
+      allow(File).to receive(:exist?).and_call_original
+      allow(File).to receive(:exist?).with(unwritable_file).and_return(true)
       allow(File).to receive(:stat).with(unwritable_file) { stat }
       allow(stat).to receive(:uid) { Process.uid }
       allow(File).to receive(:writable?).with(unwritable_file) { true }
@@ -48,9 +49,8 @@ RSpec.describe "bundle doctor" do
       doctor = Bundler::CLI::Doctor.new({})
       expect(doctor).to receive(:bundles_for_gem).exactly(2).times.and_return ["/path/to/rack/rack.bundle"]
       expect(doctor).to receive(:dylibs).exactly(2).times.and_return ["/usr/lib/libSystem.dylib"]
-      allow(File).to receive(:exist?).and_call_original
-      allow(File).to receive(:exist?).with("/usr/lib/libSystem.dylib").and_return(true)
-      expect { doctor.run }.not_to(raise_error, @stdout.string)
+      allow(Fiddle).to receive(:dlopen).with("/usr/lib/libSystem.dylib").and_return(true)
+      expect { doctor.run }.not_to raise_error
       expect(@stdout.string).to be_empty
     end
 
@@ -58,8 +58,7 @@ RSpec.describe "bundle doctor" do
       doctor = Bundler::CLI::Doctor.new({})
       expect(doctor).to receive(:bundles_for_gem).exactly(2).times.and_return ["/path/to/rack/rack.bundle"]
       expect(doctor).to receive(:dylibs).exactly(2).times.and_return ["/usr/local/opt/icu4c/lib/libicui18n.57.1.dylib"]
-      allow(File).to receive(:exist?).and_call_original
-      allow(File).to receive(:exist?).with("/usr/local/opt/icu4c/lib/libicui18n.57.1.dylib").and_return(false)
+      allow(Fiddle).to receive(:dlopen).with("/usr/local/opt/icu4c/lib/libicui18n.57.1.dylib").and_raise(Fiddle::DLError)
       expect { doctor.run }.to raise_error(Bundler::ProductionError, strip_whitespace(<<-E).strip), @stdout.string
         The following gems are missing OS dependencies:
          * bundler: /usr/local/opt/icu4c/lib/libicui18n.57.1.dylib
@@ -68,11 +67,32 @@ RSpec.describe "bundle doctor" do
     end
   end
 
+  context "when home contains broken symlinks" do
+    before(:each) do
+      @broken_symlink = double("file")
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+      allow(Find).to receive(:find).with(Bundler.bundle_path.to_s) { [@broken_symlink] }
+      allow(File).to receive(:exist?).and_call_original
+      allow(File).to receive(:exist?).with(@broken_symlink) { false }
+    end
+
+    it "exits with an error if home contains files that are not readable/writable" do
+      expect { Bundler::CLI::Doctor.new({}).run }.not_to raise_error
+      expect(@stdout.string).to include(
+        "Broken links exist in the Bundler home. Please report them to the offending gem's upstream repo. These files are:\n - #{@broken_symlink}"
+      )
+      expect(@stdout.string).not_to include("No issues")
+    end
+  end
+
   context "when home contains files that are not readable/writable" do
     before(:each) do
       @stat = double("stat")
       @unwritable_file = double("file")
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
       allow(Find).to receive(:find).with(Bundler.bundle_path.to_s) { [@unwritable_file] }
+      allow(File).to receive(:exist?).and_call_original
+      allow(File).to receive(:exist?).with(@unwritable_file) { true }
       allow(File).to receive(:stat).with(@unwritable_file) { @stat }
     end
 
@@ -87,7 +107,7 @@ RSpec.describe "bundle doctor" do
       expect(@stdout.string).not_to include("No issues")
     end
 
-    context "when home contains files that are not owned by the current process" do
+    context "when home contains files that are not owned by the current process", :permissions do
       before(:each) do
         allow(@stat).to receive(:uid) { 0o0000 }
       end
@@ -113,4 +133,14 @@ RSpec.describe "bundle doctor" do
       end
     end
   end
+
+  context "when home contains filesname with special characters" do
+    it "escape filename before command execute" do
+      doctor = Bundler::CLI::Doctor.new({})
+      expect(doctor).to receive(:`).with("/usr/bin/otool -L \\$\\(date\\)\\ \\\"\\'\\\\.bundle").and_return("dummy string")
+      doctor.dylibs_darwin('$(date) "\'\.bundle')
+      expect(doctor).to receive(:`).with("/usr/bin/ldd \\$\\(date\\)\\ \\\"\\'\\\\.bundle").and_return("dummy string")
+      doctor.dylibs_ldd('$(date) "\'\.bundle')
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/exec_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/exec_spec.rb
@@ -3,11 +3,12 @@
 RSpec.describe "bundle exec" do
   let(:system_gems_to_install) { %w[rack-1.0.0 rack-0.9.1] }
   before :each do
-    system_gems(system_gems_to_install, :path => :bundle_path)
+    system_gems(system_gems_to_install, :path => default_bundle_path)
   end
 
   it "works with --gemfile flag" do
     create_file "CustomGemfile", <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "rack", "1.0.0"
     G
 
@@ -17,6 +18,7 @@ RSpec.describe "bundle exec" do
 
   it "activates the correct gem" do
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "rack", "0.9.1"
     G
 
@@ -24,8 +26,20 @@ RSpec.describe "bundle exec" do
     expect(out).to eq("0.9.1")
   end
 
+  it "works and prints no warnings when HOME is not writable" do
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "rack", "0.9.1"
+    G
+
+    bundle "exec rackup", :env => { "HOME" => "/" }
+    expect(out).to eq("0.9.1")
+    expect(err).to be_empty
+  end
+
   it "works when the bins are in ~/.bundle" do
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
 
@@ -35,6 +49,7 @@ RSpec.describe "bundle exec" do
 
   it "works when running from a random directory" do
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
 
@@ -44,53 +59,85 @@ RSpec.describe "bundle exec" do
   end
 
   it "works when exec'ing something else" do
-    install_gemfile 'gem "rack"'
+    install_gemfile "source \"#{file_uri_for(gem_repo1)}\"; gem \"rack\""
     bundle "exec echo exec"
     expect(out).to eq("exec")
   end
 
   it "works when exec'ing to ruby" do
-    install_gemfile 'gem "rack"'
+    install_gemfile "source \"#{file_uri_for(gem_repo1)}\"; gem \"rack\""
     bundle "exec ruby -e 'puts %{hi}'"
     expect(out).to eq("hi")
   end
 
   it "works when exec'ing to rubygems" do
-    install_gemfile 'gem "rack"'
+    install_gemfile "source \"#{file_uri_for(gem_repo1)}\"; gem \"rack\""
     bundle "exec #{gem_cmd} --version"
     expect(out).to eq(Gem::VERSION)
   end
 
   it "works when exec'ing to rubygems through sh -c" do
-    install_gemfile 'gem "rack"'
+    install_gemfile "source \"#{file_uri_for(gem_repo1)}\"; gem \"rack\""
     bundle "exec sh -c '#{gem_cmd} --version'"
     expect(out).to eq(Gem::VERSION)
   end
 
+  it "works when exec'ing back to bundler with a lockfile that doesn't include the current platform" do
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "rack", "0.9.1"
+    G
+
+    # simulate lockfile generated with old version not including specific platform
+    lockfile <<-L
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
+          rack (0.9.1)
+
+      PLATFORMS
+        RUBY
+
+      DEPENDENCIES
+        rack (= 0.9.1)
+
+      BUNDLED WITH
+          2.1.4
+    L
+
+    bundle "exec bundle cache", :env => { "BUNDLER_VERSION" => Bundler::VERSION }
+
+    expect(out).to include("Updating files in vendor/cache")
+  end
+
   it "respects custom process title when loading through ruby" do
+    skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
     script_that_changes_its_own_title_and_checks_if_picked_up_by_ps_unix_utility = <<~'RUBY'
-      Process.setproctitle("1-2-3-4-5-6-7-8-9-10-11-12-13-14-15")
+      Process.setproctitle("1-2-3-4-5-6-7")
       puts `ps -ocommand= -p#{$$}`
     RUBY
-    create_file "Gemfile"
+    create_file "Gemfile", "source \"#{file_uri_for(gem_repo1)}\""
     create_file "a.rb", script_that_changes_its_own_title_and_checks_if_picked_up_by_ps_unix_utility
     bundle "exec ruby a.rb"
-    expect(out).to eq("1-2-3-4-5-6-7-8-9-10-11-12-13-14-15")
+    expect(out).to eq("1-2-3-4-5-6-7")
   end
 
   it "accepts --verbose" do
-    install_gemfile 'gem "rack"'
+    install_gemfile "source \"#{file_uri_for(gem_repo1)}\"; gem \"rack\""
     bundle "exec --verbose echo foobar"
     expect(out).to eq("foobar")
   end
 
   it "passes --verbose to command if it is given after the command" do
-    install_gemfile 'gem "rack"'
+    install_gemfile "source \"#{file_uri_for(gem_repo1)}\"; gem \"rack\""
     bundle "exec echo --verbose"
     expect(out).to eq("--verbose")
   end
 
   it "handles --keep-file-descriptors" do
+    skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
     require "tempfile"
 
     command = Tempfile.new("io-test")
@@ -107,7 +154,7 @@ RSpec.describe "bundle exec" do
       end
     G
 
-    install_gemfile ""
+    install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
     sys_exec "#{Gem.ruby} #{command.path}"
 
     expect(out).to be_empty
@@ -115,19 +162,21 @@ RSpec.describe "bundle exec" do
   end
 
   it "accepts --keep-file-descriptors" do
-    install_gemfile ""
+    install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
     bundle "exec --keep-file-descriptors echo foobar"
 
     expect(err).to be_empty
   end
 
   it "can run a command named --verbose" do
-    install_gemfile 'gem "rack"'
-    File.open("--verbose", "w") do |f|
+    skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+    install_gemfile "source \"#{file_uri_for(gem_repo1)}\"; gem \"rack\""
+    File.open(bundled_app("--verbose"), "w") do |f|
       f.puts "#!/bin/sh"
       f.puts "echo foobar"
     end
-    File.chmod(0o744, "--verbose")
+    File.chmod(0o744, bundled_app("--verbose"))
     with_path_as(".") do
       bundle "exec -- --verbose"
     end
@@ -146,40 +195,35 @@ RSpec.describe "bundle exec" do
       gem "rack", "0.9.1"
     G
 
-    Dir.chdir bundled_app2 do
-      install_gemfile bundled_app2("Gemfile"), <<-G
-        source "#{file_uri_for(gem_repo2)}"
-        gem "rack_two", "1.0.0"
-      G
-    end
+    install_gemfile bundled_app2("Gemfile"), <<-G, :dir => bundled_app2
+      source "#{file_uri_for(gem_repo2)}"
+      gem "rack_two", "1.0.0"
+    G
 
-    bundle! "exec rackup"
+    bundle "exec rackup"
 
     expect(out).to eq("0.9.1")
 
-    Dir.chdir bundled_app2 do
-      bundle! "exec rackup"
-      expect(out).to eq("1.0.0")
-    end
+    bundle "exec rackup", :dir => bundled_app2
+    expect(out).to eq("1.0.0")
   end
 
   context "with default gems" do
     let(:system_gems_to_install) { [] }
 
-    let(:default_irb_version) { ruby "gem 'irb', '< 999999'; require 'irb'; puts IRB::VERSION" }
+    let(:default_irb_version) { ruby "gem 'irb', '< 999999'; require 'irb'; puts IRB::VERSION", :raise_on_error => false }
 
     context "when not specified in Gemfile" do
       before do
         skip "irb isn't a default gem" if default_irb_version.empty?
 
-        install_gemfile ""
+        install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
       end
 
       it "uses version provided by ruby" do
-        bundle! "exec irb --version"
+        bundle "exec irb --version"
 
         expect(out).to include(default_irb_version)
-        expect(err).to be_empty
       end
     end
 
@@ -202,7 +246,7 @@ RSpec.describe "bundle exec" do
       end
 
       it "uses version specified" do
-        bundle! "exec irb --version"
+        bundle "exec irb --version"
 
         expect(out).to eq(specified_irb_version)
         expect(err).to be_empty
@@ -230,7 +274,7 @@ RSpec.describe "bundle exec" do
           gem "gem_depending_on_old_irb"
         G
 
-        bundle! "exec irb --version"
+        bundle "exec irb --version"
       end
 
       it "uses resolved version" do
@@ -247,21 +291,19 @@ RSpec.describe "bundle exec" do
       end
     end
 
-    bundle "config set path.system true"
+    bundle "config set --global path.system true"
 
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "rack", "0.9.1"
     G
 
-    Dir.chdir bundled_app2 do
-      install_gemfile bundled_app2("Gemfile"), <<-G
-        source "#{file_uri_for(gem_repo2)}"
-        gem "rack_two", "1.0.0"
-      G
-    end
+    install_gemfile bundled_app2("Gemfile"), <<-G, :dir => bundled_app2
+      source "#{file_uri_for(gem_repo2)}"
+      gem "rack_two", "1.0.0"
+    G
 
-    bundle! "exec rackup"
+    bundle "exec rackup"
 
     expect(last_command.stderr).to eq(
       "Bundler is using a binstub that was created for a different gem (rack).\n" \
@@ -270,7 +312,8 @@ RSpec.describe "bundle exec" do
   end
 
   it "handles gems installed with --without" do
-    install_gemfile <<-G, forgotten_command_line_options(:without => "middleware")
+    bundle "config set --local without middleware"
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "rack" # rack 0.9.1 and 1.0 exist
 
@@ -286,22 +329,29 @@ RSpec.describe "bundle exec" do
   end
 
   it "does not duplicate already exec'ed RUBYOPT" do
+    skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
 
-    rubyopt = ENV["RUBYOPT"]
-    rubyopt = "-r#{lib_dir}/bundler/setup #{rubyopt}"
+    bundler_setup_opt = "-r#{lib_dir}/bundler/setup"
+
+    rubyopt = opt_add(bundler_setup_opt, ENV["RUBYOPT"])
 
     bundle "exec 'echo $RUBYOPT'"
-    expect(out).to have_rubyopts(rubyopt)
+    expect(out.split(" ").count(bundler_setup_opt)).to eq(1)
 
     bundle "exec 'echo $RUBYOPT'", :env => { "RUBYOPT" => rubyopt }
-    expect(out).to have_rubyopts(rubyopt)
+    expect(out.split(" ").count(bundler_setup_opt)).to eq(1)
   end
 
   it "does not duplicate already exec'ed RUBYLIB" do
+    skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
 
@@ -318,45 +368,48 @@ RSpec.describe "bundle exec" do
 
   it "errors nicely when the argument doesn't exist" do
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
 
-    bundle "exec foobarbaz"
-    expect(exitstatus).to eq(127) if exitstatus
+    bundle "exec foobarbaz", :raise_on_error => false
+    expect(exitstatus).to eq(127)
     expect(err).to include("bundler: command not found: foobarbaz")
     expect(err).to include("Install missing gem executables with `bundle install`")
   end
 
   it "errors nicely when the argument is not executable" do
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
 
     bundle "exec touch foo"
-    bundle "exec ./foo"
-    expect(exitstatus).to eq(126) if exitstatus
+    bundle "exec ./foo", :raise_on_error => false
+    expect(exitstatus).to eq(126)
     expect(err).to include("bundler: not executable: ./foo")
   end
 
   it "errors nicely when no arguments are passed" do
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
 
-    bundle "exec"
-    expect(exitstatus).to eq(128) if exitstatus
+    bundle "exec", :raise_on_error => false
+    expect(exitstatus).to eq(128)
     expect(err).to include("bundler: exec needs a command to run")
   end
 
   it "raises a helpful error when exec'ing to something outside of the bundle" do
-    bundle! "config set clean false" # want to keep the rackup binstub
-    install_gemfile! <<-G
+    bundle "config set clean false" # want to keep the rackup binstub
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
-      gem "with_license"
+      gem "foo"
     G
     [true, false].each do |l|
-      bundle! "config set disable_exec_load #{l}"
-      bundle "exec rackup"
+      bundle "config set disable_exec_load #{l}"
+      bundle "exec rackup", :raise_on_error => false
       expect(err).to include "can't find executable rackup for gem rack. rack is not currently included in the bundle, perhaps you meant to add it to your Gemfile?"
     end
   end
@@ -368,7 +421,10 @@ RSpec.describe "bundle exec" do
     each_prefix.call("exec") do |exec|
       describe "when #{exec} is used" do
         before(:each) do
+          skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
           install_gemfile <<-G
+            source "#{file_uri_for(gem_repo1)}"
             gem "rack"
           G
 
@@ -415,44 +471,45 @@ RSpec.describe "bundle exec" do
           with_fake_man do
             bundle "#{exec} --help cat"
           end
-          expect(out).to include(%(["#{root}/man/bundle-exec.1"]))
+          expect(out).to include(%(["#{man_dir}/bundle-exec.1"]))
         end
 
         it "shows bundle-exec's man page when --help is before exec" do
           with_fake_man do
             bundle "--help #{exec}"
           end
-          expect(out).to include(%(["#{root}/man/bundle-exec.1"]))
+          expect(out).to include(%(["#{man_dir}/bundle-exec.1"]))
         end
 
         it "shows bundle-exec's man page when -h is before exec" do
           with_fake_man do
             bundle "-h #{exec}"
           end
-          expect(out).to include(%(["#{root}/man/bundle-exec.1"]))
+          expect(out).to include(%(["#{man_dir}/bundle-exec.1"]))
         end
 
         it "shows bundle-exec's man page when --help is after exec" do
           with_fake_man do
             bundle "#{exec} --help"
           end
-          expect(out).to include(%(["#{root}/man/bundle-exec.1"]))
+          expect(out).to include(%(["#{man_dir}/bundle-exec.1"]))
         end
 
         it "shows bundle-exec's man page when -h is after exec" do
           with_fake_man do
             bundle "#{exec} -h"
           end
-          expect(out).to include(%(["#{root}/man/bundle-exec.1"]))
+          expect(out).to include(%(["#{man_dir}/bundle-exec.1"]))
         end
       end
     end
   end
 
   describe "with gem executables" do
-    describe "run from a random directory", :ruby_repo do
+    describe "run from a random directory" do
       before(:each) do
         install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           gem "rack"
         G
       end
@@ -476,6 +533,7 @@ RSpec.describe "bundle exec" do
         end
 
         install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           gem "fizz", :path => "#{File.expand_path(home("fizz"))}"
         G
       end
@@ -500,6 +558,7 @@ RSpec.describe "bundle exec" do
         end
 
         install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           gem "fizz_git", :git => "#{lib_path("fizz_git-1.0")}"
         G
       end
@@ -523,6 +582,7 @@ RSpec.describe "bundle exec" do
         end
 
         install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           gem "fizz_no_gemspec", "1.0", :git => "#{lib_path("fizz_no_gemspec-1.0")}"
         G
       end
@@ -552,6 +612,36 @@ RSpec.describe "bundle exec" do
     expect(out).to include("Installing foo 1.0")
   end
 
+  it "loads the correct optparse when `auto_install` is set, and optparse is a dependency" do
+    if Gem.ruby_version >= Gem::Version.new("3.0.0") && Gem.rubygems_version < Gem::Version.new("3.3.0.a")
+      skip "optparse is a default gem, and rubygems loads it during install"
+    end
+
+    build_repo4 do
+      build_gem "fastlane", "2.192.0" do |s|
+        s.executables = "fastlane"
+        s.add_dependency "optparse", "~> 999.999.999"
+      end
+
+      build_gem "optparse", "999.999.998"
+      build_gem "optparse", "999.999.999"
+    end
+
+    system_gems "optparse-999.999.998", :gem_repo => gem_repo4
+
+    bundle "config set auto_install 1"
+    bundle "config set --local path vendor/bundle"
+
+    gemfile <<~G
+      source "#{file_uri_for(gem_repo4)}"
+      gem "fastlane"
+    G
+
+    bundle "exec fastlane"
+    expect(out).to include("Installing optparse 999.999.999")
+    expect(out).to include("2.192.0")
+  end
+
   describe "with gems bundled via :path with invalid gemspecs" do
     it "outputs the gemspec validation errors" do
       build_lib "foo"
@@ -568,11 +658,12 @@ RSpec.describe "bundle exec" do
         G
       end
 
-      install_gemfile <<-G
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :path => "#{lib_path("foo-1.0")}"
       G
 
-      bundle "exec irb"
+      bundle "exec irb", :raise_on_error => false
 
       expect(err).to match("The gemspec at #{lib_path("foo-1.0").join("foo.gemspec")} is not valid")
       expect(err).to match('"TODO" is not a summary')
@@ -581,7 +672,11 @@ RSpec.describe "bundle exec" do
 
   describe "with gems bundled for deployment" do
     it "works when calling bundler from another script" do
+      skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
       gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+
       module Monkey
         def bin_path(a,b,c)
           raise Gem::GemNotFoundException.new('Fail')
@@ -589,8 +684,9 @@ RSpec.describe "bundle exec" do
       end
       Bundler.rubygems.extend(Monkey)
       G
-      bundle "install --deployment"
-      bundle "exec ruby -e '`#{bindir.join("bundler")} -v`; puts $?.success?'"
+      bundle "config set path.system true"
+      bundle "install"
+      bundle "exec ruby -e '`bundle -v`; puts $?.success?'", :env => { "BUNDLER_VERSION" => Bundler::VERSION }
       expect(out).to match("true")
     end
   end
@@ -610,10 +706,11 @@ RSpec.describe "bundle exec" do
     RUBY
 
     before do
-      path.open("w") {|f| f << executable }
-      path.chmod(0o755)
+      bundled_app(path).open("w") {|f| f << executable }
+      bundled_app(path).chmod(0o755)
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
     end
@@ -630,29 +727,42 @@ RSpec.describe "bundle exec" do
     let(:expected) { [exec, args, rack, process].join("\n") }
     let(:expected_err) { "" }
 
-    subject { bundle "exec #{path} arg1 arg2" }
+    subject { bundle "exec #{path} arg1 arg2", :raise_on_error => false }
 
-    shared_examples_for "it runs" do
-      it "like a normally executed executable" do
-        subject
-        expect(exitstatus).to eq(exit_code) if exitstatus
-        expect(err).to eq(expected_err)
-        expect(out).to eq(expected)
-      end
-    end
+    it "runs" do
+      skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
 
-    it_behaves_like "it runs"
+      subject
+      expect(exitstatus).to eq(exit_code)
+      expect(err).to eq(expected_err)
+      expect(out).to eq(expected)
+    end
 
     context "the executable exits explicitly" do
       let(:executable) { super() << "\nexit #{exit_code}\nputs 'POST_EXIT'\n" }
 
       context "with exit 0" do
-        it_behaves_like "it runs"
+        it "runs" do
+          skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+          subject
+          expect(exitstatus).to eq(exit_code)
+          expect(err).to eq(expected_err)
+          expect(out).to eq(expected)
+        end
       end
 
       context "with exit 99" do
         let(:exit_code) { 99 }
-        it_behaves_like "it runs"
+
+        it "runs" do
+          skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+          subject
+          expect(exitstatus).to eq(exit_code)
+          expect(err).to eq(expected_err)
+          expect(out).to eq(expected)
+        end
       end
     end
 
@@ -665,11 +775,17 @@ RSpec.describe "bundle exec" do
       end
       let(:expected_err) { "" }
       let(:exit_code) do
-        # signal mask 128 + plus signal 15 -> TERM
-        # this is specified by C99
-        128 + 15
+        exit_status_for_signal(Signal.list["TERM"])
+      end
+
+      it "runs" do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        subject
+        expect(exitstatus).to eq(exit_code)
+        expect(err).to eq(expected_err)
+        expect(out).to eq(expected)
       end
-      it_behaves_like "it runs"
     end
 
     context "the executable is empty" do
@@ -678,7 +794,15 @@ RSpec.describe "bundle exec" do
       let(:exit_code) { 0 }
       let(:expected_err) { "#{path} is empty" }
       let(:expected) { "" }
-      it_behaves_like "it runs"
+
+      it "runs" do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        subject
+        expect(exitstatus).to eq(exit_code)
+        expect(err).to eq(expected_err)
+        expect(out).to eq(expected)
+      end
     end
 
     context "the executable raises" do
@@ -686,28 +810,52 @@ RSpec.describe "bundle exec" do
       let(:exit_code) { 1 }
       let(:expected_err) do
         "bundler: failed to load command: #{path} (#{path})" \
-        "\nRuntimeError: ERROR\n  #{path}:10:in `<top (required)>'"
+        "\n#{path}:10:in `<top (required)>': ERROR (RuntimeError)"
+      end
+
+      it "runs like a normally executed executable" do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        subject
+        expect(exitstatus).to eq(exit_code)
+        expect(err).to start_with(expected_err)
+        expect(out).to eq(expected)
       end
-      it_behaves_like "it runs"
     end
 
     context "the executable raises an error without a backtrace" do
       let(:executable) { super() << "\nclass Err < Exception\ndef backtrace; end;\nend\nraise Err" }
       let(:exit_code) { 1 }
-      let(:expected_err) { "bundler: failed to load command: #{path} (#{path})\nErr: Err" }
+      let(:expected_err) { "bundler: failed to load command: #{path} (#{path})\n#{system_gem_path("bin/bundle")}: Err (Err)" }
       let(:expected) { super() }
 
-      it_behaves_like "it runs"
+      it "runs" do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        subject
+        expect(exitstatus).to eq(exit_code)
+        expect(err).to eq(expected_err)
+        expect(out).to eq(expected)
+      end
     end
 
     context "when the file uses the current ruby shebang" do
       let(:shebang) { "#!#{Gem.ruby}" }
-      it_behaves_like "it runs"
+
+      it "runs" do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        subject
+        expect(exitstatus).to eq(exit_code)
+        expect(err).to eq(expected_err)
+        expect(out).to eq(expected)
+      end
     end
 
     context "when Bundler.setup fails", :bundler => "< 3" do
       before do
         gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           gem 'rack', '2'
         G
         ENV["BUNDLER_FORCE_TTY"] = "true"
@@ -716,16 +864,28 @@ RSpec.describe "bundle exec" do
       let(:exit_code) { Bundler::GemNotFound.new.status_code }
       let(:expected) { "" }
       let(:expected_err) { <<-EOS.strip }
-\e[31mCould not find gem 'rack (= 2)' in any of the gem sources listed in your Gemfile.\e[0m
-\e[33mRun `bundle install` to install missing gems.\e[0m
+Could not find gem 'rack (= 2)' in locally installed gems.
+
+The source contains the following gems matching 'rack':
+  * rack-0.9.1
+  * rack-1.0.0
+Run `bundle install` to install missing gems.
       EOS
 
-      it_behaves_like "it runs"
+      it "runs" do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        subject
+        expect(exitstatus).to eq(exit_code)
+        expect(err).to eq(expected_err)
+        expect(out).to eq(expected)
+      end
     end
 
     context "when Bundler.setup fails", :bundler => "3" do
       before do
         gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           gem 'rack', '2'
         G
         ENV["BUNDLER_FORCE_TTY"] = "true"
@@ -734,19 +894,35 @@ RSpec.describe "bundle exec" do
       let(:exit_code) { Bundler::GemNotFound.new.status_code }
       let(:expected) { "" }
       let(:expected_err) { <<-EOS.strip }
-\e[31mCould not find gem 'rack (= 2)' in locally installed gems.
-The source contains 'rack' at: 1.0.0\e[0m
-\e[33mRun `bundle install` to install missing gems.\e[0m
+Could not find gem 'rack (= 2)' in locally installed gems.
+
+The source contains the following gems matching 'rack':
+  * rack-1.0.0
+Run `bundle install` to install missing gems.
       EOS
 
-      it_behaves_like "it runs"
+      it "runs" do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        subject
+        expect(exitstatus).to eq(exit_code)
+        expect(err).to eq(expected_err)
+        expect(out).to eq(expected)
+      end
     end
 
     context "when the executable exits non-zero via at_exit" do
       let(:executable) { super() + "\n\nat_exit { $! ? raise($!) : exit(1) }" }
       let(:exit_code) { 1 }
 
-      it_behaves_like "it runs"
+      it "runs" do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        subject
+        expect(exitstatus).to eq(exit_code)
+        expect(err).to eq(expected_err)
+        expect(out).to eq(expected)
+      end
     end
 
     context "when disable_exec_load is set" do
@@ -757,7 +933,14 @@ The source contains 'rack' at: 1.0.0\e[0
         bundle "config set disable_exec_load true"
       end
 
-      it_behaves_like "it runs"
+      it "runs" do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        subject
+        expect(exitstatus).to eq(exit_code)
+        expect(err).to eq(expected_err)
+        expect(out).to eq(expected)
+      end
     end
 
     context "regarding $0 and __FILE__" do
@@ -773,16 +956,30 @@ $0: #{path.to_s.inspect}
 __FILE__: #{path.to_s.inspect}
       EOS
 
-      it_behaves_like "it runs"
+      it "runs" do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        subject
+        expect(exitstatus).to eq(exit_code)
+        expect(err).to eq(expected_err)
+        expect(out).to eq(expected)
+      end
 
       context "when the path is relative" do
         let(:path) { super().relative_path_from(bundled_app) }
 
-        it_behaves_like "it runs"
+        it "runs" do
+          skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+          subject
+          expect(exitstatus).to eq(exit_code)
+          expect(err).to eq(expected_err)
+          expect(out).to eq(expected)
+        end
       end
 
       context "when the path is relative with a leading ./" do
-        let(:path) { Pathname.new("./#{super().relative_path_from(Pathname.pwd)}") }
+        let(:path) { Pathname.new("./#{super().relative_path_from(bundled_app)}") }
 
         pending "relative paths with ./ have absolute __FILE__"
       end
@@ -813,7 +1010,9 @@ __FILE__: #{path.to_s.inspect}
         RUBY
 
         it "receives the signal" do
-          bundle!("exec #{path}") do |_, o, thr|
+          skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+          bundle("exec #{path}") do |_, o, thr|
             o.gets # Consumes 'Started' and ensures that thread has started
             Process.kill("INT", thr.pid)
           end
@@ -834,11 +1033,13 @@ __FILE__: #{path.to_s.inspect}
         RUBY
 
         it "makes sure no unexpected signals are restored to DEFAULT" do
+          skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
           test_signals.each do |n|
             Signal.trap(n, "IGNORE")
           end
 
-          bundle!("exec #{path}")
+          bundle("exec #{path}")
 
           expect(out).to eq(test_signals.count.to_s)
         end
@@ -849,65 +1050,176 @@ __FILE__: #{path.to_s.inspect}
   context "nested bundle exec" do
     context "when bundle in a local path" do
       before do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
         gemfile <<-G
           source "#{file_uri_for(gem_repo1)}"
           gem "rack"
         G
         bundle "config set path vendor/bundler"
-        bundle! :install
+        bundle :install
       end
 
-      it "correctly shells out", :ruby_repo do
+      it "correctly shells out" do
         file = bundled_app("file_that_bundle_execs.rb")
-        create_file(file, <<-RB)
+        create_file(file, <<-RUBY)
           #!#{Gem.ruby}
           puts `bundle exec echo foo`
-        RB
+        RUBY
         file.chmod(0o777)
-        bundle! "exec #{file}"
+        bundle "exec #{file}", :env => { "PATH" => path }
         expect(out).to eq("foo")
       end
     end
 
+    context "when Kernel.require uses extra monkeypatches" do
+      before do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
+      end
+
+      it "does not undo the monkeypatches" do
+        karafka = bundled_app("bin/karafka")
+        create_file(karafka, <<~RUBY)
+          #!#{Gem.ruby}
+
+          module Kernel
+            module_function
+
+            alias_method :require_before_extra_monkeypatches, :require
+
+            def require(path)
+              puts "requiring \#{path} used the monkeypatch"
+
+              require_before_extra_monkeypatches(path)
+            end
+          end
+
+          Bundler.setup(:default)
+
+          require "foo"
+        RUBY
+        karafka.chmod(0o777)
+
+        foreman = bundled_app("bin/foreman")
+        create_file(foreman, <<~RUBY)
+          #!#{Gem.ruby}
+
+          puts `bundle exec bin/karafka`
+        RUBY
+        foreman.chmod(0o777)
+
+        bundle "exec #{foreman}"
+        expect(out).to eq("requiring foo used the monkeypatch")
+      end
+    end
+
+    context "when gemfile and path are configured", :ruby_repo do
+      before do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
+
+        build_repo2 do
+          build_gem "rails", "6.1.0" do |s|
+            s.executables = "rails"
+          end
+        end
+
+        bundle "config set path vendor/bundle"
+        bundle "config set gemfile gemfiles/rack_6_1.gemfile"
+
+        create_file(bundled_app("gemfiles/rack_6_1.gemfile"), <<~RUBY)
+          source "#{file_uri_for(gem_repo2)}"
+
+          gem "rails", "6.1.0"
+        RUBY
+
+        # A Gemfile needs to be in the root to trick bundler's root resolution
+        create_file(bundled_app("Gemfile"), "source \"#{file_uri_for(gem_repo1)}\"")
+
+        bundle "install"
+      end
+
+      it "can still find gems after a nested subprocess" do
+        script = bundled_app("bin/myscript")
+
+        create_file(script, <<~RUBY)
+          #!#{Gem.ruby}
+
+          puts `bundle exec rails`
+        RUBY
+
+        script.chmod(0o777)
+
+        bundle "exec #{script}"
+
+        expect(err).to be_empty
+        expect(out).to eq("6.1.0")
+      end
+    end
+
     context "with a system gem that shadows a default gem" do
       let(:openssl_version) { "99.9.9" }
-      let(:expected) { ruby "gem 'openssl', '< 999999'; require 'openssl'; puts OpenSSL::VERSION", :artifice => nil }
+      let(:expected) { ruby "gem 'openssl', '< 999999'; require 'openssl'; puts OpenSSL::VERSION", :artifice => nil, :raise_on_error => false }
 
       it "only leaves the default gem in the stdlib available" do
+        skip "https://github.com/rubygems/rubygems/issues/3351" if Gem.win_platform?
         skip "openssl isn't a default gem" if expected.empty?
 
-        install_gemfile! "" # must happen before installing the broken system gem
+        install_gemfile "source \"#{file_uri_for(gem_repo1)}\"" # must happen before installing the broken system gem
 
         build_repo4 do
           build_gem "openssl", openssl_version do |s|
-            s.write("lib/openssl.rb", <<-RB)
+            s.write("lib/openssl.rb", <<-RUBY)
               raise "custom openssl should not be loaded, it's not in the gemfile!"
-            RB
+            RUBY
           end
         end
 
-        system_gems(:bundler, "openssl-#{openssl_version}", :gem_repo => gem_repo4)
+        system_gems("openssl-#{openssl_version}", :gem_repo => gem_repo4)
 
         file = bundled_app("require_openssl.rb")
-        create_file(file, <<-RB)
+        create_file(file, <<-RUBY)
           #!/usr/bin/env ruby
           require "openssl"
           puts OpenSSL::VERSION
           warn Gem.loaded_specs.values.map(&:full_name)
-        RB
+        RUBY
         file.chmod(0o777)
 
+        env = { "PATH" => path }
         aggregate_failures do
-          expect(bundle!("exec #{file}", :artifice => nil)).to eq(expected)
-          expect(bundle!("exec bundle exec #{file}", :artifice => nil)).to eq(expected)
-          expect(bundle!("exec ruby #{file}", :artifice => nil)).to eq(expected)
-          expect(run!(file.read, :artifice => nil)).to eq(expected)
+          expect(bundle("exec #{file}", :artifice => nil, :env => env)).to eq(expected)
+          expect(bundle("exec bundle exec #{file}", :artifice => nil, :env => env)).to eq(expected)
+          expect(bundle("exec ruby #{file}", :artifice => nil, :env => env)).to eq(expected)
+          expect(run(file.read, :artifice => nil, :env => env)).to eq(expected)
         end
 
+        skip "ruby_core has openssl and rubygems in the same folder, and this test needs rubygems require but default openssl not in a directly added entry in $LOAD_PATH" if ruby_core?
         # sanity check that we get the newer, custom version without bundler
-        sys_exec("#{Gem.ruby} #{file}")
+        sys_exec "#{Gem.ruby} #{file}", :env => env, :raise_on_error => false
         expect(err).to include("custom openssl should not be loaded")
       end
     end
+
+    context "with a git gem that includes extensions", :ruby_repo do
+      before do
+        build_git "simple_git_binary", &:add_c_extension
+        bundle "config set --local path .bundle"
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+          gem "simple_git_binary", :git => '#{lib_path("simple_git_binary-1.0")}'
+        G
+      end
+
+      it "allows calling bundle install" do
+        bundle "exec bundle install"
+      end
+
+      it "allows calling bundle install after removing gem.build_complete" do
+        FileUtils.rm_rf Dir[bundled_app(".bundle/**/gem.build_complete")]
+        bundle "exec #{Gem.ruby} -S bundle install"
+      end
+    end
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/commands/fund_spec.rb
@@ -0,0 +1,82 @@
+# frozen_string_literal: true
+
+RSpec.describe "bundle fund" do
+  before do
+    build_repo2 do
+      build_gem "has_funding_and_other_metadata" do |s|
+        s.metadata = {
+          "bug_tracker_uri"   => "https://example.com/user/bestgemever/issues",
+          "changelog_uri"     => "https://example.com/user/bestgemever/CHANGELOG.md",
+          "documentation_uri" => "https://www.example.info/gems/bestgemever/0.0.1",
+          "homepage_uri"      => "https://bestgemever.example.io",
+          "mailing_list_uri"  => "https://groups.example.com/bestgemever",
+          "funding_uri"       => "https://example.com/has_funding_and_other_metadata/funding",
+          "source_code_uri"   => "https://example.com/user/bestgemever",
+          "wiki_uri"          => "https://example.com/user/bestgemever/wiki",
+        }
+      end
+
+      build_gem "has_funding", "1.2.3" do |s|
+        s.metadata = {
+          "funding_uri"       => "https://example.com/has_funding/funding",
+        }
+      end
+
+      build_gem "gem_with_dependent_funding", "1.0" do |s|
+        s.add_dependency "has_funding"
+      end
+    end
+  end
+
+  it "prints fund information for all gems in the bundle" do
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo2)}"
+      gem 'has_funding_and_other_metadata'
+      gem 'has_funding'
+      gem 'rack-obama'
+    G
+
+    bundle "fund"
+
+    expect(out).to include("* has_funding_and_other_metadata (1.0)\n  Funding: https://example.com/has_funding_and_other_metadata/funding")
+    expect(out).to include("* has_funding (1.2.3)\n  Funding: https://example.com/has_funding/funding")
+    expect(out).to_not include("rack-obama")
+  end
+
+  it "does not consider fund information for gem dependencies" do
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo2)}"
+      gem 'gem_with_dependent_funding'
+    G
+
+    bundle "fund"
+
+    expect(out).to_not include("* has_funding (1.2.3)\n  Funding: https://example.com/has_funding/funding")
+    expect(out).to_not include("gem_with_dependent_funding")
+  end
+
+  it "prints message if none of the gems have fund information" do
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo2)}"
+      gem 'rack-obama'
+    G
+
+    bundle "fund"
+
+    expect(out).to include("None of the installed gems you directly depend on are looking for funding.")
+  end
+
+  describe "with --group option" do
+    it "prints fund message for only specified group gems" do
+      install_gemfile <<-G
+      source "#{file_uri_for(gem_repo2)}"
+        gem 'has_funding_and_other_metadata', :group => :development
+        gem 'has_funding'
+      G
+
+      bundle "fund --group development"
+      expect(out).to include("* has_funding_and_other_metadata (1.0)\n  Funding: https://example.com/has_funding_and_other_metadata/funding")
+      expect(out).to_not include("* has_funding (1.2.3)\n  Funding: https://example.com/has_funding/funding")
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/help_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/help_spec.rb
@@ -1,33 +1,35 @@
 # frozen_string_literal: true
 
 RSpec.describe "bundle help" do
-  it "uses mann when available" do
+  it "uses man when available" do
     with_fake_man do
       bundle "help gemfile"
     end
-    expect(out).to eq(%(["#{root}/man/gemfile.5"]))
+    expect(out).to eq(%(["#{man_dir}/gemfile.5"]))
   end
 
-  it "prefixes bundle commands with bundle- when finding the groff files" do
+  it "prefixes bundle commands with bundle- when finding the man files" do
     with_fake_man do
       bundle "help install"
     end
-    expect(out).to eq(%(["#{root}/man/bundle-install.1"]))
+    expect(out).to eq(%(["#{man_dir}/bundle-install.1"]))
   end
 
-  it "simply outputs the txt file when there is no man on the path" do
+  it "simply outputs the human readable file when there is no man on the path" do
     with_path_as("") do
       bundle "help install"
     end
-    expect(out).to match(/BUNDLE-INSTALL/)
+    expect(out).to match(/bundle-install/)
   end
 
   it "still outputs the old help for commands that do not have man pages yet" do
-    bundle "help version"
-    expect(out).to include("Prints the bundler's version information")
+    bundle "help fund"
+    expect(out).to include("Lists information about gems seeking funding assistance")
   end
 
   it "looks for a binary and executes it with --help option if it's named bundler-<task>" do
+    skip "Could not find command testtasks, probably because not a windows friendly executable" if Gem.win_platform?
+
     File.open(tmp("bundler-testtasks"), "w", 0o755) do |f|
       f.puts "#!/usr/bin/env ruby\nputs ARGV.join(' ')\n"
     end
@@ -36,7 +38,6 @@ RSpec.describe "bundle help" do
       bundle "help testtasks"
     end
 
-    expect(exitstatus).to be_zero if exitstatus
     expect(out).to eq("--help")
   end
 
@@ -44,33 +45,33 @@ RSpec.describe "bundle help" do
     with_fake_man do
       bundle "install --help"
     end
-    expect(out).to eq(%(["#{root}/man/bundle-install.1"]))
+    expect(out).to eq(%(["#{man_dir}/bundle-install.1"]))
   end
 
   it "is called when the --help flag is used before the command" do
     with_fake_man do
       bundle "--help install"
     end
-    expect(out).to eq(%(["#{root}/man/bundle-install.1"]))
+    expect(out).to eq(%(["#{man_dir}/bundle-install.1"]))
   end
 
   it "is called when the -h flag is used before the command" do
     with_fake_man do
       bundle "-h install"
     end
-    expect(out).to eq(%(["#{root}/man/bundle-install.1"]))
+    expect(out).to eq(%(["#{man_dir}/bundle-install.1"]))
   end
 
   it "is called when the -h flag is used after the command" do
     with_fake_man do
       bundle "install -h"
     end
-    expect(out).to eq(%(["#{root}/man/bundle-install.1"]))
+    expect(out).to eq(%(["#{man_dir}/bundle-install.1"]))
   end
 
   it "has helpful output when using --help flag for a non-existent command" do
     with_fake_man do
-      bundle "instill -h"
+      bundle "instill -h", :raise_on_error => false
     end
     expect(err).to include('Could not find command "instill".')
   end
@@ -79,11 +80,11 @@ RSpec.describe "bundle help" do
     with_fake_man do
       bundle "--help"
     end
-    expect(out).to eq(%(["#{root}/man/bundle.1"]))
+    expect(out).to eq(%(["#{man_dir}/bundle.1"]))
 
     with_fake_man do
       bundle "-h"
     end
-    expect(out).to eq(%(["#{root}/man/bundle.1"]))
+    expect(out).to eq(%(["#{man_dir}/bundle.1"]))
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/info_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/info_spec.rb
@@ -3,18 +3,34 @@
 RSpec.describe "bundle info" do
   context "with a standard Gemfile" do
     before do
+      build_repo2 do
+        build_gem "has_metadata" do |s|
+          s.metadata = {
+            "bug_tracker_uri"   => "https://example.com/user/bestgemever/issues",
+            "changelog_uri"     => "https://example.com/user/bestgemever/CHANGELOG.md",
+            "documentation_uri" => "https://www.example.info/gems/bestgemever/0.0.1",
+            "homepage_uri"      => "https://bestgemever.example.io",
+            "mailing_list_uri"  => "https://groups.example.com/bestgemever",
+            "source_code_uri"   => "https://example.com/user/bestgemever",
+            "wiki_uri"          => "https://example.com/user/bestgemever/wiki",
+          }
+        end
+      end
+
       install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
+        source "#{file_uri_for(gem_repo2)}"
         gem "rails"
+        gem "has_metadata"
+        gem "thin"
       G
     end
 
     it "creates a Gemfile.lock when invoked with a gem name" do
-      FileUtils.rm("Gemfile.lock")
+      FileUtils.rm(bundled_app_lock)
 
       bundle "info rails"
 
-      expect(bundled_app("Gemfile.lock")).to exist
+      expect(bundled_app_lock).to exist
     end
 
     it "prints information if gem exists in bundle" do
@@ -35,11 +51,41 @@ RSpec.describe "bundle info" do
       expect(out).to eq(root.to_s)
     end
 
+    it "prints gem version if exists in bundle" do
+      bundle "info rails --version"
+      expect(out).to eq("2.3.2")
+    end
+
+    it "doesn't claim that bundler has been deleted, even if using a custom path without bundler there" do
+      bundle "config set --local path vendor/bundle"
+      bundle "install"
+      bundle "info bundler"
+      expect(out).to include("\tPath: #{root}")
+      expect(err).not_to match(/The gem bundler has been deleted/i)
+    end
+
     it "complains if gem not in bundle" do
-      bundle "info missing"
+      bundle "info missing", :raise_on_error => false
       expect(err).to eq("Could not find gem 'missing'.")
     end
 
+    it "warns if path no longer exists on disk" do
+      FileUtils.rm_rf(default_bundle_path("gems", "rails-2.3.2"))
+
+      bundle "info rails --path"
+
+      expect(err).to match(/The gem rails has been deleted/i)
+      expect(err).to match(default_bundle_path("gems", "rails-2.3.2").to_s)
+
+      bundle "info rail --path"
+      expect(err).to match(/The gem rails has been deleted/i)
+      expect(err).to match(default_bundle_path("gems", "rails-2.3.2").to_s)
+
+      bundle "info rails"
+      expect(err).to match(/The gem rails has been deleted/i)
+      expect(err).to match(default_bundle_path("gems", "rails-2.3.2").to_s)
+    end
+
     context "given a default gem shippped in ruby", :ruby_repo do
       it "prints information about the default gem" do
         bundle "info rdoc"
@@ -48,6 +94,22 @@ RSpec.describe "bundle info" do
       end
     end
 
+    context "given a gem with metadata" do
+      it "prints the gem metadata" do
+        bundle "info has_metadata"
+        expect(out).to include "* has_metadata (1.0)
+\tSummary: This is just a fake gem for testing
+\tHomepage: http://example.com
+\tDocumentation: https://www.example.info/gems/bestgemever/0.0.1
+\tSource Code: https://example.com/user/bestgemever
+\tWiki: https://example.com/user/bestgemever/wiki
+\tChangelog: https://example.com/user/bestgemever/CHANGELOG.md
+\tBug Tracker: https://example.com/user/bestgemever/issues
+\tMailing List: https://groups.example.com/bestgemever
+\tPath: #{default_bundle_path("gems", "has_metadata-1.0")}"
+      end
+    end
+
     context "when gem does not have homepage" do
       before do
         build_repo2 do
@@ -62,6 +124,30 @@ RSpec.describe "bundle info" do
         expect(out).to_not include("Homepage:")
       end
     end
+
+    context "when gem has a reverse dependency on any version" do
+      it "prints the details" do
+        bundle "info rack"
+
+        expect(out).to include("Reverse Dependencies: \n\t\tthin (1.0) depends on rack (>= 0)")
+      end
+    end
+
+    context "when gem has a reverse dependency on a specific version" do
+      it "prints the details" do
+        bundle "info actionpack"
+
+        expect(out).to include("Reverse Dependencies: \n\t\trails (2.3.2) depends on actionpack (= 2.3.2)")
+      end
+    end
+
+    context "when gem has no reverse dependencies" do
+      it "excludes the reverse dependencies field from the output" do
+        bundle "info rails"
+
+        expect(out).not_to include("Reverse Dependencies:")
+      end
+    end
   end
 
   context "with a git repo in the Gemfile" do
@@ -71,21 +157,23 @@ RSpec.describe "bundle info" do
 
     it "prints out git info" do
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
       expect(the_bundle).to include_gems "foo 1.0"
 
       bundle "info foo"
-      expect(out).to include("foo (1.0 #{@git.ref_for("master", 6)}")
+      expect(out).to include("foo (1.0 #{@git.ref_for("main", 6)}")
     end
 
-    it "prints out branch names other than master" do
+    it "prints out branch names other than main" do
       update_git "foo", :branch => "omg" do |s|
         s.write "lib/foo.rb", "FOO = '1.0.omg'"
       end
       @revision = revision_for(lib_path("foo-1.0"))[0...6]
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{lib_path("foo-1.0")}", :branch => "omg"
       G
       expect(the_bundle).to include_gems "foo 1.0.omg"
@@ -97,6 +185,7 @@ RSpec.describe "bundle info" do
     it "doesn't print the branch when tied to a ref" do
       sha = revision_for(lib_path("foo-1.0"))
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{lib_path("foo-1.0")}", :ref => "#{sha}"
       G
 
@@ -107,17 +196,18 @@ RSpec.describe "bundle info" do
     it "handles when a version is a '-' prerelease" do
       @git = build_git("foo", "1.0.0-beta.1", :path => lib_path("foo"))
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", "1.0.0-beta.1", :git => "#{lib_path("foo")}"
       G
       expect(the_bundle).to include_gems "foo 1.0.0.pre.beta.1"
 
-      bundle! "info foo"
+      bundle "info foo"
       expect(out).to include("foo (1.0.0.pre.beta.1")
     end
   end
 
   context "with a valid regexp for gem name" do
-    it "presents alternatives" do
+    it "presents alternatives", :readline do
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
@@ -125,7 +215,7 @@ RSpec.describe "bundle info" do
       G
 
       bundle "info rac"
-      expect(out).to eq "1 : rack\n2 : rack-obama\n0 : - exit -\n>"
+      expect(out).to match(/\A1 : rack\n2 : rack-obama\n0 : - exit -(\n>)?\z/)
     end
   end
 
@@ -138,8 +228,22 @@ RSpec.describe "bundle info" do
 
       invalid_regexp = "[]"
 
-      bundle "info #{invalid_regexp}"
+      bundle "info #{invalid_regexp}", :raise_on_error => false
       expect(err).to include("Could not find gem '#{invalid_regexp}'.")
     end
   end
+
+  context "with without configured" do
+    it "does not find the gem, but gives a helpful error" do
+      bundle "config without test"
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rails", group: :test
+      G
+
+      bundle "info rails", :raise_on_error => false
+      expect(err).to include("Could not find gem 'rails', because it's in the group 'test', configured to be ignored.")
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/init_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/init_spec.rb
@@ -2,9 +2,9 @@
 
 RSpec.describe "bundle init" do
   it "generates a Gemfile" do
-    bundle! :init
+    bundle :init
     expect(out).to include("Writing new Gemfile")
-    expect(bundled_app("Gemfile")).to be_file
+    expect(bundled_app_gemfile).to be_file
   end
 
   context "when a Gemfile already exists" do
@@ -15,11 +15,11 @@ RSpec.describe "bundle init" do
     end
 
     it "does not change existing Gemfiles" do
-      expect { bundle :init }.not_to change { File.read(bundled_app("Gemfile")) }
+      expect { bundle :init, :raise_on_error => false }.not_to change { File.read(bundled_app_gemfile) }
     end
 
     it "notifies the user that an existing Gemfile already exists" do
-      bundle :init
+      bundle :init, :raise_on_error => false
       expect(err).to include("Gemfile already exists")
     end
   end
@@ -28,13 +28,11 @@ RSpec.describe "bundle init" do
     let(:subdir) { "child_dir" }
 
     it "lets users generate a Gemfile in a child directory" do
-      bundle! :init
+      bundle :init
 
       FileUtils.mkdir bundled_app(subdir)
 
-      Dir.chdir bundled_app(subdir) do
-        bundle! :init
-      end
+      bundle :init, :dir => bundled_app(subdir)
 
       expect(out).to include("Writing new Gemfile")
       expect(bundled_app("#{subdir}/Gemfile")).to be_file
@@ -44,15 +42,13 @@ RSpec.describe "bundle init" do
   context "when the dir is not writable by the current user" do
     let(:subdir) { "child_dir" }
 
-    it "notifies the user that it can not write to it" do
+    it "notifies the user that it cannot write to it" do
       FileUtils.mkdir bundled_app(subdir)
       # chmod a-w it
       mode = File.stat(bundled_app(subdir)).mode ^ 0o222
       FileUtils.chmod mode, bundled_app(subdir)
 
-      Dir.chdir bundled_app(subdir) do
-        bundle :init
-      end
+      bundle :init, :dir => bundled_app(subdir), :raise_on_error => false
 
       expect(err).to include("directory is not writable")
       expect(Dir[bundled_app("#{subdir}/*")]).to be_empty
@@ -75,7 +71,7 @@ RSpec.describe "bundle init" do
 
       bundle :init, :gemspec => spec_file
 
-      gemfile = bundled_app("Gemfile").read
+      gemfile = bundled_app_gemfile.read
       expect(gemfile).to match(%r{source 'https://rubygems.org'})
       expect(gemfile.scan(/gem "rack", "= 1.0.1"/).size).to eq(1)
       expect(gemfile.scan(/gem "rspec", "= 1.2"/).size).to eq(1)
@@ -93,7 +89,7 @@ RSpec.describe "bundle init" do
           S
         end
 
-        bundle :init, :gemspec => spec_file
+        bundle :init, :gemspec => spec_file, :raise_on_error => false
         expect(err).to include("There was an error while loading `test.gemspec`")
       end
     end
@@ -103,7 +99,7 @@ RSpec.describe "bundle init" do
     before { bundle "config set init_gems_rb true" }
 
     it "generates a gems.rb" do
-      bundle! :init
+      bundle :init
       expect(out).to include("Writing new gems.rb")
       expect(bundled_app("gems.rb")).to be_file
     end
@@ -116,11 +112,11 @@ RSpec.describe "bundle init" do
       end
 
       it "does not change existing Gemfiles" do
-        expect { bundle :init }.not_to change { File.read(bundled_app("gems.rb")) }
+        expect { bundle :init, :raise_on_error => false }.not_to change { File.read(bundled_app("gems.rb")) }
       end
 
       it "notifies the user that an existing gems.rb already exists" do
-        bundle :init
+        bundle :init, :raise_on_error => false
         expect(err).to include("gems.rb already exists")
       end
     end
@@ -129,13 +125,11 @@ RSpec.describe "bundle init" do
       let(:subdir) { "child_dir" }
 
       it "lets users generate a Gemfile in a child directory" do
-        bundle! :init
+        bundle :init
 
         FileUtils.mkdir bundled_app(subdir)
 
-        Dir.chdir bundled_app(subdir) do
-          bundle! :init
-        end
+        bundle :init, :dir => bundled_app(subdir)
 
         expect(out).to include("Writing new gems.rb")
         expect(bundled_app("#{subdir}/gems.rb")).to be_file
--- ruby2.7-2.7.6.orig/spec/bundler/commands/inject_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/inject_spec.rb
@@ -10,9 +10,9 @@ RSpec.describe "bundle inject", :bundler
 
   context "without a lockfile" do
     it "locks with the injected gems" do
-      expect(bundled_app("Gemfile.lock")).not_to exist
+      expect(bundled_app_lock).not_to exist
       bundle "inject 'rack-obama' '> 0'"
-      expect(bundled_app("Gemfile.lock").read).to match(/rack-obama/)
+      expect(bundled_app_lock.read).to match(/rack-obama/)
     end
   end
 
@@ -22,28 +22,28 @@ RSpec.describe "bundle inject", :bundler
     end
 
     it "adds the injected gems to the Gemfile" do
-      expect(bundled_app("Gemfile").read).not_to match(/rack-obama/)
+      expect(bundled_app_gemfile.read).not_to match(/rack-obama/)
       bundle "inject 'rack-obama' '> 0'"
-      expect(bundled_app("Gemfile").read).to match(/rack-obama/)
+      expect(bundled_app_gemfile.read).to match(/rack-obama/)
     end
 
     it "locks with the injected gems" do
-      expect(bundled_app("Gemfile.lock").read).not_to match(/rack-obama/)
+      expect(bundled_app_lock.read).not_to match(/rack-obama/)
       bundle "inject 'rack-obama' '> 0'"
-      expect(bundled_app("Gemfile.lock").read).to match(/rack-obama/)
+      expect(bundled_app_lock.read).to match(/rack-obama/)
     end
   end
 
   context "with injected gems already in the Gemfile" do
     it "doesn't add existing gems" do
-      bundle "inject 'rack' '> 0'"
+      bundle "inject 'rack' '> 0'", :raise_on_error => false
       expect(err).to match(/cannot specify the same gem twice/i)
     end
   end
 
   context "incorrect arguments" do
     it "fails when more than 2 arguments are passed" do
-      bundle "inject gem_name 1 v"
+      bundle "inject gem_name 1 v", :raise_on_error => false
       expect(err).to eq(<<-E.strip)
 ERROR: "bundle inject" was called with arguments ["gem_name", "1", "v"]
 Usage: "bundle inject GEM VERSION"
@@ -54,7 +54,7 @@ Usage: "bundle inject GEM VERSION"
   context "with source option" do
     it "add gem with source option in gemfile" do
       bundle "inject 'foo' '>0' --source #{file_uri_for(gem_repo1)}"
-      gemfile = bundled_app("Gemfile").read
+      gemfile = bundled_app_gemfile.read
       str = "gem \"foo\", \"> 0\", :source => \"#{file_uri_for(gem_repo1)}\""
       expect(gemfile).to include str
     end
@@ -63,14 +63,14 @@ Usage: "bundle inject GEM VERSION"
   context "with group option" do
     it "add gem with group option in gemfile" do
       bundle "inject 'rack-obama' '>0' --group=development"
-      gemfile = bundled_app("Gemfile").read
+      gemfile = bundled_app_gemfile.read
       str = "gem \"rack-obama\", \"> 0\", :group => :development"
       expect(gemfile).to include str
     end
 
     it "add gem with multiple groups in gemfile" do
       bundle "inject 'rack-obama' '>0' --group=development,test"
-      gemfile = bundled_app("Gemfile").read
+      gemfile = bundled_app_gemfile.read
       str = "gem \"rack-obama\", \"> 0\", :groups => [:development, :test]"
       expect(gemfile).to include str
     end
@@ -80,26 +80,26 @@ Usage: "bundle inject GEM VERSION"
     before do
       bundle "install"
       if Bundler.feature_flag.bundler_3_mode?
-        bundle! "config set --local deployment true"
+        bundle "config set --local deployment true"
       else
-        bundle! "config set --local frozen true"
+        bundle "config set --local frozen true"
       end
     end
 
     it "injects anyway" do
       bundle "inject 'rack-obama' '> 0'"
-      expect(bundled_app("Gemfile").read).to match(/rack-obama/)
+      expect(bundled_app_gemfile.read).to match(/rack-obama/)
     end
 
     it "locks with the injected gems" do
-      expect(bundled_app("Gemfile.lock").read).not_to match(/rack-obama/)
+      expect(bundled_app_lock.read).not_to match(/rack-obama/)
       bundle "inject 'rack-obama' '> 0'"
-      expect(bundled_app("Gemfile.lock").read).to match(/rack-obama/)
+      expect(bundled_app_lock.read).to match(/rack-obama/)
     end
 
     it "restores frozen afterwards" do
       bundle "inject 'rack-obama' '> 0'"
-      config = YAML.load(bundled_app(".bundle/config").read)
+      config = Psych.load(bundled_app(".bundle/config").read)
       expect(config["BUNDLE_DEPLOYMENT"] || config["BUNDLE_FROZEN"]).to eq("true")
     end
 
@@ -108,10 +108,10 @@ Usage: "bundle inject GEM VERSION"
         source "#{file_uri_for(gem_repo1)}"
         gem "rack-obama"
       G
-      bundle "inject 'rack' '> 0'"
+      bundle "inject 'rack' '> 0'", :raise_on_error => false
       expect(err).to match(/trying to install in deployment mode after changing/)
 
-      expect(bundled_app("Gemfile.lock").read).not_to match(/rack-obama/)
+      expect(bundled_app_lock.read).not_to match(/rack-obama/)
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/install_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/install_spec.rb
@@ -12,12 +12,12 @@ RSpec.describe "bundle install with gem 
     end
 
     it "does not make a lockfile if the install fails" do
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
         raise StandardError, "FAIL"
       G
 
       expect(err).to include('StandardError, "FAIL"')
-      expect(bundled_app("Gemfile.lock")).not_to exist
+      expect(bundled_app_lock).not_to exist
     end
 
     it "creates a Gemfile.lock" do
@@ -26,7 +26,7 @@ RSpec.describe "bundle install with gem 
         gem "rack"
       G
 
-      expect(bundled_app("Gemfile.lock")).to exist
+      expect(bundled_app_lock).to exist
     end
 
     it "does not create ./.bundle by default", :bundler => "< 3" do
@@ -35,7 +35,7 @@ RSpec.describe "bundle install with gem 
         gem "rack"
       G
 
-      bundle! :install # can't use install_gemfile since it sets retry
+      bundle :install # can't use install_gemfile since it sets retry
       expect(bundled_app(".bundle")).not_to exist
     end
 
@@ -45,7 +45,7 @@ RSpec.describe "bundle install with gem 
         gem "rack"
       G
 
-      bundle! :install, :env => { "BUNDLE_PATH__SYSTEM" => "true" } # can't use install_gemfile since it sets retry
+      bundle :install, :env => { "BUNDLE_PATH__SYSTEM" => "true" } # can't use install_gemfile since it sets retry
       expect(bundled_app(".bundle")).not_to exist
     end
 
@@ -66,13 +66,13 @@ RSpec.describe "bundle install with gem 
         gem 'rack'
       G
 
-      lockfile = File.read(bundled_app("Gemfile.lock"))
+      lockfile = File.read(bundled_app_lock)
 
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
         raise StandardError, "FAIL"
       G
 
-      expect(File.read(bundled_app("Gemfile.lock"))).to eq(lockfile)
+      expect(File.read(bundled_app_lock)).to eq(lockfile)
     end
 
     it "does not touch the lockfile if nothing changed" do
@@ -81,7 +81,7 @@ RSpec.describe "bundle install with gem 
         gem "rack"
       G
 
-      expect { run "1" }.not_to change { File.mtime(bundled_app("Gemfile.lock")) }
+      expect { run "1" }.not_to change { File.mtime(bundled_app_lock) }
     end
 
     it "fetches gems" do
@@ -94,6 +94,21 @@ RSpec.describe "bundle install with gem 
       expect(the_bundle).to include_gems("rack 1.0.0")
     end
 
+    it "auto-heals missing gems" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+      G
+
+      FileUtils.rm_rf(default_bundle_path("gems/rack-1.0.0"))
+
+      bundle "install --verbose"
+
+      expect(out).to include("Installing rack 1.0.0")
+      expect(default_bundle_path("gems/rack-1.0.0")).to exist
+      expect(the_bundle).to include_gems("rack 1.0.0")
+    end
+
     it "fetches gems when multiple versions are specified" do
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
@@ -115,11 +130,11 @@ RSpec.describe "bundle install with gem 
     end
 
     it "raises an appropriate error when gems are specified using symbols" do
-      install_gemfile(<<-G)
+      install_gemfile <<-G, :raise_on_error => false
         source "#{file_uri_for(gem_repo1)}"
         gem :rack
       G
-      expect(exitstatus).to eq(4) if exitstatus
+      expect(exitstatus).to eq(4)
     end
 
     it "pulls in dependencies" do
@@ -141,8 +156,14 @@ RSpec.describe "bundle install with gem 
     end
 
     it "does not install the development dependency" do
+      build_repo2 do
+        build_gem "with_development_dependency" do |s|
+          s.add_development_dependency "activesupport", "= 2.3.5"
+        end
+      end
+
       install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
+        source "#{file_uri_for(gem_repo2)}"
         gem "with_development_dependency"
       G
 
@@ -176,7 +197,7 @@ RSpec.describe "bundle install with gem 
     end
 
     it "does not reinstall any gem that is already available locally" do
-      system_gems "activesupport-2.3.2", :path => :bundle_path
+      system_gems "activesupport-2.3.2", :path => default_bundle_path
 
       build_repo2 do
         build_gem "activesupport", "2.3.2" do |s|
@@ -216,8 +237,22 @@ RSpec.describe "bundle install with gem 
       expect(the_bundle).to include_gems "rack 1.0.0", "activesupport 2.3.5"
     end
 
+    it "loads env plugins" do
+      plugin_msg = "hello from an env plugin!"
+      create_file "plugins/rubygems_plugin.rb", "puts '#{plugin_msg}'"
+      rubylib = ENV["RUBYLIB"].to_s.split(File::PATH_SEPARATOR).unshift(bundled_app("plugins").to_s).join(File::PATH_SEPARATOR)
+      install_gemfile <<-G, :env => { "RUBYLIB" => rubylib }
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      expect(last_command.stdboth).to include(plugin_msg)
+    end
+
     describe "with a gem that installs multiple platforms" do
       it "installs gems for the local platform as first choice" do
+        skip "version is 1.0, not 1.0.0" if Gem.win_platform?
+
         install_gemfile <<-G
           source "#{file_uri_for(gem_repo1)}"
           gem "platform_specific"
@@ -250,7 +285,7 @@ RSpec.describe "bundle install with gem 
       end
 
       it "installs gems for windows" do
-        simulate_platform mswin
+        simulate_platform x86_mswin32
 
         install_gemfile <<-G
           source "#{file_uri_for(gem_repo1)}"
@@ -258,7 +293,7 @@ RSpec.describe "bundle install with gem 
         G
 
         run "require 'platform_specific' ; puts PLATFORM_SPECIFIC"
-        expect(out).to eq("1.0.0 MSWIN")
+        expect(out).to eq("1.0 x86-mswin32")
       end
     end
 
@@ -271,28 +306,32 @@ RSpec.describe "bundle install with gem 
       end
 
       it "works" do
-        bundle "install", forgotten_command_line_options(:path => "vendor")
+        bundle "config set --local path vendor"
+        bundle "install"
         expect(the_bundle).to include_gems "rack 1.0"
       end
 
       it "allows running bundle install --system without deleting foo", :bundler => "< 3" do
-        bundle "install", forgotten_command_line_options(:path => "vendor")
-        bundle "install", forgotten_command_line_options(:system => true)
+        bundle "install --path vendor"
+        bundle "install --system"
         FileUtils.rm_rf(bundled_app("vendor"))
         expect(the_bundle).to include_gems "rack 1.0"
       end
 
       it "allows running bundle install --system after deleting foo", :bundler => "< 3" do
-        bundle "install", forgotten_command_line_options(:path => "vendor")
+        bundle "install --path vendor"
         FileUtils.rm_rf(bundled_app("vendor"))
-        bundle "install", forgotten_command_line_options(:system => true)
+        bundle "install --system"
         expect(the_bundle).to include_gems "rack 1.0"
       end
     end
 
     it "finds gems in multiple sources", :bundler => "< 3" do
-      build_repo2
-      update_repo2
+      build_repo2 do
+        build_gem "rack", "1.2" do |s|
+          s.executables = "rackup"
+        end
+      end
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
@@ -306,80 +345,123 @@ RSpec.describe "bundle install with gem 
     end
 
     it "gives a useful error if no sources are set" do
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
         gem "rack"
       G
 
-      bundle :install
-      expect(err).to include("Your Gemfile has no gem server sources")
+      expect(err).to include("This Gemfile does not include an explicit global source. " \
+        "Not using an explicit global source may result in a different lockfile being generated depending on " \
+        "the gems you have installed locally before bundler is run. " \
+        "Instead, define a global source in your Gemfile like this: source \"https://rubygems.org\".")
     end
 
     it "creates a Gemfile.lock on a blank Gemfile" do
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
       G
 
-      expect(File.exist?(bundled_app("Gemfile.lock"))).to eq(true)
+      expect(File.exist?(bundled_app_lock)).to eq(true)
     end
 
-    context "throws a warning if a gem is added twice in Gemfile" do
-      it "without version requirements" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo2)}"
-          gem "rack"
-          gem "rack"
-        G
+    it "throws a warning if a gem is added twice in Gemfile without version requirements" do
+      build_repo2
 
-        expect(err).to include("Your Gemfile lists the gem rack (>= 0) more than once.")
-        expect(err).to include("Remove any duplicate entries and specify the gem only once.")
-        expect(err).to include("While it's not a problem now, it could cause errors if you change the version of one of them later.")
-      end
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "rack"
+        gem "rack"
+      G
 
-      it "with same versions" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo2)}"
-          gem "rack", "1.0"
-          gem "rack", "1.0"
-        G
+      expect(err).to include("Your Gemfile lists the gem rack (>= 0) more than once.")
+      expect(err).to include("Remove any duplicate entries and specify the gem only once.")
+      expect(err).to include("While it's not a problem now, it could cause errors if you change the version of one of them later.")
+    end
 
-        expect(err).to include("Your Gemfile lists the gem rack (= 1.0) more than once.")
-        expect(err).to include("Remove any duplicate entries and specify the gem only once.")
-        expect(err).to include("While it's not a problem now, it could cause errors if you change the version of one of them later.")
-      end
+    it "throws a warning if a gem is added twice in Gemfile with same versions" do
+      build_repo2
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "rack", "1.0"
+        gem "rack", "1.0"
+      G
+
+      expect(err).to include("Your Gemfile lists the gem rack (= 1.0) more than once.")
+      expect(err).to include("Remove any duplicate entries and specify the gem only once.")
+      expect(err).to include("While it's not a problem now, it could cause errors if you change the version of one of them later.")
     end
 
-    context "throws an error if a gem is added twice in Gemfile" do
-      it "when version of one dependency is not specified" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo2)}"
-          gem "rack"
-          gem "rack", "1.0"
-        G
+    it "throws a warning if a gem is added twice under different platforms and does not crash when using the generated lockfile" do
+      build_repo2
 
-        expect(err).to include("You cannot specify the same gem twice with different version requirements")
-        expect(err).to include("You specified: rack (>= 0) and rack (= 1.0).")
-      end
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "rack", :platform => :jruby
+        gem "rack"
+      G
 
-      it "when different versions of both dependencies are specified" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo2)}"
-          gem "rack", "1.0"
-          gem "rack", "1.1"
-        G
+      bundle "install"
+
+      expect(err).to include("Your Gemfile lists the gem rack (>= 0) more than once.")
+      expect(err).to include("Remove any duplicate entries and specify the gem only once.")
+      expect(err).to include("While it's not a problem now, it could cause errors if you change the version of one of them later.")
+    end
 
-        expect(err).to include("You cannot specify the same gem twice with different version requirements")
-        expect(err).to include("You specified: rack (= 1.0) and rack (= 1.1).")
+    it "does not throw a warning if a gem is added once in Gemfile and also inside a gemspec as a development dependency" do
+      build_lib "my-gem", :path => bundled_app do |s|
+        s.add_development_dependency "my-private-gem"
       end
+
+      build_repo2 do
+        build_gem "my-private-gem"
+      end
+
+      gemfile <<~G
+        source "#{file_uri_for(gem_repo2)}"
+
+        gemspec
+
+        gem "my-private-gem", :group => :development
+      G
+
+      bundle :install
+
+      expect(err).to be_empty
+      expect(the_bundle).to include_gems("my-private-gem 1.0")
+    end
+
+    it "throws an error if a gem is added twice in Gemfile when version of one dependency is not specified" do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo2)}"
+        gem "rack"
+        gem "rack", "1.0"
+      G
+
+      expect(err).to include("You cannot specify the same gem twice with different version requirements")
+      expect(err).to include("You specified: rack (>= 0) and rack (= 1.0).")
+    end
+
+    it "throws an error if a gem is added twice in Gemfile when different versions of both dependencies are specified" do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo2)}"
+        gem "rack", "1.0"
+        gem "rack", "1.1"
+      G
+
+      expect(err).to include("You cannot specify the same gem twice with different version requirements")
+      expect(err).to include("You specified: rack (= 1.0) and rack (= 1.1).")
     end
 
     it "gracefully handles error when rubygems server is unavailable" do
-      install_gemfile <<-G, :artifice => nil
+      skip "networking issue" if Gem.win_platform?
+
+      install_gemfile <<-G, :artifice => nil, :raise_on_error => false
         source "#{file_uri_for(gem_repo1)}"
         source "http://0.0.0.0:9384" do
           gem 'foo'
         end
       G
 
-      bundle :install, :artifice => nil
       expect(err).to include("Could not fetch specs from http://0.0.0.0:9384/")
       expect(err).not_to include("file://")
     end
@@ -397,7 +479,7 @@ RSpec.describe "bundle install with gem 
         build_gem "ruby-ajp", "1.0.0"
       end
 
-      install_gemfile <<-G, :full_index => true
+      install_gemfile <<-G, :full_index => true, :raise_on_error => false
         source "#{file_uri_for(gem_repo2)}"
 
         gem "ajp-rails", "0.0.0"
@@ -405,7 +487,7 @@ RSpec.describe "bundle install with gem 
 
       expect(last_command.stdboth).not_to match(/Error Report/i)
       expect(err).to include("An error occurred while installing ajp-rails (0.0.0), and Bundler cannot continue.").
-        and include("Make sure that `gem install ajp-rails -v '0.0.0' --source '#{file_uri_for(gem_repo2)}/'` succeeds before bundling.")
+        and include("Bundler::APIResponseInvalidDependenciesError")
     end
 
     it "doesn't blow up when the local .bundle/config is empty" do
@@ -417,7 +499,6 @@ RSpec.describe "bundle install with gem 
 
         gem 'foo'
       G
-      expect(exitstatus).to eq(0) if exitstatus
     end
 
     it "doesn't blow up when the global .bundle/config is empty" do
@@ -429,7 +510,6 @@ RSpec.describe "bundle install with gem 
 
         gem 'foo'
       G
-      expect(exitstatus).to eq(0) if exitstatus
     end
   end
 
@@ -438,26 +518,26 @@ RSpec.describe "bundle install with gem 
 
     context "and using an unsupported Ruby version" do
       it "prints an error" do
-        install_gemfile <<-G
-          ::RUBY_VERSION = '2.0.1'
-          ruby '~> 2.2'
+        install_gemfile <<-G, :raise_on_error => false
+          ruby '~> 1.2'
+          source "#{file_uri_for(gem_repo1)}"
         G
-        expect(err).to include("Your Ruby version is 2.0.1, but your Gemfile specified ~> 2.2")
+        expect(err).to include("Your Ruby version is #{Gem.ruby_version}, but your Gemfile specified ~> 1.2")
       end
     end
 
     context "and using a supported Ruby version" do
       before do
         install_gemfile <<-G
-          ::RUBY_VERSION = '2.1.3'
-          ::RUBY_PATCHLEVEL = 100
-          ruby '~> 2.1.0'
+          ruby '~> #{Gem.ruby_version}'
+          source "#{file_uri_for(gem_repo1)}"
         G
       end
 
       it "writes current Ruby version to Gemfile.lock" do
-        lockfile_should_be <<-L
+        expect(lockfile).to eq <<~L
          GEM
+           remote: #{file_uri_for(gem_repo1)}/
            specs:
 
          PLATFORMS
@@ -466,22 +546,22 @@ RSpec.describe "bundle install with gem 
          DEPENDENCIES
 
          RUBY VERSION
-            ruby 2.1.3p100
+            #{Bundler::RubyVersion.system}
 
          BUNDLED WITH
             #{Bundler::VERSION}
         L
       end
 
-      it "updates Gemfile.lock with updated incompatible ruby version" do
+      it "updates Gemfile.lock with updated yet still compatible ruby version" do
         install_gemfile <<-G
-          ::RUBY_VERSION = '2.2.3'
-          ::RUBY_PATCHLEVEL = 100
-          ruby '~> 2.2.0'
+          ruby '~> #{current_ruby_minor}'
+          source "#{file_uri_for(gem_repo1)}"
         G
 
-        lockfile_should_be <<-L
+        expect(lockfile).to eq <<~L
          GEM
+           remote: #{file_uri_for(gem_repo1)}/
            specs:
 
          PLATFORMS
@@ -490,55 +570,231 @@ RSpec.describe "bundle install with gem 
          DEPENDENCIES
 
          RUBY VERSION
-            ruby 2.2.3p100
+            #{Bundler::RubyVersion.system}
 
          BUNDLED WITH
             #{Bundler::VERSION}
         L
       end
+
+      it "does not crash when unlocking" do
+        gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+          ruby '>= 2.1.0'
+        G
+
+        bundle "update"
+
+        expect(err).not_to include("Could not find gem 'Ruby")
+      end
     end
   end
 
   describe "when Bundler root contains regex chars" do
-    before do
+    it "doesn't blow up when using the `gem` DSL" do
       root_dir = tmp("foo[]bar")
 
       FileUtils.mkdir_p(root_dir)
-      in_app_root_custom(root_dir)
-    end
 
-    it "doesn't blow up" do
       build_lib "foo"
       gemfile = <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem 'foo', :path => "#{lib_path("foo-1.0")}"
       G
-      File.open("Gemfile", "w") do |file|
+      File.open("#{root_dir}/Gemfile", "w") do |file|
         file.puts gemfile
       end
 
-      bundle :install
+      bundle :install, :dir => root_dir
+    end
 
-      expect(exitstatus).to eq(0) if exitstatus
+    it "doesn't blow up when using the `gemspec` DSL" do
+      root_dir = tmp("foo[]bar")
+
+      FileUtils.mkdir_p(root_dir)
+
+      build_lib "foo", :path => root_dir
+      gemfile = <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gemspec
+      G
+      File.open("#{root_dir}/Gemfile", "w") do |file|
+        file.puts gemfile
+      end
+
+      bundle :install, :dir => root_dir
     end
   end
 
   describe "when requesting a quiet install via --quiet" do
-    it "should be quiet" do
+    it "should be quiet if there are no warnings" do
       bundle "config set force_ruby_platform true"
 
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem 'rack'
       G
 
       bundle :install, :quiet => true
-      expect(err).to include("Could not find gem 'rack'")
-      expect(err).to_not include("Your Gemfile has no gem server sources")
+      expect(out).to be_empty
+      expect(err).to be_empty
+    end
+
+    it "should still display warnings and errors" do
+      bundle "config set force_ruby_platform true"
+
+      create_file("install_with_warning.rb", <<~RUBY)
+        require "#{lib_dir}/bundler"
+        require "#{lib_dir}/bundler/cli"
+        require "#{lib_dir}/bundler/cli/install"
+
+        module RunWithWarning
+          def run
+            super
+          rescue
+            Bundler.ui.warn "BOOOOO"
+            raise
+          end
+        end
+
+        Bundler::CLI::Install.prepend(RunWithWarning)
+      RUBY
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'non-existing-gem'
+      G
+
+      bundle :install, :quiet => true, :raise_on_error => false, :env => { "RUBYOPT" => "-r#{bundled_app("install_with_warning.rb")}" }
+      expect(out).to be_empty
+      expect(err).to include("Could not find gem 'non-existing-gem'")
+      expect(err).to include("BOOOOO")
+    end
+  end
+
+  describe "when bundle path does not have write access", :permissions do
+    let(:bundle_path) { bundled_app("vendor") }
+
+    before do
+      FileUtils.mkdir_p(bundle_path)
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+      G
+    end
+
+    it "should display a proper message to explain the problem" do
+      FileUtils.chmod(0o500, bundle_path)
+
+      bundle "config set --local path vendor"
+      bundle :install, :raise_on_error => false
+      expect(err).to include(bundle_path.to_s)
+      expect(err).to include("grant write permissions")
     end
   end
 
-  describe "when bundle path does not have write access" do
+  describe "when bundle gems path does not have write access", :permissions do
+    let(:gems_path) { bundled_app("vendor/#{Bundler.ruby_scope}/gems") }
+
+    before do
+      FileUtils.mkdir_p(gems_path)
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+      G
+    end
+
+    it "should display a proper message to explain the problem" do
+      FileUtils.chmod("-x", gems_path)
+      bundle "config set --local path vendor"
+
+      begin
+        bundle :install, :raise_on_error => false
+      ensure
+        FileUtils.chmod("+x", gems_path)
+      end
+
+      expect(err).not_to include("ERROR REPORT TEMPLATE")
+
+      expect(err).to include(
+        "There was an error while trying to create `#{gems_path.join("rack-1.0.0")}`. " \
+        "It is likely that you need to grant executable permissions for all parent directories and write permissions for `#{gems_path}`."
+      )
+    end
+  end
+
+  describe "when bundle extensions path does not have write access", :permissions do
+    let(:extensions_path) { bundled_app("vendor/#{Bundler.ruby_scope}/extensions/#{Gem::Platform.local}/#{Gem.extension_api_version}") }
+
+    before do
+      FileUtils.mkdir_p(extensions_path)
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'simple_binary'
+      G
+    end
+
+    it "should display a proper message to explain the problem" do
+      FileUtils.chmod("-x", extensions_path)
+      bundle "config set --local path vendor"
+
+      begin
+        bundle :install, :raise_on_error => false
+      ensure
+        FileUtils.chmod("+x", extensions_path)
+      end
+
+      expect(err).not_to include("ERROR REPORT TEMPLATE")
+
+      expect(err).to include(
+        "There was an error while trying to create `#{extensions_path.join("simple_binary-1.0")}`. " \
+        "It is likely that you need to grant executable permissions for all parent directories and write permissions for `#{extensions_path}`."
+      )
+    end
+  end
+
+  describe "when the path of a specific gem is not writable", :permissions do
+    let(:gems_path) { bundled_app("vendor/#{Bundler.ruby_scope}/gems") }
+    let(:foo_path) { gems_path.join("foo-1.0.0") }
+
+    before do
+      build_repo4 do
+        build_gem "foo", "1.0.0" do |s|
+          s.write "CHANGELOG.md", "foo"
+        end
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem 'foo'
+      G
+    end
+
+    it "should display a proper message to explain the problem" do
+      bundle "config set --local path vendor"
+      bundle :install
+      expect(out).to include("Bundle complete!")
+      expect(err).to be_empty
+
+      FileUtils.chmod("-x", foo_path)
+
+      begin
+        bundle "install --redownload", :raise_on_error => false
+      ensure
+        FileUtils.chmod("+x", foo_path)
+      end
+
+      expect(err).not_to include("ERROR REPORT TEMPLATE")
+      expect(err).to include("Could not delete previous installation of `#{foo_path}`.")
+      expect(err).to include("The underlying error was Errno::EACCES")
+    end
+  end
+
+  describe "when bundle cache path does not have write access", :permissions do
+    let(:cache_path) { bundled_app("vendor/#{Bundler.ruby_scope}/cache") }
+
     before do
-      FileUtils.mkdir_p(bundled_app("vendor"))
+      FileUtils.mkdir_p(cache_path)
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem 'rack'
@@ -546,28 +802,29 @@ RSpec.describe "bundle install with gem 
     end
 
     it "should display a proper message to explain the problem" do
-      FileUtils.chmod(0o500, bundled_app("vendor"))
+      FileUtils.chmod(0o500, cache_path)
 
-      bundle :install, forgotten_command_line_options(:path => "vendor")
-      expect(err).to include(bundled_app("vendor").to_s)
+      bundle "config set --local path vendor"
+      bundle :install, :raise_on_error => false
+      expect(err).to include(cache_path.to_s)
       expect(err).to include("grant write permissions")
     end
   end
 
   context "after installing with --standalone" do
     before do
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
-      forgotten_command_line_options(:path => "bundle")
-      bundle! "install", :standalone => true
+      bundle "config set --local path bundle"
+      bundle "install", :standalone => true
     end
 
     it "includes the standalone path" do
-      bundle! "binstubs rack", :standalone => true
+      bundle "binstubs rack", :standalone => true
       standalone_line = File.read(bundled_app("bin/rackup")).each_line.find {|line| line.include? "$:.unshift" }.strip
-      expect(standalone_line).to eq %($:.unshift File.expand_path "../../bundle", path.realpath)
+      expect(standalone_line).to eq %($:.unshift File.expand_path "../bundle", __dir__)
     end
   end
 
@@ -580,10 +837,243 @@ RSpec.describe "bundle install with gem 
     end
 
     it "should display a helpful message explaining how to fix it" do
-      bundle :install, :env => { "BUNDLE_RUBYGEMS__ORG" => "user:pass{word" }
-      expect(exitstatus).to eq(17) if exitstatus
+      bundle :install, :env => { "BUNDLE_RUBYGEMS__ORG" => "user:pass{word" }, :raise_on_error => false
+      expect(exitstatus).to eq(17)
       expect(err).to eq("Please CGI escape your usernames and passwords before " \
                         "setting them for authentication.")
     end
   end
+
+  context "in a frozen bundle" do
+    before do
+      build_repo4 do
+        build_gem "libv8", "8.4.255.0" do |s|
+          s.platform = "x86_64-darwin-19"
+        end
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+
+        gem "libv8"
+      G
+
+      lockfile <<-L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            libv8 (8.4.255.0-x86_64-darwin-19)
+
+        PLATFORMS
+          x86_64-darwin-19
+
+        DEPENDENCIES
+          libv8
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      bundle "config set --local deployment true"
+    end
+
+    it "should fail loudly if the lockfile platforms don't include the current platform" do
+      simulate_platform(Gem::Platform.new("x86_64-linux")) { bundle "install", :raise_on_error => false }
+
+      expect(err).to eq(
+        "Your bundle only supports platforms [\"x86_64-darwin-19\"] but your local platform is x86_64-linux. " \
+        "Add the current platform to the lockfile with\n`bundle lock --add-platform x86_64-linux` and try again."
+      )
+    end
+  end
+
+  context "with missing platform specific gems in lockfile" do
+    before do
+      build_repo4 do
+        build_gem "racc", "1.5.2"
+
+        build_gem "nokogiri", "1.12.4" do |s|
+          s.platform = "x86_64-darwin"
+          s.add_runtime_dependency "racc", "~> 1.4"
+        end
+
+        build_gem "nokogiri", "1.12.4" do |s|
+          s.platform = "x86_64-linux"
+          s.add_runtime_dependency "racc", "~> 1.4"
+        end
+
+        build_gem "crass", "1.0.6"
+
+        build_gem "loofah", "2.12.0" do |s|
+          s.add_runtime_dependency "crass", "~> 1.0.2"
+          s.add_runtime_dependency "nokogiri", ">= 1.5.9"
+        end
+      end
+
+      gemfile <<-G
+        source "https://gem.repo4"
+
+        ruby "#{Gem.ruby_version}"
+
+        gem "loofah", "~> 2.12.0"
+      G
+
+      lockfile <<-L
+        GEM
+          remote: https://gem.repo4/
+          specs:
+            crass (1.0.6)
+            loofah (2.12.0)
+              crass (~> 1.0.2)
+              nokogiri (>= 1.5.9)
+            nokogiri (1.12.4-x86_64-darwin)
+              racc (~> 1.4)
+            racc (1.5.2)
+
+        PLATFORMS
+          x86_64-darwin-20
+          x86_64-linux
+
+        DEPENDENCIES
+          loofah (~> 2.12.0)
+
+        RUBY VERSION
+           #{Bundler::RubyVersion.system}
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+
+    it "automatically fixes the lockfile" do
+      bundle "config set --local path vendor/bundle"
+
+      simulate_platform "x86_64-linux" do
+        bundle "install", :artifice => "compact_index"
+      end
+
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: https://gem.repo4/
+          specs:
+            crass (1.0.6)
+            loofah (2.12.0)
+              crass (~> 1.0.2)
+              nokogiri (>= 1.5.9)
+            nokogiri (1.12.4-x86_64-darwin)
+              racc (~> 1.4)
+            nokogiri (1.12.4-x86_64-linux)
+              racc (~> 1.4)
+            racc (1.5.2)
+
+        PLATFORMS
+          x86_64-darwin-20
+          x86_64-linux
+
+        DEPENDENCIES
+          loofah (~> 2.12.0)
+
+        RUBY VERSION
+           #{Bundler::RubyVersion.system}
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+  end
+
+  context "with --local flag" do
+    before do
+      system_gems "rack-1.0.0", :path => default_bundle_path
+    end
+
+    it "respects installed gems without fetching any remote sources" do
+      install_gemfile <<-G, :local => true
+        source "#{file_uri_for(gem_repo1)}"
+
+        source "https://not-existing-source" do
+          gem "rack"
+        end
+      G
+
+      expect(last_command).to be_success
+    end
+  end
+
+  context "with only option" do
+    before do
+      bundle "config set only a:b"
+    end
+
+    it "installs only gems of the specified groups" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rails"
+        gem "rack", group: :a
+        gem "rake", group: :b
+        gem "yard", group: :c
+      G
+
+      expect(out).to include("Installing rack")
+      expect(out).to include("Installing rake")
+      expect(out).not_to include("Installing yard")
+    end
+  end
+
+  context "with --prefer-local flag" do
+    before do
+      build_repo4 do
+        build_gem "foo", "1.0.1"
+        build_gem "foo", "1.0.0"
+        build_gem "bar", "1.0.0"
+      end
+
+      system_gems "foo-1.0.0", :path => default_bundle_path, :gem_repo => gem_repo4
+    end
+
+    it "fetches remote sources only when not available locally" do
+      install_gemfile <<-G, :"prefer-local" => true, :verbose => true
+        source "#{file_uri_for(gem_repo4)}"
+
+        gem "foo"
+        gem "bar"
+      G
+
+      expect(out).to include("Using foo 1.0.0").and include("Fetching bar 1.0.0").and include("Installing bar 1.0.0")
+      expect(last_command).to be_success
+    end
+  end
+
+  context "with a symlinked configured as bundle path and a gem with symlinks" do
+    before do
+      symlinked_bundled_app = tmp("bundled_app-symlink")
+      File.symlink(bundled_app, symlinked_bundled_app)
+      bundle "config path #{File.join(symlinked_bundled_app, ".vendor")}"
+
+      binman_path = tmp("binman")
+      FileUtils.mkdir_p binman_path
+
+      readme_path = File.join(binman_path, "README.markdown")
+      FileUtils.touch(readme_path)
+
+      man_path = File.join(binman_path, "man", "man0")
+      FileUtils.mkdir_p man_path
+
+      File.symlink("../../README.markdown", File.join(man_path, "README.markdown"))
+
+      build_repo4 do
+        build_gem "binman", :path => gem_repo4("gems"), :lib_path => binman_path, :no_default => true do |s|
+          s.files = ["README.markdown", "man/man0/README.markdown"]
+        end
+      end
+    end
+
+    it "installs fine" do
+      install_gemfile <<~G
+        source "#{file_uri_for(gem_repo4)}"
+
+        gem "binman"
+      G
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/licenses_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/licenses_spec.rb
@@ -2,8 +2,14 @@
 
 RSpec.describe "bundle licenses" do
   before :each do
+    build_repo2 do
+      build_gem "with_license" do |s|
+        s.license = "MIT"
+      end
+    end
+
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+      source "#{file_uri_for(gem_repo2)}"
       gem "rails"
       gem "with_license"
     G
@@ -18,7 +24,7 @@ RSpec.describe "bundle licenses" do
 
   it "performs an automatic bundle install" do
     gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+      source "#{file_uri_for(gem_repo2)}"
       gem "rails"
       gem "with_license"
       gem "foo"
--- ruby2.7-2.7.6.orig/spec/bundler/commands/list_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/list_spec.rb
@@ -3,7 +3,7 @@
 RSpec.describe "bundle list" do
   context "with name-only and paths option" do
     it "raises an error" do
-      bundle "list --name-only --paths"
+      bundle "list --name-only --paths", :raise_on_error => false
 
       expect(err).to eq "The `--name-only` and `--paths` options cannot be used together"
     end
@@ -11,7 +11,7 @@ RSpec.describe "bundle list" do
 
   context "with without-group and only-group option" do
     it "raises an error" do
-      bundle "list --without-group dev --only-group test"
+      bundle "list --without-group dev --only-group test", :raise_on_error => false
 
       expect(err).to eq "The `--only-group` and `--without-group` options cannot be used together"
     end
@@ -24,25 +24,37 @@ RSpec.describe "bundle list" do
 
         gem "rack"
         gem "rspec", :group => [:test]
+        gem "rails", :group => [:production]
       G
     end
 
     context "when group is present" do
       it "prints the gems not in the specified group" do
-        bundle! "list --without-group test"
+        bundle "list --without-group test"
 
         expect(out).to include("  * rack (1.0.0)")
+        expect(out).to include("  * rails (2.3.2)")
         expect(out).not_to include("  * rspec (1.2.7)")
       end
     end
 
     context "when group is not found" do
       it "raises an error" do
-        bundle "list --without-group random"
+        bundle "list --without-group random", :raise_on_error => false
 
         expect(err).to eq "`random` group could not be found."
       end
     end
+
+    context "when multiple groups" do
+      it "prints the gems not in the specified groups" do
+        bundle "list --without-group test production"
+
+        expect(out).to include("  * rack (1.0.0)")
+        expect(out).not_to include("  * rails (2.3.2)")
+        expect(out).not_to include("  * rspec (1.2.7)")
+      end
+    end
   end
 
   describe "with only-group option" do
@@ -52,12 +64,13 @@ RSpec.describe "bundle list" do
 
         gem "rack"
         gem "rspec", :group => [:test]
+        gem "rails", :group => [:production]
       G
     end
 
     context "when group is present" do
       it "prints the gems in the specified group" do
-        bundle! "list --only-group default"
+        bundle "list --only-group default"
 
         expect(out).to include("  * rack (1.0.0)")
         expect(out).not_to include("  * rspec (1.2.7)")
@@ -66,11 +79,21 @@ RSpec.describe "bundle list" do
 
     context "when group is not found" do
       it "raises an error" do
-        bundle "list --only-group random"
+        bundle "list --only-group random", :raise_on_error => false
 
         expect(err).to eq "`random` group could not be found."
       end
     end
+
+    context "when multiple groups" do
+      it "prints the gems in the specified groups" do
+        bundle "list --only-group default production"
+
+        expect(out).to include("  * rack (1.0.0)")
+        expect(out).to include("  * rails (2.3.2)")
+        expect(out).not_to include("  * rspec (1.2.7)")
+      end
+    end
   end
 
   context "with name-only option" do
@@ -94,6 +117,10 @@ RSpec.describe "bundle list" do
   context "with paths option" do
     before do
       build_repo2 do
+        build_gem "rack", "1.2" do |s|
+          s.executables = "rackup"
+        end
+
         build_gem "bar"
       end
 
--- ruby2.7-2.7.6.orig/spec/bundler/commands/lock_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/lock_spec.rb
@@ -15,7 +15,7 @@ RSpec.describe "bundle lock" do
     gemfile <<-G
       source "#{file_uri_for(repo)}"
       gem "rails"
-      gem "with_license"
+      gem "weakling"
       gem "foo"
     G
 
@@ -38,9 +38,9 @@ RSpec.describe "bundle lock" do
             actionpack (= 2.3.2)
             activerecord (= 2.3.2)
             activeresource (= 2.3.2)
-            rake (= 12.3.2)
-          rake (12.3.2)
-          with_license (1.0)
+            rake (= 13.0.1)
+          rake (13.0.1)
+          weakling (0.0.3)
 
       PLATFORMS
         #{lockfile_platforms}
@@ -48,7 +48,7 @@ RSpec.describe "bundle lock" do
       DEPENDENCIES
         foo
         rails
-        with_license
+        weakling
 
       BUNDLED WITH
          #{Bundler::VERSION}
@@ -78,15 +78,15 @@ RSpec.describe "bundle lock" do
   it "writes a lockfile when there is an outdated lockfile using --update" do
     lockfile @lockfile.gsub("2.3.2", "2.3.1")
 
-    bundle! "lock --update"
+    bundle "lock --update"
 
     expect(read_lockfile).to eq(@lockfile)
   end
 
   it "does not fetch remote specs when using the --local option" do
-    bundle "lock --update --local"
+    bundle "lock --update --local", :raise_on_error => false
 
-    expect(err).to match(/sources listed in your Gemfile|installed locally/)
+    expect(err).to match(/locally installed gems/)
   end
 
   it "works with --gemfile flag" do
@@ -133,7 +133,7 @@ RSpec.describe "bundle lock" do
   end
 
   it "update specific gems using --update" do
-    lockfile @lockfile.gsub("2.3.2", "2.3.1").gsub("12.3.2", "10.0.1")
+    lockfile @lockfile.gsub("2.3.2", "2.3.1").gsub("13.0.1", "10.0.1")
 
     bundle "lock --update rails rake"
 
@@ -143,7 +143,7 @@ RSpec.describe "bundle lock" do
   it "errors when updating a missing specific gems using --update" do
     lockfile @lockfile
 
-    bundle "lock --update blahblah"
+    bundle "lock --update blahblah", :raise_on_error => false
     expect(err).to eq("Could not find gem 'blahblah'.")
 
     expect(read_lockfile).to eq(@lockfile)
@@ -156,10 +156,10 @@ RSpec.describe "bundle lock" do
       gem "thin"
       gem "rack_middleware", :group => "test"
     G
-    bundle! "config set without test"
-    bundle! "config set path .bundle"
-    bundle! "lock"
-    expect(bundled_app(".bundle")).not_to exist
+    bundle "config set without test"
+    bundle "config set path vendor/bundle"
+    bundle "lock"
+    expect(bundled_app("vendor/bundle")).not_to exist
   end
 
   # see update_spec for more coverage on same options. logic is shared so it's not necessary
@@ -195,6 +195,8 @@ RSpec.describe "bundle lock" do
         gem 'foo'
         gem 'qux'
       G
+
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
     end
 
     it "single gem updates dependent gem to minor" do
@@ -211,16 +213,43 @@ RSpec.describe "bundle lock" do
   end
 
   it "supports adding new platforms" do
-    bundle! "lock --add-platform java x86-mingw32"
+    bundle "lock --add-platform java x86-mingw32"
 
+    allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
     lockfile = Bundler::LockfileParser.new(read_lockfile)
-    expect(lockfile.platforms).to match_array(local_platforms.unshift(java, mingw).uniq)
+    expect(lockfile.platforms).to match_array([java, x86_mingw32, specific_local_platform].uniq)
+  end
+
+  it "supports adding new platforms with force_ruby_platform = true" do
+    lockfile <<-L
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
+          platform_specific (1.0)
+          platform_specific (1.0-x86-linux)
+
+      PLATFORMS
+        ruby
+        x86-linux
+
+      DEPENDENCIES
+        platform_specific
+    L
+
+    bundle "config set force_ruby_platform true"
+    bundle "lock --add-platform java x86-mingw32"
+
+    allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+    lockfile = Bundler::LockfileParser.new(read_lockfile)
+    expect(lockfile.platforms).to contain_exactly(rb, linux, java, x86_mingw32)
   end
 
   it "supports adding the `ruby` platform" do
-    bundle! "lock --add-platform ruby"
+    bundle "lock --add-platform ruby"
+
+    allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
     lockfile = Bundler::LockfileParser.new(read_lockfile)
-    expect(lockfile.platforms).to match_array(local_platforms.unshift("ruby").uniq)
+    expect(lockfile.platforms).to match_array(["ruby", specific_local_platform].uniq)
   end
 
   it "warns when adding an unknown platform" do
@@ -229,28 +258,29 @@ RSpec.describe "bundle lock" do
   end
 
   it "allows removing platforms" do
-    bundle! "lock --add-platform java x86-mingw32"
+    bundle "lock --add-platform java x86-mingw32"
 
+    allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
     lockfile = Bundler::LockfileParser.new(read_lockfile)
-    expect(lockfile.platforms).to match_array(local_platforms.unshift(java, mingw).uniq)
+    expect(lockfile.platforms).to match_array([java, x86_mingw32, specific_local_platform].uniq)
 
-    bundle! "lock --remove-platform java"
+    bundle "lock --remove-platform java"
 
     lockfile = Bundler::LockfileParser.new(read_lockfile)
-    expect(lockfile.platforms).to match_array(local_platforms.unshift(mingw).uniq)
+    expect(lockfile.platforms).to match_array([x86_mingw32, specific_local_platform].uniq)
   end
 
   it "errors when removing all platforms" do
-    bundle "lock --remove-platform #{local_platforms.join(" ")}"
+    bundle "lock --remove-platform #{specific_local_platform}", :raise_on_error => false
     expect(err).to include("Removing all platforms from the bundle is not allowed")
   end
 
-  # from https://github.com/bundler/bundler/issues/4896
+  # from https://github.com/rubygems/bundler/issues/4896
   it "properly adds platforms when platform requirements come from different dependencies" do
     build_repo4 do
       build_gem "ffi", "1.9.14"
       build_gem "ffi", "1.9.14" do |s|
-        s.platform = mingw
+        s.platform = x86_mingw32
       end
 
       build_gem "gssapi", "0.1"
@@ -282,9 +312,9 @@ RSpec.describe "bundle lock" do
       gem "gssapi"
     G
 
-    simulate_platform(mingw) { bundle! :lock }
+    simulate_platform(x86_mingw32) { bundle :lock }
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
         remote: #{file_uri_for(gem_repo4)}/
         specs:
@@ -307,9 +337,10 @@ RSpec.describe "bundle lock" do
          #{Bundler::VERSION}
     G
 
-    simulate_platform(rb) { bundle! :lock }
+    bundle "config set --local force_ruby_platform true"
+    bundle :lock
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
         remote: #{file_uri_for(gem_repo4)}/
         specs:
@@ -336,6 +367,211 @@ RSpec.describe "bundle lock" do
     G
   end
 
+  it "doesn't crash when an update candidate doesn't have any matching platform" do
+    build_repo4 do
+      build_gem "libv8", "8.4.255.0"
+      build_gem "libv8", "8.4.255.0" do |s|
+        s.platform = "x86_64-darwin-19"
+      end
+
+      build_gem "libv8", "15.0.71.48.1beta2" do |s|
+        s.platform = "x86_64-linux"
+      end
+    end
+
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo4)}"
+
+      gem "libv8"
+    G
+
+    lockfile <<-G
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          libv8 (8.4.255.0)
+          libv8 (8.4.255.0-x86_64-darwin-19)
+
+      PLATFORMS
+        ruby
+        x86_64-darwin-19
+
+      DEPENDENCIES
+        libv8
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    G
+
+    simulate_platform(Gem::Platform.new("x86_64-darwin-19")) { bundle "lock --update" }
+
+    expect(out).to match(/Writing lockfile to.+Gemfile\.lock/)
+  end
+
+  it "adds all more specific candidates when they all have the same dependencies" do
+    build_repo4 do
+      build_gem "libv8", "8.4.255.0" do |s|
+        s.platform = "x86_64-darwin-19"
+      end
+
+      build_gem "libv8", "8.4.255.0" do |s|
+        s.platform = "x86_64-darwin-20"
+      end
+    end
+
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo4)}"
+
+      gem "libv8"
+    G
+
+    simulate_platform(Gem::Platform.new("x86_64-darwin")) { bundle "lock" }
+
+    expect(lockfile).to eq <<~G
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          libv8 (8.4.255.0-x86_64-darwin-19)
+          libv8 (8.4.255.0-x86_64-darwin-20)
+
+      PLATFORMS
+        x86_64-darwin
+
+      DEPENDENCIES
+        libv8
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    G
+  end
+
+  it "respects the previous lockfile if it had a matching less specific platform already locked, and installs the best variant for each platform" do
+    build_repo4 do
+      build_gem "libv8", "8.4.255.0" do |s|
+        s.platform = "x86_64-darwin-19"
+      end
+
+      build_gem "libv8", "8.4.255.0" do |s|
+        s.platform = "x86_64-darwin-20"
+      end
+    end
+
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo4)}"
+
+      gem "libv8"
+    G
+
+    lockfile <<-G
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          libv8 (8.4.255.0-x86_64-darwin-19)
+          libv8 (8.4.255.0-x86_64-darwin-20)
+
+      PLATFORMS
+        x86_64-darwin
+
+      DEPENDENCIES
+        libv8
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    G
+
+    previous_lockfile = lockfile
+
+    %w[x86_64-darwin-19 x86_64-darwin-20].each do |platform|
+      simulate_platform(Gem::Platform.new(platform)) do
+        bundle "lock"
+        expect(lockfile).to eq(previous_lockfile)
+
+        bundle "install"
+        expect(the_bundle).to include_gem("libv8 8.4.255.0 #{platform}")
+      end
+    end
+  end
+
+  it "does not conflict on ruby requirements when adding new platforms" do
+    build_repo4 do
+      build_gem "raygun-apm", "1.0.78" do |s|
+        s.platform = "x86_64-linux"
+        s.required_ruby_version = "< #{next_ruby_minor}.dev"
+      end
+
+      build_gem "raygun-apm", "1.0.78" do |s|
+        s.platform = "universal-darwin"
+        s.required_ruby_version = "< #{next_ruby_minor}.dev"
+      end
+
+      build_gem "raygun-apm", "1.0.78" do |s|
+        s.platform = "x64-mingw32"
+        s.required_ruby_version = "< #{next_ruby_minor}.dev"
+      end
+
+      build_gem "raygun-apm", "1.0.78" do |s|
+        s.platform = "x64-mingw-ucrt"
+        s.required_ruby_version = "< #{next_ruby_minor}.dev"
+      end
+    end
+
+    gemfile <<-G
+      source "https://localgemserver.test"
+
+      gem "raygun-apm"
+    G
+
+    lockfile <<-L
+      GEM
+        remote: https://localgemserver.test/
+        specs:
+          raygun-apm (1.0.78-universal-darwin)
+
+      PLATFORMS
+        x86_64-darwin-19
+
+      DEPENDENCIES
+        raygun-apm
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    bundle "lock --add-platform x86_64-linux", :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
+  end
+
+  it "respects lower bound ruby requirements" do
+    build_repo4 do
+      build_gem "our_private_gem", "0.1.0" do |s|
+        s.required_ruby_version = ">= #{Gem.ruby_version}"
+      end
+    end
+
+    gemfile <<-G
+      source "https://localgemserver.test"
+
+      gem "our_private_gem"
+    G
+
+    lockfile <<-L
+      GEM
+        remote: https://localgemserver.test/
+        specs:
+          our_private_gem (0.1.0)
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        our_private_gem
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    bundle "install", :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
+  end
+
   context "when an update is available" do
     let(:repo) { gem_repo2 }
 
@@ -347,14 +583,14 @@ RSpec.describe "bundle lock" do
     end
 
     it "does not implicitly update" do
-      bundle! "lock"
+      bundle "lock"
 
       expect(read_lockfile).to eq(@lockfile)
     end
 
     it "accounts for changes in the gemfile" do
       gemfile gemfile.gsub('"foo"', '"foo", "2.0"')
-      bundle! "lock"
+      bundle "lock"
 
       expect(read_lockfile).to eq(@lockfile.sub("foo (1.0)", "foo (2.0)").sub(/foo$/, "foo (= 2.0)"))
     end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/newgem_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/newgem_spec.rb
@@ -10,92 +10,68 @@ RSpec.describe "bundle gem" do
     expect(bundled_app("#{gem_name}/lib/#{require_path}/version.rb")).to exist
   end
 
+  def bundle_exec_rubocop
+    prepare_gemspec(bundled_app(gem_name, "#{gem_name}.gemspec"))
+    bundle "config set path #{rubocop_gems}", :dir => bundled_app(gem_name)
+    bundle "exec rubocop --debug --config .rubocop.yml", :dir => bundled_app(gem_name)
+  end
+
+  def bundle_exec_standardrb
+    prepare_gemspec(bundled_app(gem_name, "#{gem_name}.gemspec"))
+    bundle "config set path #{standard_gems}", :dir => bundled_app(gem_name)
+    bundle "exec standardrb --debug", :dir => bundled_app(gem_name)
+  end
+
   let(:generated_gemspec) { Bundler.load_gemspec_uncached(bundled_app(gem_name).join("#{gem_name}.gemspec")) }
 
   let(:gem_name) { "mygem" }
 
   let(:require_path) { "mygem" }
 
-  before do
-    global_config "BUNDLE_GEM__MIT" => "false", "BUNDLE_GEM__TEST" => "false", "BUNDLE_GEM__COC" => "false"
-    git_config_content = <<-EOF
-    [user]
-      name = "Bundler User"
-      email = user@example.com
-    [github]
-      user = bundleuser
-    EOF
-    @git_config_location = ENV["GIT_CONFIG"]
-    path = "#{tmp}/test_git_config.txt"
-    File.open(path, "w") {|f| f.write(git_config_content) }
-    ENV["GIT_CONFIG"] = path
-  end
-
-  after do
-    FileUtils.rm(ENV["GIT_CONFIG"]) if File.exist?(ENV["GIT_CONFIG"])
-    ENV["GIT_CONFIG"] = @git_config_location
-  end
-
-  shared_examples_for "git config is present" do
-    context "git config user.{name,email} present" do
-      it "sets gemspec author to git user.name if available" do
-        expect(generated_gemspec.authors.first).to eq("Bundler User")
-      end
+  let(:minitest_test_file_path) { "test/test_mygem.rb" }
 
-      it "sets gemspec email to git user.email if available" do
-        expect(generated_gemspec.email.first).to eq("user@example.com")
-      end
-    end
-  end
+  let(:minitest_test_class_name) { "class TestMygem < Minitest::Test" }
 
-  shared_examples_for "git config is absent" do
-    it "sets gemspec author to default message if git user.name is not set or empty" do
-      expect(generated_gemspec.authors.first).to eq("TODO: Write your name")
-    end
-
-    it "sets gemspec email to default message if git user.email is not set or empty" do
-      expect(generated_gemspec.email.first).to eq("TODO: Write your email address")
-    end
+  before do
+    sys_exec("git config --global user.name 'Bundler User'")
+    sys_exec("git config --global user.email user@example.com")
+    sys_exec("git config --global github.user bundleuser")
   end
 
   describe "git repo initialization" do
-    shared_examples_for "a gem with an initial git repo" do
-      before do
-        bundle! "gem #{gem_name} #{flags}"
-      end
-
-      it "generates a gem skeleton with a .git folder" do
-        gem_skeleton_assertions
-        expect(bundled_app("#{gem_name}/.git")).to exist
-      end
+    it "generates a gem skeleton with a .git folder", :readline do
+      bundle "gem #{gem_name}"
+      gem_skeleton_assertions
+      expect(bundled_app("#{gem_name}/.git")).to exist
     end
 
-    context "when using the default" do
-      it_behaves_like "a gem with an initial git repo" do
-        let(:flags) { "" }
-      end
+    it "generates a gem skeleton with a .git folder when passing --git", :readline do
+      bundle "gem #{gem_name} --git"
+      gem_skeleton_assertions
+      expect(bundled_app("#{gem_name}/.git")).to exist
     end
 
-    context "when explicitly passing --git" do
-      it_behaves_like "a gem with an initial git repo" do
-        let(:flags) { "--git" }
-      end
+    it "generates a gem skeleton without a .git folder when passing --no-git", :readline do
+      bundle "gem #{gem_name} --no-git"
+      gem_skeleton_assertions
+      expect(bundled_app("#{gem_name}/.git")).not_to exist
     end
 
-    context "when passing --no-git" do
+    context "on a path with spaces" do
       before do
-        bundle! "gem #{gem_name} --no-git"
+        Dir.mkdir(bundled_app("path with spaces"))
       end
-      it "generates a gem skeleton without a .git folder" do
-        gem_skeleton_assertions
-        expect(bundled_app("#{gem_name}/.git")).not_to exist
+
+      it "properly initializes git repo", :readline do
+        bundle "gem #{gem_name}", :dir => bundled_app("path with spaces")
+        expect(bundled_app("path with spaces/#{gem_name}/.git")).to exist
       end
     end
   end
 
   shared_examples_for "--mit flag" do
     before do
-      bundle! "gem #{gem_name} --mit"
+      bundle "gem #{gem_name} --mit"
     end
     it "generates a gem skeleton with MIT license" do
       gem_skeleton_assertions
@@ -106,7 +82,7 @@ RSpec.describe "bundle gem" do
 
   shared_examples_for "--no-mit flag" do
     before do
-      bundle! "gem #{gem_name} --no-mit"
+      bundle "gem #{gem_name} --no-mit"
     end
     it "generates a gem skeleton without MIT license" do
       gem_skeleton_assertions
@@ -115,43 +91,283 @@ RSpec.describe "bundle gem" do
   end
 
   shared_examples_for "--coc flag" do
-    before do
-      bundle! "gem #{gem_name} --coc"
-    end
     it "generates a gem skeleton with MIT license" do
+      bundle "gem #{gem_name} --coc"
       gem_skeleton_assertions
       expect(bundled_app("#{gem_name}/CODE_OF_CONDUCT.md")).to exist
     end
 
-    describe "README additions" do
-      it "generates the README with a section for the Code of Conduct" do
-        expect(bundled_app("#{gem_name}/README.md").read).to include("## Code of Conduct")
-        expect(bundled_app("#{gem_name}/README.md").read).to include("https://github.com/bundleuser/#{gem_name}/blob/master/CODE_OF_CONDUCT.md")
-      end
+    it "generates the README with a section for the Code of Conduct" do
+      bundle "gem #{gem_name} --coc"
+      expect(bundled_app("#{gem_name}/README.md").read).to include("## Code of Conduct")
+      expect(bundled_app("#{gem_name}/README.md").read).to match(%r{https://github\.com/bundleuser/#{gem_name}/blob/.*/CODE_OF_CONDUCT.md})
+    end
+
+    it "generates the README with a section for the Code of Conduct, respecting the configured git default branch", :git => ">= 2.28.0" do
+      sys_exec("git config --global init.defaultBranch main")
+      bundle "gem #{gem_name} --coc"
+
+      expect(bundled_app("#{gem_name}/README.md").read).to include("## Code of Conduct")
+      expect(bundled_app("#{gem_name}/README.md").read).to include("https://github.com/bundleuser/#{gem_name}/blob/main/CODE_OF_CONDUCT.md")
     end
   end
 
   shared_examples_for "--no-coc flag" do
     before do
-      bundle! "gem #{gem_name} --no-coc"
+      bundle "gem #{gem_name} --no-coc"
     end
     it "generates a gem skeleton without Code of Conduct" do
       gem_skeleton_assertions
       expect(bundled_app("#{gem_name}/CODE_OF_CONDUCT.md")).to_not exist
     end
 
-    describe "README additions" do
-      it "generates the README without a section for the Code of Conduct" do
-        expect(bundled_app("#{gem_name}/README.md").read).not_to include("## Code of Conduct")
-        expect(bundled_app("#{gem_name}/README.md").read).not_to include("https://github.com/bundleuser/#{gem_name}/blob/master/CODE_OF_CONDUCT.md")
+    it "generates the README without a section for the Code of Conduct" do
+      expect(bundled_app("#{gem_name}/README.md").read).not_to include("## Code of Conduct")
+      expect(bundled_app("#{gem_name}/README.md").read).not_to match(%r{https://github\.com/bundleuser/#{gem_name}/blob/.*/CODE_OF_CONDUCT.md})
+    end
+  end
+
+  shared_examples_for "--changelog flag" do
+    before do
+      bundle "gem #{gem_name} --changelog"
+    end
+    it "generates a gem skeleton with a CHANGELOG", :readline do
+      gem_skeleton_assertions
+      expect(bundled_app("#{gem_name}/CHANGELOG.md")).to exist
+    end
+  end
+
+  shared_examples_for "--no-changelog flag" do
+    before do
+      bundle "gem #{gem_name} --no-changelog"
+    end
+    it "generates a gem skeleton without a CHANGELOG", :readline do
+      gem_skeleton_assertions
+      expect(bundled_app("#{gem_name}/CHANGELOG.md")).to_not exist
+    end
+  end
+
+  shared_examples_for "--rubocop flag" do
+    context "is deprecated", :bundler => "< 3" do
+      before do
+        bundle "gem #{gem_name} --rubocop"
+      end
+
+      it "generates a gem skeleton with rubocop" do
+        gem_skeleton_assertions
+        expect(bundled_app("test-gem/Rakefile")).to read_as(
+          include("# frozen_string_literal: true").
+          and(include('require "rubocop/rake_task"').
+          and(include("RuboCop::RakeTask.new").
+          and(match(/default:.+:rubocop/))))
+        )
+      end
+
+      it "includes rubocop in generated Gemfile" do
+        allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+        builder = Bundler::Dsl.new
+        builder.eval_gemfile(bundled_app("#{gem_name}/Gemfile"))
+        builder.dependencies
+        rubocop_dep = builder.dependencies.find {|d| d.name == "rubocop" }
+        expect(rubocop_dep).not_to be_nil
+      end
+
+      it "generates a default .rubocop.yml" do
+        expect(bundled_app("#{gem_name}/.rubocop.yml")).to exist
       end
     end
   end
 
-  context "README.md" do
+  shared_examples_for "--no-rubocop flag" do
+    context "is deprecated", :bundler => "< 3" do
+      define_negated_matcher :exclude, :include
+
+      before do
+        bundle "gem #{gem_name} --no-rubocop"
+      end
+
+      it "generates a gem skeleton without rubocop" do
+        gem_skeleton_assertions
+        expect(bundled_app("test-gem/Rakefile")).to read_as(exclude("rubocop"))
+        expect(bundled_app("test-gem/#{gem_name}.gemspec")).to read_as(exclude("rubocop"))
+      end
+
+      it "does not include rubocop in generated Gemfile" do
+        allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+        builder = Bundler::Dsl.new
+        builder.eval_gemfile(bundled_app("#{gem_name}/Gemfile"))
+        builder.dependencies
+        rubocop_dep = builder.dependencies.find {|d| d.name == "rubocop" }
+        expect(rubocop_dep).to be_nil
+      end
+
+      it "doesn't generate a default .rubocop.yml" do
+        expect(bundled_app("#{gem_name}/.rubocop.yml")).to_not exist
+      end
+    end
+  end
+
+  shared_examples_for "--linter=rubocop flag" do
+    before do
+      bundle "gem #{gem_name} --linter=rubocop"
+    end
+
+    it "generates a gem skeleton with rubocop" do
+      gem_skeleton_assertions
+      expect(bundled_app("test-gem/Rakefile")).to read_as(
+        include("# frozen_string_literal: true").
+        and(include('require "rubocop/rake_task"').
+        and(include("RuboCop::RakeTask.new").
+        and(match(/default:.+:rubocop/))))
+      )
+    end
+
+    it "includes rubocop in generated Gemfile" do
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+      builder = Bundler::Dsl.new
+      builder.eval_gemfile(bundled_app("#{gem_name}/Gemfile"))
+      builder.dependencies
+      rubocop_dep = builder.dependencies.find {|d| d.name == "rubocop" }
+      expect(rubocop_dep).not_to be_nil
+    end
+
+    it "generates a default .rubocop.yml" do
+      expect(bundled_app("#{gem_name}/.rubocop.yml")).to exist
+    end
+  end
+
+  shared_examples_for "--linter=standard flag" do
+    before do
+      bundle "gem #{gem_name} --linter=standard"
+    end
+
+    it "generates a gem skeleton with standard" do
+      gem_skeleton_assertions
+      expect(bundled_app("test-gem/Rakefile")).to read_as(
+        include('require "standard/rake"').
+        and(match(/default:.+:standard/))
+      )
+    end
+
+    it "includes standard in generated Gemfile" do
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+      builder = Bundler::Dsl.new
+      builder.eval_gemfile(bundled_app("#{gem_name}/Gemfile"))
+      builder.dependencies
+      standard_dep = builder.dependencies.find {|d| d.name == "standard" }
+      expect(standard_dep).not_to be_nil
+    end
+
+    it "generates a default .standard.yml" do
+      expect(bundled_app("#{gem_name}/.standard.yml")).to exist
+    end
+  end
+
+  shared_examples_for "--linter=none flag" do
+    define_negated_matcher :exclude, :include
+
+    before do
+      bundle "gem #{gem_name} --linter=none"
+    end
+
+    it "generates a gem skeleton without rubocop" do
+      gem_skeleton_assertions
+      expect(bundled_app("test-gem/Rakefile")).to read_as(exclude("rubocop"))
+      expect(bundled_app("test-gem/#{gem_name}.gemspec")).to read_as(exclude("rubocop"))
+    end
+
+    it "does not include rubocop in generated Gemfile" do
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+      builder = Bundler::Dsl.new
+      builder.eval_gemfile(bundled_app("#{gem_name}/Gemfile"))
+      builder.dependencies
+      rubocop_dep = builder.dependencies.find {|d| d.name == "rubocop" }
+      expect(rubocop_dep).to be_nil
+    end
+
+    it "does not include standard in generated Gemfile" do
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+      builder = Bundler::Dsl.new
+      builder.eval_gemfile(bundled_app("#{gem_name}/Gemfile"))
+      builder.dependencies
+      standard_dep = builder.dependencies.find {|d| d.name == "standard" }
+      expect(standard_dep).to be_nil
+    end
+
+    it "doesn't generate a default .rubocop.yml" do
+      expect(bundled_app("#{gem_name}/.rubocop.yml")).to_not exist
+    end
+
+    it "doesn't generate a default .standard.yml" do
+      expect(bundled_app("#{gem_name}/.standard.yml")).to_not exist
+    end
+  end
+
+  it "has no rubocop offenses when using --linter=rubocop flag", :readline do
+    skip "ruby_core has an 'ast.rb' file that gets in the middle and breaks this spec" if ruby_core?
+    bundle "gem #{gem_name} --linter=rubocop"
+    bundle_exec_rubocop
+    expect(last_command).to be_success
+  end
+
+  it "has no rubocop offenses when using --ext and --linter=rubocop flag", :readline do
+    skip "ruby_core has an 'ast.rb' file that gets in the middle and breaks this spec" if ruby_core?
+    bundle "gem #{gem_name} --ext --linter=rubocop"
+    bundle_exec_rubocop
+    expect(last_command).to be_success
+  end
+
+  it "has no rubocop offenses when using --ext, --test=minitest, and --linter=rubocop flag", :readline do
+    skip "ruby_core has an 'ast.rb' file that gets in the middle and breaks this spec" if ruby_core?
+    bundle "gem #{gem_name} --ext --test=minitest --linter=rubocop"
+    bundle_exec_rubocop
+    expect(last_command).to be_success
+  end
+
+  it "has no rubocop offenses when using --ext, --test=rspec, and --linter=rubocop flag", :readline do
+    skip "ruby_core has an 'ast.rb' file that gets in the middle and breaks this spec" if ruby_core?
+    bundle "gem #{gem_name} --ext --test=rspec --linter=rubocop"
+    bundle_exec_rubocop
+    expect(last_command).to be_success
+  end
+
+  it "has no rubocop offenses when using --ext, --ext=test-unit, and --linter=rubocop flag", :readline do
+    skip "ruby_core has an 'ast.rb' file that gets in the middle and breaks this spec" if ruby_core?
+    bundle "gem #{gem_name} --ext --test=test-unit --linter=rubocop"
+    bundle_exec_rubocop
+    expect(last_command).to be_success
+  end
+
+  it "has no standard offenses when using --linter=standard flag", :readline do
+    skip "ruby_core has an 'ast.rb' file that gets in the middle and breaks this spec" if ruby_core?
+    bundle "gem #{gem_name} --linter=standard"
+    bundle_exec_standardrb
+    expect(last_command).to be_success
+  end
+
+  shared_examples_for "CI config is absent" do
+    it "does not create any CI files" do
+      expect(bundled_app("#{gem_name}/.github/workflows/main.yml")).to_not exist
+      expect(bundled_app("#{gem_name}/.travis.yml")).to_not exist
+      expect(bundled_app("#{gem_name}/.gitlab-ci.yml")).to_not exist
+      expect(bundled_app("#{gem_name}/.circleci/config.yml")).to_not exist
+    end
+  end
+
+  shared_examples_for "test framework is absent" do
+    it "does not create any test framework files" do
+      expect(bundled_app("#{gem_name}/.rspec")).to_not exist
+      expect(bundled_app("#{gem_name}/spec/#{require_path}_spec.rb")).to_not exist
+      expect(bundled_app("#{gem_name}/spec/spec_helper.rb")).to_not exist
+      expect(bundled_app("#{gem_name}/test/#{require_path}.rb")).to_not exist
+      expect(bundled_app("#{gem_name}/test/test_helper.rb")).to_not exist
+    end
+  end
+
+  context "README.md", :readline do
     context "git config github.user present" do
       before do
-        bundle! "gem #{gem_name}"
+        bundle "gem #{gem_name}"
       end
 
       it "contribute URL set to git username" do
@@ -162,7 +378,7 @@ RSpec.describe "bundle gem" do
 
     context "git config github.user is absent" do
       before do
-        sys_exec("git config --unset github.user")
+        sys_exec("git config --global --unset github.user")
         bundle "gem #{gem_name}"
       end
 
@@ -173,18 +389,18 @@ RSpec.describe "bundle gem" do
     end
   end
 
-  it "creates a new git repository" do
+  it "creates a new git repository", :readline do
     bundle "gem #{gem_name}"
     expect(bundled_app("#{gem_name}/.git")).to exist
   end
 
-  context "when git is not available" do
+  context "when git is not available", :readline do
     # This spec cannot have `git` available in the test env
     before do
       load_paths = [lib_dir, spec_dir]
       load_path_str = "-I#{load_paths.join(File::PATH_SEPARATOR)}"
 
-      sys_exec "#{Gem.ruby} #{load_path_str} #{bindir.join("bundle")} gem #{gem_name}", "PATH" => ""
+      sys_exec "#{Gem.ruby} #{load_path_str} #{bindir.join("bundle")} gem #{gem_name}", :env => { "PATH" => "" }
     end
 
     it "creates the gem without the need for git" do
@@ -200,25 +416,24 @@ RSpec.describe "bundle gem" do
     end
   end
 
-  it "generates a valid gemspec" do
-    bundle! "gem newgem --bin"
+  it "generates a valid gemspec", :readline, :ruby_repo do
+    bundle "gem newgem --bin"
 
     prepare_gemspec(bundled_app("newgem", "newgem.gemspec"))
 
-    Dir.chdir(bundled_app("newgem")) do
-      gems = ["rake-12.3.2"]
-      system_gems gems, :path => :bundle_path
-      bundle! "exec rake build"
-    end
+    gems = ["rake-13.0.1"]
+    path = Bundler.feature_flag.default_install_uses_path? ? local_gem_path(:base => bundled_app("newgem")) : system_gem_path
+    system_gems gems, :path => path
+    bundle "exec rake build", :dir => bundled_app("newgem")
 
     expect(last_command.stdboth).not_to include("ERROR")
   end
 
-  context "gem naming with relative paths" do
+  context "gem naming with relative paths", :readline do
     it "resolves ." do
       create_temporary_dir("tmp")
 
-      bundle "gem ."
+      bundle "gem .", :dir => bundled_app("tmp")
 
       expect(bundled_app("tmp/lib/tmp.rb")).to exist
     end
@@ -226,7 +441,7 @@ RSpec.describe "bundle gem" do
     it "resolves .." do
       create_temporary_dir("temp/empty_dir")
 
-      bundle "gem .."
+      bundle "gem ..", :dir => bundled_app("temp/empty_dir")
 
       expect(bundled_app("temp/lib/temp.rb")).to exist
     end
@@ -234,89 +449,164 @@ RSpec.describe "bundle gem" do
     it "resolves relative directory" do
       create_temporary_dir("tmp/empty/tmp")
 
-      bundle "gem ../../empty"
+      bundle "gem ../../empty", :dir => bundled_app("tmp/empty/tmp")
 
       expect(bundled_app("tmp/empty/lib/empty.rb")).to exist
     end
 
     def create_temporary_dir(dir)
-      FileUtils.mkdir_p(dir)
-      Dir.chdir(dir)
+      FileUtils.mkdir_p(bundled_app(dir))
+    end
+  end
+
+  shared_examples_for "--github-username option" do |github_username|
+    before do
+      bundle "gem #{gem_name} --github-username=#{github_username}"
+    end
+
+    it "generates a gem skeleton" do
+      gem_skeleton_assertions
+    end
+
+    it "contribute URL set to given github username" do
+      expect(bundled_app("#{gem_name}/README.md").read).not_to include("[USERNAME]")
+      expect(bundled_app("#{gem_name}/README.md").read).to include("github.com/#{github_username}")
+    end
+  end
+
+  shared_examples_for "github_username configuration" do
+    context "with github_username setting set to some value" do
+      before do
+        global_config "BUNDLE_GEM__GITHUB_USERNAME" => "different_username"
+        bundle "gem #{gem_name}"
+      end
+
+      it "generates a gem skeleton" do
+        gem_skeleton_assertions
+      end
+
+      it "contribute URL set to bundle config setting" do
+        expect(bundled_app("#{gem_name}/README.md").read).not_to include("[USERNAME]")
+        expect(bundled_app("#{gem_name}/README.md").read).to include("github.com/different_username")
+      end
+    end
+
+    context "with github_username setting set to false" do
+      before do
+        global_config "BUNDLE_GEM__GITHUB_USERNAME" => "false"
+        bundle "gem #{gem_name}"
+      end
+
+      it "generates a gem skeleton" do
+        gem_skeleton_assertions
+      end
+
+      it "contribute URL set to [USERNAME]" do
+        expect(bundled_app("#{gem_name}/README.md").read).to include("[USERNAME]")
+        expect(bundled_app("#{gem_name}/README.md").read).not_to include("github.com/bundleuser")
+      end
     end
   end
 
   shared_examples_for "generating a gem" do
     it "generates a gem skeleton" do
-      bundle! "gem #{gem_name}"
+      bundle "gem #{gem_name}"
 
       expect(bundled_app("#{gem_name}/#{gem_name}.gemspec")).to exist
       expect(bundled_app("#{gem_name}/Gemfile")).to exist
       expect(bundled_app("#{gem_name}/Rakefile")).to exist
       expect(bundled_app("#{gem_name}/lib/#{require_path}.rb")).to exist
       expect(bundled_app("#{gem_name}/lib/#{require_path}/version.rb")).to exist
+      expect(bundled_app("#{gem_name}/sig/#{require_path}.rbs")).to exist
       expect(bundled_app("#{gem_name}/.gitignore")).to exist
 
       expect(bundled_app("#{gem_name}/bin/setup")).to exist
       expect(bundled_app("#{gem_name}/bin/console")).to exist
       expect(bundled_app("#{gem_name}/bin/setup")).to be_executable
       expect(bundled_app("#{gem_name}/bin/console")).to be_executable
+      expect(bundled_app("#{gem_name}/bin/setup").read).to start_with("#!")
+      expect(bundled_app("#{gem_name}/bin/console").read).to start_with("#!")
     end
 
     it "starts with version 0.1.0" do
-      bundle! "gem #{gem_name}"
+      bundle "gem #{gem_name}"
 
       expect(bundled_app("#{gem_name}/lib/#{require_path}/version.rb").read).to match(/VERSION = "0.1.0"/)
     end
 
+    it "declare String type for VERSION constant" do
+      bundle "gem #{gem_name}"
+
+      expect(bundled_app("#{gem_name}/sig/#{require_path}.rbs").read).to match(/VERSION: String/)
+    end
+
     context "git config user.{name,email} is set" do
       before do
-        bundle! "gem #{gem_name}"
+        bundle "gem #{gem_name}"
+      end
+
+      it "sets gemspec author to git user.name if available" do
+        expect(generated_gemspec.authors.first).to eq("Bundler User")
       end
 
-      it_should_behave_like "git config is present"
+      it "sets gemspec email to git user.email if available" do
+        expect(generated_gemspec.email.first).to eq("user@example.com")
+      end
     end
 
     context "git config user.{name,email} is not set" do
       before do
-        `git config --unset user.name`
-        `git config --unset user.email`
+        sys_exec("git config --global --unset user.name")
+        sys_exec("git config --global --unset user.email")
         bundle "gem #{gem_name}"
       end
 
-      it_should_behave_like "git config is absent"
+      it "sets gemspec author to default message if git user.name is not set or empty" do
+        expect(generated_gemspec.authors.first).to eq("TODO: Write your name")
+      end
+
+      it "sets gemspec email to default message if git user.email is not set or empty" do
+        expect(generated_gemspec.email.first).to eq("TODO: Write your email address")
+      end
     end
 
     it "sets gemspec metadata['allowed_push_host']" do
-      bundle! "gem #{gem_name}"
+      bundle "gem #{gem_name}"
 
       expect(generated_gemspec.metadata["allowed_push_host"]).
-        to match(/mygemserver\.com/)
+        to match(/example\.com/)
     end
 
     it "sets a minimum ruby version" do
-      bundle! "gem #{gem_name}"
-
-      bundler_gemspec = Bundler::GemHelper.new(gemspec_dir).gemspec
+      bundle "gem #{gem_name}"
 
-      expect(bundler_gemspec.required_ruby_version).to eq(generated_gemspec.required_ruby_version)
+      expect(generated_gemspec.required_ruby_version.to_s).to start_with(">=")
     end
 
     it "requires the version file" do
-      bundle! "gem #{gem_name}"
+      bundle "gem #{gem_name}"
 
-      expect(bundled_app("#{gem_name}/lib/#{require_path}.rb").read).to match(%r{require "#{require_path}/version"})
+      expect(bundled_app("#{gem_name}/lib/#{require_path}.rb").read).to match(%r{require_relative "#{require_relative_path}/version"})
     end
 
     it "creates a base error class" do
-      bundle! "gem #{gem_name}"
+      bundle "gem #{gem_name}"
 
       expect(bundled_app("#{gem_name}/lib/#{require_path}.rb").read).to match(/class Error < StandardError; end$/)
     end
 
+    it "does not include the gemspec file in files" do
+      bundle "gem #{gem_name}"
+
+      bundler_gemspec = Bundler::GemHelper.new(gemspec_dir).gemspec
+
+      expect(bundler_gemspec.files).not_to include("#{gem_name}.gemspec")
+    end
+
     it "runs rake without problems" do
-      bundle! "gem #{gem_name}"
+      bundle "gem #{gem_name}"
 
-      system_gems ["rake-12.3.2"]
+      system_gems ["rake-13.0.1"]
 
       rakefile = strip_whitespace <<-RAKEFILE
         task :default do
@@ -327,10 +617,8 @@ RSpec.describe "bundle gem" do
         file.puts rakefile
       end
 
-      Dir.chdir(bundled_app(gem_name)) do
-        sys_exec(rake)
-        expect(out).to include("SUCCESS")
-      end
+      sys_exec(rake, :dir => bundled_app(gem_name))
+      expect(out).to include("SUCCESS")
     end
 
     context "--exe parameter set" do
@@ -366,13 +654,7 @@ RSpec.describe "bundle gem" do
         bundle "gem #{gem_name}"
       end
 
-      it "doesn't create any spec/test file" do
-        expect(bundled_app("#{gem_name}/.rspec")).to_not exist
-        expect(bundled_app("#{gem_name}/spec/#{require_path}_spec.rb")).to_not exist
-        expect(bundled_app("#{gem_name}/spec/spec_helper.rb")).to_not exist
-        expect(bundled_app("#{gem_name}/test/#{require_path}.rb")).to_not exist
-        expect(bundled_app("#{gem_name}/test/minitest_helper.rb")).to_not exist
-      end
+      it_behaves_like "test framework is absent"
     end
 
     context "--test parameter set to rspec" do
@@ -387,13 +669,12 @@ RSpec.describe "bundle gem" do
       end
 
       it "depends on a specific version of rspec in generated Gemfile" do
-        Dir.chdir(bundled_app(gem_name)) do
-          builder = Bundler::Dsl.new
-          builder.eval_gemfile(bundled_app("#{gem_name}/Gemfile"))
-          builder.dependencies
-          rspec_dep = builder.dependencies.find {|d| d.name == "rspec" }
-          expect(rspec_dep).to be_specific
-        end
+        allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+        builder = Bundler::Dsl.new
+        builder.eval_gemfile(bundled_app("#{gem_name}/Gemfile"))
+        builder.dependencies
+        rspec_dep = builder.dependencies.find {|d| d.name == "rspec" }
+        expect(rspec_dep).to be_specific
       end
 
       it "requires the main file" do
@@ -425,7 +706,7 @@ RSpec.describe "bundle gem" do
       end
 
       it "builds spec skeleton" do
-        expect(bundled_app("#{gem_name}/test/#{require_path}_test.rb")).to exist
+        expect(bundled_app("#{gem_name}/#{minitest_test_file_path}")).to exist
         expect(bundled_app("#{gem_name}/test/test_helper.rb")).to exist
       end
     end
@@ -436,17 +717,16 @@ RSpec.describe "bundle gem" do
       end
 
       it "depends on a specific version of minitest" do
-        Dir.chdir(bundled_app(gem_name)) do
-          builder = Bundler::Dsl.new
-          builder.eval_gemfile(bundled_app("#{gem_name}/Gemfile"))
-          builder.dependencies
-          minitest_dep = builder.dependencies.find {|d| d.name == "minitest" }
-          expect(minitest_dep).to be_specific
-        end
+        allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+        builder = Bundler::Dsl.new
+        builder.eval_gemfile(bundled_app("#{gem_name}/Gemfile"))
+        builder.dependencies
+        minitest_dep = builder.dependencies.find {|d| d.name == "minitest" }
+        expect(minitest_dep).to be_specific
       end
 
       it "builds spec skeleton" do
-        expect(bundled_app("#{gem_name}/test/#{require_path}_test.rb")).to exist
+        expect(bundled_app("#{gem_name}/#{minitest_test_file_path}")).to exist
         expect(bundled_app("#{gem_name}/test/test_helper.rb")).to exist
       end
 
@@ -454,12 +734,16 @@ RSpec.describe "bundle gem" do
         expect(bundled_app("#{gem_name}/test/test_helper.rb").read).to include(%(require "#{require_path}"))
       end
 
-      it "requires 'minitest_helper'" do
-        expect(bundled_app("#{gem_name}/test/#{require_path}_test.rb").read).to include(%(require "test_helper"))
+      it "requires 'test_helper'" do
+        expect(bundled_app("#{gem_name}/#{minitest_test_file_path}").read).to include(%(require "test_helper"))
+      end
+
+      it "defines valid test class name" do
+        expect(bundled_app("#{gem_name}/#{minitest_test_file_path}").read).to include(minitest_test_class_name)
       end
 
       it "creates a default test which fails" do
-        expect(bundled_app("#{gem_name}/test/#{require_path}_test.rb").read).to include("assert false")
+        expect(bundled_app("#{gem_name}/#{minitest_test_file_path}").read).to include("assert false")
       end
     end
 
@@ -471,6 +755,66 @@ RSpec.describe "bundle gem" do
 
       it "creates a default rake task to run the test suite" do
         rakefile = strip_whitespace <<-RAKEFILE
+          # frozen_string_literal: true
+
+          require "bundler/gem_tasks"
+          require "rake/testtask"
+
+          Rake::TestTask.new(:test) do |t|
+            t.libs << "test"
+            t.libs << "lib"
+            t.test_files = FileList["test/**/test_*.rb"]
+          end
+
+          task default: :test
+        RAKEFILE
+
+        expect(bundled_app("#{gem_name}/Rakefile").read).to eq(rakefile)
+      end
+    end
+
+    context "--test parameter set to test-unit" do
+      before do
+        bundle "gem #{gem_name} --test=test-unit"
+      end
+
+      it "depends on a specific version of test-unit" do
+        allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+        builder = Bundler::Dsl.new
+        builder.eval_gemfile(bundled_app("#{gem_name}/Gemfile"))
+        builder.dependencies
+        test_unit_dep = builder.dependencies.find {|d| d.name == "test-unit" }
+        expect(test_unit_dep).to be_specific
+      end
+
+      it "builds spec skeleton" do
+        expect(bundled_app("#{gem_name}/test/#{require_path}_test.rb")).to exist
+        expect(bundled_app("#{gem_name}/test/test_helper.rb")).to exist
+      end
+
+      it "requires the main file" do
+        expect(bundled_app("#{gem_name}/test/test_helper.rb").read).to include(%(require "#{require_path}"))
+      end
+
+      it "requires 'test_helper'" do
+        expect(bundled_app("#{gem_name}/test/#{require_path}_test.rb").read).to include(%(require "test_helper"))
+      end
+
+      it "creates a default test which fails" do
+        expect(bundled_app("#{gem_name}/test/#{require_path}_test.rb").read).to include("assert_equal(\"expected\", \"actual\")")
+      end
+    end
+
+    context "gem.test setting set to test-unit" do
+      before do
+        bundle "config set gem.test test-unit"
+        bundle "gem #{gem_name}"
+      end
+
+      it "creates a default rake task to run the test suite" do
+        rakefile = strip_whitespace <<-RAKEFILE
+          # frozen_string_literal: true
+
           require "bundler/gem_tasks"
           require "rake/testtask"
 
@@ -480,81 +824,498 @@ RSpec.describe "bundle gem" do
             t.test_files = FileList["test/**/*_test.rb"]
           end
 
-          task :default => :test
+          task default: :test
         RAKEFILE
 
         expect(bundled_app("#{gem_name}/Rakefile").read).to eq(rakefile)
       end
     end
 
-    context "--test with no arguments" do
+    context "gem.test set to rspec and --test with no arguments", :hint_text do
       before do
+        bundle "config set gem.test rspec"
         bundle "gem #{gem_name} --test"
       end
 
-      it "defaults to rspec" do
+      it "builds spec skeleton" do
+        expect(bundled_app("#{gem_name}/.rspec")).to exist
+        expect(bundled_app("#{gem_name}/spec/#{require_path}_spec.rb")).to exist
         expect(bundled_app("#{gem_name}/spec/spec_helper.rb")).to exist
-        expect(bundled_app("#{gem_name}/test/minitest_helper.rb")).to_not exist
       end
 
-      it "creates a .travis.yml file to test the library against the current Ruby version on Travis CI" do
-        expect(bundled_app("#{gem_name}/.travis.yml").read).to match(/- #{RUBY_VERSION}/)
+      it "hints that --test is already configured" do
+        expect(out).to match("rspec is already configured, ignoring --test flag.")
+      end
+    end
+
+    context "gem.test setting set to false and --test with no arguments", :hint_text do
+      before do
+        bundle "config set gem.test false"
+        bundle "gem #{gem_name} --test"
+      end
+
+      it "asks to generate test files" do
+        expect(out).to match("Do you want to generate tests with your gem?")
+      end
+
+      it "hints that the choice will only be applied to the current gem" do
+        expect(out).to match("Your choice will only be applied to this gem.")
+      end
+
+      it_behaves_like "test framework is absent"
+    end
+
+    context "gem.test setting not set and --test with no arguments", :hint_text do
+      before do
+        bundle "gem #{gem_name} --test"
+      end
+
+      it "asks to generate test files" do
+        expect(out).to match("Do you want to generate tests with your gem?")
+      end
+
+      it "hints that the choice will be applied to future bundle gem calls" do
+        hint = "Future `bundle gem` calls will use your choice. " \
+               "This setting can be changed anytime with `bundle config gem.test`."
+        expect(out).to match(hint)
+      end
+
+      it_behaves_like "test framework is absent"
+    end
+
+    context "--ci with no argument" do
+      it "does not generate any CI config" do
+        bundle "gem #{gem_name}"
+
+        expect(bundled_app("#{gem_name}/.github/workflows/main.yml")).to_not exist
+        expect(bundled_app("#{gem_name}/.travis.yml")).to_not exist
+        expect(bundled_app("#{gem_name}/.gitlab-ci.yml")).to_not exist
+        expect(bundled_app("#{gem_name}/.circleci/config.yml")).to_not exist
+      end
+    end
+
+    context "--ci set to github" do
+      it "generates a GitHub Actions config file" do
+        bundle "gem #{gem_name} --ci=github"
+
+        expect(bundled_app("#{gem_name}/.github/workflows/main.yml")).to exist
+      end
+    end
+
+    context "--ci set to gitlab" do
+      it "generates a GitLab CI config file" do
+        bundle "gem #{gem_name} --ci=gitlab"
+
+        expect(bundled_app("#{gem_name}/.gitlab-ci.yml")).to exist
+      end
+    end
+
+    context "--ci set to circle" do
+      it "generates a CircleCI config file" do
+        bundle "gem #{gem_name} --ci=circle"
+
+        expect(bundled_app("#{gem_name}/.circleci/config.yml")).to exist
+      end
+    end
+
+    context "--ci set to travis" do
+      it "generates a Travis CI config file" do
+        bundle "gem #{gem_name} --ci=travis"
+
+        expect(bundled_app("#{gem_name}/.travis.yml")).to exist
+      end
+    end
+
+    context "gem.ci setting set to none" do
+      it "doesn't generate any CI config" do
+        expect(bundled_app("#{gem_name}/.github/workflows/main.yml")).to_not exist
+        expect(bundled_app("#{gem_name}/.travis.yml")).to_not exist
+        expect(bundled_app("#{gem_name}/.gitlab-ci.yml")).to_not exist
+        expect(bundled_app("#{gem_name}/.circleci/config.yml")).to_not exist
+      end
+    end
+
+    context "gem.ci setting set to github" do
+      it "generates a GitHub Actions config file" do
+        bundle "config set gem.ci github"
+        bundle "gem #{gem_name}"
+
+        expect(bundled_app("#{gem_name}/.github/workflows/main.yml")).to exist
+      end
+    end
+
+    context "gem.ci setting set to travis" do
+      it "generates a Travis CI config file" do
+        bundle "config set gem.ci travis"
+        bundle "gem #{gem_name}"
+
+        expect(bundled_app("#{gem_name}/.travis.yml")).to exist
+      end
+    end
+
+    context "gem.ci setting set to gitlab" do
+      it "generates a GitLab CI config file" do
+        bundle "config set gem.ci gitlab"
+        bundle "gem #{gem_name}"
+
+        expect(bundled_app("#{gem_name}/.gitlab-ci.yml")).to exist
+      end
+    end
+
+    context "gem.ci setting set to circle" do
+      it "generates a CircleCI config file" do
+        bundle "config set gem.ci circle"
+        bundle "gem #{gem_name}"
+
+        expect(bundled_app("#{gem_name}/.circleci/config.yml")).to exist
+      end
+    end
+
+    context "gem.ci set to github and --ci with no arguments", :hint_text do
+      before do
+        bundle "config set gem.ci github"
+        bundle "gem #{gem_name} --ci"
+      end
+
+      it "generates a GitHub Actions config file" do
+        expect(bundled_app("#{gem_name}/.github/workflows/main.yml")).to exist
+      end
+
+      it "hints that --ci is already configured" do
+        expect(out).to match("github is already configured, ignoring --ci flag.")
+      end
+    end
+
+    context "gem.ci setting set to false and --ci with no arguments", :hint_text do
+      before do
+        bundle "config set gem.ci false"
+        bundle "gem #{gem_name} --ci"
+      end
+
+      it "asks to setup CI" do
+        expect(out).to match("Do you want to set up continuous integration for your gem?")
+      end
+
+      it "hints that the choice will only be applied to the current gem" do
+        expect(out).to match("Your choice will only be applied to this gem.")
+      end
+    end
+
+    context "gem.ci setting not set and --ci with no arguments", :hint_text do
+      before do
+        bundle "gem #{gem_name} --ci"
+      end
+
+      it "asks to setup CI" do
+        expect(out).to match("Do you want to set up continuous integration for your gem?")
+      end
+
+      it "hints that the choice will be applied to future bundle gem calls" do
+        hint = "Future `bundle gem` calls will use your choice. " \
+               "This setting can be changed anytime with `bundle config gem.ci`."
+        expect(out).to match(hint)
+      end
+    end
+
+    context "--linter with no argument" do
+      it "does not generate any linter config" do
+        bundle "gem #{gem_name}"
+
+        expect(bundled_app("#{gem_name}/.rubocop.yml")).to_not exist
+        expect(bundled_app("#{gem_name}/.standard.yml")).to_not exist
+      end
+    end
+
+    context "--linter set to rubocop" do
+      it "generates a RuboCop config" do
+        bundle "gem #{gem_name} --linter=rubocop"
+
+        expect(bundled_app("#{gem_name}/.rubocop.yml")).to exist
+        expect(bundled_app("#{gem_name}/.standard.yml")).to_not exist
+      end
+    end
+
+    context "--linter set to standard" do
+      it "generates a Standard config" do
+        bundle "gem #{gem_name} --linter=standard"
+
+        expect(bundled_app("#{gem_name}/.standard.yml")).to exist
+        expect(bundled_app("#{gem_name}/.rubocop.yml")).to_not exist
+      end
+    end
+
+    context "gem.linter setting set to none" do
+      it "doesn't generate any linter config" do
+        bundle "gem #{gem_name}"
+
+        expect(bundled_app("#{gem_name}/.rubocop.yml")).to_not exist
+        expect(bundled_app("#{gem_name}/.standard.yml")).to_not exist
+      end
+    end
+
+    context "gem.linter setting set to rubocop" do
+      it "generates a RuboCop config file" do
+        bundle "config set gem.linter rubocop"
+        bundle "gem #{gem_name}"
+
+        expect(bundled_app("#{gem_name}/.rubocop.yml")).to exist
+      end
+    end
+
+    context "gem.linter setting set to standard" do
+      it "generates a Standard config file" do
+        bundle "config set gem.linter standard"
+        bundle "gem #{gem_name}"
+
+        expect(bundled_app("#{gem_name}/.standard.yml")).to exist
+      end
+    end
+
+    context "gem.rubocop setting set to true", :bundler => "< 3" do
+      before do
+        bundle "config set gem.rubocop true"
+        bundle "gem #{gem_name}"
+      end
+
+      it "generates rubocop config" do
+        expect(bundled_app("#{gem_name}/.rubocop.yml")).to exist
+      end
+
+      it "unsets gem.rubocop" do
+        bundle "config gem.rubocop"
+        expect(out).to include("You have not configured a value for `gem.rubocop`")
+      end
+
+      it "sets gem.linter=rubocop instead" do
+        bundle "config gem.linter"
+        expect(out).to match(/Set for the current user .*: "rubocop"/)
+      end
+    end
+
+    context "gem.linter set to rubocop and --linter with no arguments", :hint_text do
+      before do
+        bundle "config set gem.linter rubocop"
+        bundle "gem #{gem_name} --linter"
+      end
+
+      it "generates a RuboCop config file" do
+        expect(bundled_app("#{gem_name}/.rubocop.yml")).to exist
+      end
+
+      it "hints that --linter is already configured" do
+        expect(out).to match("rubocop is already configured, ignoring --linter flag.")
+      end
+    end
+
+    context "gem.linter setting set to false and --linter with no arguments", :hint_text do
+      before do
+        bundle "config set gem.linter false"
+        bundle "gem #{gem_name} --linter"
+      end
+
+      it "asks to setup a linter" do
+        expect(out).to match("Do you want to add a code linter and formatter to your gem?")
+      end
+
+      it "hints that the choice will only be applied to the current gem" do
+        expect(out).to match("Your choice will only be applied to this gem.")
+      end
+    end
+
+    context "gem.linter setting not set and --linter with no arguments", :hint_text do
+      before do
+        bundle "gem #{gem_name} --linter"
+      end
+
+      it "asks to setup a linter" do
+        expect(out).to match("Do you want to add a code linter and formatter to your gem?")
+      end
+
+      it "hints that the choice will be applied to future bundle gem calls" do
+        hint = "Future `bundle gem` calls will use your choice. " \
+               "This setting can be changed anytime with `bundle config gem.linter`."
+        expect(out).to match(hint)
       end
     end
 
     context "--edit option" do
       it "opens the generated gemspec in the user's text editor" do
         output = bundle "gem #{gem_name} --edit=echo"
-        gemspec_path = File.join(Dir.pwd, gem_name, "#{gem_name}.gemspec")
+        gemspec_path = File.join(bundled_app, gem_name, "#{gem_name}.gemspec")
         expect(output).to include("echo \"#{gemspec_path}\"")
       end
     end
   end
 
-  context "testing --mit and --coc options against bundle config settings" do
+  context "testing --mit and --coc options against bundle config settings", :readline do
     let(:gem_name) { "test-gem" }
 
     let(:require_path) { "test/gem" }
 
     context "with mit option in bundle config settings set to true" do
       before do
-        global_config "BUNDLE_GEM__MIT" => "true", "BUNDLE_GEM__TEST" => "false", "BUNDLE_GEM__COC" => "false"
+        global_config "BUNDLE_GEM__MIT" => "true"
       end
       it_behaves_like "--mit flag"
       it_behaves_like "--no-mit flag"
     end
 
     context "with mit option in bundle config settings set to false" do
+      before do
+        global_config "BUNDLE_GEM__MIT" => "false"
+      end
       it_behaves_like "--mit flag"
       it_behaves_like "--no-mit flag"
     end
 
     context "with coc option in bundle config settings set to true" do
       before do
-        global_config "BUNDLE_GEM__MIT" => "false", "BUNDLE_GEM__TEST" => "false", "BUNDLE_GEM__COC" => "true"
+        global_config "BUNDLE_GEM__COC" => "true"
       end
       it_behaves_like "--coc flag"
       it_behaves_like "--no-coc flag"
     end
 
     context "with coc option in bundle config settings set to false" do
+      before do
+        global_config "BUNDLE_GEM__COC" => "false"
+      end
       it_behaves_like "--coc flag"
       it_behaves_like "--no-coc flag"
     end
+
+    context "with rubocop option in bundle config settings set to true" do
+      before do
+        global_config "BUNDLE_GEM__RUBOCOP" => "true"
+      end
+      it_behaves_like "--linter=rubocop flag"
+      it_behaves_like "--linter=standard flag"
+      it_behaves_like "--linter=none flag"
+      it_behaves_like "--rubocop flag"
+      it_behaves_like "--no-rubocop flag"
+    end
+
+    context "with rubocop option in bundle config settings set to false" do
+      before do
+        global_config "BUNDLE_GEM__RUBOCOP" => "false"
+      end
+      it_behaves_like "--linter=rubocop flag"
+      it_behaves_like "--linter=standard flag"
+      it_behaves_like "--linter=none flag"
+      it_behaves_like "--rubocop flag"
+      it_behaves_like "--no-rubocop flag"
+    end
+
+    context "with linter option in bundle config settings set to rubocop" do
+      before do
+        global_config "BUNDLE_GEM__LINTER" => "rubocop"
+      end
+      it_behaves_like "--linter=rubocop flag"
+      it_behaves_like "--linter=standard flag"
+      it_behaves_like "--linter=none flag"
+    end
+
+    context "with linter option in bundle config settings set to standard" do
+      before do
+        global_config "BUNDLE_GEM__LINTER" => "standard"
+      end
+      it_behaves_like "--linter=rubocop flag"
+      it_behaves_like "--linter=standard flag"
+      it_behaves_like "--linter=none flag"
+    end
+
+    context "with linter option in bundle config settings set to false" do
+      before do
+        global_config "BUNDLE_GEM__LINTER" => "false"
+      end
+      it_behaves_like "--linter=rubocop flag"
+      it_behaves_like "--linter=standard flag"
+      it_behaves_like "--linter=none flag"
+    end
+
+    context "with changelog option in bundle config settings set to true" do
+      before do
+        global_config "BUNDLE_GEM__CHANGELOG" => "true"
+      end
+      it_behaves_like "--changelog flag"
+      it_behaves_like "--no-changelog flag"
+    end
+
+    context "with changelog option in bundle config settings set to false" do
+      before do
+        global_config "BUNDLE_GEM__CHANGELOG" => "false"
+      end
+      it_behaves_like "--changelog flag"
+      it_behaves_like "--no-changelog flag"
+    end
+  end
+
+  context "testing --github-username option against git and bundle config settings", :readline do
+    context "without git config set" do
+      before do
+        sys_exec("git config --global --unset github.user")
+      end
+      context "with github-username option in bundle config settings set to some value" do
+        before do
+          global_config "BUNDLE_GEM__GITHUB_USERNAME" => "different_username"
+        end
+        it_behaves_like "--github-username option", "gh_user"
+      end
+
+      context "with github-username option in bundle config settings set to false" do
+        before do
+          global_config "BUNDLE_GEM__GITHUB_USERNAME" => "false"
+        end
+        it_behaves_like "--github-username option", "gh_user"
+      end
+    end
+
+    context "with git config set" do
+      context "with github-username option in bundle config settings set to some value" do
+        before do
+          global_config "BUNDLE_GEM__GITHUB_USERNAME" => "different_username"
+        end
+        it_behaves_like "--github-username option", "gh_user"
+      end
+
+      context "with github-username option in bundle config settings set to false" do
+        before do
+          global_config "BUNDLE_GEM__GITHUB_USERNAME" => "false"
+        end
+        it_behaves_like "--github-username option", "gh_user"
+      end
+    end
+  end
+
+  context "testing github_username bundle config against git config settings", :readline do
+    context "without git config set" do
+      before do
+        sys_exec("git config --global --unset github.user")
+      end
+
+      it_behaves_like "github_username configuration"
+    end
+
+    context "with git config set" do
+      it_behaves_like "github_username configuration"
+    end
   end
 
-  context "gem naming with underscore" do
+  context "gem naming with underscore", :readline do
     let(:gem_name) { "test_gem" }
 
     let(:require_path) { "test_gem" }
 
-    let(:flags) { nil }
+    let(:require_relative_path) { "test_gem" }
 
-    before do
-      bundle! ["gem", gem_name, flags].compact.join(" ")
-    end
+    let(:minitest_test_file_path) { "test/test_test_gem.rb" }
+
+    let(:minitest_test_class_name) { "class TestTestGem < Minitest::Test" }
+
+    let(:flags) { nil }
 
     it "does not nest constants" do
+      bundle ["gem", gem_name, flags].compact.join(" ")
       expect(bundled_app("#{gem_name}/lib/#{require_path}/version.rb").read).to match(/module TestGem/)
       expect(bundled_app("#{gem_name}/lib/#{require_path}.rb").read).to match(/module TestGem/)
     end
@@ -564,6 +1325,10 @@ RSpec.describe "bundle gem" do
     context "--ext parameter set" do
       let(:flags) { "--ext" }
 
+      before do
+        bundle ["gem", gem_name, flags].compact.join(" ")
+      end
+
       it "builds ext skeleton" do
         expect(bundled_app("#{gem_name}/ext/#{gem_name}/extconf.rb")).to exist
         expect(bundled_app("#{gem_name}/ext/#{gem_name}/#{gem_name}.h")).to exist
@@ -576,16 +1341,18 @@ RSpec.describe "bundle gem" do
 
       it "depends on compile task for build" do
         rakefile = strip_whitespace <<-RAKEFILE
+          # frozen_string_literal: true
+
           require "bundler/gem_tasks"
           require "rake/extensiontask"
 
-          task :build => :compile
+          task build: :compile
 
           Rake::ExtensionTask.new("#{gem_name}") do |ext|
             ext.lib_dir = "lib/#{gem_name}"
           end
 
-          task :default => [:clobber, :compile, :spec]
+          task default: %i[clobber compile]
         RAKEFILE
 
         expect(bundled_app("#{gem_name}/Rakefile").read).to eq(rakefile)
@@ -593,16 +1360,19 @@ RSpec.describe "bundle gem" do
     end
   end
 
-  context "gem naming with dashed" do
+  context "gem naming with dashed", :readline do
     let(:gem_name) { "test-gem" }
 
     let(:require_path) { "test/gem" }
 
-    before do
-      bundle! "gem #{gem_name}"
-    end
+    let(:require_relative_path) { "gem" }
+
+    let(:minitest_test_file_path) { "test/test/test_gem.rb" }
+
+    let(:minitest_test_class_name) { "class Test::TestGem < Minitest::Test" }
 
     it "nests constants so they work" do
+      bundle "gem #{gem_name}"
       expect(bundled_app("#{gem_name}/lib/#{require_path}/version.rb").read).to match(/module Test\n  module Gem/)
       expect(bundled_app("#{gem_name}/lib/#{require_path}.rb").read).to match(/module Test\n  module Gem/)
     end
@@ -611,29 +1381,29 @@ RSpec.describe "bundle gem" do
   end
 
   describe "uncommon gem names" do
-    it "can deal with two dashes" do
-      bundle! "gem a--a"
+    it "can deal with two dashes", :readline do
+      bundle "gem a--a"
 
       expect(bundled_app("a--a/a--a.gemspec")).to exist
     end
 
     it "fails gracefully with a ." do
-      bundle "gem foo.gemspec"
+      bundle "gem foo.gemspec", :raise_on_error => false
       expect(err).to end_with("Invalid gem name foo.gemspec -- `Foo.gemspec` is an invalid constant name")
     end
 
     it "fails gracefully with a ^" do
-      bundle "gem ^"
+      bundle "gem ^", :raise_on_error => false
       expect(err).to end_with("Invalid gem name ^ -- `^` is an invalid constant name")
     end
 
     it "fails gracefully with a space" do
-      bundle "gem 'foo bar'"
+      bundle "gem 'foo bar'", :raise_on_error => false
       expect(err).to end_with("Invalid gem name foo bar -- `Foo bar` is an invalid constant name")
     end
 
     it "fails gracefully when multiple names are passed" do
-      bundle "gem foo bar baz"
+      bundle "gem foo bar baz", :raise_on_error => false
       expect(err).to eq(<<-E.strip)
 ERROR: "bundle gem" was called with arguments ["foo", "bar", "baz"]
 Usage: "bundle gem NAME [OPTIONS]"
@@ -641,9 +1411,9 @@ Usage: "bundle gem NAME [OPTIONS]"
     end
   end
 
-  describe "#ensure_safe_gem_name" do
+  describe "#ensure_safe_gem_name", :readline do
     before do
-      bundle "gem #{subject}"
+      bundle "gem #{subject}", :raise_on_error => false
     end
 
     context "with an existing const name" do
@@ -667,7 +1437,7 @@ Usage: "bundle gem NAME [OPTIONS]"
     end
   end
 
-  context "on first run" do
+  context "on first run", :readline do
     it "asks about test framework" do
       global_config "BUNDLE_GEM__MIT" => "false", "BUNDLE_GEM__COC" => "false"
 
@@ -677,20 +1447,32 @@ Usage: "bundle gem NAME [OPTIONS]"
 
       expect(bundled_app("foobar/spec/spec_helper.rb")).to exist
       rakefile = strip_whitespace <<-RAKEFILE
+        # frozen_string_literal: true
+
         require "bundler/gem_tasks"
         require "rspec/core/rake_task"
 
         RSpec::Core::RakeTask.new(:spec)
 
-        task :default => :spec
+        task default: :spec
       RAKEFILE
 
       expect(bundled_app("foobar/Rakefile").read).to eq(rakefile)
       expect(bundled_app("foobar/Gemfile").read).to include('gem "rspec"')
     end
 
+    it "asks about CI service" do
+      global_config "BUNDLE_GEM__TEST" => "false", "BUNDLE_GEM__MIT" => "false", "BUNDLE_GEM__COC" => "false", "BUNDLE_GEM__LINTER" => "false"
+
+      bundle "gem foobar" do |input, _, _|
+        input.puts "github"
+      end
+
+      expect(bundled_app("foobar/.github/workflows/main.yml")).to exist
+    end
+
     it "asks about MIT license" do
-      global_config "BUNDLE_GEM__TEST" => "false", "BUNDLE_GEM__COC" => "false"
+      global_config "BUNDLE_GEM__TEST" => "false", "BUNDLE_GEM__COC" => "false", "BUNDLE_GEM__CI" => "false", "BUNDLE_GEM__LINTER" => "false"
 
       bundle "config list"
 
@@ -702,7 +1484,7 @@ Usage: "bundle gem NAME [OPTIONS]"
     end
 
     it "asks about CoC" do
-      global_config "BUNDLE_GEM__MIT" => "false", "BUNDLE_GEM__TEST" => "false"
+      global_config "BUNDLE_GEM__MIT" => "false", "BUNDLE_GEM__TEST" => "false", "BUNDLE_GEM__CI" => "false", "BUNDLE_GEM__LINTER" => "false"
 
       bundle "gem foobar" do |input, _, _|
         input.puts "yes"
@@ -710,21 +1492,32 @@ Usage: "bundle gem NAME [OPTIONS]"
 
       expect(bundled_app("foobar/CODE_OF_CONDUCT.md")).to exist
     end
+
+    it "asks about CHANGELOG" do
+      global_config "BUNDLE_GEM__MIT" => "false", "BUNDLE_GEM__TEST" => "false", "BUNDLE_GEM__CI" => "false", "BUNDLE_GEM__LINTER" => "false",
+                    "BUNDLE_GEM__COC" => "false"
+
+      bundle "gem foobar" do |input, _, _|
+        input.puts "yes"
+      end
+
+      expect(bundled_app("foobar/CHANGELOG.md")).to exist
+    end
   end
 
-  context "on conflicts with a previously created file" do
+  context "on conflicts with a previously created file", :readline do
     it "should fail gracefully" do
-      FileUtils.touch("conflict-foobar")
-      bundle "gem conflict-foobar"
-      expect(err).to include("Errno::ENOTDIR")
-      expect(exitstatus).to eql(32) if exitstatus
+      FileUtils.touch(bundled_app("conflict-foobar"))
+      bundle "gem conflict-foobar", :raise_on_error => false
+      expect(err).to eq("Couldn't create a new gem named `conflict-foobar` because there's an existing file named `conflict-foobar`.")
+      expect(exitstatus).to eql(32)
     end
   end
 
-  context "on conflicts with a previously created directory" do
+  context "on conflicts with a previously created directory", :readline do
     it "should succeed" do
-      FileUtils.mkdir_p("conflict-foobar/Gemfile")
-      bundle! "gem conflict-foobar"
+      FileUtils.mkdir_p(bundled_app("conflict-foobar/Gemfile"))
+      bundle "gem conflict-foobar"
       expect(out).to include("file_clash  conflict-foobar/Gemfile").
         and include "Initializing git repo in #{bundled_app("conflict-foobar")}"
     end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/open_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/open_spec.rb
@@ -30,13 +30,13 @@ RSpec.describe "bundle open" do
     end
 
     it "complains if gem not in bundle" do
-      bundle "open missing", :env => { "EDITOR" => "echo editor", "VISUAL" => "", "BUNDLER_EDITOR" => "" }
+      bundle "open missing", :env => { "EDITOR" => "echo editor", "VISUAL" => "", "BUNDLER_EDITOR" => "" }, :raise_on_error => false
       expect(err).to match(/could not find gem 'missing'/i)
     end
 
     it "does not blow up if the gem to open does not have a Gemfile" do
       git = build_git "foo"
-      ref = git.ref_for("master", 11)
+      ref = git.ref_for("main", 11)
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
@@ -48,7 +48,7 @@ RSpec.describe "bundle open" do
     end
 
     it "suggests alternatives for similar-sounding gems" do
-      bundle "open Rails", :env => { "EDITOR" => "echo editor", "VISUAL" => "", "BUNDLER_EDITOR" => "" }
+      bundle "open Rails", :env => { "EDITOR" => "echo editor", "VISUAL" => "", "BUNDLER_EDITOR" => "" }, :raise_on_error => false
       expect(err).to match(/did you mean rails\?/i)
     end
 
@@ -58,7 +58,7 @@ RSpec.describe "bundle open" do
       expect(out).to include("bundler_editor #{default_bundle_path("gems", "activerecord-2.3.2")}")
     end
 
-    it "select the gem from many match gems" do
+    it "select the gem from many match gems", :readline do
       env = { "EDITOR" => "echo editor", "VISUAL" => "echo visual", "BUNDLER_EDITOR" => "echo bundler_editor" }
       bundle "open active", :env => env do |input, _, _|
         input.puts "2"
@@ -67,9 +67,9 @@ RSpec.describe "bundle open" do
       expect(out).to match(/bundler_editor #{default_bundle_path('gems', 'activerecord-2.3.2')}\z/)
     end
 
-    it "allows selecting exit from many match gems" do
+    it "allows selecting exit from many match gems", :readline do
       env = { "EDITOR" => "echo editor", "VISUAL" => "echo visual", "BUNDLER_EDITOR" => "echo bundler_editor" }
-      bundle! "open active", :env => env do |input, _, _|
+      bundle "open active", :env => env do |input, _, _|
         input.puts "0"
       end
     end
@@ -87,14 +87,14 @@ RSpec.describe "bundle open" do
     end
 
     it "opens the editor with a clean env" do
-      bundle "open", :env => { "EDITOR" => "sh -c 'env'", "VISUAL" => "", "BUNDLER_EDITOR" => "" }
+      bundle "open", :env => { "EDITOR" => "sh -c 'env'", "VISUAL" => "", "BUNDLER_EDITOR" => "" }, :raise_on_error => false
       expect(out).not_to include("BUNDLE_GEMFILE=")
     end
   end
 
   context "when opening a default gem" do
     let(:default_gems) do
-      ruby!(<<-RUBY).split("\n")
+      ruby(<<-RUBY).split("\n")
         if Gem::Specification.is_a?(Enumerable)
           puts Gem::Specification.select(&:default_gem?).map(&:name)
         end
@@ -105,6 +105,7 @@ RSpec.describe "bundle open" do
       skip "No default gems available on this test run" if default_gems.empty?
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "json"
       G
     end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/outdated_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/outdated_spec.rb
@@ -1,24 +1,24 @@
 # frozen_string_literal: true
 
 RSpec.describe "bundle outdated" do
-  before :each do
-    build_repo2 do
-      build_git "foo", :path => lib_path("foo")
-      build_git "zebra", :path => lib_path("zebra")
-    end
+  describe "with no arguments" do
+    before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
 
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo2)}"
-      gem "zebra", :git => "#{lib_path("zebra")}"
-      gem "foo", :git => "#{lib_path("foo")}"
-      gem "activesupport", "2.3.5"
-      gem "weakling", "~> 0.0.1"
-      gem "duradura", '7.0'
-      gem "terranova", '8'
-    G
-  end
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+    end
 
-  describe "with no arguments" do
     it "returns a sorted list of outdated gems" do
       update_repo2 do
         build_gem "activesupport", "3.0"
@@ -27,15 +27,37 @@ RSpec.describe "bundle outdated" do
         update_git "zebra", :path => lib_path("zebra")
       end
 
-      bundle "outdated"
+      bundle "outdated", :raise_on_error => false
+
+      expected_output = <<~TABLE.gsub("x", "\\\h").tr(".", "\.").strip
+        Gem            Current      Latest       Requested  Groups
+        activesupport  2.3.5        3.0          = 2.3.5    default
+        foo            1.0 xxxxxxx  1.0 xxxxxxx  >= 0       default
+        weakling       0.0.3        0.2          ~> 0.0.1   default
+        zebra          1.0 xxxxxxx  1.0 xxxxxxx  >= 0       default
+      TABLE
+
+      expect(out).to match(Regexp.new(expected_output))
+    end
+
+    it "excludes header row from the sorting" do
+      update_repo2 do
+        build_gem "AAA", %w[1.0.0 2.0.0]
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "AAA", "1.0.0"
+      G
+
+      bundle "outdated", :raise_on_error => false
 
-      expect(out).to include("activesupport (newest 3.0, installed 2.3.5, requested = 2.3.5)")
-      expect(out).to include("weakling (newest 0.2, installed 0.0.3, requested ~> 0.0.1)")
-      expect(out).to include("foo (newest 1.0")
-
-      # Gem names are one per-line, between "*" and their parenthesized version.
-      gem_list = out.split("\n").map {|g| g[/\* (.*) \(/, 1] }.compact
-      expect(gem_list).to eq(gem_list.sort)
+      expected_output = <<~TABLE
+        Gem  Current  Latest  Requested  Groups
+        AAA  1.0.0    2.0.0   = 1.0.0    default
+      TABLE
+
+      expect(out).to include(expected_output.strip)
     end
 
     it "returns non zero exit status if outdated gems present" do
@@ -44,15 +66,13 @@ RSpec.describe "bundle outdated" do
         update_git "foo", :path => lib_path("foo")
       end
 
-      bundle "outdated"
+      bundle "outdated", :raise_on_error => false
 
-      expect(exitstatus).to_not be_zero if exitstatus
+      expect(exitstatus).to_not be_zero
     end
 
     it "returns success exit status if no outdated gems present" do
       bundle "outdated"
-
-      expect(exitstatus).to be_zero if exitstatus
     end
 
     it "adds gem group to dependency output when repo is updated" do
@@ -69,14 +89,141 @@ RSpec.describe "bundle outdated" do
       update_repo2 { build_gem "activesupport", "3.0" }
       update_repo2 { build_gem "terranova", "9" }
 
-      bundle "outdated --verbose"
-      expect(out).to include("activesupport (newest 3.0, installed 2.3.5, requested = 2.3.5) in groups \"development, test\"")
-      expect(out).to include("terranova (newest 9, installed 8, requested = 8) in group \"default\"")
+      bundle "outdated", :raise_on_error => false
+
+      expected_output = <<~TABLE.strip
+        Gem            Current  Latest  Requested  Groups
+        activesupport  2.3.5    3.0     = 2.3.5    development, test
+        terranova      8        9       = 8        default
+      TABLE
+
+      expect(out).to end_with(expected_output)
+    end
+  end
+
+  describe "with --verbose option" do
+    before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+    end
+
+    it "shows the location of the latest version's gemspec if installed" do
+      bundle "config set clean false"
+
+      update_repo2 { build_gem "activesupport", "3.0" }
+      update_repo2 { build_gem "terranova", "9" }
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+
+        gem "terranova", '9'
+        gem 'activesupport', '2.3.5'
+      G
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+
+        gem "terranova", '8'
+        gem 'activesupport', '2.3.5'
+      G
+
+      bundle "outdated --verbose", :raise_on_error => false
+
+      expected_output = <<~TABLE.strip
+        Gem            Current  Latest  Requested  Groups   Path
+        activesupport  2.3.5    3.0     = 2.3.5    default
+        terranova      8        9       = 8        default  #{default_bundle_path("specifications/terranova-9.gemspec")}
+      TABLE
+
+      expect(out).to end_with(expected_output)
+    end
+  end
+
+  describe "with multiple, duplicated sources, with lockfile in old format", :bundler => "< 3" do
+    before do
+      build_repo2 do
+        build_gem "dotenv", "2.7.6"
+
+        build_gem "oj", "3.11.3"
+        build_gem "oj", "3.11.5"
+
+        build_gem "vcr", "6.0.0"
+      end
+
+      build_repo gem_repo3 do
+        build_gem "pkg-gem-flowbyte-with-dep", "1.0.0" do |s|
+          s.add_dependency "oj"
+        end
+      end
+
+      gemfile <<~G
+        source "https://gem.repo2"
+
+        gem "dotenv"
+
+        source "https://gem.repo3" do
+          gem 'pkg-gem-flowbyte-with-dep'
+        end
+
+        gem "vcr",source: "https://gem.repo2"
+      G
+
+      lockfile <<~L
+        GEM
+          remote: https://gem.repo2/
+          remote: https://gem.repo3/
+          specs:
+            dotenv (2.7.6)
+            oj (3.11.3)
+            pkg-gem-flowbyte-with-dep (1.0.0)
+              oj
+            vcr (6.0.0)
+
+        PLATFORMS
+          #{specific_local_platform}
+
+        DEPENDENCIES
+          dotenv
+          pkg-gem-flowbyte-with-dep!
+          vcr!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+
+    it "works" do
+      bundle :install, :artifice => "compact_index"
+      bundle :outdated, :artifice => "compact_index", :raise_on_error => false
+
+      expected_output = <<~TABLE
+        Gem  Current  Latest  Requested  Groups
+        oj   3.11.3   3.11.5
+      TABLE
+
+      expect(out).to include(expected_output.strip)
     end
   end
 
   describe "with --group option" do
     before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
 
@@ -89,62 +236,100 @@ RSpec.describe "bundle outdated" do
       G
     end
 
-    def test_group_option(group = nil, gems_list_size = 1)
+    def test_group_option(group)
       update_repo2 do
         build_gem "activesupport", "3.0"
         build_gem "terranova", "9"
         build_gem "duradura", "8.0"
       end
 
-      bundle "outdated --group #{group}"
-
-      # Gem names are one per-line, between "*" and their parenthesized version.
-      gem_list = out.split("\n").map {|g| g[/\* (.*) \(/, 1] }.compact
-      expect(gem_list).to eq(gem_list.sort)
-      expect(gem_list.size).to eq gems_list_size
+      bundle "outdated --group #{group}", :raise_on_error => false
     end
 
-    it "not outdated gems" do
+    it "works when the bundle is up to date" do
       bundle "outdated --group"
-      expect(out).to include("Bundle up to date!")
+      expect(out).to end_with("Bundle up to date!")
     end
 
     it "returns a sorted list of outdated gems from one group => 'default'" do
       test_group_option("default")
 
-      expect(out).to include("===== Group \"default\" =====")
-      expect(out).to include("terranova (")
+      expected_output = <<~TABLE.strip
+        Gem        Current  Latest  Requested  Groups
+        terranova  8        9       = 8        default
+      TABLE
 
-      expect(out).not_to include("===== Groups \"development, test\" =====")
-      expect(out).not_to include("activesupport")
-      expect(out).not_to include("duradura")
+      expect(out).to end_with(expected_output)
     end
 
     it "returns a sorted list of outdated gems from one group => 'development'" do
-      test_group_option("development", 2)
+      test_group_option("development")
 
-      expect(out).not_to include("===== Group \"default\" =====")
-      expect(out).not_to include("terranova (")
+      expected_output = <<~TABLE.strip
+        Gem            Current  Latest  Requested  Groups
+        activesupport  2.3.5    3.0     = 2.3.5    development, test
+        duradura       7.0      8.0     = 7.0      development, test
+      TABLE
 
-      expect(out).to include("===== Groups \"development, test\" =====")
-      expect(out).to include("activesupport")
-      expect(out).to include("duradura")
+      expect(out).to end_with(expected_output)
     end
 
     it "returns a sorted list of outdated gems from one group => 'test'" do
-      test_group_option("test", 2)
+      test_group_option("test")
 
-      expect(out).not_to include("===== Group \"default\" =====")
-      expect(out).not_to include("terranova (")
+      expected_output = <<~TABLE.strip
+        Gem            Current  Latest  Requested  Groups
+        activesupport  2.3.5    3.0     = 2.3.5    development, test
+        duradura       7.0      8.0     = 7.0      development, test
+      TABLE
 
-      expect(out).to include("===== Groups \"development, test\" =====")
-      expect(out).to include("activesupport")
-      expect(out).to include("duradura")
+      expect(out).to end_with(expected_output)
+    end
+  end
+
+  describe "with --groups option and outdated transitive dependencies" do
+    before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+
+        build_gem "bar", %w[2.0.0]
+
+        build_gem "bar_dependant", "7.0" do |s|
+          s.add_dependency "bar", "~> 2.0"
+        end
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+
+        gem "bar_dependant", '7.0'
+      G
+
+      update_repo2 do
+        build_gem "bar", %w[3.0.0]
+      end
+    end
+
+    it "returns a sorted list of outdated gems" do
+      bundle "outdated --groups", :raise_on_error => false
+
+      expected_output = <<~TABLE.strip
+        Gem  Current  Latest  Requested  Groups
+        bar  2.0.0    3.0.0
+      TABLE
+
+      expect(out).to end_with(expected_output)
     end
   end
 
   describe "with --groups option" do
     before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
 
@@ -159,7 +344,7 @@ RSpec.describe "bundle outdated" do
 
     it "not outdated gems" do
       bundle "outdated --groups"
-      expect(out).to include("Bundle up to date!")
+      expect(out).to end_with("Bundle up to date!")
     end
 
     it "returns a sorted list of outdated gems by groups" do
@@ -169,35 +354,58 @@ RSpec.describe "bundle outdated" do
         build_gem "duradura", "8.0"
       end
 
-      bundle "outdated --groups"
-      expect(out).to include("===== Group \"default\" =====")
-      expect(out).to include("terranova (newest 9, installed 8, requested = 8)")
-      expect(out).to include("===== Groups \"development, test\" =====")
-      expect(out).to include("activesupport (newest 3.0, installed 2.3.5, requested = 2.3.5)")
-      expect(out).to include("duradura (newest 8.0, installed 7.0, requested = 7.0)")
+      bundle "outdated --groups", :raise_on_error => false
 
-      expect(out).not_to include("weakling (")
+      expected_output = <<~TABLE.strip
+        Gem            Current  Latest  Requested  Groups
+        activesupport  2.3.5    3.0     = 2.3.5    development, test
+        duradura       7.0      8.0     = 7.0      development, test
+        terranova      8        9       = 8        default
+      TABLE
 
-      # TODO: check gems order inside the group
+      expect(out).to end_with(expected_output)
     end
   end
 
   describe "with --local option" do
+    before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+
+        gem "weakling", "~> 0.0.1"
+        gem "terranova", '8'
+        group :development, :test do
+          gem 'activesupport', '2.3.5'
+          gem "duradura", '7.0'
+        end
+      G
+    end
+
     it "uses local cache to return a list of outdated gems" do
       update_repo2 do
         build_gem "activesupport", "2.3.4"
       end
 
-      bundle! "config set clean false"
+      bundle "config set clean false"
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
         gem "activesupport", "2.3.4"
       G
 
-      bundle "outdated --local"
+      bundle "outdated --local", :raise_on_error => false
 
-      expect(out).to include("activesupport (newest 2.3.5, installed 2.3.4, requested = 2.3.4)")
+      expected_output = <<~TABLE.strip
+        Gem            Current  Latest  Requested  Groups
+        activesupport  2.3.4    2.3.5   = 2.3.4    default
+      TABLE
+
+      expect(out).to end_with(expected_output)
     end
 
     it "doesn't hit repo2" do
@@ -211,10 +419,23 @@ RSpec.describe "bundle outdated" do
   shared_examples_for "a minimal output is desired" do
     context "and gems are outdated" do
       before do
-        update_repo2 do
+        build_repo2 do
+          build_git "foo", :path => lib_path("foo")
+          build_git "zebra", :path => lib_path("zebra")
+
           build_gem "activesupport", "3.0"
           build_gem "weakling", "0.2"
         end
+
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo2)}"
+          gem "zebra", :git => "#{lib_path("zebra")}"
+          gem "foo", :git => "#{lib_path("foo")}"
+          gem "activesupport", "2.3.5"
+          gem "weakling", "~> 0.0.1"
+          gem "duradura", '7.0'
+          gem "terranova", '8'
+        G
       end
 
       it "outputs a sorted list of outdated gems with a more minimal format" do
@@ -234,31 +455,68 @@ RSpec.describe "bundle outdated" do
   end
 
   describe "with --parseable option" do
-    subject { bundle "outdated --parseable" }
+    subject { bundle "outdated --parseable", :raise_on_error => false }
 
     it_behaves_like "a minimal output is desired"
   end
 
   describe "with aliased --porcelain option" do
-    subject { bundle "outdated --porcelain" }
+    subject { bundle "outdated --porcelain", :raise_on_error => false }
 
     it_behaves_like "a minimal output is desired"
   end
 
   describe "with specified gems" do
     it "returns list of outdated gems" do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+
       update_repo2 do
         build_gem "activesupport", "3.0"
         update_git "foo", :path => lib_path("foo")
       end
 
-      bundle "outdated foo"
-      expect(out).not_to include("activesupport (newest")
-      expect(out).to include("foo (newest 1.0")
+      bundle "outdated foo", :raise_on_error => false
+
+      expected_output = <<~TABLE.gsub("x", "\\\h").tr(".", "\.").strip
+        Gem  Current      Latest       Requested  Groups
+        foo  1.0 xxxxxxx  1.0 xxxxxxx  >= 0       default
+      TABLE
+
+      expect(out).to match(Regexp.new(expected_output))
     end
   end
 
   describe "pre-release gems" do
+    before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+    end
+
     context "without the --pre option" do
       it "ignores pre-release versions" do
         update_repo2 do
@@ -266,7 +524,8 @@ RSpec.describe "bundle outdated" do
         end
 
         bundle "outdated"
-        expect(out).not_to include("activesupport (3.0.0.beta > 2.3.5)")
+
+        expect(out).to end_with("Bundle up to date!")
       end
     end
 
@@ -276,8 +535,14 @@ RSpec.describe "bundle outdated" do
           build_gem "activesupport", "3.0.0.beta"
         end
 
-        bundle "outdated --pre"
-        expect(out).to include("activesupport (newest 3.0.0.beta, installed 2.3.5, requested = 2.3.5)")
+        bundle "outdated --pre", :raise_on_error => false
+
+        expected_output = <<~TABLE.strip
+          Gem            Current  Latest      Requested  Groups
+          activesupport  2.3.5    3.0.0.beta  = 2.3.5    default
+        TABLE
+
+        expect(out).to end_with(expected_output)
       end
     end
 
@@ -293,24 +558,77 @@ RSpec.describe "bundle outdated" do
           gem "activesupport", "3.0.0.beta.1"
         G
 
-        bundle "outdated"
-        expect(out).to include("(newest 3.0.0.beta.2, installed 3.0.0.beta.1, requested = 3.0.0.beta.1)")
+        bundle "outdated", :raise_on_error => false
+
+        expected_output = <<~TABLE.strip
+          Gem            Current       Latest        Requested       Groups
+          activesupport  3.0.0.beta.1  3.0.0.beta.2  = 3.0.0.beta.1  default
+        TABLE
+
+        expect(out).to end_with(expected_output)
       end
     end
   end
 
-  filter_strict_option = Bundler.feature_flag.bundler_2_mode? ? :"filter-strict" : :strict
-  describe "with --#{filter_strict_option} option" do
+  describe "with --filter-strict option" do
+    before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+    end
+
     it "only reports gems that have a newer version that matches the specified dependency version requirements" do
       update_repo2 do
         build_gem "activesupport", "3.0"
         build_gem "weakling", "0.0.5"
       end
 
-      bundle :outdated, filter_strict_option => true
+      bundle :outdated, :"filter-strict" => true, :raise_on_error => false
+
+      expected_output = <<~TABLE.strip
+        Gem       Current  Latest  Requested  Groups
+        weakling  0.0.3    0.0.5   ~> 0.0.1   default
+      TABLE
+
+      expect(out).to end_with(expected_output)
+    end
+
+    it "only reports gems that have a newer version that matches the specified dependency version requirements, using --strict alias" do
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+        build_gem "weakling", "0.0.5"
+      end
+
+      bundle :outdated, :strict => true, :raise_on_error => false
+
+      expected_output = <<~TABLE.strip
+        Gem       Current  Latest  Requested  Groups
+        weakling  0.0.3    0.0.5   ~> 0.0.1   default
+      TABLE
 
-      expect(out).to_not include("activesupport (newest")
-      expect(out).to include("(newest 0.0.5, installed 0.0.3, requested ~> 0.0.1)")
+      expect(out).to end_with(expected_output)
+    end
+
+    it "doesn't crash when some deps unused on the current platform" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport", platforms: [:ruby_22]
+      G
+
+      bundle :outdated, :"filter-strict" => true
+
+      expect(out).to end_with("Bundle up to date!")
     end
 
     it "only reports gem dependencies when they can actually be updated" do
@@ -319,9 +637,9 @@ RSpec.describe "bundle outdated" do
         gem "rack_middleware", "1.0"
       G
 
-      bundle :outdated, filter_strict_option => true
+      bundle :outdated, :"filter-strict" => true
 
-      expect(out).to_not include("rack (1.2")
+      expect(out).to end_with("Bundle up to date!")
     end
 
     describe "and filter options" do
@@ -337,10 +655,14 @@ RSpec.describe "bundle outdated" do
           build_gem "weakling", "0.0.5"
         end
 
-        bundle :outdated, filter_strict_option => true, "filter-patch" => true
+        bundle :outdated, :"filter-strict" => true, "filter-patch" => true, :raise_on_error => false
+
+        expected_output = <<~TABLE.strip
+          Gem       Current  Latest  Requested  Groups
+          weakling  0.0.3    0.0.5   >= 0.0.1   default
+        TABLE
 
-        expect(out).to_not include("activesupport (newest")
-        expect(out).to include("(newest 0.0.5, installed 0.0.3")
+        expect(out).to end_with(expected_output)
       end
 
       it "only reports gems that match requirement and minor filter level" do
@@ -355,10 +677,14 @@ RSpec.describe "bundle outdated" do
           build_gem "weakling", "0.1.5"
         end
 
-        bundle :outdated, filter_strict_option => true, "filter-minor" => true
+        bundle :outdated, :"filter-strict" => true, "filter-minor" => true, :raise_on_error => false
+
+        expected_output = <<~TABLE.strip
+          Gem       Current  Latest  Requested  Groups
+          weakling  0.0.3    0.1.5   >= 0.0.1   default
+        TABLE
 
-        expect(out).to_not include("activesupport (newest")
-        expect(out).to include("(newest 0.1.5, installed 0.0.3")
+        expect(out).to end_with(expected_output)
       end
 
       it "only reports gems that match requirement and major filter level" do
@@ -373,23 +699,44 @@ RSpec.describe "bundle outdated" do
           build_gem "weakling", "1.1.5"
         end
 
-        bundle :outdated, filter_strict_option => true, "filter-major" => true
+        bundle :outdated, :"filter-strict" => true, "filter-major" => true, :raise_on_error => false
 
-        expect(out).to_not include("activesupport (newest")
-        expect(out).to include("(newest 1.1.5, installed 0.0.3")
+        expected_output = <<~TABLE.strip
+          Gem       Current  Latest  Requested  Groups
+          weakling  0.0.3    1.1.5   >= 0.0.1   default
+        TABLE
+
+        expect(out).to end_with(expected_output)
       end
     end
   end
 
   describe "with invalid gem name" do
+    before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+    end
+
     it "returns could not find gem name" do
-      bundle "outdated invalid_gem_name"
+      bundle "outdated invalid_gem_name", :raise_on_error => false
       expect(err).to include("Could not find gem 'invalid_gem_name'.")
     end
 
     it "returns non-zero exit code" do
-      bundle "outdated invalid_gem_name"
-      expect(exitstatus).to_not be_zero if exitstatus
+      bundle "outdated invalid_gem_name", :raise_on_error => false
+      expect(exitstatus).to_not be_zero
     end
   end
 
@@ -401,24 +748,28 @@ RSpec.describe "bundle outdated" do
     G
 
     bundle "config set auto_install 1"
-    bundle :outdated
+    bundle :outdated, :raise_on_error => false
     expect(out).to include("Installing foo 1.0")
   end
 
   context "after bundle install --deployment", :bundler => "< 3" do
     before do
-      install_gemfile <<-G, forgotten_command_line_options(:deployment => true)
+      build_repo2
+
+      gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
 
         gem "rack"
         gem "foo"
       G
+      bundle :lock
+      bundle :install, :deployment => true
     end
 
     it "outputs a helpful message about being in deployment mode" do
       update_repo2 { build_gem "activesupport", "3.0" }
 
-      bundle "outdated"
+      bundle "outdated", :raise_on_error => false
       expect(last_command).to be_failure
       expect(err).to include("You are trying to check outdated gems in deployment mode.")
       expect(err).to include("Run `bundle outdated` elsewhere.")
@@ -427,21 +778,26 @@ RSpec.describe "bundle outdated" do
     end
   end
 
-  context "after bundle config set deployment true" do
+  context "after bundle config set --local deployment true" do
     before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
 
         gem "rack"
         gem "foo"
       G
-      bundle! "config set deployment true"
+      bundle "config set --local deployment true"
     end
 
     it "outputs a helpful message about being in deployment mode" do
       update_repo2 { build_gem "activesupport", "3.0" }
 
-      bundle "outdated"
+      bundle "outdated", :raise_on_error => false
       expect(last_command).to be_failure
       expect(err).to include("You are trying to check outdated gems in deployment mode.")
       expect(err).to include("Run `bundle outdated` elsewhere.")
@@ -452,6 +808,8 @@ RSpec.describe "bundle outdated" do
 
   context "update available for a gem on a different platform" do
     before do
+      build_repo2
+
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
         gem "laduradura", '= 5.15.2'
@@ -460,11 +818,15 @@ RSpec.describe "bundle outdated" do
 
     it "reports that no updates are available" do
       bundle "outdated"
-      expect(out).to include("Bundle up to date!")
+      expect(out).to end_with("Bundle up to date!")
     end
   end
 
   context "update available for a gem on the same platform while multiple platforms used for gem" do
+    before do
+      build_repo2
+    end
+
     it "reports that updates are available if the Ruby platform is used" do
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
@@ -472,36 +834,53 @@ RSpec.describe "bundle outdated" do
       G
 
       bundle "outdated"
-      expect(out).to include("Bundle up to date!")
+      expect(out).to end_with("Bundle up to date!")
     end
 
-    it "reports that updates are available if the JRuby platform is used" do
-      simulate_ruby_engine "jruby", "1.6.7" do
-        simulate_platform "jruby" do
-          install_gemfile <<-G
-            source "#{file_uri_for(gem_repo2)}"
-            gem "laduradura", '= 5.15.2', :platforms => [:ruby, :jruby]
-          G
-
-          bundle "outdated"
-          expect(out).to include("Outdated gems included in the bundle:")
-          expect(out).to include("laduradura (newest 5.15.3, installed 5.15.2, requested = 5.15.2)")
-        end
-      end
+    it "reports that updates are available if the JRuby platform is used", :jruby_only do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "laduradura", '= 5.15.2', :platforms => [:ruby, :jruby]
+      G
+
+      bundle "outdated", :raise_on_error => false
+
+      expected_output = <<~TABLE.strip
+        Gem         Current  Latest  Requested  Groups
+        laduradura  5.15.2   5.15.3  = 5.15.2   default
+      TABLE
+
+      expect(out).to end_with(expected_output)
     end
   end
 
   shared_examples_for "version update is detected" do
     it "reports that a gem has a newer version" do
       subject
-      expect(out).to include("Outdated gems included in the bundle:")
-      expect(out).to include("activesupport (newest")
-      expect(out).to_not include("ERROR REPORT TEMPLATE")
+
+      outdated_gems = out.split("\n").drop_while {|l| !l.start_with?("Gem") }[1..-1]
+
+      expect(outdated_gems.size).to be > 0
     end
   end
 
   shared_examples_for "major version updates are detected" do
     before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+
       update_repo2 do
         build_gem "activesupport", "3.3.5"
         build_gem "weakling", "0.8.0"
@@ -513,6 +892,21 @@ RSpec.describe "bundle outdated" do
 
   context "when on a new machine" do
     before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+
       simulate_new_machine
 
       update_git "foo", :path => lib_path("foo")
@@ -522,12 +916,27 @@ RSpec.describe "bundle outdated" do
       end
     end
 
-    subject { bundle "outdated" }
+    subject { bundle "outdated", :raise_on_error => false }
     it_behaves_like "version update is detected"
   end
 
   shared_examples_for "minor version updates are detected" do
     before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+
       update_repo2 do
         build_gem "activesupport", "2.7.5"
         build_gem "weakling", "2.0.1"
@@ -539,6 +948,21 @@ RSpec.describe "bundle outdated" do
 
   shared_examples_for "patch version updates are detected" do
     before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+
       update_repo2 do
         build_gem "activesupport", "2.3.7"
         build_gem "weakling", "0.3.1"
@@ -551,15 +975,27 @@ RSpec.describe "bundle outdated" do
   shared_examples_for "no version updates are detected" do
     it "does not detect any version updates" do
       subject
-      expect(out).to include("updates to display.")
-      expect(out).to_not include("ERROR REPORT TEMPLATE")
-      expect(out).to_not include("activesupport (newest")
-      expect(out).to_not include("weakling (newest")
+      expect(out).to end_with("updates to display.")
     end
   end
 
   shared_examples_for "major version is ignored" do
     before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+
       update_repo2 do
         build_gem "activesupport", "3.3.5"
         build_gem "weakling", "1.0.1"
@@ -571,6 +1007,21 @@ RSpec.describe "bundle outdated" do
 
   shared_examples_for "minor version is ignored" do
     before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+
       update_repo2 do
         build_gem "activesupport", "2.4.5"
         build_gem "weakling", "0.3.1"
@@ -582,6 +1033,21 @@ RSpec.describe "bundle outdated" do
 
   shared_examples_for "patch version is ignored" do
     before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+        build_git "zebra", :path => lib_path("zebra")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "zebra", :git => "#{lib_path("zebra")}"
+        gem "foo", :git => "#{lib_path("foo")}"
+        gem "activesupport", "2.3.5"
+        gem "weakling", "~> 0.0.1"
+        gem "duradura", '7.0'
+        gem "terranova", '8'
+      G
+
       update_repo2 do
         build_gem "activesupport", "2.3.6"
         build_gem "weakling", "0.0.4"
@@ -592,7 +1058,7 @@ RSpec.describe "bundle outdated" do
   end
 
   describe "with --filter-major option" do
-    subject { bundle "outdated --filter-major" }
+    subject { bundle "outdated --filter-major", :raise_on_error => false }
 
     it_behaves_like "major version updates are detected"
     it_behaves_like "minor version is ignored"
@@ -600,7 +1066,7 @@ RSpec.describe "bundle outdated" do
   end
 
   describe "with --filter-minor option" do
-    subject { bundle "outdated --filter-minor" }
+    subject { bundle "outdated --filter-minor", :raise_on_error => false }
 
     it_behaves_like "minor version updates are detected"
     it_behaves_like "major version is ignored"
@@ -608,7 +1074,7 @@ RSpec.describe "bundle outdated" do
   end
 
   describe "with --filter-patch option" do
-    subject { bundle "outdated --filter-patch" }
+    subject { bundle "outdated --filter-patch", :raise_on_error => false }
 
     it_behaves_like "patch version updates are detected"
     it_behaves_like "major version is ignored"
@@ -616,7 +1082,7 @@ RSpec.describe "bundle outdated" do
   end
 
   describe "with --filter-minor --filter-patch options" do
-    subject { bundle "outdated --filter-minor --filter-patch" }
+    subject { bundle "outdated --filter-minor --filter-patch", :raise_on_error => false }
 
     it_behaves_like "minor version updates are detected"
     it_behaves_like "patch version updates are detected"
@@ -624,7 +1090,7 @@ RSpec.describe "bundle outdated" do
   end
 
   describe "with --filter-major --filter-minor options" do
-    subject { bundle "outdated --filter-major --filter-minor" }
+    subject { bundle "outdated --filter-major --filter-minor", :raise_on_error => false }
 
     it_behaves_like "major version updates are detected"
     it_behaves_like "minor version updates are detected"
@@ -632,7 +1098,7 @@ RSpec.describe "bundle outdated" do
   end
 
   describe "with --filter-major --filter-patch options" do
-    subject { bundle "outdated --filter-major --filter-patch" }
+    subject { bundle "outdated --filter-major --filter-patch", :raise_on_error => false }
 
     it_behaves_like "major version updates are detected"
     it_behaves_like "patch version updates are detected"
@@ -640,7 +1106,7 @@ RSpec.describe "bundle outdated" do
   end
 
   describe "with --filter-major --filter-minor --filter-patch options" do
-    subject { bundle "outdated --filter-major --filter-minor --filter-patch" }
+    subject { bundle "outdated --filter-major --filter-minor --filter-patch", :raise_on_error => false }
 
     it_behaves_like "major version updates are detected"
     it_behaves_like "minor version updates are detected"
@@ -648,106 +1114,125 @@ RSpec.describe "bundle outdated" do
   end
 
   context "conservative updates" do
-    context "without update-strict" do
-      before do
-        build_repo4 do
-          build_gem "patch", %w[1.0.0 1.0.1]
-          build_gem "minor", %w[1.0.0 1.0.1 1.1.0]
-          build_gem "major", %w[1.0.0 1.0.1 1.1.0 2.0.0]
-        end
+    before do
+      build_repo4 do
+        build_gem "patch", %w[1.0.0 1.0.1]
+        build_gem "minor", %w[1.0.0 1.0.1 1.1.0]
+        build_gem "major", %w[1.0.0 1.0.1 1.1.0 2.0.0]
+      end
 
-        # establish a lockfile set to 1.0.0
-        install_gemfile <<-G
+      # establish a lockfile set to 1.0.0
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo4)}"
         gem 'patch', '1.0.0'
         gem 'minor', '1.0.0'
         gem 'major', '1.0.0'
-        G
+      G
 
-        # remove 1.4.3 requirement and bar altogether
-        # to setup update specs below
-        gemfile <<-G
+      # remove all version requirements
+      gemfile <<-G
         source "#{file_uri_for(gem_repo4)}"
         gem 'patch'
         gem 'minor'
         gem 'major'
-        G
-      end
+      G
+    end
 
-      it "shows nothing when patching and filtering to minor" do
-        bundle "outdated --patch --filter-minor"
+    it "shows nothing when patching and filtering to minor" do
+      bundle "outdated --patch --filter-minor"
 
-        expect(out).to include("No minor updates to display.")
-        expect(out).not_to include("patch (newest")
-        expect(out).not_to include("minor (newest")
-        expect(out).not_to include("major (newest")
-      end
+      expect(out).to end_with("No minor updates to display.")
+    end
 
-      it "shows all gems when patching and filtering to patch" do
-        bundle "outdated --patch --filter-patch"
+    it "shows all gems when patching and filtering to patch" do
+      bundle "outdated --patch --filter-patch", :raise_on_error => false
 
-        expect(out).to include("patch (newest 1.0.1")
-        expect(out).to include("minor (newest 1.0.1")
-        expect(out).to include("major (newest 1.0.1")
-      end
+      expected_output = <<~TABLE.strip
+        Gem    Current  Latest  Requested  Groups
+        major  1.0.0    1.0.1   >= 0       default
+        minor  1.0.0    1.0.1   >= 0       default
+        patch  1.0.0    1.0.1   >= 0       default
+      TABLE
 
-      it "shows minor and major when updating to minor and filtering to patch and minor" do
-        bundle "outdated --minor --filter-minor"
+      expect(out).to end_with(expected_output)
+    end
 
-        expect(out).not_to include("patch (newest")
-        expect(out).to include("minor (newest 1.1.0")
-        expect(out).to include("major (newest 1.1.0")
-      end
+    it "shows minor and major when updating to minor and filtering to patch and minor" do
+      bundle "outdated --minor --filter-minor", :raise_on_error => false
 
-      it "shows minor when updating to major and filtering to minor with parseable" do
-        bundle "outdated --major --filter-minor --parseable"
+      expected_output = <<~TABLE.strip
+        Gem    Current  Latest  Requested  Groups
+        major  1.0.0    1.1.0   >= 0       default
+        minor  1.0.0    1.1.0   >= 0       default
+      TABLE
 
-        expect(out).not_to include("patch (newest")
-        expect(out).to include("minor (newest")
-        expect(out).not_to include("major (newest")
-      end
+      expect(out).to end_with(expected_output)
     end
 
-    context "with update-strict" do
-      before do
-        build_repo4 do
-          build_gem "foo", %w[1.4.3 1.4.4] do |s|
-            s.add_dependency "bar", "~> 2.0"
-          end
-          build_gem "foo", %w[1.4.5 1.5.0] do |s|
-            s.add_dependency "bar", "~> 2.1"
-          end
-          build_gem "foo", %w[1.5.1] do |s|
-            s.add_dependency "bar", "~> 3.0"
-          end
-          build_gem "bar", %w[2.0.3 2.0.4 2.0.5 2.1.0 2.1.1 3.0.0]
-          build_gem "qux", %w[1.0.0 1.1.0 2.0.0]
-        end
+    it "shows minor when updating to major and filtering to minor with parseable" do
+      bundle "outdated --major --filter-minor --parseable", :raise_on_error => false
 
-        # establish a lockfile set to 1.4.3
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo4)}"
-          gem 'foo', '1.4.3'
-          gem 'bar', '2.0.3'
-          gem 'qux', '1.0.0'
-        G
+      expect(out).not_to include("patch (newest")
+      expect(out).to include("minor (newest")
+      expect(out).not_to include("major (newest")
+    end
+  end
 
-        # remove 1.4.3 requirement and bar altogether
-        # to setup update specs below
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo4)}"
-          gem 'foo'
-          gem 'qux'
-        G
+  context "tricky conservative updates" do
+    before do
+      build_repo4 do
+        build_gem "foo", %w[1.4.3 1.4.4] do |s|
+          s.add_dependency "bar", "~> 2.0"
+        end
+        build_gem "foo", %w[1.4.5 1.5.0] do |s|
+          s.add_dependency "bar", "~> 2.1"
+        end
+        build_gem "foo", %w[1.5.1] do |s|
+          s.add_dependency "bar", "~> 3.0"
+        end
+        build_gem "bar", %w[2.0.3 2.0.4 2.0.5 2.1.0 2.1.1 3.0.0]
+        build_gem "qux", %w[1.0.0 1.1.0 2.0.0]
       end
 
-      it "shows gems with update-strict updating to patch and filtering to patch" do
-        bundle "outdated --patch --update-strict --filter-patch"
+      # establish a lockfile set to 1.4.3
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem 'foo', '1.4.3'
+        gem 'bar', '2.0.3'
+        gem 'qux', '1.0.0'
+      G
 
-        expect(out).to include("foo (newest 1.4.4")
-        expect(out).to include("bar (newest 2.0.5")
-        expect(out).not_to include("qux (newest")
-      end
+      # remove 1.4.3 requirement and bar altogether
+      # to setup update specs below
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem 'foo'
+        gem 'qux'
+      G
+    end
+
+    it "shows gems updating to patch and filtering to patch" do
+      bundle "outdated --patch --filter-patch", :raise_on_error => false, :env => { "DEBUG_RESOLVER" => "1" }
+
+      expected_output = <<~TABLE.strip
+        Gem  Current  Latest  Requested  Groups
+        bar  2.0.3    2.0.5
+        foo  1.4.3    1.4.4   >= 0       default
+      TABLE
+
+      expect(out).to end_with(expected_output)
+    end
+
+    it "shows gems updating to patch and filtering to patch, in debug mode" do
+      bundle "outdated --patch --filter-patch", :raise_on_error => false, :env => { "DEBUG" => "1" }
+
+      expected_output = <<~TABLE.strip
+        Gem  Current  Latest  Requested  Groups   Path
+        bar  2.0.3    2.0.5
+        foo  1.4.3    1.4.4   >= 0       default
+      TABLE
+
+      expect(out).to end_with(expected_output)
     end
   end
 
@@ -771,10 +1256,113 @@ RSpec.describe "bundle outdated" do
         gem 'weakling'
       G
 
-      bundle "outdated --only-explicit"
+      bundle "outdated --only-explicit", :raise_on_error => false
+
+      expected_output = <<~TABLE.strip
+        Gem       Current  Latest  Requested  Groups
+        weakling  0.2      0.3     >= 0       default
+      TABLE
+
+      expect(out).to end_with(expected_output)
+    end
+  end
+
+  describe "with a multiplatform lockfile" do
+    before do
+      build_repo4 do
+        build_gem "nokogiri", "1.11.1"
+        build_gem "nokogiri", "1.11.1" do |s|
+          s.platform = Bundler.local_platform
+        end
+
+        build_gem "nokogiri", "1.11.2"
+        build_gem "nokogiri", "1.11.2" do |s|
+          s.platform = Bundler.local_platform
+        end
+      end
+
+      lockfile <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            nokogiri (1.11.1)
+            nokogiri (1.11.1-#{Bundler.local_platform})
+
+        PLATFORMS
+          ruby
+          #{Bundler.local_platform}
+
+        DEPENDENCIES
+          nokogiri
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "nokogiri"
+      G
+    end
+
+    it "reports a single entry per gem" do
+      bundle "outdated", :raise_on_error => false
+
+      expected_output = <<~TABLE.strip
+        Gem       Current  Latest  Requested  Groups
+        nokogiri  1.11.1   1.11.2  >= 0       default
+      TABLE
+
+      expect(out).to end_with(expected_output)
+    end
+  end
+
+  context "when a gem is no longer a dependency after a full update" do
+    before do
+      build_repo4 do
+        build_gem "mini_portile2", "2.5.2" do |s|
+          s.add_dependency "net-ftp", "~> 0.1"
+        end
+
+        build_gem "mini_portile2", "2.5.3"
+
+        build_gem "net-ftp", "0.1.2"
+      end
+
+      gemfile <<~G
+        source "#{file_uri_for(gem_repo4)}"
+
+        gem "mini_portile2"
+      G
+
+      lockfile <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            mini_portile2 (2.5.2)
+              net-ftp (~> 0.1)
+            net-ftp (0.1.2)
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          mini_portile2
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+
+    it "works" do
+      bundle "outdated", :raise_on_error => false
+
+      expected_output = <<~TABLE.strip
+        Gem            Current  Latest  Requested  Groups
+        mini_portile2  2.5.2    2.5.3   >= 0       default
+      TABLE
 
-      expect(out).to include("weakling (newest 0.3")
-      expect(out).not_to include("bar (newest 2.2")
+      expect(out).to end_with(expected_output)
     end
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/commands/platform_spec.rb
@@ -0,0 +1,1307 @@
+# frozen_string_literal: true
+
+RSpec.describe "bundle platform" do
+  context "without flags" do
+    it "returns all the output" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+
+        #{ruby_version_correct}
+
+        gem "foo"
+      G
+
+      bundle "platform"
+      expect(out).to eq(<<-G.chomp)
+Your platform is: #{Gem::Platform.local}
+
+Your app has gems that work on these platforms:
+* #{specific_local_platform}
+
+Your Gemfile specifies a Ruby version requirement:
+* ruby #{Gem.ruby_version}
+
+Your current platform satisfies the Ruby version requirement.
+G
+    end
+
+    it "returns all the output including the patchlevel" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+
+        #{ruby_version_correct_patchlevel}
+
+        gem "foo"
+      G
+
+      bundle "platform"
+      expect(out).to eq(<<-G.chomp)
+Your platform is: #{Gem::Platform.local}
+
+Your app has gems that work on these platforms:
+* #{specific_local_platform}
+
+Your Gemfile specifies a Ruby version requirement:
+* #{Bundler::RubyVersion.system.single_version_string}
+
+Your current platform satisfies the Ruby version requirement.
+G
+    end
+
+    it "doesn't print ruby version requirement if it isn't specified" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+
+        gem "foo"
+      G
+
+      bundle "platform"
+      expect(out).to eq(<<-G.chomp)
+Your platform is: #{Gem::Platform.local}
+
+Your app has gems that work on these platforms:
+* #{specific_local_platform}
+
+Your Gemfile does not specify a Ruby version requirement.
+G
+    end
+
+    it "doesn't match the ruby version requirement" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+
+        #{ruby_version_incorrect}
+
+        gem "foo"
+      G
+
+      bundle "platform"
+      expect(out).to eq(<<-G.chomp)
+Your platform is: #{Gem::Platform.local}
+
+Your app has gems that work on these platforms:
+* #{specific_local_platform}
+
+Your Gemfile specifies a Ruby version requirement:
+* ruby #{not_local_ruby_version}
+
+Your Ruby version is #{Gem.ruby_version}, but your Gemfile specified #{not_local_ruby_version}
+G
+    end
+  end
+
+  context "--ruby" do
+    it "returns ruby version when explicit" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby "1.9.3", :engine => 'ruby', :engine_version => '1.9.3'
+
+        gem "foo"
+      G
+
+      bundle "platform --ruby"
+
+      expect(out).to eq("ruby 1.9.3")
+    end
+
+    it "defaults to MRI" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby "1.9.3"
+
+        gem "foo"
+      G
+
+      bundle "platform --ruby"
+
+      expect(out).to eq("ruby 1.9.3")
+    end
+
+    it "handles jruby" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby "1.8.7", :engine => 'jruby', :engine_version => '1.6.5'
+
+        gem "foo"
+      G
+
+      bundle "platform --ruby"
+
+      expect(out).to eq("ruby 1.8.7 (jruby 1.6.5)")
+    end
+
+    it "handles rbx" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby "1.8.7", :engine => 'rbx', :engine_version => '1.2.4'
+
+        gem "foo"
+      G
+
+      bundle "platform --ruby"
+
+      expect(out).to eq("ruby 1.8.7 (rbx 1.2.4)")
+    end
+
+    it "handles truffleruby" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby "2.5.1", :engine => 'truffleruby', :engine_version => '1.0.0-rc6'
+
+        gem "foo"
+      G
+
+      bundle "platform --ruby"
+
+      expect(out).to eq("ruby 2.5.1 (truffleruby 1.0.0-rc6)")
+    end
+
+    it "raises an error if engine is used but engine version is not" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby "1.8.7", :engine => 'rbx'
+
+        gem "foo"
+      G
+
+      bundle "platform", :raise_on_error => false
+
+      expect(exitstatus).not_to eq(0)
+    end
+
+    it "raises an error if engine_version is used but engine is not" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby "1.8.7", :engine_version => '1.2.4'
+
+        gem "foo"
+      G
+
+      bundle "platform", :raise_on_error => false
+
+      expect(exitstatus).not_to eq(0)
+    end
+
+    it "raises an error if engine version doesn't match ruby version for MRI" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby "1.8.7", :engine => 'ruby', :engine_version => '1.2.4'
+
+        gem "foo"
+      G
+
+      bundle "platform", :raise_on_error => false
+
+      expect(exitstatus).not_to eq(0)
+    end
+
+    it "should print if no ruby version is specified" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+
+        gem "foo"
+      G
+
+      bundle "platform --ruby"
+
+      expect(out).to eq("No ruby version specified")
+    end
+
+    it "handles when there is a locked requirement" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby "< 1.8.7"
+      G
+
+      lockfile <<-L
+        GEM
+          remote: #{file_uri_for(gem_repo1)}/
+          specs:
+
+        PLATFORMS
+          ruby
+
+        DEPENDENCIES
+
+        RUBY VERSION
+           ruby 1.0.0p127
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      bundle "platform --ruby"
+      expect(out).to eq("ruby 1.0.0")
+    end
+
+    it "handles when there is a lockfile with no requirement" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+      G
+
+      lockfile <<-L
+        GEM
+          remote: #{file_uri_for(gem_repo1)}/
+          specs:
+
+        PLATFORMS
+          ruby
+
+        DEPENDENCIES
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      bundle "platform --ruby"
+      expect(out).to eq("No ruby version specified")
+    end
+
+    it "handles when there is a requirement in the gemfile" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby ">= 1.8.7"
+      G
+
+      bundle "platform --ruby"
+      expect(out).to eq("ruby 1.8.7")
+    end
+
+    it "handles when there are multiple requirements in the gemfile" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby ">= 1.8.7", "< 2.0.0"
+      G
+
+      bundle "platform --ruby"
+      expect(out).to eq("ruby 1.8.7")
+    end
+  end
+
+  let(:ruby_version_correct) { "ruby \"#{Gem.ruby_version}\", :engine => \"#{local_ruby_engine}\", :engine_version => \"#{local_engine_version}\"" }
+  let(:ruby_version_correct_engineless) { "ruby \"#{Gem.ruby_version}\"" }
+  let(:ruby_version_correct_patchlevel) { "#{ruby_version_correct}, :patchlevel => '#{RUBY_PATCHLEVEL}'" }
+  let(:ruby_version_incorrect) { "ruby \"#{not_local_ruby_version}\", :engine => \"#{local_ruby_engine}\", :engine_version => \"#{not_local_ruby_version}\"" }
+  let(:engine_incorrect) { "ruby \"#{Gem.ruby_version}\", :engine => \"#{not_local_tag}\", :engine_version => \"#{Gem.ruby_version}\"" }
+  let(:engine_version_incorrect) { "ruby \"#{Gem.ruby_version}\", :engine => \"#{local_ruby_engine}\", :engine_version => \"#{not_local_engine_version}\"" }
+  let(:patchlevel_incorrect) { "#{ruby_version_correct}, :patchlevel => '#{not_local_patchlevel}'" }
+  let(:patchlevel_fixnum) { "#{ruby_version_correct}, :patchlevel => #{RUBY_PATCHLEVEL}1" }
+
+  def should_be_ruby_version_incorrect
+    expect(exitstatus).to eq(18)
+    expect(err).to be_include("Your Ruby version is #{Gem.ruby_version}, but your Gemfile specified #{not_local_ruby_version}")
+  end
+
+  def should_be_engine_incorrect
+    expect(exitstatus).to eq(18)
+    expect(err).to be_include("Your Ruby engine is #{local_ruby_engine}, but your Gemfile specified #{not_local_tag}")
+  end
+
+  def should_be_engine_version_incorrect
+    expect(exitstatus).to eq(18)
+    expect(err).to be_include("Your #{local_ruby_engine} version is #{local_engine_version}, but your Gemfile specified #{local_ruby_engine} #{not_local_engine_version}")
+  end
+
+  def should_be_patchlevel_incorrect
+    expect(exitstatus).to eq(18)
+    expect(err).to be_include("Your Ruby patchlevel is #{RUBY_PATCHLEVEL}, but your Gemfile specified #{not_local_patchlevel}")
+  end
+
+  def should_be_patchlevel_fixnum
+    expect(exitstatus).to eq(18)
+    expect(err).to be_include("The Ruby patchlevel in your Gemfile must be a string")
+  end
+
+  context "bundle install" do
+    it "installs fine when the ruby version matches" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{ruby_version_correct}
+      G
+
+      expect(bundled_app_lock).to exist
+    end
+
+    it "installs fine with any engine", :jruby_only do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{ruby_version_correct_engineless}
+      G
+
+      expect(bundled_app_lock).to exist
+    end
+
+    it "installs fine when the patchlevel matches" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{ruby_version_correct_patchlevel}
+      G
+
+      expect(bundled_app_lock).to exist
+    end
+
+    it "doesn't install when the ruby version doesn't match" do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{ruby_version_incorrect}
+      G
+
+      expect(bundled_app_lock).not_to exist
+      should_be_ruby_version_incorrect
+    end
+
+    it "doesn't install when engine doesn't match" do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{engine_incorrect}
+      G
+
+      expect(bundled_app_lock).not_to exist
+      should_be_engine_incorrect
+    end
+
+    it "doesn't install when engine version doesn't match", :jruby_only do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{engine_version_incorrect}
+      G
+
+      expect(bundled_app_lock).not_to exist
+      should_be_engine_version_incorrect
+    end
+
+    it "doesn't install when patchlevel doesn't match" do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{patchlevel_incorrect}
+      G
+
+      expect(bundled_app_lock).not_to exist
+      should_be_patchlevel_incorrect
+    end
+  end
+
+  context "bundle check" do
+    it "checks fine when the ruby version matches" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{ruby_version_correct}
+      G
+
+      bundle :check
+      expect(out).to match(/\AResolving dependencies\.\.\.\.*\nThe Gemfile's dependencies are satisfied\z/)
+    end
+
+    it "checks fine with any engine", :jruby_only do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{ruby_version_correct_engineless}
+      G
+
+      bundle :check
+      expect(out).to match(/\AResolving dependencies\.\.\.\.*\nThe Gemfile's dependencies are satisfied\z/)
+    end
+
+    it "fails when ruby version doesn't match" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{ruby_version_incorrect}
+      G
+
+      bundle :check, :raise_on_error => false
+      should_be_ruby_version_incorrect
+    end
+
+    it "fails when engine doesn't match" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{engine_incorrect}
+      G
+
+      bundle :check, :raise_on_error => false
+      should_be_engine_incorrect
+    end
+
+    it "fails when engine version doesn't match", :jruby_only do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{engine_version_incorrect}
+      G
+
+      bundle :check, :raise_on_error => false
+      should_be_engine_version_incorrect
+    end
+
+    it "fails when patchlevel doesn't match" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{patchlevel_incorrect}
+      G
+
+      bundle :check, :raise_on_error => false
+      should_be_patchlevel_incorrect
+    end
+  end
+
+  context "bundle update" do
+    before do
+      build_repo2
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+      G
+    end
+
+    it "updates successfully when the ruby version matches" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+
+        #{ruby_version_correct}
+      G
+      update_repo2 do
+        build_gem "rack", "1.2" do |s|
+          s.executables = "rackup"
+        end
+
+        build_gem "activesupport", "3.0"
+      end
+
+      bundle "update", :all => true
+      expect(the_bundle).to include_gems "rack 1.2", "rack-obama 1.0", "activesupport 3.0"
+    end
+
+    it "updates fine with any engine", :jruby_only do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+
+        #{ruby_version_correct_engineless}
+      G
+      update_repo2 do
+        build_gem "rack", "1.2" do |s|
+          s.executables = "rackup"
+        end
+
+        build_gem "activesupport", "3.0"
+      end
+
+      bundle "update", :all => true
+      expect(the_bundle).to include_gems "rack 1.2", "rack-obama 1.0", "activesupport 3.0"
+    end
+
+    it "fails when ruby version doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+
+        #{ruby_version_incorrect}
+      G
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+      end
+
+      bundle :update, :all => true, :raise_on_error => false
+      should_be_ruby_version_incorrect
+    end
+
+    it "fails when ruby engine doesn't match", :jruby_only do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+
+        #{engine_incorrect}
+      G
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+      end
+
+      bundle :update, :all => true, :raise_on_error => false
+      should_be_engine_incorrect
+    end
+
+    it "fails when ruby engine version doesn't match", :jruby_only do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+
+        #{engine_version_incorrect}
+      G
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+      end
+
+      bundle :update, :all => true, :raise_on_error => false
+      should_be_engine_version_incorrect
+    end
+
+    it "fails when patchlevel doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{patchlevel_incorrect}
+      G
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+      end
+
+      bundle :update, :all => true, :raise_on_error => false
+      should_be_patchlevel_incorrect
+    end
+  end
+
+  context "bundle info" do
+    before do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rails"
+      G
+    end
+
+    it "prints path if ruby version is correct" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rails"
+
+        #{ruby_version_correct}
+      G
+
+      bundle "info rails --path"
+      expect(out).to eq(default_bundle_path("gems", "rails-2.3.2").to_s)
+    end
+
+    it "prints path if ruby version is correct for any engine", :jruby_only do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rails"
+
+        #{ruby_version_correct_engineless}
+      G
+
+      bundle "info rails --path"
+      expect(out).to eq(default_bundle_path("gems", "rails-2.3.2").to_s)
+    end
+
+    it "fails if ruby version doesn't match", :bundler => "< 3" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rails"
+
+        #{ruby_version_incorrect}
+      G
+
+      bundle "show rails", :raise_on_error => false
+      should_be_ruby_version_incorrect
+    end
+
+    it "fails if engine doesn't match", :bundler => "< 3" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rails"
+
+        #{engine_incorrect}
+      G
+
+      bundle "show rails", :raise_on_error => false
+      should_be_engine_incorrect
+    end
+
+    it "fails if engine version doesn't match", :bundler => "< 3", :jruby_only => true do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rails"
+
+        #{engine_version_incorrect}
+      G
+
+      bundle "show rails", :raise_on_error => false
+      should_be_engine_version_incorrect
+    end
+
+    it "fails when patchlevel doesn't match", :bundler => "< 3" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{patchlevel_incorrect}
+      G
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+      end
+
+      bundle "show rails", :raise_on_error => false
+      should_be_patchlevel_incorrect
+    end
+  end
+
+  context "bundle cache" do
+    before do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+      G
+    end
+
+    it "copies the .gem file to vendor/cache when ruby version matches" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+
+        #{ruby_version_correct}
+      G
+
+      bundle :cache
+      expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
+    end
+
+    it "copies the .gem file to vendor/cache when ruby version matches for any engine", :jruby_only do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+
+        #{ruby_version_correct_engineless}
+      G
+
+      bundle :cache
+      expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
+    end
+
+    it "fails if the ruby version doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+
+        #{ruby_version_incorrect}
+      G
+
+      bundle :cache, :raise_on_error => false
+      should_be_ruby_version_incorrect
+    end
+
+    it "fails if the engine doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+
+        #{engine_incorrect}
+      G
+
+      bundle :cache, :raise_on_error => false
+      should_be_engine_incorrect
+    end
+
+    it "fails if the engine version doesn't match", :jruby_only do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+
+        #{engine_version_incorrect}
+      G
+
+      bundle :cache, :raise_on_error => false
+      should_be_engine_version_incorrect
+    end
+
+    it "fails when patchlevel doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{patchlevel_incorrect}
+      G
+
+      bundle :cache, :raise_on_error => false
+      should_be_patchlevel_incorrect
+    end
+  end
+
+  context "bundle pack" do
+    before do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+      G
+    end
+
+    it "copies the .gem file to vendor/cache when ruby version matches" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+
+        #{ruby_version_correct}
+      G
+
+      bundle :cache
+      expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
+    end
+
+    it "copies the .gem file to vendor/cache when ruby version matches any engine", :jruby_only do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+
+        #{ruby_version_correct_engineless}
+      G
+
+      bundle :cache
+      expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
+    end
+
+    it "fails if the ruby version doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+
+        #{ruby_version_incorrect}
+      G
+
+      bundle :cache, :raise_on_error => false
+      should_be_ruby_version_incorrect
+    end
+
+    it "fails if the engine doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+
+        #{engine_incorrect}
+      G
+
+      bundle :cache, :raise_on_error => false
+      should_be_engine_incorrect
+    end
+
+    it "fails if the engine version doesn't match", :jruby_only do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem 'rack'
+
+        #{engine_version_incorrect}
+      G
+
+      bundle :cache, :raise_on_error => false
+      should_be_engine_version_incorrect
+    end
+
+    it "fails when patchlevel doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{patchlevel_incorrect}
+      G
+
+      bundle :cache, :raise_on_error => false
+      should_be_patchlevel_incorrect
+    end
+  end
+
+  context "bundle exec" do
+    before do
+      ENV["BUNDLER_FORCE_TTY"] = "true"
+      system_gems "rack-1.0.0", "rack-0.9.1", :path => default_bundle_path
+    end
+
+    it "activates the correct gem when ruby version matches" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack", "0.9.1"
+
+        #{ruby_version_correct}
+      G
+
+      bundle "exec rackup"
+      expect(out).to include("0.9.1")
+    end
+
+    it "activates the correct gem when ruby version matches any engine", :jruby_only do
+      system_gems "rack-1.0.0", "rack-0.9.1", :path => default_bundle_path
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack", "0.9.1"
+
+        #{ruby_version_correct_engineless}
+      G
+
+      bundle "exec rackup"
+      expect(out).to include("0.9.1")
+    end
+
+    it "fails when the ruby version doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack", "0.9.1"
+
+        #{ruby_version_incorrect}
+      G
+
+      bundle "exec rackup", :raise_on_error => false
+      should_be_ruby_version_incorrect
+    end
+
+    it "fails when the engine doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack", "0.9.1"
+
+        #{engine_incorrect}
+      G
+
+      bundle "exec rackup", :raise_on_error => false
+      should_be_engine_incorrect
+    end
+
+    # it "fails when the engine version doesn't match", :jruby_only do
+    #   gemfile <<-G
+    #     gem "rack", "0.9.1"
+    #
+    #     #{engine_version_incorrect}
+    #   G
+    #
+    #   bundle "exec rackup"
+    #   should_be_engine_version_incorrect
+    # end
+
+    it "fails when patchlevel doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+
+        #{patchlevel_incorrect}
+      G
+
+      bundle "exec rackup", :raise_on_error => false
+      should_be_patchlevel_incorrect
+    end
+  end
+
+  context "bundle console", :bundler => "< 3" do
+    before do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+        gem "activesupport", :group => :test
+        gem "rack_middleware", :group => :development
+      G
+    end
+
+    it "starts IRB with the default group loaded when ruby version matches", :readline do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+        gem "activesupport", :group => :test
+        gem "rack_middleware", :group => :development
+
+        #{ruby_version_correct}
+      G
+
+      bundle "console" do |input, _, _|
+        input.puts("puts RACK")
+        input.puts("exit")
+      end
+      expect(out).to include("0.9.1")
+    end
+
+    it "starts IRB with the default group loaded when ruby version matches", :readline, :jruby_only do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+        gem "activesupport", :group => :test
+        gem "rack_middleware", :group => :development
+
+        #{ruby_version_correct_engineless}
+      G
+
+      bundle "console" do |input, _, _|
+        input.puts("puts RACK")
+        input.puts("exit")
+      end
+      expect(out).to include("0.9.1")
+    end
+
+    it "fails when ruby version doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+        gem "activesupport", :group => :test
+        gem "rack_middleware", :group => :development
+
+        #{ruby_version_incorrect}
+      G
+
+      bundle "console", :raise_on_error => false
+      should_be_ruby_version_incorrect
+    end
+
+    it "fails when engine doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+        gem "activesupport", :group => :test
+        gem "rack_middleware", :group => :development
+
+        #{engine_incorrect}
+      G
+
+      bundle "console", :raise_on_error => false
+      should_be_engine_incorrect
+    end
+
+    it "fails when engine version doesn't match", :jruby_only do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+        gem "activesupport", :group => :test
+        gem "rack_middleware", :group => :development
+
+        #{engine_version_incorrect}
+      G
+
+      bundle "console", :raise_on_error => false
+      should_be_engine_version_incorrect
+    end
+
+    it "fails when patchlevel doesn't match" do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+        gem "activesupport", :group => :test
+        gem "rack_middleware", :group => :development
+
+        #{patchlevel_incorrect}
+      G
+
+      bundle "console", :raise_on_error => false
+      should_be_patchlevel_incorrect
+    end
+  end
+
+  context "Bundler.setup" do
+    before do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "yard"
+        gem "rack", :group => :test
+      G
+
+      ENV["BUNDLER_FORCE_TTY"] = "true"
+    end
+
+    it "makes a Gemfile.lock if setup succeeds" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "yard"
+        gem "rack"
+
+        #{ruby_version_correct}
+      G
+
+      FileUtils.rm(bundled_app_lock)
+
+      run "1"
+      expect(bundled_app_lock).to exist
+    end
+
+    it "makes a Gemfile.lock if setup succeeds for any engine", :jruby_only do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "yard"
+        gem "rack"
+
+        #{ruby_version_correct_engineless}
+      G
+
+      FileUtils.rm(bundled_app_lock)
+
+      run "1"
+      expect(bundled_app_lock).to exist
+    end
+
+    it "fails when ruby version doesn't match" do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
+        gem "yard"
+        gem "rack"
+
+        #{ruby_version_incorrect}
+      G
+
+      FileUtils.rm(bundled_app_lock)
+
+      ruby "require 'bundler/setup'", :env => { "BUNDLER_VERSION" => Bundler::VERSION }, :raise_on_error => false
+
+      expect(bundled_app_lock).not_to exist
+      should_be_ruby_version_incorrect
+    end
+
+    it "fails when engine doesn't match" do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
+        gem "yard"
+        gem "rack"
+
+        #{engine_incorrect}
+      G
+
+      FileUtils.rm(bundled_app_lock)
+
+      ruby "require 'bundler/setup'", :env => { "BUNDLER_VERSION" => Bundler::VERSION }, :raise_on_error => false
+
+      expect(bundled_app_lock).not_to exist
+      should_be_engine_incorrect
+    end
+
+    it "fails when engine version doesn't match", :jruby_only do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
+        gem "yard"
+        gem "rack"
+
+        #{engine_version_incorrect}
+      G
+
+      FileUtils.rm(bundled_app_lock)
+
+      ruby "require 'bundler/setup'", :env => { "BUNDLER_VERSION" => Bundler::VERSION }, :raise_on_error => false
+
+      expect(bundled_app_lock).not_to exist
+      should_be_engine_version_incorrect
+    end
+
+    it "fails when patchlevel doesn't match" do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
+        gem "yard"
+        gem "rack"
+
+        #{patchlevel_incorrect}
+      G
+
+      FileUtils.rm(bundled_app_lock)
+
+      ruby "require 'bundler/setup'", :env => { "BUNDLER_VERSION" => Bundler::VERSION }, :raise_on_error => false
+
+      expect(bundled_app_lock).not_to exist
+      should_be_patchlevel_incorrect
+    end
+  end
+
+  context "bundle outdated" do
+    before do
+      build_repo2 do
+        build_git "foo", :path => lib_path("foo")
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport", "2.3.5"
+        gem "foo", :git => "#{lib_path("foo")}"
+      G
+    end
+
+    it "returns list of outdated gems when the ruby version matches" do
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+        update_git "foo", :path => lib_path("foo")
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport", "2.3.5"
+        gem "foo", :git => "#{lib_path("foo")}"
+
+        #{ruby_version_correct}
+      G
+
+      bundle "outdated", :raise_on_error => false
+
+      expected_output = <<~TABLE.gsub("x", "\\\h").tr(".", "\.").strip
+        Gem            Current      Latest       Requested  Groups
+        activesupport  2.3.5        3.0          = 2.3.5    default
+        foo            1.0 xxxxxxx  1.0 xxxxxxx  >= 0       default
+      TABLE
+
+      expect(out).to match(Regexp.new(expected_output))
+    end
+
+    it "returns list of outdated gems when the ruby version matches for any engine", :jruby_only do
+      bundle :install
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+        update_git "foo", :path => lib_path("foo")
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport", "2.3.5"
+        gem "foo", :git => "#{lib_path("foo")}"
+
+        #{ruby_version_correct_engineless}
+      G
+
+      bundle "outdated", :raise_on_error => false
+
+      expected_output = <<~TABLE.gsub("x", "\\\h").tr(".", "\.").strip
+        Gem            Current      Latest       Requested  Groups
+        activesupport  2.3.5        3.0          = 2.3.5    default
+        foo            1.0 xxxxxxx  1.0 xxxxxxx  >= 0       default
+      TABLE
+
+      expect(out).to match(Regexp.new(expected_output))
+    end
+
+    it "fails when the ruby version doesn't match" do
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+        update_git "foo", :path => lib_path("foo")
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport", "2.3.5"
+        gem "foo", :git => "#{lib_path("foo")}"
+
+        #{ruby_version_incorrect}
+      G
+
+      bundle "outdated", :raise_on_error => false
+      should_be_ruby_version_incorrect
+    end
+
+    it "fails when the engine doesn't match" do
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+        update_git "foo", :path => lib_path("foo")
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport", "2.3.5"
+        gem "foo", :git => "#{lib_path("foo")}"
+
+        #{engine_incorrect}
+      G
+
+      bundle "outdated", :raise_on_error => false
+      should_be_engine_incorrect
+    end
+
+    it "fails when the engine version doesn't match", :jruby_only do
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+        update_git "foo", :path => lib_path("foo")
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport", "2.3.5"
+        gem "foo", :git => "#{lib_path("foo")}"
+
+        #{engine_version_incorrect}
+      G
+
+      bundle "outdated", :raise_on_error => false
+      should_be_engine_version_incorrect
+    end
+
+    it "fails when the patchlevel doesn't match", :jruby_only do
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+        update_git "foo", :path => lib_path("foo")
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport", "2.3.5"
+        gem "foo", :git => "#{lib_path("foo")}"
+
+        #{patchlevel_incorrect}
+      G
+
+      bundle "outdated", :raise_on_error => false
+      should_be_patchlevel_incorrect
+    end
+
+    it "fails when the patchlevel is a fixnum", :jruby_only do
+      update_repo2 do
+        build_gem "activesupport", "3.0"
+        update_git "foo", :path => lib_path("foo")
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport", "2.3.5"
+        gem "foo", :git => "#{lib_path("foo")}"
+
+        #{patchlevel_fixnum}
+      G
+
+      bundle "outdated", :raise_on_error => false
+      should_be_patchlevel_fixnum
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/post_bundle_message_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/post_bundle_message_spec.rb
@@ -22,78 +22,86 @@ RSpec.describe "post bundle message" do
   let(:bundle_show_message)        { Bundler::VERSION.split(".").first.to_i < 3 ? bundle_show_system_message : bundle_show_path_message }
 
   describe "for fresh bundle install" do
-    it "without any options" do
+    it "shows proper messages according to the configured groups" do
       bundle :install
       expect(out).to include(bundle_show_message)
       expect(out).not_to include("Gems in the group")
       expect(out).to include(bundle_complete_message)
       expect(out).to include(installed_gems_stats)
-    end
 
-    it "with --without one group" do
-      bundle! :install, forgotten_command_line_options(:without => "emo")
+      bundle "config set --local without emo"
+      bundle :install
       expect(out).to include(bundle_show_message)
-      expect(out).to include("Gems in the group emo were not installed")
+      expect(out).to include("Gems in the group 'emo' were not installed")
       expect(out).to include(bundle_complete_message)
       expect(out).to include(installed_gems_stats)
-    end
 
-    it "with --without two groups" do
-      bundle! :install, forgotten_command_line_options(:without => "emo test")
+      bundle "config set --local without emo test"
+      bundle :install
       expect(out).to include(bundle_show_message)
-      expect(out).to include("Gems in the groups emo and test were not installed")
+      expect(out).to include("Gems in the groups 'emo' and 'test' were not installed")
       expect(out).to include(bundle_complete_message)
       expect(out).to include("4 Gemfile dependencies, 3 gems now installed.")
-    end
 
-    it "with --without more groups" do
-      bundle! :install, forgotten_command_line_options(:without => "emo obama test")
+      bundle "config set --local without emo obama test"
+      bundle :install
       expect(out).to include(bundle_show_message)
-      expect(out).to include("Gems in the groups emo, obama and test were not installed")
+      expect(out).to include("Gems in the groups 'emo', 'obama' and 'test' were not installed")
       expect(out).to include(bundle_complete_message)
       expect(out).to include("4 Gemfile dependencies, 2 gems now installed.")
     end
 
-    describe "with --path and" do
+    describe "with `path` configured" do
       let(:bundle_path) { "./vendor" }
 
-      it "without any options" do
-        bundle! :install, forgotten_command_line_options(:path => "vendor")
+      it "shows proper messages according to the configured groups" do
+        bundle "config set --local path vendor"
+        bundle :install
         expect(out).to include(bundle_show_path_message)
         expect(out).to_not include("Gems in the group")
         expect(out).to include(bundle_complete_message)
-      end
 
-      it "with --without one group" do
-        bundle! :install, forgotten_command_line_options(:without => "emo", :path => "vendor")
+        bundle "config set --local path vendor"
+        bundle "config set --local without emo"
+        bundle :install
         expect(out).to include(bundle_show_path_message)
-        expect(out).to include("Gems in the group emo were not installed")
+        expect(out).to include("Gems in the group 'emo' were not installed")
         expect(out).to include(bundle_complete_message)
-      end
 
-      it "with --without two groups" do
-        bundle! :install, forgotten_command_line_options(:without => "emo test", :path => "vendor")
+        bundle "config set --local path vendor"
+        bundle "config set --local without emo test"
+        bundle :install
         expect(out).to include(bundle_show_path_message)
-        expect(out).to include("Gems in the groups emo and test were not installed")
+        expect(out).to include("Gems in the groups 'emo' and 'test' were not installed")
         expect(out).to include(bundle_complete_message)
-      end
 
-      it "with --without more groups" do
-        bundle! :install, forgotten_command_line_options(:without => "emo obama test", :path => "vendor")
+        bundle "config set --local path vendor"
+        bundle "config set --local without emo obama test"
+        bundle :install
         expect(out).to include(bundle_show_path_message)
-        expect(out).to include("Gems in the groups emo, obama and test were not installed")
+        expect(out).to include("Gems in the groups 'emo', 'obama' and 'test' were not installed")
         expect(out).to include(bundle_complete_message)
       end
+    end
+
+    describe "with an absolute `path` inside the cwd configured" do
+      let(:bundle_path) { bundled_app("cache") }
 
-      it "with an absolute --path inside the cwd" do
-        bundle! :install, forgotten_command_line_options(:path => bundled_app("cache"))
+      it "shows proper messages according to the configured groups" do
+        bundle "config set --local path #{bundle_path}"
+        bundle :install
         expect(out).to include("Bundled gems are installed into `./cache`")
         expect(out).to_not include("Gems in the group")
         expect(out).to include(bundle_complete_message)
       end
+    end
+
+    describe "with `path` configured to an absolute path outside the cwd" do
+      let(:bundle_path) { tmp("not_bundled_app") }
 
-      it "with an absolute --path outside the cwd" do
-        bundle! :install, forgotten_command_line_options(:path => tmp("not_bundled_app"))
+      it "shows proper messages according to the configured groups" do
+        bundle "config set --local path #{bundle_path}"
+        bundle :install
         expect(out).to include("Bundled gems are installed into `#{tmp("not_bundled_app")}`")
         expect(out).to_not include("Gems in the group")
         expect(out).to include(bundle_complete_message)
@@ -105,24 +113,14 @@ RSpec.describe "post bundle message" do
         bundle "config set force_ruby_platform true"
       end
 
-      it "should report a helpful error message", :bundler => "< 3" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rack"
-          gem "not-a-gem", :group => :development
-        G
-        expect(err).to include("Could not find gem 'not-a-gem' in any of the gem sources listed in your Gemfile.")
-      end
-
-      it "should report a helpful error message", :bundler => "3" do
-        install_gemfile <<-G
+      it "should report a helpful error message" do
+        install_gemfile <<-G, :raise_on_error => false
           source "#{file_uri_for(gem_repo1)}"
           gem "rack"
           gem "not-a-gem", :group => :development
         G
         expect(err).to include <<-EOS.strip
 Could not find gem 'not-a-gem' in rubygems repository #{file_uri_for(gem_repo1)}/ or installed locally.
-The source does not contain any versions of 'not-a-gem'
         EOS
       end
 
@@ -133,7 +131,7 @@ The source does not contain any versions
         G
         bundle :cache
         expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
-        install_gemfile <<-G
+        install_gemfile <<-G, :raise_on_error => false
           source "#{file_uri_for(gem_repo1)}"
           gem "rack"
           gem "not-a-gem", :group => :development
@@ -144,7 +142,7 @@ The source does not contain any versions
     end
   end
 
-  describe "for second bundle install run" do
+  describe "for second bundle install run", :bundler => "< 3" do
     it "without any options" do
       2.times { bundle :install }
       expect(out).to include(bundle_show_message)
@@ -154,56 +152,53 @@ The source does not contain any versions
     end
 
     it "with --without one group" do
-      bundle! :install, forgotten_command_line_options(:without => "emo")
-      bundle! :install
+      bundle "install --without emo"
+      bundle :install
       expect(out).to include(bundle_show_message)
-      expect(out).to include("Gems in the group emo were not installed")
+      expect(out).to include("Gems in the group 'emo' were not installed")
       expect(out).to include(bundle_complete_message)
       expect(out).to include(installed_gems_stats)
     end
 
     it "with --without two groups" do
-      bundle! :install, forgotten_command_line_options(:without => "emo test")
-      bundle! :install
+      bundle "install --without emo test"
+      bundle :install
       expect(out).to include(bundle_show_message)
-      expect(out).to include("Gems in the groups emo and test were not installed")
+      expect(out).to include("Gems in the groups 'emo' and 'test' were not installed")
       expect(out).to include(bundle_complete_message)
     end
 
     it "with --without more groups" do
-      bundle! :install, forgotten_command_line_options(:without => "emo obama test")
+      bundle "install --without emo obama test"
       bundle :install
       expect(out).to include(bundle_show_message)
-      expect(out).to include("Gems in the groups emo, obama and test were not installed")
+      expect(out).to include("Gems in the groups 'emo', 'obama' and 'test' were not installed")
       expect(out).to include(bundle_complete_message)
     end
   end
 
   describe "for bundle update" do
-    it "without any options" do
-      bundle! :update, :all => true
+    it "shows proper messages according to the configured groups" do
+      bundle :update, :all => true
       expect(out).not_to include("Gems in the groups")
       expect(out).to include(bundle_updated_message)
-    end
 
-    it "with --without one group" do
-      bundle! :install, forgotten_command_line_options(:without => "emo")
-      bundle! :update, :all => true
-      expect(out).to include("Gems in the group emo were not updated")
+      bundle "config set --local without emo"
+      bundle :install
+      bundle :update, :all => true
+      expect(out).to include("Gems in the group 'emo' were not updated")
       expect(out).to include(bundle_updated_message)
-    end
 
-    it "with --without two groups" do
-      bundle! :install, forgotten_command_line_options(:without => "emo test")
-      bundle! :update, :all => true
-      expect(out).to include("Gems in the groups emo and test were not updated")
+      bundle "config set --local without emo test"
+      bundle :install
+      bundle :update, :all => true
+      expect(out).to include("Gems in the groups 'emo' and 'test' were not updated")
       expect(out).to include(bundle_updated_message)
-    end
 
-    it "with --without more groups" do
-      bundle! :install, forgotten_command_line_options(:without => "emo obama test")
-      bundle! :update, :all => true
-      expect(out).to include("Gems in the groups emo, obama and test were not updated")
+      bundle "config set --local without emo obama test"
+      bundle :install
+      bundle :update, :all => true
+      expect(out).to include("Gems in the groups 'emo', 'obama' and 'test' were not updated")
       expect(out).to include(bundle_updated_message)
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/pristine_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/pristine_spec.rb
@@ -2,7 +2,7 @@
 
 require "bundler/vendored_fileutils"
 
-RSpec.describe "bundle pristine", :ruby_repo do
+RSpec.describe "bundle pristine" do
   before :each do
     build_lib "baz", :path => bundled_app do |s|
       s.version = "1.0.0"
@@ -18,21 +18,23 @@ RSpec.describe "bundle pristine", :ruby_
       build_lib "bar", :path => lib_path("bar")
     end
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo2)}"
       gem "weakling"
       gem "very_simple_binary"
-      gem "foo", :git => "#{lib_path("foo")}"
+      gem "foo", :git => "#{lib_path("foo")}", :branch => "main"
       gem "git_with_ext", :git => "#{lib_path("git_with_ext")}"
       gem "bar", :path => "#{lib_path("bar")}"
 
       gemspec
     G
+
+    allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
   end
 
   context "when sourced from RubyGems" do
     it "reverts using cached .gem file" do
-      spec = Bundler.definition.specs["weakling"].first
+      spec = find_spec("weakling")
       changes_txt = Pathname.new(spec.full_gem_path).join("lib/changes.txt")
 
       FileUtils.touch(changes_txt)
@@ -43,10 +45,9 @@ RSpec.describe "bundle pristine", :ruby_
     end
 
     it "does not delete the bundler gem" do
-      system_gems :bundler
-      bundle! "install"
-      bundle! "pristine", :system_bundler => true
-      bundle! "-v", :system_bundler => true
+      bundle "install"
+      bundle "pristine"
+      bundle "-v"
 
       expected = if Bundler::VERSION < "3.0"
         "Bundler version"
@@ -60,32 +61,45 @@ RSpec.describe "bundle pristine", :ruby_
 
   context "when sourced from git repo" do
     it "reverts by resetting to current revision`" do
-      spec = Bundler.definition.specs["foo"].first
+      spec = find_spec("foo")
       changed_file = Pathname.new(spec.full_gem_path).join("lib/foo.rb")
       diff = "#Pristine spec changes"
 
       File.open(changed_file, "a") {|f| f.puts diff }
       expect(File.read(changed_file)).to include(diff)
 
-      bundle! "pristine"
+      bundle "pristine"
       expect(File.read(changed_file)).to_not include(diff)
     end
 
     it "removes added files" do
-      spec = Bundler.definition.specs["foo"].first
+      spec = find_spec("foo")
       changes_txt = Pathname.new(spec.full_gem_path).join("lib/changes.txt")
 
       FileUtils.touch(changes_txt)
       expect(changes_txt).to be_file
 
-      bundle! "pristine"
+      bundle "pristine"
       expect(changes_txt).not_to be_file
     end
+
+    it "displays warning and ignores changes when a local config exists" do
+      spec = find_spec("foo")
+      bundle "config set local.#{spec.name} #{lib_path(spec.name)}"
+
+      changes_txt = Pathname.new(spec.full_gem_path).join("lib/changes.txt")
+      FileUtils.touch(changes_txt)
+      expect(changes_txt).to be_file
+
+      bundle "pristine"
+      expect(changes_txt).to be_file
+      expect(err).to include("Cannot pristine #{spec.name} (#{spec.version}#{spec.git_version}). Gem is locally overridden.")
+    end
   end
 
   context "when sourced from gemspec" do
     it "displays warning and ignores changes when sourced from gemspec" do
-      spec = Bundler.definition.specs["baz"].first
+      spec = find_spec("baz")
       changed_file = Pathname.new(spec.full_gem_path).join("lib/baz.rb")
       diff = "#Pristine spec changes"
 
@@ -98,7 +112,7 @@ RSpec.describe "bundle pristine", :ruby_
     end
 
     it "reinstall gemspec dependency" do
-      spec = Bundler.definition.specs["baz-dev"].first
+      spec = find_spec("baz-dev")
       changed_file = Pathname.new(spec.full_gem_path).join("lib/baz/dev.rb")
       diff = "#Pristine spec changes"
 
@@ -112,7 +126,7 @@ RSpec.describe "bundle pristine", :ruby_
 
   context "when sourced from path" do
     it "displays warning and ignores changes when sourced from local path" do
-      spec = Bundler.definition.specs["bar"].first
+      spec = find_spec("bar")
       changes_txt = Pathname.new(spec.full_gem_path).join("lib/changes.txt")
       FileUtils.touch(changes_txt)
       expect(changes_txt).to be_file
@@ -124,22 +138,22 @@ RSpec.describe "bundle pristine", :ruby_
 
   context "when passing a list of gems to pristine" do
     it "resets them" do
-      foo = Bundler.definition.specs["foo"].first
+      foo = find_spec("foo")
       foo_changes_txt = Pathname.new(foo.full_gem_path).join("lib/changes.txt")
       FileUtils.touch(foo_changes_txt)
       expect(foo_changes_txt).to be_file
 
-      bar = Bundler.definition.specs["bar"].first
+      bar = find_spec("bar")
       bar_changes_txt = Pathname.new(bar.full_gem_path).join("lib/changes.txt")
       FileUtils.touch(bar_changes_txt)
       expect(bar_changes_txt).to be_file
 
-      weakling = Bundler.definition.specs["weakling"].first
+      weakling = find_spec("weakling")
       weakling_changes_txt = Pathname.new(weakling.full_gem_path).join("lib/changes.txt")
       FileUtils.touch(weakling_changes_txt)
       expect(weakling_changes_txt).to be_file
 
-      bundle! "pristine foo bar weakling"
+      bundle "pristine foo bar weakling"
 
       expect(err).to include("Cannot pristine bar (1.0). Gem is sourced from local path.")
       expect(out).to include("Installing weakling 1.0")
@@ -150,13 +164,13 @@ RSpec.describe "bundle pristine", :ruby_
     end
 
     it "raises when one of them is not in the lockfile" do
-      bundle "pristine abcabcabc"
+      bundle "pristine abcabcabc", :raise_on_error => false
       expect(err).to include("Could not find gem 'abcabcabc'.")
     end
   end
 
   context "when a build config exists for one of the gems" do
-    let(:very_simple_binary) { Bundler.definition.specs["very_simple_binary"].first }
+    let(:very_simple_binary) { find_spec("very_simple_binary") }
     let(:c_ext_dir)          { Pathname.new(very_simple_binary.full_gem_path).join("ext") }
     let(:build_opt)          { "--with-ext-lib=#{c_ext_dir}" }
     before { bundle "config set build.very_simple_binary -- #{build_opt}" }
@@ -164,7 +178,7 @@ RSpec.describe "bundle pristine", :ruby_
     # This just verifies that the generated Makefile from the c_ext gem makes
     # use of the build_args from the bundle config
     it "applies the config when installing the gem" do
-      bundle! "pristine"
+      bundle "pristine"
 
       makefile_contents = File.read(c_ext_dir.join("Makefile").to_s)
       expect(makefile_contents).to match(/libpath =.*#{c_ext_dir}/)
@@ -173,7 +187,7 @@ RSpec.describe "bundle pristine", :ruby_
   end
 
   context "when a build config exists for a git sourced gem" do
-    let(:git_with_ext) { Bundler.definition.specs["git_with_ext"].first }
+    let(:git_with_ext) { find_spec("git_with_ext") }
     let(:c_ext_dir)          { Pathname.new(git_with_ext.full_gem_path).join("ext") }
     let(:build_opt)          { "--with-ext-lib=#{c_ext_dir}" }
     before { bundle "config set build.git_with_ext -- #{build_opt}" }
@@ -181,11 +195,27 @@ RSpec.describe "bundle pristine", :ruby_
     # This just verifies that the generated Makefile from the c_ext gem makes
     # use of the build_args from the bundle config
     it "applies the config when installing the gem" do
-      bundle! "pristine"
+      bundle "pristine"
 
       makefile_contents = File.read(c_ext_dir.join("Makefile").to_s)
       expect(makefile_contents).to match(/libpath =.*#{c_ext_dir}/)
       expect(makefile_contents).to match(/LIBPATH =.*-L#{c_ext_dir}/)
     end
   end
+
+  context "when BUNDLE_GEMFILE doesn't exist" do
+    before do
+      bundle "pristine", :env => { "BUNDLE_GEMFILE" => "does/not/exist" }, :raise_on_error => false
+    end
+
+    it "shows a meaningful error" do
+      expect(err).to eq("#{bundled_app("does/not/exist")} not found")
+    end
+  end
+
+  def find_spec(name)
+    without_env_side_effects do
+      Bundler.definition.specs[name].first
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/remove_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/remove_spec.rb
@@ -7,13 +7,43 @@ RSpec.describe "bundle remove" do
         source "#{file_uri_for(gem_repo1)}"
       G
 
-      bundle "remove"
+      bundle "remove", :raise_on_error => false
 
       expect(err).to include("Please specify gems to remove.")
     end
   end
 
-  context "when --install flag is specified" do
+  context "after 'bundle install' is run" do
+    describe "running 'bundle remove GEM_NAME'" do
+      it "removes it from the lockfile" do
+        rack_dep = <<~L
+
+          DEPENDENCIES
+            rack
+
+        L
+
+        gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+
+          gem "rack"
+        G
+
+        bundle "install"
+
+        expect(lockfile).to include(rack_dep)
+
+        bundle "remove rack"
+
+        expect(gemfile).to eq <<~G
+          source "#{file_uri_for(gem_repo1)}"
+        G
+        expect(lockfile).to_not include(rack_dep)
+      end
+    end
+  end
+
+  context "when --install flag is specified", :bundler => "< 3" do
     it "removes gems from .bundle" do
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
@@ -21,7 +51,7 @@ RSpec.describe "bundle remove" do
         gem "rack"
       G
 
-      bundle! "remove rack --install"
+      bundle "remove rack --install"
 
       expect(out).to include("rack was removed.")
       expect(the_bundle).to_not include_gems "rack"
@@ -37,13 +67,40 @@ RSpec.describe "bundle remove" do
           gem "rack"
         G
 
-        bundle! "remove rack"
+        bundle "remove rack"
 
         expect(out).to include("rack was removed.")
-        gemfile_should_be <<-G
+        expect(the_bundle).to_not include_gems "rack"
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
         G
       end
+
+      context "when gem is specified in multiple lines" do
+        it "shows success for removed gem" do
+          build_git "rack"
+
+          gemfile <<-G
+            source '#{file_uri_for(gem_repo1)}'
+
+            gem 'git'
+            gem 'rack',
+                git: "#{lib_path("rack-1.0")}",
+                branch: 'main'
+            gem 'nokogiri'
+          G
+
+          bundle "remove rack"
+
+          expect(out).to include("rack was removed.")
+          expect(gemfile).to eq <<~G
+            source '#{file_uri_for(gem_repo1)}'
+
+            gem 'git'
+            gem 'nokogiri'
+          G
+        end
+      end
     end
 
     context "when gem is not present in gemfile" do
@@ -52,14 +109,14 @@ RSpec.describe "bundle remove" do
           source "#{file_uri_for(gem_repo1)}"
         G
 
-        bundle "remove rack"
+        bundle "remove rack", :raise_on_error => false
 
-        expect(err).to include("`rack` is not specified in #{bundled_app("Gemfile")} so it could not be removed.")
+        expect(err).to include("`rack` is not specified in #{bundled_app_gemfile} so it could not be removed.")
       end
     end
   end
 
-  describe "remove mutiple gems from gemfile" do
+  describe "remove multiple gems from gemfile" do
     context "when all gems are present in gemfile" do
       it "shows success fir all removed gems" do
         gemfile <<-G
@@ -69,11 +126,11 @@ RSpec.describe "bundle remove" do
           gem "rails"
         G
 
-        bundle! "remove rack rails"
+        bundle "remove rack rails"
 
         expect(out).to include("rack was removed.")
         expect(out).to include("rails was removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
         source "#{file_uri_for(gem_repo1)}"
         G
       end
@@ -89,10 +146,10 @@ RSpec.describe "bundle remove" do
           gem "rspec"
         G
 
-        bundle "remove rails rack minitest"
+        bundle "remove rails rack minitest", :raise_on_error => false
 
-        expect(err).to include("`rack` is not specified in #{bundled_app("Gemfile")} so it could not be removed.")
-        gemfile_should_be <<-G
+        expect(err).to include("`rack` is not specified in #{bundled_app_gemfile} so it could not be removed.")
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
 
           gem "rails"
@@ -111,10 +168,10 @@ RSpec.describe "bundle remove" do
         gem "rack", :group => [:dev]
       G
 
-      bundle! "remove rack"
+      bundle "remove rack"
 
       expect(out).to include("rack was removed.")
-      gemfile_should_be <<-G
+      expect(gemfile).to eq <<~G
         source "#{file_uri_for(gem_repo1)}"
       G
     end
@@ -131,10 +188,10 @@ RSpec.describe "bundle remove" do
           end
         G
 
-        bundle! "remove rspec"
+        bundle "remove rspec"
 
         expect(out).to include("rspec was removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
         G
       end
@@ -151,10 +208,10 @@ RSpec.describe "bundle remove" do
           end
         G
 
-        bundle! "remove rack"
+        bundle "remove rack"
 
         expect(out).to include("rack was removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
 
           group :test do
@@ -177,16 +234,16 @@ RSpec.describe "bundle remove" do
           end
         G
 
-        bundle! "remove rspec"
+        bundle "remove rspec"
 
         expect(out).to include("rspec was removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
         G
       end
     end
 
-    context "when the gem belongs to mutiple groups" do
+    context "when the gem belongs to multiple groups" do
       it "removes the groups" do
         gemfile <<-G
           source "#{file_uri_for(gem_repo1)}"
@@ -196,16 +253,16 @@ RSpec.describe "bundle remove" do
           end
         G
 
-        bundle! "remove rspec"
+        bundle "remove rspec"
 
         expect(out).to include("rspec was removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
         G
       end
     end
 
-    context "when the gem is present in mutiple groups" do
+    context "when the gem is present in multiple groups" do
       it "removes all empty blocks" do
         gemfile <<-G
           source "#{file_uri_for(gem_repo1)}"
@@ -219,10 +276,10 @@ RSpec.describe "bundle remove" do
           end
         G
 
-        bundle! "remove rspec"
+        bundle "remove rspec"
 
         expect(out).to include("rspec was removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
         G
       end
@@ -242,10 +299,10 @@ RSpec.describe "bundle remove" do
           end
         G
 
-        bundle! "remove rspec"
+        bundle "remove rspec"
 
         expect(out).to include("rspec was removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
         G
       end
@@ -265,10 +322,10 @@ RSpec.describe "bundle remove" do
           end
         G
 
-        bundle! "remove rspec"
+        bundle "remove rspec"
 
         expect(out).to include("rspec was removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
 
           group :test do
@@ -292,10 +349,10 @@ RSpec.describe "bundle remove" do
           end
         G
 
-        bundle! "remove rspec"
+        bundle "remove rspec"
 
         expect(out).to include("rspec was removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
 
           group :test do
@@ -309,17 +366,17 @@ RSpec.describe "bundle remove" do
   end
 
   describe "arbitrary gemfile" do
-    context "when mutiple gems are present in same line" do
+    context "when multiple gems are present in same line" do
       it "shows warning for gems not removed" do
         install_gemfile <<-G
           source "#{file_uri_for(gem_repo1)}"
           gem "rack"; gem "rails"
         G
 
-        bundle "remove rails"
+        bundle "remove rails", :raise_on_error => false
 
         expect(err).to include("Gems could not be removed. rack (>= 0) would also have been removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
           gem "rack"; gem "rails"
         G
@@ -328,7 +385,7 @@ RSpec.describe "bundle remove" do
 
     context "when some gems could not be removed" do
       it "shows warning for gems not removed and success for those removed" do
-        install_gemfile <<-G
+        install_gemfile <<-G, :raise_on_error => false
           source "#{file_uri_for(gem_repo1)}"
           gem"rack"
           gem"rspec"
@@ -336,12 +393,12 @@ RSpec.describe "bundle remove" do
           gem "minitest"
         G
 
-        bundle! "remove rails rack rspec minitest"
+        bundle "remove rails rack rspec minitest"
 
         expect(out).to include("rails was removed.")
         expect(out).to include("minitest was removed.")
         expect(out).to include("rack, rspec could not be removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
           gem"rack"
           gem"rspec"
@@ -368,12 +425,12 @@ RSpec.describe "bundle remove" do
         end
       G
 
-      bundle! "install"
+      bundle "install"
 
-      bundle! "remove rspec"
+      bundle "remove rspec"
 
       expect(out).to include("rspec was removed.")
-      gemfile_should_be <<-G
+      expect(gemfile).to eq <<~G
         source "#{file_uri_for(gem_repo1)}"
 
         gem "rack"
@@ -396,7 +453,7 @@ RSpec.describe "bundle remove" do
           gem "rack"
         G
 
-        bundle! "remove rack"
+        bundle "remove rack"
 
         expect(out).to include("rack was removed.")
       end
@@ -414,7 +471,7 @@ RSpec.describe "bundle remove" do
           eval_gemfile "Gemfile-other"
         G
 
-        bundle! "remove rack"
+        bundle "remove rack"
 
         expect(bundled_app("Gemfile-other").read).to_not include("gem \"rack\"")
         expect(out).to include("rack was removed.")
@@ -434,9 +491,9 @@ RSpec.describe "bundle remove" do
           eval_gemfile "Gemfile-other"
         G
 
-        bundle "remove rack"
+        bundle "remove rack", :raise_on_error => false
 
-        expect(err).to include("`rack` is not specified in #{bundled_app("Gemfile")} so it could not be removed.")
+        expect(err).to include("`rack` is not specified in #{bundled_app_gemfile} so it could not be removed.")
       end
     end
 
@@ -453,11 +510,11 @@ RSpec.describe "bundle remove" do
           gem "rack"
         G
 
-        bundle "remove rack"
+        bundle "remove rack", :raise_on_error => false
 
         expect(out).to include("rack was removed.")
         expect(err).to include("`rack` is not specified in #{bundled_app("Gemfile-other")} so it could not be removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
 
           eval_gemfile "Gemfile-other"
@@ -465,7 +522,7 @@ RSpec.describe "bundle remove" do
       end
     end
 
-    context "when gems can not be removed from other gemfile" do
+    context "when gems cannot be removed from other gemfile" do
       it "shows error" do
         create_file "Gemfile-other", <<-G
           gem "rails"; gem "rack"
@@ -478,11 +535,11 @@ RSpec.describe "bundle remove" do
           gem "rack"
         G
 
-        bundle "remove rack"
+        bundle "remove rack", :raise_on_error => false
 
         expect(out).to include("rack was removed.")
         expect(err).to include("Gems could not be removed. rails (>= 0) would also have been removed.")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
 
           eval_gemfile "Gemfile-other"
@@ -503,11 +560,11 @@ RSpec.describe "bundle remove" do
           gem "rails"; gem "rack"
         G
 
-        bundle "remove rack"
+        bundle "remove rack", :raise_on_error => false
 
         expect(err).to include("Gems could not be removed. rails (>= 0) would also have been removed.")
         expect(bundled_app("Gemfile-other").read).to include("gem \"rack\"")
-        gemfile_should_be <<-G
+        expect(gemfile).to eq <<~G
           source "#{file_uri_for(gem_repo1)}"
 
           eval_gemfile "Gemfile-other"
@@ -517,7 +574,7 @@ RSpec.describe "bundle remove" do
     end
 
     context "when gem present in gemfiles but could not be removed from one from one of them" do
-      it "removes gem which can be removed and shows warning for file from which it can not be removed" do
+      it "removes gem which can be removed and shows warning for file from which it cannot be removed" do
         create_file "Gemfile-other", <<-G
           gem "rack"
         G
@@ -529,7 +586,7 @@ RSpec.describe "bundle remove" do
           gem"rack"
         G
 
-        bundle! "remove rack"
+        bundle "remove rack"
 
         expect(out).to include("rack was removed.")
         expect(bundled_app("Gemfile-other").read).to_not include("gem \"rack\"")
@@ -547,10 +604,10 @@ RSpec.describe "bundle remove" do
         end
       G
 
-      bundle! "remove rack"
+      bundle "remove rack"
 
       expect(out).to include("rack was removed.")
-      gemfile_should_be <<-G
+      expect(gemfile).to eq <<~G
         source "#{file_uri_for(gem_repo1)}"
       G
     end
@@ -566,10 +623,10 @@ RSpec.describe "bundle remove" do
         end
       G
 
-      bundle! "remove rack"
+      bundle "remove rack"
 
       expect(out).to include("rack was removed.")
-      gemfile_should_be <<-G
+      expect(gemfile).to eq <<~G
         source "#{file_uri_for(gem_repo1)}"
       G
     end
@@ -587,9 +644,89 @@ RSpec.describe "bundle remove" do
         gemspec :path => '#{tmp.join("foo")}', :name => 'foo'
       G
 
-      bundle! "remove foo"
+      bundle "remove foo"
 
       expect(out).to include("foo could not be removed.")
     end
   end
+
+  describe "with comments that mention gems" do
+    context "when comment is a separate line comment" do
+      it "does not remove the line comment" do
+        gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+
+          # gem "rack" might be used in the future
+          gem "rack"
+        G
+
+        bundle "remove rack"
+
+        expect(out).to include("rack was removed.")
+        expect(gemfile).to eq <<~G
+          source "#{file_uri_for(gem_repo1)}"
+
+          # gem "rack" might be used in the future
+        G
+      end
+    end
+
+    context "when gem specified for removal has an inline comment" do
+      it "removes the inline comment" do
+        gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+
+          gem "rack" # this can be removed
+        G
+
+        bundle "remove rack"
+
+        expect(out).to include("rack was removed.")
+        expect(gemfile).to eq <<~G
+          source "#{file_uri_for(gem_repo1)}"
+        G
+      end
+    end
+
+    context "when gem specified for removal is mentioned in other gem's comment" do
+      it "does not remove other gem" do
+        gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+          gem "puma" # implements interface provided by gem "rack"
+
+          gem "rack"
+        G
+
+        bundle "remove rack"
+
+        expect(out).to_not include("puma was removed.")
+        expect(out).to include("rack was removed.")
+        expect(gemfile).to eq <<~G
+          source "#{file_uri_for(gem_repo1)}"
+          gem "puma" # implements interface provided by gem "rack"
+        G
+      end
+    end
+
+    context "when gem specified for removal has a comment that mentions other gem" do
+      it "does not remove other gem" do
+        gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+          gem "puma" # implements interface provided by gem "rack"
+
+          gem "rack"
+        G
+
+        bundle "remove puma"
+
+        expect(out).to include("puma was removed.")
+        expect(out).to_not include("rack was removed.")
+        expect(gemfile).to eq <<~G
+          source "#{file_uri_for(gem_repo1)}"
+
+          gem "rack"
+        G
+      end
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/show_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/show_spec.rb
@@ -10,19 +10,19 @@ RSpec.describe "bundle show", :bundler =
     end
 
     it "creates a Gemfile.lock if one did not exist" do
-      FileUtils.rm("Gemfile.lock")
+      FileUtils.rm(bundled_app_lock)
 
       bundle "show"
 
-      expect(bundled_app("Gemfile.lock")).to exist
+      expect(bundled_app_lock).to exist
     end
 
     it "creates a Gemfile.lock when invoked with a gem name" do
-      FileUtils.rm("Gemfile.lock")
+      FileUtils.rm(bundled_app_lock)
 
       bundle "show rails"
 
-      expect(bundled_app("Gemfile.lock")).to exist
+      expect(bundled_app_lock).to exist
     end
 
     it "prints path if gem exists in bundle" do
@@ -50,14 +50,14 @@ RSpec.describe "bundle show", :bundler =
     end
 
     it "complains if gem not in bundle" do
-      bundle "show missing"
+      bundle "show missing", :raise_on_error => false
       expect(err).to match(/could not find gem 'missing'/i)
     end
 
     it "prints path of all gems in bundle sorted by name" do
       bundle "show --paths"
 
-      expect(out).to include(default_bundle_path("gems", "rake-12.3.2").to_s)
+      expect(out).to include(default_bundle_path("gems", "rake-13.0.1").to_s)
       expect(out).to include(default_bundle_path("gems", "rails-2.3.2").to_s)
 
       # Gem names are the last component of their path.
@@ -100,10 +100,10 @@ RSpec.describe "bundle show", :bundler =
       expect(the_bundle).to include_gems "foo 1.0"
 
       bundle :show
-      expect(out).to include("foo (1.0 #{@git.ref_for("master", 6)}")
+      expect(out).to include("foo (1.0 #{@git.ref_for("main", 6)}")
     end
 
-    it "prints out branch names other than master" do
+    it "prints out branch names other than main" do
       update_git "foo", :branch => "omg" do |s|
         s.write "lib/foo.rb", "FOO = '1.0.omg'"
       end
@@ -135,7 +135,7 @@ RSpec.describe "bundle show", :bundler =
       G
       expect(the_bundle).to include_gems "foo 1.0.0.pre.beta.1"
 
-      bundle! :show
+      bundle :show
       expect(out).to include("foo (1.0.0.pre.beta.1")
     end
   end
@@ -143,13 +143,12 @@ RSpec.describe "bundle show", :bundler =
   context "in a fresh gem in a blank git repo" do
     before :each do
       build_git "foo", :path => lib_path("foo")
-      in_app_root_custom lib_path("foo")
-      File.open("Gemfile", "w") {|f| f.puts "gemspec" }
-      sys_exec "rm -rf .git && git init"
+      File.open(lib_path("foo/Gemfile"), "w") {|f| f.puts "gemspec" }
+      sys_exec "rm -rf .git && git init", :dir => lib_path("foo")
     end
 
     it "does not output git errors" do
-      bundle :show
+      bundle :show, :dir => lib_path("foo")
       expect(err_without_deprecations).to be_empty
     end
   end
@@ -166,7 +165,7 @@ RSpec.describe "bundle show", :bundler =
   end
 
   context "with a valid regexp for gem name" do
-    it "presents alternatives" do
+    it "presents alternatives", :readline do
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
@@ -174,7 +173,7 @@ RSpec.describe "bundle show", :bundler =
       G
 
       bundle "show rac"
-      expect(out).to eq "1 : rack\n2 : rack-obama\n0 : - exit -\n>"
+      expect(out).to match(/\A1 : rack\n2 : rack-obama\n0 : - exit -(\n>)?\z/)
     end
   end
 
@@ -187,19 +186,19 @@ RSpec.describe "bundle show", :bundler =
 
       invalid_regexp = "[]"
 
-      bundle "show #{invalid_regexp}"
+      bundle "show #{invalid_regexp}", :raise_on_error => false
       expect(err).to include("Could not find gem '#{invalid_regexp}'.")
     end
   end
 
   context "--outdated option" do
-    # Regression test for https://github.com/bundler/bundler/issues/5375
+    # Regression test for https://github.com/rubygems/bundler/issues/5375
     before do
       build_repo2
     end
 
     it "doesn't update gems to newer versions" do
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
         gem "rails"
       G
@@ -212,9 +211,9 @@ RSpec.describe "bundle show", :bundler =
         end
       end
 
-      bundle! "show --outdated"
+      bundle "show --outdated"
 
-      bundle! "install"
+      bundle "install"
       expect(the_bundle).to include_gem("rails 2.3.2")
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/update_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/update_spec.rb
@@ -1,20 +1,24 @@
 # frozen_string_literal: true
 
 RSpec.describe "bundle update" do
-  before :each do
-    build_repo2
+  describe "with no arguments" do
+    before do
+      build_repo2
 
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo2)}"
-      gem "activesupport"
-      gem "rack-obama"
-      gem "platform_specific"
-    G
-  end
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+        gem "platform_specific"
+      G
+    end
 
-  describe "with no arguments", :bundler => "< 3" do
     it "updates the entire bundle" do
       update_repo2 do
+        build_gem "rack", "1.2" do |s|
+          s.executables = "rackup"
+        end
+
         build_gem "activesupport", "3.0"
       end
 
@@ -30,31 +34,48 @@ RSpec.describe "bundle update" do
         gem "rack-obama"
         exit!
       G
-      bundle "update"
-      expect(bundled_app("Gemfile.lock")).to exist
+      bundle "update", :raise_on_error => false
+      expect(bundled_app_lock).to exist
     end
   end
 
-  describe "with --all", :bundler => "3" do
+  describe "with --all" do
+    before do
+      build_repo2
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+        gem "platform_specific"
+      G
+    end
+
     it "updates the entire bundle" do
       update_repo2 do
+        build_gem "rack", "1.2" do |s|
+          s.executables = "rackup"
+        end
+
         build_gem "activesupport", "3.0"
       end
 
-      bundle! "update", :all => true
+      bundle "update", :all => true
       expect(out).to include("Bundle updated!")
       expect(the_bundle).to include_gems "rack 1.2", "rack-obama 1.0", "activesupport 3.0"
     end
 
     it "doesn't delete the Gemfile.lock file if something goes wrong" do
+      install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
+
       gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
         gem "activesupport"
         gem "rack-obama"
         exit!
       G
-      bundle "update", :all => true
-      expect(bundled_app("Gemfile.lock")).to exist
+      bundle "update", :all => true, :raise_on_error => false
+      expect(bundled_app_lock).to exist
     end
   end
 
@@ -65,35 +86,46 @@ RSpec.describe "bundle update" do
         gem "rack", "1.0"
       G
 
-      bundle! "update --gemfile OmgFile", :all => true
+      bundle "update --gemfile OmgFile", :all => true
 
       expect(bundled_app("OmgFile.lock")).to exist
     end
   end
 
   context "when update_requires_all_flag is set" do
-    before { bundle! "config set update_requires_all_flag true" }
+    before { bundle "config set update_requires_all_flag true" }
 
     it "errors when passed nothing" do
-      install_gemfile! ""
-      bundle :update
+      install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
+      bundle :update, :raise_on_error => false
       expect(err).to eq("To update everything, pass the `--all` flag.")
     end
 
     it "errors when passed --all and another option" do
-      install_gemfile! ""
-      bundle "update --all foo"
+      install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
+      bundle "update --all foo", :raise_on_error => false
       expect(err).to eq("Cannot specify --all along with specific options.")
     end
 
     it "updates everything when passed --all" do
-      install_gemfile! ""
+      install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
       bundle "update --all"
       expect(out).to include("Bundle updated!")
     end
   end
 
   describe "--quiet argument" do
+    before do
+      build_repo2
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+        gem "platform_specific"
+      G
+    end
+
     it "hides UI messages" do
       bundle "update --quiet"
       expect(out).not_to include("Bundle updated!")
@@ -101,8 +133,23 @@ RSpec.describe "bundle update" do
   end
 
   describe "with a top level dependency" do
+    before do
+      build_repo2
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+        gem "platform_specific"
+      G
+    end
+
     it "unlocks all child dependencies that are unrelated to other locked dependencies" do
       update_repo2 do
+        build_gem "rack", "1.2" do |s|
+          s.executables = "rackup"
+        end
+
         build_gem "activesupport", "3.0"
       end
 
@@ -112,95 +159,336 @@ RSpec.describe "bundle update" do
   end
 
   describe "with an unknown dependency" do
+    before do
+      build_repo2
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+        gem "platform_specific"
+      G
+    end
+
     it "should inform the user" do
-      bundle "update halting-problem-solver"
+      bundle "update halting-problem-solver", :raise_on_error => false
       expect(err).to include "Could not find gem 'halting-problem-solver'"
     end
     it "should suggest alternatives" do
-      bundle "update platformspecific"
+      bundle "update platformspecific", :raise_on_error => false
       expect(err).to include "Did you mean platform_specific?"
     end
   end
 
   describe "with a child dependency" do
+    before do
+      build_repo2
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+        gem "platform_specific"
+      G
+    end
+
     it "should update the child dependency" do
-      update_repo2
+      update_repo2 do
+        build_gem "rack", "1.2" do |s|
+          s.executables = "rackup"
+        end
+      end
+
       bundle "update rack"
       expect(the_bundle).to include_gems "rack 1.2"
     end
   end
 
   describe "when a possible resolve requires an older version of a locked gem" do
-    context "and only_update_to_newer_versions is set" do
-      before do
-        bundle! "config set only_update_to_newer_versions true"
+    it "does not go to an older version" do
+      build_repo4 do
+        build_gem "tilt", "2.0.8"
+        build_gem "slim", "3.0.9" do |s|
+          s.add_dependency "tilt", [">= 1.3.3", "< 2.1"]
+        end
+        build_gem "slim_lint", "0.16.1" do |s|
+          s.add_dependency "slim", [">= 3.0", "< 5.0"]
+        end
+        build_gem "slim-rails", "0.2.1" do |s|
+          s.add_dependency "slim", ">= 0.9.2"
+        end
+        build_gem "slim-rails", "3.1.3" do |s|
+          s.add_dependency "slim", "~> 3.0"
+        end
       end
 
-      it "does not go to an older version" do
-        build_repo4 do
-          build_gem "tilt", "2.0.8"
-          build_gem "slim", "3.0.9" do |s|
-            s.add_dependency "tilt", [">= 1.3.3", "< 2.1"]
-          end
-          build_gem "slim_lint", "0.16.1" do |s|
-            s.add_dependency "slim", [">= 3.0", "< 5.0"]
-          end
-          build_gem "slim-rails", "0.2.1" do |s|
-            s.add_dependency "slim", ">= 0.9.2"
-          end
-          build_gem "slim-rails", "3.1.3" do |s|
-            s.add_dependency "slim", "~> 3.0"
-          end
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "slim-rails"
+        gem "slim_lint"
+      G
+
+      expect(the_bundle).to include_gems("slim 3.0.9", "slim-rails 3.1.3", "slim_lint 0.16.1")
+
+      update_repo4 do
+        build_gem "slim", "4.0.0" do |s|
+          s.add_dependency "tilt", [">= 2.0.6", "< 2.1"]
         end
+      end
 
-        install_gemfile! <<-G
-          source "#{file_uri_for(gem_repo4)}"
-          gem "slim-rails"
-          gem "slim_lint"
-        G
+      bundle "update", :all => true
 
-        expect(the_bundle).to include_gems("slim 3.0.9", "slim-rails 3.1.3", "slim_lint 0.16.1")
+      expect(the_bundle).to include_gems("slim 3.0.9", "slim-rails 3.1.3", "slim_lint 0.16.1")
+    end
 
-        update_repo4 do
-          build_gem "slim", "4.0.0" do |s|
-            s.add_dependency "tilt", [">= 2.0.6", "< 2.1"]
-          end
+    it "does not go to an older version, even if the version upgrade that could cause another gem to downgrade is activated first" do
+      build_repo4 do
+        # countries is processed before country_select by the resolver due to having less spec groups (groups of versions with the same dependencies) (2 vs 3)
+
+        build_gem "countries", "2.1.4"
+        build_gem "countries", "3.1.0"
+
+        build_gem "countries", "4.0.0" do |s|
+          s.add_dependency "sixarm_ruby_unaccent", "~> 1.1"
+        end
+
+        build_gem "country_select", "1.2.0"
+
+        build_gem "country_select", "2.1.4" do |s|
+          s.add_dependency "countries", "~> 2.0"
+        end
+        build_gem "country_select", "3.1.1" do |s|
+          s.add_dependency "countries", "~> 2.0"
         end
 
-        bundle! "update", :all => true
+        build_gem "country_select", "5.1.0" do |s|
+          s.add_dependency "countries", "~> 3.0"
+        end
 
-        expect(the_bundle).to include_gems("slim 3.0.9", "slim-rails 3.1.3", "slim_lint 0.16.1")
+        build_gem "sixarm_ruby_unaccent", "1.1.0"
       end
 
-      it "should still downgrade if forced by the Gemfile" do
-        build_repo4 do
-          build_gem "a"
-          build_gem "b", "1.0"
-          build_gem "b", "2.0"
+      gemfile <<~G
+        source "#{file_uri_for(gem_repo4)}"
+
+        gem "country_select"
+        gem "countries"
+      G
+
+      lockfile <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            countries (3.1.0)
+            country_select (5.1.0)
+              countries (~> 3.0)
+
+        PLATFORMS
+          #{specific_local_platform}
+
+        DEPENDENCIES
+          countries
+          country_select
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      previous_lockfile = lockfile
+
+      bundle "lock --update"
+
+      expect(lockfile).to eq(previous_lockfile)
+    end
+
+    it "does not downgrade direct dependencies when run with --conservative" do
+      build_repo4 do
+        build_gem "oauth2", "2.0.6" do |s|
+          s.add_dependency "faraday", ">= 0.17.3", "< 3.0"
         end
 
-        install_gemfile! <<-G
-          source "#{file_uri_for(gem_repo4)}"
-          gem "a"
-          gem "b"
-        G
+        build_gem "oauth2", "1.4.10" do |s|
+          s.add_dependency "faraday", ">= 0.17.3", "< 3.0"
+          s.add_dependency "multi_json", "~> 1.3"
+        end
 
-        expect(the_bundle).to include_gems("a 1.0", "b 2.0")
+        build_gem "faraday", "2.5.2"
 
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo4)}"
-          gem "a"
-          gem "b", "1.0"
-        G
+        build_gem "multi_json", "1.15.0"
+
+        build_gem "quickbooks-ruby", "1.0.19" do |s|
+          s.add_dependency "oauth2", "~> 1.4"
+        end
+
+        build_gem "quickbooks-ruby", "0.1.9" do |s|
+          s.add_dependency "oauth2"
+        end
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+
+        gem "oauth2"
+        gem "quickbooks-ruby"
+      G
+
+      lockfile <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            faraday (2.5.2)
+            multi_json (1.15.0)
+            oauth2 (1.4.10)
+              faraday (>= 0.17.3, < 3.0)
+              multi_json (~> 1.3)
+            quickbooks-ruby (1.0.19)
+              oauth2 (~> 1.4)
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          oauth2
+          quickbooks-ruby
 
-        bundle! "update b"
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      bundle "update --conservative --verbose"
 
-        expect(the_bundle).to include_gems("a 1.0", "b 1.0")
+      expect(out).not_to include("Installing quickbooks-ruby 0.1.9")
+      expect(out).to include("Installing quickbooks-ruby 1.0.19").and include("Installing oauth2 1.4.10")
+    end
+
+    it "does not downgrade indirect dependencies unnecessarily" do
+      build_repo4 do
+        build_gem "a" do |s|
+          s.add_dependency "b"
+          s.add_dependency "c"
+        end
+        build_gem "b"
+        build_gem "c"
+        build_gem "c", "2.0"
       end
+
+      install_gemfile <<-G, :verbose => true
+        source "#{file_uri_for(gem_repo4)}"
+        gem "a"
+      G
+
+      expect(the_bundle).to include_gems("a 1.0", "b 1.0", "c 2.0")
+
+      update_repo4 do
+        build_gem "b", "2.0" do |s|
+          s.add_dependency "c", "< 2"
+        end
+      end
+
+      bundle "update", :all => true, :verbose => true
+      expect(the_bundle).to include_gems("a 1.0", "b 1.0", "c 2.0")
+    end
+
+    it "should still downgrade if forced by the Gemfile" do
+      build_repo4 do
+        build_gem "a"
+        build_gem "b", "1.0"
+        build_gem "b", "2.0"
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "a"
+        gem "b"
+      G
+
+      expect(the_bundle).to include_gems("a 1.0", "b 2.0")
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "a"
+        gem "b", "1.0"
+      G
+
+      bundle "update b"
+
+      expect(the_bundle).to include_gems("a 1.0", "b 1.0")
+    end
+
+    it "should still downgrade if forced by the Gemfile, when transitive dependencies also need downgrade" do
+      build_repo4 do
+        build_gem "activesupport", "6.1.4.1" do |s|
+          s.add_dependency "tzinfo", "~> 2.0"
+        end
+
+        build_gem "activesupport", "6.0.4.1" do |s|
+          s.add_dependency "tzinfo", "~> 1.1"
+        end
+
+        build_gem "tzinfo", "2.0.4"
+        build_gem "tzinfo", "1.2.9"
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "activesupport", "~> 6.1.0"
+      G
+
+      expect(the_bundle).to include_gems("activesupport 6.1.4.1", "tzinfo 2.0.4")
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "activesupport", "~> 6.0.0"
+      G
+
+      original_lockfile = lockfile
+
+      expected_lockfile = <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            activesupport (6.0.4.1)
+              tzinfo (~> 1.1)
+            tzinfo (1.2.9)
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          activesupport (~> 6.0.0)
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      bundle "update activesupport"
+      expect(the_bundle).to include_gems("activesupport 6.0.4.1", "tzinfo 1.2.9")
+      expect(lockfile).to eq(expected_lockfile)
+
+      lockfile original_lockfile
+      bundle "update"
+      expect(the_bundle).to include_gems("activesupport 6.0.4.1", "tzinfo 1.2.9")
+      expect(lockfile).to eq(expected_lockfile)
+
+      lockfile original_lockfile
+      bundle "lock --update"
+      expect(the_bundle).to include_gems("activesupport 6.0.4.1", "tzinfo 1.2.9")
+      expect(lockfile).to eq(expected_lockfile)
     end
   end
 
   describe "with --local option" do
+    before do
+      build_repo2
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+        gem "platform_specific"
+      G
+    end
+
     it "doesn't hit repo2" do
       FileUtils.rm_rf(gem_repo2)
 
@@ -210,6 +498,10 @@ RSpec.describe "bundle update" do
   end
 
   describe "with --group option" do
+    before do
+      build_repo2
+    end
+
     it "should update only specified group gems" do
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
@@ -217,6 +509,10 @@ RSpec.describe "bundle update" do
         gem "rack"
       G
       update_repo2 do
+        build_gem "rack", "1.2" do |s|
+          s.executables = "rackup"
+        end
+
         build_gem "activesupport", "3.0"
       end
       bundle "update --group development"
@@ -242,7 +538,7 @@ RSpec.describe "bundle update" do
     end
 
     context "when there is a source with the same name as a gem in a group" do
-      before :each do
+      before do
         build_git "foo", :path => lib_path("activesupport")
         install_gemfile <<-G
           source "#{file_uri_for(gem_repo2)}"
@@ -269,6 +565,10 @@ RSpec.describe "bundle update" do
           gem "rack"
         G
         update_repo2 do
+          build_gem "rack", "1.2" do |s|
+            s.executables = "rackup"
+          end
+
           build_gem "activesupport", "3.0"
         end
         bundle "update --group development"
@@ -280,9 +580,20 @@ RSpec.describe "bundle update" do
   end
 
   describe "in a frozen bundle" do
+    before do
+      build_repo2
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "activesupport"
+        gem "rack-obama"
+        gem "platform_specific"
+      G
+    end
+
     it "should fail loudly", :bundler => "< 3" do
-      bundle! "install --deployment"
-      bundle "update", :all => true
+      bundle "install --deployment"
+      bundle "update", :all => true, :raise_on_error => false
 
       expect(last_command).to be_failure
       expect(err).to match(/You are trying to install in deployment mode after changing.your Gemfile/m)
@@ -290,56 +601,45 @@ RSpec.describe "bundle update" do
     end
 
     it "should suggest different command when frozen is set globally", :bundler => "< 3" do
-      bundle! "config set --global frozen 1"
-      bundle "update", :all => true
+      bundle "config set --global frozen 1"
+      bundle "update", :all => true, :raise_on_error => false
       expect(err).to match(/You are trying to install in deployment mode after changing.your Gemfile/m).
         and match(/freeze \nby running `bundle config unset frozen`./m)
     end
 
     it "should suggest different command when frozen is set globally", :bundler => "3" do
-      bundle! "config set --global deployment true"
-      bundle "update", :all => true
+      bundle "config set --global deployment true"
+      bundle "update", :all => true, :raise_on_error => false
       expect(err).to match(/You are trying to install in deployment mode after changing.your Gemfile/m).
         and match(/freeze \nby running `bundle config unset deployment`./m)
     end
   end
 
   describe "with --source option" do
-    it "should not update gems not included in the source that happen to have the same name", :bundler => "< 3" do
-      install_gemfile! <<-G
+    before do
+      build_repo2
+    end
+
+    it "should not update gems not included in the source that happen to have the same name" do
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
         gem "activesupport"
       G
       update_repo2 { build_gem "activesupport", "3.0" }
 
-      bundle! "update --source activesupport"
-      expect(the_bundle).to include_gem "activesupport 3.0"
+      bundle "update --source activesupport"
+      expect(the_bundle).not_to include_gem "activesupport 3.0"
     end
 
-    it "should not update gems not included in the source that happen to have the same name", :bundler => "3" do
-      install_gemfile! <<-G
+    it "should not update gems not included in the source that happen to have the same name" do
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
         gem "activesupport"
       G
       update_repo2 { build_gem "activesupport", "3.0" }
 
-      bundle! "update --source activesupport"
-      expect(the_bundle).not_to include_gem "activesupport 3.0"
-    end
-
-    context "with unlock_source_unlocks_spec set to false" do
-      before { bundle! "config set unlock_source_unlocks_spec false" }
-
-      it "should not update gems not included in the source that happen to have the same name" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo2)}"
-          gem "activesupport"
-        G
-        update_repo2 { build_gem "activesupport", "3.0" }
-
-        bundle "update --source activesupport"
-        expect(the_bundle).not_to include_gems "activesupport 3.0"
-      end
+      bundle "update --source activesupport"
+      expect(the_bundle).not_to include_gems "activesupport 3.0"
     end
   end
 
@@ -359,20 +659,7 @@ RSpec.describe "bundle update" do
       G
     end
 
-    it "should not update the child dependencies of a gem that has the same name as the source", :bundler => "< 3" do
-      update_repo2 do
-        build_gem "fred", "2.0"
-        build_gem "harry", "2.0" do |s|
-          s.add_dependency "fred"
-        end
-      end
-
-      bundle "update --source harry"
-      expect(the_bundle).to include_gems "harry 2.0"
-      expect(the_bundle).to include_gems "fred 1.0"
-    end
-
-    it "should not update the child dependencies of a gem that has the same name as the source", :bundler => "3" do
+    it "should not update the child dependencies of a gem that has the same name as the source" do
       update_repo2 do
         build_gem "fred", "2.0"
         build_gem "harry", "2.0" do |s|
@@ -404,7 +691,7 @@ RSpec.describe "bundle update" do
       G
     end
 
-    it "should not update the child dependencies of a gem that has the same name as the source", :bundler => "< 3" do
+    it "should not update the child dependencies of a gem that has the same name as the source" do
       update_repo2 do
         build_gem "george", "2.0"
         build_gem "harry", "2.0" do |s|
@@ -413,27 +700,133 @@ RSpec.describe "bundle update" do
       end
 
       bundle "update --source harry"
-      expect(the_bundle).to include_gems "harry 2.0"
-      expect(the_bundle).to include_gems "fred 1.0"
-      expect(the_bundle).to include_gems "george 1.0"
+      expect(the_bundle).to include_gems "harry 1.0", "fred 1.0", "george 1.0"
+    end
+  end
+
+  it "shows the previous version of the gem when updated from rubygems source", :bundler => "< 3" do
+    build_repo2
+
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo2)}"
+      gem "activesupport"
+    G
+
+    bundle "update", :all => true
+    expect(out).to include("Using activesupport 2.3.5")
+
+    update_repo2 do
+      build_gem "activesupport", "3.0"
+    end
+
+    bundle "update", :all => true
+    expect(out).to include("Installing activesupport 3.0 (was 2.3.5)")
+  end
+
+  context "with suppress_install_using_messages set" do
+    before { bundle "config set suppress_install_using_messages true" }
+
+    it "only prints `Using` for versions that have changed" do
+      build_repo4 do
+        build_gem "bar"
+        build_gem "foo"
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "bar"
+        gem "foo"
+      G
+
+      bundle "update", :all => true
+      expect(out).to match(/Resolving dependencies\.\.\.\.*\nBundle updated!/)
+
+      update_repo4 do
+        build_gem "foo", "2.0"
+      end
+
+      bundle "update", :all => true
+      out.sub!("Removing foo (1.0)\n", "")
+      expect(out).to match(/Resolving dependencies\.\.\.\.*\nFetching foo 2\.0 \(was 1\.0\)\nInstalling foo 2\.0 \(was 1\.0\)\nBundle updated/)
+    end
+  end
+
+  it "shows error message when Gemfile.lock is not preset and gem is specified" do
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo2)}"
+      gem "activesupport"
+    G
+
+    bundle "update nonexisting", :raise_on_error => false
+    expect(err).to include("This Bundle hasn't been installed yet. Run `bundle install` to update and install the bundled gems.")
+    expect(exitstatus).to eq(22)
+  end
+
+  context "with multiple, duplicated sources, with lockfile in old format", :bundler => "< 3" do
+    before do
+      build_repo2 do
+        build_gem "dotenv", "2.7.6"
+
+        build_gem "oj", "3.11.3"
+        build_gem "oj", "3.11.5"
+
+        build_gem "vcr", "6.0.0"
+      end
+
+      build_repo gem_repo3 do
+        build_gem "pkg-gem-flowbyte-with-dep", "1.0.0" do |s|
+          s.add_dependency "oj"
+        end
+      end
+
+      gemfile <<~G
+        source "https://gem.repo2"
+
+        gem "dotenv"
+
+        source "https://gem.repo3" do
+          gem 'pkg-gem-flowbyte-with-dep'
+        end
+
+        gem "vcr",source: "https://gem.repo2"
+      G
+
+      lockfile <<~L
+        GEM
+          remote: https://gem.repo2/
+          remote: https://gem.repo3/
+          specs:
+            dotenv (2.7.6)
+            oj (3.11.3)
+            pkg-gem-flowbyte-with-dep (1.0.0)
+              oj
+            vcr (6.0.0)
+
+        PLATFORMS
+          #{specific_local_platform}
+
+        DEPENDENCIES
+          dotenv
+          pkg-gem-flowbyte-with-dep!
+          vcr!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
     end
 
-    it "should not update the child dependencies of a gem that has the same name as the source", :bundler => "3" do
-      update_repo2 do
-        build_gem "george", "2.0"
-        build_gem "harry", "2.0" do |s|
-          s.add_dependency "george"
-        end
-      end
+    it "works" do
+      bundle :install, :artifice => "compact_index"
+      bundle "update oj", :artifice => "compact_index"
 
-      bundle "update --source harry"
-      expect(the_bundle).to include_gems "harry 1.0", "fred 1.0", "george 1.0"
+      expect(out).to include("Bundle updated!")
+      expect(the_bundle).to include_gems "oj 3.11.5"
     end
   end
 end
 
 RSpec.describe "bundle update in more complicated situations" do
-  before :each do
+  before do
     build_repo2
   end
 
@@ -446,6 +839,10 @@ RSpec.describe "bundle update in more co
     G
 
     update_repo2 do
+      build_gem "rack", "1.2" do |s|
+        s.executables = "rackup"
+      end
+
       build_gem "thin", "2.0" do |s|
         s.add_dependency "rack"
       end
@@ -456,7 +853,7 @@ RSpec.describe "bundle update in more co
   end
 
   it "will warn when some explicitly updated gems are not updated" do
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo2)}"
 
       gem "thin"
@@ -468,7 +865,7 @@ RSpec.describe "bundle update in more co
       build_gem "rack", "10.0"
     end
 
-    bundle! "update thin rack-obama"
+    bundle "update thin rack-obama"
     expect(last_command.stdboth).to include "Bundler attempted to update rack-obama but its version stayed the same"
     expect(the_bundle).to include_gems "thin 2.0", "rack 10.0", "rack-obama 1.0"
   end
@@ -476,7 +873,8 @@ RSpec.describe "bundle update in more co
   it "will not warn when an explicitly updated git gem changes sha but not version" do
     build_git "foo"
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => '#{lib_path("foo-1.0")}'
     G
 
@@ -484,7 +882,7 @@ RSpec.describe "bundle update in more co
       s.write "lib/foo2.rb", "puts :foo2"
     end
 
-    bundle! "update foo"
+    bundle "update foo"
 
     expect(last_command.stdboth).not_to include "attempted to update"
   end
@@ -492,7 +890,8 @@ RSpec.describe "bundle update in more co
   it "will not warn when changing gem sources but not versions" do
     build_git "rack"
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo2)}"
       gem "rack", :git => '#{lib_path("rack-1.0")}'
     G
 
@@ -501,7 +900,7 @@ RSpec.describe "bundle update in more co
       gem "rack"
     G
 
-    bundle! "update rack"
+    bundle "update rack"
 
     expect(last_command.stdboth).not_to include "attempted to update"
   end
@@ -554,12 +953,12 @@ RSpec.describe "bundle update in more co
     end
 
     it "allows updating" do
-      bundle! :update, :all => true
+      bundle :update, :all => true
       expect(the_bundle).to include_gem "a 1.1"
     end
 
     it "allows updating a specific gem" do
-      bundle! "update a"
+      bundle "update a"
       expect(the_bundle).to include_gem "a 1.1"
     end
   end
@@ -593,7 +992,7 @@ RSpec.describe "bundle update in more co
     end
 
     it "is not updated because it is not actually included in the bundle" do
-      bundle! "update a"
+      bundle "update a"
       expect(last_command.stdboth).to include "Bundler attempted to update a but it was not considered because it is for a different platform from the current one"
       expect(the_bundle).to_not include_gem "a"
     end
@@ -617,11 +1016,13 @@ RSpec.describe "bundle update without a 
 end
 
 RSpec.describe "bundle update when a gem depends on a newer version of bundler" do
-  before(:each) do
+  before do
     build_repo2 do
       build_gem "rails", "3.0.1" do |s|
         s.add_dependency "bundler", Bundler::VERSION.succ
       end
+
+      build_gem "bundler", Bundler::VERSION.succ
     end
 
     gemfile <<-G
@@ -630,110 +1031,32 @@ RSpec.describe "bundle update when a gem
     G
   end
 
-  it "should explain that bundler conflicted", :bundler => "< 3" do
-    bundle "update", :all => true
+  it "should explain that bundler conflicted and how to resolve the conflict" do
+    bundle "update", :all => true, :raise_on_error => false
     expect(last_command.stdboth).not_to match(/in snapshot/i)
     expect(err).to match(/current Bundler version/i).
-      and match(/perhaps you need to update bundler/i)
-  end
-
-  it "should warn that the newer version of Bundler would conflict", :bundler => "3" do
-    bundle! "update", :all => true
-    expect(err).to include("rails (3.0.1) has dependency bundler").
-      and include("so the dependency is being ignored")
-    expect(the_bundle).to include_gem "rails 3.0.1"
-  end
-end
-
-RSpec.describe "bundle update" do
-  it "shows the previous version of the gem when updated from rubygems source", :bundler => "< 3" do
-    build_repo2
-
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo2)}"
-      gem "activesupport"
-    G
-
-    bundle "update", :all => true
-    expect(out).to include("Using activesupport 2.3.5")
-
-    update_repo2 do
-      build_gem "activesupport", "3.0"
-    end
-
-    bundle "update", :all => true
-    expect(out).to include("Installing activesupport 3.0 (was 2.3.5)")
-  end
-
-  context "with suppress_install_using_messages set" do
-    before { bundle! "config set suppress_install_using_messages true" }
-
-    it "only prints `Using` for versions that have changed" do
-      build_repo4 do
-        build_gem "bar"
-        build_gem "foo"
-      end
-
-      install_gemfile! <<-G
-        source "#{file_uri_for(gem_repo4)}"
-        gem "bar"
-        gem "foo"
-      G
-
-      bundle! "update", :all => true
-      out.gsub!(/RubyGems [\d\.]+ is not threadsafe.*\n?/, "")
-      expect(out).to include "Resolving dependencies...\nBundle updated!"
-
-      update_repo4 do
-        build_gem "foo", "2.0"
-      end
-
-      bundle! "update", :all => true
-      out.sub!("Removing foo (1.0)\n", "")
-      out.gsub!(/RubyGems [\d\.]+ is not threadsafe.*\n?/, "")
-      expect(out).to include strip_whitespace(<<-EOS).strip
-        Resolving dependencies...
-        Fetching foo 2.0 (was 1.0)
-        Installing foo 2.0 (was 1.0)
-        Bundle updated
-      EOS
-    end
-  end
-
-  it "shows error message when Gemfile.lock is not preset and gem is specified" do
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo2)}"
-      gem "activesupport"
-    G
-
-    bundle "update nonexisting"
-    expect(err).to include("This Bundle hasn't been installed yet. Run `bundle install` to update and install the bundled gems.")
-    expect(exitstatus).to eq(22) if exitstatus
+      and match(/Install the necessary version with `gem install bundler:#{Bundler::VERSION.succ}`/i)
   end
 end
 
 RSpec.describe "bundle update --ruby" do
-  before do
-    install_gemfile <<-G
-        ::RUBY_VERSION = '2.1.3'
-        ::RUBY_PATCHLEVEL = 100
-        ruby '~> 2.1.0'
-    G
-    bundle "update --ruby"
-  end
-
   context "when the Gemfile removes the ruby" do
     before do
       install_gemfile <<-G
-          ::RUBY_VERSION = '2.1.4'
-          ::RUBY_PATCHLEVEL = 222
+        ruby '~> #{Gem.ruby_version}'
+        source "#{file_uri_for(gem_repo1)}"
+      G
+
+      gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
       G
     end
     it "removes the Ruby from the Gemfile.lock" do
       bundle "update --ruby"
 
-      lockfile_should_be <<-L
+      expect(lockfile).to eq <<~L
        GEM
+         remote: #{file_uri_for(gem_repo1)}/
          specs:
 
        PLATFORMS
@@ -750,16 +1073,21 @@ RSpec.describe "bundle update --ruby" do
   context "when the Gemfile specified an updated Ruby version" do
     before do
       install_gemfile <<-G
-          ::RUBY_VERSION = '2.1.4'
-          ::RUBY_PATCHLEVEL = 222
-          ruby '~> 2.1.0'
+        ruby '~> #{Gem.ruby_version}'
+        source "#{file_uri_for(gem_repo1)}"
+      G
+
+      gemfile <<-G
+          ruby '~> #{current_ruby_minor}'
+          source "#{file_uri_for(gem_repo1)}"
       G
     end
     it "updates the Gemfile.lock with the latest version" do
       bundle "update --ruby"
 
-      lockfile_should_be <<-L
+      expect(lockfile).to eq <<~L
        GEM
+         remote: #{file_uri_for(gem_repo1)}/
          specs:
 
        PLATFORMS
@@ -768,7 +1096,7 @@ RSpec.describe "bundle update --ruby" do
        DEPENDENCIES
 
        RUBY VERSION
-          ruby 2.1.4p222
+          #{Bundler::RubyVersion.system}
 
        BUNDLED WITH
           #{Bundler::VERSION}
@@ -779,31 +1107,52 @@ RSpec.describe "bundle update --ruby" do
   context "when a different Ruby is being used than has been versioned" do
     before do
       install_gemfile <<-G
-          ::RUBY_VERSION = '2.2.2'
-          ::RUBY_PATCHLEVEL = 505
+        ruby '~> #{Gem.ruby_version}'
+        source "#{file_uri_for(gem_repo1)}"
+      G
+
+      gemfile <<-G
           ruby '~> 2.1.0'
+          source "#{file_uri_for(gem_repo1)}"
       G
     end
     it "shows a helpful error message" do
-      bundle "update --ruby"
+      bundle "update --ruby", :raise_on_error => false
 
-      expect(err).to include("Your Ruby version is 2.2.2, but your Gemfile specified ~> 2.1.0")
+      expect(err).to include("Your Ruby version is #{Bundler::RubyVersion.system.gem_version}, but your Gemfile specified ~> 2.1.0")
     end
   end
 
   context "when updating Ruby version and Gemfile `ruby`" do
     before do
-      install_gemfile <<-G
-          ::RUBY_VERSION = '1.8.3'
-          ::RUBY_PATCHLEVEL = 55
-          ruby '~> 1.8.0'
+      lockfile <<~L
+       GEM
+         remote: #{file_uri_for(gem_repo1)}/
+         specs:
+
+       PLATFORMS
+         #{lockfile_platforms}
+
+       DEPENDENCIES
+
+       RUBY VERSION
+          ruby 2.1.4p222
+
+       BUNDLED WITH
+          #{Bundler::VERSION}
+      L
+
+      gemfile <<-G
+          ruby '~> #{Gem.ruby_version}'
+          source "#{file_uri_for(gem_repo1)}"
       G
     end
     it "updates the Gemfile.lock with the latest version" do
       bundle "update --ruby"
 
-      lockfile_should_be <<-L
+      expect(lockfile).to eq <<~L
        GEM
+         remote: #{file_uri_for(gem_repo1)}/
          specs:
 
        PLATFORMS
@@ -812,7 +1161,7 @@ RSpec.describe "bundle update --ruby" do
        DEPENDENCIES
 
        RUBY VERSION
-          ruby 1.8.3p55
+          #{Bundler::RubyVersion.system}
 
        BUNDLED WITH
           #{Bundler::VERSION}
@@ -827,7 +1176,7 @@ RSpec.describe "bundle update --bundler"
       build_gem "rack", "1.0"
     end
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo4)}"
       gem "rack"
     G
@@ -835,10 +1184,208 @@ RSpec.describe "bundle update --bundler"
 
     FileUtils.rm_r gem_repo4
 
-    bundle! :update, :bundler => true, :verbose => true
+    bundle :update, :bundler => true, :artifice => "compact_index", :verbose => true
+    expect(out).to include("Using bundler #{Bundler::VERSION}")
+
+    expect(lockfile).to eq <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          rack (1.0)
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        rack
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    expect(the_bundle).to include_gem "rack 1.0"
+  end
+
+  it "updates the bundler version in the lockfile without re-resolving if the highest version is already installed" do
+    system_gems "bundler-2.3.9"
+
+    build_repo4 do
+      build_gem "rack", "1.0"
+    end
+
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo4)}"
+      gem "rack"
+    G
+    lockfile lockfile.sub(/(^\s*)#{Bundler::VERSION}($)/, "2.3.9")
+
+    bundle :update, :bundler => true, :artifice => "compact_index", :verbose => true
+    expect(out).to include("Using bundler #{Bundler::VERSION}")
+
+    expect(lockfile).to eq <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          rack (1.0)
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        rack
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
     expect(the_bundle).to include_gem "rack 1.0"
+  end
+
+  it "updates the bundler version in the lockfile even if the latest version is not installed", :ruby_repo, :realworld do
+    skip "ruby-head has a default Bundler version too high for this spec to work" if RUBY_PATCHLEVEL == -1
+
+    pristine_system_gems "bundler-2.3.9"
+
+    build_repo4 do
+      build_gem "rack", "1.0"
+    end
+
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo4)}"
+      gem "rack"
+    G
+    lockfile lockfile.sub(/(^\s*)#{Bundler::VERSION}($)/, "2.3.9")
+
+    bundle :update, :bundler => true, :artifice => "vcr", :verbose => true
+
+    # Only updates properly on modern RubyGems.
+
+    if Gem.rubygems_version >= Gem::Version.new("3.3.0.dev")
+      expect(out).to include("Updating bundler to 2.3.10")
+      expect(out).to include("Using bundler 2.3.10")
+      expect(out).not_to include("Installing Bundler 2.3.9 and restarting using that version.")
+
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            rack (1.0)
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          rack
+
+        BUNDLED WITH
+           2.3.10
+      L
+
+      expect(the_bundle).to include_gems "bundler 2.3.10"
+    end
+
+    expect(the_bundle).to include_gems "rack 1.0"
+  end
+
+  it "errors if the explicit target version does not exist", :realworld do
+    skip "ruby-head has a default Bundler version too high for this spec to work" if RUBY_PATCHLEVEL == -1
+
+    pristine_system_gems "bundler-2.3.9"
+
+    build_repo4 do
+      build_gem "rack", "1.0"
+    end
+
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo4)}"
+      gem "rack"
+    G
+    lockfile lockfile.sub(/(^\s*)#{Bundler::VERSION}($)/, "2.3.9")
+
+    bundle :update, :bundler => "999.999.999", :artifice => "vcr", :raise_on_error => false
+
+    # Only gives a meaningful error message on modern RubyGems.
+
+    if Gem.rubygems_version >= Gem::Version.new("3.3.0.dev")
+      expect(last_command).to be_failure
+      expect(err).to include("The `bundle update --bundler` target version (999.999.999) does not exist")
+    end
+  end
+
+  it "allows updating to development versions if already installed locally" do
+    system_gems "bundler-2.3.0.dev"
+
+    build_repo4 do
+      build_gem "rack", "1.0"
+    end
+
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo4)}"
+      gem "rack"
+    G
+
+    bundle :update, :bundler => "2.3.0.dev"
+
+    # Only updates properly on modern RubyGems.
+
+    if Gem.rubygems_version >= Gem::Version.new("3.3.0.dev")
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            rack (1.0)
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          rack
+
+        BUNDLED WITH
+           2.3.0.dev
+      L
+
+      expect(out).to include("Using bundler 2.3.0.dev")
+    end
+  end
+
+  it "does not touch the network if not necessary" do
+    system_gems "bundler-2.3.9"
+
+    build_repo4 do
+      build_gem "rack", "1.0"
+    end
+
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo4)}"
+      gem "rack"
+    G
+
+    bundle :update, :bundler => "2.3.9", :raise_on_error => false
+
+    expect(out).not_to include("Fetching gem metadata from https://rubygems.org/")
+
+    # Only updates properly on modern RubyGems.
+
+    if Gem.rubygems_version >= Gem::Version.new("3.3.0.dev")
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            rack (1.0)
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          rack
 
-    expect(the_bundle.locked_gems.bundler_version).to eq v(Bundler::VERSION)
+        BUNDLED WITH
+           2.3.9
+      L
+
+      expect(out).to include("Using bundler 2.3.9")
+    end
   end
 end
 
@@ -879,8 +1426,8 @@ RSpec.describe "bundle update conservati
 
     context "with patch set as default update level in config" do
       it "should do a patch level update" do
-        bundle! "config set --local prefer_patch true"
-        bundle! "update foo"
+        bundle "config set --local prefer_patch true"
+        bundle "update foo"
 
         expect(the_bundle).to include_gems "foo 1.4.5", "bar 2.1.1", "qux 1.0.0"
       end
@@ -888,13 +1435,13 @@ RSpec.describe "bundle update conservati
 
     context "patch preferred" do
       it "single gem updates dependent gem to minor" do
-        bundle! "update --patch foo"
+        bundle "update --patch foo"
 
         expect(the_bundle).to include_gems "foo 1.4.5", "bar 2.1.1", "qux 1.0.0"
       end
 
       it "update all" do
-        bundle! "update --patch", :all => true
+        bundle "update --patch", :all => true
 
         expect(the_bundle).to include_gems "foo 1.4.5", "bar 2.1.1", "qux 1.0.1"
       end
@@ -902,7 +1449,7 @@ RSpec.describe "bundle update conservati
 
     context "minor preferred" do
       it "single gem updates dependent gem to major" do
-        bundle! "update --minor foo"
+        bundle "update --minor foo"
 
         expect(the_bundle).to include_gems "foo 1.5.1", "bar 3.0.0", "qux 1.0.0"
       end
@@ -910,13 +1457,13 @@ RSpec.describe "bundle update conservati
 
     context "strict" do
       it "patch preferred" do
-        bundle! "update --patch foo bar --strict"
+        bundle "update --patch foo bar --strict"
 
         expect(the_bundle).to include_gems "foo 1.4.4", "bar 2.0.5", "qux 1.0.0"
       end
 
       it "minor preferred" do
-        bundle! "update --minor --strict", :all => true
+        bundle "update --minor --strict", :all => true
 
         expect(the_bundle).to include_gems "foo 1.5.0", "bar 2.1.1", "qux 1.1.0"
       end
@@ -948,9 +1495,9 @@ RSpec.describe "bundle update conservati
         gem 'shared_owner_b'
       G
 
-      lockfile <<-L
+      lockfile <<~L
         GEM
-          remote: #{file_uri_for(gem_repo4)}
+          remote: #{file_uri_for(gem_repo4)}/
           specs:
             isolated_dep (2.0.1)
             isolated_owner (1.0.1)
@@ -962,15 +1509,15 @@ RSpec.describe "bundle update conservati
               shared_dep (~> 5.0)
 
         PLATFORMS
-          ruby
+          #{specific_local_platform}
 
         DEPENDENCIES
+          isolated_owner
           shared_owner_a
           shared_owner_b
-          isolated_owner
 
         BUNDLED WITH
-           1.13.0
+           #{Bundler::VERSION}
       L
     end
 
@@ -989,7 +1536,42 @@ RSpec.describe "bundle update conservati
     it "should not eagerly unlock with --conservative" do
       bundle "update --conservative shared_owner_a isolated_owner"
 
-      expect(the_bundle).to include_gems "isolated_owner 1.0.2", "isolated_dep 2.0.2", "shared_dep 5.0.1", "shared_owner_a 3.0.2", "shared_owner_b 4.0.1"
+      expect(the_bundle).to include_gems "isolated_owner 1.0.2", "isolated_dep 2.0.1", "shared_dep 5.0.1", "shared_owner_a 3.0.2", "shared_owner_b 4.0.1"
+    end
+
+    it "should only update direct dependencies when fully updating with --conservative" do
+      bundle "update --conservative"
+
+      expect(the_bundle).to include_gems "isolated_owner 1.0.2", "isolated_dep 2.0.1", "shared_dep 5.0.1", "shared_owner_a 3.0.2", "shared_owner_b 4.0.2"
+    end
+
+    it "should only change direct dependencies when updating the lockfile with --conservative" do
+      bundle "lock --update --conservative"
+
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            isolated_dep (2.0.1)
+            isolated_owner (1.0.2)
+              isolated_dep (~> 2.0)
+            shared_dep (5.0.1)
+            shared_owner_a (3.0.2)
+              shared_dep (~> 5.0)
+            shared_owner_b (4.0.2)
+              shared_dep (~> 5.0)
+
+        PLATFORMS
+          #{specific_local_platform}
+
+        DEPENDENCIES
+          isolated_owner
+          shared_owner_a
+          shared_owner_b
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
     end
 
     it "should match bundle install conservative update behavior when not eagerly unlocking" do
@@ -1009,11 +1591,11 @@ RSpec.describe "bundle update conservati
 
   context "error handling" do
     before do
-      gemfile ""
+      gemfile "source \"#{file_uri_for(gem_repo1)}\""
     end
 
     it "raises if too many flags are provided" do
-      bundle "update --patch --minor", :all => true
+      bundle "update --patch --minor", :all => true, :raise_on_error => false
 
       expect(err).to eq "Provide only one of the following options: minor, patch"
     end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/version_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/version_spec.rb
@@ -11,36 +11,36 @@ RSpec.describe "bundle version" do
 
   context "with -v" do
     it "outputs the version", :bundler => "< 3" do
-      bundle! "-v"
+      bundle "-v"
       expect(out).to eq("Bundler version #{Bundler::VERSION}")
     end
 
     it "outputs the version", :bundler => "3" do
-      bundle! "-v"
+      bundle "-v"
       expect(out).to eq(Bundler::VERSION)
     end
   end
 
   context "with --version" do
     it "outputs the version", :bundler => "< 3" do
-      bundle! "--version"
+      bundle "--version"
       expect(out).to eq("Bundler version #{Bundler::VERSION}")
     end
 
     it "outputs the version", :bundler => "3" do
-      bundle! "--version"
+      bundle "--version"
       expect(out).to eq(Bundler::VERSION)
     end
   end
 
   context "with version" do
     it "outputs the version with build metadata", :bundler => "< 3" do
-      bundle! "version"
+      bundle "version"
       expect(out).to match(/\ABundler version #{Regexp.escape(Bundler::VERSION)} \(\d{4}-\d{2}-\d{2} commit #{COMMIT_HASH}\)\z/)
     end
 
     it "outputs the version with build metadata", :bundler => "3" do
-      bundle! "version"
+      bundle "version"
       expect(out).to match(/\A#{Regexp.escape(Bundler::VERSION)} \(\d{4}-\d{2}-\d{2} commit #{COMMIT_HASH}\)\z/)
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/commands/viz_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/commands/viz_spec.rb
@@ -1,13 +1,10 @@
 # frozen_string_literal: true
 
 RSpec.describe "bundle viz", :bundler => "< 3", :if => Bundler.which("dot") do
-  let(:ruby_graphviz) do
-    graphviz_glob = base_system_gems.join("cache/ruby-graphviz*")
-    Pathname.glob(graphviz_glob).first
-  end
-
   before do
-    system_gems ruby_graphviz
+    graphviz_version = RUBY_VERSION >= "2.4" ? "1.2.5" : "1.2.4"
+
+    realworld_system_gems "ruby-graphviz --version #{graphviz_version}"
   end
 
   it "graphs gems from the Gemfile" do
@@ -17,10 +14,10 @@ RSpec.describe "bundle viz", :bundler =>
       gem "rack-obama"
     G
 
-    bundle! "viz"
+    bundle "viz"
     expect(out).to include("gem_graph.png")
 
-    bundle! "viz", :format => "debug"
+    bundle "viz", :format => "debug"
     expect(out).to eq(strip_whitespace(<<-DOT).strip)
       digraph Gemfile {
       concentrate = "true";
@@ -51,10 +48,10 @@ RSpec.describe "bundle viz", :bundler =>
       gem "rack-obama"
     G
 
-    bundle! "viz"
+    bundle "viz"
     expect(out).to include("gem_graph.png")
 
-    bundle! "viz", :format => :debug, :version => true
+    bundle "viz", :format => :debug, :version => true
     expect(out).to eq(strip_whitespace(<<-EOS).strip)
       digraph Gemfile {
       concentrate = "true";
@@ -82,7 +79,7 @@ RSpec.describe "bundle viz", :bundler =>
         end
       end
 
-      system_gems ruby_graphviz, "graphviz-999", :gem_repo => gem_repo4
+      system_gems "graphviz-999", :gem_repo => gem_repo4
     end
 
     it "loads the correct ruby-graphviz gem" do
@@ -92,7 +89,7 @@ RSpec.describe "bundle viz", :bundler =>
         gem "rack-obama"
       G
 
-      bundle! "viz", :format => "debug"
+      bundle "viz", :format => "debug"
       expect(out).to eq(strip_whitespace(<<-DOT).strip)
         digraph Gemfile {
         concentrate = "true";
@@ -124,7 +121,7 @@ RSpec.describe "bundle viz", :bundler =>
         end
       G
 
-      bundle! "viz --without=rails"
+      bundle "viz --without=rails"
       expect(out).to include("gem_graph.png")
     end
 
@@ -142,7 +139,7 @@ RSpec.describe "bundle viz", :bundler =>
         end
       G
 
-      bundle! "viz --without=rails:rack"
+      bundle "viz --without=rails:rack"
       expect(out).to include("gem_graph.png")
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/install/allow_offline_install_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/allow_offline_install_spec.rb
@@ -7,7 +7,7 @@ RSpec.describe "bundle install with :all
 
   context "with no cached data locally" do
     it "still installs" do
-      install_gemfile! <<-G, :artifice => "compact_index"
+      install_gemfile <<-G, :artifice => "compact_index"
         source "http://testgemserver.local"
         gem "rack-obama"
       G
@@ -15,7 +15,7 @@ RSpec.describe "bundle install with :all
     end
 
     it "still fails when the network is down" do
-      install_gemfile <<-G, :artifice => "fail"
+      install_gemfile <<-G, :artifice => "fail", :raise_on_error => false
         source "http://testgemserver.local"
         gem "rack-obama"
       G
@@ -26,10 +26,10 @@ RSpec.describe "bundle install with :all
 
   context "with cached data locally" do
     it "will install from the compact index" do
-      system_gems ["rack-1.0.0"], :path => :bundle_path
+      system_gems ["rack-1.0.0"], :path => default_bundle_path
 
-      bundle! "config set clean false"
-      install_gemfile! <<-G, :artifice => "compact_index"
+      bundle "config set clean false"
+      install_gemfile <<-G, :artifice => "compact_index"
         source "http://testgemserver.local"
         gem "rack-obama"
         gem "rack", "< 1.0"
@@ -42,7 +42,7 @@ RSpec.describe "bundle install with :all
         gem "rack-obama"
       G
 
-      bundle! :update, :artifice => "fail", :all => true
+      bundle :update, :artifice => "fail", :all => true
       expect(last_command.stdboth).to include "Using the cached data for the new index because of a network error"
 
       expect(the_bundle).to include_gems("rack-obama 1.0", "rack 1.0.0")
@@ -70,18 +70,22 @@ RSpec.describe "bundle install with :all
     end
 
     it "will install from a cached git repo" do
+      skip "doesn't print errors" if Gem.win_platform?
+
       git = build_git "a", "1.0.0", :path => lib_path("a")
       update_git("a", :path => git.path, :branch => "new_branch")
-      install_gemfile! <<-G
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "a", :git => #{git.path.to_s.dump}
       G
 
-      break_git_remote_ops! { bundle! :update, :all => true }
+      break_git_remote_ops! { bundle :update, :all => true }
       expect(err).to include("Using cached git data because of network errors")
       expect(the_bundle).to be_locked
 
       break_git_remote_ops! do
-        install_gemfile! <<-G
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           gem "a", :git => #{git.path.to_s.dump}, :branch => "new_branch"
         G
       end
--- ruby2.7-2.7.6.orig/spec/bundler/install/binstubs_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/binstubs_spec.rb
@@ -35,7 +35,7 @@ RSpec.describe "bundle install" do
     end
 
     it "warns about the situation" do
-      bundle! "exec rackup"
+      bundle "exec rackup"
 
       expect(last_command.stderr).to include(
         "The `rackup` executable in the `fake` gem is being loaded, but it's also present in other gems (rack).\n" \
--- ruby2.7-2.7.6.orig/spec/bundler/install/bundler_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/bundler_spec.rb
@@ -21,18 +21,58 @@ RSpec.describe "bundle install" do
       expect(the_bundle).to include_gems "bundler #{Bundler::VERSION}"
     end
 
-    it "are not added if not already present" do
+    it "are forced to the current bundler version even if not already present" do
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
-      expect(the_bundle).not_to include_gems "bundler #{Bundler::VERSION}"
+      expect(the_bundle).to include_gems "bundler #{Bundler::VERSION}"
     end
 
-    it "causes a conflict if explicitly requesting a different version" do
-      bundle "config set force_ruby_platform true"
+    it "causes a conflict if explicitly requesting a different version of bundler" do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo2)}"
+        gem "rails", "3.0"
+        gem "bundler", "0.9.1"
+      G
 
-      install_gemfile <<-G
+      nice_error = <<-E.strip.gsub(/^ {8}/, "")
+        Bundler could not find compatible versions for gem "bundler":
+          In Gemfile:
+            bundler (= 0.9.1)
+
+          Current Bundler version:
+            bundler (#{Bundler::VERSION})
+
+        Your bundle requires a different version of Bundler than the one you're running.
+        Install the necessary version with `gem install bundler:0.9.1` and rerun bundler using `bundle _0.9.1_ install`
+        E
+      expect(err).to include(nice_error)
+    end
+
+    it "causes a conflict if explicitly requesting a non matching requirement on bundler" do
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo2)}"
+        gem "rails", "3.0"
+        gem "bundler", "~> 0.8"
+      G
+
+      nice_error = <<-E.strip.gsub(/^ {8}/, "")
+        Bundler could not find compatible versions for gem "bundler":
+          In Gemfile:
+            bundler (~> 0.8)
+
+          Current Bundler version:
+            bundler (#{Bundler::VERSION})
+
+        Your bundle requires a different version of Bundler than the one you're running.
+        Install the necessary version with `gem install bundler:0.9.1` and rerun bundler using `bundle _0.9.1_ install`
+        E
+      expect(err).to include(nice_error)
+    end
+
+    it "causes a conflict if explicitly requesting a version of bundler that doesn't exist" do
+      install_gemfile <<-G, :raise_on_error => false
         source "#{file_uri_for(gem_repo2)}"
         gem "rails", "3.0"
         gem "bundler", "0.9.2"
@@ -45,15 +85,19 @@ RSpec.describe "bundle install" do
 
           Current Bundler version:
             bundler (#{Bundler::VERSION})
-        This Gemfile requires a different version of Bundler.
-        Perhaps you need to update Bundler by running `gem install bundler`?
 
-        Could not find gem 'bundler (= 0.9.2)' in any
+        Your bundle requires a different version of Bundler than the one you're running, and that version could not be found.
         E
       expect(err).to include(nice_error)
     end
 
     it "works for gems with multiple versions in its dependencies" do
+      build_repo2 do
+        build_gem "multiple_versioned_deps" do |s|
+          s.add_dependency "weakling", ">= 0.0.1", "< 0.1"
+        end
+      end
+
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
 
@@ -93,10 +137,16 @@ RSpec.describe "bundle install" do
     it "causes a conflict if child dependencies conflict" do
       bundle "config set force_ruby_platform true"
 
-      install_gemfile <<-G
+      update_repo2 do
+        build_gem "rails_pinned_to_old_activesupport" do |s|
+          s.add_dependency "activesupport", "= 1.2.3"
+        end
+      end
+
+      install_gemfile <<-G, :raise_on_error => false
         source "#{file_uri_for(gem_repo2)}"
         gem "activemerchant"
-        gem "rails_fail"
+        gem "rails_pinned_to_old_activesupport"
       G
 
       nice_error = <<-E.strip.gsub(/^ {8}/, "")
@@ -105,7 +155,7 @@ RSpec.describe "bundle install" do
             activemerchant was resolved to 1.0, which depends on
               activesupport (>= 2.0.0)
 
-            rails_fail was resolved to 1.0, which depends on
+            rails_pinned_to_old_activesupport was resolved to 1.0, which depends on
               activesupport (= 1.2.3)
       E
       expect(err).to include(nice_error)
@@ -114,9 +164,15 @@ RSpec.describe "bundle install" do
     it "causes a conflict if a child dependency conflicts with the Gemfile" do
       bundle "config set force_ruby_platform true"
 
-      install_gemfile <<-G
+      update_repo2 do
+        build_gem "rails_pinned_to_old_activesupport" do |s|
+          s.add_dependency "activesupport", "= 1.2.3"
+        end
+      end
+
+      install_gemfile <<-G, :raise_on_error => false
         source "#{file_uri_for(gem_repo2)}"
-        gem "rails_fail"
+        gem "rails_pinned_to_old_activesupport"
         gem "activesupport", "2.3.5"
       G
 
@@ -125,58 +181,59 @@ RSpec.describe "bundle install" do
           In Gemfile:
             activesupport (= 2.3.5)
 
-            rails_fail was resolved to 1.0, which depends on
+            rails_pinned_to_old_activesupport was resolved to 1.0, which depends on
               activesupport (= 1.2.3)
       E
       expect(err).to include(nice_error)
     end
 
-    it "can install dependencies with newer bundler version with system gems" do
-      bundle! "config set path.system true"
-      install_gemfile! <<-G
+    it "does not cause a conflict if new dependencies in the Gemfile require older dependencies than the lockfile" do
+      update_repo2 do
+        build_gem "rails_pinned_to_old_activesupport" do |s|
+          s.add_dependency "activesupport", "= 1.2.3"
+        end
+      end
+
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
-        gem "rails", "3.0"
+        gem 'rails', "2.3.2"
       G
 
-      simulate_bundler_version "99999999.99.1"
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "rails_pinned_to_old_activesupport"
+      G
 
-      bundle! "check"
-      expect(out).to include("The Gemfile's dependencies are satisfied")
+      expect(out).to include("Installing activesupport 1.2.3 (was 2.3.2)")
+      expect(err).to be_empty
     end
 
-    it "can install dependencies with newer bundler version with a local path" do
-      bundle! "config set path .bundle"
-      install_gemfile! <<-G
+    it "can install dependencies with newer bundler version with system gems" do
+      bundle "config set path.system true"
+
+      system_gems "bundler-99999999.99.1"
+
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
         gem "rails", "3.0"
       G
 
-      simulate_bundler_version "99999999.99.1"
-
-      bundle! "check"
+      bundle "check"
       expect(out).to include("The Gemfile's dependencies are satisfied")
     end
 
-    context "with allow_bundler_dependency_conflicts set" do
-      before { bundle! "config set allow_bundler_dependency_conflicts true" }
-
-      it "are forced to the current bundler version with warnings when no compatible version is found" do
-        build_repo4 do
-          build_gem "requires_nonexistant_bundler" do |s|
-            s.add_runtime_dependency "bundler", "99.99.99.99"
-          end
-        end
+    it "can install dependencies with newer bundler version with a local path" do
+      bundle "config set path .bundle"
 
-        install_gemfile! <<-G
-          source "#{file_uri_for(gem_repo4)}"
-          gem "requires_nonexistant_bundler"
-        G
+      system_gems "bundler-99999999.99.1"
 
-        expect(err).to include "requires_nonexistant_bundler (1.0) has dependency bundler (= 99.99.99.99), " \
-                               "which is unsatisfied by the current bundler version #{Bundler::VERSION}, so the dependency is being ignored"
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "rails", "3.0"
+      G
 
-        expect(the_bundle).to include_gems "bundler #{Bundler::VERSION}", "requires_nonexistant_bundler 1.0"
-      end
+      bundle "check"
+      expect(out).to include("The Gemfile's dependencies are satisfied")
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/deploy_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/deploy_spec.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
 
-RSpec.describe "install with --deployment or --frozen" do
+RSpec.describe "install in deployment or frozen mode" do
   before do
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
@@ -10,76 +10,94 @@ RSpec.describe "install with --deploymen
 
   context "with CLI flags", :bundler => "< 3" do
     it "fails without a lockfile and says that --deployment requires a lock" do
-      bundle "install --deployment"
+      bundle "install --deployment", :raise_on_error => false
       expect(err).to include("The --deployment flag requires a Gemfile.lock")
     end
 
     it "fails without a lockfile and says that --frozen requires a lock" do
-      bundle "install --frozen"
+      bundle "install --frozen", :raise_on_error => false
       expect(err).to include("The --frozen flag requires a Gemfile.lock")
     end
 
     it "disallows --deployment --system" do
-      bundle "install --deployment --system"
+      bundle "install --deployment --system", :raise_on_error => false
       expect(err).to include("You have specified both --deployment")
       expect(err).to include("Please choose only one option")
-      expect(exitstatus).to eq(15) if exitstatus
+      expect(exitstatus).to eq(15)
     end
 
     it "disallows --deployment --path --system" do
-      bundle "install --deployment --path . --system"
+      bundle "install --deployment --path . --system", :raise_on_error => false
       expect(err).to include("You have specified both --path")
       expect(err).to include("as well as --system")
       expect(err).to include("Please choose only one option")
-      expect(exitstatus).to eq(15) if exitstatus
+      expect(exitstatus).to eq(15)
     end
 
     it "doesn't mess up a subsequent `bundle install` after you try to deploy without a lock" do
-      bundle "install --deployment"
-      bundle! :install
+      bundle "install --deployment", :raise_on_error => false
+      bundle :install
       expect(the_bundle).to include_gems "rack 1.0"
     end
   end
 
   it "still works if you are not in the app directory and specify --gemfile" do
-    bundle! "install"
-    Dir.chdir tmp do
-      simulate_new_machine
-      bundle! :install,
-        forgotten_command_line_options(:gemfile => "#{tmp}/bundled_app/Gemfile",
-                                       :deployment => true,
-                                       :path => "vendor/bundle")
-    end
+    bundle "install"
+    simulate_new_machine
+    bundle "config set --local deployment true"
+    bundle "config set --local path vendor/bundle"
+    bundle "install --gemfile #{tmp}/bundled_app/Gemfile", :dir => tmp
     expect(the_bundle).to include_gems "rack 1.0"
   end
 
   it "works if you exclude a group with a git gem" do
     build_git "foo"
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       group :test do
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       end
     G
-    bundle! :install
-    bundle! :install, forgotten_command_line_options(:deployment => true, :without => "test")
+    bundle :install
+    bundle "config set --local deployment true"
+    bundle "config set --local without test"
+    bundle :install
   end
 
   it "works when you bundle exec bundle" do
-    bundle! :install
-    bundle "install --deployment"
-    bundle! "exec bundle check"
+    skip "doesn't find bundle" if Gem.win_platform?
+
+    bundle :install
+    bundle "config set --local deployment true"
+    bundle :install
+    bundle "exec bundle check", :env => { "PATH" => path }
   end
 
   it "works when using path gems from the same path and the version is specified" do
     build_lib "foo", :path => lib_path("nested/foo")
     build_lib "bar", :path => lib_path("nested/bar")
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", "1.0", :path => "#{lib_path("nested")}"
       gem "bar", :path => "#{lib_path("nested")}"
     G
 
-    bundle! :install
-    bundle! :install, forgotten_command_line_options(:deployment => true)
+    bundle :install
+    bundle "config set --local deployment true"
+    bundle :install
+  end
+
+  it "works when path gems are specified twice" do
+    build_lib "foo", :path => lib_path("nested/foo")
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "foo", :path => "#{lib_path("nested/foo")}"
+      gem "foo", :path => "#{lib_path("nested/foo")}"
+    G
+
+    bundle :install
+    bundle "config set --local deployment true"
+    bundle :install
   end
 
   it "works when there are credentials in the source URL" do
@@ -89,66 +107,70 @@ RSpec.describe "install with --deploymen
       gem "rack-obama", ">= 1.0"
     G
 
-    bundle! :install, forgotten_command_line_options(:deployment => true).merge(:artifice => "endpoint_strict_basic_authentication")
+    bundle "config set --local deployment true"
+    bundle :install, :artifice => "endpoint_strict_basic_authentication"
   end
 
   it "works with sources given by a block" do
-    install_gemfile! <<-G
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       source "#{file_uri_for(gem_repo1)}" do
         gem "rack"
       end
     G
 
-    bundle! :install, forgotten_command_line_options(:deployment => true)
+    bundle "config set --local deployment true"
+    bundle :install
 
     expect(the_bundle).to include_gems "rack 1.0"
   end
 
   context "when replacing a host with the same host with credentials" do
     before do
-      bundle! "install", forgotten_command_line_options(:path => "vendor/bundle")
+      bundle "config set --local path vendor/bundle"
+      bundle "install"
       gemfile <<-G
-      source "http://user_name:password@localgemserver.test/"
-      gem "rack"
+        source "http://user_name:password@localgemserver.test/"
+        gem "rack"
       G
 
       lockfile <<-G
-      GEM
-        remote: http://localgemserver.test/
-        specs:
-          rack (1.0.0)
+        GEM
+          remote: http://localgemserver.test/
+          specs:
+            rack (1.0.0)
 
-      PLATFORMS
-        #{local}
+        PLATFORMS
+          #{local}
 
-      DEPENDENCIES
-        rack
+        DEPENDENCIES
+          rack
       G
 
-      bundle! "config set --local deployment true"
+      bundle "config set --local deployment true"
     end
 
     it "prevents the replace by default" do
-      bundle :install
+      bundle :install, :raise_on_error => false
 
       expect(err).to match(/The list of sources changed/)
     end
 
     context "when allow_deployment_source_credential_changes is true" do
-      before { bundle! "config set allow_deployment_source_credential_changes true" }
+      before { bundle "config set allow_deployment_source_credential_changes true" }
 
       it "allows the replace" do
-        bundle! :install
+        bundle :install
 
         expect(out).to match(/Bundle complete!/)
       end
     end
 
     context "when allow_deployment_source_credential_changes is false" do
-      before { bundle! "config set allow_deployment_source_credential_changes false" }
+      before { bundle "config set allow_deployment_source_credential_changes false" }
 
       it "prevents the replace" do
-        bundle :install
+        bundle :install, :raise_on_error => false
 
         expect(err).to match(/The list of sources changed/)
       end
@@ -168,7 +190,7 @@ RSpec.describe "install with --deploymen
       before { ENV["BUNDLE_ALLOW_DEPLOYMENT_SOURCE_CREDENTIAL_CHANGES"] = "false" }
 
       it "prevents the replace" do
-        bundle :install
+        bundle :install, :raise_on_error => false
 
         expect(err).to match(/The list of sources changed/)
       end
@@ -177,29 +199,29 @@ RSpec.describe "install with --deploymen
 
   describe "with an existing lockfile" do
     before do
-      bundle! "install"
+      bundle "install"
     end
 
     it "installs gems by default to vendor/bundle", :bundler => "< 3" do
-      bundle! "install --deployment"
+      bundle "install --deployment"
       expect(out).to include("vendor/bundle")
     end
 
     it "installs gems to custom path if specified", :bundler => "< 3" do
-      bundle! "install --path vendor/bundle2 --deployment"
+      bundle "install --path vendor/bundle2 --deployment"
       expect(out).to include("vendor/bundle2")
     end
 
     it "works with the --deployment flag if you didn't change anything", :bundler => "< 3" do
-      bundle! "install --deployment"
+      bundle "install --deployment"
     end
 
     it "works with the --frozen flag if you didn't change anything", :bundler => "< 3" do
-      bundle! "install --frozen"
+      bundle "install --frozen"
     end
 
     it "works with BUNDLE_FROZEN if you didn't change anything" do
-      bundle! :install, :env => { "BUNDLE_FROZEN" => "true" }
+      bundle :install, :env => { "BUNDLE_FROZEN" => "true" }
     end
 
     it "explodes with the --deployment flag if you make a change and don't check in the lockfile" do
@@ -209,7 +231,8 @@ RSpec.describe "install with --deploymen
         gem "rack-obama"
       G
 
-      bundle :install, forgotten_command_line_options(:deployment => true)
+      bundle "config set --local deployment true"
+      bundle :install, :raise_on_error => false
       expect(err).to include("deployment mode")
       expect(err).to include("You have added to the Gemfile")
       expect(err).to include("* rack-obama")
@@ -219,7 +242,7 @@ RSpec.describe "install with --deploymen
 
     it "works if a path gem is missing but is in a without group" do
       build_lib "path_gem"
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rake"
         gem "path_gem", :path => "#{lib_path("path_gem-1.0")}", :group => :development
@@ -227,14 +250,28 @@ RSpec.describe "install with --deploymen
       expect(the_bundle).to include_gems "path_gem 1.0"
       FileUtils.rm_r lib_path("path_gem-1.0")
 
-      bundle! :install, forgotten_command_line_options(:path => ".bundle", :without => "development", :deployment => true).merge(:env => { "DEBUG" => "1" })
-      run! "puts :WIN"
+      bundle "config set --local path .bundle"
+      bundle "config set --local without development"
+      bundle "config set --local deployment true"
+      bundle :install, :env => { "DEBUG" => "1" }
+      run "puts :WIN"
       expect(out).to eq("WIN")
     end
 
+    it "works if a gem is missing, but it's on a different platform, and the Gemfile has no global source", :bundler => "< 3" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}" do
+          gem "rake", platform: :#{not_local_tag}
+        end
+      G
+
+      bundle :install, :env => { "BUNDLE_FROZEN" => "true" }
+      expect(last_command).to be_success
+    end
+
     it "explodes if a path gem is missing" do
       build_lib "path_gem"
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rake"
         gem "path_gem", :path => "#{lib_path("path_gem-1.0")}", :group => :development
@@ -242,7 +279,9 @@ RSpec.describe "install with --deploymen
       expect(the_bundle).to include_gems "path_gem 1.0"
       FileUtils.rm_r lib_path("path_gem-1.0")
 
-      bundle :install, forgotten_command_line_options(:path => ".bundle", :deployment => true)
+      bundle "config set --local path .bundle"
+      bundle "config set --local deployment true"
+      bundle :install, :raise_on_error => false
       expect(err).to include("The path `#{lib_path("path_gem-1.0")}` does not exist.")
     end
 
@@ -254,7 +293,7 @@ RSpec.describe "install with --deploymen
       G
 
       ENV["BUNDLE_FROZEN"] = "1"
-      bundle "install"
+      bundle "install", :raise_on_error => false
       expect(err).to include("deployment mode")
       expect(err).to include("You have added to the Gemfile")
       expect(err).to include("* rack-obama")
@@ -270,7 +309,7 @@ RSpec.describe "install with --deploymen
       G
 
       ENV["BUNDLE_DEPLOYMENT"] = "true"
-      bundle "install"
+      bundle "install", :raise_on_error => false
       expect(err).to include("deployment mode")
       expect(err).to include("You have added to the Gemfile")
       expect(err).to include("* rack-obama")
@@ -278,7 +317,7 @@ RSpec.describe "install with --deploymen
       expect(err).not_to include("You have changed in the Gemfile")
     end
 
-    it "installs gems by default to vendor/bundle when `--deployment` is set via an environment variable", :bundler => "< 3" do
+    it "installs gems by default to vendor/bundle when deployment mode is set via an environment variable", :bundler => "< 3" do
       ENV["BUNDLE_DEPLOYMENT"] = "true"
       bundle "install"
       expect(out).to include("vendor/bundle")
@@ -312,7 +351,8 @@ RSpec.describe "install with --deploymen
         gem "activesupport"
       G
 
-      bundle :install, forgotten_command_line_options(:deployment => true)
+      bundle "config set --local deployment true"
+      bundle :install, :raise_on_error => false
       expect(err).to include("deployment mode")
       expect(err).to include("You have added to the Gemfile:\n* activesupport\n\n")
       expect(err).to include("You have deleted from the Gemfile:\n* rack")
@@ -325,13 +365,14 @@ RSpec.describe "install with --deploymen
         gem "rack", :git => "git://hubz.com"
       G
 
-      bundle :install, forgotten_command_line_options(:deployment => true)
+      bundle "config set --local deployment true"
+      bundle :install, :raise_on_error => false
       expect(err).to include("deployment mode")
-      expect(err).to include("You have added to the Gemfile:\n* source: git://hubz.com (at master)")
-      expect(err).not_to include("You have changed in the Gemfile")
+      expect(err).not_to include("You have added to the Gemfile")
+      expect(err).to include("You have changed in the Gemfile:\n* rack from `no specified source` to `git://hubz.com`")
     end
 
-    it "explodes if you unpin a source" do
+    it "explodes if you change a source" do
       build_git "rack"
 
       install_gemfile <<-G
@@ -344,14 +385,15 @@ RSpec.describe "install with --deploymen
         gem "rack"
       G
 
-      bundle :install, forgotten_command_line_options(:deployment => true)
+      bundle "config set --local deployment true"
+      bundle :install, :raise_on_error => false
       expect(err).to include("deployment mode")
-      expect(err).to include("You have deleted from the Gemfile:\n* source: #{lib_path("rack-1.0")} (at master@#{revision_for(lib_path("rack-1.0"))[0..6]}")
+      expect(err).not_to include("You have deleted from the Gemfile")
       expect(err).not_to include("You have added to the Gemfile")
-      expect(err).not_to include("You have changed in the Gemfile")
+      expect(err).to include("You have changed in the Gemfile:\n* rack from `#{lib_path("rack-1.0")}` to `no specified source`")
     end
 
-    it "explodes if you unpin a source, leaving it pinned somewhere else" do
+    it "explodes if you change a source" do
       build_lib "foo", :path => lib_path("rack/foo")
       build_git "rack", :path => lib_path("rack")
 
@@ -367,17 +409,18 @@ RSpec.describe "install with --deploymen
         gem "foo", :git => "#{lib_path("rack")}"
       G
 
-      bundle :install, forgotten_command_line_options(:deployment => true)
+      bundle "config set --local deployment true"
+      bundle :install, :raise_on_error => false
       expect(err).to include("deployment mode")
-      expect(err).to include("You have changed in the Gemfile:\n* rack from `no specified source` to `#{lib_path("rack")} (at master@#{revision_for(lib_path("rack"))[0..6]})`")
+      expect(err).to include("You have changed in the Gemfile:\n* rack from `#{lib_path("rack")}` to `no specified source`")
       expect(err).not_to include("You have added to the Gemfile")
       expect(err).not_to include("You have deleted from the Gemfile")
     end
 
     it "remembers that the bundle is frozen at runtime" do
-      bundle! :lock
+      bundle :lock
 
-      bundle! "config set --local deployment true"
+      bundle "config set --local deployment true"
 
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
@@ -385,7 +428,7 @@ RSpec.describe "install with --deploymen
         gem "rack-obama"
       G
 
-      expect(the_bundle).not_to include_gems "rack 1.0.0"
+      run "require 'rack'", :raise_on_error => false
       expect(err).to include strip_whitespace(<<-E).strip
 The dependencies in your gemfile changed
 
@@ -402,23 +445,24 @@ You have deleted from the Gemfile:
   context "with path in Gemfile and packed" do
     it "works fine after bundle package and bundle install --local" do
       build_lib "foo", :path => lib_path("foo")
-      install_gemfile! <<-G
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :path => "#{lib_path("foo")}"
       G
 
-      bundle! :install
+      bundle :install
       expect(the_bundle).to include_gems "foo 1.0"
 
       bundle "config set cache_all true"
-      bundle! :cache
+      bundle :cache
       expect(bundled_app("vendor/cache/foo")).to be_directory
 
-      bundle! "install --local"
+      bundle "install --local"
       expect(out).to include("Updating files in vendor/cache")
 
       simulate_new_machine
-      bundle! "config set --local deployment true"
-      bundle! "install --verbose"
+      bundle "config set --local deployment true"
+      bundle "install --verbose"
       expect(out).not_to include("You are trying to install in deployment mode after changing your Gemfile")
       expect(out).not_to include("You have added to the Gemfile")
       expect(out).not_to include("You have deleted from the Gemfile")
--- ruby2.7-2.7.6.orig/spec/bundler/install/failure_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/failure_spec.rb
@@ -2,7 +2,7 @@
 
 RSpec.describe "bundle install" do
   context "installing a gem fails" do
-    it "prints out why that gem was being installed" do
+    it "prints out why that gem was being installed and the underlying error" do
       build_repo2 do
         build_gem "activesupport", "2.3.2" do |s|
           s.extensions << "Rakefile"
@@ -14,106 +14,13 @@ RSpec.describe "bundle install" do
         end
       end
 
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
         source "#{file_uri_for(gem_repo2)}"
         gem "rails"
       G
+      expect(err).to start_with("Gem::Ext::BuildError: ERROR: Failed to build gem native extension.")
       expect(err).to end_with(<<-M.strip)
 An error occurred while installing activesupport (2.3.2), and Bundler cannot continue.
-Make sure that `gem install activesupport -v '2.3.2' --source '#{file_uri_for(gem_repo2)}/'` succeeds before bundling.
-
-In Gemfile:
-  rails was resolved to 2.3.2, which depends on
-    actionmailer was resolved to 2.3.2, which depends on
-      activesupport
-                     M
-    end
-
-    context "when installing a git gem" do
-      it "does not tell the user to run 'gem install'" do
-        build_git "activesupport", "2.3.2", :path => lib_path("activesupport") do |s|
-          s.extensions << "Rakefile"
-          s.write "Rakefile", <<-RUBY
-            task :default do
-              abort "make installing activesupport-2.3.2 fail"
-            end
-          RUBY
-        end
-
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rails"
-          gem "activesupport", :git => "#{lib_path("activesupport")}"
-        G
-
-        expect(err).to end_with(<<-M.strip)
-An error occurred while installing activesupport (2.3.2), and Bundler cannot continue.
-
-In Gemfile:
-  rails was resolved to 2.3.2, which depends on
-    actionmailer was resolved to 2.3.2, which depends on
-      activesupport
-                     M
-      end
-    end
-
-    context "when installing a gem using a git block" do
-      it "does not tell the user to run 'gem install'" do
-        build_git "activesupport", "2.3.2", :path => lib_path("activesupport") do |s|
-          s.extensions << "Rakefile"
-          s.write "Rakefile", <<-RUBY
-            task :default do
-              abort "make installing activesupport-2.3.2 fail"
-            end
-          RUBY
-        end
-
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rails"
-
-          git "#{lib_path("activesupport")}" do
-            gem "activesupport"
-          end
-        G
-
-        expect(err).to end_with(<<-M.strip)
-An error occurred while installing activesupport (2.3.2), and Bundler cannot continue.
-
-
-In Gemfile:
-  rails was resolved to 2.3.2, which depends on
-    actionmailer was resolved to 2.3.2, which depends on
-      activesupport
-                     M
-      end
-    end
-
-    it "prints out the hint for the remote source when available" do
-      build_repo2 do
-        build_gem "activesupport", "2.3.2" do |s|
-          s.extensions << "Rakefile"
-          s.write "Rakefile", <<-RUBY
-            task :default do
-              abort "make installing activesupport-2.3.2 fail"
-            end
-          RUBY
-        end
-      end
-
-      build_repo4 do
-        build_gem "a"
-      end
-
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo4)}"
-        source "#{file_uri_for(gem_repo2)}" do
-          gem "rails"
-        end
-      G
-      expect(err).to end_with(<<-M.strip)
-An error occurred while installing activesupport (2.3.2), and Bundler cannot continue.
-Make sure that `gem install activesupport -v '2.3.2' --source '#{file_uri_for(gem_repo2)}/'` succeeds before bundling.
 
 In Gemfile:
   rails was resolved to 2.3.2, which depends on
@@ -132,7 +39,7 @@ In Gemfile:
       end
 
       it "removes the downloaded .gem" do
-        install_gemfile <<-G
+        install_gemfile <<-G, :raise_on_error => false
           source "#{file_uri_for(gem_repo4)}"
           gem "a"
         G
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile/eval_gemfile_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/eval_gemfile_spec.rb
@@ -11,12 +11,14 @@ RSpec.describe "bundle install with gemf
   context "eval-ed Gemfile points to an internal gemspec" do
     before do
       create_file "Gemfile-other", <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gemspec :path => 'gems/gunks'
       G
     end
 
     it "installs the gemspec specified gem" do
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         eval_gemfile 'Gemfile-other'
       G
       expect(out).to include("Resolving dependencies")
@@ -26,28 +28,65 @@ RSpec.describe "bundle install with gemf
     end
   end
 
+  context "eval-ed Gemfile points to an internal gemspec and uses a scoped source that duplicates the main Gemfile global source" do
+    before do
+      build_repo2 do
+        build_gem "rails", "6.1.3.2"
+
+        build_gem "zip-zip", "0.3"
+      end
+
+      create_file bundled_app("gems/Gemfile"), <<-G
+        source "#{file_uri_for(gem_repo2)}"
+
+        gemspec :path => "\#{__dir__}/gunks"
+
+        source "#{file_uri_for(gem_repo2)}" do
+          gem "zip-zip"
+        end
+      G
+    end
+
+    it "installs and finds gems correctly" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+
+        gem "rails"
+
+        eval_gemfile File.join(__dir__, "gems/Gemfile")
+      G
+      expect(out).to include("Resolving dependencies")
+      expect(out).to include("Bundle complete")
+
+      expect(the_bundle).to include_gem "rails 6.1.3.2"
+    end
+  end
+
   context "eval-ed Gemfile has relative-path gems" do
     before do
-      build_lib("a", :path => "gems/a")
-      create_file "nested/Gemfile-nested", <<-G
+      build_lib("a", :path => bundled_app("gems/a"))
+      create_file bundled_app("nested/Gemfile-nested"), <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "a", :path => "../gems/a"
       G
 
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         eval_gemfile "nested/Gemfile-nested"
       G
     end
 
     it "installs the path gem" do
-      bundle! :install
+      bundle :install
       expect(the_bundle).to include_gem("a 1.0")
     end
 
     # Make sure that we are properly comparing path based gems between the
     # parsed lockfile and the evaluated gemfile.
-    it "bundles with --deployment" do
-      bundle! :install
-      bundle! :install, forgotten_command_line_options(:deployment => true)
+    it "bundles with deployment mode configured" do
+      bundle :install
+      bundle "config set --local deployment true"
+      bundle :install
     end
   end
 
@@ -56,6 +95,7 @@ RSpec.describe "bundle install with gemf
 
     it "installs the gemspec specified gem" do
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         eval_gemfile 'other/Gemfile-other'
         gemspec :path => 'gems/gunks'
       G
@@ -74,7 +114,7 @@ RSpec.describe "bundle install with gemf
         source "#{file_uri_for(gem_repo1)}"
         eval_gemfile "other/Gemfile"
       G
-      install_gemfile! "eval_gemfile File.expand_path('Gemfile-alt')"
+      install_gemfile "eval_gemfile File.expand_path('Gemfile-alt')"
 
       expect(the_bundle).to include_gem "rack 1.0.0"
     end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/force_ruby_platform_spec.rb
@@ -0,0 +1,118 @@
+# frozen_string_literal: true
+
+RSpec.describe "bundle install with force_ruby_platform DSL option", :jruby do
+  context "when no transitive deps" do
+    before do
+      build_repo4 do
+        # Build a gem with platform specific versions
+        build_gem("platform_specific") do |s|
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0.0 RUBY'"
+        end
+
+        build_gem("platform_specific") do |s|
+          s.platform = Bundler.local_platform
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0.0 #{Bundler.local_platform}'"
+        end
+
+        # Build the exact same gem with a different name to compare using vs not using the option
+        build_gem("platform_specific_forced") do |s|
+          s.write "lib/platform_specific_forced.rb", "PLATFORM_SPECIFIC_FORCED = '1.0.0 RUBY'"
+        end
+
+        build_gem("platform_specific_forced") do |s|
+          s.platform = Bundler.local_platform
+          s.write "lib/platform_specific_forced.rb", "PLATFORM_SPECIFIC_FORCED = '1.0.0 #{Bundler.local_platform}'"
+        end
+      end
+    end
+
+    it "pulls the pure ruby variant of the given gem" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+
+        gem "platform_specific_forced", :force_ruby_platform => true
+        gem "platform_specific"
+      G
+
+      expect(the_bundle).to include_gems "platform_specific_forced 1.0.0 RUBY"
+      expect(the_bundle).to include_gems "platform_specific 1.0.0 #{Bundler.local_platform}"
+    end
+
+    it "still respects a global `force_ruby_platform` config" do
+      install_gemfile <<-G, :env => { "BUNDLE_FORCE_RUBY_PLATFORM" => "true" }
+        source "#{file_uri_for(gem_repo4)}"
+
+        gem "platform_specific_forced", :force_ruby_platform => true
+        gem "platform_specific"
+      G
+
+      expect(the_bundle).to include_gems "platform_specific_forced 1.0.0 RUBY"
+      expect(the_bundle).to include_gems "platform_specific 1.0.0 RUBY"
+    end
+  end
+
+  context "when also a transitive dependency" do
+    before do
+      build_repo4 do
+        build_gem("depends_on_platform_specific") {|s| s.add_runtime_dependency "platform_specific" }
+
+        build_gem("platform_specific") do |s|
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0.0 RUBY'"
+        end
+
+        build_gem("platform_specific") do |s|
+          s.platform = Bundler.local_platform
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0.0 #{Bundler.local_platform}'"
+        end
+      end
+    end
+
+    it "still pulls the ruby variant" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+
+        gem "depends_on_platform_specific"
+        gem "platform_specific", :force_ruby_platform => true
+      G
+
+      expect(the_bundle).to include_gems "platform_specific 1.0.0 RUBY"
+    end
+  end
+
+  context "with transitive dependencies with platform specific versions" do
+    before do
+      build_repo4 do
+        build_gem("depends_on_platform_specific") do |s|
+          s.add_runtime_dependency "platform_specific"
+          s.write "lib/depends_on_platform_specific.rb", "DEPENDS_ON_PLATFORM_SPECIFIC = '1.0.0 RUBY'"
+        end
+
+        build_gem("depends_on_platform_specific") do |s|
+          s.add_runtime_dependency "platform_specific"
+          s.platform = Bundler.local_platform
+          s.write "lib/depends_on_platform_specific.rb", "DEPENDS_ON_PLATFORM_SPECIFIC = '1.0.0 #{Bundler.local_platform}'"
+        end
+
+        build_gem("platform_specific") do |s|
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0.0 RUBY'"
+        end
+
+        build_gem("platform_specific") do |s|
+          s.platform = Bundler.local_platform
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0.0 #{Bundler.local_platform}'"
+        end
+      end
+    end
+
+    it "ignores ruby variants for the transitive dependencies" do
+      install_gemfile <<-G, :env => { "DEBUG_RESOLVER" => "true" }
+        source "#{file_uri_for(gem_repo4)}"
+
+        gem "depends_on_platform_specific", :force_ruby_platform => true
+      G
+
+      expect(the_bundle).to include_gems "depends_on_platform_specific 1.0.0 RUBY"
+      expect(the_bundle).to include_gems "platform_specific 1.0.0 #{Bundler.local_platform}"
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile/gemspec_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/gemspec_spec.rb
@@ -8,6 +8,26 @@ RSpec.describe "bundle install from an e
     end
   end
 
+  let(:x64_mingw_archs) do
+    if RUBY_PLATFORM == "x64-mingw-ucrt"
+      if Gem.rubygems_version >= Gem::Version.new("3.2.28")
+        ["x64-mingw-ucrt", "x64-mingw32"]
+      else
+        ["x64-mingw32", "x64-unknown"]
+      end
+    else
+      ["x64-mingw32"]
+    end
+  end
+
+  let(:x64_mingw_gems) do
+    x64_mingw_archs.map {|p| "platform_specific (1.0-#{p})" }.join("\n    ")
+  end
+
+  let(:x64_mingw_platforms) do
+    x64_mingw_archs.join("\n  ")
+  end
+
   it "should install runtime and development dependencies" do
     build_lib("foo", :path => tmp.join("foo")) do |s|
       s.write("Gemfile", "source :rubygems\ngemspec")
@@ -61,7 +81,7 @@ RSpec.describe "bundle install from an e
   it "should raise if there are no gemspecs available" do
     build_lib("foo", :path => tmp.join("foo"), :gemspec => false)
 
-    install_gemfile(<<-G)
+    install_gemfile <<-G, :raise_on_error => false
       source "#{file_uri_for(gem_repo2)}"
       gemspec :path => '#{tmp.join("foo")}'
     G
@@ -73,7 +93,7 @@ RSpec.describe "bundle install from an e
       s.write("foo2.gemspec", build_spec("foo", "4.0").first.to_ruby)
     end
 
-    install_gemfile(<<-G)
+    install_gemfile <<-G, :raise_on_error => false
       source "#{file_uri_for(gem_repo2)}"
       gemspec :path => '#{tmp.join("foo")}'
     G
@@ -117,21 +137,20 @@ RSpec.describe "bundle install from an e
     build_lib("foo", :path => tmp.join("foo")) do |s|
       s.write("Gemfile", "source '#{file_uri_for(gem_repo1)}'\ngemspec")
       s.add_dependency "actionpack", "=2.3.2"
-      s.add_development_dependency "rake", "=12.3.2"
+      s.add_development_dependency "rake", "=13.0.1"
     end
 
-    Dir.chdir(tmp.join("foo")) do
-      bundle "install"
-      # This should really be able to rely on $stderr, but, it's not written
-      # right, so we can't. In fact, this is a bug negation test, and so it'll
-      # ghost pass in future, and will only catch a regression if the message
-      # doesn't change. Exit codes should be used correctly (they can be more
-      # than just 0 and 1).
-      output = bundle("install --deployment")
-      expect(output).not_to match(/You have added to the Gemfile/)
-      expect(output).not_to match(/You have deleted from the Gemfile/)
-      expect(output).not_to match(/install in deployment mode after changing/)
-    end
+    bundle "install", :dir => tmp.join("foo")
+    # This should really be able to rely on $stderr, but, it's not written
+    # right, so we can't. In fact, this is a bug negation test, and so it'll
+    # ghost pass in future, and will only catch a regression if the message
+    # doesn't change. Exit codes should be used correctly (they can be more
+    # than just 0 and 1).
+    bundle "config set --local deployment true"
+    output = bundle("install", :dir => tmp.join("foo"))
+    expect(output).not_to match(/You have added to the Gemfile/)
+    expect(output).not_to match(/You have deleted from the Gemfile/)
+    expect(output).not_to match(/install in deployment mode after changing/)
   end
 
   it "should match a lockfile without needing to re-resolve" do
@@ -139,12 +158,12 @@ RSpec.describe "bundle install from an e
       s.add_dependency "rack"
     end
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gemspec :path => '#{tmp.join("foo")}'
     G
 
-    bundle! "install", :verbose => true
+    bundle "install", :verbose => true
 
     message = "Found no changes, using resolution from the lockfile"
     expect(out.scan(message).size).to eq(1)
@@ -158,32 +177,29 @@ RSpec.describe "bundle install from an e
       s.add_development_dependency "thin"
     end
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gemspec :path => '#{tmp.join("foo")}'
     G
 
-    bundle! "install", :verbose => true
+    bundle "install", :verbose => true
 
     message = "Found no changes, using resolution from the lockfile"
     expect(out.scan(message).size).to eq(1)
   end
 
-  it "should match a lockfile on non-ruby platforms with a transitive platform dependency" do
-    simulate_platform java
-    simulate_ruby_engine "jruby"
-
+  it "should match a lockfile on non-ruby platforms with a transitive platform dependency", :jruby_only do
     build_lib("foo", :path => tmp.join("foo")) do |s|
       s.add_dependency "platform_specific"
     end
 
-    system_gems "platform_specific-1.0-java", :path => :bundle_path, :keep_path => true
+    system_gems "platform_specific-1.0-java", :path => default_bundle_path
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       gemspec :path => '#{tmp.join("foo")}'
     G
 
-    bundle! "update --bundler", :verbose => true
+    bundle "update --bundler", :artifice => "compact_index", :verbose => true
     expect(the_bundle).to include_gems "foo 1.0", "platform_specific 1.0 JAVA"
   end
 
@@ -193,7 +209,7 @@ RSpec.describe "bundle install from an e
       s.write "raise 'ahh' unless Dir.pwd == '#{tmp.join("foo")}'"
     end
 
-    install_gemfile <<-G
+    install_gemfile <<-G, :raise_on_error => false
       gemspec :path => '#{tmp.join("foo")}'
     G
     expect(last_command.stdboth).not_to include("ahh")
@@ -201,7 +217,7 @@ RSpec.describe "bundle install from an e
 
   it "allows the gemspec to activate other gems" do
     ENV["BUNDLE_PATH__SYSTEM"] = "true"
-    # see https://github.com/bundler/bundler/issues/5409
+    # see https://github.com/rubygems/bundler/issues/5409
     #
     # issue was caused by rubygems having an unresolved gem during a require,
     # so emulate that
@@ -213,7 +229,8 @@ RSpec.describe "bundle install from an e
       f.write "#{gemspec.strip}.tap { gem 'rack-obama'; require 'rack/obama' }"
     end
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gemspec
     G
 
@@ -251,7 +268,7 @@ RSpec.describe "bundle install from an e
       build_gem "foo", "0.0.1"
     end
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo2)}"
       gem "deps"
       gemspec :path => '#{tmp.join("foo")}', :name => 'foo'
@@ -259,20 +276,21 @@ RSpec.describe "bundle install from an e
 
     expect(the_bundle).to include_gems "foo 1.0.0"
 
-    run! "Gem.finish_resolve; puts 'WIN'"
+    run "Gem.finish_resolve; puts 'WIN'"
     expect(out).to eq("WIN")
   end
 
-  it "works with only_update_to_newer_versions" do
+  it "handles downgrades" do
     build_lib "omg", "2.0", :path => lib_path("omg")
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gemspec :path => "#{lib_path("omg")}"
     G
 
     build_lib "omg", "1.0", :path => lib_path("omg")
 
-    bundle! :install, :env => { "BUNDLE_BUNDLE_ONLY_UPDATE_TO_NEWER_VERSIONS" => "true" }
+    bundle :install
 
     expect(the_bundle).to include_gems "omg 1.0"
   end
@@ -284,7 +302,7 @@ RSpec.describe "bundle install from an e
           s.add_dependency "activesupport", ">= 1"
         end
 
-        install_gemfile! <<-G
+        install_gemfile <<-G
           source "#{file_uri_for(gem_repo1)}"
           gemspec
         G
@@ -295,7 +313,8 @@ RSpec.describe "bundle install from an e
           s.add_dependency "activesupport", ">= 1.0.1"
         end
 
-        bundle :install, forgotten_command_line_options(:deployment => true)
+        bundle "config set --local deployment true"
+        bundle :install, :raise_on_error => false
 
         expect(err).to include("changed")
       end
@@ -329,93 +348,65 @@ RSpec.describe "bundle install from an e
   context "with a lockfile and some missing dependencies" do
     let(:source_uri) { "http://localgemserver.test" }
 
-    context "previously bundled for Ruby" do
-      let(:platform) { "ruby" }
-
-      before do
-        build_lib("foo", :path => tmp.join("foo")) do |s|
-          s.add_dependency "rack", "=1.0.0"
-        end
-
-        gemfile <<-G
-          source "#{source_uri}"
-          gemspec :path => "../foo"
-        G
-
-        lockfile <<-L
-          PATH
-            remote: ../foo
-            specs:
-              foo (1.0)
-                rack (= 1.0.0)
-
-          GEM
-            remote: #{source_uri}
-            specs:
-              rack (1.0.0)
-
-          PLATFORMS
-            #{generic_local_platform}
-
-          DEPENDENCIES
-            foo!
-
-          BUNDLED WITH
-             #{Bundler::VERSION}
-        L
+    before do
+      build_lib("foo", :path => tmp.join("foo")) do |s|
+        s.add_dependency "rack", "=1.0.0"
       end
 
-      context "using JRuby with explicit platform" do
-        let(:platform) { "java" }
+      gemfile <<-G
+        source "#{source_uri}"
+        gemspec :path => "../foo"
+      G
 
-        before do
-          create_file(
-            tmp.join("foo", "foo-#{platform}.gemspec"),
-            build_spec("foo", "1.0", platform) do
-              dep "rack", "=1.0.0"
-              @spec.authors = "authors"
-              @spec.summary = "summary"
-            end.first.to_ruby
-          )
-        end
+      lockfile <<-L
+        PATH
+          remote: ../foo
+          specs:
+            foo (1.0)
+              rack (= 1.0.0)
+
+        GEM
+          remote: #{source_uri}
+          specs:
+            rack (1.0.0)
+
+        PLATFORMS
+          #{generic_local_platform}
+
+        DEPENDENCIES
+          foo!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
 
-        it "should install" do
-          simulate_ruby_engine "jruby" do
-            simulate_platform "java" do
-              results = bundle "install", :artifice => "endpoint"
-              expect(results).to include("Installing rack 1.0.0")
-              expect(the_bundle).to include_gems "rack 1.0.0"
-            end
-          end
-        end
+    context "using JRuby with explicit platform", :jruby_only do
+      before do
+        create_file(
+          tmp.join("foo", "foo-java.gemspec"),
+          build_spec("foo", "1.0", "java") do
+            dep "rack", "=1.0.0"
+            @spec.authors = "authors"
+            @spec.summary = "summary"
+          end.first.to_ruby
+        )
       end
 
-      context "using JRuby" do
-        let(:platform) { "java" }
-
-        it "should install" do
-          simulate_ruby_engine "jruby" do
-            simulate_platform "java" do
-              results = bundle "install", :artifice => "endpoint"
-              expect(results).to include("Installing rack 1.0.0")
-              expect(the_bundle).to include_gems "rack 1.0.0"
-            end
-          end
-        end
+      it "should install" do
+        results = bundle "install", :artifice => "endpoint"
+        expect(results).to include("Installing rack 1.0.0")
+        expect(the_bundle).to include_gems "rack 1.0.0"
       end
+    end
 
-      context "using Windows" do
-        it "should install" do
-          simulate_windows do
-            results = bundle "install", :artifice => "endpoint"
-            expect(results).to include("Installing rack 1.0.0")
-            expect(the_bundle).to include_gems "rack 1.0.0"
-          end
-        end
-      end
+    it "should install", :jruby do
+      results = bundle "install", :artifice => "endpoint"
+      expect(results).to include("Installing rack 1.0.0")
+      expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
-    context "bundled for ruby and jruby" do
+    context "bundled for multiple platforms" do
       let(:platform_specific_type) { :runtime }
       let(:dependency) { "platform_specific" }
       before do
@@ -425,7 +416,7 @@ RSpec.describe "bundle install from an e
           end
         end
 
-        build_lib "foo", :path => "." do |s|
+        build_lib "foo", :path => bundled_app do |s|
           if platform_specific_type == :runtime
             s.add_runtime_dependency dependency
           elsif platform_specific_type == :development
@@ -435,24 +426,27 @@ RSpec.describe "bundle install from an e
           end
         end
 
-        %w[ruby jruby].each do |platform|
-          simulate_platform(platform) do
-            install_gemfile <<-G
-              source "#{file_uri_for(gem_repo2)}"
-              gemspec
-            G
-          end
-        end
+        gemfile <<-G
+          source "#{file_uri_for(gem_repo2)}"
+          gemspec
+        G
+
+        bundle "config set --local force_ruby_platform true"
+        bundle "install"
+
+        simulate_new_machine
+        simulate_platform("jruby") { bundle "install" }
+        simulate_platform(x64_mingw32) { bundle "install" }
       end
 
       context "on ruby" do
         before do
-          simulate_platform("ruby")
+          bundle "config set --local force_ruby_platform true"
           bundle :install
         end
 
         context "as a runtime dependency" do
-          it "keeps java dependencies in the lockfile" do
+          it "keeps all platform dependencies in the lockfile" do
             expect(the_bundle).to include_gems "foo 1.0", "platform_specific 1.0 RUBY"
             expect(lockfile).to eq strip_whitespace(<<-L)
               PATH
@@ -466,10 +460,12 @@ RSpec.describe "bundle install from an e
                 specs:
                   platform_specific (1.0)
                   platform_specific (1.0-java)
+                  #{x64_mingw_gems}
 
               PLATFORMS
                 java
                 ruby
+                #{x64_mingw_platforms}
 
               DEPENDENCIES
                 foo!
@@ -483,7 +479,7 @@ RSpec.describe "bundle install from an e
         context "as a development dependency" do
           let(:platform_specific_type) { :development }
 
-          it "keeps java dependencies in the lockfile" do
+          it "keeps all platform dependencies in the lockfile" do
             expect(the_bundle).to include_gems "foo 1.0", "platform_specific 1.0 RUBY"
             expect(lockfile).to eq strip_whitespace(<<-L)
               PATH
@@ -496,10 +492,12 @@ RSpec.describe "bundle install from an e
                 specs:
                   platform_specific (1.0)
                   platform_specific (1.0-java)
+                  #{x64_mingw_gems}
 
               PLATFORMS
                 java
                 ruby
+                #{x64_mingw_platforms}
 
               DEPENDENCIES
                 foo!
@@ -515,7 +513,7 @@ RSpec.describe "bundle install from an e
           let(:platform_specific_type) { :development }
           let(:dependency) { "indirect_platform_specific" }
 
-          it "keeps java dependencies in the lockfile" do
+          it "keeps all platform dependencies in the lockfile" do
             expect(the_bundle).to include_gems "foo 1.0", "indirect_platform_specific 1.0", "platform_specific 1.0 RUBY"
             expect(lockfile).to eq strip_whitespace(<<-L)
               PATH
@@ -530,10 +528,12 @@ RSpec.describe "bundle install from an e
                     platform_specific
                   platform_specific (1.0)
                   platform_specific (1.0-java)
+                  #{x64_mingw_gems}
 
               PLATFORMS
                 java
                 ruby
+                #{x64_mingw_platforms}
 
               DEPENDENCIES
                 foo!
@@ -558,9 +558,9 @@ RSpec.describe "bundle install from an e
     end
 
     it "installs the ruby platform gemspec" do
-      simulate_platform "ruby"
+      bundle "config set --local force_ruby_platform true"
 
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gemspec :path => '#{tmp.join("foo")}', :name => 'foo'
       G
@@ -568,10 +568,11 @@ RSpec.describe "bundle install from an e
       expect(the_bundle).to include_gems "foo 1.0.0", "rack 1.0.0"
     end
 
-    it "installs the ruby platform gemspec and skips dev deps with --without development" do
-      simulate_platform "ruby"
+    it "installs the ruby platform gemspec and skips dev deps with `without development` configured" do
+      bundle "config set --local force_ruby_platform true"
 
-      install_gemfile! <<-G, forgotten_command_line_options(:without => "development")
+      bundle "config set --local without development"
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gemspec :path => '#{tmp.join("foo")}', :name => 'foo'
       G
@@ -580,4 +581,117 @@ RSpec.describe "bundle install from an e
       expect(the_bundle).not_to include_gem "rack"
     end
   end
+
+  context "with multiple platforms and resolving for more specific platforms" do
+    before do
+      build_lib("chef", :path => tmp.join("chef")) do |s|
+        s.version = "17.1.17"
+        s.write "chef-universal-mingw32.gemspec", build_spec("chef", "17.1.17", "universal-mingw32") {|sw| sw.runtime "win32-api", "~> 1.5.3" }.first.to_ruby
+      end
+    end
+
+    it "does not remove the platform specific specs from the lockfile when updating" do
+      build_repo4 do
+        build_gem "win32-api", "1.5.3" do |s|
+          s.platform = "universal-mingw32"
+        end
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gemspec :path => "../chef"
+      G
+
+      initial_lockfile = <<~L
+        PATH
+          remote: ../chef
+          specs:
+            chef (17.1.17)
+            chef (17.1.17-universal-mingw32)
+              win32-api (~> 1.5.3)
+
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            win32-api (1.5.3-universal-mingw32)
+
+        PLATFORMS
+          ruby
+          #{x64_mingw_platforms}
+          x86-mingw32
+
+        DEPENDENCIES
+          chef!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      lockfile initial_lockfile
+
+      bundle "update"
+
+      expect(lockfile).to eq initial_lockfile
+    end
+  end
+
+  context "with multiple locked platforms" do
+    before do
+      build_lib("activeadmin", :path => tmp.join("activeadmin")) do |s|
+        s.version = "2.9.0"
+        s.add_dependency "railties", ">= 5.2", "< 6.2"
+      end
+
+      build_repo4 do
+        build_gem "railties", "6.1.4"
+
+        build_gem "jruby-openssl", "0.10.7" do |s|
+          s.platform = "java"
+        end
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gemspec :path => "../activeadmin"
+        gem "jruby-openssl", :platform => :jruby
+      G
+
+      bundle "lock --add-platform java"
+    end
+
+    it "does not remove the platform specific specs from the lockfile when re-resolving due to gemspec changes" do
+      expect(lockfile).to eq <<~L
+        PATH
+          remote: ../activeadmin
+          specs:
+            activeadmin (2.9.0)
+              railties (>= 5.2, < 6.2)
+
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            jruby-openssl (0.10.7-java)
+            railties (6.1.4)
+
+        PLATFORMS
+          #{lockfile_platforms_for(["java", specific_local_platform])}
+
+        DEPENDENCIES
+          activeadmin!
+          jruby-openssl
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      gemspec = tmp.join("activeadmin/activeadmin.gemspec")
+      File.write(gemspec, File.read(gemspec).sub(">= 5.2", ">= 6.0"))
+
+      previous_lockfile = lockfile
+
+      bundle "install --local"
+
+      expect(lockfile).to eq(previous_lockfile.sub(">= 5.2", ">= 6.0"))
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile/git_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/git_spec.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
 
 RSpec.describe "bundle install with git sources" do
-  describe "when floating on master" do
+  describe "when floating on main" do
     before :each do
       build_git "foo" do |s|
         s.executables = "foobar"
@@ -30,11 +30,15 @@ RSpec.describe "bundle install with git 
       expect(Dir["#{default_bundle_path}/cache/bundler/git/foo-1.0-*"]).to have_attributes :size => 1
     end
 
-    it "caches the git repo globally" do
+    it "caches the git repo globally and properly uses the cached repo on the next invocation" do
       simulate_new_machine
-      bundle! "config set global_gem_cache true"
-      bundle! :install
+      bundle "config set global_gem_cache true"
+      bundle :install
       expect(Dir["#{home}/.bundle/cache/git/foo-1.0-*"]).to have_attributes :size => 1
+
+      bundle "install --verbose"
+      expect(err).to be_empty
+      expect(out).to include("Using foo 1.0 from #{lib_path("foo")}")
     end
 
     it "caches the evaluated gemspec" do
@@ -47,7 +51,7 @@ RSpec.describe "bundle install with git 
 
       bundle "update foo"
 
-      sha = git.ref_for("master", 11)
+      sha = git.ref_for("main", 11)
       spec_file = default_bundle_path.join("bundler/gems/foo-1.0-#{sha}/foo.gemspec").to_s
       ruby_code = Gem::Specification.load(spec_file).to_ruby
       file_code = File.read(spec_file)
@@ -57,22 +61,19 @@ RSpec.describe "bundle install with git 
     it "does not update the git source implicitly" do
       update_git "foo"
 
-      in_app_root2 do
-        install_gemfile bundled_app2("Gemfile"), <<-G
-          git "#{lib_path("foo-1.0")}" do
-            gem 'foo'
-          end
-        G
-      end
+      install_gemfile bundled_app2("Gemfile"), <<-G, :dir => bundled_app2
+        source "#{file_uri_for(gem_repo1)}"
+        git "#{lib_path("foo-1.0")}" do
+          gem 'foo'
+        end
+      G
 
-      in_app_root do
-        run <<-RUBY
-          require 'foo'
-          puts "fail" if defined?(FOO_PREV_REF)
-        RUBY
+      run <<-RUBY
+        require 'foo'
+        puts "fail" if defined?(FOO_PREV_REF)
+      RUBY
 
-        expect(out).to be_empty
-      end
+      expect(out).to be_empty
     end
 
     it "sets up git gem executables on the path" do
@@ -83,32 +84,30 @@ RSpec.describe "bundle install with git 
     it "complains if pinned specs don't exist in the git repo" do
       build_git "foo"
 
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", "1.1", :git => "#{lib_path("foo-1.0")}"
       G
 
-      expect(err).to include("The source contains 'foo' at: 1.0")
+      expect(err).to include("The source contains the following gems matching 'foo':\n  * foo-1.0")
     end
 
-    it "complains with version and platform if pinned specs don't exist in the git repo" do
-      simulate_platform "java"
-
+    it "complains with version and platform if pinned specs don't exist in the git repo", :jruby_only do
       build_git "only_java" do |s|
         s.platform = "java"
       end
 
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
         platforms :jruby do
           gem "only_java", "1.2", :git => "#{lib_path("only_java-1.0-java")}"
         end
       G
 
-      expect(err).to include("The source contains 'only_java' at: 1.0 java")
+      expect(err).to include("The source contains the following gems matching 'only_java':\n  * only_java-1.0-java")
     end
 
-    it "complains with multiple versions and platforms if pinned specs don't exist in the git repo" do
-      simulate_platform "java"
-
+    it "complains with multiple versions and platforms if pinned specs don't exist in the git repo", :jruby_only do
       build_git "only_java", "1.0" do |s|
         s.platform = "java"
       end
@@ -118,30 +117,33 @@ RSpec.describe "bundle install with git 
         s.write "only_java1-0.gemspec", File.read("#{lib_path("only_java-1.0-java")}/only_java.gemspec")
       end
 
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
         platforms :jruby do
           gem "only_java", "1.2", :git => "#{lib_path("only_java-1.1-java")}"
         end
       G
 
-      expect(err).to include("The source contains 'only_java' at: 1.0 java, 1.1 java")
+      expect(err).to include("The source contains the following gems matching 'only_java':\n  * only_java-1.0-java\n  * only_java-1.1-java")
     end
 
     it "still works after moving the application directory" do
-      bundle "install --path vendor/bundle"
+      bundle "config set --local path vendor/bundle"
+      bundle "install"
+
       FileUtils.mv bundled_app, tmp("bundled_app.bck")
 
-      Dir.chdir tmp("bundled_app.bck")
-      expect(the_bundle).to include_gems "foo 1.0"
+      expect(the_bundle).to include_gems "foo 1.0", :dir => tmp("bundled_app.bck")
     end
 
     it "can still install after moving the application directory" do
-      bundle "install --path vendor/bundle"
+      bundle "config set --local path vendor/bundle"
+      bundle "install"
+
       FileUtils.mv bundled_app, tmp("bundled_app.bck")
 
       update_git "foo", "1.1", :path => lib_path("foo-1.0")
 
-      Dir.chdir tmp("bundled_app.bck")
       gemfile tmp("bundled_app.bck/Gemfile"), <<-G
         source "#{file_uri_for(gem_repo1)}"
         git "#{lib_path("foo-1.0")}" do
@@ -151,9 +153,9 @@ RSpec.describe "bundle install with git 
         gem "rack", "1.0"
       G
 
-      bundle "update foo"
+      bundle "update foo", :dir => tmp("bundled_app.bck")
 
-      expect(the_bundle).to include_gems "foo 1.1", "rack 1.0"
+      expect(the_bundle).to include_gems "foo 1.1", "rack 1.0", :dir => tmp("bundled_app.bck")
     end
   end
 
@@ -185,6 +187,7 @@ RSpec.describe "bundle install with git 
 
     it "works" do
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{lib_path("foo-1.0")}", :ref => "#{@revision}" do
           gem "foo"
         end
@@ -200,6 +203,7 @@ RSpec.describe "bundle install with git 
 
     it "works when the revision is a symbol" do
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{lib_path("foo-1.0")}", :ref => #{@revision.to_sym.inspect} do
           gem "foo"
         end
@@ -215,28 +219,27 @@ RSpec.describe "bundle install with git 
     end
 
     it "works when the revision is a non-head ref" do
-      # want to ensure we don't fallback to master
+      # want to ensure we don't fallback to main
       update_git "foo", :path => lib_path("foo-1.0") do |s|
         s.write("lib/foo.rb", "raise 'FAIL'")
       end
 
-      Dir.chdir(lib_path("foo-1.0")) do
-        `git update-ref -m "Bundler Spec!" refs/bundler/1 master~1`
-      end
+      sys_exec("git update-ref -m \"Bundler Spec!\" refs/bundler/1 main~1", :dir => lib_path("foo-1.0"))
 
       # want to ensure we don't fallback to HEAD
       update_git "foo", :path => lib_path("foo-1.0"), :branch => "rando" do |s|
-        s.write("lib/foo.rb", "raise 'FAIL'")
+        s.write("lib/foo.rb", "raise 'FAIL_FROM_RANDO'")
       end
 
-      install_gemfile! <<-G
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{lib_path("foo-1.0")}", :ref => "refs/bundler/1" do
           gem "foo"
         end
       G
       expect(err).to be_empty
 
-      run! <<-RUBY
+      run <<-RUBY
         require 'foo'
         puts "WIN" if defined?(FOO)
       RUBY
@@ -245,34 +248,34 @@ RSpec.describe "bundle install with git 
     end
 
     it "works when the revision is a non-head ref and it was previously downloaded" do
-      install_gemfile! <<-G
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{lib_path("foo-1.0")}" do
           gem "foo"
         end
       G
 
-      # want to ensure we don't fallback to master
+      # want to ensure we don't fallback to main
       update_git "foo", :path => lib_path("foo-1.0") do |s|
         s.write("lib/foo.rb", "raise 'FAIL'")
       end
 
-      Dir.chdir(lib_path("foo-1.0")) do
-        `git update-ref -m "Bundler Spec!" refs/bundler/1 master~1`
-      end
+      sys_exec("git update-ref -m \"Bundler Spec!\" refs/bundler/1 main~1", :dir => lib_path("foo-1.0"))
 
       # want to ensure we don't fallback to HEAD
       update_git "foo", :path => lib_path("foo-1.0"), :branch => "rando" do |s|
-        s.write("lib/foo.rb", "raise 'FAIL'")
+        s.write("lib/foo.rb", "raise 'FAIL_FROM_RANDO'")
       end
 
-      install_gemfile! <<-G
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{lib_path("foo-1.0")}", :ref => "refs/bundler/1" do
           gem "foo"
         end
       G
       expect(err).to be_empty
 
-      run! <<-RUBY
+      run <<-RUBY
         require 'foo'
         puts "WIN" if defined?(FOO)
       RUBY
@@ -281,24 +284,21 @@ RSpec.describe "bundle install with git 
     end
 
     it "does not download random non-head refs" do
-      Dir.chdir(lib_path("foo-1.0")) do
-        sys_exec!('git update-ref -m "Bundler Spec!" refs/bundler/1 master~1')
-      end
+      sys_exec("git update-ref -m \"Bundler Spec!\" refs/bundler/1 main~1", :dir => lib_path("foo-1.0"))
 
-      bundle! "config set global_gem_cache true"
+      bundle "config set global_gem_cache true"
 
-      install_gemfile! <<-G
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{lib_path("foo-1.0")}" do
           gem "foo"
         end
       G
 
       # ensure we also git fetch after cloning
-      bundle! :update, :all => true
+      bundle :update, :all => true
 
-      Dir.chdir(Dir[home(".bundle/cache/git/foo-*")].first) do
-        sys_exec("git ls-remote .")
-      end
+      sys_exec("git ls-remote .", :dir => Dir[home(".bundle/cache/git/foo-*")].first)
 
       expect(out).not_to include("refs/bundler/1")
     end
@@ -307,12 +307,12 @@ RSpec.describe "bundle install with git 
   describe "when specifying a branch" do
     let(:branch) { "branch" }
     let(:repo) { build_git("foo").path }
-    before(:each) do
-      update_git("foo", :path => repo, :branch => branch)
-    end
 
     it "works" do
+      update_git("foo", :path => repo, :branch => branch)
+
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{repo}", :branch => #{branch.dump} do
           gem "foo"
         end
@@ -324,7 +324,12 @@ RSpec.describe "bundle install with git 
     context "when the branch starts with a `#`" do
       let(:branch) { "#149/redirect-url-fragment" }
       it "works" do
+        skip "git does not accept this" if Gem.win_platform?
+
+        update_git("foo", :path => repo, :branch => branch)
+
         install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           git "#{repo}", :branch => #{branch.dump} do
             gem "foo"
           end
@@ -337,7 +342,12 @@ RSpec.describe "bundle install with git 
     context "when the branch includes quotes" do
       let(:branch) { %('") }
       it "works" do
+        skip "git does not accept this" if Gem.win_platform?
+
+        update_git("foo", :path => repo, :branch => branch)
+
         install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           git "#{repo}", :branch => #{branch.dump} do
             gem "foo"
           end
@@ -351,12 +361,12 @@ RSpec.describe "bundle install with git 
   describe "when specifying a tag" do
     let(:tag) { "tag" }
     let(:repo) { build_git("foo").path }
-    before(:each) do
-      update_git("foo", :path => repo, :tag => tag)
-    end
 
     it "works" do
+      update_git("foo", :path => repo, :tag => tag)
+
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{repo}", :tag => #{tag.dump} do
           gem "foo"
         end
@@ -368,7 +378,12 @@ RSpec.describe "bundle install with git 
     context "when the tag starts with a `#`" do
       let(:tag) { "#149/redirect-url-fragment" }
       it "works" do
+        skip "git does not accept this" if Gem.win_platform?
+
+        update_git("foo", :path => repo, :tag => tag)
+
         install_gemfile <<-G
+         source "#{file_uri_for(gem_repo1)}"
           git "#{repo}", :tag => #{tag.dump} do
             gem "foo"
           end
@@ -381,7 +396,12 @@ RSpec.describe "bundle install with git 
     context "when the tag includes quotes" do
       let(:tag) { %('") }
       it "works" do
+        skip "git does not accept this" if Gem.win_platform?
+
+        update_git("foo", :path => repo, :tag => tag)
+
         install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           git "#{repo}", :tag => #{tag.dump} do
             gem "foo"
           end
@@ -394,20 +414,17 @@ RSpec.describe "bundle install with git 
 
   describe "when specifying local override" do
     it "uses the local repository instead of checking a new one out" do
-      # We don't generate it because we actually don't need it
-      # build_git "rack", "0.8"
-
       build_git "rack", "0.8", :path => lib_path("local-rack") do |s|
         s.write "lib/rack.rb", "puts :LOCAL"
       end
 
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
       G
 
-      bundle! %(config set local.rack #{lib_path("local-rack")})
-      bundle! :install
+      bundle %(config set local.rack #{lib_path("local-rack")})
+      bundle :install
 
       run "require 'rack'"
       expect(out).to eq("LOCAL")
@@ -424,7 +441,7 @@ RSpec.describe "bundle install with git 
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
       G
 
       bundle %(config set local.rack #{lib_path("local-rack")})
@@ -442,14 +459,14 @@ RSpec.describe "bundle install with git 
         s.write "lib/rack.rb", "puts :LOCAL"
       end
 
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
       G
 
-      bundle! %(config set local.rack #{lib_path("local-rack")})
-      bundle! :install
-      run! "require 'rack'"
+      bundle %(config set local.rack #{lib_path("local-rack")})
+      bundle :install
+      run "require 'rack'"
       expect(out).to eq("LOCAL")
     end
 
@@ -460,10 +477,10 @@ RSpec.describe "bundle install with git 
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
       G
 
-      lockfile0 = File.read(bundled_app("Gemfile.lock"))
+      lockfile0 = File.read(bundled_app_lock)
 
       FileUtils.cp_r("#{lib_path("rack-0.8")}/.", lib_path("local-rack"))
       update_git "rack", "0.8", :path => lib_path("local-rack") do |s|
@@ -473,7 +490,7 @@ RSpec.describe "bundle install with git 
       bundle %(config set local.rack #{lib_path("local-rack")})
       run "require 'rack'"
 
-      lockfile1 = File.read(bundled_app("Gemfile.lock"))
+      lockfile1 = File.read(bundled_app_lock)
       expect(lockfile1).not_to eq(lockfile0)
     end
 
@@ -482,10 +499,10 @@ RSpec.describe "bundle install with git 
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
       G
 
-      lockfile0 = File.read(bundled_app("Gemfile.lock"))
+      lockfile0 = File.read(bundled_app_lock)
 
       FileUtils.cp_r("#{lib_path("rack-0.8")}/.", lib_path("local-rack"))
       update_git "rack", "0.8", :path => lib_path("local-rack")
@@ -493,7 +510,7 @@ RSpec.describe "bundle install with git 
       bundle %(config set local.rack #{lib_path("local-rack")})
       bundle :install
 
-      lockfile1 = File.read(bundled_app("Gemfile.lock"))
+      lockfile1 = File.read(bundled_app_lock)
       expect(lockfile1).not_to eq(lockfile0)
     end
 
@@ -502,11 +519,11 @@ RSpec.describe "bundle install with git 
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
       G
 
       bundle %(config set local.rack #{lib_path("local-rack")})
-      bundle :install
+      bundle :install, :raise_on_error => false
       expect(err).to match(/Cannot use local override for rack-0.8 because #{Regexp.escape(lib_path('local-rack').to_s)} does not exist/)
 
       solution = "config unset local.rack"
@@ -528,7 +545,7 @@ RSpec.describe "bundle install with git 
       G
 
       bundle %(config set local.rack #{lib_path("local-rack")})
-      bundle :install
+      bundle :install, :raise_on_error => false
       expect(err).to match(/Cannot use local override for rack-0.8 at #{Regexp.escape(lib_path('local-rack').to_s)} because :branch is not specified in Gemfile/)
 
       solution = "config unset local.rack"
@@ -566,12 +583,12 @@ RSpec.describe "bundle install with git 
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
       G
 
       bundle %(config set local.rack #{lib_path("local-rack")})
-      bundle :install
-      expect(err).to match(/is using branch another but Gemfile specifies master/)
+      bundle :install, :raise_on_error => false
+      expect(err).to match(/is using branch another but Gemfile specifies main/)
     end
 
     it "explodes on invalid revision on install" do
@@ -583,13 +600,31 @@ RSpec.describe "bundle install with git 
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
       G
 
       bundle %(config set local.rack #{lib_path("local-rack")})
-      bundle :install
+      bundle :install, :raise_on_error => false
       expect(err).to match(/The Gemfile lock is pointing to revision \w+/)
     end
+
+    it "does not explode on invalid revision on install" do
+      build_git "rack", "0.8"
+
+      build_git "rack", "0.8", :path => lib_path("local-rack") do |s|
+        s.write "lib/rack.rb", "puts :LOCAL"
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
+      G
+
+      bundle %(config set local.rack #{lib_path("local-rack")})
+      bundle %(config set disable_local_revision_check true)
+      bundle :install
+      expect(out).to match(/Bundle complete!/)
+    end
   end
 
   describe "specified inline" do
@@ -679,6 +714,7 @@ RSpec.describe "bundle install with git 
       build_lib "hi2u", :path => lib_path("hi2u")
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         path "#{lib_path("hi2u")}" do
           gem "omg"
           gem "hi2u"
@@ -695,6 +731,7 @@ RSpec.describe "bundle install with git 
     update_git "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => "#{lib_path("foo-1.0")}", :ref => "#{@revision}"
     G
 
@@ -759,6 +796,7 @@ RSpec.describe "bundle install with git 
     build_git "foo", "1.0"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", "1.0", :git => "#{lib_path("foo-1.0")}"
     G
 
@@ -780,10 +818,11 @@ RSpec.describe "bundle install with git 
 
   it "catches git errors and spits out useful output" do
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", "1.0", :git => "omgomg"
     G
 
-    bundle :install
+    bundle :install, :raise_on_error => false
 
     expect(err).to include("Git error:")
     expect(err).to include("fatal")
@@ -794,6 +833,7 @@ RSpec.describe "bundle install with git 
     build_git "foo", :path => lib_path("foo space-1.0")
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => "#{lib_path("foo space-1.0")}"
     G
 
@@ -804,6 +844,7 @@ RSpec.describe "bundle install with git 
     build_git "forced", "1.0"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       git "#{lib_path("forced-1.0")}" do
         gem 'forced'
       end
@@ -817,9 +858,7 @@ RSpec.describe "bundle install with git 
     bundle "update", :all => true
     expect(the_bundle).to include_gems "forced 1.1"
 
-    Dir.chdir(lib_path("forced-1.0")) do
-      `git reset --hard HEAD^`
-    end
+    sys_exec("git reset --hard HEAD^", :dir => lib_path("forced-1.0"))
 
     bundle "update", :all => true
     expect(the_bundle).to include_gems "forced 1.0"
@@ -830,12 +869,11 @@ RSpec.describe "bundle install with git 
     build_git "has_submodule", "1.0" do |s|
       s.add_dependency "submodule"
     end
-    Dir.chdir(lib_path("has_submodule-1.0")) do
-      sys_exec "git submodule add #{lib_path("submodule-1.0")} submodule-1.0"
-      `git commit -m "submodulator"`
-    end
+    sys_exec "git submodule add #{lib_path("submodule-1.0")} submodule-1.0", :dir => lib_path("has_submodule-1.0")
+    sys_exec "git commit -m \"submodulator\"", :dir => lib_path("has_submodule-1.0")
 
-    install_gemfile <<-G
+    install_gemfile <<-G, :raise_on_error => false
+      source "#{file_uri_for(gem_repo1)}"
       git "#{lib_path("has_submodule-1.0")}" do
         gem "has_submodule"
       end
@@ -850,12 +888,11 @@ RSpec.describe "bundle install with git 
     build_git "has_submodule", "1.0" do |s|
       s.add_dependency "submodule"
     end
-    Dir.chdir(lib_path("has_submodule-1.0")) do
-      sys_exec "git submodule add #{lib_path("submodule-1.0")} submodule-1.0"
-      `git commit -m "submodulator"`
-    end
+    sys_exec "git submodule add #{lib_path("submodule-1.0")} submodule-1.0", :dir => lib_path("has_submodule-1.0")
+    sys_exec "git commit -m \"submodulator\"", :dir => lib_path("has_submodule-1.0")
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       git "#{lib_path("has_submodule-1.0")}", :submodules => true do
         gem "has_submodule"
       end
@@ -864,10 +901,30 @@ RSpec.describe "bundle install with git 
     expect(the_bundle).to include_gems "has_submodule 1.0"
   end
 
+  it "does not warn when deiniting submodules" do
+    build_git "submodule", "1.0"
+    build_git "has_submodule", "1.0"
+
+    sys_exec "git submodule add #{lib_path("submodule-1.0")} submodule-1.0", :dir => lib_path("has_submodule-1.0")
+    sys_exec "git commit -m \"submodulator\"", :dir => lib_path("has_submodule-1.0")
+
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      git "#{lib_path("has_submodule-1.0")}" do
+        gem "has_submodule"
+      end
+    G
+    expect(err).to be_empty
+
+    expect(the_bundle).to include_gems "has_submodule 1.0"
+    expect(the_bundle).to_not include_gems "submodule 1.0"
+  end
+
   it "handles implicit updates when modifying the source info" do
     git = build_git "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       git "#{lib_path("foo-1.0")}" do
         gem "foo"
       end
@@ -877,6 +934,7 @@ RSpec.describe "bundle install with git 
     update_git "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       git "#{lib_path("foo-1.0")}", :ref => "#{git.ref_for("HEAD^")}" do
         gem "foo"
       end
@@ -894,6 +952,7 @@ RSpec.describe "bundle install with git 
     build_git "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => "#{lib_path("foo-1.0")}"
     G
 
@@ -907,12 +966,12 @@ RSpec.describe "bundle install with git 
     build_git "foo"
 
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => "#{lib_path("foo-1.0")}"
     G
 
     bundle "install"
     bundle "install"
-    expect(exitstatus).to eq(0) if exitstatus
   end
 
   it "prints a friendly error if a file blocks the git repo" do
@@ -921,11 +980,12 @@ RSpec.describe "bundle install with git 
     FileUtils.mkdir_p(default_bundle_path)
     FileUtils.touch(default_bundle_path("bundler"))
 
-    install_gemfile <<-G
+    install_gemfile <<-G, :raise_on_error => false
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => "#{lib_path("foo-1.0")}"
     G
 
-    expect(exitstatus).to_not eq(0) if exitstatus
+    expect(exitstatus).to_not eq(0)
     expect(err).to include("Bundler could not install a gem because it " \
                            "needs to create a directory, but a file exists " \
                            "- #{default_bundle_path("bundler")}")
@@ -939,11 +999,12 @@ RSpec.describe "bundle install with git 
     build_git "bar", :path => lib_path("nested")
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => "#{lib_path("nested")}"
       gem "bar", :git => "#{lib_path("nested")}"
     G
 
-    expect(File.read(bundled_app("Gemfile.lock")).scan("GIT").size).to eq(1)
+    expect(File.read(bundled_app_lock).scan("GIT").size).to eq(1)
   end
 
   describe "switching sources" do
@@ -996,6 +1057,7 @@ RSpec.describe "bundle install with git 
       build_git "valim"
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "valim", :git => "#{file_uri_for(lib_path("valim-1.0"))}"
       G
 
@@ -1003,8 +1065,8 @@ RSpec.describe "bundle install with git 
       update_git "valim"
       new_revision = revision_for(lib_path("valim-1.0"))
 
-      old_lockfile = File.read(bundled_app("Gemfile.lock"))
-      lockfile(bundled_app("Gemfile.lock"), old_lockfile.gsub(/revision: #{old_revision}/, "revision: #{new_revision}"))
+      old_lockfile = File.read(bundled_app_lock)
+      lockfile(bundled_app_lock, old_lockfile.gsub(/revision: #{old_revision}/, "revision: #{new_revision}"))
 
       bundle "install"
 
@@ -1021,18 +1083,20 @@ RSpec.describe "bundle install with git 
       revision = revision_for(lib_path("foo-1.0"))
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{file_uri_for(lib_path("foo-1.0"))}", :ref => "#{revision}"
       G
       expect(out).to_not match(/Revision.*does not exist/)
 
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{file_uri_for(lib_path("foo-1.0"))}", :ref => "deadbeef"
       G
       expect(err).to include("Revision deadbeef does not exist in the repository")
     end
   end
 
-  describe "bundle install --deployment with git sources" do
+  describe "bundle install with deployment mode configured and git sources" do
     it "works" do
       build_git "valim", :path => lib_path("valim")
 
@@ -1043,7 +1107,8 @@ RSpec.describe "bundle install with git 
 
       simulate_new_machine
 
-      bundle! :install, forgotten_command_line_options(:deployment => true)
+      bundle "config set --local deployment true"
+      bundle :install
     end
   end
 
@@ -1051,6 +1116,7 @@ RSpec.describe "bundle install with git 
     it "runs pre-install hooks" do
       build_git "foo"
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
 
@@ -1070,6 +1136,7 @@ RSpec.describe "bundle install with git 
     it "runs post-install hooks" do
       build_git "foo"
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
 
@@ -1089,6 +1156,7 @@ RSpec.describe "bundle install with git 
     it "complains if the install hook fails" do
       build_git "foo"
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
 
@@ -1100,8 +1168,7 @@ RSpec.describe "bundle install with git 
         H
       end
 
-      bundle :install,
-        :requires => [lib_path("install_hooks.rb")]
+      bundle :install, :requires => [lib_path("install_hooks.rb")], :raise_on_error => false
       expect(err).to include("failed for foo-1.0")
     end
   end
@@ -1113,7 +1180,7 @@ RSpec.describe "bundle install with git 
         s.extensions << "Rakefile"
         s.write "Rakefile", <<-RUBY
           task :default do
-            path = File.expand_path("../lib", __FILE__)
+            path = File.expand_path("lib", __dir__)
             FileUtils.mkdir_p(path)
             File.open("\#{path}/foo.rb", "w") do |f|
               f.puts "FOO = 'YES'"
@@ -1133,33 +1200,33 @@ RSpec.describe "bundle install with git 
       R
       expect(out).to eq("YES")
 
-      run! <<-R
+      run <<-R
         puts $:.grep(/ext/)
       R
       expect(out).to include(Pathname.glob(default_bundle_path("bundler/gems/extensions/**/foo-1.0-*")).first.to_s)
     end
 
-    it "does not use old extension after ref changes", :ruby_repo do
+    it "does not use old extension after ref changes" do
       git_reader = build_git "foo", :no_default => true do |s|
         s.extensions = ["ext/extconf.rb"]
         s.write "ext/extconf.rb", <<-RUBY
           require "mkmf"
+          $extout = "$(topdir)/" + RbConfig::CONFIG["EXTOUT"] unless RUBY_VERSION < "2.4"
           create_makefile("foo")
         RUBY
         s.write "ext/foo.c", "void Init_foo() {}"
       end
 
       2.times do |i|
-        Dir.chdir(git_reader.path) do
-          File.open("ext/foo.c", "w") do |file|
-            file.write <<-C
-              #include "ruby.h"
-              VALUE foo() { return INT2FIX(#{i}); }
-              void Init_foo() { rb_define_global_function("foo", &foo, 0); }
-            C
-          end
-          `git commit -m "commit for iteration #{i}" ext/foo.c`
+        File.open(git_reader.path.join("ext/foo.c"), "w") do |file|
+          file.write <<-C
+            #include "ruby.h"
+            VALUE foo() { return INT2FIX(#{i}); }
+            void Init_foo() { rb_define_global_function("foo", &foo, 0); }
+          C
         end
+        sys_exec("git commit -m \"commit for iteration #{i}\" ext/foo.c", :dir => git_reader.path)
+
         git_commit_sha = git_reader.ref_for("HEAD")
 
         install_gemfile <<-G
@@ -1187,7 +1254,7 @@ RSpec.describe "bundle install with git 
         RUBY
       end
 
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
         source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
@@ -1207,7 +1274,7 @@ In Gemfile:
         s.extensions << "Rakefile"
         s.write "Rakefile", <<-RUBY
           task :default do
-            path = File.expand_path("../lib", __FILE__)
+            path = File.expand_path("lib", __dir__)
             FileUtils.mkdir_p(path)
             cur_time = Time.now.to_f.to_s
             File.open("\#{path}/foo.rb", "w") do |f|
@@ -1222,7 +1289,7 @@ In Gemfile:
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
 
-      run! <<-R
+      run <<-R
         require 'foo'
         puts FOO
       R
@@ -1235,7 +1302,7 @@ In Gemfile:
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
 
-      run! <<-R
+      run <<-R
         require 'foo'
         puts FOO
       R
@@ -1248,7 +1315,7 @@ In Gemfile:
         s.extensions << "Rakefile"
         s.write "Rakefile", <<-RUBY
           task :default do
-            path = File.expand_path("../lib", __FILE__)
+            path = File.expand_path("lib", __dir__)
             FileUtils.mkdir_p(path)
             cur_time = Time.now.to_f.to_s
             File.open("\#{path}/foo.rb", "w") do |f|
@@ -1264,7 +1331,7 @@ In Gemfile:
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
 
-      run! <<-R
+      run <<-R
         require 'foo'
         puts FOO
       R
@@ -1278,7 +1345,7 @@ In Gemfile:
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
 
-      run! <<-R
+      run <<-R
         require 'foo'
         puts FOO
       R
@@ -1291,7 +1358,7 @@ In Gemfile:
         s.extensions << "Rakefile"
         s.write "Rakefile", <<-RUBY
           task :default do
-            path = File.expand_path("../lib", __FILE__)
+            path = File.expand_path("lib", __dir__)
             FileUtils.mkdir_p(path)
             cur_time = Time.now.to_f.to_s
             File.open("\#{path}/foo.rb", "w") do |f|
@@ -1306,14 +1373,15 @@ In Gemfile:
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
 
-      run! <<-R
+      run <<-R
         require 'foo'
         puts FOO
       R
 
+      installed_time = out
+
       update_git("foo", :branch => "branch2")
 
-      installed_time = out
       expect(installed_time).to match(/\A\d+\.\d+\z/)
 
       install_gemfile <<-G
@@ -1321,7 +1389,7 @@ In Gemfile:
         gem "foo", :git => "#{lib_path("foo-1.0")}", :branch => "branch2"
       G
 
-      run! <<-R
+      run <<-R
         require 'foo'
         puts FOO
       R
@@ -1330,9 +1398,9 @@ In Gemfile:
       installed_time = out
 
       update_git("foo")
-      bundle! "update foo"
+      bundle "update foo"
 
-      run! <<-R
+      run <<-R
         require 'foo'
         puts FOO
       R
@@ -1356,24 +1424,61 @@ In Gemfile:
         end
       G
 
-      expect(exitstatus).to eq(0) if exitstatus
       expect(ENV["GIT_DIR"]).to eq("bar")
       expect(ENV["GIT_WORK_TREE"]).to eq("bar")
     end
   end
 
   describe "without git installed" do
-    it "prints a better error message" do
+    it "prints a better error message when installing" do
+      build_git "foo"
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+
+        gem "rake", git: "https://github.com/ruby/rake"
+      G
+
+      lockfile <<-L
+        GIT
+          remote: https://github.com/ruby/rake
+          revision: 5c60da8644a9e4f655e819252e3b6ca77f42b7af
+          specs:
+            rake (13.0.6)
+
+        GEM
+          remote: https://rubygems.org/
+          specs:
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          rake!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      with_path_as("") do
+        bundle "install", :raise_on_error => false
+      end
+      expect(err).
+        to include("You need to install git to be able to use gems from git repositories. For help installing git, please refer to GitHub's tutorial at https://help.github.com/articles/set-up-git")
+    end
+
+    it "prints a better error message when updating" do
       build_git "foo"
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{lib_path("foo-1.0")}" do
           gem 'foo'
         end
       G
 
       with_path_as("") do
-        bundle "update", :all => true
+        bundle "update", :all => true, :raise_on_error => false
       end
       expect(err).
         to include("You need to install git to be able to use gems from git repositories. For help installing git, please refer to GitHub's tutorial at https://help.github.com/articles/set-up-git")
@@ -1383,6 +1488,7 @@ In Gemfile:
       build_git "foo"
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{lib_path("foo-1.0")}" do
           gem 'foo'
         end
@@ -1391,14 +1497,14 @@ In Gemfile:
       bundle :cache
       simulate_new_machine
 
-      bundle! "install", :env => { "PATH" => "" }
+      bundle "install", :env => { "PATH" => "" }
       expect(out).to_not include("You need to install git to be able to use gems from git repositories.")
     end
   end
 
   describe "when the git source is overridden with a local git repo" do
     before do
-      bundle! "config set --global local.foo #{lib_path("foo")}"
+      bundle "config set --global local.foo #{lib_path("foo")}"
     end
 
     describe "and git output is colorized" do
@@ -1412,7 +1518,8 @@ In Gemfile:
         build_git "foo", "1.0", :path => lib_path("foo")
 
         gemfile <<-G
-          gem "foo", :git => "#{lib_path("foo")}", :branch => "master"
+          source "#{file_uri_for(gem_repo1)}"
+          gem "foo", :git => "#{lib_path("foo")}", :branch => "main"
         G
 
         bundle :install
@@ -1426,7 +1533,8 @@ In Gemfile:
       let(:credentials) { "user1:password1" }
 
       it "does not display the password" do
-        install_gemfile <<-G
+        install_gemfile <<-G, :raise_on_error => false
+          source "#{file_uri_for(gem_repo1)}"
           git "https://#{credentials}@github.com/company/private-repo" do
             gem "foo"
           end
@@ -1441,7 +1549,8 @@ In Gemfile:
       let(:credentials) { "oauth_token" }
 
       it "displays the oauth scheme but not the oauth token" do
-        install_gemfile <<-G
+        install_gemfile <<-G, :raise_on_error => false
+          source "#{file_uri_for(gem_repo1)}"
           git "https://#{credentials}:x-oauth-basic@github.com/company/private-repo" do
             gem "foo"
           end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile/groups_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/groups_spec.rb
@@ -70,7 +70,7 @@ RSpec.describe "bundle install with grou
     end
   end
 
-  describe "installing --without" do
+  describe "without option" do
     describe "with gems assigned to a single group" do
       before :each do
         gemfile <<-G
@@ -86,30 +86,50 @@ RSpec.describe "bundle install with grou
       end
 
       it "installs gems in the default group" do
-        bundle! :install, forgotten_command_line_options(:without => "emo")
+        bundle "config set --local without emo"
+        bundle :install
+        expect(the_bundle).to include_gems "rack 1.0.0", :groups => [:default]
+      end
+
+      it "respects global `without` configuration, but does not save it locally" do
+        bundle "config set --global without emo"
+        bundle :install
         expect(the_bundle).to include_gems "rack 1.0.0", :groups => [:default]
+        bundle "config list"
+        expect(out).not_to include("Set for your local app (#{bundled_app(".bundle/config")}): [:emo]")
+        expect(out).to include("Set for the current user (#{home(".bundle/config")}): [:emo]")
+      end
+
+      it "allows running application where groups where configured by a different user", :bundler => "< 3" do
+        bundle "config set without emo"
+        bundle :install
+        bundle "exec ruby -e 'puts 42'", :env => { "BUNDLE_USER_HOME" => tmp("new_home").to_s }
+        expect(out).to include("42")
       end
 
       it "does not install gems from the excluded group" do
-        bundle :install, :without => "emo"
+        bundle "config set --local without emo"
+        bundle :install
         expect(the_bundle).not_to include_gems "activesupport 2.3.5", :groups => [:default]
       end
 
-      it "does not install gems from the previously excluded group" do
-        bundle :install, forgotten_command_line_options(:without => "emo")
+      it "remembers previous exclusion with `--without`", :bundler => "< 3" do
+        bundle "install --without emo"
         expect(the_bundle).not_to include_gems "activesupport 2.3.5"
         bundle :install
         expect(the_bundle).not_to include_gems "activesupport 2.3.5"
       end
 
       it "does not say it installed gems from the excluded group" do
-        bundle! :install, forgotten_command_line_options(:without => "emo")
+        bundle "config set --local without emo"
+        bundle :install
         expect(out).not_to include("activesupport")
       end
 
       it "allows Bundler.setup for specific groups" do
-        bundle :install, forgotten_command_line_options(:without => "emo")
-        run!("require 'rack'; puts RACK", :default)
+        bundle "config set --local without emo"
+        bundle :install
+        run("require 'rack'; puts RACK", :default)
         expect(out).to eq("1.0.0")
       end
 
@@ -122,20 +142,11 @@ RSpec.describe "bundle install with grou
           end
         G
 
-        bundle :install, forgotten_command_line_options(:without => "emo")
+        bundle "config set --local without emo"
+        bundle :install
         expect(the_bundle).to include_gems "activesupport 2.3.2", :groups => [:default]
       end
 
-      it "still works on a different machine and excludes gems" do
-        bundle :install, forgotten_command_line_options(:without => "emo")
-
-        simulate_new_machine
-        bundle :install, forgotten_command_line_options(:without => "emo")
-
-        expect(the_bundle).to include_gems "rack 1.0.0", :groups => [:default]
-        expect(the_bundle).not_to include_gems "activesupport 2.3.5", :groups => [:default]
-      end
-
       it "still works when BUNDLE_WITHOUT is set" do
         ENV["BUNDLE_WITHOUT"] = "emo"
 
@@ -148,15 +159,15 @@ RSpec.describe "bundle install with grou
         ENV["BUNDLE_WITHOUT"] = nil
       end
 
-      it "clears without when passed an empty list" do
-        bundle :install, forgotten_command_line_options(:without => "emo")
+      it "clears --without when passed an empty list", :bundler => "< 3" do
+        bundle "install --without emo"
 
-        bundle :install, forgotten_command_line_options(:without => "")
+        bundle "install --without ''"
         expect(the_bundle).to include_gems "activesupport 2.3.5"
       end
 
-      it "doesn't clear without when nothing is passed" do
-        bundle :install, forgotten_command_line_options(:without => "emo")
+      it "doesn't clear without when nothing is passed", :bundler => "< 3" do
+        bundle "install --without emo"
 
         bundle :install
         expect(the_bundle).not_to include_gems "activesupport 2.3.5"
@@ -167,45 +178,46 @@ RSpec.describe "bundle install with grou
         expect(the_bundle).not_to include_gems "thin 1.0"
       end
 
-      it "does install gems from the optional group when requested" do
-        bundle :install, forgotten_command_line_options(:with => "debugging")
+      it "installs gems from the optional group when requested" do
+        bundle "config set --local with debugging"
+        bundle :install
         expect(the_bundle).to include_gems "thin 1.0"
       end
 
-      it "does install gems from the previously requested group" do
-        bundle :install, forgotten_command_line_options(:with => "debugging")
+      it "installs gems from the previously requested group", :bundler => "< 3" do
+        bundle "install --with debugging"
         expect(the_bundle).to include_gems "thin 1.0"
         bundle :install
         expect(the_bundle).to include_gems "thin 1.0"
       end
 
-      it "does install gems from the optional groups requested with BUNDLE_WITH" do
+      it "installs gems from the optional groups requested with BUNDLE_WITH" do
         ENV["BUNDLE_WITH"] = "debugging"
         bundle :install
         expect(the_bundle).to include_gems "thin 1.0"
         ENV["BUNDLE_WITH"] = nil
       end
 
-      it "clears with when passed an empty list" do
-        bundle :install, forgotten_command_line_options(:with => "debugging")
-        bundle :install, forgotten_command_line_options(:with => "")
+      it "clears --with when passed an empty list", :bundler => "< 3" do
+        bundle "install --with debugging"
+        bundle "install --with ''"
         expect(the_bundle).not_to include_gems "thin 1.0"
       end
 
-      it "does remove groups from without when passed at --with", :bundler => "< 3" do
-        bundle :install, forgotten_command_line_options(:without => "emo")
-        bundle :install, forgotten_command_line_options(:with => "emo")
+      it "removes groups from without when passed at --with", :bundler => "< 3" do
+        bundle "config set --local without emo"
+        bundle "install --with emo"
         expect(the_bundle).to include_gems "activesupport 2.3.5"
       end
 
-      it "does remove groups from with when passed at --without", :bundler => "< 3" do
-        bundle :install, forgotten_command_line_options(:with => "debugging")
-        bundle :install, forgotten_command_line_options(:without => "debugging")
+      it "removes groups from with when passed at --without", :bundler => "< 3" do
+        bundle "config set --local with debugging"
+        bundle "install --without debugging", :raise_on_error => false
         expect(the_bundle).not_to include_gem "thin 1.0"
       end
 
       it "errors out when passing a group to with and without via CLI flags", :bundler => "< 3" do
-        bundle :install, forgotten_command_line_options(:with => "emo debugging", :without => "emo")
+        bundle "install --with emo debugging --without emo", :raise_on_error => false
         expect(last_command).to be_failure
         expect(err).to include("The offending groups are: emo")
       end
@@ -213,29 +225,31 @@ RSpec.describe "bundle install with grou
       it "allows the BUNDLE_WITH setting to override BUNDLE_WITHOUT" do
         ENV["BUNDLE_WITH"] = "debugging"
 
-        bundle! :install
+        bundle :install
         expect(the_bundle).to include_gem "thin 1.0"
 
         ENV["BUNDLE_WITHOUT"] = "debugging"
         expect(the_bundle).to include_gem "thin 1.0"
 
-        bundle! :install
+        bundle :install
         expect(the_bundle).to include_gem "thin 1.0"
       end
 
-      it "can add and remove a group at the same time" do
-        bundle :install, forgotten_command_line_options(:with => "debugging", :without => "emo")
+      it "can add and remove a group at the same time", :bundler => "< 3" do
+        bundle "install --with debugging --without emo"
         expect(the_bundle).to include_gems "thin 1.0"
         expect(the_bundle).not_to include_gems "activesupport 2.3.5"
       end
 
-      it "does have no effect when listing a not optional group in with" do
-        bundle :install, forgotten_command_line_options(:with => "emo")
+      it "has no effect when listing a not optional group in with" do
+        bundle "config set --local with emo"
+        bundle :install
         expect(the_bundle).to include_gems "activesupport 2.3.5"
       end
 
-      it "does have no effect when listing an optional group in without" do
-        bundle :install, forgotten_command_line_options(:without => "debugging")
+      it "has no effect when listing an optional group in without" do
+        bundle "config set --local without debugging"
+        bundle :install
         expect(the_bundle).not_to include_gems "thin 1.0"
       end
     end
@@ -252,12 +266,14 @@ RSpec.describe "bundle install with grou
       end
 
       it "installs gems in the default group" do
-        bundle! :install, forgotten_command_line_options(:without => "emo lolercoaster")
+        bundle "config set --local without emo lolercoaster"
+        bundle :install
         expect(the_bundle).to include_gems "rack 1.0.0"
       end
 
       it "installs the gem if any of its groups are installed" do
-        bundle! :install, forgotten_command_line_options(:without => "emo")
+        bundle "config set --local without emo"
+        bundle :install
         expect(the_bundle).to include_gems "rack 1.0.0", "activesupport 2.3.5"
       end
 
@@ -277,23 +293,21 @@ RSpec.describe "bundle install with grou
           G
         end
 
-        it "installs the gem w/ option --without emo" do
-          bundle :install, forgotten_command_line_options(:without => "emo")
+        it "installs the gem unless all groups are excluded" do
+          bundle "config set --local without emo"
+          bundle :install
           expect(the_bundle).to include_gems "activesupport 2.3.5"
-        end
 
-        it "installs the gem w/ option --without lolercoaster" do
-          bundle :install, forgotten_command_line_options(:without => "lolercoaster")
+          bundle "config set --local without lolercoaster"
+          bundle :install
           expect(the_bundle).to include_gems "activesupport 2.3.5"
-        end
 
-        it "does not install the gem w/ option --without emo lolercoaster" do
-          bundle :install, forgotten_command_line_options(:without => "emo lolercoaster")
+          bundle "config set --local without emo lolercoaster"
+          bundle :install
           expect(the_bundle).not_to include_gems "activesupport 2.3.5"
-        end
 
-        it "does not install the gem w/ option --without 'emo lolercoaster'" do
-          bundle :install, forgotten_command_line_options(:without => "'emo lolercoaster'")
+          bundle "config set --local without 'emo lolercoaster'"
+          bundle :install
           expect(the_bundle).not_to include_gems "activesupport 2.3.5"
         end
       end
@@ -313,12 +327,14 @@ RSpec.describe "bundle install with grou
       end
 
       it "installs gems in the default group" do
-        bundle! :install, forgotten_command_line_options(:without => "emo lolercoaster")
+        bundle "config set --local without emo lolercoaster"
+        bundle :install
         expect(the_bundle).to include_gems "rack 1.0.0"
       end
 
       it "installs the gem if any of its groups are installed" do
-        bundle! :install, forgotten_command_line_options(:without => "emo")
+        bundle "config set --local without emo"
+        bundle :install
         expect(the_bundle).to include_gems "rack 1.0.0", "activesupport 2.3.5"
       end
     end
@@ -333,7 +349,7 @@ RSpec.describe "bundle install with grou
       G
 
       ruby <<-R
-        require "#{lib_dir}/bundler"
+        require "#{entrypoint}"
         Bundler.setup :default
         Bundler.require :default
         puts RACK
@@ -349,19 +365,21 @@ RSpec.describe "bundle install with grou
     end
   end
 
-  describe "when locked and installed with --without" do
+  describe "when locked and installed with `without` option" do
     before(:each) do
       build_repo2
-      system_gems "rack-0.9.1" do
-        install_gemfile <<-G, forgotten_command_line_options(:without => "rack")
-          source "#{file_uri_for(gem_repo2)}"
-          gem "rack"
 
-          group :rack do
-            gem "rack_middleware"
-          end
-        G
-      end
+      system_gems "rack-0.9.1"
+
+      bundle "config set --local without rack"
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "rack"
+
+        group :rack do
+          gem "rack_middleware"
+        end
+      G
     end
 
     it "uses the correct versions even if --without was used on the original" do
@@ -377,7 +395,8 @@ RSpec.describe "bundle install with grou
 
     it "does not hit the remote a second time" do
       FileUtils.rm_rf gem_repo2
-      bundle! :install, forgotten_command_line_options(:without => "rack").merge(:verbose => true)
+      bundle "config set --local without rack"
+      bundle :install, :verbose => true
       expect(last_command.stdboth).not_to match(/fetching/i)
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile/install_if.rb
+++ /dev/null
@@ -1,44 +0,0 @@
-# frozen_string_literal: true
-
-describe "bundle install with install_if conditionals" do
-  it "follows the install_if DSL" do
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
-      install_if(lambda { true }) do
-        gem "activesupport", "2.3.5"
-      end
-      gem "thin", :install_if => false
-      install_if(lambda { false }) do
-        gem "foo"
-      end
-      gem "rack"
-    G
-
-    expect(the_bundle).to include_gems("rack 1.0", "activesupport 2.3.5")
-    expect(the_bundle).not_to include_gems("thin")
-    expect(the_bundle).not_to include_gems("foo")
-
-    lockfile_should_be <<-L
-      GEM
-        remote: #{file_uri_for(gem_repo1)}/
-        specs:
-          activesupport (2.3.5)
-          foo (1.0)
-          rack (1.0.0)
-          thin (1.0)
-            rack
-
-      PLATFORMS
-        ruby
-
-      DEPENDENCIES
-        activesupport (= 2.3.5)
-        foo
-        rack
-        thin
-
-      BUNDLED WITH
-         #{Bundler::VERSION}
-    L
-  end
-end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/install_if_spec.rb
@@ -0,0 +1,44 @@
+# frozen_string_literal: true
+
+RSpec.describe "bundle install with install_if conditionals" do
+  it "follows the install_if DSL" do
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      install_if(lambda { true }) do
+        gem "activesupport", "2.3.5"
+      end
+      gem "thin", :install_if => false
+      install_if(lambda { false }) do
+        gem "foo"
+      end
+      gem "rack"
+    G
+
+    expect(the_bundle).to include_gems("rack 1.0", "activesupport 2.3.5")
+    expect(the_bundle).not_to include_gems("thin")
+    expect(the_bundle).not_to include_gems("foo")
+
+    expect(lockfile).to eq <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
+          activesupport (2.3.5)
+          foo (1.0)
+          rack (1.0.0)
+          thin (1.0)
+            rack
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        activesupport (= 2.3.5)
+        foo
+        rack
+        thin
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile/lockfile_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/lockfile_spec.rb
@@ -16,12 +16,12 @@ RSpec.describe "bundle install with a lo
 
     context "with plugins disabled" do
       before do
-        bundle! "config set plugins false"
+        bundle "config set plugins false"
         subject
       end
 
       it "does not evaluate the gemfile twice" do
-        bundle! :install
+        bundle :install
 
         with_env_vars("BUNDLER_SPEC_NO_APPEND" => "1") { expect(the_bundle).to include_gem "rack 1.0.0" }
 
@@ -31,10 +31,10 @@ RSpec.describe "bundle install with a lo
       end
 
       context "when the gem is not installed" do
-        before { FileUtils.rm_rf ".bundle" }
+        before { FileUtils.rm_rf bundled_app(".bundle") }
 
         it "does not evaluate the gemfile twice" do
-          bundle! :install
+          bundle :install
 
           with_env_vars("BUNDLER_SPEC_NO_APPEND" => "1") { expect(the_bundle).to include_gem "rack 1.0.0" }
 
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile/path_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/path_spec.rb
@@ -16,6 +16,7 @@ RSpec.describe "bundle install with expl
     build_lib "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       path "#{lib_path("foo-1.0")}" do
         gem 'foo'
       end
@@ -28,6 +29,7 @@ RSpec.describe "bundle install with expl
     build_lib "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem 'foo', :path => "#{lib_path("foo-1.0")}"
     G
 
@@ -37,9 +39,10 @@ RSpec.describe "bundle install with expl
   it "supports relative paths" do
     build_lib "foo"
 
-    relative_path = lib_path("foo-1.0").relative_path_from(Pathname.new(Dir.pwd))
+    relative_path = lib_path("foo-1.0").relative_path_from(bundled_app)
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem 'foo', :path => "#{relative_path}"
     G
 
@@ -52,6 +55,7 @@ RSpec.describe "bundle install with expl
     relative_path = lib_path("foo-1.0").relative_path_from(Pathname.new("~").expand_path)
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem 'foo', :path => "~/#{relative_path}"
     G
 
@@ -59,11 +63,14 @@ RSpec.describe "bundle install with expl
   end
 
   it "expands paths raise error with not existing user's home dir" do
+    skip "problems with ~ expansion" if Gem.win_platform?
+
     build_lib "foo"
     username = "some_unexisting_user"
     relative_path = lib_path("foo-1.0").relative_path_from(Pathname.new("/home/#{username}").expand_path)
 
-    install_gemfile <<-G
+    install_gemfile <<-G, :raise_on_error => false
+      source "#{file_uri_for(gem_repo1)}"
       gem 'foo', :path => "~#{username}/#{relative_path}"
     G
     expect(err).to match("There was an error while trying to use the path `~#{username}/#{relative_path}`.")
@@ -74,13 +81,11 @@ RSpec.describe "bundle install with expl
     build_lib "foo", :path => bundled_app("foo-1.0")
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem 'foo', :path => "./foo-1.0"
     G
 
-    bundled_app("subdir").mkpath
-    Dir.chdir(bundled_app("subdir")) do
-      expect(the_bundle).to include_gems("foo 1.0")
-    end
+    expect(the_bundle).to include_gems("foo 1.0", :dir => bundled_app("subdir").mkpath)
   end
 
   it "sorts paths consistently on install and update when they start with ./" do
@@ -88,6 +93,7 @@ RSpec.describe "bundle install with expl
     build_lib "aaa", :path => lib_path("demo/aaa")
 
     gemfile = <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gemspec
       gem "aaa", :path => "./aaa"
     G
@@ -106,6 +112,7 @@ RSpec.describe "bundle install with expl
           aaa (1.0)
 
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       PLATFORMS
@@ -119,23 +126,22 @@ RSpec.describe "bundle install with expl
          #{Bundler::VERSION}
     L
 
-    Dir.chdir(lib_path("demo")) do
-      bundle :install
-      expect(lib_path("demo/Gemfile.lock")).to have_lockfile(lockfile)
-      bundle :update, :all => true
-      expect(lib_path("demo/Gemfile.lock")).to have_lockfile(lockfile)
-    end
+    bundle :install, :dir => lib_path("demo")
+    expect(lib_path("demo/Gemfile.lock")).to read_as(lockfile)
+    bundle :update, :all => true, :dir => lib_path("demo")
+    expect(lib_path("demo/Gemfile.lock")).to read_as(lockfile)
   end
 
   it "expands paths when comparing locked paths to Gemfile paths" do
     build_lib "foo", :path => bundled_app("foo-1.0")
 
     install_gemfile <<-G
-      gem 'foo', :path => File.expand_path("../foo-1.0", __FILE__)
+      source "#{file_uri_for(gem_repo1)}"
+      gem 'foo', :path => File.expand_path("foo-1.0", __dir__)
     G
 
-    bundle! :install, forgotten_command_line_options(:frozen => true)
-    expect(exitstatus).to eq(0) if exitstatus
+    bundle "config set --local frozen true"
+    bundle :install
   end
 
   it "installs dependencies from the path even if a newer gem is available elsewhere" do
@@ -170,22 +176,90 @@ RSpec.describe "bundle install with expl
     build_lib "foo", "1.0.0", :path => lib_path("omg/foo")
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "omg", :path => "#{lib_path("omg")}"
     G
 
     expect(the_bundle).to include_gems "foo 1.0"
   end
 
-  it "works with only_update_to_newer_versions" do
+  it "works when using prereleases of 0.0.0" do
+    build_lib "foo", "0.0.0.dev", :path => lib_path("foo")
+
+    gemfile <<~G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "foo", :path => "#{lib_path("foo")}"
+    G
+
+    lockfile <<~L
+      PATH
+        remote: #{lib_path("foo")}
+        specs:
+          foo (0.0.0.dev)
+
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        foo!
+
+      BUNDLED WITH
+        #{Bundler::VERSION}
+    L
+
+    bundle :install
+
+    expect(the_bundle).to include_gems "foo 0.0.0.dev"
+  end
+
+  it "works when using uppercase prereleases of 0.0.0" do
+    build_lib "foo", "0.0.0.SNAPSHOT", :path => lib_path("foo")
+
+    gemfile <<~G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "foo", :path => "#{lib_path("foo")}"
+    G
+
+    lockfile <<~L
+      PATH
+        remote: #{lib_path("foo")}
+        specs:
+          foo (0.0.0.SNAPSHOT)
+
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        foo!
+
+      BUNDLED WITH
+        #{Bundler::VERSION}
+    L
+
+    bundle :install
+
+    expect(the_bundle).to include_gems "foo 0.0.0.SNAPSHOT"
+  end
+
+  it "handles downgrades" do
     build_lib "omg", "2.0", :path => lib_path("omg")
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "omg", :path => "#{lib_path("omg")}"
     G
 
     build_lib "omg", "1.0", :path => lib_path("omg")
 
-    bundle! :install, :env => { "BUNDLE_BUNDLE_ONLY_UPDATE_TO_NEWER_VERSIONS" => "true" }
+    bundle :install
 
     expect(the_bundle).to include_gems "omg 1.0"
   end
@@ -203,6 +277,7 @@ RSpec.describe "bundle install with expl
     end
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "premailer", :path => "#{lib_path("premailer")}"
     G
 
@@ -223,11 +298,11 @@ RSpec.describe "bundle install with expl
       G
     end
 
-    install_gemfile <<-G
+    install_gemfile <<-G, :raise_on_error => false
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => "#{lib_path("foo-1.0")}"
     G
 
-    expect(err).to_not include("ERROR REPORT")
     expect(err).to_not include("Your Gemfile has no gem server sources.")
     expect(err).to match(/is not valid. Please fix this gemspec./)
     expect(err).to match(/The validation error was 'missing value for attribute version'/)
@@ -246,11 +321,9 @@ RSpec.describe "bundle install with expl
 
     File.open(lib_path("foo/Gemfile"), "w") {|f| f.puts gemfile }
 
-    Dir.chdir(lib_path("foo")) do
-      bundle "install"
-      expect(the_bundle).to include_gems "foo 1.0"
-      expect(the_bundle).to include_gems "rack 1.0"
-    end
+    bundle "install", :dir => lib_path("foo")
+    expect(the_bundle).to include_gems "foo 1.0", :dir => lib_path("foo")
+    expect(the_bundle).to include_gems "rack 1.0", :dir => lib_path("foo")
   end
 
   it "supports gemspec syntax with an alternative path" do
@@ -272,19 +345,17 @@ RSpec.describe "bundle install with expl
       s.add_dependency "rack", ">= 1.0"
     end
 
-    Dir.chdir lib_path("foo")
-
-    install_gemfile lib_path("foo/Gemfile"), <<-G
+    install_gemfile lib_path("foo/Gemfile"), <<-G, :dir => lib_path("foo")
       source "#{file_uri_for(gem_repo1)}"
       gemspec
     G
 
     build_gem "rack", "1.0.1", :to_system => true
 
-    bundle "install"
+    bundle "install", :dir => lib_path("foo")
 
-    expect(the_bundle).to include_gems "foo 1.0"
-    expect(the_bundle).to include_gems "rack 1.0"
+    expect(the_bundle).to include_gems "foo 1.0", :dir => lib_path("foo")
+    expect(the_bundle).to include_gems "rack 1.0", :dir => lib_path("foo")
   end
 
   it "doesn't automatically unlock dependencies when using the gemspec syntax and the gem has development dependencies" do
@@ -293,19 +364,17 @@ RSpec.describe "bundle install with expl
       s.add_development_dependency "activesupport"
     end
 
-    Dir.chdir lib_path("foo")
-
-    install_gemfile lib_path("foo/Gemfile"), <<-G
+    install_gemfile lib_path("foo/Gemfile"), <<-G, :dir => lib_path("foo")
       source "#{file_uri_for(gem_repo1)}"
       gemspec
     G
 
     build_gem "rack", "1.0.1", :to_system => true
 
-    bundle "install"
+    bundle "install", :dir => lib_path("foo")
 
-    expect(the_bundle).to include_gems "foo 1.0"
-    expect(the_bundle).to include_gems "rack 1.0"
+    expect(the_bundle).to include_gems "foo 1.0", :dir => lib_path("foo")
+    expect(the_bundle).to include_gems "rack 1.0", :dir => lib_path("foo")
   end
 
   it "raises if there are multiple gemspecs" do
@@ -313,11 +382,12 @@ RSpec.describe "bundle install with expl
       s.write "bar.gemspec", build_spec("bar", "1.0").first.to_ruby
     end
 
-    install_gemfile <<-G
+    install_gemfile <<-G, :raise_on_error => false
+      source "#{file_uri_for(gem_repo1)}"
       gemspec :path => "#{lib_path("foo")}"
     G
 
-    expect(exitstatus).to eq(15) if exitstatus
+    expect(exitstatus).to eq(15)
     expect(err).to match(/There are multiple gemspecs/)
   end
 
@@ -327,6 +397,7 @@ RSpec.describe "bundle install with expl
     end
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gemspec :path => "#{lib_path("foo")}", :name => "foo"
     G
 
@@ -338,11 +409,13 @@ RSpec.describe "bundle install with expl
       s.executables = "foobar"
     end
 
-    install_gemfile <<-G
+    install_gemfile <<-G, :verbose => true
+      source "#{file_uri_for(gem_repo1)}"
       path "#{lib_path("foo-1.0")}" do
         gem 'foo'
       end
     G
+    expect(out).to include("Using foo 1.0 from source at `#{lib_path("foo-1.0")}` and installing its executables")
     expect(the_bundle).to include_gems "foo 1.0"
 
     bundle "exec foobar"
@@ -355,6 +428,7 @@ RSpec.describe "bundle install with expl
     lib_path("foo-1.0").join("bin/performance").mkpath
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem 'foo', '1.0', :path => "#{lib_path("foo-1.0")}"
     G
     expect(err).to be_empty
@@ -364,6 +438,7 @@ RSpec.describe "bundle install with expl
     build_lib "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem 'foo', :path => "#{lib_path("foo-1.0")}"
     G
 
@@ -376,6 +451,7 @@ RSpec.describe "bundle install with expl
       build_lib "hi2u"
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         path "#{lib_path}" do
           gem "omg"
           gem "hi2u"
@@ -394,6 +470,7 @@ RSpec.describe "bundle install with expl
     end
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => "#{lib_path("foo")}"
       gem "omg", :path => "#{lib_path("omg")}"
     G
@@ -405,6 +482,7 @@ RSpec.describe "bundle install with expl
     build_lib "foo", :gemspec => false
 
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", "1.0", :path => "#{lib_path("foo-1.0")}"
     G
 
@@ -420,15 +498,15 @@ RSpec.describe "bundle install with expl
         specs:
 
       GEM
-        remote: http://rubygems.org
+        remote: http://rubygems.org/
     L
 
-    in_app_root { FileUtils.mkdir_p("vendor/bar") }
+    FileUtils.mkdir_p(bundled_app("vendor/bar"))
 
     install_gemfile <<-G
+      source "http://rubygems.org"
       gem "bar", "1.0.0", path: "vendor/bar", require: "bar/nyard"
     G
-    expect(exitstatus).to eq(0) if exitstatus
   end
 
   context "existing lockfile" do
@@ -471,6 +549,7 @@ RSpec.describe "bundle install with expl
     end
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => "#{lib_path("foo-1.0")}"
     G
 
@@ -486,6 +565,7 @@ RSpec.describe "bundle install with expl
       build_lib "bar", "1.0", :path => lib_path("foo/bar")
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :path => "#{lib_path("foo")}"
       G
     end
@@ -538,7 +618,7 @@ RSpec.describe "bundle install with expl
 
       expect(the_bundle).to include_gems "rack 0.9.1"
 
-      lockfile_should_be <<-G
+      expect(lockfile).to eq <<~G
         PATH
           remote: #{lib_path("foo")}
           specs:
@@ -566,7 +646,7 @@ RSpec.describe "bundle install with expl
 
       bundle "install"
 
-      lockfile_should_be <<-G
+      expect(lockfile).to eq <<~G
         PATH
           remote: #{lib_path("foo")}
           specs:
@@ -590,6 +670,71 @@ RSpec.describe "bundle install with expl
 
       expect(the_bundle).to include_gems "rack 0.9.1"
     end
+
+    it "keeps using the same version even when another dependency is added" do
+      build_lib "foo", "1.0", :path => lib_path("foo") do |s|
+        s.add_dependency "rack", "0.9.1"
+      end
+
+      bundle "install"
+
+      expect(the_bundle).to include_gems "rack 0.9.1"
+
+      expect(lockfile).to eq <<~G
+        PATH
+          remote: #{lib_path("foo")}
+          specs:
+            foo (1.0)
+              rack (= 0.9.1)
+
+        GEM
+          remote: #{file_uri_for(gem_repo1)}/
+          specs:
+            rack (0.9.1)
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          foo!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      G
+
+      build_lib "foo", "1.0", :path => lib_path("foo") do |s|
+        s.add_dependency "rack"
+        s.add_dependency "rake", "13.0.1"
+      end
+
+      bundle "install"
+
+      expect(lockfile).to eq <<~G
+        PATH
+          remote: #{lib_path("foo")}
+          specs:
+            foo (1.0)
+              rack
+              rake (= 13.0.1)
+
+        GEM
+          remote: #{file_uri_for(gem_repo1)}/
+          specs:
+            rack (0.9.1)
+            rake (13.0.1)
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          foo!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      G
+
+      expect(the_bundle).to include_gems "rack 0.9.1"
+    end
   end
 
   describe "switching sources" do
@@ -617,7 +762,7 @@ RSpec.describe "bundle install with expl
 
     it "switches the source when the gem existed in rubygems and the path was already being used for another gem" do
       build_lib "foo", "1.0", :path => lib_path("foo")
-      build_gem "bar", "1.0", :to_system => true do |s|
+      build_gem "bar", "1.0", :to_bundle => true do |s|
         s.write "lib/bar.rb", "raise 'fail'"
       end
 
@@ -653,13 +798,11 @@ RSpec.describe "bundle install with expl
       G
       File.open(lib_path("private_lib/Gemfile"), "w") {|f| f.puts gemfile }
 
-      Dir.chdir(lib_path("private_lib")) do
-        bundle :install, :env => { "DEBUG" => "1" }, :artifice => "endpoint"
-        expect(out).to match(%r{^HTTP GET http://localgemserver\.test/api/v1/dependencies\?gems=rack$})
-        expect(out).not_to match(/^HTTP GET.*private_lib/)
-        expect(the_bundle).to include_gems "private_lib 2.2"
-        expect(the_bundle).to include_gems "rack 1.0"
-      end
+      bundle :install, :env => { "DEBUG" => "1" }, :artifice => "endpoint", :dir => lib_path("private_lib")
+      expect(out).to match(%r{^HTTP GET http://localgemserver\.test/api/v1/dependencies\?gems=rack$})
+      expect(out).not_to match(/^HTTP GET.*private_lib/)
+      expect(the_bundle).to include_gems "private_lib 2.2", :dir => lib_path("private_lib")
+      expect(the_bundle).to include_gems "rack 1.0", :dir => lib_path("private_lib")
     end
   end
 
@@ -667,6 +810,7 @@ RSpec.describe "bundle install with expl
     it "runs pre-install hooks" do
       build_git "foo"
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
 
@@ -686,6 +830,7 @@ RSpec.describe "bundle install with expl
     it "runs post-install hooks" do
       build_git "foo"
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
 
@@ -705,6 +850,7 @@ RSpec.describe "bundle install with expl
     it "complains if the install hook fails" do
       build_git "foo"
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       G
 
@@ -716,8 +862,7 @@ RSpec.describe "bundle install with expl
         H
       end
 
-      bundle :install,
-        :requires => [lib_path("install_hooks.rb")]
+      bundle :install, :requires => [lib_path("install_hooks.rb")], :raise_on_error => false
       expect(err).to include("failed for foo-1.0")
     end
 
@@ -728,14 +873,15 @@ RSpec.describe "bundle install with expl
       expect(bar_file).not_to be_file
 
       build_lib "foo" do |s|
-        s.write("lib/rubygems_plugin.rb", "FileUtils.touch('#{foo_file}')")
+        s.write("lib/rubygems_plugin.rb", "require 'fileutils'; FileUtils.touch('#{foo_file}')")
       end
 
       build_git "bar" do |s|
-        s.write("lib/rubygems_plugin.rb", "FileUtils.touch('#{bar_file}')")
+        s.write("lib/rubygems_plugin.rb", "require 'fileutils'; FileUtils.touch('#{bar_file}')")
       end
 
-      install_gemfile! <<-G
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :path => "#{lib_path("foo-1.0")}"
         gem "bar", :path => "#{lib_path("bar-1.0")}"
       G
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile/platform_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/platform_spec.rb
@@ -50,27 +50,53 @@ RSpec.describe "bundle install across pl
     expect(the_bundle).to include_gems "platform_specific 1.0 JAVA"
   end
 
-  it "works with gems that have different dependencies" do
-    simulate_platform "java"
+  it "pulls the pure ruby version on jruby if the java platform is not present in the lockfile and bundler is run in frozen mode", :jruby_only do
+    lockfile <<-G
+      GEM
+        remote: #{file_uri_for(gem_repo1)}
+        specs:
+          platform_specific (1.0)
+
+      PLATFORMS
+        ruby
+
+      DEPENDENCIES
+        platform_specific
+    G
+
+    bundle "config set --local frozen true"
+
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
 
-      gem "nokogiri"
+      gem "platform_specific"
     G
 
-    expect(the_bundle).to include_gems "nokogiri 1.4.2 JAVA", "weakling 0.0.3"
-
-    simulate_new_machine
+    expect(the_bundle).to include_gems "platform_specific 1.0 RUBY"
+  end
 
-    simulate_platform "ruby"
+  it "works with gems that have different dependencies" do
+    simulate_platform "java"
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
 
       gem "nokogiri"
     G
 
+    expect(the_bundle).to include_gems "nokogiri 1.4.2 JAVA", "weakling 0.0.3"
+
+    simulate_new_machine
+    bundle "config set --local force_ruby_platform true"
+    bundle "install"
+
     expect(the_bundle).to include_gems "nokogiri 1.4.2"
     expect(the_bundle).not_to include_gems "weakling"
+
+    simulate_new_machine
+    simulate_platform "java"
+    bundle "install"
+
+    expect(the_bundle).to include_gems "nokogiri 1.4.2 JAVA", "weakling 0.0.3"
   end
 
   it "does not keep unneeded platforms for gems that are used" do
@@ -95,14 +121,14 @@ RSpec.describe "bundle install across pl
 
     simulate_platform java
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo4)}"
 
       gem "empyrean", "0.1.0"
       gem "pry"
     G
 
-    lockfile_should_be <<-L
+    expect(lockfile).to eq <<~L
       GEM
         remote: #{file_uri_for(gem_repo4)}/
         specs:
@@ -128,9 +154,9 @@ RSpec.describe "bundle install across pl
          #{Bundler::VERSION}
     L
 
-    bundle! "lock --add-platform ruby"
+    bundle "lock --add-platform ruby"
 
-    good_lockfile = strip_whitespace(<<-L)
+    good_lockfile = <<~L
       GEM
         remote: #{file_uri_for(gem_repo4)}/
         specs:
@@ -160,9 +186,9 @@ RSpec.describe "bundle install across pl
          #{Bundler::VERSION}
     L
 
-    lockfile_should_be good_lockfile
+    expect(lockfile).to eq good_lockfile
 
-    bad_lockfile = strip_whitespace <<-L
+    bad_lockfile = <<~L
       GEM
         remote: #{file_uri_for(gem_repo4)}/
         specs:
@@ -190,70 +216,59 @@ RSpec.describe "bundle install across pl
         pry
 
       BUNDLED WITH
-        #{Bundler::VERSION}
+         1.16.1
     L
 
     aggregate_failures do
       lockfile bad_lockfile
-      bundle! :install
-      lockfile_should_be good_lockfile
+      bundle :install, :env => { "BUNDLER_VERSION" => Bundler::VERSION }
+      expect(lockfile).to eq good_lockfile
 
       lockfile bad_lockfile
-      bundle! :update, :all => true
-      lockfile_should_be good_lockfile
+      bundle :update, :all => true, :env => { "BUNDLER_VERSION" => Bundler::VERSION }
+      expect(lockfile).to eq good_lockfile
 
       lockfile bad_lockfile
-      bundle! "update ffi"
-      lockfile_should_be good_lockfile
+      bundle "update ffi", :env => { "BUNDLER_VERSION" => Bundler::VERSION }
+      expect(lockfile).to eq good_lockfile
 
       lockfile bad_lockfile
-      bundle! "update empyrean"
-      lockfile_should_be good_lockfile
+      bundle "update empyrean", :env => { "BUNDLER_VERSION" => Bundler::VERSION }
+      expect(lockfile).to eq good_lockfile
 
       lockfile bad_lockfile
-      bundle! :lock
-      lockfile_should_be good_lockfile
+      bundle :lock, :env => { "BUNDLER_VERSION" => Bundler::VERSION }
+      expect(lockfile).to eq good_lockfile
     end
   end
 
-  it "works the other way with gems that have different dependencies" do
-    simulate_platform "ruby"
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
-
-      gem "nokogiri"
-    G
-
-    simulate_platform "java"
-    bundle "install"
-
-    expect(the_bundle).to include_gems "nokogiri 1.4.2 JAVA", "weakling 0.0.3"
-  end
-
-  it "works with gems that have extra platform-specific runtime dependencies", :bundler => "< 3" do
+  it "works with gems with platform-specific dependency having different requirements order" do
     simulate_platform x64_mac
 
     update_repo2 do
-      build_gem "facter", "2.4.6"
-      build_gem "facter", "2.4.6" do |s|
+      build_gem "fspath", "3"
+      build_gem "image_optim_pack", "1.2.3" do |s|
+        s.add_runtime_dependency "fspath", ">= 2.1", "< 4"
+      end
+      build_gem "image_optim_pack", "1.2.3" do |s|
         s.platform = "universal-darwin"
-        s.add_runtime_dependency "CFPropertyList"
+        s.add_runtime_dependency "fspath", "< 4", ">= 2.1"
       end
-      build_gem "CFPropertyList"
     end
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo2)}"
+    G
 
-      gem "facter"
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo2)}"
+
+      gem "image_optim_pack"
     G
 
-    expect(err).to include "Unable to use the platform-specific (universal-darwin) version of facter (2.4.6) " \
-      "because it has different dependencies from the ruby version. " \
-      "To use the platform-specific version of the gem, run `bundle config set specific_platform true` and install again."
+    expect(err).not_to include "Unable to use the platform-specific"
 
-    expect(the_bundle).to include_gem "facter 2.4.6"
-    expect(the_bundle).not_to include_gem "CFPropertyList"
+    expect(the_bundle).to include_gem "image_optim_pack 1.2.3 universal-darwin"
   end
 
   it "fetches gems again after changing the version of Ruby" do
@@ -263,13 +278,56 @@ RSpec.describe "bundle install across pl
       gem "rack", "1.0.0"
     G
 
-    bundle! :install, forgotten_command_line_options(:path => "vendor/bundle")
+    bundle "config set --local path vendor/bundle"
+    bundle :install
 
     FileUtils.mv(vendored_gems, bundled_app("vendor/bundle", Gem.ruby_engine, "1.8"))
 
-    bundle! :install
+    bundle :install
     expect(vendored_gems("gems/rack-1.0.0")).to exist
   end
+
+  it "keeps existing platforms when installing with force_ruby_platform" do
+    lockfile <<-G
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
+          platform_specific (1.0-java)
+
+      PLATFORMS
+        java
+
+      DEPENDENCIES
+        platform_specific
+    G
+
+    bundle "config set --local force_ruby_platform true"
+
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "platform_specific"
+    G
+
+    expect(the_bundle).to include_gem "platform_specific 1.0 RUBY"
+
+    expect(lockfile).to eq <<~G
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
+          platform_specific (1.0)
+          platform_specific (1.0-java)
+
+      PLATFORMS
+        java
+        ruby
+
+      DEPENDENCIES
+        platform_specific
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    G
+  end
 end
 
 RSpec.describe "bundle install with platform conditionals" do
@@ -298,6 +356,49 @@ RSpec.describe "bundle install with plat
     expect(the_bundle).not_to include_gems "nokogiri 1.4.2"
   end
 
+  it "installs gems tagged w/ another platform but also dependent on the current one transitively" do
+    build_repo4 do
+      build_gem "activesupport", "6.1.4.1" do |s|
+        s.add_dependency "tzinfo", "~> 2.0"
+      end
+
+      build_gem "tzinfo", "2.0.4"
+    end
+
+    gemfile <<~G
+      source "#{file_uri_for(gem_repo4)}"
+
+      gem "activesupport"
+
+      platforms :#{not_local_tag} do
+        gem "tzinfo", "~> 1.2"
+      end
+    G
+
+    lockfile <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          activesupport (6.1.4.1)
+            tzinfo (~> 2.0)
+          tzinfo (2.0.4)
+
+      PLATFORMS
+        #{specific_local_platform}
+
+      DEPENDENCIES
+        activesupport
+        tzinfo (~> 1.2)
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    bundle "install --verbose"
+
+    expect(the_bundle).to include_gems "tzinfo 2.0.4"
+  end
+
   it "installs gems tagged w/ the current platforms inline" do
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
@@ -336,18 +437,17 @@ RSpec.describe "bundle install with plat
     build_git "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       platform :#{not_local_tag} do
         gem "foo", :git => "#{lib_path("foo-1.0")}"
       end
     G
 
     bundle :list
-    expect(exitstatus).to eq(0) if exitstatus
   end
 
   it "does not attempt to install gems from :rbx when using --local" do
-    simulate_platform "ruby"
-    simulate_ruby_engine "ruby"
+    bundle "config set --local force_ruby_platform true"
 
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
@@ -359,59 +459,57 @@ RSpec.describe "bundle install with plat
   end
 
   it "does not attempt to install gems from other rubies when using --local" do
-    simulate_platform "ruby"
-    simulate_ruby_engine "ruby"
-    other_ruby_version_tag = RUBY_VERSION =~ /^1\.8/ ? :ruby_19 : :ruby_18
-
+    bundle "config set --local force_ruby_platform true"
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
-      gem "some_gem", platform: :#{other_ruby_version_tag}
+      gem "some_gem", platform: :ruby_22
     G
 
     bundle "install --local"
     expect(out).not_to match(/Could not find gem 'some_gem/)
   end
 
-  it "prints a helpful warning when a dependency is unused on any platform" do
-    simulate_platform "ruby"
-    simulate_ruby_engine "ruby"
+  it "does not print a warning when a dependency is unused on a platform different from the current one" do
+    bundle "config set --local force_ruby_platform true"
 
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
 
-      gem "rack", :platform => [:mingw, :mswin, :x64_mingw, :jruby]
+      gem "rack", :platform => [:windows, :mingw, :mswin, :x64_mingw, :jruby]
     G
 
-    bundle! "install"
-
-    expect(err).to include <<-O.strip
-The dependency #{Gem::Dependency.new("rack", ">= 0")} will be unused by any of the platforms Bundler is installing for. Bundler is installing for ruby but the dependency is only for x86-mingw32, x86-mswin32, x64-mingw32, java. To add those platforms to the bundle, run `bundle lock --add-platform x86-mingw32 x86-mswin32 x64-mingw32 java`.
-    O
-  end
-
-  context "when disable_platform_warnings is true" do
-    before { bundle! "config set disable_platform_warnings true" }
+    bundle "install"
 
-    it "does not print the warning when a dependency is unused on any platform" do
-      simulate_platform "ruby"
-      simulate_ruby_engine "ruby"
+    expect(err).to be_empty
 
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
+    expect(lockfile).to eq <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
 
-        gem "rack", :platform => [:mingw, :mswin, :x64_mingw, :jruby]
-      G
+      PLATFORMS
+        ruby
 
-      bundle! "install"
+      DEPENDENCIES
+        rack
 
-      expect(out).not_to match(/The dependency (.*) will be unused/)
-    end
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
   end
 end
 
 RSpec.describe "when a gem has no architecture" do
   it "still installs correctly" do
-    simulate_platform mswin
+    simulate_platform x86_mswin32
+
+    build_repo2 do
+      # The rcov gem is platform mswin32, but has no arch
+      build_gem "rcov" do |s|
+        s.platform = Gem::Platform.new([nil, "mswin32", nil])
+        s.write "lib/rcov.rb", "RCOV = '1.0.0'"
+      end
+    end
 
     gemfile <<-G
       # Try to install gem with nil arch
@@ -419,7 +517,7 @@ RSpec.describe "when a gem has no archit
       gem "rcov"
     G
 
-    bundle :install, :artifice => "windows"
+    bundle :install, :artifice => "windows", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
     expect(the_bundle).to include_gems "rcov 1.0.0"
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile/ruby_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/ruby_spec.rb
@@ -2,34 +2,33 @@
 
 RSpec.describe "ruby requirement" do
   def locked_ruby_version
-    Bundler::RubyVersion.from_string(Bundler::LockfileParser.new(lockfile).ruby_version)
+    Bundler::RubyVersion.from_string(Bundler::LockfileParser.new(File.read(bundled_app_lock)).ruby_version)
   end
 
-  # As discovered by https://github.com/bundler/bundler/issues/4147, there is
+  # As discovered by https://github.com/rubygems/bundler/issues/4147, there is
   # no test coverage to ensure that adding a gem is possible with a ruby
   # requirement. This test verifies the fix, committed in bfbad5c5.
   it "allows adding gems" do
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
-      ruby "#{RUBY_VERSION}"
+      ruby "#{Gem.ruby_version}"
       gem "rack"
     G
 
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
-      ruby "#{RUBY_VERSION}"
+      ruby "#{Gem.ruby_version}"
       gem "rack"
       gem "rack-obama"
     G
 
-    expect(exitstatus).to eq(0) if exitstatus
     expect(the_bundle).to include_gems "rack-obama 1.0"
   end
 
   it "allows removing the ruby version requirement" do
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
-      ruby "~> #{RUBY_VERSION}"
+      ruby "~> #{Gem.ruby_version}"
       gem "rack"
     G
 
@@ -47,17 +46,16 @@ RSpec.describe "ruby requirement" do
   it "allows changing the ruby version requirement to something compatible" do
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
-      ruby ">= 1.0.0"
+      ruby ">= #{current_ruby_minor}"
       gem "rack"
     G
 
+    allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
     expect(locked_ruby_version).to eq(Bundler::RubyVersion.system)
 
-    simulate_ruby_version "5100"
-
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
-      ruby ">= 1.0.1"
+      ruby ">= #{Gem.ruby_version}"
       gem "rack"
     G
 
@@ -72,24 +70,41 @@ RSpec.describe "ruby requirement" do
       gem "rack"
     G
 
-    expect(locked_ruby_version).to eq(Bundler::RubyVersion.system)
+    lockfile <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
+          rack (1.0.0)
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        rack
 
-    simulate_ruby_version "5100"
+      RUBY VERSION
+         ruby 2.1.4p422
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
 
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
-      ruby ">= 5000.0"
+      ruby ">= #{current_ruby_minor}"
       gem "rack"
     G
 
     expect(the_bundle).to include_gems "rack 1.0.0"
-    expect(locked_ruby_version.versions).to eq(["5100"])
+    expect(locked_ruby_version).to eq(Bundler::RubyVersion.system)
   end
 
   it "allows requirements with trailing whitespace" do
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
-      ruby "#{RUBY_VERSION}\\n \t\\n"
+      ruby "#{Gem.ruby_version}\\n \t\\n"
       gem "rack"
     G
 
@@ -97,7 +112,7 @@ RSpec.describe "ruby requirement" do
   end
 
   it "fails gracefully with malformed requirements" do
-    install_gemfile <<-G
+    install_gemfile <<-G, :raise_on_error => false
       source "#{file_uri_for(gem_repo1)}"
       ruby ">= 0", "-.\\0"
       gem "rack"
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile/sources_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/sources_spec.rb
@@ -15,56 +15,56 @@ RSpec.describe "bundle install with gems
       end
     end
 
-    context "with multiple toplevel sources", :bundler => "< 3" do
+    context "with multiple toplevel sources" do
       let(:repo3_rack_version) { "1.0.0" }
 
       before do
         gemfile <<-G
-          source "#{file_uri_for(gem_repo3)}"
-          source "#{file_uri_for(gem_repo1)}"
+          source "https://gem.repo3"
+          source "https://gem.repo1"
           gem "rack-obama"
           gem "rack"
         G
       end
 
-      it "warns about ambiguous gems, but installs anyway, prioritizing sources last to first", :bundler => "2" do
-        bundle :install
+      it "warns about ambiguous gems, but installs anyway, prioritizing sources last to first", :bundler => "< 3" do
+        bundle :install, :artifice => "compact_index"
 
         expect(err).to include("Warning: the gem 'rack' was found in multiple sources.")
-        expect(err).to include("Installed from: #{file_uri_for(gem_repo1)}")
+        expect(err).to include("Installed from: https://gem.repo1")
         expect(the_bundle).to include_gems("rack-obama 1.0.0", "rack 1.0.0", :source => "remote1")
       end
 
       it "fails", :bundler => "3" do
-        bundle :install
+        bundle :instal, :artifice => "compact_index", :raise_on_error => false
         expect(err).to include("Each source after the first must include a block")
-        expect(exitstatus).to eq(4) if exitstatus
+        expect(exitstatus).to eq(4)
       end
     end
 
-    context "when different versions of the same gem are in multiple sources", :bundler => "< 3" do
+    context "when different versions of the same gem are in multiple sources" do
       let(:repo3_rack_version) { "1.2" }
 
       before do
         gemfile <<-G
-          source "#{file_uri_for(gem_repo3)}"
-          source "#{file_uri_for(gem_repo1)}"
+          source "https://gem.repo3"
+          source "https://gem.repo1"
           gem "rack-obama"
           gem "rack", "1.0.0" # force it to install the working version in repo1
         G
-
-        bundle :install
       end
 
-      it "warns about ambiguous gems, but installs anyway", :bundler => "2" do
+      it "warns about ambiguous gems, but installs anyway", :bundler => "< 3" do
+        bundle :install, :artifice => "compact_index"
         expect(err).to include("Warning: the gem 'rack' was found in multiple sources.")
-        expect(err).to include("Installed from: #{file_uri_for(gem_repo1)}")
+        expect(err).to include("Installed from: https://gem.repo1")
         expect(the_bundle).to include_gems("rack-obama 1.0.0", "rack 1.0.0", :source => "remote1")
       end
 
       it "fails", :bundler => "3" do
+        bundle :install, :artifice => "compact_index", :raise_on_error => false
         expect(err).to include("Each source after the first must include a block")
-        expect(exitstatus).to eq(4) if exitstatus
+        expect(exitstatus).to eq(4)
       end
     end
   end
@@ -85,29 +85,30 @@ RSpec.describe "bundle install with gems
         end
 
         gemfile <<-G
-          source "#{file_uri_for(gem_repo3)}"
-          source "#{file_uri_for(gem_repo1)}" do
+          source "https://gem.repo3"
+          source "https://gem.repo1" do
             gem "thin" # comes first to test name sorting
             gem "rack"
           end
-          gem "rack-obama" # shoud come from repo3!
+          gem "rack-obama" # should come from repo3!
         G
       end
 
       it "installs the gems without any warning" do
-        bundle! :install
-        expect(out).not_to include("Warning")
+        bundle :install, :artifice => "compact_index"
+        expect(err).not_to include("Warning")
         expect(the_bundle).to include_gems("rack-obama 1.0.0")
         expect(the_bundle).to include_gems("rack 1.0.0", :source => "remote1")
       end
 
       it "can cache and deploy" do
-        bundle! :cache
+        bundle :cache, :artifice => "compact_index"
 
         expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
         expect(bundled_app("vendor/cache/rack-obama-1.0.gem")).to exist
 
-        bundle! :install, forgotten_command_line_options(:deployment => true)
+        bundle "config set --local deployment true"
+        bundle :install, :artifice => "compact_index"
 
         expect(the_bundle).to include_gems("rack-obama 1.0.0", "rack 1.0.0")
       end
@@ -127,258 +128,813 @@ RSpec.describe "bundle install with gems
           end
         end
 
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo3)}"
+        install_gemfile <<-G, :artifice => "compact_index"
+          source "https://gem.repo3"
           gem "rack-obama" # should come from repo3!
-          gem "rack", :source => "#{file_uri_for(gem_repo1)}"
+          gem "rack", :source => "https://gem.repo1"
         G
       end
 
       it "installs the gems without any warning" do
-        bundle :install
-        expect(out).not_to include("Warning")
+        expect(err).not_to include("Warning")
         expect(the_bundle).to include_gems("rack-obama 1.0.0", "rack 1.0.0")
       end
     end
 
-    context "when a pinned gem has an indirect dependency" do
+    context "when a pinned gem has an indirect dependency in the pinned source" do
       before do
         build_repo gem_repo3 do
           build_gem "depends_on_rack", "1.0.1" do |s|
             s.add_dependency "rack"
           end
         end
+
+        # we need a working rack gem in repo3
+        update_repo gem_repo3 do
+          build_gem "rack", "1.0.0"
+        end
+
+        gemfile <<-G
+          source "https://gem.repo2"
+          source "https://gem.repo3" do
+            gem "depends_on_rack"
+          end
+        G
       end
 
-      context "when the indirect dependency is in the pinned source" do
+      context "and not in any other sources" do
         before do
-          # we need a working rack gem in repo3
-          update_repo gem_repo3 do
-            build_gem "rack", "1.0.0"
-          end
+          build_repo(gem_repo2) {}
+        end
 
-          gemfile <<-G
-            source "#{file_uri_for(gem_repo2)}"
-            source "#{file_uri_for(gem_repo3)}" do
-              gem "depends_on_rack"
-            end
-          G
+        it "installs from the same source without any warning" do
+          bundle :install, :artifice => "compact_index"
+          expect(err).not_to include("Warning")
+          expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0", :source => "remote3")
         end
+      end
 
-        context "and not in any other sources" do
-          before do
-            build_repo(gem_repo2) {}
+      context "and in another source" do
+        before do
+          # need this to be broken to check for correct source ordering
+          build_repo gem_repo2 do
+            build_gem "rack", "1.0.0" do |s|
+              s.write "lib/rack.rb", "RACK = 'FAIL'"
+            end
           end
+        end
 
-          it "installs from the same source without any warning" do
-            bundle :install
-            expect(out).not_to include("Warning")
-            expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0")
-          end
+        it "installs from the same source without any warning" do
+          bundle :install, :artifice => "compact_index"
+
+          expect(err).not_to include("Warning: the gem 'rack' was found in multiple sources.")
+          expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0", :source => "remote3")
+
+          # In https://github.com/bundler/bundler/issues/3585 this failed
+          # when there is already a lock file, and the gems are missing, so try again
+          system_gems []
+          bundle :install, :artifice => "compact_index"
+
+          expect(err).not_to include("Warning: the gem 'rack' was found in multiple sources.")
+          expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0", :source => "remote3")
         end
+      end
+    end
 
-        context "and in another source" do
-          before do
-            # need this to be broken to check for correct source ordering
-            build_repo gem_repo2 do
-              build_gem "rack", "1.0.0" do |s|
-                s.write "lib/rack.rb", "RACK = 'FAIL'"
-              end
-            end
+    context "when a pinned gem has an indirect dependency in a different source" do
+      before do
+        # In these tests, we need a working rack gem in repo2 and not repo3
+
+        build_repo gem_repo3 do
+          build_gem "depends_on_rack", "1.0.1" do |s|
+            s.add_dependency "rack"
           end
+        end
+
+        build_repo gem_repo2 do
+          build_gem "rack", "1.0.0"
+        end
+      end
 
-          context "when disable_multisource is set" do
-            before do
-              bundle! "config set disable_multisource true"
+      context "and not in any other sources" do
+        before do
+          install_gemfile <<-G, :artifice => "compact_index"
+            source "https://gem.repo2"
+            source "https://gem.repo3" do
+              gem "depends_on_rack"
             end
+          G
+        end
 
-            it "installs from the same source without any warning" do
-              bundle! :install
+        it "installs from the other source without any warning" do
+          expect(err).not_to include("Warning")
+          expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0")
+        end
+      end
 
-              expect(out).not_to include("Warning: the gem 'rack' was found in multiple sources.")
-              expect(err).not_to include("Warning: the gem 'rack' was found in multiple sources.")
-              expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0")
-
-              # when there is already a lock file, and the gems are missing, so try again
-              system_gems []
-              bundle! :install
-
-              expect(out).not_to include("Warning: the gem 'rack' was found in multiple sources.")
-              expect(err).not_to include("Warning: the gem 'rack' was found in multiple sources.")
-              expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0")
+      context "and in yet another source" do
+        before do
+          gemfile <<-G
+            source "https://gem.repo1"
+            source "https://gem.repo2"
+            source "https://gem.repo3" do
+              gem "depends_on_rack"
             end
-          end
+          G
+        end
+
+        it "installs from the other source and warns about ambiguous gems", :bundler => "< 3" do
+          bundle :install, :artifice => "compact_index"
+          expect(err).to include("Warning: the gem 'rack' was found in multiple sources.")
+          expect(err).to include("Installed from: https://gem.repo2")
+
+          expect(lockfile).to eq <<~L
+            GEM
+              remote: https://gem.repo1/
+              remote: https://gem.repo2/
+              specs:
+                rack (1.0.0)
+
+            GEM
+              remote: https://gem.repo3/
+              specs:
+                depends_on_rack (1.0.1)
+                  rack
+
+            PLATFORMS
+              #{specific_local_platform}
+
+            DEPENDENCIES
+              depends_on_rack!
+
+            BUNDLED WITH
+               #{Bundler::VERSION}
+          L
+
+          previous_lockfile = lockfile
+          expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0")
+          expect(lockfile).to eq(previous_lockfile)
+        end
+
+        it "fails", :bundler => "3" do
+          bundle :install, :artifice => "compact_index", :raise_on_error => false
+          expect(err).to include("Each source after the first must include a block")
+          expect(exitstatus).to eq(4)
         end
       end
 
-      context "when the indirect dependency is in a different source" do
+      context "and only the dependency is pinned" do
         before do
-          # In these tests, we need a working rack gem in repo2 and not repo3
+          # need this to be broken to check for correct source ordering
           build_repo gem_repo2 do
-            build_gem "rack", "1.0.0"
+            build_gem "rack", "1.0.0" do |s|
+              s.write "lib/rack.rb", "RACK = 'FAIL'"
+            end
           end
+
+          gemfile <<-G
+            source "https://gem.repo3" # contains depends_on_rack
+            source "https://gem.repo2" # contains broken rack
+
+            gem "depends_on_rack" # installed from gem_repo3
+            gem "rack", :source => "https://gem.repo1"
+          G
         end
 
-        context "and not in any other sources" do
-          before do
-            gemfile <<-G
-              source "#{file_uri_for(gem_repo2)}"
-              source "#{file_uri_for(gem_repo3)}" do
-                gem "depends_on_rack"
-              end
-            G
+        it "installs the dependency from the pinned source without warning", :bundler => "< 3" do
+          bundle :install, :artifice => "compact_index"
+
+          expect(err).not_to include("Warning: the gem 'rack' was found in multiple sources.")
+          expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0")
+
+          # In https://github.com/rubygems/bundler/issues/3585 this failed
+          # when there is already a lock file, and the gems are missing, so try again
+          system_gems []
+          bundle :install, :artifice => "compact_index"
+
+          expect(err).not_to include("Warning: the gem 'rack' was found in multiple sources.")
+          expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0")
+        end
+
+        it "fails", :bundler => "3" do
+          bundle :install, :artifice => "compact_index", :raise_on_error => false
+          expect(err).to include("Each source after the first must include a block")
+          expect(exitstatus).to eq(4)
+        end
+      end
+    end
+
+    context "when a top-level gem can only be found in an scoped source" do
+      before do
+        build_repo2
+
+        build_repo gem_repo3 do
+          build_gem "private_gem_1", "1.0.0"
+          build_gem "private_gem_2", "1.0.0"
+        end
+
+        gemfile <<-G
+          source "https://gem.repo2"
+
+          gem "private_gem_1"
+
+          source "https://gem.repo3" do
+            gem "private_gem_2"
           end
+        G
+      end
+
+      it "fails" do
+        bundle :install, :artifice => "compact_index", :raise_on_error => false
+        expect(err).to include("Could not find gem 'private_gem_1' in rubygems repository https://gem.repo2/ or installed locally.")
+      end
+    end
+
+    context "when an indirect dependency can't be found in the aggregate rubygems source", :bundler => "< 3" do
+      before do
+        build_repo2
 
-          it "installs from the other source without any warning" do
-            bundle :install
-            expect(out).not_to include("Warning")
-            expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0")
+        build_repo gem_repo3 do
+          build_gem "depends_on_missing", "1.0.1" do |s|
+            s.add_dependency "missing"
           end
         end
 
-        context "and in yet another source", :bundler => "< 3" do
-          before do
-            gemfile <<-G
-              source "#{file_uri_for(gem_repo1)}"
-              source "#{file_uri_for(gem_repo2)}"
-              source "#{file_uri_for(gem_repo3)}" do
-                gem "depends_on_rack"
-              end
-            G
+        gemfile <<-G
+          source "https://gem.repo2"
+
+          source "https://gem.repo3"
+
+          gem "depends_on_missing"
+        G
+      end
+
+      it "fails" do
+        bundle :install, :artifice => "compact_index", :raise_on_error => false
+        expect(err).to include("Could not find gem 'missing', which is required by gem 'depends_on_missing', in any of the sources.")
+      end
+    end
 
-            bundle :install
+    context "when a top-level gem has an indirect dependency" do
+      before do
+        build_repo gem_repo2 do
+          build_gem "depends_on_rack", "1.0.1" do |s|
+            s.add_dependency "rack"
           end
+        end
+
+        build_repo gem_repo3 do
+          build_gem "unrelated_gem", "1.0.0"
+        end
+
+        gemfile <<-G
+          source "https://gem.repo2"
+
+          gem "depends_on_rack"
 
-          it "installs from the other source and warns about ambiguous gems", :bundler => "2" do
-            expect(err).to include("Warning: the gem 'rack' was found in multiple sources.")
-            expect(err).to include("Installed from: #{file_uri_for(gem_repo2)}")
-            expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0")
+          source "https://gem.repo3" do
+            gem "unrelated_gem"
           end
+        G
+      end
 
-          it "fails", :bundler => "3" do
-            expect(err).to include("Each source after the first must include a block")
-            expect(exitstatus).to eq(4) if exitstatus
+      context "and the dependency is only in the top-level source" do
+        before do
+          update_repo gem_repo2 do
+            build_gem "rack", "1.0.0"
           end
         end
 
-        context "and only the dependency is pinned", :bundler => "< 3" do
-          before do
-            # need this to be broken to check for correct source ordering
-            build_repo gem_repo2 do
-              build_gem "rack", "1.0.0" do |s|
-                s.write "lib/rack.rb", "RACK = 'FAIL'"
-              end
+        it "installs the dependency from the top-level source without warning" do
+          bundle :install, :artifice => "compact_index"
+          expect(err).not_to include("Warning")
+          expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0", "unrelated_gem 1.0.0")
+          expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0", :source => "remote2")
+          expect(the_bundle).to include_gems("unrelated_gem 1.0.0", :source => "remote3")
+        end
+      end
+
+      context "and the dependency is only in a pinned source" do
+        before do
+          update_repo gem_repo3 do
+            build_gem "rack", "1.0.0" do |s|
+              s.write "lib/rack.rb", "RACK = 'FAIL'"
             end
+          end
+        end
 
-            gemfile <<-G
-              source "#{file_uri_for(gem_repo3)}" # contains depends_on_rack
-              source "#{file_uri_for(gem_repo2)}" # contains broken rack
+        it "does not find the dependency" do
+          bundle :install, :artifice => "compact_index", :raise_on_error => false
+          expect(err).to include(
+            "Could not find gem 'rack', which is required by gem 'depends_on_rack', in rubygems repository https://gem.repo2/ or installed locally."
+          )
+        end
+      end
 
-              gem "depends_on_rack" # installed from gem_repo3
-              gem "rack", :source => "#{file_uri_for(gem_repo1)}"
-            G
+      context "and the dependency is in both the top-level and a pinned source" do
+        before do
+          update_repo gem_repo2 do
+            build_gem "rack", "1.0.0"
+          end
+
+          update_repo gem_repo3 do
+            build_gem "rack", "1.0.0" do |s|
+              s.write "lib/rack.rb", "RACK = 'FAIL'"
+            end
           end
+        end
+
+        it "installs the dependency from the top-level source without warning" do
+          bundle :install, :artifice => "compact_index"
+          expect(err).not_to include("Warning")
+          expect(run("require 'rack'; puts RACK")).to eq("1.0.0")
+          expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0", "unrelated_gem 1.0.0")
+          expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0", :source => "remote2")
+          expect(the_bundle).to include_gems("unrelated_gem 1.0.0", :source => "remote3")
+        end
+      end
+    end
 
-          it "installs the dependency from the pinned source without warning", :bundler => "2" do
-            bundle :install
+    context "when a scoped gem has a deeply nested indirect dependency" do
+      before do
+        build_repo gem_repo3 do
+          build_gem "depends_on_depends_on_rack", "1.0.1" do |s|
+            s.add_dependency "depends_on_rack"
+          end
 
-            expect(err).not_to include("Warning: the gem 'rack' was found in multiple sources.")
-            expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0")
+          build_gem "depends_on_rack", "1.0.1" do |s|
+            s.add_dependency "rack"
+          end
+        end
 
-            # In https://github.com/bundler/bundler/issues/3585 this failed
-            # when there is already a lock file, and the gems are missing, so try again
-            system_gems []
-            bundle :install
+        gemfile <<-G
+          source "https://gem.repo2"
 
-            expect(err).not_to include("Warning: the gem 'rack' was found in multiple sources.")
-            expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0")
+          source "https://gem.repo3" do
+            gem "depends_on_depends_on_rack"
           end
+        G
+      end
 
-          it "fails", :bundler => "3" do
-            bundle :install
-            expect(err).to include("Each source after the first must include a block")
-            expect(exitstatus).to eq(4) if exitstatus
+      context "and the dependency is only in the top-level source" do
+        before do
+          update_repo gem_repo2 do
+            build_gem "rack", "1.0.0"
           end
         end
+
+        it "installs the dependency from the top-level source" do
+          bundle :install, :artifice => "compact_index"
+          expect(the_bundle).to include_gems("depends_on_depends_on_rack 1.0.1", "depends_on_rack 1.0.1", "rack 1.0.0")
+          expect(the_bundle).to include_gems("rack 1.0.0", :source => "remote2")
+          expect(the_bundle).to include_gems("depends_on_depends_on_rack 1.0.1", "depends_on_rack 1.0.1", :source => "remote3")
+        end
       end
-    end
 
-    context "when a top-level gem has an indirect dependency" do
-      context "when disable_multisource is set" do
+      context "and the dependency is only in a pinned source" do
         before do
-          bundle! "config set disable_multisource true"
+          build_repo2
+
+          update_repo gem_repo3 do
+            build_gem "rack", "1.0.0"
+          end
+        end
+
+        it "installs the dependency from the pinned source" do
+          bundle :install, :artifice => "compact_index"
+          expect(the_bundle).to include_gems("depends_on_depends_on_rack 1.0.1", "depends_on_rack 1.0.1", "rack 1.0.0", :source => "remote3")
         end
+      end
 
+      context "and the dependency is in both the top-level and a pinned source" do
         before do
-          build_repo gem_repo2 do
-            build_gem "depends_on_rack", "1.0.1" do |s|
-              s.add_dependency "rack"
+          update_repo gem_repo2 do
+            build_gem "rack", "1.0.0" do |s|
+              s.write "lib/rack.rb", "RACK = 'FAIL'"
             end
           end
 
-          build_repo gem_repo3 do
-            build_gem "unrelated_gem", "1.0.0"
+          update_repo gem_repo3 do
+            build_gem "rack", "1.0.0"
           end
+        end
 
-          gemfile <<-G
-            source "#{file_uri_for(gem_repo2)}"
+        it "installs the dependency from the pinned source without warning" do
+          bundle :install, :artifice => "compact_index"
+          expect(the_bundle).to include_gems("depends_on_depends_on_rack 1.0.1", "depends_on_rack 1.0.1", "rack 1.0.0", :source => "remote3")
+        end
+      end
+    end
 
-            gem "depends_on_rack"
+    context "when the lockfile has aggregated rubygems sources and newer versions of dependencies are available" do
+      before do
+        build_repo gem_repo2 do
+          build_gem "activesupport", "6.0.3.4" do |s|
+            s.add_dependency "concurrent-ruby", "~> 1.0", ">= 1.0.2"
+            s.add_dependency "i18n", ">= 0.7", "< 2"
+            s.add_dependency "minitest", "~> 5.1"
+            s.add_dependency "tzinfo", "~> 1.1"
+            s.add_dependency "zeitwerk", "~> 2.2", ">= 2.2.2"
+          end
 
-            source "#{file_uri_for(gem_repo3)}" do
-              gem "unrelated_gem"
-            end
-          G
-        end
+          build_gem "activesupport", "6.1.2.1" do |s|
+            s.add_dependency "concurrent-ruby", "~> 1.0", ">= 1.0.2"
+            s.add_dependency "i18n", ">= 1.6", "< 2"
+            s.add_dependency "minitest", ">= 5.1"
+            s.add_dependency "tzinfo", "~> 2.0"
+            s.add_dependency "zeitwerk", "~> 2.3"
+          end
 
-        context "and the dependency is only in the top-level source" do
-          before do
-            update_repo gem_repo2 do
-              build_gem "rack", "1.0.0"
-            end
+          build_gem "concurrent-ruby", "1.1.8"
+          build_gem "concurrent-ruby", "1.1.9"
+          build_gem "connection_pool", "2.2.3"
+
+          build_gem "i18n", "1.8.9" do |s|
+            s.add_dependency "concurrent-ruby", "~> 1.0"
           end
 
-          it "installs all gems without warning" do
-            bundle :install
-            expect(err).not_to include("Warning")
-            expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0", "unrelated_gem 1.0.0")
+          build_gem "minitest", "5.14.3"
+          build_gem "rack", "2.2.3"
+          build_gem "redis", "4.2.5"
+
+          build_gem "sidekiq", "6.1.3" do |s|
+            s.add_dependency "connection_pool", ">= 2.2.2"
+            s.add_dependency "rack", "~> 2.0"
+            s.add_dependency "redis", ">= 4.2.0"
           end
+
+          build_gem "thread_safe", "0.3.6"
+
+          build_gem "tzinfo", "1.2.9" do |s|
+            s.add_dependency "thread_safe", "~> 0.1"
+          end
+
+          build_gem "tzinfo", "2.0.4" do |s|
+            s.add_dependency "concurrent-ruby", "~> 1.0"
+          end
+
+          build_gem "zeitwerk", "2.4.2"
         end
 
-        context "and the dependency is only in a pinned source" do
-          before do
-            update_repo gem_repo3 do
-              build_gem "rack", "1.0.0" do |s|
-                s.write "lib/rack.rb", "RACK = 'FAIL'"
-              end
-            end
+        build_repo gem_repo3 do
+          build_gem "sidekiq-pro", "5.2.1" do |s|
+            s.add_dependency "connection_pool", ">= 2.2.3"
+            s.add_dependency "sidekiq", ">= 6.1.0"
           end
+        end
+
+        gemfile <<-G
+          # frozen_string_literal: true
+
+          source "https://gem.repo2"
+
+          gem "activesupport"
+
+          source "https://gem.repo3" do
+            gem "sidekiq-pro"
+          end
+        G
+
+        lockfile <<~L
+          GEM
+            remote: https://gem.repo2/
+            remote: https://gem.repo3/
+            specs:
+              activesupport (6.0.3.4)
+                concurrent-ruby (~> 1.0, >= 1.0.2)
+                i18n (>= 0.7, < 2)
+                minitest (~> 5.1)
+                tzinfo (~> 1.1)
+                zeitwerk (~> 2.2, >= 2.2.2)
+              concurrent-ruby (1.1.8)
+              connection_pool (2.2.3)
+              i18n (1.8.9)
+                concurrent-ruby (~> 1.0)
+              minitest (5.14.3)
+              rack (2.2.3)
+              redis (4.2.5)
+              sidekiq (6.1.3)
+                connection_pool (>= 2.2.2)
+                rack (~> 2.0)
+                redis (>= 4.2.0)
+              sidekiq-pro (5.2.1)
+                connection_pool (>= 2.2.3)
+                sidekiq (>= 6.1.0)
+              thread_safe (0.3.6)
+              tzinfo (1.2.9)
+                thread_safe (~> 0.1)
+              zeitwerk (2.4.2)
+
+          PLATFORMS
+            #{specific_local_platform}
+
+          DEPENDENCIES
+            activesupport
+            sidekiq-pro!
+
+          BUNDLED WITH
+             #{Bundler::VERSION}
+        L
+      end
+
+      it "does not install newer versions but updates the lockfile format when running bundle install in non frozen mode, and doesn't warn" do
+        bundle :install, :artifice => "compact_index"
+        expect(err).to be_empty
+
+        expect(the_bundle).to include_gems("activesupport 6.0.3.4")
+        expect(the_bundle).not_to include_gems("activesupport 6.1.2.1")
+        expect(the_bundle).to include_gems("tzinfo 1.2.9")
+        expect(the_bundle).not_to include_gems("tzinfo 2.0.4")
+        expect(the_bundle).to include_gems("concurrent-ruby 1.1.8")
+        expect(the_bundle).not_to include_gems("concurrent-ruby 1.1.9")
+
+        expect(lockfile).to eq <<~L
+          GEM
+            remote: https://gem.repo2/
+            specs:
+              activesupport (6.0.3.4)
+                concurrent-ruby (~> 1.0, >= 1.0.2)
+                i18n (>= 0.7, < 2)
+                minitest (~> 5.1)
+                tzinfo (~> 1.1)
+                zeitwerk (~> 2.2, >= 2.2.2)
+              concurrent-ruby (1.1.8)
+              connection_pool (2.2.3)
+              i18n (1.8.9)
+                concurrent-ruby (~> 1.0)
+              minitest (5.14.3)
+              rack (2.2.3)
+              redis (4.2.5)
+              sidekiq (6.1.3)
+                connection_pool (>= 2.2.2)
+                rack (~> 2.0)
+                redis (>= 4.2.0)
+              thread_safe (0.3.6)
+              tzinfo (1.2.9)
+                thread_safe (~> 0.1)
+              zeitwerk (2.4.2)
+
+          GEM
+            remote: https://gem.repo3/
+            specs:
+              sidekiq-pro (5.2.1)
+                connection_pool (>= 2.2.3)
+                sidekiq (>= 6.1.0)
+
+          PLATFORMS
+            #{specific_local_platform}
+
+          DEPENDENCIES
+            activesupport
+            sidekiq-pro!
+
+          BUNDLED WITH
+             #{Bundler::VERSION}
+        L
+      end
+
+      it "does not install newer versions or generate lockfile changes when running bundle install in frozen mode, and warns", :bundler => "< 3" do
+        initial_lockfile = lockfile
+
+        bundle "config set --local frozen true"
+        bundle :install, :artifice => "compact_index"
+
+        expect(err).to include("Your lockfile contains a single rubygems source section with multiple remotes, which is insecure.")
+
+        expect(the_bundle).to include_gems("activesupport 6.0.3.4")
+        expect(the_bundle).not_to include_gems("activesupport 6.1.2.1")
+        expect(the_bundle).to include_gems("tzinfo 1.2.9")
+        expect(the_bundle).not_to include_gems("tzinfo 2.0.4")
+        expect(the_bundle).to include_gems("concurrent-ruby 1.1.8")
+        expect(the_bundle).not_to include_gems("concurrent-ruby 1.1.9")
+
+        expect(lockfile).to eq(initial_lockfile)
+      end
+
+      it "fails when running bundle install in frozen mode", :bundler => "3" do
+        initial_lockfile = lockfile
+
+        bundle "config set --local frozen true"
+        bundle :install, :artifice => "compact_index", :raise_on_error => false
+
+        expect(err).to include("Your lockfile contains a single rubygems source section with multiple remotes, which is insecure.")
+
+        expect(lockfile).to eq(initial_lockfile)
+      end
+
+      it "splits sections and upgrades gems when running bundle update, and doesn't warn" do
+        bundle "update --all", :artifice => "compact_index"
+        expect(err).to be_empty
+
+        expect(the_bundle).not_to include_gems("activesupport 6.0.3.4")
+        expect(the_bundle).to include_gems("activesupport 6.1.2.1")
+        expect(the_bundle).not_to include_gems("tzinfo 1.2.9")
+        expect(the_bundle).to include_gems("tzinfo 2.0.4")
+        expect(the_bundle).not_to include_gems("concurrent-ruby 1.1.8")
+        expect(the_bundle).to include_gems("concurrent-ruby 1.1.9")
+
+        expect(lockfile).to eq <<~L
+          GEM
+            remote: https://gem.repo2/
+            specs:
+              activesupport (6.1.2.1)
+                concurrent-ruby (~> 1.0, >= 1.0.2)
+                i18n (>= 1.6, < 2)
+                minitest (>= 5.1)
+                tzinfo (~> 2.0)
+                zeitwerk (~> 2.3)
+              concurrent-ruby (1.1.9)
+              connection_pool (2.2.3)
+              i18n (1.8.9)
+                concurrent-ruby (~> 1.0)
+              minitest (5.14.3)
+              rack (2.2.3)
+              redis (4.2.5)
+              sidekiq (6.1.3)
+                connection_pool (>= 2.2.2)
+                rack (~> 2.0)
+                redis (>= 4.2.0)
+              tzinfo (2.0.4)
+                concurrent-ruby (~> 1.0)
+              zeitwerk (2.4.2)
+
+          GEM
+            remote: https://gem.repo3/
+            specs:
+              sidekiq-pro (5.2.1)
+                connection_pool (>= 2.2.3)
+                sidekiq (>= 6.1.0)
+
+          PLATFORMS
+            #{specific_local_platform}
+
+          DEPENDENCIES
+            activesupport
+            sidekiq-pro!
+
+          BUNDLED WITH
+             #{Bundler::VERSION}
+        L
+      end
+
+      it "upgrades the lockfile format and upgrades the requested gem when running bundle update with an argument" do
+        bundle "update concurrent-ruby", :artifice => "compact_index"
+        expect(err).to be_empty
+
+        expect(the_bundle).to include_gems("activesupport 6.0.3.4")
+        expect(the_bundle).not_to include_gems("activesupport 6.1.2.1")
+        expect(the_bundle).to include_gems("tzinfo 1.2.9")
+        expect(the_bundle).not_to include_gems("tzinfo 2.0.4")
+        expect(the_bundle).to include_gems("concurrent-ruby 1.1.9")
+        expect(the_bundle).not_to include_gems("concurrent-ruby 1.1.8")
+
+        expect(lockfile).to eq <<~L
+          GEM
+            remote: https://gem.repo2/
+            specs:
+              activesupport (6.0.3.4)
+                concurrent-ruby (~> 1.0, >= 1.0.2)
+                i18n (>= 0.7, < 2)
+                minitest (~> 5.1)
+                tzinfo (~> 1.1)
+                zeitwerk (~> 2.2, >= 2.2.2)
+              concurrent-ruby (1.1.9)
+              connection_pool (2.2.3)
+              i18n (1.8.9)
+                concurrent-ruby (~> 1.0)
+              minitest (5.14.3)
+              rack (2.2.3)
+              redis (4.2.5)
+              sidekiq (6.1.3)
+                connection_pool (>= 2.2.2)
+                rack (~> 2.0)
+                redis (>= 4.2.0)
+              thread_safe (0.3.6)
+              tzinfo (1.2.9)
+                thread_safe (~> 0.1)
+              zeitwerk (2.4.2)
+
+          GEM
+            remote: https://gem.repo3/
+            specs:
+              sidekiq-pro (5.2.1)
+                connection_pool (>= 2.2.3)
+                sidekiq (>= 6.1.0)
+
+          PLATFORMS
+            #{specific_local_platform}
+
+          DEPENDENCIES
+            activesupport
+            sidekiq-pro!
+
+          BUNDLED WITH
+             #{Bundler::VERSION}
+        L
+      end
+    end
+
+    context "when a top-level gem has an indirect dependency present in the default source, but with a different version from the one resolved" do
+      before do
+        build_lib "activesupport", "7.0.0.alpha", :path => lib_path("rails/activesupport")
+        build_lib "rails", "7.0.0.alpha", :path => lib_path("rails") do |s|
+          s.add_dependency "activesupport", "= 7.0.0.alpha"
+        end
+
+        build_repo gem_repo2 do
+          build_gem "activesupport", "6.1.2"
 
-          it "does not find the dependency" do
-            bundle :install
-            expect(err).to include("Could not find gem 'rack', which is required by gem 'depends_on_rack', in any of the relevant sources")
+          build_gem "webpacker", "5.2.1" do |s|
+            s.add_dependency "activesupport", ">= 5.2"
           end
         end
 
-        context "and the dependency is in both the top-level and a pinned source" do
-          before do
-            update_repo gem_repo2 do
-              build_gem "rack", "1.0.0"
-            end
+        gemfile <<-G
+          source "https://gem.repo2"
 
-            update_repo gem_repo3 do
-              build_gem "rack", "1.0.0" do |s|
-                s.write "lib/rack.rb", "RACK = 'FAIL'"
-              end
-            end
+          gemspec :path => "#{lib_path("rails")}"
+
+          gem "webpacker", "~> 5.0"
+        G
+      end
+
+      it "installs all gems without warning" do
+        bundle :install, :artifice => "compact_index"
+        expect(err).not_to include("Warning")
+        expect(the_bundle).to include_gems("activesupport 7.0.0.alpha", "rails 7.0.0.alpha")
+        expect(the_bundle).to include_gems("activesupport 7.0.0.alpha", :source => "path@#{lib_path("rails/activesupport")}")
+        expect(the_bundle).to include_gems("rails 7.0.0.alpha", :source => "path@#{lib_path("rails")}")
+      end
+    end
+
+    context "when a pinned gem has an indirect dependency with more than one level of indirection in the default source " do
+      before do
+        build_repo gem_repo3 do
+          build_gem "handsoap", "0.2.5.5" do |s|
+            s.add_dependency "nokogiri", ">= 1.2.3"
           end
+        end
 
-          it "installs the dependency from the top-level source without warning" do
-            bundle :install
-            expect(err).not_to include("Warning")
-            expect(the_bundle).to include_gems("depends_on_rack 1.0.1", "rack 1.0.0", "unrelated_gem 1.0.0")
+        update_repo gem_repo2 do
+          build_gem "nokogiri", "1.11.1" do |s|
+            s.add_dependency "racca", "~> 1.4"
           end
+
+          build_gem "racca", "1.5.2"
         end
+
+        gemfile <<-G
+          source "https://gem.repo2"
+
+          source "https://gem.repo3" do
+            gem "handsoap"
+          end
+
+          gem "nokogiri"
+        G
+      end
+
+      it "installs from the default source without any warnings or errors and generates a proper lockfile" do
+        expected_lockfile = <<~L
+          GEM
+            remote: https://gem.repo2/
+            specs:
+              nokogiri (1.11.1)
+                racca (~> 1.4)
+              racca (1.5.2)
+
+          GEM
+            remote: https://gem.repo3/
+            specs:
+              handsoap (0.2.5.5)
+                nokogiri (>= 1.2.3)
+
+          PLATFORMS
+            #{specific_local_platform}
+
+          DEPENDENCIES
+            handsoap!
+            nokogiri
+
+          BUNDLED WITH
+             #{Bundler::VERSION}
+        L
+
+        bundle "install --verbose", :artifice => "compact_index"
+        expect(err).not_to include("Warning")
+        expect(the_bundle).to include_gems("handsoap 0.2.5.5", "nokogiri 1.11.1", "racca 1.5.2")
+        expect(the_bundle).to include_gems("handsoap 0.2.5.5", :source => "remote3")
+        expect(the_bundle).to include_gems("nokogiri 1.11.1", "racca 1.5.2", :source => "remote2")
+        expect(lockfile).to eq(expected_lockfile)
+
+        # Even if the gems are already installed
+        FileUtils.rm bundled_app_lock
+        bundle "install --verbose", :artifice => "compact_index"
+        expect(err).not_to include("Warning")
+        expect(the_bundle).to include_gems("handsoap 0.2.5.5", "nokogiri 1.11.1", "racca 1.5.2")
+        expect(the_bundle).to include_gems("handsoap 0.2.5.5", :source => "remote3")
+        expect(the_bundle).to include_gems("nokogiri 1.11.1", "racca 1.5.2", :source => "remote2")
+        expect(lockfile).to eq(expected_lockfile)
       end
     end
 
@@ -388,64 +944,145 @@ RSpec.describe "bundle install with gems
           build_gem "not_in_repo1", "1.0.0"
         end
 
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo3)}"
-          gem "not_in_repo1", :source => "#{file_uri_for(gem_repo1)}"
+        install_gemfile <<-G, :artifice => "compact_index", :raise_on_error => false
+          source "https://gem.repo3"
+          gem "not_in_repo1", :source => "https://gem.repo1"
         G
       end
 
       it "does not install the gem" do
-        bundle :install
         expect(err).to include("Could not find gem 'not_in_repo1'")
       end
     end
 
     context "with an existing lockfile" do
       before do
-        system_gems "rack-0.9.1", "rack-1.0.0", :path => :bundle_path
+        system_gems "rack-0.9.1", "rack-1.0.0", :path => default_bundle_path
 
         lockfile <<-L
           GEM
-            remote: #{file_uri_for(gem_repo1)}
-            remote: #{file_uri_for(gem_repo3)}
+            remote: https://gem.repo1
+            specs:
+
+          GEM
+            remote: https://gem.repo3
             specs:
               rack (0.9.1)
 
           PLATFORMS
-            ruby
+            #{specific_local_platform}
 
           DEPENDENCIES
             rack!
         L
 
         gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          source "#{file_uri_for(gem_repo3)}" do
+          source "https://gem.repo1"
+          source "https://gem.repo3" do
             gem 'rack'
           end
         G
       end
 
-      # Reproduction of https://github.com/bundler/bundler/issues/3298
+      # Reproduction of https://github.com/rubygems/bundler/issues/3298
       it "does not unlock the installed gem on exec" do
         expect(the_bundle).to include_gems("rack 0.9.1")
       end
     end
 
+    context "with a lockfile with aggregated rubygems sources" do
+      let(:aggregate_gem_section_lockfile) do
+        <<~L
+          GEM
+            remote: https://gem.repo1/
+            remote: https://gem.repo3/
+            specs:
+              rack (0.9.1)
+
+          PLATFORMS
+            #{specific_local_platform}
+
+          DEPENDENCIES
+            rack!
+
+          BUNDLED WITH
+             #{Bundler::VERSION}
+        L
+      end
+
+      let(:split_gem_section_lockfile) do
+        <<~L
+          GEM
+            remote: https://gem.repo1/
+            specs:
+
+          GEM
+            remote: https://gem.repo3/
+            specs:
+              rack (0.9.1)
+
+          PLATFORMS
+            #{specific_local_platform}
+
+          DEPENDENCIES
+            rack!
+
+          BUNDLED WITH
+             #{Bundler::VERSION}
+        L
+      end
+
+      before do
+        build_repo gem_repo3 do
+          build_gem "rack", "0.9.1"
+        end
+
+        gemfile <<-G
+          source "https://gem.repo1"
+          source "https://gem.repo3" do
+            gem 'rack'
+          end
+        G
+
+        lockfile aggregate_gem_section_lockfile
+      end
+
+      it "installs the existing lockfile but prints a warning", :bundler => "< 3" do
+        bundle "config set --local deployment true"
+
+        bundle "install", :artifice => "compact_index"
+
+        expect(lockfile).to eq(aggregate_gem_section_lockfile)
+        expect(err).to include("Your lockfile contains a single rubygems source section with multiple remotes, which is insecure.")
+        expect(the_bundle).to include_gems("rack 0.9.1", :source => "remote3")
+      end
+
+      it "refuses to install the existing lockfile and prints an error", :bundler => "3" do
+        bundle "config set --local deployment true"
+
+        bundle "install", :artifice => "compact_index", :raise_on_error =>false
+
+        expect(lockfile).to eq(aggregate_gem_section_lockfile)
+        expect(err).to include("Your lockfile contains a single rubygems source section with multiple remotes, which is insecure.")
+        expect(out).to be_empty
+      end
+    end
+
     context "with a path gem in the same Gemfile" do
       before do
         build_lib "foo"
 
         gemfile <<-G
-          gem "rack", :source => "#{file_uri_for(gem_repo1)}"
+          source "#{file_uri_for(gem_repo1)}"
+          gem "rack", :source => "https://gem.repo1"
           gem "foo", :path => "#{lib_path("foo-1.0")}"
         G
       end
 
       it "does not unlock the non-path gem after install" do
-        bundle! :install
+        bundle :install, :artifice => "compact_index"
 
-        bundle! %(exec ruby -e 'puts "OK"')
+        bundle %(exec ruby -e 'puts "OK"')
 
         expect(out).to include("OK")
       end
@@ -456,14 +1093,13 @@ RSpec.describe "bundle install with gems
     before do
       system_gems "rack-0.9.1"
 
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack" # shoud come from repo1!
+      install_gemfile <<-G, :artifice => "compact_index"
+        source "https://gem.repo1"
+        gem "rack" # should come from repo1!
       G
     end
 
     it "installs the gems without any warning" do
-      bundle :install
       expect(err).not_to include("Warning")
       expect(the_bundle).to include_gems("rack 1.0.0")
     end
@@ -479,13 +1115,14 @@ RSpec.describe "bundle install with gems
 
       # Installing this gemfile...
       gemfile <<-G
-        source '#{file_uri_for(gem_repo1)}'
+        source 'https://gem.repo1'
         gem 'rack'
-        gem 'foo', '~> 0.1', :source => '#{file_uri_for(gem_repo4)}'
-        gem 'bar', '~> 0.1', :source => '#{file_uri_for(gem_repo4)}'
+        gem 'foo', '~> 0.1', :source => 'https://gem.repo4'
+        gem 'bar', '~> 0.1', :source => 'https://gem.repo4'
       G
 
-      bundle! :install, forgotten_command_line_options(:path => "../gems/system")
+      bundle "config set --local path ../gems/system"
+      bundle :install, :artifice => "compact_index"
 
       # And then we add some new versions...
       update_repo4 do
@@ -496,11 +1133,11 @@ RSpec.describe "bundle install with gems
 
     it "allows them to be unlocked separately" do
       # And install this gemfile, updating only foo.
-      install_gemfile <<-G
-        source '#{file_uri_for(gem_repo1)}'
+      install_gemfile <<-G, :artifice => "compact_index"
+        source 'https://gem.repo1'
         gem 'rack'
-        gem 'foo', '~> 0.2', :source => '#{file_uri_for(gem_repo4)}'
-        gem 'bar', '~> 0.1', :source => '#{file_uri_for(gem_repo4)}'
+        gem 'foo', '~> 0.2', :source => 'https://gem.repo4'
+        gem 'bar', '~> 0.1', :source => 'https://gem.repo4'
       G
 
       # It should update foo to 0.2, but not the (locked) bar 0.1
@@ -511,17 +1148,20 @@ RSpec.describe "bundle install with gems
   context "re-resolving" do
     context "when there is a mix of sources in the gemfile" do
       before do
-        build_repo3
+        build_repo gem_repo3 do
+          build_gem "rack"
+        end
+
         build_lib "path1"
         build_lib "path2"
         build_git "git1"
         build_git "git2"
 
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
+        install_gemfile <<-G, :artifice => "compact_index"
+          source "https://gem.repo1"
           gem "rails"
 
-          source "#{file_uri_for(gem_repo3)}" do
+          source "https://gem.repo3" do
             gem "rack"
           end
 
@@ -533,7 +1173,7 @@ RSpec.describe "bundle install with gems
       end
 
       it "does not re-resolve" do
-        bundle! :install, :verbose => true
+        bundle :install, :artifice => "compact_index", :verbose => true
         expect(out).to include("using resolution from the lockfile")
         expect(out).not_to include("re-resolving dependencies")
       end
@@ -542,27 +1182,24 @@ RSpec.describe "bundle install with gems
 
   context "when a gem is installed to system gems" do
     before do
-      install_gemfile! <<-G
-        source "#{file_uri_for(gem_repo1)}"
+      install_gemfile <<-G, :artifice => "compact_index"
+        source "https://gem.repo1"
         gem "rack"
       G
     end
 
     context "and the gemfile changes" do
       it "is still able to find that gem from remote sources" do
-        source_uri = file_uri_for(gem_repo1)
-        second_uri = file_uri_for(gem_repo4)
-
         build_repo4 do
           build_gem "rack", "2.0.1.1.forked"
           build_gem "thor", "0.19.1.1.forked"
         end
 
         # When this gemfile is installed...
-        install_gemfile <<-G
-          source "#{source_uri}"
+        install_gemfile <<-G, :artifice => "compact_index"
+          source "https://gem.repo1"
 
-          source "#{second_uri}" do
+          source "https://gem.repo4" do
             gem "rack", "2.0.1.1.forked"
             gem "thor"
           end
@@ -571,9 +1208,9 @@ RSpec.describe "bundle install with gems
 
         # Then we change the Gemfile by adding a version to thor
         gemfile <<-G
-          source "#{source_uri}"
+          source "https://gem.repo1"
 
-          source "#{second_uri}" do
+          source "https://gem.repo4" do
             gem "rack", "2.0.1.1.forked"
             gem "thor", "0.19.1.1.forked"
           end
@@ -581,20 +1218,24 @@ RSpec.describe "bundle install with gems
         G
 
         # But we should still be able to find rack 2.0.1.1.forked and install it
-        bundle! :install
+        bundle :install, :artifice => "compact_index"
       end
     end
   end
 
   describe "source changed to one containing a higher version of a dependency" do
     before do
-      install_gemfile! <<-G
-        source "#{file_uri_for(gem_repo1)}"
+      install_gemfile <<-G, :artifice => "compact_index"
+        source "https://gem.repo1"
 
         gem "rack"
       G
 
       build_repo2 do
+        build_gem "rack", "1.2" do |s|
+          s.executables = "rackup"
+        end
+
         build_gem "bar"
       end
 
@@ -602,23 +1243,135 @@ RSpec.describe "bundle install with gems
         s.add_dependency "bar", "=1.0.0"
       end
 
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo2)}"
+      install_gemfile <<-G, :artifice => "compact_index"
+        source "https://gem.repo2"
         gem "rack"
         gemspec :path => "#{tmp.join("gemspec_test")}"
       G
     end
 
-    it "keeps the old version", :bundler => "2" do
+    it "conservatively installs the existing locked version" do
       expect(the_bundle).to include_gems("rack 1.0.0")
     end
+  end
+
+  context "when Gemfile overrides a gemspec development dependency to change the default source" do
+    before do
+      build_repo4 do
+        build_gem "bar"
+      end
+
+      build_lib("gemspec_test", :path => tmp.join("gemspec_test")) do |s|
+        s.add_development_dependency "bar"
+      end
+
+      install_gemfile <<-G, :artifice => "compact_index"
+        source "https://gem.repo1"
+
+        source "https://gem.repo4" do
+          gem "bar"
+        end
+
+        gemspec :path => "#{tmp.join("gemspec_test")}"
+      G
+    end
+
+    it "does not print warnings" do
+      expect(err).to be_empty
+    end
+  end
+
+  it "doesn't update version when a gem uses a source block but a higher version from another source is already installed locally" do
+    build_repo2 do
+      build_gem "example", "0.1.0"
+    end
 
-    it "installs the higher version in the new repo", :bundler => "3" do
-      expect(the_bundle).to include_gems("rack 1.2")
+    build_repo4 do
+      build_gem "example", "1.0.2"
     end
+
+    install_gemfile <<-G, :artifice => "compact_index"
+      source "https://gem.repo4"
+
+      gem "example", :source => "https://gem.repo2"
+    G
+
+    bundle "info example"
+    expect(out).to include("example (0.1.0)")
+
+    system_gems "example-1.0.2", :path => default_bundle_path, :gem_repo => gem_repo4
+
+    bundle "update example --verbose", :artifice => "compact_index"
+    expect(out).not_to include("Using example 1.0.2")
+    expect(out).to include("Using example 0.1.0")
+  end
+
+  it "fails inmmediately with a helpful error when a rubygems source does not exist and bundler/setup is required" do
+    gemfile <<-G
+      source "https://gem.repo1"
+
+      source "https://gem.repo4" do
+        gem "example"
+      end
+    G
+
+    simulate_bundler_version_when_missing_prerelease_default_gem_activation do
+      ruby <<~R, :raise_on_error => false
+        require 'bundler/setup'
+      R
+    end
+
+    expect(last_command).to be_failure
+    expect(err).to include("Could not find gem 'example' in locally installed gems.")
+  end
+
+  it "fails inmmediately with a helpful error when a non retriable network error happens while resolving sources" do
+    gemfile <<-G
+      source "https://gem.repo1"
+
+      source "https://gem.repo4" do
+        gem "example"
+      end
+    G
+
+    bundle "install", :artifice => nil, :raise_on_error => false
+
+    expect(last_command).to be_failure
+    expect(err).to include("Could not reach host gem.repo4. Check your network connection and try again.")
   end
 
-  context "when a gem is available from multiple ambiguous sources", :bundler => "3" do
+  context "when an indirect dependency is available from multiple ambiguous sources", :bundler => "< 3" do
+    it "succeeds but warns, suggesting a source block" do
+      build_repo4 do
+        build_gem "depends_on_rack" do |s|
+          s.add_dependency "rack"
+        end
+        build_gem "rack"
+      end
+
+      install_gemfile <<-G, :artifice => "compact_index", :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
+
+        source "https://gem.repo4" do
+          gem "depends_on_rack"
+        end
+
+        source "https://gem.repo1" do
+          gem "thin"
+        end
+      G
+      expect(err).to eq strip_whitespace(<<-EOS).strip
+        Warning: The gem 'rack' was found in multiple relevant sources.
+          * rubygems repository https://gem.repo1/
+          * rubygems repository https://gem.repo4/
+        You should add this gem to the source block for the source you wish it to be installed from.
+      EOS
+      expect(last_command).to be_success
+      expect(the_bundle).to be_locked
+    end
+  end
+
+  context "when an indirect dependency is available from multiple ambiguous sources", :bundler => "3" do
     it "raises, suggesting a source block" do
       build_repo4 do
         build_gem "depends_on_rack" do |s|
@@ -627,21 +1380,279 @@ RSpec.describe "bundle install with gems
         build_gem "rack"
       end
 
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo4)}"
-        source "#{file_uri_for(gem_repo1)}" do
+      install_gemfile <<-G, :artifice => "compact_index", :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
+        source "https://gem.repo4" do
+          gem "depends_on_rack"
+        end
+        source "https://gem.repo1" do
           gem "thin"
         end
-        gem "depends_on_rack"
       G
       expect(last_command).to be_failure
       expect(err).to eq strip_whitespace(<<-EOS).strip
         The gem 'rack' was found in multiple relevant sources.
-          * rubygems repository #{file_uri_for(gem_repo1)}/ or installed locally
-          * rubygems repository #{file_uri_for(gem_repo4)}/ or installed locally
+          * rubygems repository https://gem.repo1/
+          * rubygems repository https://gem.repo4/
         You must add this gem to the source block for the source you wish it to be installed from.
       EOS
       expect(the_bundle).not_to be_locked
     end
   end
+
+  context "when upgrading a lockfile suffering from dependency confusion" do
+    before do
+      build_repo4 do
+        build_gem "mime-types", "3.0.0"
+      end
+
+      build_repo2 do
+        build_gem "capybara", "2.5.0" do |s|
+          s.add_dependency "mime-types", ">= 1.16"
+        end
+
+        build_gem "mime-types", "3.3.1"
+      end
+
+      gemfile <<~G
+        source "https://gem.repo2"
+
+        gem "capybara", "~> 2.5.0"
+
+        source "https://gem.repo4" do
+          gem "mime-types", "~> 3.0"
+        end
+      G
+
+      lockfile <<-L
+        GEM
+          remote: https://gem.repo2/
+          remote: https://gem.repo4/
+          specs:
+            capybara (2.5.0)
+              mime-types (>= 1.16)
+            mime-types (3.3.1)
+
+        PLATFORMS
+          #{specific_local_platform}
+
+        DEPENDENCIES
+          capybara (~> 2.5.0)
+          mime-types (~> 3.0)!
+      L
+    end
+
+    it "upgrades the lockfile correctly" do
+      bundle "lock --update", :artifice => "compact_index"
+
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: https://gem.repo2/
+          specs:
+            capybara (2.5.0)
+              mime-types (>= 1.16)
+
+        GEM
+          remote: https://gem.repo4/
+          specs:
+            mime-types (3.0.0)
+
+        PLATFORMS
+          #{specific_local_platform}
+
+        DEPENDENCIES
+          capybara (~> 2.5.0)
+          mime-types (~> 3.0)!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+  end
+
+  context "when default source includes old gems with nil required_ruby_version" do
+    before do
+      build_repo2 do
+        build_gem "ruport", "1.7.0.3" do |s|
+          s.add_dependency "pdf-writer", "1.1.8"
+        end
+      end
+
+      build_repo gem_repo4 do
+        build_gem "pdf-writer", "1.1.8"
+      end
+
+      path = "#{gem_repo4}/#{Gem::MARSHAL_SPEC_DIR}/pdf-writer-1.1.8.gemspec.rz"
+      spec = Marshal.load(Bundler.rubygems.inflate(File.binread(path)))
+      spec.instance_variable_set(:@required_ruby_version, nil)
+      File.open(path, "wb") do |f|
+        f.write Gem.deflate(Marshal.dump(spec))
+      end
+
+      gemfile <<~G
+        source "https://localgemserver.test"
+
+        gem "ruport", "= 1.7.0.3", :source => "https://localgemserver.test/extra"
+      G
+    end
+
+    it "handles that fine" do
+      bundle "install", :artifice => "compact_index_extra", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
+
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: https://localgemserver.test/
+          specs:
+            pdf-writer (1.1.8)
+
+        GEM
+          remote: https://localgemserver.test/extra/
+          specs:
+            ruport (1.7.0.3)
+              pdf-writer (= 1.1.8)
+
+        PLATFORMS
+          #{specific_local_platform}
+
+        DEPENDENCIES
+          ruport (= 1.7.0.3)!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+  end
+
+  context "when default source includes old gems with nil required_rubygems_version" do
+    before do
+      build_repo2 do
+        build_gem "ruport", "1.7.0.3" do |s|
+          s.add_dependency "pdf-writer", "1.1.8"
+        end
+      end
+
+      build_repo gem_repo4 do
+        build_gem "pdf-writer", "1.1.8"
+      end
+
+      path = "#{gem_repo4}/#{Gem::MARSHAL_SPEC_DIR}/pdf-writer-1.1.8.gemspec.rz"
+      spec = Marshal.load(Bundler.rubygems.inflate(File.binread(path)))
+      spec.instance_variable_set(:@required_rubygems_version, nil)
+      File.open(path, "wb") do |f|
+        f.write Gem.deflate(Marshal.dump(spec))
+      end
+
+      gemfile <<~G
+        source "https://localgemserver.test"
+
+        gem "ruport", "= 1.7.0.3", :source => "https://localgemserver.test/extra"
+      G
+    end
+
+    it "handles that fine" do
+      bundle "install", :artifice => "compact_index_extra", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
+
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: https://localgemserver.test/
+          specs:
+            pdf-writer (1.1.8)
+
+        GEM
+          remote: https://localgemserver.test/extra/
+          specs:
+            ruport (1.7.0.3)
+              pdf-writer (= 1.1.8)
+
+        PLATFORMS
+          #{specific_local_platform}
+
+        DEPENDENCIES
+          ruport (= 1.7.0.3)!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+  end
+
+  context "when default source uses the old API and includes old gems with nil required_rubygems_version" do
+    before do
+      build_repo4 do
+        build_gem "pdf-writer", "1.1.8"
+      end
+
+      path = "#{gem_repo4}/#{Gem::MARSHAL_SPEC_DIR}/pdf-writer-1.1.8.gemspec.rz"
+      spec = Marshal.load(Bundler.rubygems.inflate(File.binread(path)))
+      spec.instance_variable_set(:@required_rubygems_version, nil)
+      File.open(path, "wb") do |f|
+        f.write Gem.deflate(Marshal.dump(spec))
+      end
+
+      gemfile <<~G
+        source "https://localgemserver.test"
+
+        gem "pdf-writer", "= 1.1.8"
+      G
+    end
+
+    it "handles that fine" do
+      bundle "install --verbose", :artifice => "endpoint", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
+
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: https://localgemserver.test/
+          specs:
+            pdf-writer (1.1.8)
+
+        PLATFORMS
+          #{specific_local_platform}
+
+        DEPENDENCIES
+          pdf-writer (= 1.1.8)
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+  end
+
+  context "when mistakenly adding a top level gem already depended on and cached under the wrong source" do
+    before do
+      build_repo4 do
+        build_gem "some_private_gem", "0.1.0" do |s|
+          s.add_dependency "example", "~> 1.0"
+        end
+      end
+
+      build_repo2 do
+        build_gem "example", "1.0.0"
+      end
+
+      install_gemfile <<~G, :artifice => "compact_index"
+        source "https://gem.repo2"
+
+        source "https://gem.repo4" do
+          gem "some_private_gem"
+        end
+      G
+
+      gemfile <<~G
+        source "https://gem.repo2"
+
+        source "https://gem.repo4" do
+          gem "some_private_gem"
+          gem "example" # MISTAKE, example is not available at gem.repo4
+        end
+      G
+    end
+
+    it "shows a proper error message and does not generate a corrupted lockfile" do
+      expect do
+        bundle :install, :artifice => "compact_index", :raise_on_error => false, :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
+      end.not_to change { lockfile }
+
+      expect(err).to include("Could not find gem 'example' in rubygems repository https://gem.repo4/")
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile/specific_platform_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile/specific_platform_spec.rb
@@ -1,53 +1,6 @@
 # frozen_string_literal: true
 
-RSpec.describe "bundle install with specific_platform enabled" do
-  before do
-    bundle "config set specific_platform true"
-
-    build_repo2 do
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.5.1")
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.5.1") {|s| s.platform = "x86_64-linux" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.5.1") {|s| s.platform = "x86-mingw32" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.5.1") {|s| s.platform = "x86-linux" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.5.1") {|s| s.platform = "x64-mingw32" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.5.1") {|s| s.platform = "universal-darwin" }
-
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.5") {|s| s.platform = "x86_64-linux" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.5") {|s| s.platform = "x86-linux" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.5") {|s| s.platform = "x64-mingw32" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.5") {|s| s.platform = "x86-mingw32" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.5")
-
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.4") {|s| s.platform = "universal-darwin" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.4") {|s| s.platform = "x86_64-linux" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.4") {|s| s.platform = "x86-mingw32" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.4") {|s| s.platform = "x86-linux" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.4") {|s| s.platform = "x64-mingw32" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.4")
-
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.3")
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.3") {|s| s.platform = "x86_64-linux" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.3") {|s| s.platform = "x86-mingw32" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.3") {|s| s.platform = "x86-linux" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.3") {|s| s.platform = "x64-mingw32" }
-      build_gem("google-protobuf", "3.0.0.alpha.5.0.3") {|s| s.platform = "universal-darwin" }
-
-      build_gem("google-protobuf", "3.0.0.alpha.4.0")
-      build_gem("google-protobuf", "3.0.0.alpha.3.1.pre")
-      build_gem("google-protobuf", "3.0.0.alpha.3")
-      build_gem("google-protobuf", "3.0.0.alpha.2.0")
-      build_gem("google-protobuf", "3.0.0.alpha.1.1")
-      build_gem("google-protobuf", "3.0.0.alpha.1.0")
-
-      build_gem("facter", "2.4.6")
-      build_gem("facter", "2.4.6") do |s|
-        s.platform = "universal-darwin"
-        s.add_runtime_dependency "CFPropertyList"
-      end
-      build_gem("CFPropertyList")
-    end
-  end
-
+RSpec.describe "bundle install with specific platforms" do
   let(:google_protobuf) { <<-G }
     source "#{file_uri_for(gem_repo2)}"
     gem "google-protobuf"
@@ -56,54 +9,239 @@ RSpec.describe "bundle install with spec
   context "when on a darwin machine" do
     before { simulate_platform "x86_64-darwin-15" }
 
-    it "locks to both the specific darwin platform and ruby" do
-      install_gemfile!(google_protobuf)
-      expect(the_bundle.locked_gems.platforms).to eq([pl("ruby"), pl("x86_64-darwin-15")])
+    it "locks to the specific darwin platform" do
+      setup_multiplatform_gem
+      install_gemfile(google_protobuf)
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+      expect(the_bundle.locked_gems.platforms).to eq([pl("x86_64-darwin-15")])
       expect(the_bundle).to include_gem("google-protobuf 3.0.0.alpha.5.0.5.1 universal-darwin")
       expect(the_bundle.locked_gems.specs.map(&:full_name)).to eq(%w[
-        google-protobuf-3.0.0.alpha.5.0.5.1
         google-protobuf-3.0.0.alpha.5.0.5.1-universal-darwin
       ])
     end
 
-    it "caches both the universal-darwin and ruby gems when --all-platforms is passed" do
+    it "understands that a non-platform specific gem in a old lockfile doesn't necessarily mean installing the non-specific variant" do
+      setup_multiplatform_gem
+
+      system_gems "bundler-2.1.4"
+
+      # Consistent location to install and look for gems
+      bundle "config set --local path vendor/bundle", :env => { "BUNDLER_VERSION" => "2.1.4" }
+
+      install_gemfile(google_protobuf, :env => { "BUNDLER_VERSION" => "2.1.4" })
+
+      # simulate lockfile created with old bundler, which only locks for ruby platform
+      lockfile <<-L
+        GEM
+          remote: #{file_uri_for(gem_repo2)}/
+          specs:
+            google-protobuf (3.0.0.alpha.5.0.5.1)
+
+        PLATFORMS
+          ruby
+
+        DEPENDENCIES
+          google-protobuf
+
+        BUNDLED WITH
+           2.1.4
+      L
+
+      # force strict usage of the lock file by setting frozen mode
+      bundle "config set --local frozen true", :env => { "BUNDLER_VERSION" => "2.1.4" }
+
+      # make sure the platform that got actually installed with the old bundler is used
+      expect(the_bundle).to include_gem("google-protobuf 3.0.0.alpha.5.0.5.1 universal-darwin")
+    end
+
+    it "understands that a non-platform specific gem in a new lockfile locked only to RUBY doesn't necessarily mean installing the non-specific variant" do
+      setup_multiplatform_gem
+
+      system_gems "bundler-2.1.4"
+
+      # Consistent location to install and look for gems
+      bundle "config set --local path vendor/bundle", :env => { "BUNDLER_VERSION" => "2.1.4" }
+
+      gemfile google_protobuf
+
+      # simulate lockfile created with old bundler, which only locks for ruby platform
+      lockfile <<-L
+        GEM
+          remote: #{file_uri_for(gem_repo2)}/
+          specs:
+            google-protobuf (3.0.0.alpha.4.0)
+
+        PLATFORMS
+          ruby
+
+        DEPENDENCIES
+          google-protobuf
+
+        BUNDLED WITH
+           2.1.4
+      L
+
+      bundle "update", :env => { "BUNDLER_VERSION" => Bundler::VERSION }
+
+      # make sure the platform that the platform specific dependency is used, since we're only locked to ruby
+      expect(the_bundle).to include_gem("google-protobuf 3.0.0.alpha.5.0.5.1 universal-darwin")
+
+      # make sure we're still only locked to ruby
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo2)}/
+          specs:
+            google-protobuf (3.0.0.alpha.5.0.5.1)
+
+        PLATFORMS
+          ruby
+
+        DEPENDENCIES
+          google-protobuf
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+    end
+
+    it "doesn't discard previously installed platform specific gem and fall back to ruby on subsequent bundles" do
+      build_repo2 do
+        build_gem("libv8", "8.4.255.0")
+        build_gem("libv8", "8.4.255.0") {|s| s.platform = "universal-darwin" }
+
+        build_gem("mini_racer", "1.0.0") do |s|
+          s.add_runtime_dependency "libv8"
+        end
+      end
+
+      system_gems "bundler-2.1.4"
+
+      # Consistent location to install and look for gems
+      bundle "config set --local path vendor/bundle", :env => { "BUNDLER_VERSION" => "2.1.4" }
+
+      gemfile <<-G
+        source "https://localgemserver.test"
+        gem "libv8"
+      G
+
+      # simulate lockfile created with old bundler, which only locks for ruby platform
+      lockfile <<-L
+        GEM
+          remote: https://localgemserver.test/
+          specs:
+            libv8 (8.4.255.0)
+
+        PLATFORMS
+          ruby
+
+        DEPENDENCIES
+          libv8
+
+        BUNDLED WITH
+           2.1.4
+      L
+
+      bundle "install --verbose", :artifice => "compact_index", :env => { "BUNDLER_VERSION" => "2.1.4", "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
+      expect(out).to include("Installing libv8 8.4.255.0 (universal-darwin)")
+
+      bundle "add mini_racer --verbose", :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
+      expect(out).to include("Using libv8 8.4.255.0 (universal-darwin)")
+    end
+
+    it "caches the universal-darwin gem when --all-platforms is passed and properly picks it up on further bundler invocations" do
+      setup_multiplatform_gem
       gemfile(google_protobuf)
-      bundle! "package --all-platforms"
-      expect([cached_gem("google-protobuf-3.0.0.alpha.5.0.5.1"), cached_gem("google-protobuf-3.0.0.alpha.5.0.5.1-universal-darwin")]).
-        to all(exist)
+      bundle "cache --all-platforms"
+      expect(cached_gem("google-protobuf-3.0.0.alpha.5.0.5.1-universal-darwin")).to exist
+
+      bundle "install --verbose"
+      expect(err).to be_empty
+    end
+
+    it "caches the universal-darwin gem when cache_all_platforms is configured and properly picks it up on further bundler invocations" do
+      setup_multiplatform_gem
+      gemfile(google_protobuf)
+      bundle "config set --local cache_all_platforms true"
+      bundle "cache"
+      expect(cached_gem("google-protobuf-3.0.0.alpha.5.0.5.1-universal-darwin")).to exist
+
+      bundle "install --verbose"
+      expect(err).to be_empty
+    end
+
+    it "caches multiplatform git gems with a single gemspec when --all-platforms is passed" do
+      git = build_git "pg_array_parser", "1.0"
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "pg_array_parser", :git => "#{lib_path("pg_array_parser-1.0")}"
+      G
+
+      lockfile <<-L
+        GIT
+          remote: #{lib_path("pg_array_parser-1.0")}
+          revision: #{git.ref_for("main")}
+          specs:
+            pg_array_parser (1.0-java)
+            pg_array_parser (1.0)
+
+        GEM
+          specs:
+
+        PLATFORMS
+          java
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          pg_array_parser!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      bundle "config set --local cache_all true"
+      bundle "cache --all-platforms"
+
+      expect(err).to be_empty
     end
 
     it "uses the platform-specific gem with extra dependencies" do
-      install_gemfile! <<-G
+      setup_multiplatform_gem_with_different_dependencies_per_platform
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
         gem "facter"
       G
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
 
-      expect(the_bundle.locked_gems.platforms).to eq([pl("ruby"), pl("x86_64-darwin-15")])
+      expect(the_bundle.locked_gems.platforms).to eq([pl("x86_64-darwin-15")])
       expect(the_bundle).to include_gems("facter 2.4.6 universal-darwin", "CFPropertyList 1.0")
       expect(the_bundle.locked_gems.specs.map(&:full_name)).to eq(["CFPropertyList-1.0",
-                                                                   "facter-2.4.6",
                                                                    "facter-2.4.6-universal-darwin"])
     end
 
     context "when adding a platform via lock --add_platform" do
+      before do
+        allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+      end
+
       it "adds the foreign platform" do
-        install_gemfile!(google_protobuf)
-        bundle! "lock --add-platform=#{x64_mingw}"
+        setup_multiplatform_gem
+        install_gemfile(google_protobuf)
+        bundle "lock --add-platform=#{x64_mingw32}"
 
-        expect(the_bundle.locked_gems.platforms).to eq([rb, x64_mingw, pl("x86_64-darwin-15")])
+        expect(the_bundle.locked_gems.platforms).to eq([x64_mingw32, pl("x86_64-darwin-15")])
         expect(the_bundle.locked_gems.specs.map(&:full_name)).to eq(%w[
-          google-protobuf-3.0.0.alpha.5.0.5.1
           google-protobuf-3.0.0.alpha.5.0.5.1-universal-darwin
           google-protobuf-3.0.0.alpha.5.0.5.1-x64-mingw32
         ])
       end
 
       it "falls back on plain ruby when that version doesnt have a platform-specific gem" do
-        install_gemfile!(google_protobuf)
-        bundle! "lock --add-platform=#{java}"
+        setup_multiplatform_gem
+        install_gemfile(google_protobuf)
+        bundle "lock --add-platform=#{java}"
 
-        expect(the_bundle.locked_gems.platforms).to eq([java, rb, pl("x86_64-darwin-15")])
+        expect(the_bundle.locked_gems.platforms).to eq([java, pl("x86_64-darwin-15")])
         expect(the_bundle.locked_gems.specs.map(&:full_name)).to eq(%w[
           google-protobuf-3.0.0.alpha.5.0.5.1
           google-protobuf-3.0.0.alpha.5.0.5.1-universal-darwin
@@ -111,4 +249,389 @@ RSpec.describe "bundle install with spec
       end
     end
   end
+
+  it "installs sorbet-static, which does not provide a pure ruby variant, just fine", :truffleruby do
+    skip "does not apply to Windows" if Gem.win_platform?
+
+    build_repo2 do
+      build_gem("sorbet-static", "0.5.6403") {|s| s.platform = Bundler.local_platform }
+    end
+
+    gemfile <<~G
+      source "#{file_uri_for(gem_repo2)}"
+
+      gem "sorbet-static", "0.5.6403"
+    G
+
+    lockfile <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo2)}/
+        specs:
+          sorbet-static (0.5.6403-#{Bundler.local_platform})
+
+      PLATFORMS
+        ruby
+
+      DEPENDENCIES
+        sorbet-static (= 0.5.6403)
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    bundle "install --verbose"
+  end
+
+  it "does not resolve if the current platform does not match any of available platform specific variants for a top level dependency" do
+    build_repo4 do
+      build_gem("sorbet-static", "0.5.6433") {|s| s.platform = "x86_64-linux" }
+      build_gem("sorbet-static", "0.5.6433") {|s| s.platform = "universal-darwin-20" }
+    end
+
+    gemfile <<~G
+      source "#{file_uri_for(gem_repo4)}"
+
+      gem "sorbet-static", "0.5.6433"
+    G
+
+    error_message = <<~ERROR.strip
+      Could not find gem 'sorbet-static (= 0.5.6433)' with platform 'arm64-darwin-21' in rubygems repository #{file_uri_for(gem_repo4)}/ or installed locally.
+
+      The source contains the following gems matching 'sorbet-static (= 0.5.6433)':
+        * sorbet-static-0.5.6433-universal-darwin-20
+        * sorbet-static-0.5.6433-x86_64-linux
+    ERROR
+
+    simulate_platform "arm64-darwin-21" do
+      bundle "lock", :raise_on_error => false
+    end
+
+    expect(err).to include(error_message).once
+
+    # Make sure it doesn't print error twice in verbose mode
+
+    simulate_platform "arm64-darwin-21" do
+      bundle "lock --verbose", :raise_on_error => false
+    end
+
+    expect(err).to include(error_message).once
+  end
+
+  it "does not resolve if the current platform does not match any of available platform specific variants for a transitive dependency" do
+    build_repo4 do
+      build_gem("sorbet", "0.5.6433") {|s| s.add_dependency "sorbet-static", "= 0.5.6433" }
+      build_gem("sorbet-static", "0.5.6433") {|s| s.platform = "x86_64-linux" }
+      build_gem("sorbet-static", "0.5.6433") {|s| s.platform = "universal-darwin-20" }
+    end
+
+    gemfile <<~G
+      source "#{file_uri_for(gem_repo4)}"
+
+      gem "sorbet", "0.5.6433"
+    G
+
+    error_message = <<~ERROR.strip
+      Could not find gem 'sorbet-static (= 0.5.6433)' with platform 'arm64-darwin-21', which is required by gem 'sorbet (= 0.5.6433)', in rubygems repository #{file_uri_for(gem_repo4)}/ or installed locally.
+
+      The source contains the following gems matching 'sorbet-static (= 0.5.6433)':
+        * sorbet-static-0.5.6433-universal-darwin-20
+        * sorbet-static-0.5.6433-x86_64-linux
+    ERROR
+
+    simulate_platform "arm64-darwin-21" do
+      bundle "lock", :raise_on_error => false
+    end
+
+    expect(err).to include(error_message).once
+
+    # Make sure it doesn't print error twice in verbose mode
+
+    simulate_platform "arm64-darwin-21" do
+      bundle "lock --verbose", :raise_on_error => false
+    end
+
+    expect(err).to include(error_message).once
+  end
+
+  it "does not generate a lockfile if RUBY platform is forced and some gem has no RUBY variant available" do
+    build_repo4 do
+      build_gem("sorbet-static", "0.5.9889") {|s| s.platform = Gem::Platform.local }
+    end
+
+    gemfile <<~G
+      source "#{file_uri_for(gem_repo4)}"
+
+      gem "sorbet-static", "0.5.9889"
+    G
+
+    bundle "lock", :raise_on_error => false, :env => { "BUNDLE_FORCE_RUBY_PLATFORM" => "true" }
+
+    expect(err).to include <<~ERROR.rstrip
+      Could not find gem 'sorbet-static (= 0.5.9889)' with platform 'ruby' in rubygems repository #{file_uri_for(gem_repo4)}/ or installed locally.
+
+      The source contains the following gems matching 'sorbet-static (= 0.5.9889)':
+        * sorbet-static-0.5.9889-#{Gem::Platform.local}
+    ERROR
+  end
+
+  it "automatically fixes the lockfile if RUBY platform is locked and some gem has no RUBY variant available" do
+    build_repo4 do
+      build_gem("sorbet-static-and-runtime", "0.5.10160") do |s|
+        s.add_runtime_dependency "sorbet", "= 0.5.10160"
+        s.add_runtime_dependency "sorbet-runtime", "= 0.5.10160"
+      end
+
+      build_gem("sorbet", "0.5.10160") do |s|
+        s.add_runtime_dependency "sorbet-static", "= 0.5.10160"
+      end
+
+      build_gem("sorbet-runtime", "0.5.10160")
+
+      build_gem("sorbet-static", "0.5.10160") do |s|
+        s.platform = Gem::Platform.local
+      end
+    end
+
+    gemfile <<~G
+      source "#{file_uri_for(gem_repo4)}"
+
+      gem "sorbet-static-and-runtime"
+    G
+
+    lockfile <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          sorbet (0.5.10160)
+            sorbet-static (= 0.5.10160)
+          sorbet-runtime (0.5.10160)
+          sorbet-static (0.5.10160-#{Gem::Platform.local})
+          sorbet-static-and-runtime (0.5.10160)
+            sorbet (= 0.5.10160)
+            sorbet-runtime (= 0.5.10160)
+
+      PLATFORMS
+        #{lockfile_platforms_for([specific_local_platform, "ruby"])}
+
+      DEPENDENCIES
+        sorbet-static-and-runtime
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    bundle "update"
+
+    expect(lockfile).to eq <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          sorbet (0.5.10160)
+            sorbet-static (= 0.5.10160)
+          sorbet-runtime (0.5.10160)
+          sorbet-static (0.5.10160-#{Gem::Platform.local})
+          sorbet-static-and-runtime (0.5.10160)
+            sorbet (= 0.5.10160)
+            sorbet-runtime (= 0.5.10160)
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        sorbet-static-and-runtime
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+  end
+
+  it "automatically fixes the lockfile if only RUBY platform is locked and some gem has no RUBY variant available" do
+    build_repo4 do
+      build_gem("sorbet-static-and-runtime", "0.5.10160") do |s|
+        s.add_runtime_dependency "sorbet", "= 0.5.10160"
+        s.add_runtime_dependency "sorbet-runtime", "= 0.5.10160"
+      end
+
+      build_gem("sorbet", "0.5.10160") do |s|
+        s.add_runtime_dependency "sorbet-static", "= 0.5.10160"
+      end
+
+      build_gem("sorbet-runtime", "0.5.10160")
+
+      build_gem("sorbet-static", "0.5.10160") do |s|
+        s.platform = Gem::Platform.local
+      end
+    end
+
+    gemfile <<~G
+      source "#{file_uri_for(gem_repo4)}"
+
+      gem "sorbet-static-and-runtime"
+    G
+
+    lockfile <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          sorbet (0.5.10160)
+            sorbet-static (= 0.5.10160)
+          sorbet-runtime (0.5.10160)
+          sorbet-static (0.5.10160-#{Gem::Platform.local})
+          sorbet-static-and-runtime (0.5.10160)
+            sorbet (= 0.5.10160)
+            sorbet-runtime (= 0.5.10160)
+
+      PLATFORMS
+        ruby
+
+      DEPENDENCIES
+        sorbet-static-and-runtime
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    bundle "update"
+
+    expect(lockfile).to eq <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          sorbet (0.5.10160)
+            sorbet-static (= 0.5.10160)
+          sorbet-runtime (0.5.10160)
+          sorbet-static (0.5.10160-#{Gem::Platform.local})
+          sorbet-static-and-runtime (0.5.10160)
+            sorbet (= 0.5.10160)
+            sorbet-runtime (= 0.5.10160)
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        sorbet-static-and-runtime
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+  end
+
+  it "does not remove ruby if gems for other platforms, and not present in the lockfile, exist in the Gemfile" do
+    build_repo4 do
+      build_gem "nokogiri", "1.13.8"
+      build_gem "nokogiri", "1.13.8" do |s|
+        s.platform = Gem::Platform.local
+      end
+    end
+
+    gemfile <<~G
+      source "#{file_uri_for(gem_repo4)}"
+
+      gem "nokogiri"
+
+      gem "tzinfo", "~> 1.2", platform: :#{not_local_tag}
+    G
+
+    original_lockfile = <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          nokogiri (1.13.8)
+          nokogiri (1.13.8-#{Gem::Platform.local})
+
+      PLATFORMS
+        #{lockfile_platforms_for([specific_local_platform, "ruby"])}
+
+      DEPENDENCIES
+        nokogiri
+        tzinfo (~> 1.2)
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    lockfile original_lockfile
+
+    bundle "lock --update"
+
+    expect(lockfile).to eq(original_lockfile)
+  end
+
+  it "can fallback to a source gem when platform gems are incompatible with current ruby version" do
+    setup_multiplatform_gem_with_source_gem
+
+    source = file_uri_for(gem_repo2)
+
+    gemfile <<~G
+      source "#{source}"
+
+      gem "my-precompiled-gem"
+    G
+
+    # simulate lockfile which includes both a precompiled gem with:
+    # - Gem the current platform (with imcompatible ruby version)
+    # - A source gem with compatible ruby version
+    lockfile <<-L
+      GEM
+        remote: #{source}/
+        specs:
+          my-precompiled-gem (3.0.0)
+          my-precompiled-gem (3.0.0-#{Bundler.local_platform})
+
+      PLATFORMS
+        ruby
+        #{Bundler.local_platform}
+
+      DEPENDENCIES
+        my-precompiled-gem
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    bundle :install
+  end
+
+  private
+
+  def setup_multiplatform_gem
+    build_repo2 do
+      build_gem("google-protobuf", "3.0.0.alpha.5.0.5.1")
+      build_gem("google-protobuf", "3.0.0.alpha.5.0.5.1") {|s| s.platform = "x86_64-linux" }
+      build_gem("google-protobuf", "3.0.0.alpha.5.0.5.1") {|s| s.platform = "x64-mingw32" }
+      build_gem("google-protobuf", "3.0.0.alpha.5.0.5.1") {|s| s.platform = "universal-darwin" }
+
+      build_gem("google-protobuf", "3.0.0.alpha.5.0.5") {|s| s.platform = "x86_64-linux" }
+      build_gem("google-protobuf", "3.0.0.alpha.5.0.5") {|s| s.platform = "x64-mingw32" }
+      build_gem("google-protobuf", "3.0.0.alpha.5.0.5")
+
+      build_gem("google-protobuf", "3.0.0.alpha.5.0.4") {|s| s.platform = "universal-darwin" }
+
+      build_gem("google-protobuf", "3.0.0.alpha.4.0")
+      build_gem("google-protobuf", "3.0.0.alpha.3.1.pre")
+    end
+  end
+
+  def setup_multiplatform_gem_with_different_dependencies_per_platform
+    build_repo2 do
+      build_gem("facter", "2.4.6")
+      build_gem("facter", "2.4.6") do |s|
+        s.platform = "universal-darwin"
+        s.add_runtime_dependency "CFPropertyList"
+      end
+      build_gem("CFPropertyList")
+    end
+  end
+
+  def setup_multiplatform_gem_with_source_gem
+    build_repo2 do
+      build_gem("my-precompiled-gem", "3.0.0")
+      build_gem("my-precompiled-gem", "3.0.0") do |s|
+        s.platform = Bundler.local_platform
+
+        # purposely unresolvable
+        s.required_ruby_version = ">= 1000.0.0"
+      end
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemfile_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemfile_spec.rb
@@ -3,7 +3,9 @@
 RSpec.describe "bundle install" do
   context "with duplicated gems" do
     it "will display a warning" do
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
+
         gem 'rails', '~> 4.0.0'
         gem 'rails', '~> 4.0.0'
       G
@@ -44,62 +46,52 @@ RSpec.describe "bundle install" do
     end
     it "uses the gemfile while in a subdirectory" do
       bundled_app("subdir").mkpath
-      Dir.chdir(bundled_app("subdir")) do
-        bundle "install"
-        bundle "list"
+      bundle "install", :dir => bundled_app("subdir")
+      bundle "list", :dir => bundled_app("subdir")
 
-        expect(out).to include("rack (1.0.0)")
-      end
+      expect(out).to include("rack (1.0.0)")
     end
   end
 
   context "with deprecated features" do
-    before :each do
-      in_app_root
-    end
-
     it "reports that lib is an invalid option" do
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+
         gem "rack", :lib => "rack"
       G
 
-      bundle :install
+      bundle :install, :raise_on_error => false
       expect(err).to match(/You passed :lib as an option for gem 'rack', but it is invalid/)
     end
   end
 
-  context "with engine specified in symbol" do
+  context "with engine specified in symbol", :jruby_only do
     it "does not raise any error parsing Gemfile" do
-      simulate_ruby_version "2.3.0" do
-        simulate_ruby_engine "jruby", "9.1.2.0" do
-          install_gemfile! <<-G
-            source "#{file_uri_for(gem_repo1)}"
-            ruby "2.3.0", :engine => :jruby, :engine_version => "9.1.2.0"
-          G
-
-          expect(out).to match(/Bundle complete!/)
-        end
-      end
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby "#{RUBY_VERSION}", :engine => :jruby, :engine_version => "#{RUBY_ENGINE_VERSION}"
+      G
+
+      expect(out).to match(/Bundle complete!/)
     end
 
     it "installation succeeds" do
-      simulate_ruby_version "2.3.0" do
-        simulate_ruby_engine "jruby", "9.1.2.0" do
-          install_gemfile! <<-G
-            source "#{file_uri_for(gem_repo1)}"
-            ruby "2.3.0", :engine => :jruby, :engine_version => "9.1.2.0"
-            gem "rack"
-          G
-
-          expect(the_bundle).to include_gems "rack 1.0.0"
-        end
-      end
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        ruby "#{RUBY_VERSION}", :engine => :jruby, :engine_version => "#{RUBY_ENGINE_VERSION}"
+        gem "rack"
+      G
+
+      expect(the_bundle).to include_gems "rack 1.0.0"
     end
   end
 
   context "with a Gemfile containing non-US-ASCII characters" do
     it "reads the Gemfile with the UTF-8 encoding by default" do
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+
         str = "Il était une fois ..."
         puts "The source encoding is: " + str.encoding.name
       G
@@ -113,6 +105,8 @@ RSpec.describe "bundle install" do
       # NOTE: This works thanks to #eval interpreting the magic encoding comment
       install_gemfile <<-G
         # encoding: iso-8859-1
+        source "#{file_uri_for(gem_repo1)}"
+
         str = "Il #{"\xE9".dup.force_encoding("binary")}tait une fois ..."
         puts "The source encoding is: " + str.encoding.name
       G
--- ruby2.7-2.7.6.orig/spec/bundler/install/gems/compact_index_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gems/compact_index_spec.rb
@@ -10,7 +10,7 @@ RSpec.describe "compact index api" do
       gem "rack"
     G
 
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
     expect(out).to include("Fetching gem metadata from #{source_uri}")
     expect(the_bundle).to include_gems "rack 1.0.0"
   end
@@ -21,7 +21,7 @@ RSpec.describe "compact index api" do
       gem " sinatra"
     G
 
-    bundle :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index", :raise_on_error => false
     expect(err).to include("' sinatra' is not a valid gem name because it contains whitespace.")
   end
 
@@ -31,7 +31,7 @@ RSpec.describe "compact index api" do
       gem "rails"
     G
 
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
     expect(out).to include("Fetching gem metadata from #{source_uri}")
     expect(the_bundle).to include_gems(
       "rails 2.3.2",
@@ -51,7 +51,7 @@ RSpec.describe "compact index api" do
       build_gem "Rack", "0.1"
     end
 
-    install_gemfile! <<-G, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
+    install_gemfile <<-G, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
       source "#{source_uri}"
       gem "rack", "1.0"
       gem "Rack", "0.1"
@@ -59,7 +59,7 @@ RSpec.describe "compact index api" do
 
     # can't use `include_gems` here since the `require` will conflict on a
     # case-insensitive FS
-    run! "Bundler.require; puts Gem.loaded_specs.values_at('rack', 'Rack').map(&:full_name)"
+    run "Bundler.require; puts Gem.loaded_specs.values_at('rack', 'Rack').map(&:full_name)"
     expect(out).to eq("rack-1.0\nRack-0.1")
   end
 
@@ -69,18 +69,20 @@ RSpec.describe "compact index api" do
       gem "net-sftp"
     G
 
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
     expect(the_bundle).to include_gems "net-sftp 1.1.1"
   end
 
-  it "should use the endpoint when using --deployment" do
+  it "should use the endpoint when using deployment mode" do
     gemfile <<-G
       source "#{source_uri}"
       gem "rack"
     G
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
 
-    bundle! :install, forgotten_command_line_options(:deployment => true, :path => "vendor/bundle").merge(:artifice => "compact_index")
+    bundle "config set --local deployment true"
+    bundle "config set --local path vendor/bundle"
+    bundle :install, :artifice => "compact_index"
     expect(out).to include("Fetching gem metadata from #{source_uri}")
     expect(the_bundle).to include_gems "rack 1.0.0"
   end
@@ -98,12 +100,12 @@ RSpec.describe "compact index api" do
       end
     G
 
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
 
     expect(the_bundle).to include_gems("rails 2.3.2")
   end
 
-  it "handles git dependencies that are in rubygems using --deployment" do
+  it "handles git dependencies that are in rubygems using deployment mode" do
     build_git "foo" do |s|
       s.executables = "foobar"
       s.add_dependency "rails", "2.3.2"
@@ -114,14 +116,15 @@ RSpec.describe "compact index api" do
       gem 'foo', :git => "#{file_uri_for(lib_path("foo-1.0"))}"
     G
 
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
 
-    bundle "install --deployment", :artifice => "compact_index"
+    bundle "config set --local deployment true"
+    bundle :install, :artifice => "compact_index"
 
     expect(the_bundle).to include_gems("rails 2.3.2")
   end
 
-  it "doesn't fail if you only have a git gem with no deps when using --deployment" do
+  it "doesn't fail if you only have a git gem with no deps when using deployment mode" do
     build_git "foo"
     gemfile <<-G
       source "#{source_uri}"
@@ -129,31 +132,19 @@ RSpec.describe "compact index api" do
     G
 
     bundle "install", :artifice => "compact_index"
-    bundle! :install, forgotten_command_line_options(:deployment => true).merge(:artifice => "compact_index")
+    bundle "config set --local deployment true"
+    bundle :install, :artifice => "compact_index"
 
     expect(the_bundle).to include_gems("foo 1.0")
   end
 
-  it "falls back when the API errors out" do
-    simulate_platform mswin
-
-    gemfile <<-G
-      source "#{source_uri}"
-      gem "rcov"
-    G
-
-    bundle! :install, :artifice => "windows"
-    expect(out).to include("Fetching source index from #{source_uri}")
-    expect(the_bundle).to include_gems "rcov 1.0.0"
-  end
-
   it "falls back when the API URL returns 403 Forbidden" do
     gemfile <<-G
       source "#{source_uri}"
       gem "rack"
     G
 
-    bundle! :install, :verbose => true, :artifice => "compact_index_forbidden"
+    bundle :install, :verbose => true, :artifice => "compact_index_forbidden"
     expect(out).to include("Fetching gem metadata from #{source_uri}")
     expect(the_bundle).to include_gems "rack 1.0.0"
   end
@@ -164,7 +155,7 @@ RSpec.describe "compact index api" do
       gem "rack"
     G
 
-    bundle! :install, :verbose => true, :artifice => "compact_index_checksum_mismatch"
+    bundle :install, :verbose => true, :artifice => "compact_index_checksum_mismatch"
     expect(out).to include("Fetching gem metadata from #{source_uri}")
     expect(out).to include <<-'WARN'
 The checksum of /versions does not match the checksum provided by the server! Something is wrong (local checksum is "\"d41d8cd98f00b204e9800998ecf8427e\"", was expecting "\"123\"").
@@ -172,6 +163,25 @@ The checksum of /versions does not match
     expect(the_bundle).to include_gems "rack 1.0.0"
   end
 
+  it "shows proper path when permission errors happen", :permissions do
+    gemfile <<-G
+      source "#{source_uri}"
+      gem "rack"
+    G
+
+    versions = File.join(Bundler.rubygems.user_home, ".bundle", "cache", "compact_index",
+      "localgemserver.test.80.dd34752a738ee965a2a4298dc16db6c5", "versions")
+    FileUtils.mkdir_p(File.dirname(versions))
+    FileUtils.touch(versions)
+    FileUtils.chmod("-r", versions)
+
+    bundle :install, :artifice => "compact_index", :raise_on_error => false
+
+    expect(err).to include(
+      "There was an error while trying to read from `#{versions}`. It is likely that you need to grant read permissions for that path."
+    )
+  end
+
   it "falls back when the user's home directory does not exist or is not writable" do
     ENV["HOME"] = tmp("missing_home").to_s
 
@@ -180,7 +190,7 @@ The checksum of /versions does not match
       gem "rack"
     G
 
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
     expect(out).to include("Fetching gem metadata from #{source_uri}")
     expect(the_bundle).to include_gems "rack 1.0.0"
   end
@@ -191,7 +201,7 @@ The checksum of /versions does not match
       gem "rack"
     G
 
-    bundle! :install, :artifice => "compact_index_host_redirect"
+    bundle :install, :artifice => "compact_index_host_redirect"
     expect(the_bundle).to include_gems "rack 1.0.0"
   end
 
@@ -214,7 +224,7 @@ The checksum of /versions does not match
       H
     end
 
-    bundle! :install, :artifice => "compact_index_host_redirect", :requires => [lib_path("disable_net_http_persistent.rb")]
+    bundle :install, :artifice => "compact_index_host_redirect", :requires => [lib_path("disable_net_http_persistent.rb")]
     expect(out).to_not match(/Too many redirects/)
     expect(the_bundle).to include_gems "rack 1.0.0"
   end
@@ -225,7 +235,7 @@ The checksum of /versions does not match
       gem "rack"
     G
 
-    bundle :install, :artifice => "compact_index_redirects"
+    bundle :install, :artifice => "compact_index_redirects", :raise_on_error => false
     expect(err).to match(/Too many redirects/)
   end
 
@@ -247,21 +257,44 @@ The checksum of /versions does not match
         gem "rack"
       G
 
-      bundle! "update --full-index", :artifice => "compact_index", :all => true
+      bundle "update --full-index", :artifice => "compact_index", :all => true
       expect(out).to include("Fetching source index from #{source_uri}")
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
   end
 
   it "does not double check for gems that are only installed locally" do
-    system_gems %w[rack-1.0.0 thin-1.0 net_a-1.0]
-    bundle! "config set --local path.system true"
+    build_repo2 do
+      build_gem "net_a" do |s|
+        s.add_dependency "net_b"
+        s.add_dependency "net_build_extensions"
+      end
+
+      build_gem "net_b"
+
+      build_gem "net_build_extensions" do |s|
+        s.add_dependency "rake"
+        s.extensions << "Rakefile"
+        s.write "Rakefile", <<-RUBY
+          task :default do
+            path = File.expand_path("lib", __dir__)
+            FileUtils.mkdir_p(path)
+            File.open("\#{path}/net_build_extensions.rb", "w") do |f|
+              f.puts "NET_BUILD_EXTENSIONS = 'YES'"
+            end
+          end
+        RUBY
+      end
+    end
+
+    system_gems %w[rack-1.0.0 thin-1.0 net_a-1.0], :gem_repo => gem_repo2
+    bundle "config set --local path.system true"
     ENV["BUNDLER_SPEC_ALL_REQUESTS"] = strip_whitespace(<<-EOS).strip
       #{source_uri}/versions
       #{source_uri}/info/rack
     EOS
 
-    install_gemfile! <<-G, :artifice => "compact_index", :verbose => true
+    install_gemfile <<-G, :artifice => "compact_index", :verbose => true, :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
       source "#{source_uri}"
       gem "rack"
     G
@@ -283,7 +316,7 @@ The checksum of /versions does not match
       gem "back_deps"
     G
 
-    bundle! :install, :artifice => "compact_index_extra"
+    bundle :install, :artifice => "compact_index_extra"
     expect(the_bundle).to include_gems "back_deps 1.0", "foo 1.0"
   end
 
@@ -295,7 +328,7 @@ The checksum of /versions does not match
       FileUtils.rm_rf Dir[gem_repo2("gems/foo-*.gem")]
     end
 
-    install_gemfile! <<-G, :artifice => "compact_index_extra", :verbose => true
+    install_gemfile <<-G, :artifice => "compact_index_extra", :verbose => true
       source "#{source_uri}"
       source "#{source_uri}/extra" do
         gem "back_deps"
@@ -310,7 +343,7 @@ The checksum of /versions does not match
       source "#{source_uri}"
       gem "rack", "1.0.0"
     G
-    bundle! :install, :artifice => "compact_index_extra_api"
+    bundle :install, :artifice => "compact_index_extra_api"
     expect(the_bundle).to include_gems "rack 1.0.0"
 
     build_repo4 do
@@ -324,7 +357,7 @@ The checksum of /versions does not match
       source "#{source_uri}/extra"
       gem "rack", "1.2"
     G
-    bundle! :install, :artifice => "compact_index_extra_api"
+    bundle :install, :artifice => "compact_index_extra_api"
     expect(the_bundle).to include_gems "rack 1.2"
   end
 
@@ -346,32 +379,7 @@ The checksum of /versions does not match
       gem 'somegem', '1.0.0'
     G
 
-    bundle! :install, :artifice => "compact_index_extra_api"
-
-    expect(the_bundle).to include_gems "somegem 1.0.0"
-    expect(the_bundle).to include_gems "activesupport 1.2.3"
-  end
-
-  it "considers all possible versions of dependencies from all api gem sources when using blocks", :bundler => "< 3" do
-    # In this scenario, the gem "somegem" only exists in repo4.  It depends on specific version of activesupport that
-    # exists only in repo1.  There happens also be a version of activesupport in repo4, but not the one that version 1.0.0
-    # of somegem wants. This test makes sure that bundler actually finds version 1.2.3 of active support in the other
-    # repo and installs it.
-    build_repo4 do
-      build_gem "activesupport", "1.2.0"
-      build_gem "somegem", "1.0.0" do |s|
-        s.add_dependency "activesupport", "1.2.3" # This version exists only in repo1
-      end
-    end
-
-    gemfile <<-G
-      source "#{source_uri}"
-      source "#{source_uri}/extra" do
-        gem 'somegem', '1.0.0'
-      end
-    G
-
-    bundle! :install, :artifice => "compact_index_extra_api"
+    bundle :install, :artifice => "compact_index_extra_api"
 
     expect(the_bundle).to include_gems "somegem 1.0.0"
     expect(the_bundle).to include_gems "activesupport 1.2.3"
@@ -392,7 +400,7 @@ The checksum of /versions does not match
       end
     G
 
-    bundle! :install, :artifice => "compact_index_extra"
+    bundle :install, :artifice => "compact_index_extra"
 
     expect(out).to include("Fetching gem metadata from http://localgemserver.test/")
     expect(out).to include("Fetching source index from http://localgemserver.test/extra")
@@ -404,22 +412,19 @@ The checksum of /versions does not match
         s.add_dependency "foo"
       end
       build_gem "missing"
-      # need to hit the limit
-      1.upto(Bundler::Source::Rubygems::API_REQUEST_LIMIT) do |i|
-        build_gem "gem#{i}"
-      end
 
       FileUtils.rm_rf Dir[gem_repo2("gems/foo-*.gem")]
     end
 
-    gemfile <<-G
+    api_request_limit = low_api_request_limit_for(gem_repo2)
+
+    install_gemfile <<-G, :artifice => "compact_index_extra_missing", :requires => [api_request_limit_hack_file], :env => { "BUNDLER_SPEC_API_REQUEST_LIMIT" => api_request_limit.to_s }.merge(env_for_missing_prerelease_default_gem_activation)
       source "#{source_uri}"
       source "#{source_uri}/extra" do
         gem "back_deps"
       end
     G
 
-    bundle! :install, :artifice => "compact_index_extra_missing"
     expect(the_bundle).to include_gems "back_deps 1.0"
   end
 
@@ -429,15 +434,13 @@ The checksum of /versions does not match
         s.add_dependency "foo"
       end
       build_gem "missing"
-      # need to hit the limit
-      1.upto(Bundler::Source::Rubygems::API_REQUEST_LIMIT) do |i|
-        build_gem "gem#{i}"
-      end
 
       FileUtils.rm_rf Dir[gem_repo4("gems/foo-*.gem")]
     end
 
-    install_gemfile! <<-G, :artifice => "compact_index_extra_api_missing"
+    api_request_limit = low_api_request_limit_for(gem_repo4)
+
+    install_gemfile <<-G, :artifice => "compact_index_extra_api_missing", :requires => [api_request_limit_hack_file], :env => { "BUNDLER_SPEC_API_REQUEST_LIMIT" => api_request_limit.to_s }.merge(env_for_missing_prerelease_default_gem_activation)
       source "#{source_uri}"
       source "#{source_uri}/extra" do
         gem "back_deps"
@@ -454,11 +457,11 @@ The checksum of /versions does not match
       gem 'foo'
     G
 
-    bundle! :install, :artifice => "compact_index_api_missing"
+    bundle :install, :artifice => "compact_index_api_missing"
     expect(the_bundle).to include_gems "foo 1.0"
   end
 
-  it "fetches again when more dependencies are found in subsequent sources using --deployment", :bundler => "< 3" do
+  it "fetches again when more dependencies are found in subsequent sources using deployment mode", :bundler => "< 3" do
     build_repo2 do
       build_gem "back_deps" do |s|
         s.add_dependency "foo"
@@ -472,13 +475,13 @@ The checksum of /versions does not match
       gem "back_deps"
     G
 
-    bundle! :install, :artifice => "compact_index_extra"
-
-    bundle "install --deployment", :artifice => "compact_index_extra"
+    bundle :install, :artifice => "compact_index_extra"
+    bundle "config --set local deployment true"
+    bundle :install, :artifice => "compact_index_extra"
     expect(the_bundle).to include_gems "back_deps 1.0"
   end
 
-  it "fetches again when more dependencies are found in subsequent sources using --deployment with blocks" do
+  it "fetches again when more dependencies are found in subsequent sources using deployment mode with blocks" do
     build_repo2 do
       build_gem "back_deps" do |s|
         s.add_dependency "foo"
@@ -493,20 +496,26 @@ The checksum of /versions does not match
       end
     G
 
-    bundle! :install, :artifice => "compact_index_extra"
-
-    bundle "install --deployment", :artifice => "compact_index_extra"
+    bundle :install, :artifice => "compact_index_extra"
+    bundle "config set --local deployment true"
+    bundle :install, :artifice => "compact_index_extra"
     expect(the_bundle).to include_gems "back_deps 1.0"
   end
 
   it "does not refetch if the only unmet dependency is bundler" do
+    build_repo2 do
+      build_gem "bundler_dep" do |s|
+        s.add_dependency "bundler"
+      end
+    end
+
     gemfile <<-G
       source "#{source_uri}"
 
       gem "bundler_dep"
     G
 
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
     expect(out).to include("Fetching gem metadata from #{source_uri}")
   end
 
@@ -518,7 +527,7 @@ The checksum of /versions does not match
       source "#{source_uri}"
       gem "rails"
     G
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
     expect(the_bundle).to include_gems "rails 2.3.2"
   end
 
@@ -562,7 +571,7 @@ The checksum of /versions does not match
       gem 'rack-obama'
     G
 
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
     expect(out).to include("Post-install message from rack:")
   end
 
@@ -572,7 +581,7 @@ The checksum of /versions does not match
       gem 'rack_middleware'
     G
 
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
     expect(out).to include("Post-install message from rack:")
     expect(out).to include("Rack's post install message")
   end
@@ -581,7 +590,7 @@ The checksum of /versions does not match
     let(:user)     { "user" }
     let(:password) { "pass" }
     let(:basic_auth_source_uri) do
-      uri          = URI.parse(source_uri)
+      uri          = Bundler::URI.parse(source_uri)
       uri.user     = user
       uri.password = password
 
@@ -594,32 +603,22 @@ The checksum of /versions does not match
         gem "rack"
       G
 
-      bundle! :install, :artifice => "compact_index_basic_authentication"
+      bundle :install, :artifice => "compact_index_basic_authentication"
       expect(out).not_to include("#{user}:#{password}")
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
-    it "strips http basic authentication creds for modern index" do
+    it "passes basic authentication details and strips out creds also in verbose mode" do
       gemfile <<-G
         source "#{basic_auth_source_uri}"
         gem "rack"
       G
 
-      bundle! :install, :artifice => "endopint_marshal_fail_basic_authentication"
+      bundle :install, :verbose => true, :artifice => "compact_index_basic_authentication"
       expect(out).not_to include("#{user}:#{password}")
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
-    it "strips http basic auth creds when it can't reach the server" do
-      gemfile <<-G
-        source "#{basic_auth_source_uri}"
-        gem "rack"
-      G
-
-      bundle :install, :artifice => "endpoint_500"
-      expect(out).not_to include("#{user}:#{password}")
-    end
-
     it "strips http basic auth creds when warning about ambiguous sources", :bundler => "< 3" do
       gemfile <<-G
         source "#{basic_auth_source_uri}"
@@ -627,7 +626,7 @@ The checksum of /versions does not match
         gem "rack"
       G
 
-      bundle! :install, :artifice => "compact_index_basic_authentication"
+      bundle :install, :artifice => "compact_index_basic_authentication"
       expect(err).to include("Warning: the gem 'rack' was found in multiple sources.")
       expect(err).not_to include("#{user}:#{password}")
       expect(the_bundle).to include_gems "rack 1.0.0"
@@ -639,7 +638,7 @@ The checksum of /versions does not match
         gem "rack"
       G
 
-      bundle! :install, :artifice => "compact_index_creds_diff_host"
+      bundle :install, :artifice => "compact_index_creds_diff_host"
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
@@ -654,7 +653,7 @@ The checksum of /versions does not match
       it "reads authentication details by host name from bundle config" do
         bundle "config set #{source_hostname} #{user}:#{password}"
 
-        bundle! :install, :artifice => "compact_index_strict_basic_authentication"
+        bundle :install, :artifice => "compact_index_strict_basic_authentication"
 
         expect(out).to include("Fetching gem metadata from #{source_uri}")
         expect(the_bundle).to include_gems "rack 1.0.0"
@@ -664,7 +663,7 @@ The checksum of /versions does not match
         # The trailing slash is necessary here; Fetcher canonicalizes the URI.
         bundle "config set #{source_uri}/ #{user}:#{password}"
 
-        bundle! :install, :artifice => "compact_index_strict_basic_authentication"
+        bundle :install, :artifice => "compact_index_strict_basic_authentication"
 
         expect(out).to include("Fetching gem metadata from #{source_uri}")
         expect(the_bundle).to include_gems "rack 1.0.0"
@@ -672,7 +671,7 @@ The checksum of /versions does not match
 
       it "should use the API" do
         bundle "config set #{source_hostname} #{user}:#{password}"
-        bundle! :install, :artifice => "compact_index_strict_basic_authentication"
+        bundle :install, :artifice => "compact_index_strict_basic_authentication"
         expect(out).to include("Fetching gem metadata from #{source_uri}")
         expect(the_bundle).to include_gems "rack 1.0.0"
       end
@@ -685,19 +684,19 @@ The checksum of /versions does not match
 
         bundle "config set #{source_hostname} otheruser:wrong"
 
-        bundle! :install, :artifice => "compact_index_strict_basic_authentication"
+        bundle :install, :artifice => "compact_index_strict_basic_authentication"
         expect(the_bundle).to include_gems "rack 1.0.0"
       end
 
       it "shows instructions if auth is not provided for the source" do
-        bundle :install, :artifice => "compact_index_strict_basic_authentication"
-        expect(err).to include("bundle config set #{source_hostname} username:password")
+        bundle :install, :artifice => "compact_index_strict_basic_authentication", :raise_on_error => false
+        expect(err).to include("bundle config set --global #{source_hostname} username:password")
       end
 
       it "fails if authentication has already been provided, but failed" do
         bundle "config set #{source_hostname} #{user}:wrong"
 
-        bundle :install, :artifice => "compact_index_strict_basic_authentication"
+        bundle :install, :artifice => "compact_index_strict_basic_authentication", :raise_on_error => false
         expect(err).to include("Bad username or password")
       end
     end
@@ -711,7 +710,7 @@ The checksum of /versions does not match
           gem "rack"
         G
 
-        bundle! :install, :artifice => "compact_index_basic_authentication"
+        bundle :install, :artifice => "compact_index_basic_authentication"
         expect(the_bundle).to include_gems "rack 1.0.0"
       end
     end
@@ -736,7 +735,7 @@ The checksum of /versions does not match
         gem "rack"
       G
 
-      bundle :install, :env => { "RUBYOPT" => "-I#{bundled_app("broken_ssl")}" }
+      bundle :install, :env => { "RUBYOPT" => opt_add("-I#{bundled_app("broken_ssl")}", ENV["RUBYOPT"]) }, :raise_on_error => false
       expect(err).to include("OpenSSL")
     end
   end
@@ -756,29 +755,27 @@ The checksum of /versions does not match
         gem "rack"
       G
 
-      bundle :install
+      bundle :install, :raise_on_error => false
       expect(err).to match(/could not verify the SSL certificate/i)
     end
   end
 
   context ".gemrc with sources is present" do
-    before do
+    it "uses other sources declared in the Gemfile" do
       File.open(home(".gemrc"), "w") do |file|
         file.puts({ :sources => ["https://rubygems.org"] }.to_yaml)
       end
-    end
 
-    after do
-      home(".gemrc").rmtree
-    end
-
-    it "uses other sources declared in the Gemfile" do
-      gemfile <<-G
-        source "#{source_uri}"
-        gem 'rack'
-      G
+      begin
+        gemfile <<-G
+          source "#{source_uri}"
+          gem 'rack'
+        G
 
-      bundle! :install, :artifice => "compact_index_forbidden"
+        bundle :install, :artifice => "compact_index_forbidden"
+      ensure
+        home(".gemrc").rmtree
+      end
     end
   end
 
@@ -789,7 +786,7 @@ The checksum of /versions does not match
     G
 
     # Initial install creates the cached versions file
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
 
     # Update the Gemfile so we can check subsequent install was successful
     gemfile <<-G
@@ -798,7 +795,7 @@ The checksum of /versions does not match
     G
 
     # Second install should make only a partial request to /versions
-    bundle! :install, :artifice => "compact_index_partial_update"
+    bundle :install, :artifice => "compact_index_partial_update"
 
     expect(the_bundle).to include_gems "rack 1.0.0"
   end
@@ -815,12 +812,34 @@ The checksum of /versions does not match
     FileUtils.mkdir_p(File.dirname(versions))
     FileUtils.touch(versions)
 
-    bundle! :install, :artifice => "compact_index_concurrent_download"
+    bundle :install, :artifice => "compact_index_concurrent_download"
 
     expect(File.read(versions)).to start_with("created_at")
     expect(the_bundle).to include_gems "rack 1.0.0"
   end
 
+  it "performs full update if server endpoints serve partial content responses but don't have incremental content and provide no Etag" do
+    build_repo4 do
+      build_gem "rack", "0.9.1"
+    end
+
+    install_gemfile <<-G, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
+      source "#{source_uri}"
+      gem 'rack', '0.9.1'
+    G
+
+    update_repo4 do
+      build_gem "rack", "1.0.0"
+    end
+
+    install_gemfile <<-G, :artifice => "compact_index_partial_update_no_etag_not_incremental", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
+      source "#{source_uri}"
+      gem 'rack', '1.0.0'
+    G
+
+    expect(the_bundle).to include_gems "rack 1.0.0"
+  end
+
   it "performs full update of compact index info cache if range is not satisfiable" do
     gemfile <<-G
       source "#{source_uri}"
@@ -830,7 +849,7 @@ The checksum of /versions does not match
     rake_info_path = File.join(Bundler.rubygems.user_home, ".bundle", "cache", "compact_index",
       "localgemserver.test.80.dd34752a738ee965a2a4298dc16db6c5", "info", "rack")
 
-    bundle! :install, :artifice => "compact_index"
+    bundle :install, :artifice => "compact_index"
 
     expected_rack_info_content = File.read(rake_info_path)
 
@@ -845,7 +864,7 @@ The checksum of /versions does not match
 
     # The cache files now being longer means the requested range is going to be not satisfiable
     # Bundler must end up requesting the whole file to fix things up.
-    bundle! :install, :artifice => "compact_index_range_not_satisfiable"
+    bundle :install, :artifice => "compact_index_range_not_satisfiable"
 
     resulting_rack_info_content = File.read(rake_info_path)
 
@@ -853,11 +872,11 @@ The checksum of /versions does not match
   end
 
   it "fails gracefully when the source URI has an invalid scheme" do
-    install_gemfile <<-G
+    install_gemfile <<-G, :raise_on_error => false
       source "htps://rubygems.org"
       gem "rack"
     G
-    expect(exitstatus).to eq(15) if exitstatus
+    expect(exitstatus).to eq(15)
     expect(err).to end_with(<<-E.strip)
       The request uri `htps://index.rubygems.org/versions` has an invalid scheme (`htps`). Did you mean `http` or `https`?
     E
@@ -865,12 +884,12 @@ The checksum of /versions does not match
 
   describe "checksum validation" do
     it "raises when the checksum does not match" do
-      install_gemfile <<-G, :artifice => "compact_index_wrong_gem_checksum"
+      install_gemfile <<-G, :artifice => "compact_index_wrong_gem_checksum", :raise_on_error => false
         source "#{source_uri}"
         gem "rack"
       G
 
-      expect(exitstatus).to eq(19) if exitstatus
+      expect(exitstatus).to eq(19)
       expect(err).
         to  include("Bundler cannot continue installing rack (1.0.0).").
         and include("The checksum for the downloaded `rack-1.0.0.gem` does not match the checksum given by the server.").
@@ -879,23 +898,23 @@ The checksum of /versions does not match
         and include("1. delete the downloaded gem located at: `#{default_bundle_path}/gems/rack-1.0.0/rack-1.0.0.gem`").
         and include("2. run `bundle install`").
         and include("If you wish to continue installing the downloaded gem, and are certain it does not pose a security issue despite the mismatching checksum, do the following:").
-        and include("1. run `bundle config set disable_checksum_validation true` to turn off checksum verification").
+        and include("1. run `bundle config set --local disable_checksum_validation true` to turn off checksum verification").
         and include("2. run `bundle install`").
         and match(/\(More info: The expected SHA256 checksum was "#{"ab" * 22}", but the checksum for the downloaded gem was ".+?"\.\)/)
     end
 
     it "raises when the checksum is the wrong length" do
-      install_gemfile <<-G, :artifice => "compact_index_wrong_gem_checksum", :env => { "BUNDLER_SPEC_RACK_CHECKSUM" => "checksum!" }
+      install_gemfile <<-G, :artifice => "compact_index_wrong_gem_checksum", :env => { "BUNDLER_SPEC_RACK_CHECKSUM" => "checksum!", "DEBUG" => "1" }, :verbose => true, :raise_on_error => false
         source "#{source_uri}"
         gem "rack"
       G
-      expect(exitstatus).to eq(5) if exitstatus
+      expect(exitstatus).to eq(5)
       expect(err).to include("The given checksum for rack-1.0.0 (\"checksum!\") is not a valid SHA256 hexdigest nor base64digest")
     end
 
     it "does not raise when disable_checksum_validation is set" do
-      bundle! "config set disable_checksum_validation true"
-      install_gemfile! <<-G, :artifice => "compact_index_wrong_gem_checksum"
+      bundle "config set disable_checksum_validation true"
+      install_gemfile <<-G, :artifice => "compact_index_wrong_gem_checksum"
         source "#{source_uri}"
         gem "rack"
       G
@@ -903,7 +922,7 @@ The checksum of /versions does not match
   end
 
   it "works when cache dir is world-writable" do
-    install_gemfile! <<-G, :artifice => "compact_index"
+    install_gemfile <<-G, :artifice => "compact_index"
       File.umask(0000)
       source "#{source_uri}"
       gem "rack"
@@ -911,30 +930,32 @@ The checksum of /versions does not match
   end
 
   it "doesn't explode when the API dependencies are wrong" do
-    install_gemfile <<-G, :artifice => "compact_index_wrong_dependencies", :env => { "DEBUG" => "true" }
+    install_gemfile <<-G, :artifice => "compact_index_wrong_dependencies", :env => { "DEBUG" => "true" }, :raise_on_error => false
       source "#{source_uri}"
       gem "rails"
     G
-    deps = [Gem::Dependency.new("rake", "= 12.3.2"),
+    deps = [Gem::Dependency.new("rake", "= 13.0.1"),
             Gem::Dependency.new("actionpack", "= 2.3.2"),
             Gem::Dependency.new("activerecord", "= 2.3.2"),
             Gem::Dependency.new("actionmailer", "= 2.3.2"),
             Gem::Dependency.new("activeresource", "= 2.3.2")]
-    expect(out).to include(<<-E.strip).and include("rails-2.3.2 from rubygems remote at #{source_uri}/ has either corrupted API or lockfile dependencies")
+    expect(out).to include("rails-2.3.2 from rubygems remote at #{source_uri}/ has either corrupted API or lockfile dependencies")
+    expect(err).to include(<<-E.strip)
 Bundler::APIResponseMismatchError: Downloading rails-2.3.2 revealed dependencies not in the API or the lockfile (#{deps.map(&:to_s).join(", ")}).
 Either installing with `--full-index` or running `bundle update rails` should fix the problem.
     E
   end
 
   it "does not duplicate specs in the lockfile when updating and a dependency is not installed" do
-    install_gemfile! <<-G, :artifice => "compact_index"
+    install_gemfile <<-G, :artifice => "compact_index"
+      source "#{file_uri_for(gem_repo1)}"
       source "#{source_uri}" do
         gem "rails"
         gem "activemerchant"
       end
     G
-    gem_command! :uninstall, "activemerchant"
-    bundle! "update rails", :artifice => "compact_index"
+    gem_command "uninstall activemerchant"
+    bundle "update rails", :artifice => "compact_index"
     expect(lockfile.scan(/activemerchant \(/).size).to eq(1)
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gems/dependency_api_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gems/dependency_api_spec.rb
@@ -21,7 +21,7 @@ RSpec.describe "gemcutter's dependency A
       gem " sinatra"
     G
 
-    bundle :install, :artifice => "endpoint"
+    bundle :install, :artifice => "endpoint", :raise_on_error => false
     expect(err).to include("' sinatra' is not a valid gem name because it contains whitespace.")
   end
 
@@ -53,14 +53,16 @@ RSpec.describe "gemcutter's dependency A
     expect(the_bundle).to include_gems "net-sftp 1.1.1"
   end
 
-  it "should use the endpoint when using --deployment" do
+  it "should use the endpoint when using deployment mode" do
     gemfile <<-G
       source "#{source_uri}"
       gem "rack"
     G
     bundle :install, :artifice => "endpoint"
 
-    bundle! :install, forgotten_command_line_options(:deployment => true, :path => "vendor/bundle").merge(:artifice => "endpoint")
+    bundle "config set --local deployment true"
+    bundle "config set --local path vendor/bundle"
+    bundle :install, :artifice => "endpoint"
     expect(out).to include("Fetching gem metadata from #{source_uri}")
     expect(the_bundle).to include_gems "rack 1.0.0"
   end
@@ -83,7 +85,7 @@ RSpec.describe "gemcutter's dependency A
     expect(the_bundle).to include_gems("rails 2.3.2")
   end
 
-  it "handles git dependencies that are in rubygems using --deployment" do
+  it "handles git dependencies that are in rubygems using deployment mode" do
     build_git "foo" do |s|
       s.executables = "foobar"
       s.add_dependency "rails", "2.3.2"
@@ -96,12 +98,13 @@ RSpec.describe "gemcutter's dependency A
 
     bundle :install, :artifice => "endpoint"
 
-    bundle "install --deployment", :artifice => "endpoint"
+    bundle "config set --local deployment true"
+    bundle :install, :artifice => "endpoint"
 
     expect(the_bundle).to include_gems("rails 2.3.2")
   end
 
-  it "doesn't fail if you only have a git gem with no deps when using --deployment" do
+  it "doesn't fail if you only have a git gem with no deps when using deployment mode" do
     build_git "foo"
     gemfile <<-G
       source "#{source_uri}"
@@ -109,20 +112,29 @@ RSpec.describe "gemcutter's dependency A
     G
 
     bundle "install", :artifice => "endpoint"
-    bundle! :install, forgotten_command_line_options(:deployment => true).merge(:artifice => "endpoint")
+    bundle "config set --local deployment true"
+    bundle :install, :artifice => "endpoint"
 
     expect(the_bundle).to include_gems("foo 1.0")
   end
 
   it "falls back when the API errors out" do
-    simulate_platform mswin
+    simulate_platform x86_mswin32
+
+    build_repo2 do
+      # The rcov gem is platform mswin32, but has no arch
+      build_gem "rcov" do |s|
+        s.platform = Gem::Platform.new([nil, "mswin32", nil])
+        s.write "lib/rcov.rb", "RCOV = '1.0.0'"
+      end
+    end
 
     gemfile <<-G
       source "#{source_uri}"
       gem "rcov"
     G
 
-    bundle :install, :artifice => "windows"
+    bundle :install, :artifice => "windows", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
     expect(out).to include("Fetching source index from #{source_uri}")
     expect(the_bundle).to include_gems "rcov 1.0.0"
   end
@@ -215,7 +227,7 @@ RSpec.describe "gemcutter's dependency A
       gem "rack"
     G
 
-    bundle :install, :artifice => "endpoint_redirect"
+    bundle :install, :artifice => "endpoint_redirect", :raise_on_error => false
     expect(err).to match(/Too many redirects/)
   end
 
@@ -237,7 +249,7 @@ RSpec.describe "gemcutter's dependency A
         gem "rack"
       G
 
-      bundle! "update --full-index", :artifice => "endpoint", :all => true
+      bundle "update --full-index", :artifice => "endpoint", :all => true
       expect(out).to include("Fetching source index from #{source_uri}")
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
@@ -320,31 +332,6 @@ RSpec.describe "gemcutter's dependency A
       gem 'somegem', '1.0.0'
     G
 
-    bundle! :install, :artifice => "endpoint_extra_api"
-
-    expect(the_bundle).to include_gems "somegem 1.0.0"
-    expect(the_bundle).to include_gems "activesupport 1.2.3"
-  end
-
-  it "considers all possible versions of dependencies from all api gem sources using blocks" do
-    # In this scenario, the gem "somegem" only exists in repo4.  It depends on specific version of activesupport that
-    # exists only in repo1.  There happens also be a version of activesupport in repo4, but not the one that version 1.0.0
-    # of somegem wants. This test makes sure that bundler actually finds version 1.2.3 of active support in the other
-    # repo and installs it.
-    build_repo4 do
-      build_gem "activesupport", "1.2.0"
-      build_gem "somegem", "1.0.0" do |s|
-        s.add_dependency "activesupport", "1.2.3" # This version exists only in repo1
-      end
-    end
-
-    gemfile <<-G
-      source "#{source_uri}"
-      source "#{source_uri}/extra" do
-        gem 'somegem', '1.0.0'
-      end
-    G
-
     bundle :install, :artifice => "endpoint_extra_api"
 
     expect(the_bundle).to include_gems "somegem 1.0.0"
@@ -378,21 +365,18 @@ RSpec.describe "gemcutter's dependency A
         s.add_dependency "foo"
       end
       build_gem "missing"
-      # need to hit the limit
-      1.upto(Bundler::Source::Rubygems::API_REQUEST_LIMIT) do |i|
-        build_gem "gem#{i}"
-      end
 
       FileUtils.rm_rf Dir[gem_repo2("gems/foo-*.gem")]
     end
 
-    gemfile <<-G
+    api_request_limit = low_api_request_limit_for(gem_repo2)
+
+    install_gemfile <<-G, :artifice => "endpoint_extra_missing", :requires => [api_request_limit_hack_file], :env => { "BUNDLER_SPEC_API_REQUEST_LIMIT" => api_request_limit.to_s }.merge(env_for_missing_prerelease_default_gem_activation)
       source "#{source_uri}"
       source "#{source_uri}/extra"
       gem "back_deps"
     G
 
-    bundle :install, :artifice => "endpoint_extra_missing"
     expect(the_bundle).to include_gems "back_deps 1.0"
   end
 
@@ -402,37 +386,23 @@ RSpec.describe "gemcutter's dependency A
         s.add_dependency "foo"
       end
       build_gem "missing"
-      # need to hit the limit
-      1.upto(Bundler::Source::Rubygems::API_REQUEST_LIMIT) do |i|
-        build_gem "gem#{i}"
-      end
 
       FileUtils.rm_rf Dir[gem_repo2("gems/foo-*.gem")]
     end
 
-    gemfile <<-G
+    api_request_limit = low_api_request_limit_for(gem_repo2)
+
+    install_gemfile <<-G, :artifice => "endpoint_extra_missing", :requires => [api_request_limit_hack_file], :env => { "BUNDLER_SPEC_API_REQUEST_LIMIT" => api_request_limit.to_s }.merge(env_for_missing_prerelease_default_gem_activation)
       source "#{source_uri}"
       source "#{source_uri}/extra" do
         gem "back_deps"
       end
     G
 
-    bundle :install, :artifice => "endpoint_extra_missing"
     expect(the_bundle).to include_gems "back_deps 1.0"
   end
 
-  it "uses the endpoint if all sources support it" do
-    gemfile <<-G
-      source "#{source_uri}"
-
-      gem 'foo'
-    G
-
-    bundle :install, :artifice => "endpoint_api_missing"
-    expect(the_bundle).to include_gems "foo 1.0"
-  end
-
-  it "fetches again when more dependencies are found in subsequent sources using --deployment", :bundler => "< 3" do
+  it "fetches again when more dependencies are found in subsequent sources using deployment mode", :bundler => "< 3" do
     build_repo2 do
       build_gem "back_deps" do |s|
         s.add_dependency "foo"
@@ -447,12 +417,12 @@ RSpec.describe "gemcutter's dependency A
     G
 
     bundle :install, :artifice => "endpoint_extra"
-
-    bundle "install --deployment", :artifice => "endpoint_extra"
+    bundle "config set --local deployment true"
+    bundle :install, :artifice => "endpoint_extra"
     expect(the_bundle).to include_gems "back_deps 1.0"
   end
 
-  it "fetches again when more dependencies are found in subsequent sources using --deployment with blocks" do
+  it "fetches again when more dependencies are found in subsequent sources using deployment mode with blocks" do
     build_repo2 do
       build_gem "back_deps" do |s|
         s.add_dependency "foo"
@@ -468,19 +438,41 @@ RSpec.describe "gemcutter's dependency A
     G
 
     bundle :install, :artifice => "endpoint_extra"
-
-    bundle "install --deployment", :artifice => "endpoint_extra"
+    bundle "config set --local deployment true"
+    bundle "install", :artifice => "endpoint_extra"
     expect(the_bundle).to include_gems "back_deps 1.0"
   end
 
+  it "does not fetch all marshaled specs" do
+    build_repo2 do
+      build_gem "foo", "1.0"
+      build_gem "foo", "2.0"
+    end
+
+    install_gemfile <<-G, :artifice => "endpoint", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }, :verbose => true
+      source "#{source_uri}"
+
+      gem "foo"
+    G
+
+    expect(out).to include("foo-2.0.gemspec.rz")
+    expect(out).not_to include("foo-1.0.gemspec.rz")
+  end
+
   it "does not refetch if the only unmet dependency is bundler" do
+    build_repo2 do
+      build_gem "bundler_dep" do |s|
+        s.add_dependency "bundler"
+      end
+    end
+
     gemfile <<-G
       source "#{source_uri}"
 
       gem "bundler_dep"
     G
 
-    bundle :install, :artifice => "endpoint"
+    bundle :install, :artifice => "endpoint", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
     expect(out).to include("Fetching gem metadata from #{source_uri}")
   end
 
@@ -555,7 +547,7 @@ RSpec.describe "gemcutter's dependency A
     let(:user)     { "user" }
     let(:password) { "pass" }
     let(:basic_auth_source_uri) do
-      uri          = URI.parse(source_uri)
+      uri          = Bundler::URI.parse(source_uri)
       uri.user     = user
       uri.password = password
 
@@ -573,13 +565,24 @@ RSpec.describe "gemcutter's dependency A
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
+    it "passes basic authentication details and strips out creds also in verbose mode" do
+      gemfile <<-G
+        source "#{basic_auth_source_uri}"
+        gem "rack"
+      G
+
+      bundle :install, :verbose => true, :artifice => "endpoint_basic_authentication"
+      expect(out).not_to include("#{user}:#{password}")
+      expect(the_bundle).to include_gems "rack 1.0.0"
+    end
+
     it "strips http basic authentication creds for modern index" do
       gemfile <<-G
         source "#{basic_auth_source_uri}"
         gem "rack"
       G
 
-      bundle :install, :artifice => "endopint_marshal_fail_basic_authentication"
+      bundle :install, :artifice => "endpoint_marshal_fail_basic_authentication"
       expect(out).not_to include("#{user}:#{password}")
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
@@ -590,7 +593,7 @@ RSpec.describe "gemcutter's dependency A
         gem "rack"
       G
 
-      bundle :install, :artifice => "endpoint_500"
+      bundle :install, :artifice => "endpoint_500", :raise_on_error => false
       expect(out).not_to include("#{user}:#{password}")
     end
 
@@ -617,6 +620,22 @@ RSpec.describe "gemcutter's dependency A
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
+    describe "with host including dashes" do
+      before do
+        gemfile <<-G
+          source "http://local-gemserver.test"
+          gem "rack"
+        G
+      end
+
+      it "reads authentication details from a valid ENV variable" do
+        bundle :install, :artifice => "endpoint_strict_basic_authentication", :env => { "BUNDLE_LOCAL___GEMSERVER__TEST" => "#{user}:#{password}" }
+
+        expect(out).to include("Fetching gem metadata from http://local-gemserver.test")
+        expect(the_bundle).to include_gems "rack 1.0.0"
+      end
+    end
+
     describe "with authentication details in bundle config" do
       before do
         gemfile <<-G
@@ -664,14 +683,14 @@ RSpec.describe "gemcutter's dependency A
       end
 
       it "shows instructions if auth is not provided for the source" do
-        bundle :install, :artifice => "endpoint_strict_basic_authentication"
-        expect(err).to include("bundle config set #{source_hostname} username:password")
+        bundle :install, :artifice => "endpoint_strict_basic_authentication", :raise_on_error => false
+        expect(err).to include("bundle config set --global #{source_hostname} username:password")
       end
 
       it "fails if authentication has already been provided, but failed" do
         bundle "config set #{source_hostname} #{user}:wrong"
 
-        bundle :install, :artifice => "endpoint_strict_basic_authentication"
+        bundle :install, :artifice => "endpoint_strict_basic_authentication", :raise_on_error => false
         expect(err).to include("Bad username or password")
       end
     end
@@ -710,7 +729,7 @@ RSpec.describe "gemcutter's dependency A
         gem "rack"
       G
 
-      bundle :install, :env => { "RUBYOPT" => "-I#{bundled_app("broken_ssl")}" }
+      bundle :install, :env => { "RUBYOPT" => opt_add("-I#{bundled_app("broken_ssl")}", ENV["RUBYOPT"]) }, :raise_on_error => false
       expect(err).to include("OpenSSL")
     end
   end
@@ -730,31 +749,27 @@ RSpec.describe "gemcutter's dependency A
         gem "rack"
       G
 
-      bundle :install
+      bundle :install, :raise_on_error => false
       expect(err).to match(/could not verify the SSL certificate/i)
     end
   end
 
   context ".gemrc with sources is present" do
-    before do
+    it "uses other sources declared in the Gemfile" do
       File.open(home(".gemrc"), "w") do |file|
         file.puts({ :sources => ["https://rubygems.org"] }.to_yaml)
       end
-    end
-
-    after do
-      home(".gemrc").rmtree
-    end
-
-    it "uses other sources declared in the Gemfile" do
-      gemfile <<-G
-        source "#{source_uri}"
-        gem 'rack'
-      G
 
-      bundle "install", :artifice => "endpoint_marshal_fail"
+      begin
+        gemfile <<-G
+          source "#{source_uri}"
+          gem 'rack'
+        G
 
-      expect(exitstatus).to eq(0) if exitstatus
+        bundle "install", :artifice => "endpoint_marshal_fail"
+      ensure
+        home(".gemrc").rmtree
+      end
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gems/flex_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gems/flex_spec.rb
@@ -156,7 +156,7 @@ RSpec.describe "bundle flex_install" do
     end
   end
 
-  describe "when Gemfile conflicts with lockfile" do
+  describe "when running bundle install and Gemfile conflicts with lockfile" do
     before(:each) do
       build_repo2
       install_gemfile <<-G
@@ -166,8 +166,7 @@ RSpec.describe "bundle flex_install" do
 
       expect(the_bundle).to include_gems "rack_middleware 1.0", "rack 0.9.1"
 
-      build_repo2
-      update_repo2 do
+      build_repo2 do
         build_gem "rack-obama", "2.0" do |s|
           s.add_dependency "rack", "=1.2"
         end
@@ -184,34 +183,68 @@ RSpec.describe "bundle flex_install" do
     end
 
     it "does not install gems whose dependencies are not met" do
-      bundle :install
-      ruby <<-RUBY
+      bundle :install, :raise_on_error => false
+      ruby <<-RUBY, :raise_on_error => false
         require 'bundler/setup'
       RUBY
       expect(err).to match(/could not find gem 'rack-obama/i)
     end
 
-    it "suggests bundle update when the Gemfile requires different versions than the lock" do
+    it "discards the locked gems when the Gemfile requires different versions than the lock" do
       bundle "config set force_ruby_platform true"
 
       nice_error = <<-E.strip.gsub(/^ {8}/, "")
-        Bundler could not find compatible versions for gem "rack":
-          In snapshot (Gemfile.lock):
-            rack (= 0.9.1)
+        Could not find gem 'rack (= 1.2)', which is required by gem 'rack-obama (= 2.0)', in rubygems repository #{file_uri_for(gem_repo2)}/ or installed locally.
 
-          In Gemfile:
-            rack-obama (= 2.0) was resolved to 2.0, which depends on
-              rack (= 1.2)
+        The source contains the following gems matching 'rack':
+          * rack-0.9.1
+          * rack-1.0.0
+      E
+
+      bundle :install, :retry => 0, :raise_on_error => false
+      expect(err).to end_with(nice_error)
+    end
 
-            rack_middleware was resolved to 1.0, which depends on
-              rack (= 0.9.1)
+    it "does not include conflicts with a single requirement tree, because that can't possibly be a conflict" do
+      bundle "config set force_ruby_platform true"
 
-        Running `bundle update` will rebuild your snapshot from scratch, using only
-        the gems in your Gemfile, which may resolve the conflict.
+      bad_error = <<-E.strip.gsub(/^ {8}/, "")
+        Bundler could not find compatible versions for gem "rack-obama":
+          In Gemfile:
+            rack-obama (= 2.0)
       E
 
-      bundle :install, :retry => 0
-      expect(err).to end_with(nice_error)
+      bundle "update rack_middleware", :retry => 0, :raise_on_error => false
+      expect(err).not_to end_with(bad_error)
+    end
+  end
+
+  describe "when running bundle update and Gemfile conflicts with lockfile" do
+    before(:each) do
+      build_repo4 do
+        build_gem "jekyll-feed", "0.16.0"
+        build_gem "jekyll-feed", "0.15.1"
+
+        build_gem "github-pages", "226" do |s|
+          s.add_dependency "jekyll-feed", "0.15.1"
+        end
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "jekyll-feed", "~> 0.12"
+      G
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "github-pages", "~> 226"
+        gem "jekyll-feed", "~> 0.12"
+      G
+    end
+
+    it "discards the conflicting lockfile information and resolves properly" do
+      bundle :update, :raise_on_error => false, :all => true
+      expect(err).to be_empty
     end
   end
 
@@ -230,14 +263,27 @@ RSpec.describe "bundle flex_install" do
       G
     end
 
-    it "does something" do
-      expect do
-        bundle "install"
-      end.not_to change { File.read(bundled_app("Gemfile.lock")) }
-
-      expect(err).to include("rack = 0.9.1")
-      expect(err).to include("locked at 1.0.0")
-      expect(err).to include("bundle update rack")
+    it "should work when you install" do
+      bundle "install"
+
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo1)}/
+          specs:
+            rack (0.9.1)
+            rack-obama (1.0)
+              rack
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          rack (= 0.9.1)
+          rack-obama
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
     end
 
     it "should work when you update" do
@@ -246,68 +292,38 @@ RSpec.describe "bundle flex_install" do
   end
 
   describe "when adding a new source" do
-    it "updates the lockfile", :bundler => "< 3" do
+    it "updates the lockfile" do
       build_repo2
-      install_gemfile! <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-      G
-      install_gemfile! <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        source "#{file_uri_for(gem_repo2)}"
-        gem "rack"
-      G
-
-      lockfile_should_be <<-L
-      GEM
-        remote: #{file_uri_for(gem_repo1)}/
-        remote: #{file_uri_for(gem_repo2)}/
-        specs:
-          rack (1.0.0)
-
-      PLATFORMS
-        #{lockfile_platforms}
-
-      DEPENDENCIES
-        rack
-
-      BUNDLED WITH
-         #{Bundler::VERSION}
-      L
-    end
-
-    it "updates the lockfile", :bundler => "3" do
-      build_repo2
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
 
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         source "#{file_uri_for(gem_repo2)}" do
         end
         gem "rack"
       G
 
-      lockfile_should_be <<-L
-      GEM
-        remote: #{file_uri_for(gem_repo1)}/
-        specs:
-          rack (1.0.0)
-
-      GEM
-        remote: #{file_uri_for(gem_repo2)}/
-        specs:
+      expect(lockfile).to eq <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo1)}/
+          specs:
+            rack (1.0.0)
+
+        GEM
+          remote: #{file_uri_for(gem_repo2)}/
+          specs:
 
-      PLATFORMS
-        #{lockfile_platforms}
+        PLATFORMS
+          #{lockfile_platforms}
 
-      DEPENDENCIES
-        rack
+        DEPENDENCIES
+          rack
 
-      BUNDLED WITH
-         #{Bundler::VERSION}
+        BUNDLED WITH
+           #{Bundler::VERSION}
       L
     end
   end
@@ -332,7 +348,7 @@ RSpec.describe "bundle flex_install" do
       end
     end
 
-    it "prints the correct error message" do
+    it "resolves them" do
       # install Rails 3.0.0.rc
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
@@ -346,8 +362,7 @@ RSpec.describe "bundle flex_install" do
         gem "rails", "3.0.0"
         gem "capybara", "0.3.9"
       G
-
-      expect(err).to include("Gemfile.lock")
+      expect(err).to be_empty
     end
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/install/gems/fund_spec.rb
@@ -0,0 +1,164 @@
+# frozen_string_literal: true
+
+RSpec.describe "bundle install" do
+  context "with gem sources" do
+    before do
+      build_repo2 do
+        build_gem "has_funding_and_other_metadata" do |s|
+          s.metadata = {
+            "bug_tracker_uri"   => "https://example.com/user/bestgemever/issues",
+            "changelog_uri"     => "https://example.com/user/bestgemever/CHANGELOG.md",
+            "documentation_uri" => "https://www.example.info/gems/bestgemever/0.0.1",
+            "homepage_uri"      => "https://bestgemever.example.io",
+            "mailing_list_uri"  => "https://groups.example.com/bestgemever",
+            "funding_uri"       => "https://example.com/has_funding_and_other_metadata/funding",
+            "source_code_uri"   => "https://example.com/user/bestgemever",
+            "wiki_uri"          => "https://example.com/user/bestgemever/wiki",
+          }
+        end
+
+        build_gem "has_funding", "1.2.3" do |s|
+          s.metadata = {
+            "funding_uri"       => "https://example.com/has_funding/funding",
+          }
+        end
+
+        build_gem "gem_with_dependent_funding", "1.0" do |s|
+          s.add_dependency "has_funding"
+        end
+      end
+    end
+
+    context "when gems include a fund URI" do
+      it "displays the plural fund message after installing" do
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo2)}"
+          gem 'has_funding_and_other_metadata'
+          gem 'has_funding'
+          gem 'rack-obama'
+        G
+
+        expect(out).to include("2 installed gems you directly depend on are looking for funding.")
+      end
+
+      it "displays the singular fund message after installing" do
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo2)}"
+          gem 'has_funding'
+          gem 'rack-obama'
+        G
+
+        expect(out).to include("1 installed gem you directly depend on is looking for funding.")
+      end
+    end
+
+    context "when gems include a fund URI but `ignore_funding_requests` is configured" do
+      before do
+        bundle "config set ignore_funding_requests true"
+      end
+
+      it "does not display the plural fund message after installing" do
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo2)}"
+          gem 'has_funding_and_other_metadata'
+          gem 'has_funding'
+          gem 'rack-obama'
+        G
+
+        expect(out).not_to include("2 installed gems you directly depend on are looking for funding.")
+      end
+
+      it "does not display the singular fund message after installing" do
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo2)}"
+          gem 'has_funding'
+          gem 'rack-obama'
+        G
+
+        expect(out).not_to include("1 installed gem you directly depend on is looking for funding.")
+      end
+    end
+
+    context "when gems do not include fund messages" do
+      it "does not display any fund messages" do
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo2)}"
+          gem "activesupport"
+        G
+
+        expect(out).not_to include("gem you depend on")
+      end
+    end
+
+    context "when a dependency includes a fund message" do
+      it "does not display the fund message" do
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo2)}"
+          gem 'gem_with_dependent_funding'
+        G
+
+        expect(out).not_to include("gem you depend on")
+      end
+    end
+  end
+
+  context "with git sources" do
+    context "when gems include fund URI" do
+      it "displays the fund message after installing" do
+        build_git "also_has_funding" do |s|
+          s.metadata = {
+            "funding_uri" => "https://example.com/also_has_funding/funding",
+          }
+        end
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+          gem 'also_has_funding', :git => '#{lib_path("also_has_funding-1.0")}'
+        G
+
+        expect(out).to include("1 installed gem you directly depend on is looking for funding.")
+      end
+
+      it "displays the fund message if repo is updated" do
+        build_git "also_has_funding" do |s|
+          s.metadata = {
+            "funding_uri" => "https://example.com/also_has_funding/funding",
+          }
+        end
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+          gem 'also_has_funding', :git => '#{lib_path("also_has_funding-1.0")}'
+        G
+
+        build_git "also_has_funding", "1.1" do |s|
+          s.metadata = {
+            "funding_uri" => "https://example.com/also_has_funding/funding",
+          }
+        end
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+          gem 'also_has_funding', :git => '#{lib_path("also_has_funding-1.1")}'
+        G
+
+        expect(out).to include("1 installed gem you directly depend on is looking for funding.")
+      end
+
+      it "displays the fund message if repo is not updated" do
+        build_git "also_has_funding" do |s|
+          s.metadata = {
+            "funding_uri" => "https://example.com/also_has_funding/funding",
+          }
+        end
+        gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+          gem 'also_has_funding', :git => '#{lib_path("also_has_funding-1.0")}'
+        G
+
+        bundle :install
+        expect(out).to include("1 installed gem you directly depend on is looking for funding.")
+
+        bundle :install
+        expect(out).to include("1 installed gem you directly depend on is looking for funding.")
+      end
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gems/native_extensions_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gems/native_extensions_spec.rb
@@ -1,12 +1,13 @@
 # frozen_string_literal: true
 
-RSpec.describe "installing a gem with native extensions", :ruby_repo do
+RSpec.describe "installing a gem with native extensions" do
   it "installs" do
     build_repo2 do
       build_gem "c_extension" do |s|
         s.extensions = ["ext/extconf.rb"]
         s.write "ext/extconf.rb", <<-E
           require "mkmf"
+          $extout = "$(topdir)/" + RbConfig::CONFIG["EXTOUT"] unless RUBY_VERSION < "2.4"
           name = "c_extension_bundle"
           dir_config(name)
           raise "OMG" unless with_config("c_extension") == "hello"
@@ -40,7 +41,6 @@ RSpec.describe "installing a gem with na
     bundle "config set build.c_extension --with-c_extension=hello"
     bundle "install"
 
-    expect(out).not_to include("extconf.rb failed")
     expect(out).to include("Installing c_extension 1.0 with native extensions")
 
     run "Bundler.require; puts CExtension.new.its_true"
@@ -52,6 +52,7 @@ RSpec.describe "installing a gem with na
       s.extensions = ["ext/extconf.rb"]
       s.write "ext/extconf.rb", <<-E
         require "mkmf"
+        $extout = "$(topdir)/" + RbConfig::CONFIG["EXTOUT"] unless RUBY_VERSION < "2.4"
         name = "c_extension_bundle"
         dir_config(name)
         raise "OMG" unless with_config("c_extension") == "hello"
@@ -76,23 +77,80 @@ RSpec.describe "installing a gem with na
       C
     end
 
-    bundle! "config set build.c_extension --with-c_extension=hello"
+    bundle "config set build.c_extension --with-c_extension=hello"
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "c_extension", :git => #{lib_path("c_extension-1.0").to_s.dump}
     G
 
-    expect(out).not_to include("extconf.rb failed")
+    expect(err).to_not include("warning: conflicting chdir during another chdir block")
 
-    run! "Bundler.require; puts CExtension.new.its_true"
+    run "Bundler.require; puts CExtension.new.its_true"
     expect(out).to eq("true")
   end
 
+  it "installs correctly from git when multiple gems with extensions share one repository" do
+    build_repo2 do
+      ["one", "two"].each do |n|
+        build_lib "c_extension_#{n}", "1.0", :path => lib_path("gems/c_extension_#{n}") do |s|
+          s.extensions = ["ext/extconf.rb"]
+          s.write "ext/extconf.rb", <<-E
+            require "mkmf"
+            $extout = "$(topdir)/" + RbConfig::CONFIG["EXTOUT"] unless RUBY_VERSION < "2.4"
+            name = "c_extension_bundle_#{n}"
+            dir_config(name)
+            raise "OMG" unless with_config("c_extension_#{n}") == "#{n}"
+            create_makefile(name)
+          E
+
+          s.write "ext/c_extension_#{n}.c", <<-C
+            #include "ruby.h"
+
+            VALUE c_extension_#{n}_value(VALUE self) {
+              return rb_str_new_cstr("#{n}");
+            }
+
+            void Init_c_extension_bundle_#{n}() {
+              VALUE c_Extension = rb_define_class("CExtension_#{n}", rb_cObject);
+              rb_define_method(c_Extension, "value", c_extension_#{n}_value, 0);
+            }
+          C
+
+          s.write "lib/c_extension_#{n}.rb", <<-C
+            require "c_extension_bundle_#{n}"
+          C
+        end
+      end
+      build_git "gems", :path => lib_path("gems"), :gemspec => false
+    end
+
+    bundle "config set build.c_extension_one --with-c_extension_one=one"
+    bundle "config set build.c_extension_two --with-c_extension_two=two"
+
+    # 1st time, require only one gem -- only one of the extensions gets built.
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "c_extension_one", :git => #{lib_path("gems").to_s.dump}
+    G
+
+    # 2nd time, require both gems -- we need both extensions to be built now.
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "c_extension_one", :git => #{lib_path("gems").to_s.dump}
+      gem "c_extension_two", :git => #{lib_path("gems").to_s.dump}
+    G
+
+    run "Bundler.require; puts CExtension_one.new.value; puts CExtension_two.new.value"
+    expect(out).to eq("one\ntwo")
+  end
+
   it "install with multiple build flags" do
     build_git "c_extension" do |s|
       s.extensions = ["ext/extconf.rb"]
       s.write "ext/extconf.rb", <<-E
         require "mkmf"
+        $extout = "$(topdir)/" + RbConfig::CONFIG["EXTOUT"] unless RUBY_VERSION < "2.4"
         name = "c_extension_bundle"
         dir_config(name)
         raise "OMG" unless with_config("c_extension") == "hello" && with_config("c_extension_bundle-dir") == "hola"
@@ -117,15 +175,14 @@ RSpec.describe "installing a gem with na
       C
     end
 
-    bundle! "config set build.c_extension --with-c_extension=hello --with-c_extension_bundle-dir=hola"
+    bundle "config set build.c_extension --with-c_extension=hello --with-c_extension_bundle-dir=hola"
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "c_extension", :git => #{lib_path("c_extension-1.0").to_s.dump}
     G
 
-    expect(out).not_to include("extconf.rb failed")
-
-    run! "Bundler.require; puts CExtension.new.its_true"
+    run "Bundler.require; puts CExtension.new.its_true"
     expect(out).to eq("true")
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gems/post_install_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gems/post_install_spec.rb
@@ -33,7 +33,7 @@ RSpec.describe "bundle install" do
       end
     end
 
-    context "when a dependecy includes a post install message" do
+    context "when a dependency includes a post install message" do
       it "should display the post install message" do
         gemfile <<-G
           source "#{file_uri_for(gem_repo1)}"
--- ruby2.7-2.7.6.orig/spec/bundler/install/gems/resolving_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gems/resolving_spec.rb
@@ -1,9 +1,72 @@
 # frozen_string_literal: true
 
 RSpec.describe "bundle install with install-time dependencies" do
+  before do
+    build_repo2 do
+      build_gem "with_implicit_rake_dep" do |s|
+        s.extensions << "Rakefile"
+        s.write "Rakefile", <<-RUBY
+          task :default do
+            path = File.expand_path("lib", __dir__)
+            FileUtils.mkdir_p(path)
+            File.open("\#{path}/implicit_rake_dep.rb", "w") do |f|
+              f.puts "IMPLICIT_RAKE_DEP = 'YES'"
+            end
+          end
+        RUBY
+      end
+
+      build_gem "another_implicit_rake_dep" do |s|
+        s.extensions << "Rakefile"
+        s.write "Rakefile", <<-RUBY
+          task :default do
+            path = File.expand_path("lib", __dir__)
+            FileUtils.mkdir_p(path)
+            File.open("\#{path}/another_implicit_rake_dep.rb", "w") do |f|
+              f.puts "ANOTHER_IMPLICIT_RAKE_DEP = 'YES'"
+            end
+          end
+        RUBY
+      end
+
+      # Test complicated gem dependencies for install
+      build_gem "net_a" do |s|
+        s.add_dependency "net_b"
+        s.add_dependency "net_build_extensions"
+      end
+
+      build_gem "net_b"
+
+      build_gem "net_build_extensions" do |s|
+        s.add_dependency "rake"
+        s.extensions << "Rakefile"
+        s.write "Rakefile", <<-RUBY
+          task :default do
+            path = File.expand_path("lib", __dir__)
+            FileUtils.mkdir_p(path)
+            File.open("\#{path}/net_build_extensions.rb", "w") do |f|
+              f.puts "NET_BUILD_EXTENSIONS = 'YES'"
+            end
+          end
+        RUBY
+      end
+
+      build_gem "net_c" do |s|
+        s.add_dependency "net_a"
+        s.add_dependency "net_d"
+      end
+
+      build_gem "net_d"
+
+      build_gem "net_e" do |s|
+        s.add_dependency "net_d"
+      end
+    end
+  end
+
   it "installs gems with implicit rake dependencies" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+      source "#{file_uri_for(gem_repo2)}"
       gem "with_implicit_rake_dep"
       gem "another_implicit_rake_dep"
       gem "rake"
@@ -18,6 +81,25 @@ RSpec.describe "bundle install with inst
     expect(out).to eq("YES\nYES")
   end
 
+  it "installs gems with implicit rake dependencies without rake previously installed" do
+    with_path_as("") do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem "with_implicit_rake_dep"
+        gem "another_implicit_rake_dep"
+        gem "rake"
+      G
+    end
+
+    run <<-R
+      require 'implicit_rake_dep'
+      require 'another_implicit_rake_dep'
+      puts IMPLICIT_RAKE_DEP
+      puts ANOTHER_IMPLICIT_RAKE_DEP
+    R
+    expect(out).to eq("YES\nYES")
+  end
+
   it "installs gems with a dependency with no type" do
     build_repo2
 
@@ -26,7 +108,7 @@ RSpec.describe "bundle install with inst
     spec.dependencies.each do |d|
       d.instance_variable_set(:@type, :fail)
     end
-    File.open(path, "w") do |f|
+    File.open(path, "wb") do |f|
       f.write Gem.deflate(Marshal.dump(spec))
     end
 
@@ -41,7 +123,7 @@ RSpec.describe "bundle install with inst
   describe "with crazy rubygem plugin stuff" do
     it "installs plugins" do
       install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
+        source "#{file_uri_for(gem_repo2)}"
         gem "net_b"
       G
 
@@ -49,8 +131,8 @@ RSpec.describe "bundle install with inst
     end
 
     it "installs plugins depended on by other plugins" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
+      install_gemfile <<-G, :env => { "DEBUG" => "1" }
+        source "#{file_uri_for(gem_repo2)}"
         gem "net_a"
       G
 
@@ -58,8 +140,8 @@ RSpec.describe "bundle install with inst
     end
 
     it "installs multiple levels of dependencies" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
+      install_gemfile <<-G, :env => { "DEBUG" => "1" }
+        source "#{file_uri_for(gem_repo2)}"
         gem "net_c"
         gem "net_e"
       G
@@ -67,34 +149,50 @@ RSpec.describe "bundle install with inst
       expect(the_bundle).to include_gems "net_a 1.0", "net_b 1.0", "net_c 1.0", "net_d 1.0", "net_e 1.0"
     end
 
+    context "with ENV['BUNDLER_DEBUG_RESOLVER'] set" do
+      it "produces debug output" do
+        gemfile <<-G
+          source "#{file_uri_for(gem_repo2)}"
+          gem "net_c"
+          gem "net_e"
+        G
+
+        bundle :install, :env => { "BUNDLER_DEBUG_RESOLVER" => "1", "DEBUG" => "1" }
+
+        expect(out).to include("BUNDLER: Starting resolution")
+      end
+    end
+
     context "with ENV['DEBUG_RESOLVER'] set" do
       it "produces debug output" do
         gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
+          source "#{file_uri_for(gem_repo2)}"
           gem "net_c"
           gem "net_e"
         G
 
-        bundle :install, :env => { "DEBUG_RESOLVER" => "1" }
+        bundle :install, :env => { "DEBUG_RESOLVER" => "1", "DEBUG" => "1" }
 
-        expect(err).to include("Creating possibility state for net_c")
+        expect(out).to include("BUNDLER: Starting resolution")
       end
     end
 
     context "with ENV['DEBUG_RESOLVER_TREE'] set" do
       it "produces debug output" do
         gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
+          source "#{file_uri_for(gem_repo2)}"
           gem "net_c"
           gem "net_e"
         G
 
-        bundle :install, :env => { "DEBUG_RESOLVER_TREE" => "1" }
+        bundle :install, :env => { "DEBUG_RESOLVER_TREE" => "1", "DEBUG" => "1" }
 
-        expect(err).to include(" net_b").
-          and include("Starting resolution").
-          and include("Finished resolution").
-          and include("Attempting to activate")
+        activated_groups = "net_b (1.0) (ruby), net_b (1.0) (#{specific_local_platform})"
+
+        expect(out).to include(" net_b").
+          and include("BUNDLER: Starting resolution").
+          and include("BUNDLER: Finished resolution").
+          and include("Attempting to activate [#{activated_groups}]")
       end
     end
   end
@@ -103,21 +201,202 @@ RSpec.describe "bundle install with inst
     context "allows only an older version" do
       it "installs the older version" do
         build_repo2 do
+          build_gem "rack", "1.2" do |s|
+            s.executables = "rackup"
+          end
+
           build_gem "rack", "9001.0.0" do |s|
             s.required_ruby_version = "> 9000"
           end
         end
 
         install_gemfile <<-G, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
-          ruby "#{RUBY_VERSION}"
+          ruby "#{Gem.ruby_version}"
+          source "http://localgemserver.test/"
+          gem 'rack'
+        G
+
+        expect(err).to_not include("rack-9001.0.0 requires ruby version > 9000")
+        expect(the_bundle).to include_gems("rack 1.2")
+      end
+
+      it "installs the older version when using servers not implementing the compact index API" do
+        build_repo2 do
+          build_gem "rack", "1.2" do |s|
+            s.executables = "rackup"
+          end
+
+          build_gem "rack", "9001.0.0" do |s|
+            s.required_ruby_version = "> 9000"
+          end
+        end
+
+        install_gemfile <<-G, :artifice => "endpoint", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
+          ruby "#{Gem.ruby_version}"
           source "http://localgemserver.test/"
           gem 'rack'
         G
 
-        expect(out).to_not include("rack-9001.0.0 requires ruby version > 9000")
+        expect(err).to_not include("rack-9001.0.0 requires ruby version > 9000")
         expect(the_bundle).to include_gems("rack 1.2")
       end
 
+      context "when there is a lockfile using the newer incompatible version" do
+        before do
+          build_repo2 do
+            build_gem "parallel_tests", "3.7.0" do |s|
+              s.required_ruby_version = ">= #{current_ruby_minor}"
+            end
+
+            build_gem "parallel_tests", "3.8.0" do |s|
+              s.required_ruby_version = ">= #{next_ruby_minor}"
+            end
+          end
+
+          gemfile <<-G
+            source "http://localgemserver.test/"
+            gem 'parallel_tests'
+          G
+
+          lockfile <<~L
+            GEM
+              remote: http://localgemserver.test/
+              specs:
+                parallel_tests (3.8.0)
+
+            PLATFORMS
+              #{lockfile_platforms}
+
+            DEPENDENCIES
+              parallel_tests
+
+            BUNDLED WITH
+               #{Bundler::VERSION}
+          L
+        end
+
+        it "automatically updates lockfile to use the older version" do
+          bundle "install --verbose", :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
+
+          expect(lockfile).to eq <<~L
+            GEM
+              remote: http://localgemserver.test/
+              specs:
+                parallel_tests (3.7.0)
+
+            PLATFORMS
+              #{lockfile_platforms}
+
+            DEPENDENCIES
+              parallel_tests
+
+            BUNDLED WITH
+               #{Bundler::VERSION}
+          L
+        end
+
+        it "gives a meaningful error if we're in frozen mode" do
+          expect do
+            bundle "install --verbose", :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s, "BUNDLE_FROZEN" => "true" }, :raise_on_error => false
+          end.not_to change { lockfile }
+
+          expect(err).to include("parallel_tests-3.8.0 requires ruby version >= #{next_ruby_minor}")
+          expect(err).not_to include("That means the author of parallel_tests (3.8.0) has removed it.")
+        end
+      end
+
+      context "in a transitive dependencies in a lockfile" do
+        before do
+          build_repo2 do
+            build_gem "rubocop", "1.28.2" do |s|
+              s.required_ruby_version = ">= #{current_ruby_minor}"
+
+              s.add_dependency "rubocop-ast", ">= 1.17.0", "< 2.0"
+            end
+
+            build_gem "rubocop", "1.35.0" do |s|
+              s.required_ruby_version = ">= #{next_ruby_minor}"
+
+              s.add_dependency "rubocop-ast", ">= 1.20.1", "< 2.0"
+            end
+
+            build_gem "rubocop-ast", "1.17.0" do |s|
+              s.required_ruby_version = ">= #{current_ruby_minor}"
+            end
+
+            build_gem "rubocop-ast", "1.21.0" do |s|
+              s.required_ruby_version = ">= #{next_ruby_minor}"
+            end
+          end
+
+          gemfile <<-G
+            source "http://localgemserver.test/"
+            gem 'rubocop'
+          G
+
+          lockfile <<~L
+            GEM
+              remote: http://localgemserver.test/
+              specs:
+                rubocop (1.35.0)
+                  rubocop-ast (>= 1.20.1, < 2.0)
+                rubocop-ast (1.21.0)
+
+            PLATFORMS
+              #{lockfile_platforms}
+
+            DEPENDENCIES
+              parallel_tests
+
+            BUNDLED WITH
+               #{Bundler::VERSION}
+          L
+        end
+
+        it "automatically updates lockfile to use the older compatible versions" do
+          bundle "install --verbose", :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
+
+          expect(lockfile).to eq <<~L
+            GEM
+              remote: http://localgemserver.test/
+              specs:
+                rubocop (1.28.2)
+                  rubocop-ast (>= 1.17.0, < 2.0)
+                rubocop-ast (1.17.0)
+
+            PLATFORMS
+              #{lockfile_platforms}
+
+            DEPENDENCIES
+              rubocop
+
+            BUNDLED WITH
+               #{Bundler::VERSION}
+          L
+        end
+      end
+
+      it "gives a meaningful error on ruby version mismatches between dependencies" do
+        build_repo4 do
+          build_gem "requires-old-ruby" do |s|
+            s.required_ruby_version = "< #{RUBY_VERSION}"
+          end
+        end
+
+        build_lib("foo", :path => bundled_app) do |s|
+          s.required_ruby_version = ">= #{RUBY_VERSION}"
+
+          s.add_dependency "requires-old-ruby"
+        end
+
+        install_gemfile <<-G, :raise_on_error => false
+          source "#{file_uri_for(gem_repo4)}"
+          gemspec
+        G
+
+        expect(err).to include("Bundler found conflicting requirements for the Ruby\0 version:")
+      end
+
       it "installs the older version under rate limiting conditions" do
         build_repo4 do
           build_gem "rack", "9001.0.0" do |s|
@@ -128,13 +407,38 @@ RSpec.describe "bundle install with inst
         end
 
         install_gemfile <<-G, :artifice => "compact_index_rate_limited", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
-          ruby "#{RUBY_VERSION}"
+          ruby "#{Gem.ruby_version}"
           source "http://localgemserver.test/"
           gem 'rack'
           gem 'foo1'
         G
 
-        expect(out).to_not include("rack-9001.0.0 requires ruby version > 9000")
+        expect(err).to_not include("rack-9001.0.0 requires ruby version > 9000")
+        expect(the_bundle).to include_gems("rack 1.2")
+      end
+
+      it "installs the older not platform specific version" do
+        build_repo4 do
+          build_gem "rack", "9001.0.0" do |s|
+            s.required_ruby_version = "> 9000"
+          end
+          build_gem "rack", "1.2" do |s|
+            s.platform = x86_mingw32
+            s.required_ruby_version = "> 9000"
+          end
+          build_gem "rack", "1.2"
+        end
+
+        simulate_platform x86_mingw32 do
+          install_gemfile <<-G, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
+            ruby "#{Gem.ruby_version}"
+            source "http://localgemserver.test/"
+            gem 'rack'
+          G
+        end
+
+        expect(err).to_not include("rack-9001.0.0 requires ruby version > 9000")
+        expect(err).to_not include("rack-1.2-#{Bundler.local_platform} requires ruby version > 9000")
         expect(the_bundle).to include_gems("rack 1.2")
       end
     end
@@ -148,12 +452,33 @@ RSpec.describe "bundle install with inst
         end
       end
 
-      let(:ruby_requirement) { %("#{RUBY_VERSION}") }
-      let(:error_message_requirement) { "~> #{RUBY_VERSION}.0" }
+      let(:ruby_requirement) { %("#{Gem.ruby_version}") }
+      let(:error_message_requirement) { "= #{Gem.ruby_version}" }
+
+      it "raises a proper error that mentions the current Ruby version during resolution" do
+        install_gemfile <<-G, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }, :raise_on_error => false
+          source "http://localgemserver.test/"
+          gem 'require_ruby'
+        G
+
+        expect(out).to_not include("Gem::InstallError: require_ruby requires Ruby version > 9000")
+
+        nice_error = strip_whitespace(<<-E).strip
+          Bundler found conflicting requirements for the Ruby\0 version:
+            In Gemfile:
+              require_ruby was resolved to 1.0, which depends on
+                Ruby\0 (> 9000)
+
+            Current Ruby\0 version:
+              Ruby\0 (#{error_message_requirement})
+
+        E
+        expect(err).to end_with(nice_error)
+      end
 
       shared_examples_for "ruby version conflicts" do
         it "raises an error during resolution" do
-          install_gemfile <<-G, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }
+          install_gemfile <<-G, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo2.to_s }, :raise_on_error => false
             source "http://localgemserver.test/"
             ruby #{ruby_requirement}
             gem 'require_ruby'
@@ -164,12 +489,12 @@ RSpec.describe "bundle install with inst
           nice_error = strip_whitespace(<<-E).strip
             Bundler found conflicting requirements for the Ruby\0 version:
               In Gemfile:
-                Ruby\0 (#{error_message_requirement})
-
                 require_ruby was resolved to 1.0, which depends on
                   Ruby\0 (> 9000)
 
-            Ruby\0 (> 9000), which is required by gem 'require_ruby', is not available in the local ruby installation
+              Current Ruby\0 version:
+                Ruby\0 (#{error_message_requirement})
+
           E
           expect(err).to end_with(nice_error)
         end
@@ -179,7 +504,6 @@ RSpec.describe "bundle install with inst
 
       describe "with a < requirement" do
         let(:ruby_requirement) { %("< 5000") }
-        let(:error_message_requirement) { "< 5000" }
 
         it_behaves_like "ruby version conflicts"
       end
@@ -187,7 +511,6 @@ RSpec.describe "bundle install with inst
       describe "with a compound requirement" do
         let(:reqs) { ["> 0.1", "< 5000"] }
         let(:ruby_requirement) { reqs.map(&:dump).join(", ") }
-        let(:error_message_requirement) { Gem::Requirement.new(reqs).to_s }
 
         it_behaves_like "ruby version conflicts"
       end
@@ -202,13 +525,23 @@ RSpec.describe "bundle install with inst
         end
       end
 
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
         source "#{file_uri_for(gem_repo2)}"
         gem 'require_rubygems'
       G
 
       expect(err).to_not include("Gem::InstallError: require_rubygems requires RubyGems version > 9000")
-      expect(err).to include("require_rubygems-1.0 requires rubygems version > 9000, which is incompatible with the current version, #{Gem::VERSION}")
+      nice_error = strip_whitespace(<<-E).strip
+        Bundler found conflicting requirements for the RubyGems\0 version:
+          In Gemfile:
+            require_rubygems was resolved to 1.0, which depends on
+              RubyGems\0 (> 9000)
+
+          Current RubyGems\0 version:
+            RubyGems\0 (= #{Gem::VERSION})
+
+      E
+      expect(err).to end_with(nice_error)
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gems/standalone_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gems/standalone_spec.rb
@@ -7,6 +7,12 @@ RSpec.shared_examples "bundle install --
       expect(the_bundle).to include_gems(*args)
     end
 
+    it "still makes system gems unavailable to normal bundler" do
+      system_gems "rack-1.0.0"
+
+      expect(the_bundle).to_not include_gems("rack")
+    end
+
     it "generates a bundle/bundler/setup.rb" do
       expect(bundled_app("bundle/bundler/setup.rb")).to exist
     end
@@ -21,15 +27,66 @@ RSpec.shared_examples "bundle install --
         testrb << "\nrequire \"#{k}\""
         testrb << "\nputs #{k.upcase}"
       end
-      Dir.chdir(bundled_app) do
-        ruby testrb, :no_lib => true
+      ruby testrb
+
+      expect(out).to eq(expected_gems.values.join("\n"))
+    end
+
+    it "makes the gems available without bundler nor rubygems" do
+      testrb = String.new <<-RUBY
+        $:.unshift File.expand_path("bundle")
+        require "bundler/setup"
+
+      RUBY
+      expected_gems.each do |k, _|
+        testrb << "\nrequire \"#{k}\""
+        testrb << "\nputs #{k.upcase}"
+      end
+      sys_exec %(#{Gem.ruby} --disable-gems -w -e #{testrb.shellescape})
+
+      expect(out).to eq(expected_gems.values.join("\n"))
+    end
+
+    it "makes the gems available without bundler via Kernel.require" do
+      testrb = String.new <<-RUBY
+        $:.unshift File.expand_path("bundle")
+        require "bundler/setup"
+
+      RUBY
+      expected_gems.each do |k, _|
+        testrb << "\nKernel.require \"#{k}\""
+        testrb << "\nputs #{k.upcase}"
       end
+      ruby testrb
 
       expect(out).to eq(expected_gems.values.join("\n"))
     end
 
+    it "makes system gems unavailable without bundler" do
+      system_gems "rack-1.0.0"
+
+      testrb = String.new <<-RUBY
+        $:.unshift File.expand_path("bundle")
+        require "bundler/setup"
+
+        begin
+          require "rack"
+        rescue LoadError
+          puts "LoadError"
+        end
+      RUBY
+      ruby testrb
+
+      expect(out).to eq("LoadError")
+    end
+
     it "works on a different system" do
-      FileUtils.mv(bundled_app, "#{bundled_app}2")
+      begin
+        FileUtils.mv(bundled_app, "#{bundled_app}2")
+      rescue Errno::ENOTEMPTY
+        puts "Couldn't rename test app since the target folder has these files: #{Dir.glob("#{bundled_app}2/*")}"
+        raise
+      end
 
       testrb = String.new <<-RUBY
         $:.unshift File.expand_path("bundle")
@@ -40,9 +97,7 @@ RSpec.shared_examples "bundle install --
         testrb << "\nrequire \"#{k}\""
         testrb << "\nputs #{k.upcase}"
       end
-      Dir.chdir("#{bundled_app}2") do
-        ruby testrb, :no_lib => true
-      end
+      ruby testrb, :dir => "#{bundled_app}2"
 
       expect(out).to eq(expected_gems.values.join("\n"))
     end
@@ -54,7 +109,8 @@ RSpec.shared_examples "bundle install --
         source "#{file_uri_for(gem_repo1)}"
         gem "rails"
       G
-      bundle! :install, forgotten_command_line_options(:path => bundled_app("bundle")).merge(:standalone => true)
+      bundle "config set --local path #{bundled_app("bundle")}"
+      bundle :install, :standalone => true, :dir => cwd
     end
 
     let(:expected_gems) do
@@ -67,9 +123,87 @@ RSpec.shared_examples "bundle install --
     include_examples "common functionality"
   end
 
-  describe "with gems with native extension", :ruby_repo do
+  describe "with default gems and a lockfile", :ruby_repo do
+    before do
+      skip "does not work on rubygems versions where `--install_dir` doesn't respect --default" unless Gem::Installer.for_spec(loaded_gemspec, :install_dir => "/foo").default_spec_file == "/foo/specifications/default/bundler-#{Bundler::VERSION}.gemspec" # Since rubygems 3.2.0.rc.2
+      skip "does not work on old rubies because the realworld gems that need to be installed don't support them" if RUBY_VERSION < "2.7.0"
+
+      realworld_system_gems "tsort --version 0.1.0"
+
+      necessary_system_gems = ["optparse --version 0.1.1", "psych --version 3.3.2", "logger --version 1.4.3", "etc --version 1.2.0", "stringio --version 3.0.1"]
+      necessary_system_gems += ["shellwords --version 0.1.0", "base64 --version 0.1.0", "resolv --version 0.2.1"] if Gem.rubygems_version < Gem::Version.new("3.3.a")
+      necessary_system_gems += ["yaml --version 0.1.1"] if Gem.rubygems_version < Gem::Version.new("3.4.a")
+      realworld_system_gems(*necessary_system_gems, :path => scoped_gem_path(bundled_app("bundle")))
+
+      build_gem "foo", "1.0.0", :to_system => true, :default => true do |s|
+        s.add_dependency "bar"
+      end
+
+      build_gem "bar", "1.0.0", :to_system => true, :default => true
+
+      build_repo4 do
+        build_gem "foo", "1.0.0" do |s|
+          s.add_dependency "bar"
+        end
+
+        build_gem "bar", "1.0.0"
+      end
+
+      gemfile <<-G
+        source "https://gem.repo4"
+        gem "foo"
+      G
+
+      bundle "lock", :dir => cwd, :artifice => "compact_index"
+    end
+
+    it "works and points to the vendored copies, not to the default copies" do
+      bundle "config set --local path #{bundled_app("bundle")}"
+      bundle :install, :standalone => true, :dir => cwd, :artifice => "compact_index", :env => { "BUNDLER_GEM_DEFAULT_DIR" => system_gem_path.to_s }
+
+      load_path_lines = bundled_app("bundle/bundler/setup.rb").read.split("\n").select {|line| line.start_with?("$:.unshift") }
+
+      expect(load_path_lines).to eq [
+        '$:.unshift File.expand_path("#{__dir__}/../#{RUBY_ENGINE}/#{Gem.ruby_api_version}/gems/bar-1.0.0/lib")',
+        '$:.unshift File.expand_path("#{__dir__}/../#{RUBY_ENGINE}/#{Gem.ruby_api_version}/gems/foo-1.0.0/lib")',
+      ]
+    end
+  end
+
+  describe "with Gemfiles using path sources and resulting bundle moved to a folder hierarchy with different nesting" do
+    before do
+      build_lib "minitest", "1.0.0", :path => lib_path("minitest")
+
+      Dir.mkdir bundled_app("app")
+
+      gemfile bundled_app("app/Gemfile"), <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "minitest", :path => "#{lib_path("minitest")}"
+      G
+
+      bundle "install", :standalone => true, :dir => bundled_app("app")
+
+      Dir.mkdir tmp("one_more_level")
+      FileUtils.mv bundled_app, tmp("one_more_level")
+    end
+
+    it "also works" do
+      ruby <<-RUBY, :dir => tmp("one_more_level/bundled_app/app")
+        require "./bundle/bundler/setup"
+
+        require "minitest"
+        puts MINITEST
+      RUBY
+
+      expect(out).to eq("1.0.0")
+      expect(err).to be_empty
+    end
+  end
+
+  describe "with gems with native extension" do
     before do
-      install_gemfile <<-G, forgotten_command_line_options(:path => bundled_app("bundle")).merge(:standalone => true)
+      bundle "config set --local path #{bundled_app("bundle")}"
+      install_gemfile <<-G, :standalone => true, :dir => cwd
         source "#{file_uri_for(gem_repo1)}"
         gem "very_simple_binary"
       G
@@ -77,9 +211,13 @@ RSpec.shared_examples "bundle install --
 
     it "generates a bundle/bundler/setup.rb with the proper paths" do
       expected_path = bundled_app("bundle/bundler/setup.rb")
-      extension_line = File.read(expected_path).each_line.find {|line| line.include? "/extensions/" }.strip
-      expect(extension_line).to start_with '$:.unshift "#{path}/../#{ruby_engine}/#{ruby_version}/extensions/'
-      expect(extension_line).to end_with '/very_simple_binary-1.0"'
+      script_content = File.read(expected_path)
+      expect(script_content).to include("def self.ruby_api_version")
+      expect(script_content).to include("def self.extension_api_version")
+      extension_line = script_content.each_line.find {|line| line.include? "/extensions/" }.strip
+      platform = Gem::Platform.local
+      expect(extension_line).to start_with '$:.unshift File.expand_path("#{__dir__}/../#{RUBY_ENGINE}/#{Gem.ruby_api_version}/extensions/'
+      expect(extension_line).to end_with platform.to_s + '/#{Gem.extension_api_version}/very_simple_binary-1.0")'
     end
   end
 
@@ -88,7 +226,7 @@ RSpec.shared_examples "bundle install --
       build_git "bar", :gemspec => false do |s|
         s.write "lib/bar/version.rb", %(BAR_VERSION = '1.0')
         s.write "bar.gemspec", <<-G
-          lib = File.expand_path('../lib/', __FILE__)
+          lib = File.expand_path('lib/', __dir__)
           $:.unshift lib unless $:.include?(lib)
           require 'bar/version'
 
@@ -102,7 +240,9 @@ RSpec.shared_examples "bundle install --
           end
         G
       end
-      install_gemfile <<-G, forgotten_command_line_options(:path => bundled_app("bundle")).merge(:standalone => true)
+      bundle "config set --local path #{bundled_app("bundle")}"
+      install_gemfile <<-G, :standalone => true, :dir => cwd, :raise_on_error => false
+        source "#{file_uri_for(gem_repo1)}"
         gem "bar", :git => "#{lib_path("bar-1.0")}"
       G
     end
@@ -122,7 +262,8 @@ RSpec.shared_examples "bundle install --
         gem "rails"
         gem "devise", :git => "#{lib_path("devise-1.0")}"
       G
-      bundle! :install, forgotten_command_line_options(:path => bundled_app("bundle")).merge(:standalone => true)
+      bundle "config set --local path #{bundled_app("bundle")}"
+      bundle :install, :standalone => true, :dir => cwd
     end
 
     let(:expected_gems) do
@@ -149,7 +290,8 @@ RSpec.shared_examples "bundle install --
           gem "rack-test"
         end
       G
-      bundle! :install, forgotten_command_line_options(:path => bundled_app("bundle")).merge(:standalone => true)
+      bundle "config set --local path #{bundled_app("bundle")}"
+      bundle :install, :standalone => true, :dir => cwd
     end
 
     let(:expected_gems) do
@@ -162,88 +304,69 @@ RSpec.shared_examples "bundle install --
     include_examples "common functionality"
 
     it "allows creating a standalone file with limited groups" do
-      bundle! :install, forgotten_command_line_options(:path => bundled_app("bundle")).merge(:standalone => "default")
+      bundle "config set --local path #{bundled_app("bundle")}"
+      bundle :install, :standalone => "default", :dir => cwd
 
-      Dir.chdir(bundled_app) do
-        load_error_ruby <<-RUBY, "spec", :no_lib => true
-          $:.unshift File.expand_path("bundle")
-          require "bundler/setup"
-
-          require "actionpack"
-          puts ACTIONPACK
-          require "spec"
-        RUBY
-      end
+      load_error_ruby <<-RUBY, "spec"
+        $:.unshift File.expand_path("bundle")
+        require "bundler/setup"
+
+        require "actionpack"
+        puts ACTIONPACK
+        require "spec"
+      RUBY
 
       expect(out).to eq("2.3.2")
       expect(err).to eq("ZOMG LOAD ERROR")
     end
 
-    it "allows --without to limit the groups used in a standalone" do
-      bundle! :install, forgotten_command_line_options(:path => bundled_app("bundle"), :without => "test").merge(:standalone => true)
+    it "allows `without` configuration to limit the groups used in a standalone" do
+      bundle "config set --local path #{bundled_app("bundle")}"
+      bundle "config set --local without test"
+      bundle :install, :standalone => true, :dir => cwd
 
-      Dir.chdir(bundled_app) do
-        load_error_ruby <<-RUBY, "spec", :no_lib => true
-          $:.unshift File.expand_path("bundle")
-          require "bundler/setup"
-
-          require "actionpack"
-          puts ACTIONPACK
-          require "spec"
-        RUBY
-      end
+      load_error_ruby <<-RUBY, "spec"
+        $:.unshift File.expand_path("bundle")
+        require "bundler/setup"
+
+        require "actionpack"
+        puts ACTIONPACK
+        require "spec"
+      RUBY
 
       expect(out).to eq("2.3.2")
       expect(err).to eq("ZOMG LOAD ERROR")
     end
 
-    it "allows --path to change the location of the standalone bundle", :bundler => "< 3" do
-      bundle! "install", forgotten_command_line_options(:path => "path/to/bundle").merge(:standalone => true)
+    it "allows `path` configuration to change the location of the standalone bundle" do
+      bundle "config set --local path path/to/bundle"
+      bundle "install", :standalone => true, :dir => cwd
 
-      Dir.chdir(bundled_app) do
-        ruby <<-RUBY, :no_lib => true
-          $:.unshift File.expand_path("path/to/bundle")
-          require "bundler/setup"
-
-          require "actionpack"
-          puts ACTIONPACK
-        RUBY
-      end
+      ruby <<-RUBY
+        $:.unshift File.expand_path("path/to/bundle")
+        require "bundler/setup"
+
+        require "actionpack"
+        puts ACTIONPACK
+      RUBY
 
       expect(out).to eq("2.3.2")
     end
 
-    it "allows --path to change the location of the standalone bundle", :bundler => "3" do
-      bundle! "install", forgotten_command_line_options(:path => "path/to/bundle").merge(:standalone => true)
-      path = File.expand_path("path/to/bundle")
-
-      Dir.chdir(bundled_app) do
-        ruby <<-RUBY, :no_lib => true
-          $:.unshift File.expand_path(#{path.dump})
-          require "bundler/setup"
-
-          require "actionpack"
-          puts ACTIONPACK
-        RUBY
-      end
+    it "allows `without` to limit the groups used in a standalone" do
+      bundle "config set --local without test"
+      bundle :install, :dir => cwd
+      bundle "config set --local path #{bundled_app("bundle")}"
+      bundle :install, :standalone => true, :dir => cwd
 
-      expect(out).to eq("2.3.2")
-    end
+      load_error_ruby <<-RUBY, "spec"
+        $:.unshift File.expand_path("bundle")
+        require "bundler/setup"
 
-    it "allows remembered --without to limit the groups used in a standalone" do
-      bundle! :install, forgotten_command_line_options(:without => "test")
-      bundle! :install, forgotten_command_line_options(:path => bundled_app("bundle")).merge(:standalone => true)
-
-      Dir.chdir(bundled_app) do
-        load_error_ruby <<-RUBY, "spec", :no_lib => true
-          $:.unshift File.expand_path("bundle")
-          require "bundler/setup"
-
-          require "actionpack"
-          puts ACTIONPACK
-          require "spec"
-        RUBY
-      end
+        require "actionpack"
+        puts ACTIONPACK
+        require "spec"
+      RUBY
 
       expect(out).to eq("2.3.2")
       expect(err).to eq("ZOMG LOAD ERROR")
@@ -259,7 +382,8 @@ RSpec.shared_examples "bundle install --
           source "#{source_uri}"
           gem "rails"
         G
-        bundle! :install, forgotten_command_line_options(:path => bundled_app("bundle")).merge(:standalone => true, :artifice => "endpoint")
+        bundle "config set --local path #{bundled_app("bundle")}"
+        bundle :install, :standalone => true, :artifice => "endpoint", :dir => cwd
       end
 
       let(:expected_gems) do
@@ -279,7 +403,8 @@ RSpec.shared_examples "bundle install --
         source "#{file_uri_for(gem_repo1)}"
         gem "rails"
       G
-      bundle! :install, forgotten_command_line_options(:path => bundled_app("bundle")).merge(:standalone => true, :binstubs => true)
+      bundle "config set --local path #{bundled_app("bundle")}"
+      bundle :install, :standalone => true, :binstubs => true, :dir => cwd
     end
 
     let(:expected_gems) do
@@ -292,46 +417,70 @@ RSpec.shared_examples "bundle install --
     include_examples "common functionality"
 
     it "creates stubs that use the standalone load path" do
-      Dir.chdir(bundled_app) do
-        expect(`bin/rails -v`.chomp).to eql "2.3.2"
-      end
+      expect(sys_exec("bin/rails -v").chomp).to eql "2.3.2"
     end
 
     it "creates stubs that can be executed from anywhere" do
       require "tmpdir"
-      Dir.chdir(Dir.tmpdir) do
-        sys_exec!(%(#{bundled_app("bin/rails")} -v))
-        expect(out).to eq("2.3.2")
-      end
+      sys_exec(%(#{bundled_app("bin/rails")} -v), :dir => Dir.tmpdir)
+      expect(out).to eq("2.3.2")
     end
 
     it "creates stubs that can be symlinked" do
-      pending "File.symlink is unsupported on Windows" if Bundler::WINDOWS
+      skip "symlinks unsupported" if Gem.win_platform?
 
       symlink_dir = tmp("symlink")
       FileUtils.mkdir_p(symlink_dir)
       symlink = File.join(symlink_dir, "rails")
 
       File.symlink(bundled_app("bin/rails"), symlink)
-      sys_exec!("#{symlink} -v")
+      sys_exec("#{symlink} -v")
       expect(out).to eq("2.3.2")
     end
 
     it "creates stubs with the correct load path" do
       extension_line = File.read(bundled_app("bin/rails")).each_line.find {|line| line.include? "$:.unshift" }.strip
-      expect(extension_line).to eq %($:.unshift File.expand_path "../../bundle", path.realpath)
+      expect(extension_line).to eq %($:.unshift File.expand_path "../bundle", __dir__)
     end
   end
 end
 
 RSpec.describe "bundle install --standalone" do
+  let(:cwd) { bundled_app }
+
   include_examples("bundle install --standalone")
 end
 
 RSpec.describe "bundle install --standalone run in a subdirectory" do
+  let(:cwd) { bundled_app("bob").tap(&:mkpath) }
+
+  include_examples("bundle install --standalone")
+end
+
+RSpec.describe "bundle install --standalone --local" do
   before do
-    Dir.chdir(bundled_app("bob").tap(&:mkpath))
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "rack"
+    G
+
+    system_gems "rack-1.0.0", :path => default_bundle_path
   end
 
-  include_examples("bundle install --standalone")
+  it "generates script pointing to system gems" do
+    bundle "install --standalone --local --verbose"
+
+    expect(out).to include("Using rack 1.0.0")
+
+    load_error_ruby <<-RUBY, "spec"
+      require "./bundler/setup"
+
+      require "rack"
+      puts RACK
+      require "spec"
+    RUBY
+
+    expect(out).to eq("1.0.0")
+    expect(err).to eq("ZOMG LOAD ERROR")
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gems/sudo_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gems/sudo_spec.rb
@@ -8,7 +8,7 @@ RSpec.describe "when using sudo", :sudo 
       end
 
       before do
-        bundle! "config set path.system true"
+        bundle "config set path.system true"
         subdir.mkpath
         sudo "chmod u-w #{subdir}"
       end
@@ -32,7 +32,7 @@ RSpec.describe "when using sudo", :sudo 
 
   describe "and GEM_HOME is owned by root" do
     before :each do
-      bundle! "config set path.system true"
+      bundle "config set path.system true"
       chown_system_gems_to_root
     end
 
@@ -49,8 +49,23 @@ RSpec.describe "when using sudo", :sudo 
     end
 
     it "installs rake and a gem dependent on rake in the same session" do
+      build_repo2 do
+        build_gem "another_implicit_rake_dep" do |s|
+          s.extensions << "Rakefile"
+          s.write "Rakefile", <<-RUBY
+            task :default do
+              path = File.expand_path("lib", __dir__)
+              FileUtils.mkdir_p(path)
+              File.open("\#{path}/another_implicit_rake_dep.rb", "w") do |f|
+                f.puts "ANOTHER_IMPLICIT_RAKE_DEP = 'YES'"
+              end
+            end
+          RUBY
+        end
+      end
+
       gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
+          source "#{file_uri_for(gem_repo2)}"
           gem "rake"
           gem "another_implicit_rake_dep"
       G
@@ -105,11 +120,12 @@ RSpec.describe "when using sudo", :sudo 
 
   describe "and BUNDLE_PATH is not writable" do
     before do
-      sudo "chmod ugo-w #{default_bundle_path}"
+      bundle "config set --local path .bundle"
+      sudo "chmod ugo-w .bundle"
     end
 
     after do
-      sudo "chmod ugo+w #{default_bundle_path}"
+      sudo "chmod ugo+w .bundle"
     end
 
     it "installs" do
@@ -118,7 +134,7 @@ RSpec.describe "when using sudo", :sudo 
         gem "rack", '1.0'
       G
 
-      expect(default_bundle_path("gems/rack-1.0.0")).to exist
+      expect(local_gem_path("gems/rack-1.0.0")).to exist
       expect(the_bundle).to include_gems "rack 1.0"
     end
 
@@ -140,11 +156,13 @@ RSpec.describe "when using sudo", :sudo 
 
   describe "and GEM_HOME is not writable" do
     it "installs" do
-      bundle! "config set path.system true"
+      bundle "config set path.system true"
       gem_home = tmp("sudo_gem_home")
       sudo "mkdir -p #{gem_home}"
       sudo "chmod ugo-w #{gem_home}"
 
+      system_gems :bundler, :path => gem_home
+
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack", '1.0'
@@ -166,7 +184,7 @@ RSpec.describe "when using sudo", :sudo 
     end
 
     it "warns against that" do
-      bundle :install, :sudo => true
+      bundle :install, :sudo => :preserve_env
       expect(err).to include(warning)
     end
 
@@ -179,7 +197,7 @@ RSpec.describe "when using sudo", :sudo 
 
     context "when silence_root_warning = false" do
       it "warns against that" do
-        bundle :install, :sudo => true, :env => { "BUNDLE_SILENCE_ROOT_WARNING" => "false" }
+        bundle :install, :sudo => :preserve_env, :env => { "BUNDLE_SILENCE_ROOT_WARNING" => "false" }
         expect(err).to include(warning)
       end
     end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gems/win32_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gems/win32_spec.rb
@@ -2,7 +2,7 @@
 
 RSpec.describe "bundle install with win32-generated lockfile" do
   it "should read lockfile" do
-    File.open(bundled_app("Gemfile.lock"), "wb") do |f|
+    File.open(bundled_app_lock, "wb") do |f|
       f << "GEM\r\n"
       f << "  remote: #{file_uri_for(gem_repo1)}/\r\n"
       f << "  specs:\r\n"
@@ -21,6 +21,5 @@ RSpec.describe "bundle install with win3
 
       gem "rack"
     G
-    expect(exitstatus).to eq(0) if exitstatus
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/gemspecs_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/gemspecs_spec.rb
@@ -21,6 +21,7 @@ RSpec.describe "bundle install" do
       build_lib "yaml_spec", :gemspec => :yaml
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem 'yaml_spec', :path => "#{lib_path("yaml_spec-1.0")}"
       G
       expect(err).to be_empty
@@ -33,6 +34,8 @@ RSpec.describe "bundle install" do
       gem 'rack'
     G
 
+    system_gems "rack-1.0.0", :path => default_bundle_path
+
     FileUtils.mkdir_p "#{default_bundle_path}/specifications"
     File.open("#{default_bundle_path}/specifications/rack-1.0.0.gemspec", "w+") do |f|
       spec = Gem::Specification.new do |s|
@@ -43,7 +46,7 @@ RSpec.describe "bundle install" do
       f.write spec.to_ruby
     end
     bundle :install, :artifice => "endpoint_marshal_fail" # force gemspec load
-    expect(the_bundle).to include_gems "activesupport 2.3.2"
+    expect(the_bundle).to include_gems "rack 1.0.0", "activesupport 2.3.2"
   end
 
   it "does not hang when gemspec has incompatible encoding" do
@@ -57,6 +60,7 @@ RSpec.describe "bundle install" do
     G
 
     install_gemfile <<-G, :env => { "LANG" => "C" }
+      source "#{file_uri_for(gem_repo1)}"
       gemspec
     G
 
@@ -82,6 +86,7 @@ RSpec.describe "bundle install" do
     G
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gemspec
     G
 
@@ -89,13 +94,15 @@ RSpec.describe "bundle install" do
   end
 
   context "when ruby version is specified in gemspec and gemfile" do
-    it "installs when patch level is not specified and the version matches" do
+    it "installs when patch level is not specified and the version matches",
+      :if => RUBY_PATCHLEVEL >= 0 do
       build_lib("foo", :path => bundled_app) do |s|
         s.required_ruby_version = "~> #{RUBY_VERSION}.0"
       end
 
       install_gemfile <<-G
         ruby '#{RUBY_VERSION}', :engine_version => '#{RUBY_VERSION}', :engine => 'ruby'
+        source "#{file_uri_for(gem_repo1)}"
         gemspec
       G
       expect(the_bundle).to include_gems "foo 1.0"
@@ -107,8 +114,9 @@ RSpec.describe "bundle install" do
         s.required_ruby_version = "#{RUBY_VERSION}.#{RUBY_PATCHLEVEL}"
       end
 
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
         ruby '#{RUBY_VERSION}', :engine_version => '#{RUBY_VERSION}', :engine => 'ruby', :patchlevel => '#{RUBY_PATCHLEVEL}'
+        source "#{file_uri_for(gem_repo1)}"
         gemspec
       G
       expect(the_bundle).to include_gems "foo 1.0"
@@ -121,14 +129,15 @@ RSpec.describe "bundle install" do
         s.required_ruby_version = "#{RUBY_VERSION}.#{patchlevel}"
       end
 
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
         ruby '#{RUBY_VERSION}', :engine_version => '#{RUBY_VERSION}', :engine => 'ruby', :patchlevel => '#{patchlevel}'
+        source "#{file_uri_for(gem_repo1)}"
         gemspec
       G
 
       expect(err).to include("Ruby patchlevel")
       expect(err).to include("but your Gemfile specified")
-      expect(exitstatus).to eq(18) if exitstatus
+      expect(exitstatus).to eq(18)
     end
 
     it "fails and complains about version on version mismatch" do
@@ -138,14 +147,15 @@ RSpec.describe "bundle install" do
         s.required_ruby_version = version
       end
 
-      install_gemfile <<-G
+      install_gemfile <<-G, :raise_on_error => false
         ruby '#{version}', :engine_version => '#{version}', :engine => 'ruby'
+        source "#{file_uri_for(gem_repo1)}"
         gemspec
       G
 
       expect(err).to include("Ruby version")
       expect(err).to include("but your Gemfile specified")
-      expect(exitstatus).to eq(18) if exitstatus
+      expect(exitstatus).to eq(18)
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/git_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/git_spec.rb
@@ -2,37 +2,51 @@
 
 RSpec.describe "bundle install" do
   context "git sources" do
-    it "displays the revision hash of the gem repository", :bundler => "< 3" do
+    it "displays the revision hash of the gem repository" do
       build_git "foo", "1.0", :path => lib_path("foo")
 
-      install_gemfile <<-G
-        gem "foo", :git => "#{lib_path("foo")}"
+      install_gemfile <<-G, :verbose => true
+        source "#{file_uri_for(gem_repo1)}"
+        gem "foo", :git => "#{file_uri_for(lib_path("foo"))}"
+      G
+
+      expect(out).to include("Using foo 1.0 from #{file_uri_for(lib_path("foo"))} (at main@#{revision_for(lib_path("foo"))[0..6]})")
+      expect(the_bundle).to include_gems "foo 1.0", :source => "git@#{lib_path("foo")}"
+    end
+
+    it "displays the correct default branch", :git => ">= 2.28.0" do
+      build_git "foo", "1.0", :path => lib_path("foo"), :default_branch => "main"
+
+      install_gemfile <<-G, :verbose => true
+        source "#{file_uri_for(gem_repo1)}"
+        gem "foo", :git => "#{file_uri_for(lib_path("foo"))}"
       G
 
-      bundle! :install
-      expect(out).to include("Using foo 1.0 from #{lib_path("foo")} (at master@#{revision_for(lib_path("foo"))[0..6]})")
+      expect(out).to include("Using foo 1.0 from #{file_uri_for(lib_path("foo"))} (at main@#{revision_for(lib_path("foo"))[0..6]})")
       expect(the_bundle).to include_gems "foo 1.0", :source => "git@#{lib_path("foo")}"
     end
 
-    it "displays the ref of the gem repository when using branch~num as a ref", :bundler => "< 3" do
+    it "displays the ref of the gem repository when using branch~num as a ref" do
+      skip "maybe branch~num notation doesn't work on Windows' git" if Gem.win_platform?
+
       build_git "foo", "1.0", :path => lib_path("foo")
       rev = revision_for(lib_path("foo"))[0..6]
       update_git "foo", "2.0", :path => lib_path("foo"), :gemspec => true
       rev2 = revision_for(lib_path("foo"))[0..6]
       update_git "foo", "3.0", :path => lib_path("foo"), :gemspec => true
 
-      install_gemfile! <<-G
-        gem "foo", :git => "#{lib_path("foo")}", :ref => "master~2"
+      install_gemfile <<-G, :verbose => true
+        source "#{file_uri_for(gem_repo1)}"
+        gem "foo", :git => "#{file_uri_for(lib_path("foo"))}", :ref => "main~2"
       G
 
-      bundle! :install
-      expect(out).to include("Using foo 1.0 from #{lib_path("foo")} (at master~2@#{rev})")
+      expect(out).to include("Using foo 1.0 from #{file_uri_for(lib_path("foo"))} (at main~2@#{rev})")
       expect(the_bundle).to include_gems "foo 1.0", :source => "git@#{lib_path("foo")}"
 
       update_git "foo", "4.0", :path => lib_path("foo"), :gemspec => true
 
-      bundle! :update, :all => true
-      expect(out).to include("Using foo 2.0 (was 1.0) from #{lib_path("foo")} (at master~2@#{rev2})")
+      bundle :update, :all => true, :verbose => true
+      expect(out).to include("Using foo 2.0 (was 1.0) from #{file_uri_for(lib_path("foo"))} (at main~2@#{rev2})")
       expect(the_bundle).to include_gems "foo 2.0", :source => "git@#{lib_path("foo")}"
     end
 
@@ -40,6 +54,7 @@ RSpec.describe "bundle install" do
       revision = build_git("foo").ref_for("HEAD")
 
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => "#{file_uri_for(lib_path("foo-1.0"))}", :group => :development
       G
 
@@ -57,7 +72,9 @@ RSpec.describe "bundle install" do
           foo!
       L
 
-      bundle! :install, forgotten_command_line_options(:path => "vendor/bundle", :without => "development")
+      bundle "config set --local path vendor/bundle"
+      bundle "config set --local without development"
+      bundle :install
 
       expect(out).to include("Bundle complete!")
     end
@@ -71,8 +88,8 @@ RSpec.describe "bundle install" do
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo2)}"
-        gem "foo", :git => "#{lib_path("gems")}", :glob => "foo/*.gemspec"
-        gem "zebra", :git => "#{lib_path("gems")}", :glob => "zebra/*.gemspec"
+        gem "foo", :git => "#{file_uri_for(lib_path("gems"))}", :glob => "foo/*.gemspec"
+        gem "zebra", :git => "#{file_uri_for(lib_path("gems"))}", :glob => "zebra/*.gemspec"
       G
 
       bundle "info foo"
--- ruby2.7-2.7.6.orig/spec/bundler/install/global_cache_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/global_cache_spec.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
 
 RSpec.describe "global gem caching" do
-  before { bundle! "config set global_gem_cache true" }
+  before { bundle "config set global_gem_cache true" }
 
   describe "using the cross-application user cache" do
     let(:source)  { "http://localgemserver.test" }
@@ -16,7 +16,7 @@ RSpec.describe "global gem caching" do
     end
 
     it "caches gems into the global cache on download" do
-      install_gemfile! <<-G, :artifice => "compact_index"
+      install_gemfile <<-G, :artifice => "compact_index"
         source "#{source}"
         gem "rack"
       G
@@ -29,7 +29,7 @@ RSpec.describe "global gem caching" do
       source_global_cache.mkpath
       FileUtils.cp(gem_repo1("gems/rack-1.0.0.gem"), source_global_cache("rack-1.0.0.gem"))
 
-      install_gemfile! <<-G, :artifice => "compact_index_no_gem"
+      install_gemfile <<-G, :artifice => "compact_index_no_gem"
         source "#{source}"
         gem "rack"
       G
@@ -37,24 +37,36 @@ RSpec.describe "global gem caching" do
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
+    it "shows a proper error message if a cached gem is corrupted" do
+      source_global_cache.mkpath
+      FileUtils.touch(source_global_cache("rack-1.0.0.gem"))
+
+      install_gemfile <<-G, :artifice => "compact_index_no_gem", :raise_on_error => false
+        source "#{source}"
+        gem "rack"
+      G
+
+      expect(err).to include("Gem::Package::FormatError: package metadata is missing in #{source_global_cache("rack-1.0.0.gem")}")
+    end
+
     describe "when the same gem from different sources is installed" do
       it "should use the appropriate one from the global cache" do
-        install_gemfile! <<-G, :artifice => "compact_index"
+        install_gemfile <<-G, :artifice => "compact_index"
           source "#{source}"
           gem "rack"
         G
 
-        FileUtils.rm_r(default_bundle_path)
+        simulate_new_machine
         expect(the_bundle).not_to include_gems "rack 1.0.0"
         expect(source_global_cache("rack-1.0.0.gem")).to exist
         # rack 1.0.0 is not installed and it is in the global cache
 
-        install_gemfile! <<-G, :artifice => "compact_index"
+        install_gemfile <<-G, :artifice => "compact_index"
           source "#{source2}"
           gem "rack", "0.9.1"
         G
 
-        FileUtils.rm_r(default_bundle_path)
+        simulate_new_machine
         expect(the_bundle).not_to include_gems "rack 0.9.1"
         expect(source2_global_cache("rack-0.9.1.gem")).to exist
         # rack 0.9.1 is not installed and it is in the global cache
@@ -64,18 +76,18 @@ RSpec.describe "global gem caching" do
           gem "rack", "1.0.0"
         G
 
-        bundle! :install, :artifice => "compact_index_no_gem"
+        bundle :install, :artifice => "compact_index_no_gem"
         # rack 1.0.0 is installed and rack 0.9.1 is not
         expect(the_bundle).to include_gems "rack 1.0.0"
         expect(the_bundle).not_to include_gems "rack 0.9.1"
-        FileUtils.rm_r(default_bundle_path)
+        simulate_new_machine
 
         gemfile <<-G
           source "#{source2}"
           gem "rack", "0.9.1"
         G
 
-        bundle! :install, :artifice => "compact_index_no_gem"
+        bundle :install, :artifice => "compact_index_no_gem"
         # rack 0.9.1 is installed and rack 1.0.0 is not
         expect(the_bundle).to include_gems "rack 0.9.1"
         expect(the_bundle).not_to include_gems "rack 1.0.0"
@@ -87,8 +99,8 @@ RSpec.describe "global gem caching" do
           gem "rack"
         G
 
-        bundle! :install, :artifice => "compact_index"
-        FileUtils.rm_r(default_bundle_path)
+        bundle :install, :artifice => "compact_index"
+        simulate_new_machine
         expect(the_bundle).not_to include_gems "rack 1.0.0"
         expect(source_global_cache("rack-1.0.0.gem")).to exist
         # rack 1.0.0 is not installed and it is in the global cache
@@ -98,8 +110,8 @@ RSpec.describe "global gem caching" do
           gem "rack", "0.9.1"
         G
 
-        bundle! :install, :artifice => "compact_index"
-        FileUtils.rm_r(default_bundle_path)
+        bundle :install, :artifice => "compact_index"
+        simulate_new_machine
         expect(the_bundle).not_to include_gems "rack 0.9.1"
         expect(source2_global_cache("rack-0.9.1.gem")).to exist
         # rack 0.9.1 is not installed and it is in the global cache
@@ -111,8 +123,10 @@ RSpec.describe "global gem caching" do
 
         expect(source_global_cache("rack-1.0.0.gem")).to exist
         expect(source2_global_cache("rack-0.9.1.gem")).to exist
-        bundle :install, :artifice => "compact_index_no_gem"
+        bundle :install, :artifice => "compact_index_no_gem", :raise_on_error => false
         expect(err).to include("Internal Server Error 500")
+        expect(err).not_to include("ERROR REPORT TEMPLATE")
+
         # rack 1.0.0 is not installed and rack 0.9.1 is not
         expect(the_bundle).not_to include_gems "rack 1.0.0"
         expect(the_bundle).not_to include_gems "rack 0.9.1"
@@ -124,8 +138,10 @@ RSpec.describe "global gem caching" do
 
         expect(source_global_cache("rack-1.0.0.gem")).to exist
         expect(source2_global_cache("rack-0.9.1.gem")).to exist
-        bundle :install, :artifice => "compact_index_no_gem"
+        bundle :install, :artifice => "compact_index_no_gem", :raise_on_error => false
         expect(err).to include("Internal Server Error 500")
+        expect(err).not_to include("ERROR REPORT TEMPLATE")
+
         # rack 0.9.1 is not installed and rack 1.0.0 is not
         expect(the_bundle).not_to include_gems "rack 0.9.1"
         expect(the_bundle).not_to include_gems "rack 1.0.0"
@@ -134,7 +150,7 @@ RSpec.describe "global gem caching" do
 
     describe "when installing gems from a different directory" do
       it "uses the global cache as a source" do
-        install_gemfile! <<-G, :artifice => "compact_index"
+        install_gemfile <<-G, :artifice => "compact_index"
           source "#{source}"
           gem "rack"
           gem "activesupport"
@@ -145,12 +161,12 @@ RSpec.describe "global gem caching" do
         expect(the_bundle).to include_gems "activesupport 2.3.5"
         expect(source_global_cache("rack-1.0.0.gem")).to exist
         expect(source_global_cache("activesupport-2.3.5.gem")).to exist
-        FileUtils.rm_r(default_bundle_path)
+        simulate_new_machine
         # Both gems are now only in the global cache
         expect(the_bundle).not_to include_gems "rack 1.0.0"
         expect(the_bundle).not_to include_gems "activesupport 2.3.5"
 
-        install_gemfile! <<-G, :artifice => "compact_index_no_gem"
+        install_gemfile <<-G, :artifice => "compact_index_no_gem"
           source "#{source}"
           gem "rack"
         G
@@ -161,39 +177,42 @@ RSpec.describe "global gem caching" do
         expect(source_global_cache("rack-1.0.0.gem")).to exist
         expect(source_global_cache("activesupport-2.3.5.gem")).to exist
 
-        Dir.chdir bundled_app2 do
-          create_file bundled_app2("gems.rb"), <<-G
-            source "#{source}"
-            gem "activesupport"
-          G
-
-          # Neither gem is installed and both are in the global cache
-          expect(the_bundle).not_to include_gems "rack 1.0.0"
-          expect(the_bundle).not_to include_gems "activesupport 2.3.5"
-          expect(source_global_cache("rack-1.0.0.gem")).to exist
-          expect(source_global_cache("activesupport-2.3.5.gem")).to exist
-
-          # Install using the global cache instead of by downloading the .gem
-          # from the server
-          bundle! :install, :artifice => "compact_index_no_gem"
-
-          # activesupport is installed and both are in the global cache
-          expect(the_bundle).not_to include_gems "rack 1.0.0"
-          expect(the_bundle).to include_gems "activesupport 2.3.5"
-          expect(source_global_cache("rack-1.0.0.gem")).to exist
-          expect(source_global_cache("activesupport-2.3.5.gem")).to exist
+        create_file bundled_app2("gems.rb"), <<-G
+          source "#{source}"
+          gem "activesupport"
+        G
+
+        # Neither gem is installed and both are in the global cache
+        expect(the_bundle).not_to include_gems "rack 1.0.0", :dir => bundled_app2
+        expect(the_bundle).not_to include_gems "activesupport 2.3.5", :dir => bundled_app2
+        expect(source_global_cache("rack-1.0.0.gem")).to exist
+        expect(source_global_cache("activesupport-2.3.5.gem")).to exist
+
+        # Install using the global cache instead of by downloading the .gem
+        # from the server
+        bundle :install, :artifice => "compact_index_no_gem", :dir => bundled_app2
+
+        # activesupport is installed and both are in the global cache
+        simulate_bundler_version_when_missing_prerelease_default_gem_activation do
+          expect(the_bundle).not_to include_gems "rack 1.0.0", :dir => bundled_app2
+          expect(the_bundle).to include_gems "activesupport 2.3.5", :dir => bundled_app2
         end
+
+        expect(source_global_cache("rack-1.0.0.gem")).to exist
+        expect(source_global_cache("activesupport-2.3.5.gem")).to exist
       end
     end
   end
 
-  describe "extension caching", :ruby_repo do
+  describe "extension caching" do
     it "works" do
+      skip "gets incorrect ref in path" if Gem.win_platform?
+
       build_git "very_simple_git_binary", &:add_c_extension
       build_lib "very_simple_path_binary", &:add_c_extension
       revision = revision_for(lib_path("very_simple_git_binary-1.0"))[0, 12]
 
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
 
         gem "very_simple_binary"
@@ -209,7 +228,7 @@ RSpec.describe "global gem caching" do
       cached_extensions = Pathname.glob(home(".bundle", "cache", "extensions", "*", "*", "*", "*", "*")).sort
       expect(cached_extensions).to eq [gem_binary_cache, git_binary_cache].sort
 
-      run! <<-R
+      run <<-R
         require 'very_simple_binary_c'; puts ::VERY_SIMPLE_BINARY_IN_C
         require 'very_simple_git_binary_c'; puts ::VERY_SIMPLE_GIT_BINARY_IN_C
       R
@@ -220,12 +239,12 @@ RSpec.describe "global gem caching" do
       gem_binary_cache.join("very_simple_binary_c.rb").open("w") {|f| f << "puts File.basename(__FILE__)" }
       git_binary_cache.join("very_simple_git_binary_c.rb").open("w") {|f| f << "puts File.basename(__FILE__)" }
 
-      bundle! "config set --local path different_path"
-      bundle! :install
+      bundle "config set --local path different_path"
+      bundle :install
 
       expect(Dir[home(".bundle", "cache", "extensions", "**", "*binary_c*")]).to all(end_with(".rb"))
 
-      run! <<-R
+      run <<-R
         require 'very_simple_binary_c'
         require 'very_simple_git_binary_c'
       R
--- ruby2.7-2.7.6.orig/spec/bundler/install/path_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/path_spec.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
 
 RSpec.describe "bundle install" do
-  describe "with --path" do
+  describe "with path configured" do
     before :each do
       build_gem "rack", "1.0.0", :to_system => true do |s|
         s.write "lib/rack.rb", "puts 'FAIL'"
@@ -13,32 +13,41 @@ RSpec.describe "bundle install" do
       G
     end
 
-    it "does not use available system gems with bundle --path vendor/bundle", :bundler => "< 3" do
-      bundle! :install, forgotten_command_line_options(:path => "vendor/bundle")
+    it "does not use available system gems with `vendor/bundle" do
+      bundle "config set --local path vendor/bundle"
+      bundle :install
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
+    it "uses system gems with `path.system` configured with more priority than `path`" do
+      bundle "config set --local path.system true"
+      bundle "config set --global path vendor/bundle"
+      bundle :install
+      run "require 'rack'", :raise_on_error => false
+      expect(out).to include("FAIL")
+    end
+
     it "handles paths with regex characters in them" do
       dir = bundled_app("bun++dle")
       dir.mkpath
 
-      Dir.chdir(dir) do
-        bundle! :install, forgotten_command_line_options(:path => dir.join("vendor/bundle"))
-        expect(out).to include("installed into `./vendor/bundle`")
-      end
+      bundle "config set --local path #{dir.join("vendor/bundle")}"
+      bundle :install, :dir => dir
+      expect(out).to include("installed into `./vendor/bundle`")
 
       dir.rmtree
     end
 
-    it "prints a warning to let the user know what has happened with bundle --path vendor/bundle" do
-      bundle! :install, forgotten_command_line_options(:path => "vendor/bundle")
+    it "prints a message to let the user know where gems where installed" do
+      bundle "config set --local path vendor/bundle"
+      bundle :install
       expect(out).to include("gems are installed into `./vendor/bundle`")
     end
 
     it "disallows --path vendor/bundle --system", :bundler => "< 3" do
-      bundle "install --path vendor/bundle --system"
+      bundle "install --path vendor/bundle --system", :raise_on_error => false
       expect(err).to include("Please choose only one option.")
-      expect(exitstatus).to eq(15) if exitstatus
+      expect(exitstatus).to eq(15)
     end
 
     it "remembers to disable system gems after the first time with bundle --path vendor/bundle", :bundler => "< 3" do
@@ -51,33 +60,27 @@ RSpec.describe "bundle install" do
     end
 
     context "with path_relative_to_cwd set to true" do
-      before { bundle! "config set path_relative_to_cwd true" }
+      before { bundle "config set path_relative_to_cwd true" }
 
       it "installs the bundle relatively to current working directory", :bundler => "< 3" do
-        Dir.chdir(bundled_app.parent) do
-          bundle! "install --gemfile='#{bundled_app}/Gemfile' --path vendor/bundle"
-          expect(out).to include("installed into `./vendor/bundle`")
-          expect(bundled_app("../vendor/bundle")).to be_directory
-        end
+        bundle "install --gemfile='#{bundled_app}/Gemfile' --path vendor/bundle", :dir => bundled_app.parent
+        expect(out).to include("installed into `./vendor/bundle`")
+        expect(bundled_app("../vendor/bundle")).to be_directory
         expect(the_bundle).to include_gems "rack 1.0.0"
       end
 
       it "installs the standalone bundle relative to the cwd" do
-        Dir.chdir(bundled_app.parent) do
-          bundle! :install, :gemfile => bundled_app("Gemfile"), :standalone => true
-          expect(out).to include("installed into `./bundled_app/bundle`")
-          expect(bundled_app("bundle")).to be_directory
-          expect(bundled_app("bundle/ruby")).to be_directory
-        end
-
-        bundle! "config unset path"
-
-        Dir.chdir(bundled_app("subdir").tap(&:mkpath)) do
-          bundle! :install, :gemfile => bundled_app("Gemfile"), :standalone => true
-          expect(out).to include("installed into `../bundle`")
-          expect(bundled_app("bundle")).to be_directory
-          expect(bundled_app("bundle/ruby")).to be_directory
-        end
+        bundle :install, :gemfile => bundled_app_gemfile, :standalone => true, :dir => bundled_app.parent
+        expect(out).to include("installed into `./bundled_app/bundle`")
+        expect(bundled_app("bundle")).to be_directory
+        expect(bundled_app("bundle/ruby")).to be_directory
+
+        bundle "config unset path"
+
+        bundle :install, :gemfile => bundled_app_gemfile, :standalone => true, :dir => bundled_app("subdir").tap(&:mkpath)
+        expect(out).to include("installed into `../bundle`")
+        expect(bundled_app("bundle")).to be_directory
+        expect(bundled_app("bundle/ruby")).to be_directory
       end
     end
   end
@@ -98,7 +101,7 @@ RSpec.describe "bundle install" do
       if type == :env
         ENV["BUNDLE_PATH"] = location
       elsif type == :global
-        bundle! "config set path #{location}", "no-color" => nil
+        bundle "config set path #{location}", "no-color" => nil
       end
     end
 
@@ -106,7 +109,8 @@ RSpec.describe "bundle install" do
       context "when set via #{type}" do
         it "installs gems to a path if one is specified" do
           set_bundle_path(type, bundled_app("vendor2").to_s)
-          bundle! :install, forgotten_command_line_options(:path => "vendor/bundle")
+          bundle "config set --local path vendor/bundle"
+          bundle :install
 
           expect(vendored_gems("gems/rack-1.0.0")).to be_directory
           expect(bundled_app("vendor2")).not_to be_directory
@@ -115,9 +119,9 @@ RSpec.describe "bundle install" do
 
         it "installs gems to ." do
           set_bundle_path(type, ".")
-          bundle! "config set --global disable_shared_gems true"
+          bundle "config set --global disable_shared_gems true"
 
-          bundle! :install
+          bundle :install
 
           paths_to_exist = %w[cache/rack-1.0.0.gem gems/rack-1.0.0 specifications/rack-1.0.0.gemspec].map {|path| bundled_app(Bundler.ruby_scope, path) }
           expect(paths_to_exist).to all exist
@@ -127,7 +131,7 @@ RSpec.describe "bundle install" do
         it "installs gems to the path" do
           set_bundle_path(type, bundled_app("vendor").to_s)
 
-          bundle! :install
+          bundle :install
 
           expect(bundled_app("vendor", Bundler.ruby_scope, "gems/rack-1.0.0")).to be_directory
           expect(the_bundle).to include_gems "rack 1.0.0"
@@ -137,9 +141,7 @@ RSpec.describe "bundle install" do
           set_bundle_path(type, "vendor")
 
           FileUtils.mkdir_p bundled_app("lol")
-          Dir.chdir(bundled_app("lol")) do
-            bundle! :install
-          end
+          bundle :install, :dir => bundled_app("lol")
 
           expect(bundled_app("vendor", Bundler.ruby_scope, "gems/rack-1.0.0")).to be_directory
           expect(the_bundle).to include_gems "rack 1.0.0"
@@ -157,7 +159,8 @@ RSpec.describe "bundle install" do
     end
 
     it "sets BUNDLE_PATH as the first argument to bundle install" do
-      bundle! :install, forgotten_command_line_options(:path => "./vendor/bundle")
+      bundle "config set --local path ./vendor/bundle"
+      bundle :install
 
       expect(vendored_gems("gems/rack-1.0.0")).to be_directory
       expect(the_bundle).to include_gems "rack 1.0.0"
@@ -166,13 +169,14 @@ RSpec.describe "bundle install" do
     it "disables system gems when passing a path to install" do
       # This is so that vendored gems can be distributed to others
       build_gem "rack", "1.1.0", :to_system => true
-      bundle! :install, forgotten_command_line_options(:path => "./vendor/bundle")
+      bundle "config set --local path ./vendor/bundle"
+      bundle :install
 
       expect(vendored_gems("gems/rack-1.0.0")).to be_directory
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
-    it "re-installs gems whose extensions have been deleted", :ruby_repo do
+    it "re-installs gems whose extensions have been deleted" do
       build_lib "very_simple_binary", "1.0.0", :to_system => true do |s|
         s.write "lib/very_simple_binary.rb", "raise 'FAIL'"
       end
@@ -182,7 +186,8 @@ RSpec.describe "bundle install" do
         gem "very_simple_binary"
       G
 
-      bundle! :install, forgotten_command_line_options(:path => "./vendor/bundle")
+      bundle "config set --local path ./vendor/bundle"
+      bundle :install
 
       expect(vendored_gems("gems/very_simple_binary-1.0")).to be_directory
       expect(vendored_gems("extensions")).to be_directory
@@ -190,10 +195,11 @@ RSpec.describe "bundle install" do
 
       vendored_gems("extensions").rmtree
 
-      run "require 'very_simple_binary_c'"
+      run "require 'very_simple_binary_c'", :raise_on_error => false
       expect(err).to include("Bundler::GemNotFound")
 
-      bundle :install, forgotten_command_line_options(:path => "./vendor/bundle")
+      bundle "config set --local path ./vendor/bundle"
+      bundle :install
 
       expect(vendored_gems("gems/very_simple_binary-1.0")).to be_directory
       expect(vendored_gems("extensions")).to be_directory
@@ -203,9 +209,7 @@ RSpec.describe "bundle install" do
 
   describe "to a file" do
     before do
-      in_app_root do
-        FileUtils.touch "bundle"
-      end
+      FileUtils.touch bundled_app("bundle")
     end
 
     it "reports the file exists" do
@@ -214,7 +218,8 @@ RSpec.describe "bundle install" do
         gem "rack"
       G
 
-      bundle :install, forgotten_command_line_options(:path => "bundle")
+      bundle "config set --local path bundle"
+      bundle :install, :raise_on_error => false
       expect(err).to include("file already exists")
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/install/prereleases_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/prereleases_spec.rb
@@ -1,10 +1,19 @@
 # frozen_string_literal: true
 
 RSpec.describe "bundle install" do
+  before do
+    build_repo2 do
+      build_gem "not_released", "1.0.pre"
+
+      build_gem "has_prerelease", "1.0"
+      build_gem "has_prerelease", "1.1.pre"
+    end
+  end
+
   describe "when prerelease gems are available" do
     it "finds prereleases" do
       install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
+        source "#{file_uri_for(gem_repo2)}"
         gem "not_released"
       G
       expect(the_bundle).to include_gems "not_released 1.0.pre"
@@ -12,7 +21,7 @@ RSpec.describe "bundle install" do
 
     it "uses regular releases if available" do
       install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
+        source "#{file_uri_for(gem_repo2)}"
         gem "has_prerelease"
       G
       expect(the_bundle).to include_gems "has_prerelease 1.0"
@@ -20,7 +29,7 @@ RSpec.describe "bundle install" do
 
     it "uses prereleases if requested" do
       install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
+        source "#{file_uri_for(gem_repo2)}"
         gem "has_prerelease", "1.1.pre"
       G
       expect(the_bundle).to include_gems "has_prerelease 1.1.pre"
@@ -29,7 +38,11 @@ RSpec.describe "bundle install" do
 
   describe "when prerelease gems are not available" do
     it "still works" do
-      build_repo3
+      build_repo gem_repo3 do
+        build_gem "rack"
+      end
+      FileUtils.rm_rf Dir[gem_repo3("prerelease*")]
+
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo3)}"
         gem "rack"
--- ruby2.7-2.7.6.orig/spec/bundler/install/process_lock_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/process_lock_spec.rb
@@ -12,7 +12,7 @@ RSpec.describe "process lock spec" do
         end
       end
 
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
@@ -31,5 +31,27 @@ RSpec.describe "process lock spec" do
         expect(processed).to eq true
       end
     end
+
+    context "when creating a lock raises Errno::EPERM" do
+      before { allow(File).to receive(:open).and_raise(Errno::EPERM) }
+
+      it "skips creating the lock file and yields" do
+        processed = false
+        Bundler::ProcessLock.lock(default_bundle_path) { processed = true }
+
+        expect(processed).to eq true
+      end
+    end
+
+    context "when creating a lock raises Errno::EROFS" do
+      before { allow(File).to receive(:open).and_raise(Errno::EROFS) }
+
+      it "skips creating the lock file and yields" do
+        processed = false
+        Bundler::ProcessLock.lock(default_bundle_path) { processed = true }
+
+        expect(processed).to eq true
+      end
+    end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/redownload_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/redownload_spec.rb
@@ -12,9 +12,9 @@ RSpec.describe "bundle install" do
     it "re-installs installed gems" do
       rack_lib = default_bundle_path("gems/rack-1.0.0/lib/rack.rb")
 
-      bundle! :install
+      bundle :install
       rack_lib.open("w") {|f| f.write("blah blah blah") }
-      bundle! :install, flag => true
+      bundle :install, flag => true
 
       expect(out).to include "Installing rack 1.0.0"
       expect(rack_lib.open(&:read)).to eq("RACK = '1.0.0'\n")
@@ -22,7 +22,7 @@ RSpec.describe "bundle install" do
     end
 
     it "works on first bundle install" do
-      bundle! :install, flag => true
+      bundle :install, flag => true
 
       expect(out).to include "Installing rack 1.0.0"
       expect(the_bundle).to include_gems "rack 1.0.0"
@@ -33,6 +33,7 @@ RSpec.describe "bundle install" do
 
       before do
         gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           gem "foo", :git => "#{lib_path("foo-1.0")}"
         G
       end
@@ -40,16 +41,16 @@ RSpec.describe "bundle install" do
       it "re-installs installed gems" do
         foo_lib = default_bundle_path("bundler/gems/foo-1.0-#{ref}/lib/foo.rb")
 
-        bundle! :install
+        bundle :install
         foo_lib.open("w") {|f| f.write("blah blah blah") }
-        bundle! :install, flag => true
+        bundle :install, flag => true
 
         expect(foo_lib.open(&:read)).to eq("FOO = '1.0'\n")
         expect(the_bundle).to include_gems "foo 1.0"
       end
 
       it "works on first bundle install" do
-        bundle! :install, flag => true
+        bundle :install, flag => true
 
         expect(the_bundle).to include_gems "foo 1.0"
       end
@@ -62,12 +63,12 @@ RSpec.describe "bundle install" do
     end
 
     it "shows a deprecation when single flag passed" do
-      bundle! "install --force"
+      bundle "install --force"
       expect(err).to include "[DEPRECATED] The `--force` option has been renamed to `--redownload`"
     end
 
     it "shows a deprecation when multiple flags passed" do
-      bundle! "install --no-color --force"
+      bundle "install --no-color --force"
       expect(err).to include "[DEPRECATED] The `--force` option has been renamed to `--redownload`"
     end
   end
@@ -78,12 +79,12 @@ RSpec.describe "bundle install" do
     end
 
     it "does not show a deprecation when single flag passed" do
-      bundle! "install --redownload"
+      bundle "install --redownload"
       expect(err).not_to include "[DEPRECATED] The `--force` option has been renamed to `--redownload`"
     end
 
     it "does not show a deprecation when single multiple flags passed" do
-      bundle! "install --no-color --redownload"
+      bundle "install --no-color --redownload"
       expect(err).not_to include "[DEPRECATED] The `--force` option has been renamed to `--redownload`"
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/install/security_policy_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/security_policy_spec.rb
@@ -16,30 +16,28 @@ RSpec.describe "policies with unsigned g
   end
 
   it "will work after you try to deploy without a lock" do
-    bundle "install --deployment"
+    bundle "install --deployment", :raise_on_error => false
     bundle :install
-    expect(exitstatus).to eq(0) if exitstatus
     expect(the_bundle).to include_gems "rack 1.0", "signed_gem 1.0"
   end
 
   it "will fail when given invalid security policy" do
-    bundle "install --trust-policy=InvalidPolicyName"
+    bundle "install --trust-policy=InvalidPolicyName", :raise_on_error => false
     expect(err).to include("RubyGems doesn't know about trust policy")
   end
 
   it "will fail with High Security setting due to presence of unsigned gem" do
-    bundle "install --trust-policy=HighSecurity"
+    bundle "install --trust-policy=HighSecurity", :raise_on_error => false
     expect(err).to include("security policy didn't allow")
   end
 
   it "will fail with Medium Security setting due to presence of unsigned gem" do
-    bundle "install --trust-policy=MediumSecurity"
+    bundle "install --trust-policy=MediumSecurity", :raise_on_error => false
     expect(err).to include("security policy didn't allow")
   end
 
   it "will succeed with no policy" do
     bundle "install"
-    expect(exitstatus).to eq(0) if exitstatus
   end
 end
 
@@ -53,24 +51,22 @@ RSpec.describe "policies with signed gem
   end
 
   it "will fail with High Security setting, gem is self-signed" do
-    bundle "install --trust-policy=HighSecurity"
+    bundle "install --trust-policy=HighSecurity", :raise_on_error => false
     expect(err).to include("security policy didn't allow")
   end
 
   it "will fail with Medium Security setting, gem is self-signed" do
-    bundle "install --trust-policy=MediumSecurity"
+    bundle "install --trust-policy=MediumSecurity", :raise_on_error => false
     expect(err).to include("security policy didn't allow")
   end
 
   it "will succeed with Low Security setting, low security accepts self signed gem" do
     bundle "install --trust-policy=LowSecurity"
-    expect(exitstatus).to eq(0) if exitstatus
     expect(the_bundle).to include_gems "signed_gem 1.0"
   end
 
   it "will succeed with no policy" do
     bundle "install"
-    expect(exitstatus).to eq(0) if exitstatus
     expect(the_bundle).to include_gems "signed_gem 1.0"
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/install/yanked_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/install/yanked_spec.rb
@@ -15,14 +15,14 @@ RSpec.context "when installing a bundle 
            foo (10.0.0)
 
        PLATFORMS
-         ruby
+         #{lockfile_platforms}
 
        DEPENDENCIES
          foo (= 10.0.0)
 
     L
 
-    install_gemfile <<-G
+    install_gemfile <<-G, :raise_on_error => false
       source "#{file_uri_for(gem_repo4)}"
       gem "foo", "10.0.0"
     G
@@ -33,7 +33,7 @@ RSpec.context "when installing a bundle 
   it "throws the original error when only the Gemfile specifies a gem version that doesn't exist" do
     bundle "config set force_ruby_platform true"
 
-    install_gemfile <<-G
+    install_gemfile <<-G, :raise_on_error => false
       source "#{file_uri_for(gem_repo4)}"
       gem "foo", "10.0.0"
     G
@@ -43,6 +43,63 @@ RSpec.context "when installing a bundle 
   end
 end
 
+RSpec.context "when resolving a bundle that includes yanked gems, but unlocking an unrelated gem" do
+  before(:each) do
+    build_repo4 do
+      build_gem "foo", "10.0.0"
+
+      build_gem "bar", "1.0.0"
+      build_gem "bar", "2.0.0"
+    end
+
+    lockfile <<-L
+      GEM
+        remote: #{file_uri_for(gem_repo4)}
+        specs:
+          foo (9.0.0)
+          bar (1.0.0)
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        foo
+        bar
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo4)}"
+      gem "foo"
+      gem "bar"
+    G
+  end
+
+  it "does not update the yanked gem" do
+    bundle "lock --update bar"
+
+    expect(lockfile).to eq <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          bar (2.0.0)
+          foo (9.0.0)
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        bar
+        foo
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+  end
+end
+
 RSpec.context "when using gem before installing" do
   it "does not suggest the author has yanked the gem" do
     gemfile <<-G
@@ -57,16 +114,47 @@ RSpec.context "when using gem before ins
           rack (0.9.1)
 
       PLATFORMS
-        ruby
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        rack (= 0.9.1)
+    L
+
+    bundle :list, :raise_on_error => false
+
+    expect(err).to include("Could not find rack-0.9.1 in locally installed gems")
+    expect(err).to_not include("Your bundle is locked to rack (0.9.1) from")
+    expect(err).to_not include("If you haven't changed sources, that means the author of rack (0.9.1) has removed it.")
+    expect(err).to_not include("You'll need to update your bundle to a different version of rack (0.9.1) that hasn't been removed in order to install.")
+  end
+
+  it "does not suggest the author has yanked the gem when using more than one gem, but shows all gems that couldn't be found in the source" do
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "rack", "0.9.1"
+      gem "rack_middleware", "1.0"
+    G
+
+    lockfile <<-L
+      GEM
+        remote: #{file_uri_for(gem_repo1)}
+        specs:
+          rack (0.9.1)
+          rack_middleware (1.0)
+
+      PLATFORMS
+        #{lockfile_platforms}
 
       DEPENDENCIES
         rack (= 0.9.1)
+        rack_middleware (1.0)
     L
 
-    bundle :list
+    bundle :list, :raise_on_error => false
 
-    expect(err).to include("Could not find rack-0.9.1 in any of the sources")
-    expect(err).to_not include("Your bundle is locked to rack (0.9.1), but that version could not be found in any of the sources listed in your Gemfile.")
+    expect(err).to include("Could not find rack-0.9.1, rack_middleware-1.0 in locally installed gems")
+    expect(err).to include("Install missing gems with `bundle install`.")
+    expect(err).to_not include("Your bundle is locked to rack (0.9.1) from")
     expect(err).to_not include("If you haven't changed sources, that means the author of rack (0.9.1) has removed it.")
     expect(err).to_not include("You'll need to update your bundle to a different version of rack (0.9.1) that hasn't been removed in order to install.")
   end
--- ruby2.7-2.7.6.orig/spec/bundler/lock/git_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/lock/git_spec.rb
@@ -5,6 +5,7 @@ RSpec.describe "bundle lock with git gem
     build_git "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem 'foo', :git => "#{lib_path("foo-1.0")}"
     G
   end
--- ruby2.7-2.7.6.orig/spec/bundler/lock/lockfile_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/lock/lockfile_spec.rb
@@ -1,18 +1,20 @@
 # frozen_string_literal: true
 
 RSpec.describe "the lockfile format" do
-  include Bundler::GemHelpers
+  before do
+    build_repo2
+  end
 
   it "generates a simple lockfile for a single source, gem" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+      source "#{file_uri_for(gem_repo2)}"
 
       gem "rack"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -27,7 +29,9 @@ RSpec.describe "the lockfile format" do
     G
   end
 
-  it "updates the lockfile's bundler version if current ver. is newer" do
+  it "updates the lockfile's bundler version if current ver. is newer, and version was forced through BUNDLER_VERSION" do
+    system_gems "bundler-1.8.2"
+
     lockfile <<-L
       GIT
         remote: git://github.com/nex3/haml.git
@@ -35,7 +39,7 @@ RSpec.describe "the lockfile format" do
         specs:
 
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -50,15 +54,18 @@ RSpec.describe "the lockfile format" do
          1.8.2
     L
 
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+    install_gemfile <<-G, :verbose => true, :env => { "BUNDLER_VERSION" => Bundler::VERSION }
+      source "#{file_uri_for(gem_repo2)}"
 
       gem "rack"
     G
 
-    lockfile_should_be <<-G
+    expect(out).not_to include("Bundler #{Bundler::VERSION} is running, but your lockfile was generated with 1.8.2.")
+    expect(out).to include("Using bundler #{Bundler::VERSION}")
+
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -73,12 +80,12 @@ RSpec.describe "the lockfile format" do
     G
   end
 
-  it "does not update the lockfile's bundler version if nothing changed during bundle install" do
-    version = "#{Bundler::VERSION.split(".").first}.0.0.a"
+  it "does not update the lockfile's bundler version if nothing changed during bundle install, but uses the locked version", :rubygems => ">= 3.3.0.a", :realworld => true do
+    version = "2.3.0"
 
     lockfile <<-L
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -92,15 +99,18 @@ RSpec.describe "the lockfile format" do
          #{version}
     L
 
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+    install_gemfile <<-G, :verbose => true, :artifice => "vcr"
+      source "#{file_uri_for(gem_repo2)}"
 
       gem "rack"
     G
 
-    lockfile_should_be <<-G
+    expect(out).to include("Bundler #{Bundler::VERSION} is running, but your lockfile was generated with #{version}.")
+    expect(out).to include("Using bundler #{version}")
+
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -115,10 +125,12 @@ RSpec.describe "the lockfile format" do
     G
   end
 
-  it "updates the lockfile's bundler version if not present" do
+  it "does not update the lockfile's bundler version if nothing changed during bundle install, and uses the latest version", :rubygems => "< 3.3.0.a" do
+    version = "#{Bundler::VERSION.split(".").first}.0.0.a"
+
     lockfile <<-L
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -127,17 +139,23 @@ RSpec.describe "the lockfile format" do
 
       DEPENDENCIES
         rack
+
+      BUNDLED WITH
+         #{version}
     L
 
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+    install_gemfile <<-G, :verbose => true
+      source "#{file_uri_for(gem_repo2)}"
 
-      gem "rack", "> 0"
+      gem "rack"
     G
 
-    lockfile_should_be <<-G
+    expect(out).not_to include("Bundler #{Bundler::VERSION} is running, but your lockfile was generated with #{version}.")
+    expect(out).to include("Using bundler #{Bundler::VERSION}")
+
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -145,20 +163,17 @@ RSpec.describe "the lockfile format" do
         #{lockfile_platforms}
 
       DEPENDENCIES
-        rack (> 0)
+        rack
 
       BUNDLED WITH
-         #{Bundler::VERSION}
+         #{version}
     G
   end
 
-  it "warns if the current is older than lockfile's bundler version" do
-    current_version = Bundler::VERSION
-    newer_minor = bump_minor(current_version)
-
+  it "adds the BUNDLED WITH section if not present" do
     lockfile <<-L
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -167,27 +182,17 @@ RSpec.describe "the lockfile format" do
 
       DEPENDENCIES
         rack
-
-      BUNDLED WITH
-         #{newer_minor}
     L
 
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+      source "#{file_uri_for(gem_repo2)}"
 
-      gem "rack"
+      gem "rack", "> 0"
     G
 
-    pre_flag = prerelease?(newer_minor) ? " --pre" : ""
-    warning_message = "the running version of Bundler (#{current_version}) is older " \
-                      "than the version that created the lockfile (#{newer_minor}). " \
-                      "We suggest you to upgrade to the version that created the " \
-                      "lockfile by running `gem install bundler:#{newer_minor}#{pre_flag}`."
-    expect(err).to include warning_message
-
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -195,20 +200,22 @@ RSpec.describe "the lockfile format" do
         #{lockfile_platforms}
 
       DEPENDENCIES
-        rack
+        rack (> 0)
 
       BUNDLED WITH
-         #{newer_minor}
+         #{Bundler::VERSION}
     G
   end
 
-  it "warns when updating bundler major version" do
+  it "update the bundler major version just fine" do
     current_version = Bundler::VERSION
     older_major = previous_major(current_version)
 
+    system_gems "bundler-#{older_major}"
+
     lockfile <<-L
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -222,20 +229,17 @@ RSpec.describe "the lockfile format" do
          #{older_major}
     L
 
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+    install_gemfile <<-G, :env => { "BUNDLER_VERSION" => Bundler::VERSION }
+      source "#{file_uri_for(gem_repo2)}/"
 
       gem "rack"
     G
 
-    expect(err).to include(
-      "Warning: the lockfile is being updated to Bundler " \
-      "#{current_version.split(".").first}, after which you will be unable to return to Bundler #{older_major.split(".").first}."
-    )
+    expect(err).to be_empty
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -252,14 +256,14 @@ RSpec.describe "the lockfile format" do
 
   it "generates a simple lockfile for a single source, gem with dependencies" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
 
       gem "rack-obama"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
           rack-obama (1.0)
@@ -278,14 +282,14 @@ RSpec.describe "the lockfile format" do
 
   it "generates a simple lockfile for a single source, gem with a version requirement" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
 
       gem "rack-obama", ">= 1.0"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
           rack-obama (1.0)
@@ -302,43 +306,12 @@ RSpec.describe "the lockfile format" do
     G
   end
 
-  it "generates a lockfile without credentials for a configured source", :bundler => "< 3" do
+  it "generates a lockfile without credentials for a configured source" do
     bundle "config set http://localgemserver.test/ user:pass"
 
     install_gemfile(<<-G, :artifice => "endpoint_strict_basic_authentication", :quiet => true)
-      source "http://localgemserver.test/" do
-
-      end
-
-      source "http://user:pass@othergemserver.test/" do
-        gem "rack-obama", ">= 1.0"
-      end
-    G
-
-    lockfile_should_be <<-G
-      GEM
-        remote: http://localgemserver.test/
-        remote: http://user:pass@othergemserver.test/
-        specs:
-          rack (1.0.0)
-          rack-obama (1.0)
-            rack
-
-      PLATFORMS
-        #{lockfile_platforms}
-
-      DEPENDENCIES
-        rack-obama (>= 1.0)!
-
-      BUNDLED WITH
-         #{Bundler::VERSION}
-    G
-  end
-
-  it "generates a lockfile without credentials for a configured source", :bundler => "3" do
-    bundle "config set http://localgemserver.test/ user:pass"
+      source "#{file_uri_for(gem_repo1)}"
 
-    install_gemfile(<<-G, :artifice => "endpoint_strict_basic_authentication", :quiet => true)
       source "http://localgemserver.test/" do
 
       end
@@ -348,8 +321,9 @@ RSpec.describe "the lockfile format" do
       end
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       GEM
@@ -376,13 +350,13 @@ RSpec.describe "the lockfile format" do
 
   it "generates lockfiles with multiple requirements" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
       gem "net-sftp"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           net-sftp (1.1.1)
             net-ssh (>= 1.0.0, < 1.99.0)
@@ -401,49 +375,23 @@ RSpec.describe "the lockfile format" do
     expect(the_bundle).to include_gems "net-sftp 1.1.1", "net-ssh 1.0.0"
   end
 
-  it "generates a simple lockfile for a single pinned source, gem with a version requirement", :bundler => "< 3" do
-    git = build_git "foo"
-
-    install_gemfile <<-G
-      gem "foo", :git => "#{lib_path("foo-1.0")}"
-    G
-
-    lockfile_should_be <<-G
-      GIT
-        remote: #{lib_path("foo-1.0")}
-        revision: #{git.ref_for("master")}
-        specs:
-          foo (1.0)
-
-      GEM
-        specs:
-
-      PLATFORMS
-        #{lockfile_platforms}
-
-      DEPENDENCIES
-        foo!
-
-      BUNDLED WITH
-         #{Bundler::VERSION}
-    G
-  end
-
   it "generates a simple lockfile for a single pinned source, gem with a version requirement" do
     git = build_git "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => "#{lib_path("foo-1.0")}"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GIT
         remote: #{lib_path("foo-1.0")}
-        revision: #{git.ref_for("master")}
+        revision: #{git.ref_for("main")}
         specs:
           foo (1.0)
 
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       PLATFORMS
@@ -461,7 +409,7 @@ RSpec.describe "the lockfile format" do
     build_lib "omg", :path => lib_path("omg")
 
     gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
 
       platforms :#{not_local_tag} do
         gem "omg", :path => "#{lib_path("omg")}"
@@ -477,7 +425,7 @@ RSpec.describe "the lockfile format" do
         specs:
 
       GEM
-        remote: #{file_uri_for(gem_repo1)}//
+        remote: #{file_uri_for(gem_repo2)}//
         specs:
           rack (1.0.0)
 
@@ -492,7 +440,7 @@ RSpec.describe "the lockfile format" do
          #{Bundler::VERSION}
     L
 
-    bundle! "install"
+    bundle "install"
     expect(the_bundle).to include_gems "rack 1.0.0"
   end
 
@@ -500,19 +448,21 @@ RSpec.describe "the lockfile format" do
     git = build_git "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       git "#{lib_path("foo-1.0")}" do
         gem "foo"
       end
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GIT
         remote: #{lib_path("foo-1.0")}
-        revision: #{git.ref_for("master")}
+        revision: #{git.ref_for("main")}
         specs:
           foo (1.0)
 
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       PLATFORMS
@@ -531,10 +481,11 @@ RSpec.describe "the lockfile format" do
     update_git "foo", :branch => "omg"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => "#{lib_path("foo-1.0")}", :branch => "omg"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GIT
         remote: #{lib_path("foo-1.0")}
         revision: #{git.ref_for("omg")}
@@ -543,6 +494,7 @@ RSpec.describe "the lockfile format" do
           foo (1.0)
 
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       PLATFORMS
@@ -561,10 +513,11 @@ RSpec.describe "the lockfile format" do
     update_git "foo", :tag => "omg"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => "#{lib_path("foo-1.0")}", :tag => "omg"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GIT
         remote: #{lib_path("foo-1.0")}
         revision: #{git.ref_for("omg")}
@@ -573,6 +526,7 @@ RSpec.describe "the lockfile format" do
           foo (1.0)
 
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       PLATFORMS
@@ -590,16 +544,18 @@ RSpec.describe "the lockfile format" do
     build_lib "foo"
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => "#{lib_path("foo-1.0")}"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       PATH
         remote: #{lib_path("foo-1.0")}
         specs:
           foo (1.0)
 
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       PLATFORMS
@@ -616,21 +572,23 @@ RSpec.describe "the lockfile format" do
   it "serializes pinned path sources to the lockfile even when packaging" do
     build_lib "foo"
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :path => "#{lib_path("foo-1.0")}"
     G
 
     bundle "config set cache_all true"
-    bundle! :cache
-    bundle! :install, :local => true
+    bundle :cache
+    bundle :install, :local => true
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       PATH
         remote: #{lib_path("foo-1.0")}
         specs:
           foo (1.0)
 
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       PLATFORMS
@@ -649,17 +607,17 @@ RSpec.describe "the lockfile format" do
     bar = build_git "bar"
 
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
 
       gem "rack"
       gem "foo", :path => "#{lib_path("foo-1.0")}"
       gem "bar", :git => "#{lib_path("bar-1.0")}"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GIT
         remote: #{lib_path("bar-1.0")}
-        revision: #{bar.ref_for("master")}
+        revision: #{bar.ref_for("main")}
         specs:
           bar (1.0)
 
@@ -669,7 +627,7 @@ RSpec.describe "the lockfile format" do
           foo (1.0)
 
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -686,18 +644,42 @@ RSpec.describe "the lockfile format" do
     G
   end
 
+  it "removes redundant sources" do
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo2)}/"
+
+      gem "rack", :source => "#{file_uri_for(gem_repo2)}/"
+    G
+
+    expect(lockfile).to eq <<~G
+      GEM
+        remote: #{file_uri_for(gem_repo2)}/
+        specs:
+          rack (1.0.0)
+
+      PLATFORMS
+        #{lockfile_platforms}
+
+      DEPENDENCIES
+        rack!
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    G
+  end
+
   it "lists gems alphabetically" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
 
       gem "thin"
       gem "actionpack"
       gem "rack-obama"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           actionpack (2.3.2)
             activesupport (= 2.3.2)
@@ -723,14 +705,14 @@ RSpec.describe "the lockfile format" do
 
   it "orders dependencies' dependencies in alphabetical order" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
 
       gem "rails"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           actionmailer (2.3.2)
             activesupport (= 2.3.2)
@@ -746,8 +728,8 @@ RSpec.describe "the lockfile format" do
             actionpack (= 2.3.2)
             activerecord (= 2.3.2)
             activeresource (= 2.3.2)
-            rake (= 12.3.2)
-          rake (12.3.2)
+            rake (= 13.0.1)
+          rake (13.0.1)
 
       PLATFORMS
         #{lockfile_platforms}
@@ -761,14 +743,24 @@ RSpec.describe "the lockfile format" do
   end
 
   it "orders dependencies by version" do
+    update_repo2 do
+      # Capistrano did this (at least until version 2.5.10)
+      # RubyGems 2.2 doesn't allow the specifying of a dependency twice
+      # See https://github.com/rubygems/rubygems/commit/03dbac93a3396a80db258d9bc63500333c25bd2f
+      build_gem "double_deps", "1.0", :skip_validation => true do |s|
+        s.add_dependency "net-ssh", ">= 1.0.0"
+        s.add_dependency "net-ssh"
+      end
+    end
+
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
       gem 'double_deps'
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           double_deps (1.0)
             net-ssh
@@ -788,14 +780,14 @@ RSpec.describe "the lockfile format" do
 
   it "does not add the :require option to the lockfile" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
 
       gem "rack-obama", ">= 1.0", :require => "rack/obama"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
           rack-obama (1.0)
@@ -814,14 +806,14 @@ RSpec.describe "the lockfile format" do
 
   it "does not add the :group option to the lockfile" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
 
       gem "rack-obama", ">= 1.0", :group => :test
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
           rack-obama (1.0)
@@ -842,18 +834,20 @@ RSpec.describe "the lockfile format" do
     build_lib "foo", :path => bundled_app("foo")
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       path "foo" do
         gem "foo"
       end
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       PATH
         remote: foo
         specs:
           foo (1.0)
 
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       PLATFORMS
@@ -871,18 +865,20 @@ RSpec.describe "the lockfile format" do
     build_lib "foo", :path => bundled_app(File.join("..", "foo"))
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       path "../foo" do
         gem "foo"
       end
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       PATH
         remote: ../foo
         specs:
           foo (1.0)
 
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       PLATFORMS
@@ -900,18 +896,20 @@ RSpec.describe "the lockfile format" do
     build_lib "foo", :path => bundled_app("foo")
 
     install_gemfile <<-G
-      path File.expand_path("../foo", __FILE__) do
+      source "#{file_uri_for(gem_repo1)}"
+      path File.expand_path("foo", __dir__) do
         gem "foo"
       end
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       PATH
         remote: foo
         specs:
           foo (1.0)
 
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       PLATFORMS
@@ -929,16 +927,18 @@ RSpec.describe "the lockfile format" do
     build_lib("foo", :path => tmp.join("foo"))
 
     install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gemspec :path => "../foo"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       PATH
         remote: ../foo
         specs:
           foo (1.0)
 
       GEM
+        remote: #{file_uri_for(gem_repo1)}/
         specs:
 
       PLATFORMS
@@ -952,51 +952,10 @@ RSpec.describe "the lockfile format" do
     G
   end
 
-  it "keeps existing platforms in the lockfile", :bundler => "< 3" do
+  it "keeps existing platforms in the lockfile" do
     lockfile <<-G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
-        specs:
-          rack (1.0.0)
-
-      PLATFORMS
-        java
-
-      DEPENDENCIES
-        rack
-
-      BUNDLED WITH
-         #{Bundler::VERSION}
-    G
-
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
-
-      gem "rack"
-    G
-
-    lockfile_should_be <<-G
-      GEM
-        remote: #{file_uri_for(gem_repo1)}/
-        specs:
-          rack (1.0.0)
-
-      PLATFORMS
-        java
-        #{generic_local_platform}
-
-      DEPENDENCIES
-        rack
-
-      BUNDLED WITH
-         #{Bundler::VERSION}
-    G
-  end
-
-  it "keeps existing platforms in the lockfile", :bundler => "3" do
-    lockfile <<-G
-      GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -1011,21 +970,19 @@ RSpec.describe "the lockfile format" do
     G
 
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
 
       gem "rack"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
       PLATFORMS
-        java
-        #{generic_local_platform}
-        #{specific_local_platform}
+        #{lockfile_platforms_for(["java", specific_local_platform])}
 
       DEPENDENCIES
         rack
@@ -1035,38 +992,7 @@ RSpec.describe "the lockfile format" do
     G
   end
 
-  it "persists the spec's platform to the lockfile", :bundler => "< 3" do
-    build_repo2 do
-      build_gem "platform_specific", "1.0" do |s|
-        s.platform = Gem::Platform.new("universal-java-16")
-      end
-    end
-
-    simulate_platform "universal-java-16"
-
-    install_gemfile! <<-G
-      source "#{file_uri_for(gem_repo2)}"
-      gem "platform_specific"
-    G
-
-    lockfile_should_be <<-G
-      GEM
-        remote: #{file_uri_for(gem_repo2)}/
-        specs:
-          platform_specific (1.0-java)
-
-      PLATFORMS
-        java
-
-      DEPENDENCIES
-        platform_specific
-
-      BUNDLED WITH
-         #{Bundler::VERSION}
-    G
-  end
-
-  it "persists the spec's platform and specific platform to the lockfile", :bundler => "3" do
+  it "persists the spec's specific platform to the lockfile" do
     build_repo2 do
       build_gem "platform_specific", "1.0" do |s|
         s.platform = Gem::Platform.new("universal-java-16")
@@ -1075,20 +1001,18 @@ RSpec.describe "the lockfile format" do
 
     simulate_platform "universal-java-16"
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo2)}"
       gem "platform_specific"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
         remote: #{file_uri_for(gem_repo2)}/
         specs:
-          platform_specific (1.0-java)
           platform_specific (1.0-universal-java-16)
 
       PLATFORMS
-        java
         universal-java-16
 
       DEPENDENCIES
@@ -1101,19 +1025,19 @@ RSpec.describe "the lockfile format" do
 
   it "does not add duplicate gems" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
       gem "rack"
     G
 
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
       gem "rack"
       gem "activesupport"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           activesupport (2.3.5)
           rack (1.0.0)
@@ -1132,14 +1056,14 @@ RSpec.describe "the lockfile format" do
 
   it "does not add duplicate dependencies" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
       gem "rack"
       gem "rack"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -1156,14 +1080,14 @@ RSpec.describe "the lockfile format" do
 
   it "does not add duplicate dependencies with versions" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
       gem "rack", "1.0"
       gem "rack", "1.0"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -1180,14 +1104,14 @@ RSpec.describe "the lockfile format" do
 
   it "does not add duplicate dependencies in different groups" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
       gem "rack", "1.0", :group => :one
       gem "rack", "1.0", :group => :two
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (1.0.0)
 
@@ -1203,36 +1127,36 @@ RSpec.describe "the lockfile format" do
   end
 
   it "raises if two different versions are used" do
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+    install_gemfile <<-G, :raise_on_error => false
+      source "#{file_uri_for(gem_repo2)}/"
       gem "rack", "1.0"
       gem "rack", "1.1"
     G
 
-    expect(bundled_app("Gemfile.lock")).not_to exist
+    expect(bundled_app_lock).not_to exist
     expect(err).to include "rack (= 1.0) and rack (= 1.1)"
   end
 
   it "raises if two different sources are used" do
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+    install_gemfile <<-G, :raise_on_error => false
+      source "#{file_uri_for(gem_repo2)}/"
       gem "rack"
       gem "rack", :git => "git://hubz.com"
     G
 
-    expect(bundled_app("Gemfile.lock")).not_to exist
-    expect(err).to include "rack (>= 0) should come from an unspecified source and git://hubz.com (at master)"
+    expect(bundled_app_lock).not_to exist
+    expect(err).to include "rack (>= 0) should come from an unspecified source and git://hubz.com"
   end
 
   it "works correctly with multiple version dependencies" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
+      source "#{file_uri_for(gem_repo2)}/"
       gem "rack", "> 0.9", "< 1.0"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (0.9.1)
 
@@ -1249,14 +1173,14 @@ RSpec.describe "the lockfile format" do
 
   it "captures the Ruby version in the lockfile" do
     install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
-      ruby '#{RUBY_VERSION}'
+      source "#{file_uri_for(gem_repo2)}/"
+      ruby '#{Gem.ruby_version}'
       gem "rack", "> 0.9", "< 1.0"
     G
 
-    lockfile_should_be <<-G
+    expect(lockfile).to eq <<~G
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack (0.9.1)
 
@@ -1267,93 +1191,17 @@ RSpec.describe "the lockfile format" do
         rack (> 0.9, < 1.0)
 
       RUBY VERSION
-         ruby #{RUBY_VERSION}p#{RUBY_PATCHLEVEL}
+         #{Bundler::RubyVersion.system}
 
       BUNDLED WITH
          #{Bundler::VERSION}
     G
   end
 
-  # Some versions of the Bundler 1.1 RC series introduced corrupted
-  # lockfiles. There were two major problems:
-  #
-  # * multiple copies of the same GIT section appeared in the lockfile
-  # * when this happened, those sections got multiple copies of gems
-  #   in those sections.
-  it "fixes corrupted lockfiles" do
-    build_git "omg", :path => lib_path("omg")
-    revision = revision_for(lib_path("omg"))
-
-    gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}/"
-      gem "omg", :git => "#{lib_path("omg")}", :branch => 'master'
-    G
-
-    bundle! :install, forgotten_command_line_options(:path => "vendor")
-    expect(the_bundle).to include_gems "omg 1.0"
-
-    # Create a Gemfile.lock that has duplicate GIT sections
-    lockfile <<-L
-      GIT
-        remote: #{lib_path("omg")}
-        revision: #{revision}
-        branch: master
-        specs:
-          omg (1.0)
-
-      GIT
-        remote: #{lib_path("omg")}
-        revision: #{revision}
-        branch: master
-        specs:
-          omg (1.0)
-
-      GEM
-        remote: #{file_uri_for(gem_repo1)}/
-        specs:
-
-      PLATFORMS
-        #{lockfile_platforms}
-
-      DEPENDENCIES
-        omg!
-
-      BUNDLED WITH
-         #{Bundler::VERSION}
-    L
-
-    FileUtils.rm_rf(bundled_app("vendor"))
-    bundle "install"
-    expect(the_bundle).to include_gems "omg 1.0"
-
-    # Confirm that duplicate specs do not appear
-    lockfile_should_be(<<-L)
-      GIT
-        remote: #{lib_path("omg")}
-        revision: #{revision}
-        branch: master
-        specs:
-          omg (1.0)
-
-      GEM
-        remote: #{file_uri_for(gem_repo1)}/
-        specs:
-
-      PLATFORMS
-        #{lockfile_platforms}
-
-      DEPENDENCIES
-        omg!
-
-      BUNDLED WITH
-         #{Bundler::VERSION}
-    L
-  end
-
   it "raises a helpful error message when the lockfile is missing deps" do
     lockfile <<-L
       GEM
-        remote: #{file_uri_for(gem_repo1)}/
+        remote: #{file_uri_for(gem_repo2)}/
         specs:
           rack_middleware (1.0)
 
@@ -1364,8 +1212,8 @@ RSpec.describe "the lockfile format" do
         rack_middleware
     L
 
-    install_gemfile <<-G
-      source "#{file_uri_for(gem_repo1)}"
+    install_gemfile <<-G, :raise_on_error => false
+      source "#{file_uri_for(gem_repo2)}"
       gem "rack_middleware"
     G
 
@@ -1376,7 +1224,7 @@ RSpec.describe "the lockfile format" do
   describe "a line ending" do
     def set_lockfile_mtime_to_known_value
       time = Time.local(2000, 1, 1, 0, 0, 0)
-      File.utime(time, time, bundled_app("Gemfile.lock"))
+      File.utime(time, time, bundled_app_lock)
     end
     before(:each) do
       build_repo2
@@ -1389,28 +1237,42 @@ RSpec.describe "the lockfile format" do
     end
 
     it "generates Gemfile.lock with \\n line endings" do
-      expect(File.read(bundled_app("Gemfile.lock"))).not_to match("\r\n")
+      expect(File.read(bundled_app_lock)).not_to match("\r\n")
       expect(the_bundle).to include_gems "rack 1.0"
     end
 
     context "during updates" do
       it "preserves Gemfile.lock \\n line endings" do
-        update_repo2
+        update_repo2 do
+          build_gem "rack", "1.2" do |s|
+            s.executables = "rackup"
+          end
+        end
 
-        expect { bundle "update", :all => true }.to change { File.mtime(bundled_app("Gemfile.lock")) }
-        expect(File.read(bundled_app("Gemfile.lock"))).not_to match("\r\n")
+        expect { bundle "update", :all => true }.to change { File.mtime(bundled_app_lock) }
+        expect(File.read(bundled_app_lock)).not_to match("\r\n")
         expect(the_bundle).to include_gems "rack 1.2"
       end
 
       it "preserves Gemfile.lock \\n\\r line endings" do
-        update_repo2
-        win_lock = File.read(bundled_app("Gemfile.lock")).gsub(/\n/, "\r\n")
-        File.open(bundled_app("Gemfile.lock"), "wb") {|f| f.puts(win_lock) }
+        skip "needs to be adapted" if Gem.win_platform?
+
+        update_repo2 do
+          build_gem "rack", "1.2" do |s|
+            s.executables = "rackup"
+          end
+        end
+
+        win_lock = File.read(bundled_app_lock).gsub(/\n/, "\r\n")
+        File.open(bundled_app_lock, "wb") {|f| f.puts(win_lock) }
         set_lockfile_mtime_to_known_value
 
-        expect { bundle "update", :all => true }.to change { File.mtime(bundled_app("Gemfile.lock")) }
-        expect(File.read(bundled_app("Gemfile.lock"))).to match("\r\n")
-        expect(the_bundle).to include_gems "rack 1.2"
+        expect { bundle "update", :all => true }.to change { File.mtime(bundled_app_lock) }
+        expect(File.read(bundled_app_lock)).to match("\r\n")
+
+        simulate_bundler_version_when_missing_prerelease_default_gem_activation do
+          expect(the_bundle).to include_gems "rack 1.2"
+        end
       end
     end
 
@@ -1421,20 +1283,20 @@ RSpec.describe "the lockfile format" do
                    require 'bundler'
                    Bundler.setup
                  RUBY
-        end.not_to change { File.mtime(bundled_app("Gemfile.lock")) }
+        end.not_to change { File.mtime(bundled_app_lock) }
       end
 
       it "preserves Gemfile.lock \\n\\r line endings" do
-        win_lock = File.read(bundled_app("Gemfile.lock")).gsub(/\n/, "\r\n")
-        File.open(bundled_app("Gemfile.lock"), "wb") {|f| f.puts(win_lock) }
+        win_lock = File.read(bundled_app_lock).gsub(/\n/, "\r\n")
+        File.open(bundled_app_lock, "wb") {|f| f.puts(win_lock) }
         set_lockfile_mtime_to_known_value
 
         expect do
           ruby <<-RUBY
-                   require 'bundler'
+                   require '#{entrypoint}'
                    Bundler.setup
                  RUBY
-        end.not_to change { File.mtime(bundled_app("Gemfile.lock")) }
+        end.not_to change { File.mtime(bundled_app_lock) }
       end
     end
   end
@@ -1442,7 +1304,7 @@ RSpec.describe "the lockfile format" do
   it "refuses to install if Gemfile.lock contains conflict markers" do
     lockfile <<-L
       GEM
-        remote: #{file_uri_for(gem_repo1)}//
+        remote: #{file_uri_for(gem_repo2)}//
         specs:
       <<<<<<<
           rack (1.0.0)
@@ -1460,8 +1322,8 @@ RSpec.describe "the lockfile format" do
          #{Bundler::VERSION}
     L
 
-    install_gemfile(<<-G)
-      source "#{file_uri_for(gem_repo1)}/"
+    install_gemfile <<-G, :raise_on_error => false
+      source "#{file_uri_for(gem_repo2)}/"
       gem "rack"
     G
 
@@ -1469,7 +1331,7 @@ RSpec.describe "the lockfile format" do
     expect(err).to match(/git checkout HEAD -- Gemfile.lock/i)
   end
 
-private
+  private
 
   def prerelease?(version)
     Gem::Version.new(version).prerelease?
--- ruby2.7-2.7.6.orig/spec/bundler/other/cli_dispatch_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/other/cli_dispatch_spec.rb
@@ -2,19 +2,19 @@
 
 RSpec.describe "bundle command names" do
   it "work when given fully" do
-    bundle "install"
+    bundle "install", :raise_on_error => false
     expect(err).to eq("Could not locate Gemfile")
     expect(last_command.stdboth).not_to include("Ambiguous command")
   end
 
   it "work when not ambiguous" do
-    bundle "ins"
+    bundle "ins", :raise_on_error => false
     expect(err).to eq("Could not locate Gemfile")
     expect(last_command.stdboth).not_to include("Ambiguous command")
   end
 
   it "print a friendly error when ambiguous" do
-    bundle "in"
+    bundle "in", :raise_on_error => false
     expect(err).to eq("Ambiguous command in matches [info, init, inject, install]")
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/other/ext_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/other/ext_spec.rb
@@ -44,6 +44,10 @@ RSpec.describe "Bundler::GemHelpers#gene
     expect(generic(pl("x64-mingw32"))).to eq(pl("x64-mingw32"))
     expect(generic(pl("x86_64-mingw32"))).to eq(pl("x64-mingw32"))
   end
+
+  it "converts 64-bit mingw UCRT platform variants into x64-mingw-ucrt" do
+    expect(generic(pl("x64-mingw-ucrt"))).to eq(pl("x64-mingw-ucrt"))
+  end
 end
 
 RSpec.describe "Gem::SourceIndex#refresh!" do
@@ -55,7 +59,7 @@ RSpec.describe "Gem::SourceIndex#refresh
   end
 
   it "does not explode when called" do
-    run "Gem.source_index.refresh!"
-    run "Gem::SourceIndex.new([]).refresh!"
+    run "Gem.source_index.refresh!", :raise_on_error => false
+    run "Gem::SourceIndex.new([]).refresh!", :raise_on_error => false
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/other/major_deprecation_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/other/major_deprecation_spec.rb
@@ -5,7 +5,7 @@ RSpec.describe "major deprecations" do
 
   describe "Bundler" do
     before do
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
@@ -17,7 +17,7 @@ RSpec.describe "major deprecations" do
         bundle "exec ruby -e #{source.dump}"
       end
 
-      it "is deprecated in favor of .unbundled_env", :bundler => "2" do
+      it "is deprecated in favor of .unbundled_env", :bundler => "< 3" do
         expect(deprecations).to include \
           "`Bundler.clean_env` has been deprecated in favor of `Bundler.unbundled_env`. " \
           "If you instead want the environment before bundler was originally loaded, use `Bundler.original_env` " \
@@ -33,7 +33,7 @@ RSpec.describe "major deprecations" do
         bundle "exec ruby -e #{source.dump}"
       end
 
-      it "is deprecated in favor of .unbundled_env", :bundler => "2" do
+      it "is deprecated in favor of .unbundled_env", :bundler => "< 3" do
         expect(deprecations).to include(
           "`Bundler.with_clean_env` has been deprecated in favor of `Bundler.with_unbundled_env`. " \
           "If you instead want the environment before bundler was originally loaded, use `Bundler.with_original_env` " \
@@ -50,7 +50,7 @@ RSpec.describe "major deprecations" do
         bundle "exec ruby -e #{source.dump}"
       end
 
-      it "is deprecated in favor of .unbundled_system", :bundler => "2" do
+      it "is deprecated in favor of .unbundled_system", :bundler => "< 3" do
         expect(deprecations).to include(
           "`Bundler.clean_system` has been deprecated in favor of `Bundler.unbundled_system`. " \
           "If you instead want to run the command in the environment before bundler was originally loaded, use `Bundler.original_system` " \
@@ -67,7 +67,7 @@ RSpec.describe "major deprecations" do
         bundle "exec ruby -e #{source.dump}"
       end
 
-      it "is deprecated in favor of .unbundled_exec", :bundler => "2" do
+      it "is deprecated in favor of .unbundled_exec", :bundler => "< 3" do
         expect(deprecations).to include(
           "`Bundler.clean_exec` has been deprecated in favor of `Bundler.unbundled_exec`. " \
           "If you instead want to exec to a command in the environment before bundler was originally loaded, use `Bundler.original_exec` " \
@@ -84,7 +84,7 @@ RSpec.describe "major deprecations" do
         bundle "exec ruby -e #{source.dump}"
       end
 
-      it "is deprecated in favor of .load", :bundler => "2" do
+      it "is deprecated in favor of .load", :bundler => "< 3" do
         expect(deprecations).to include "Bundler.environment has been removed in favor of Bundler.load (called at -e:1)"
       end
 
@@ -92,9 +92,21 @@ RSpec.describe "major deprecations" do
     end
   end
 
+  describe "bundle exec --no-keep-file-descriptors" do
+    before do
+      bundle "exec --no-keep-file-descriptors -e 1", :raise_on_error => false
+    end
+
+    it "is deprecated", :bundler => "< 3" do
+      expect(deprecations).to include "The `--no-keep-file-descriptors` has been deprecated. `bundle exec` no longer mess with your file descriptors. Close them in the exec'd script if you need to"
+    end
+
+    pending "is removed and shows a helpful error message about it", :bundler => "3"
+  end
+
   describe "bundle update --quiet" do
     it "does not print any deprecations" do
-      bundle :update, :quiet => true
+      bundle :update, :quiet => true, :raise_on_error => false
       expect(deprecations).to be_empty
     end
   end
@@ -106,25 +118,91 @@ RSpec.describe "major deprecations" do
         gem "rack"
       G
 
-      bundle "check --path vendor/bundle"
+      bundle "check --path vendor/bundle", :raise_on_error => false
     end
 
-    it "should print a deprecation warning", :bundler => "2" do
+    it "should print a deprecation warning", :bundler => "< 3" do
       expect(deprecations).to include(
         "The `--path` flag is deprecated because it relies on being " \
         "remembered across bundler invocations, which bundler will no " \
-        "longer do in future versions. Instead please use `bundle config set " \
+        "longer do in future versions. Instead please use `bundle config set --local " \
+        "path 'vendor/bundle'`, and stop using this flag"
+      )
+    end
+
+    pending "fails with a helpful error", :bundler => "3"
+  end
+
+  context "bundle check --path=" do
+    before do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      bundle "check --path=vendor/bundle", :raise_on_error => false
+    end
+
+    it "should print a deprecation warning", :bundler => "< 3" do
+      expect(deprecations).to include(
+        "The `--path` flag is deprecated because it relies on being " \
+        "remembered across bundler invocations, which bundler will no " \
+        "longer do in future versions. Instead please use `bundle config set --local " \
         "path 'vendor/bundle'`, and stop using this flag"
       )
     end
 
-    pending "should fail with a helpful error", :bundler => "3"
+    pending "fails with a helpful error", :bundler => "3"
+  end
+
+  context "bundle cache --all" do
+    before do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      bundle "cache --all", :raise_on_error => false
+    end
+
+    it "should print a deprecation warning", :bundler => "< 3" do
+      expect(deprecations).to include(
+        "The `--all` flag is deprecated because it relies on being " \
+        "remembered across bundler invocations, which bundler will no " \
+        "longer do in future versions. Instead please use `bundle config set " \
+        "cache_all true`, and stop using this flag"
+      )
+    end
+
+    pending "fails with a helpful error", :bundler => "3"
+  end
+
+  context "bundle cache --path" do
+    before do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      bundle "cache --path foo", :raise_on_error => false
+    end
+
+    it "should print a deprecation warning", :bundler => "< 3" do
+      expect(deprecations).to include(
+        "The `--path` flag is deprecated because its semantics are unclear. " \
+        "Use `bundle config cache_path` to configure the path of your cache of gems, " \
+        "and `bundle config path` to configure the path where your gems are installed, " \
+        "and stop using this flag"
+      )
+    end
+
+    pending "fails with a helpful error", :bundler => "3"
   end
 
   describe "bundle config" do
     describe "old list interface" do
       before do
-        bundle! "config"
+        bundle "config"
       end
 
       it "warns", :bundler => "3" do
@@ -136,7 +214,7 @@ RSpec.describe "major deprecations" do
 
     describe "old get interface" do
       before do
-        bundle! "config waka"
+        bundle "config waka"
       end
 
       it "warns", :bundler => "3" do
@@ -148,7 +226,7 @@ RSpec.describe "major deprecations" do
 
     describe "old set interface" do
       before do
-        bundle! "config waka wakapun"
+        bundle "config waka wakapun"
       end
 
       it "warns", :bundler => "3" do
@@ -160,7 +238,7 @@ RSpec.describe "major deprecations" do
 
     describe "old set interface with --local" do
       before do
-        bundle! "config --local waka wakapun"
+        bundle "config --local waka wakapun"
       end
 
       it "warns", :bundler => "3" do
@@ -172,7 +250,7 @@ RSpec.describe "major deprecations" do
 
     describe "old set interface with --global" do
       before do
-        bundle! "config --global waka wakapun"
+        bundle "config --global waka wakapun"
       end
 
       it "warns", :bundler => "3" do
@@ -184,7 +262,7 @@ RSpec.describe "major deprecations" do
 
     describe "old unset interface" do
       before do
-        bundle! "config --delete waka"
+        bundle "config --delete waka"
       end
 
       it "warns", :bundler => "3" do
@@ -196,7 +274,7 @@ RSpec.describe "major deprecations" do
 
     describe "old unset interface with --local" do
       before do
-        bundle! "config --delete --local waka"
+        bundle "config --delete --local waka"
       end
 
       it "warns", :bundler => "3" do
@@ -208,7 +286,7 @@ RSpec.describe "major deprecations" do
 
     describe "old unset interface with --global" do
       before do
-        bundle! "config --delete --global waka"
+        bundle "config --delete --global waka"
       end
 
       it "warns", :bundler => "3" do
@@ -228,14 +306,14 @@ RSpec.describe "major deprecations" do
     end
 
     it "warns when no options are given", :bundler => "3" do
-      bundle! "update"
+      bundle "update"
       expect(deprecations).to include("Pass --all to `bundle update` to update everything")
     end
 
     pending "fails with a helpful error when no options are given", :bundler => "3"
 
     it "does not warn when --all is passed" do
-      bundle! "update --all"
+      bundle "update --all"
       expect(deprecations).to be_empty
     end
   end
@@ -248,8 +326,8 @@ RSpec.describe "major deprecations" do
       G
     end
 
-    it "should output a deprecation warning", :bundler => "2" do
-      expect(deprecations).to include("The --binstubs option will be removed in favor of `bundle binstubs`")
+    it "should output a deprecation warning", :bundler => "< 3" do
+      expect(deprecations).to include("The --binstubs option will be removed in favor of `bundle binstubs --all`")
     end
 
     pending "fails with a helpful error", :bundler => "3"
@@ -267,14 +345,14 @@ RSpec.describe "major deprecations" do
     end
 
     it "should print a proper warning, and use gems.rb" do
-      create_file "gems.rb"
-      install_gemfile! <<-G
+      create_file "gems.rb", "source \"#{file_uri_for(gem_repo1)}\""
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
 
       expect(warnings).to include(
-        "Multiple gemfiles (gems.rb and Gemfile) detected. Make sure you remove Gemfile and Gemfile.lock since bundler is ignoring them in favor of gems.rb and gems.rb.locked."
+        "Multiple gemfiles (gems.rb and Gemfile) detected. Make sure you remove Gemfile and Gemfile.lock since bundler is ignoring them in favor of gems.rb and gems.locked."
       )
 
       expect(the_bundle).not_to include_gem "rack 1.0"
@@ -292,17 +370,18 @@ RSpec.describe "major deprecations" do
     end
 
     {
-      :clean => true,
-      :deployment => true,
-      :frozen => true,
-      :"no-cache" => true,
-      :"no-prune" => true,
-      :path => "vendor/bundle",
-      :shebang => "ruby27",
-      :system => true,
-      :without => "development",
-      :with => "development",
-    }.each do |name, value|
+      "clean" => ["clean", true],
+      "deployment" => ["deployment", true],
+      "frozen" => ["frozen", true],
+      "no-deployment" => ["deployment", false],
+      "no-prune" => ["no_prune", true],
+      "path" => ["path", "vendor/bundle"],
+      "shebang" => ["shebang", "ruby27"],
+      "system" => ["system", true],
+      "without" => ["without", "development"],
+      "with" => ["with", "development"],
+    }.each do |name, expectations|
+      option_name, value = *expectations
       flag_name = "--#{name}"
 
       context "with the #{flag_name} flag" do
@@ -311,16 +390,16 @@ RSpec.describe "major deprecations" do
           bundle "install #{flag_name} #{value}"
         end
 
-        it "should print a deprecation warning", :bundler => "2" do
+        it "should print a deprecation warning", :bundler => "< 3" do
           expect(deprecations).to include(
             "The `#{flag_name}` flag is deprecated because it relies on " \
             "being remembered across bundler invocations, which bundler " \
             "will no longer do in future versions. Instead please use " \
-            "`bundle config set #{name} '#{value}'`, and stop using this flag"
+            "`bundle config set --local #{option_name} '#{value}'`, and stop using this flag"
           )
         end
 
-        pending "should fail with a helpful error", :bundler => "3"
+        pending "fails with a helpful error", :bundler => "3"
       end
     end
   end
@@ -333,30 +412,98 @@ RSpec.describe "major deprecations" do
       G
     end
 
-    it "shows a deprecation", :bundler => "2" do
+    it "shows a deprecation", :bundler => "< 3" do
       expect(deprecations).to include(
-        "Your Gemfile contains multiple primary sources. " \
+        "Your Gemfile contains multiple global sources. " \
         "Using `source` more than once without a block is a security risk, and " \
         "may result in installing unexpected gems. To resolve this warning, use " \
-        "a block to indicate which gems should come from the secondary source. " \
-        "To upgrade this warning to an error, run `bundle config set " \
-        "disable_multisource true`."
+        "a block to indicate which gems should come from the secondary source."
       )
     end
 
-    pending "should fail with a helpful error", :bundler => "3"
+    it "doesn't show lockfile deprecations if there's a lockfile", :bundler => "< 3" do
+      bundle "install"
+
+      expect(deprecations).to include(
+        "Your Gemfile contains multiple global sources. " \
+        "Using `source` more than once without a block is a security risk, and " \
+        "may result in installing unexpected gems. To resolve this warning, use " \
+        "a block to indicate which gems should come from the secondary source."
+      )
+      expect(deprecations).not_to include(
+        "Your lockfile contains a single rubygems source section with multiple remotes, which is insecure. " \
+        "Make sure you run `bundle install` in non frozen mode and commit the result to make your lockfile secure."
+      )
+      bundle "config set --local frozen true"
+      bundle "install"
+
+      expect(deprecations).to include(
+        "Your Gemfile contains multiple global sources. " \
+        "Using `source` more than once without a block is a security risk, and " \
+        "may result in installing unexpected gems. To resolve this warning, use " \
+        "a block to indicate which gems should come from the secondary source."
+      )
+      expect(deprecations).not_to include(
+        "Your lockfile contains a single rubygems source section with multiple remotes, which is insecure. " \
+        "Make sure you run `bundle install` in non frozen mode and commit the result to make your lockfile secure."
+      )
+    end
+
+    pending "fails with a helpful error", :bundler => "3"
+  end
+
+  context "bundle install in frozen mode with a lockfile with a single rubygems section with multiple remotes" do
+    before do
+      build_repo gem_repo3 do
+        build_gem "rack", "0.9.1"
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        source "#{file_uri_for(gem_repo3)}" do
+          gem 'rack'
+        end
+      G
+
+      lockfile <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo1)}/
+          remote: #{file_uri_for(gem_repo3)}/
+          specs:
+            rack (0.9.1)
+
+        PLATFORMS
+          ruby
+
+        DEPENDENCIES
+          rack!
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      bundle "config set --local frozen true"
+    end
+
+    it "shows a deprecation", :bundler => "< 3" do
+      bundle "install"
+
+      expect(deprecations).to include("Your lockfile contains a single rubygems source section with multiple remotes, which is insecure. Make sure you run `bundle install` in non frozen mode and commit the result to make your lockfile secure.")
+    end
+
+    pending "fails with a helpful error", :bundler => "3"
   end
 
   context "when Bundler.setup is run in a ruby script" do
     before do
-      create_file "gems.rb"
-      install_gemfile! <<-G
+      create_file "gems.rb", "source \"#{file_uri_for(gem_repo1)}\""
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack", :group => :test
       G
 
       ruby <<-RUBY
-        require '#{lib_dir}/bundler'
+        require '#{entrypoint}'
 
         Bundler.setup
         Bundler.setup
@@ -365,198 +512,139 @@ RSpec.describe "major deprecations" do
 
     it "should print a single deprecation warning" do
       expect(warnings).to include(
-        "Multiple gemfiles (gems.rb and Gemfile) detected. Make sure you remove Gemfile and Gemfile.lock since bundler is ignoring them in favor of gems.rb and gems.rb.locked."
+        "Multiple gemfiles (gems.rb and Gemfile) detected. Make sure you remove Gemfile and Gemfile.lock since bundler is ignoring them in favor of gems.rb and gems.locked."
       )
     end
   end
 
   context "when `bundler/deployment` is required in a ruby script" do
     before do
-      ruby(<<-RUBY)
+      ruby(<<-RUBY, :env => env_for_missing_prerelease_default_gem_activation)
         require 'bundler/deployment'
       RUBY
     end
 
-    it "should print a capistrano deprecation warning", :bundler => "2" do
+    it "should print a capistrano deprecation warning", :bundler => "< 3" do
       expect(deprecations).to include("Bundler no longer integrates " \
                              "with Capistrano, but Capistrano provides " \
                              "its own integration with Bundler via the " \
                              "capistrano-bundler gem. Use it instead.")
     end
 
-    pending "should fail with a helpful error", :bundler => "3"
+    pending "fails with a helpful error", :bundler => "3"
   end
 
-  describe Bundler::Dsl do
+  context "bundle show" do
     before do
-      @rubygems = double("rubygems")
-      allow(Bundler::Source::Rubygems).to receive(:new) { @rubygems }
-    end
-
-    context "with github gems" do
-      it "warns about removal", :bundler => "2" do
-        msg = <<-EOS
-The :github git source is deprecated, and will be removed in the future. Change any "reponame" :github sources to "username/reponame". Add this code to the top of your Gemfile to ensure it continues to work:
-
-    git_source(:github) {|repo_name| "https://github.com/\#{repo_name}.git" }
-
-        EOS
-        expect(Bundler::SharedHelpers).to receive(:major_deprecation).with(3, msg)
-        subject.gem("sparks", :github => "indirect/sparks")
-        github_uri = "https://github.com/indirect/sparks.git"
-        expect(subject.dependencies.first.source.uri).to eq(github_uri)
-      end
-
-      pending "should fail with a helpful error", :bundler => "3"
-    end
-
-    context "with bitbucket gems" do
-      it "warns about removal", :bundler => "2" do
-        allow(Bundler.ui).to receive(:deprecate)
-        msg = <<-EOS
-The :bitbucket git source is deprecated, and will be removed in the future. Add this code to the top of your Gemfile to ensure it continues to work:
-
-    git_source(:bitbucket) do |repo_name|
-      user_name, repo_name = repo_name.split("/")
-      repo_name ||= user_name
-      "https://\#{user_name}@bitbucket.org/\#{user_name}/\#{repo_name}.git"
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
     end
 
-        EOS
-        expect(Bundler::SharedHelpers).to receive(:major_deprecation).with(3, msg)
-        subject.gem("not-really-a-gem", :bitbucket => "mcorp/flatlab-rails")
+    context "with --outdated flag" do
+      before do
+        bundle "show --outdated"
       end
 
-      pending "should fail with a helpful error", :bundler => "3"
-    end
-
-    context "with gist gems" do
-      it "warns about removal", :bundler => "2" do
-        allow(Bundler.ui).to receive(:deprecate)
-        msg = <<-EOS
-The :gist git source is deprecated, and will be removed in the future. Add this code to the top of your Gemfile to ensure it continues to work:
-
-    git_source(:gist) {|repo_name| "https://gist.github.com/\#{repo_name}.git" }
-
-        EOS
-        expect(Bundler::SharedHelpers).to receive(:major_deprecation).with(3, msg)
-        subject.gem("not-really-a-gem", :gist => "1234")
+      it "prints a deprecation warning informing about its removal", :bundler => "< 3" do
+        expect(deprecations).to include("the `--outdated` flag to `bundle show` was undocumented and will be removed without replacement")
       end
 
-      pending "should fail with a helpful error", :bundler => "3"
+      pending "fails with a helpful message", :bundler => "3"
     end
   end
 
-  context "bundle show" do
+  context "bundle remove" do
     before do
-      install_gemfile! <<-G
+      gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
     end
 
-    context "without flags" do
-      before do
-        bundle! :show
-      end
+    context "with --install" do
+      it "shows a deprecation warning", :bundler => "< 3" do
+        bundle "remove rack --install"
 
-      it "prints a deprecation warning recommending `bundle list`", :bundler => "2" do
-        expect(deprecations).to include("use `bundle list` instead of `bundle show`")
+        expect(err).to include "[DEPRECATED] The `--install` flag has been deprecated. `bundle install` is triggered by default."
       end
 
       pending "fails with a helpful message", :bundler => "3"
     end
+  end
 
-    context "with --outdated flag" do
-      before do
-        bundle! "show --outdated"
-      end
-
-      it "prints a deprecation warning informing about its removal", :bundler => "2" do
-        expect(deprecations).to include("the `--outdated` flag to `bundle show` was undocumented and will be removed without replacement")
-      end
+  context "bundle console" do
+    before do
+      bundle "console", :raise_on_error => false
+    end
 
-      pending "fails with a helpful message", :bundler => "3"
+    it "prints a deprecation warning", :bundler => "< 3" do
+      expect(deprecations).to include \
+        "bundle console will be replaced by `bin/console` generated by `bundle gem <name>`"
     end
 
-    context "with --verbose flag" do
-      before do
-        bundle! "show --verbose"
-      end
+    pending "fails with a helpful message", :bundler => "3"
+  end
 
-      it "prints a deprecation warning informing about its removal", :bundler => "2" do
-        expect(deprecations).to include("the `--verbose` flag to `bundle show` was undocumented and will be removed without replacement")
-      end
+  context "bundle viz" do
+    before do
+      graphviz_version = RUBY_VERSION >= "2.4" ? "1.2.5" : "1.2.4"
+      realworld_system_gems "ruby-graphviz --version #{graphviz_version}"
+      create_file "gems.rb", "source \"#{file_uri_for(gem_repo1)}\""
+      bundle "viz"
+    end
 
-      pending "fails with a helpful message", :bundler => "3"
+    it "prints a deprecation warning", :bundler => "< 3" do
+      expect(deprecations).to include "The `viz` command has been renamed to `graph` and moved to a plugin. See https://github.com/rubygems/bundler-graph"
     end
 
-    context "with a gem argument" do
+    pending "fails with a helpful message", :bundler => "3"
+  end
+
+  describe "deprecating rubocop", :readline do
+    context "bundle gem --rubocop" do
       before do
-        bundle! "show rack"
+        bundle "gem my_new_gem --rubocop", :raise_on_error => false
       end
 
-      it "prints a deprecation warning recommending `bundle info`", :bundler => "2" do
-        expect(deprecations).to include("use `bundle info rack` instead of `bundle show rack`")
+      it "prints a deprecation warning", :bundler => "< 3" do
+        expect(deprecations).to include \
+          "--rubocop is deprecated, use --linter=rubocop"
       end
-
-      pending "fails with a helpful message", :bundler => "3"
     end
 
-    context "with the --paths option" do
+    context "bundle gem --no-rubocop" do
       before do
-        bundle "show --paths"
+        bundle "gem my_new_gem --no-rubocop", :raise_on_error => false
       end
 
-      it "prints a deprecation warning recommending `bundle list`", :bundler => "2" do
-        expect(deprecations).to include("use `bundle list` instead of `bundle show --paths`")
+      it "prints a deprecation warning", :bundler => "< 3" do
+        expect(deprecations).to include \
+          "--no-rubocop is deprecated, use --linter"
       end
-
-      pending "fails with a helpful message", :bundler => "3"
     end
 
-    context "with a gem argument and the --paths option" do
+    context "bundle gem with gem.rubocop set to true" do
       before do
-        bundle "show rack --paths"
+        bundle "gem my_new_gem", :env => { "BUNDLE_GEM__RUBOCOP" => "true" }, :raise_on_error => false
       end
 
-      it "prints deprecation warning recommending `bundle info`", :bundler => "2" do
-        expect(deprecations).to include("use `bundle info rack --path` instead of `bundle show rack --paths`")
+      it "prints a deprecation warning", :bundler => "< 3" do
+        expect(deprecations).to include \
+          "config gem.rubocop is deprecated; we've updated your config to use gem.linter instead"
       end
-
-      pending "fails with a helpful message", :bundler => "3"
     end
-  end
 
-  context "bundle console" do
-    before do
-      bundle "console"
-    end
-
-    it "prints a deprecation warning", :bundler => "2" do
-      expect(deprecations).to include \
-        "bundle console will be replaced by `bin/console` generated by `bundle gem <name>`"
-    end
-
-    pending "fails with a helpful message", :bundler => "3"
-  end
-
-  context "bundle viz" do
-    let(:ruby_graphviz) do
-      graphviz_glob = base_system_gems.join("cache/ruby-graphviz*")
-      Pathname.glob(graphviz_glob).first
-    end
-
-    before do
-      system_gems ruby_graphviz
-      create_file "gems.rb"
-      bundle "viz"
-    end
+    context "bundle gem with gem.rubocop set to false" do
+      before do
+        bundle "gem my_new_gem", :env => { "BUNDLE_GEM__RUBOCOP" => "false" }, :raise_on_error => false
+      end
 
-    it "prints a deprecation warning", :bundler => "2" do
-      expect(deprecations).to include "The `viz` command has been moved to the `bundle-viz` gem, see https://github.com/bundler/bundler-viz"
+      it "prints a deprecation warning", :bundler => "< 3" do
+        expect(deprecations).to include \
+          "config gem.rubocop is deprecated; we've updated your config to use gem.linter instead"
+      end
     end
-
-    pending "fails with a helpful message", :bundler => "3"
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/other/platform_spec.rb
+++ /dev/null
@@ -1,1307 +0,0 @@
-# frozen_string_literal: true
-
-RSpec.describe "bundle platform" do
-  context "without flags" do
-    let(:bundle_platform_platforms_string) do
-      local_platforms.reverse.map {|pl| "* #{pl}" }.join("\n")
-    end
-
-    it "returns all the output" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-
-        #{ruby_version_correct}
-
-        gem "foo"
-      G
-
-      bundle "platform"
-      expect(out).to eq(<<-G.chomp)
-Your platform is: #{RUBY_PLATFORM}
-
-Your app has gems that work on these platforms:
-#{bundle_platform_platforms_string}
-
-Your Gemfile specifies a Ruby version requirement:
-* ruby #{RUBY_VERSION}
-
-Your current platform satisfies the Ruby version requirement.
-G
-    end
-
-    it "returns all the output including the patchlevel" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-
-        #{ruby_version_correct_patchlevel}
-
-        gem "foo"
-      G
-
-      bundle "platform"
-      expect(out).to eq(<<-G.chomp)
-Your platform is: #{RUBY_PLATFORM}
-
-Your app has gems that work on these platforms:
-#{bundle_platform_platforms_string}
-
-Your Gemfile specifies a Ruby version requirement:
-* ruby #{RUBY_VERSION}p#{RUBY_PATCHLEVEL}
-
-Your current platform satisfies the Ruby version requirement.
-G
-    end
-
-    it "doesn't print ruby version requirement if it isn't specified" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-
-        gem "foo"
-      G
-
-      bundle "platform"
-      expect(out).to eq(<<-G.chomp)
-Your platform is: #{RUBY_PLATFORM}
-
-Your app has gems that work on these platforms:
-#{bundle_platform_platforms_string}
-
-Your Gemfile does not specify a Ruby version requirement.
-G
-    end
-
-    it "doesn't match the ruby version requirement" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-
-        #{ruby_version_incorrect}
-
-        gem "foo"
-      G
-
-      bundle "platform"
-      expect(out).to eq(<<-G.chomp)
-Your platform is: #{RUBY_PLATFORM}
-
-Your app has gems that work on these platforms:
-#{bundle_platform_platforms_string}
-
-Your Gemfile specifies a Ruby version requirement:
-* ruby #{not_local_ruby_version}
-
-Your Ruby version is #{RUBY_VERSION}, but your Gemfile specified #{not_local_ruby_version}
-G
-    end
-  end
-
-  context "--ruby" do
-    it "returns ruby version when explicit" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        ruby "1.9.3", :engine => 'ruby', :engine_version => '1.9.3'
-
-        gem "foo"
-      G
-
-      bundle "platform --ruby"
-
-      expect(out).to eq("ruby 1.9.3")
-    end
-
-    it "defaults to MRI" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        ruby "1.9.3"
-
-        gem "foo"
-      G
-
-      bundle "platform --ruby"
-
-      expect(out).to eq("ruby 1.9.3")
-    end
-
-    it "handles jruby" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        ruby "1.8.7", :engine => 'jruby', :engine_version => '1.6.5'
-
-        gem "foo"
-      G
-
-      bundle "platform --ruby"
-
-      expect(out).to eq("ruby 1.8.7 (jruby 1.6.5)")
-    end
-
-    it "handles rbx" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        ruby "1.8.7", :engine => 'rbx', :engine_version => '1.2.4'
-
-        gem "foo"
-      G
-
-      bundle "platform --ruby"
-
-      expect(out).to eq("ruby 1.8.7 (rbx 1.2.4)")
-    end
-
-    it "handles truffleruby" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        ruby "2.5.1", :engine => 'truffleruby', :engine_version => '1.0.0-rc6'
-
-        gem "foo"
-      G
-
-      bundle "platform --ruby"
-
-      expect(out).to eq("ruby 2.5.1 (truffleruby 1.0.0-rc6)")
-    end
-
-    it "raises an error if engine is used but engine version is not" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        ruby "1.8.7", :engine => 'rbx'
-
-        gem "foo"
-      G
-
-      bundle "platform"
-
-      expect(exitstatus).not_to eq(0) if exitstatus
-    end
-
-    it "raises an error if engine_version is used but engine is not" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        ruby "1.8.7", :engine_version => '1.2.4'
-
-        gem "foo"
-      G
-
-      bundle "platform"
-
-      expect(exitstatus).not_to eq(0) if exitstatus
-    end
-
-    it "raises an error if engine version doesn't match ruby version for MRI" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        ruby "1.8.7", :engine => 'ruby', :engine_version => '1.2.4'
-
-        gem "foo"
-      G
-
-      bundle "platform"
-
-      expect(exitstatus).not_to eq(0) if exitstatus
-    end
-
-    it "should print if no ruby version is specified" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-
-        gem "foo"
-      G
-
-      bundle "platform --ruby"
-
-      expect(out).to eq("No ruby version specified")
-    end
-
-    it "handles when there is a locked requirement" do
-      gemfile <<-G
-        ruby "< 1.8.7"
-      G
-
-      lockfile <<-L
-        GEM
-          specs:
-
-        PLATFORMS
-          ruby
-
-        DEPENDENCIES
-
-        RUBY VERSION
-           ruby 1.0.0p127
-
-        BUNDLED WITH
-           #{Bundler::VERSION}
-      L
-
-      bundle! "platform --ruby"
-      expect(out).to eq("ruby 1.0.0p127")
-    end
-
-    it "handles when there is a requirement in the gemfile" do
-      gemfile <<-G
-        ruby ">= 1.8.7"
-      G
-
-      bundle! "platform --ruby"
-      expect(out).to eq("ruby 1.8.7")
-    end
-
-    it "handles when there are multiple requirements in the gemfile" do
-      gemfile <<-G
-        ruby ">= 1.8.7", "< 2.0.0"
-      G
-
-      bundle! "platform --ruby"
-      expect(out).to eq("ruby 1.8.7")
-    end
-  end
-
-  let(:ruby_version_correct) { "ruby \"#{RUBY_VERSION}\", :engine => \"#{local_ruby_engine}\", :engine_version => \"#{local_engine_version}\"" }
-  let(:ruby_version_correct_engineless) { "ruby \"#{RUBY_VERSION}\"" }
-  let(:ruby_version_correct_patchlevel) { "#{ruby_version_correct}, :patchlevel => '#{RUBY_PATCHLEVEL}'" }
-  let(:ruby_version_incorrect) { "ruby \"#{not_local_ruby_version}\", :engine => \"#{local_ruby_engine}\", :engine_version => \"#{not_local_ruby_version}\"" }
-  let(:engine_incorrect) { "ruby \"#{RUBY_VERSION}\", :engine => \"#{not_local_tag}\", :engine_version => \"#{RUBY_VERSION}\"" }
-  let(:engine_version_incorrect) { "ruby \"#{RUBY_VERSION}\", :engine => \"#{local_ruby_engine}\", :engine_version => \"#{not_local_engine_version}\"" }
-  let(:patchlevel_incorrect) { "#{ruby_version_correct}, :patchlevel => '#{not_local_patchlevel}'" }
-  let(:patchlevel_fixnum) { "#{ruby_version_correct}, :patchlevel => #{RUBY_PATCHLEVEL}1" }
-
-  def should_be_ruby_version_incorrect
-    expect(exitstatus).to eq(18) if exitstatus
-    expect(err).to be_include("Your Ruby version is #{RUBY_VERSION}, but your Gemfile specified #{not_local_ruby_version}")
-  end
-
-  def should_be_engine_incorrect
-    expect(exitstatus).to eq(18) if exitstatus
-    expect(err).to be_include("Your Ruby engine is #{local_ruby_engine}, but your Gemfile specified #{not_local_tag}")
-  end
-
-  def should_be_engine_version_incorrect
-    expect(exitstatus).to eq(18) if exitstatus
-    expect(err).to be_include("Your #{local_ruby_engine} version is #{local_engine_version}, but your Gemfile specified #{local_ruby_engine} #{not_local_engine_version}")
-  end
-
-  def should_be_patchlevel_incorrect
-    expect(exitstatus).to eq(18) if exitstatus
-    expect(err).to be_include("Your Ruby patchlevel is #{RUBY_PATCHLEVEL}, but your Gemfile specified #{not_local_patchlevel}")
-  end
-
-  def should_be_patchlevel_fixnum
-    expect(exitstatus).to eq(18) if exitstatus
-    expect(err).to be_include("The Ruby patchlevel in your Gemfile must be a string")
-  end
-
-  context "bundle install" do
-    it "installs fine when the ruby version matches" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{ruby_version_correct}
-      G
-
-      expect(bundled_app("Gemfile.lock")).to exist
-    end
-
-    it "installs fine with any engine" do
-      simulate_ruby_engine "jruby" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rack"
-
-          #{ruby_version_correct_engineless}
-        G
-
-        expect(bundled_app("Gemfile.lock")).to exist
-      end
-    end
-
-    it "installs fine when the patchlevel matches" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{ruby_version_correct_patchlevel}
-      G
-
-      expect(bundled_app("Gemfile.lock")).to exist
-    end
-
-    it "doesn't install when the ruby version doesn't match" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{ruby_version_incorrect}
-      G
-
-      expect(bundled_app("Gemfile.lock")).not_to exist
-      should_be_ruby_version_incorrect
-    end
-
-    it "doesn't install when engine doesn't match" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{engine_incorrect}
-      G
-
-      expect(bundled_app("Gemfile.lock")).not_to exist
-      should_be_engine_incorrect
-    end
-
-    it "doesn't install when engine version doesn't match" do
-      simulate_ruby_engine "jruby" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rack"
-
-          #{engine_version_incorrect}
-        G
-
-        expect(bundled_app("Gemfile.lock")).not_to exist
-        should_be_engine_version_incorrect
-      end
-    end
-
-    it "doesn't install when patchlevel doesn't match" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{patchlevel_incorrect}
-      G
-
-      expect(bundled_app("Gemfile.lock")).not_to exist
-      should_be_patchlevel_incorrect
-    end
-  end
-
-  context "bundle check" do
-    it "checks fine when the ruby version matches" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-      G
-
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{ruby_version_correct}
-      G
-
-      bundle :check
-      expect(exitstatus).to eq(0) if exitstatus
-      expect(out).to eq("Resolving dependencies...\nThe Gemfile's dependencies are satisfied")
-    end
-
-    it "checks fine with any engine" do
-      simulate_ruby_engine "jruby" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rack"
-        G
-
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rack"
-
-          #{ruby_version_correct_engineless}
-        G
-
-        bundle :check
-        expect(exitstatus).to eq(0) if exitstatus
-        expect(out).to eq("Resolving dependencies...\nThe Gemfile's dependencies are satisfied")
-      end
-    end
-
-    it "fails when ruby version doesn't match" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-      G
-
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{ruby_version_incorrect}
-      G
-
-      bundle :check
-      should_be_ruby_version_incorrect
-    end
-
-    it "fails when engine doesn't match" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-      G
-
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{engine_incorrect}
-      G
-
-      bundle :check
-      should_be_engine_incorrect
-    end
-
-    it "fails when engine version doesn't match" do
-      simulate_ruby_engine "ruby" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rack"
-        G
-
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rack"
-
-          #{engine_version_incorrect}
-        G
-
-        bundle :check
-        should_be_engine_version_incorrect
-      end
-    end
-
-    it "fails when patchlevel doesn't match" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-      G
-
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{patchlevel_incorrect}
-      G
-
-      bundle :check
-      should_be_patchlevel_incorrect
-    end
-  end
-
-  context "bundle update" do
-    before do
-      build_repo2
-
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo2)}"
-        gem "activesupport"
-        gem "rack-obama"
-      G
-    end
-
-    it "updates successfully when the ruby version matches" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo2)}"
-        gem "activesupport"
-        gem "rack-obama"
-
-        #{ruby_version_correct}
-      G
-      update_repo2 do
-        build_gem "activesupport", "3.0"
-      end
-
-      bundle "update", :all => true
-      expect(the_bundle).to include_gems "rack 1.2", "rack-obama 1.0", "activesupport 3.0"
-    end
-
-    it "updates fine with any engine" do
-      simulate_ruby_engine "jruby" do
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo2)}"
-          gem "activesupport"
-          gem "rack-obama"
-
-          #{ruby_version_correct_engineless}
-        G
-        update_repo2 do
-          build_gem "activesupport", "3.0"
-        end
-
-        bundle "update", :all => true
-        expect(the_bundle).to include_gems "rack 1.2", "rack-obama 1.0", "activesupport 3.0"
-      end
-    end
-
-    it "fails when ruby version doesn't match" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo2)}"
-        gem "activesupport"
-        gem "rack-obama"
-
-        #{ruby_version_incorrect}
-      G
-      update_repo2 do
-        build_gem "activesupport", "3.0"
-      end
-
-      bundle :update, :all => true
-      should_be_ruby_version_incorrect
-    end
-
-    it "fails when ruby engine doesn't match" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo2)}"
-        gem "activesupport"
-        gem "rack-obama"
-
-        #{engine_incorrect}
-      G
-      update_repo2 do
-        build_gem "activesupport", "3.0"
-      end
-
-      bundle :update, :all => true
-      should_be_engine_incorrect
-    end
-
-    it "fails when ruby engine version doesn't match" do
-      simulate_ruby_engine "jruby" do
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo2)}"
-          gem "activesupport"
-          gem "rack-obama"
-
-          #{engine_version_incorrect}
-        G
-        update_repo2 do
-          build_gem "activesupport", "3.0"
-        end
-
-        bundle :update, :all => true
-        should_be_engine_version_incorrect
-      end
-    end
-
-    it "fails when patchlevel doesn't match" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{patchlevel_incorrect}
-      G
-      update_repo2 do
-        build_gem "activesupport", "3.0"
-      end
-
-      bundle :update, :all => true
-      should_be_patchlevel_incorrect
-    end
-  end
-
-  context "bundle info" do
-    before do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rails"
-      G
-    end
-
-    it "prints path if ruby version is correct" do
-      install_gemfile! <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rails"
-
-        #{ruby_version_correct}
-      G
-
-      bundle "info rails --path"
-      expect(out).to eq(default_bundle_path("gems", "rails-2.3.2").to_s)
-    end
-
-    it "prints path if ruby version is correct for any engine" do
-      simulate_ruby_engine "jruby" do
-        install_gemfile! <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rails"
-
-          #{ruby_version_correct_engineless}
-        G
-
-        bundle "info rails --path"
-        expect(out).to eq(default_bundle_path("gems", "rails-2.3.2").to_s)
-      end
-    end
-
-    it "fails if ruby version doesn't match", :bundler => "< 3" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rails"
-
-        #{ruby_version_incorrect}
-      G
-
-      bundle "show rails"
-      should_be_ruby_version_incorrect
-    end
-
-    it "fails if engine doesn't match", :bundler => "< 3" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rails"
-
-        #{engine_incorrect}
-      G
-
-      bundle "show rails"
-      should_be_engine_incorrect
-    end
-
-    it "fails if engine version doesn't match", :bundler => "< 3" do
-      simulate_ruby_engine "jruby" do
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rails"
-
-          #{engine_version_incorrect}
-        G
-
-        bundle "show rails"
-        should_be_engine_version_incorrect
-      end
-    end
-
-    it "fails when patchlevel doesn't match", :bundler => "< 3" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{patchlevel_incorrect}
-      G
-      update_repo2 do
-        build_gem "activesupport", "3.0"
-      end
-
-      bundle "show rails"
-      should_be_patchlevel_incorrect
-    end
-  end
-
-  context "bundle cache" do
-    before do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem 'rack'
-      G
-    end
-
-    it "copies the .gem file to vendor/cache when ruby version matches" do
-      gemfile <<-G
-        gem 'rack'
-
-        #{ruby_version_correct}
-      G
-
-      bundle :cache
-      expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
-    end
-
-    it "copies the .gem file to vendor/cache when ruby version matches for any engine" do
-      simulate_ruby_engine "jruby" do
-        install_gemfile! <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem 'rack'
-
-          #{ruby_version_correct_engineless}
-        G
-
-        bundle! :cache
-        expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
-      end
-    end
-
-    it "fails if the ruby version doesn't match" do
-      gemfile <<-G
-        gem 'rack'
-
-        #{ruby_version_incorrect}
-      G
-
-      bundle :cache
-      should_be_ruby_version_incorrect
-    end
-
-    it "fails if the engine doesn't match" do
-      gemfile <<-G
-        gem 'rack'
-
-        #{engine_incorrect}
-      G
-
-      bundle :cache
-      should_be_engine_incorrect
-    end
-
-    it "fails if the engine version doesn't match" do
-      simulate_ruby_engine "jruby" do
-        gemfile <<-G
-          gem 'rack'
-
-          #{engine_version_incorrect}
-        G
-
-        bundle :cache
-        should_be_engine_version_incorrect
-      end
-    end
-
-    it "fails when patchlevel doesn't match" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{patchlevel_incorrect}
-      G
-
-      bundle :cache
-      should_be_patchlevel_incorrect
-    end
-  end
-
-  context "bundle pack" do
-    before do
-      install_gemfile! <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem 'rack'
-      G
-    end
-
-    it "copies the .gem file to vendor/cache when ruby version matches" do
-      gemfile <<-G
-        gem 'rack'
-
-        #{ruby_version_correct}
-      G
-
-      bundle :cache
-      expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
-    end
-
-    it "copies the .gem file to vendor/cache when ruby version matches any engine" do
-      simulate_ruby_engine "jruby" do
-        install_gemfile! <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem 'rack'
-
-          #{ruby_version_correct_engineless}
-        G
-
-        bundle :cache
-        expect(bundled_app("vendor/cache/rack-1.0.0.gem")).to exist
-      end
-    end
-
-    it "fails if the ruby version doesn't match" do
-      gemfile <<-G
-        gem 'rack'
-
-        #{ruby_version_incorrect}
-      G
-
-      bundle :cache
-      should_be_ruby_version_incorrect
-    end
-
-    it "fails if the engine doesn't match" do
-      gemfile <<-G
-        gem 'rack'
-
-        #{engine_incorrect}
-      G
-
-      bundle :cache
-      should_be_engine_incorrect
-    end
-
-    it "fails if the engine version doesn't match" do
-      simulate_ruby_engine "jruby" do
-        gemfile <<-G
-          gem 'rack'
-
-          #{engine_version_incorrect}
-        G
-
-        bundle :cache
-        should_be_engine_version_incorrect
-      end
-    end
-
-    it "fails when patchlevel doesn't match" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{patchlevel_incorrect}
-      G
-
-      bundle :cache
-      should_be_patchlevel_incorrect
-    end
-  end
-
-  context "bundle exec" do
-    before do
-      ENV["BUNDLER_FORCE_TTY"] = "true"
-      system_gems "rack-1.0.0", "rack-0.9.1", :path => :bundle_path
-    end
-
-    it "activates the correct gem when ruby version matches" do
-      gemfile <<-G
-        gem "rack", "0.9.1"
-
-        #{ruby_version_correct}
-      G
-
-      bundle "exec rackup"
-      expect(out).to include("0.9.1")
-    end
-
-    it "activates the correct gem when ruby version matches any engine" do
-      simulate_ruby_engine "jruby" do
-        system_gems "rack-1.0.0", "rack-0.9.1", :path => :bundle_path
-        gemfile <<-G
-          gem "rack", "0.9.1"
-
-          #{ruby_version_correct_engineless}
-        G
-
-        bundle "exec rackup"
-        expect(out).to include("0.9.1")
-      end
-    end
-
-    it "fails when the ruby version doesn't match" do
-      gemfile <<-G
-        gem "rack", "0.9.1"
-
-        #{ruby_version_incorrect}
-      G
-
-      bundle "exec rackup"
-      should_be_ruby_version_incorrect
-    end
-
-    it "fails when the engine doesn't match" do
-      gemfile <<-G
-        gem "rack", "0.9.1"
-
-        #{engine_incorrect}
-      G
-
-      bundle "exec rackup"
-      should_be_engine_incorrect
-    end
-
-    # it "fails when the engine version doesn't match" do
-    #   simulate_ruby_engine "jruby" do
-    #     gemfile <<-G
-    #       gem "rack", "0.9.1"
-    #
-    #       #{engine_version_incorrect}
-    #     G
-    #
-    #     bundle "exec rackup"
-    #     should_be_engine_version_incorrect
-    #   end
-    # end
-
-    it "fails when patchlevel doesn't match" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-
-        #{patchlevel_incorrect}
-      G
-
-      bundle "exec rackup"
-      should_be_patchlevel_incorrect
-    end
-  end
-
-  context "bundle console", :bundler => "< 3" do
-    before do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-        gem "activesupport", :group => :test
-        gem "rack_middleware", :group => :development
-      G
-    end
-
-    it "starts IRB with the default group loaded when ruby version matches" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-        gem "activesupport", :group => :test
-        gem "rack_middleware", :group => :development
-
-        #{ruby_version_correct}
-      G
-
-      bundle "console" do |input, _, _|
-        input.puts("puts RACK")
-        input.puts("exit")
-      end
-      expect(out).to include("0.9.1")
-    end
-
-    it "starts IRB with the default group loaded when ruby version matches any engine" do
-      skip "irb depend on JRuby.compile_ir and don't work in simulated environment." unless RUBY_ENGINE == "jruby"
-      simulate_ruby_engine "jruby" do
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rack"
-          gem "activesupport", :group => :test
-          gem "rack_middleware", :group => :development
-
-          #{ruby_version_correct_engineless}
-        G
-
-        bundle "console" do |input, _, _|
-          input.puts("puts RACK")
-          input.puts("exit")
-        end
-        expect(out).to include("0.9.1")
-      end
-    end
-
-    it "fails when ruby version doesn't match" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-        gem "activesupport", :group => :test
-        gem "rack_middleware", :group => :development
-
-        #{ruby_version_incorrect}
-      G
-
-      bundle "console"
-      should_be_ruby_version_incorrect
-    end
-
-    it "fails when engine doesn't match" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-        gem "activesupport", :group => :test
-        gem "rack_middleware", :group => :development
-
-        #{engine_incorrect}
-      G
-
-      bundle "console"
-      should_be_engine_incorrect
-    end
-
-    it "fails when engine version doesn't match" do
-      simulate_ruby_engine "jruby" do
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rack"
-          gem "activesupport", :group => :test
-          gem "rack_middleware", :group => :development
-
-          #{engine_version_incorrect}
-        G
-
-        bundle "console"
-        should_be_engine_version_incorrect
-      end
-    end
-
-    it "fails when patchlevel doesn't match" do
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "rack"
-        gem "activesupport", :group => :test
-        gem "rack_middleware", :group => :development
-
-        #{patchlevel_incorrect}
-      G
-
-      bundle "console"
-      should_be_patchlevel_incorrect
-    end
-  end
-
-  context "Bundler.setup" do
-    before do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "yard"
-        gem "rack", :group => :test
-      G
-
-      ENV["BUNDLER_FORCE_TTY"] = "true"
-    end
-
-    it "makes a Gemfile.lock if setup succeeds" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "yard"
-        gem "rack"
-
-        #{ruby_version_correct}
-      G
-
-      FileUtils.rm(bundled_app("Gemfile.lock"))
-
-      run "1"
-      expect(bundled_app("Gemfile.lock")).to exist
-    end
-
-    it "makes a Gemfile.lock if setup succeeds for any engine" do
-      simulate_ruby_engine "jruby" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "yard"
-          gem "rack"
-
-          #{ruby_version_correct_engineless}
-        G
-
-        FileUtils.rm(bundled_app("Gemfile.lock"))
-
-        run "1"
-        expect(bundled_app("Gemfile.lock")).to exist
-      end
-    end
-
-    it "fails when ruby version doesn't match" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "yard"
-        gem "rack"
-
-        #{ruby_version_incorrect}
-      G
-
-      FileUtils.rm(bundled_app("Gemfile.lock"))
-
-      ruby <<-R
-        require 'bundler/setup'
-      R
-
-      expect(bundled_app("Gemfile.lock")).not_to exist
-      should_be_ruby_version_incorrect
-    end
-
-    it "fails when engine doesn't match" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "yard"
-        gem "rack"
-
-        #{engine_incorrect}
-      G
-
-      FileUtils.rm(bundled_app("Gemfile.lock"))
-
-      ruby <<-R
-        require 'bundler/setup'
-      R
-
-      expect(bundled_app("Gemfile.lock")).not_to exist
-      should_be_engine_incorrect
-    end
-
-    it "fails when engine version doesn't match" do
-      simulate_ruby_engine "jruby" do
-        install_gemfile <<-G
-          source "#{file_uri_for(gem_repo1)}"
-          gem "yard"
-          gem "rack"
-
-          #{engine_version_incorrect}
-        G
-
-        FileUtils.rm(bundled_app("Gemfile.lock"))
-
-        ruby <<-R
-          require 'bundler/setup'
-        R
-
-        expect(bundled_app("Gemfile.lock")).not_to exist
-        should_be_engine_version_incorrect
-      end
-    end
-
-    it "fails when patchlevel doesn't match" do
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo1)}"
-        gem "yard"
-        gem "rack"
-
-        #{patchlevel_incorrect}
-      G
-
-      FileUtils.rm(bundled_app("Gemfile.lock"))
-
-      ruby <<-R
-        require 'bundler/setup'
-      R
-
-      expect(bundled_app("Gemfile.lock")).not_to exist
-      should_be_patchlevel_incorrect
-    end
-  end
-
-  context "bundle outdated" do
-    before do
-      build_repo2 do
-        build_git "foo", :path => lib_path("foo")
-      end
-
-      install_gemfile <<-G
-        source "#{file_uri_for(gem_repo2)}"
-        gem "activesupport", "2.3.5"
-        gem "foo", :git => "#{lib_path("foo")}"
-      G
-    end
-
-    it "returns list of outdated gems when the ruby version matches" do
-      update_repo2 do
-        build_gem "activesupport", "3.0"
-        update_git "foo", :path => lib_path("foo")
-      end
-
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo2)}"
-        gem "activesupport", "2.3.5"
-        gem "foo", :git => "#{lib_path("foo")}"
-
-        #{ruby_version_correct}
-      G
-
-      bundle "outdated"
-      expect(out).to include("activesupport (newest 3.0, installed 2.3.5, requested = 2.3.5")
-      expect(out).to include("foo (newest 1.0")
-    end
-
-    it "returns list of outdated gems when the ruby version matches for any engine" do
-      simulate_ruby_engine "jruby" do
-        bundle! :install
-        update_repo2 do
-          build_gem "activesupport", "3.0"
-          update_git "foo", :path => lib_path("foo")
-        end
-
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo2)}"
-          gem "activesupport", "2.3.5"
-          gem "foo", :git => "#{lib_path("foo")}"
-
-          #{ruby_version_correct_engineless}
-        G
-
-        bundle "outdated"
-        expect(out).to include("activesupport (newest 3.0, installed 2.3.5, requested = 2.3.5)")
-        expect(out).to include("foo (newest 1.0")
-      end
-    end
-
-    it "fails when the ruby version doesn't match" do
-      update_repo2 do
-        build_gem "activesupport", "3.0"
-        update_git "foo", :path => lib_path("foo")
-      end
-
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo2)}"
-        gem "activesupport", "2.3.5"
-        gem "foo", :git => "#{lib_path("foo")}"
-
-        #{ruby_version_incorrect}
-      G
-
-      bundle "outdated"
-      should_be_ruby_version_incorrect
-    end
-
-    it "fails when the engine doesn't match" do
-      update_repo2 do
-        build_gem "activesupport", "3.0"
-        update_git "foo", :path => lib_path("foo")
-      end
-
-      gemfile <<-G
-        source "#{file_uri_for(gem_repo2)}"
-        gem "activesupport", "2.3.5"
-        gem "foo", :git => "#{lib_path("foo")}"
-
-        #{engine_incorrect}
-      G
-
-      bundle "outdated"
-      should_be_engine_incorrect
-    end
-
-    it "fails when the engine version doesn't match" do
-      simulate_ruby_engine "jruby" do
-        update_repo2 do
-          build_gem "activesupport", "3.0"
-          update_git "foo", :path => lib_path("foo")
-        end
-
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo2)}"
-          gem "activesupport", "2.3.5"
-          gem "foo", :git => "#{lib_path("foo")}"
-
-          #{engine_version_incorrect}
-        G
-
-        bundle "outdated"
-        should_be_engine_version_incorrect
-      end
-    end
-
-    it "fails when the patchlevel doesn't match" do
-      simulate_ruby_engine "jruby" do
-        update_repo2 do
-          build_gem "activesupport", "3.0"
-          update_git "foo", :path => lib_path("foo")
-        end
-
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo2)}"
-          gem "activesupport", "2.3.5"
-          gem "foo", :git => "#{lib_path("foo")}"
-
-          #{patchlevel_incorrect}
-        G
-
-        bundle "outdated"
-        should_be_patchlevel_incorrect
-      end
-    end
-
-    it "fails when the patchlevel is a fixnum" do
-      simulate_ruby_engine "jruby" do
-        update_repo2 do
-          build_gem "activesupport", "3.0"
-          update_git "foo", :path => lib_path("foo")
-        end
-
-        gemfile <<-G
-          source "#{file_uri_for(gem_repo2)}"
-          gem "activesupport", "2.3.5"
-          gem "foo", :git => "#{lib_path("foo")}"
-
-          #{patchlevel_fixnum}
-        G
-
-        bundle "outdated"
-        should_be_patchlevel_fixnum
-      end
-    end
-  end
-end
--- ruby2.7-2.7.6.orig/spec/bundler/plugins/command_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/plugins/command_spec.rb
@@ -69,12 +69,10 @@ RSpec.describe "command plugins" do
       end
     end
 
-    bundle "plugin install copycat --source #{file_uri_for(gem_repo2)}"
+    bundle "plugin install copycat --source #{file_uri_for(gem_repo2)}", :raise_on_error => false
 
     expect(out).not_to include("Installed plugin copycat")
 
-    expect(err).to include("Failed to install plugin")
-
-    expect(err).to include("Command(s) `mahcommand` declared by copycat are already registered.")
+    expect(err).to include("Failed to install plugin `copycat`, due to Bundler::Plugin::Index::CommandConflict (Command(s) `mahcommand` declared by copycat are already registered.)")
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/plugins/install_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/plugins/install_spec.rb
@@ -9,7 +9,7 @@ RSpec.describe "bundler plugin install" 
   end
 
   it "shows proper message when gem in not found in the source" do
-    bundle "plugin install no-foo --source #{file_uri_for(gem_repo1)}"
+    bundle "plugin install no-foo --source #{file_uri_for(gem_repo1)}", :raise_on_error => false
 
     expect(err).to include("Could not find")
     plugin_should_not_be_installed("no-foo")
@@ -22,6 +22,20 @@ RSpec.describe "bundler plugin install" 
     plugin_should_be_installed("foo")
   end
 
+  it "installs from sources configured as Gem.sources without any flags" do
+    bundle "plugin install foo", :env => { "BUNDLER_SPEC_GEM_SOURCES" => file_uri_for(gem_repo2).to_s }
+
+    expect(out).to include("Installed plugin foo")
+    plugin_should_be_installed("foo")
+  end
+
+  it "shows help when --help flag is given" do
+    bundle "plugin install --help"
+
+    # The help message defined in ../../lib/bundler/man/bundle-plugin.1.ronn will be output.
+    expect(out).to include("You can install, uninstall, and list plugin(s)")
+  end
+
   context "plugin is already installed" do
     before do
       bundle "plugin install foo --source #{file_uri_for(gem_repo2)}"
@@ -56,6 +70,41 @@ RSpec.describe "bundler plugin install" 
     plugin_should_be_installed("foo", "kung-foo")
   end
 
+  it "installs the latest version if not installed" do
+    update_repo2 do
+      build_plugin "foo", "1.1"
+    end
+
+    bundle "plugin install foo --version 1.0 --source #{file_uri_for(gem_repo2)} --verbose"
+    expect(out).to include("Installing foo 1.0")
+
+    bundle "plugin install foo --source #{file_uri_for(gem_repo2)} --verbose"
+    expect(out).to include("Installing foo 1.1")
+
+    bundle "plugin install foo --source #{file_uri_for(gem_repo2)} --verbose"
+    expect(out).to include("Using foo 1.1")
+  end
+
+  it "installs when --branch specified" do
+    bundle "plugin install foo --branch main --source #{file_uri_for(gem_repo2)}"
+
+    expect(out).to include("Installed plugin foo")
+  end
+
+  it "installs when --ref specified" do
+    bundle "plugin install foo --ref v1.2.3 --source #{file_uri_for(gem_repo2)}"
+
+    expect(out).to include("Installed plugin foo")
+  end
+
+  it "raises error when both --branch and --ref options are specified" do
+    bundle "plugin install foo --source #{file_uri_for(gem_repo2)} --branch main --ref v1.2.3", :raise_on_error => false
+
+    expect(out).not_to include("Installed plugin foo")
+
+    expect(err).to include("You cannot specify `--branch` and `--ref` at the same time.")
+  end
+
   it "works with different load paths" do
     build_repo2 do
       build_plugin "testing" do |s|
@@ -96,9 +145,9 @@ RSpec.describe "bundler plugin install" 
         build_gem "charlie"
       end
 
-      bundle "plugin install charlie --source #{file_uri_for(gem_repo2)}"
+      bundle "plugin install charlie --source #{file_uri_for(gem_repo2)}", :raise_on_error => false
 
-      expect(err).to include("plugins.rb was not found")
+      expect(err).to include("Failed to install plugin `charlie`, due to Bundler::Plugin::MalformattedPlugin (plugins.rb was not found in the plugin.)")
 
       expect(global_plugin_gem("charlie-1.0")).not_to be_directory
 
@@ -115,7 +164,7 @@ RSpec.describe "bundler plugin install" 
         end
       end
 
-      bundle "plugin install chaplin --source #{file_uri_for(gem_repo2)}"
+      bundle "plugin install chaplin --source #{file_uri_for(gem_repo2)}", :raise_on_error => false
 
       expect(global_plugin_gem("chaplin-1.0")).not_to be_directory
 
@@ -147,14 +196,18 @@ RSpec.describe "bundler plugin install" 
     end
 
     it "raises an error when both git and local git sources are specified" do
-      bundle "plugin install foo --local_git /phony/path/project --git git@gitphony.com:/repo/project"
+      bundle "plugin install foo --local_git /phony/path/project --git git@gitphony.com:/repo/project", :raise_on_error => false
 
-      expect(exitstatus).not_to eq(0) if exitstatus
+      expect(exitstatus).not_to eq(0)
       expect(err).to eq("Remote and local plugin git sources can't be both specified")
     end
   end
 
   context "Gemfile eval" do
+    before do
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
+    end
+
     it "installs plugins listed in gemfile" do
       gemfile <<-G
         source '#{file_uri_for(gem_repo2)}'
@@ -197,6 +250,7 @@ RSpec.describe "bundler plugin install" 
       end
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         plugin 'ga-plugin', :git => "#{lib_path("ga-plugin-1.0")}"
       G
 
@@ -204,14 +258,29 @@ RSpec.describe "bundler plugin install" 
       plugin_should_be_installed("ga-plugin")
     end
 
+    it "accepts path sources" do
+      build_lib "ga-plugin" do |s|
+        s.write "plugins.rb"
+      end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        plugin 'ga-plugin', :path => "#{lib_path("ga-plugin-1.0")}"
+      G
+
+      expect(out).to include("Installed plugin ga-plugin")
+      plugin_should_be_installed("ga-plugin")
+    end
+
     context "in deployment mode" do
       it "installs plugins" do
-        install_gemfile! <<-G
+        install_gemfile <<-G
           source '#{file_uri_for(gem_repo2)}'
           gem 'rack', "1.0.0"
         G
 
-        install_gemfile! <<-G, forgotten_command_line_options(:deployment => true)
+        bundle "config set --local deployment true"
+        install_gemfile <<-G
           source '#{file_uri_for(gem_repo2)}'
           plugin 'foo'
           gem 'rack', "1.0.0"
@@ -238,13 +307,14 @@ RSpec.describe "bundler plugin install" 
         end
       RUBY
 
-      ruby code
+      ruby code, :env => { "BUNDLER_VERSION" => Bundler::VERSION }
       expect(local_plugin_gem("foo-1.0", "plugins.rb")).to exist
     end
   end
 
   describe "local plugin" do
     it "is installed when inside an app" do
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
       gemfile ""
       bundle "plugin install foo --source #{file_uri_for(gem_repo2)}"
 
@@ -287,21 +357,16 @@ RSpec.describe "bundler plugin install" 
         end
 
         # outside the app
-        Dir.chdir tmp
-        bundle "plugin install fubar --source #{file_uri_for(gem_repo2)}"
+        bundle "plugin install fubar --source #{file_uri_for(gem_repo2)}", :dir => tmp
       end
 
       it "inside the app takes precedence over global plugin" do
-        Dir.chdir bundled_app
-
         bundle "shout"
         expect(out).to eq("local_one")
       end
 
       it "outside the app global plugin is used" do
-        Dir.chdir tmp
-
-        bundle "shout"
+        bundle "shout", :dir => tmp
         expect(out).to eq("global_one")
       end
     end
--- ruby2.7-2.7.6.orig/spec/bundler/plugins/source/example_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/plugins/source/example_spec.rb
@@ -33,6 +33,7 @@ RSpec.describe "real source plugins" do
 
               def install(spec, opts)
                 mkdir_p(install_path.parent)
+                require 'fileutils'
                 FileUtils.cp_r(path, install_path)
 
                 spec_path = install_path.join("\#{spec.full_name}.gemspec")
@@ -66,35 +67,10 @@ RSpec.describe "real source plugins" do
       expect(the_bundle).to include_gems("a-path-gem 1.0")
     end
 
-    it "writes to lock file", :bundler => "< 3" do
+    it "writes to lock file" do
       bundle "install"
 
-      lockfile_should_be <<-G
-        PLUGIN SOURCE
-          remote: #{lib_path("a-path-gem-1.0")}
-          type: mpath
-          specs:
-            a-path-gem (1.0)
-
-        GEM
-          remote: #{file_uri_for(gem_repo2)}/
-          specs:
-
-        PLATFORMS
-          #{generic_local_platform}
-
-        DEPENDENCIES
-          a-path-gem!
-
-        BUNDLED WITH
-           #{Bundler::VERSION}
-      G
-    end
-
-    it "writes to lock file", :bundler => "3" do
-      bundle "install"
-
-      lockfile_should_be <<-G
+      expect(lockfile).to eq <<~G
         PLUGIN SOURCE
           remote: #{lib_path("a-path-gem-1.0")}
           type: mpath
@@ -155,10 +131,11 @@ RSpec.describe "real source plugins" do
         expect(the_bundle).to include_gems("a-path-gem 1.0")
       end
 
-      it "copies repository to vendor cache and uses it even when installed with bundle --path" do
-        bundle! :install, forgotten_command_line_options(:path => "vendor/bundle")
+      it "copies repository to vendor cache and uses it even when installed with `path` configured" do
+        bundle "config set --local path vendor/bundle"
+        bundle :install
         bundle "config set cache_all true"
-        bundle! :cache
+        bundle :cache
 
         expect(bundled_app("vendor/cache/a-path-gem-1.0-#{uri_hash}")).to exist
 
@@ -167,9 +144,10 @@ RSpec.describe "real source plugins" do
       end
 
       it "bundler package copies repository to vendor cache" do
-        bundle! :install, forgotten_command_line_options(:path => "vendor/bundle")
+        bundle "config set --local path vendor/bundle"
+        bundle :install
         bundle "config set cache_all true"
-        bundle! :cache
+        bundle :cache
 
         expect(bundled_app("vendor/cache/a-path-gem-1.0-#{uri_hash}")).to exist
 
@@ -203,7 +181,7 @@ RSpec.describe "real source plugins" do
       end
 
       it "installs" do
-        bundle! "install"
+        bundle "install"
 
         expect(the_bundle).to include_gems("a-path-gem 1.0")
       end
@@ -215,6 +193,8 @@ RSpec.describe "real source plugins" do
       build_repo2 do
         build_plugin "bundler-source-gitp" do |s|
           s.write "plugins.rb", <<-RUBY
+            require "open3"
+
             class SPlugin < Bundler::Plugin::API
               source "gitp"
 
@@ -223,7 +203,7 @@ RSpec.describe "real source plugins" do
               def initialize(opts)
                 super
 
-                @ref = options["ref"] || options["branch"] || options["tag"] || "master"
+                @ref = options["ref"] || options["branch"] || options["tag"] || "main"
                 @unlocked = false
               end
 
@@ -254,9 +234,7 @@ RSpec.describe "real source plugins" do
                 mkdir_p(install_path.dirname)
                 rm_rf(install_path)
                 `git clone --no-checkout --quiet "\#{cache_path}" "\#{install_path}"`
-                Dir.chdir install_path do
-                  `git reset --hard \#{revision}`
-                end
+                Open3.capture2e("git reset --hard \#{revision}", :chdir => install_path)
 
                 spec_path = install_path.join("\#{spec.full_name}.gemspec")
                 spec_path.open("wb") {|f| f.write spec.to_ruby }
@@ -269,7 +247,7 @@ RSpec.describe "real source plugins" do
 
               def options_to_lock
                 opts = {"revision" => revision}
-                opts["ref"] = ref if ref != "master"
+                opts["ref"] = ref if ref != "main"
                 opts
               end
 
@@ -310,9 +288,8 @@ RSpec.describe "real source plugins" do
                   cache_repo
                 end
 
-                Dir.chdir cache_path do
-                  `git rev-parse --verify \#{@ref}`.strip
-                end
+                output, _status = Open3.capture2e("git rev-parse --verify \#{@ref}", :chdir => cache_path)
+                output.strip
               end
 
               def base_name
@@ -361,38 +338,11 @@ RSpec.describe "real source plugins" do
       expect(the_bundle).to include_gems("ma-gitp-gem 1.0")
     end
 
-    it "writes to lock file", :bundler => "< 3" do
-      revision = revision_for(lib_path("ma-gitp-gem-1.0"))
-      bundle "install"
-
-      lockfile_should_be <<-G
-        PLUGIN SOURCE
-          remote: #{file_uri_for(lib_path("ma-gitp-gem-1.0"))}
-          type: gitp
-          revision: #{revision}
-          specs:
-            ma-gitp-gem (1.0)
-
-        GEM
-          remote: #{file_uri_for(gem_repo2)}/
-          specs:
-
-        PLATFORMS
-          #{generic_local_platform}
-
-        DEPENDENCIES
-          ma-gitp-gem!
-
-        BUNDLED WITH
-           #{Bundler::VERSION}
-      G
-    end
-
-    it "writes to lock file", :bundler => "3" do
+    it "writes to lock file" do
       revision = revision_for(lib_path("ma-gitp-gem-1.0"))
       bundle "install"
 
-      lockfile_should_be <<-G
+      expect(lockfile).to eq <<~G
         PLUGIN SOURCE
           remote: #{file_uri_for(lib_path("ma-gitp-gem-1.0"))}
           type: gitp
@@ -485,7 +435,7 @@ RSpec.describe "real source plugins" do
     describe "bundle cache with gitp" do
       it "copies repository to vendor cache and uses it" do
         git = build_git "foo"
-        ref = git.ref_for("master", 11)
+        ref = git.ref_for("main", 11)
 
         install_gemfile <<-G
           source "#{file_uri_for(gem_repo2)}" # plugin source
--- ruby2.7-2.7.6.orig/spec/bundler/plugins/source_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/plugins/source_spec.rb
@@ -21,6 +21,7 @@ RSpec.describe "bundler source plugin" d
         end
       G
 
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
       plugin_should_be_installed("bundler-source-psource")
     end
 
@@ -75,6 +76,7 @@ RSpec.describe "bundler source plugin" d
         end
 
         it "installs the explicit one" do
+          allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
           plugin_should_be_installed("another-psource")
         end
 
@@ -100,6 +102,7 @@ RSpec.describe "bundler source plugin" d
         end
 
         it "installs the default one" do
+          allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
           plugin_should_be_installed("bundler-source-psource")
         end
       end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/plugins/uninstall_spec.rb
@@ -0,0 +1,49 @@
+# frozen_string_literal: true
+
+RSpec.describe "bundler plugin uninstall" do
+  before do
+    build_repo2 do
+      build_plugin "foo"
+      build_plugin "kung-foo"
+    end
+  end
+
+  it "shows proper error message when plugins are not specified" do
+    bundle "plugin uninstall"
+    expect(err).to include("No plugins to uninstall")
+  end
+
+  it "uninstalls specified plugins" do
+    bundle "plugin install foo kung-foo --source #{file_uri_for(gem_repo2)}"
+    plugin_should_be_installed("foo")
+    plugin_should_be_installed("kung-foo")
+
+    bundle "plugin uninstall foo"
+    expect(out).to include("Uninstalled plugin foo")
+    plugin_should_not_be_installed("foo")
+    plugin_should_be_installed("kung-foo")
+  end
+
+  it "shows proper message when plugin is not installed" do
+    bundle "plugin uninstall foo"
+    expect(err).to include("Plugin foo is not installed")
+    plugin_should_not_be_installed("foo")
+  end
+
+  describe "with --all" do
+    it "uninstalls all installed plugins" do
+      bundle "plugin install foo kung-foo --source #{file_uri_for(gem_repo2)}"
+      plugin_should_be_installed("foo")
+      plugin_should_be_installed("kung-foo")
+
+      bundle "plugin uninstall --all"
+      plugin_should_not_be_installed("foo")
+      plugin_should_not_be_installed("kung-foo")
+    end
+
+    it "shows proper no plugins installed message when no plugins installed" do
+      bundle "plugin uninstall --all"
+      expect(out).to include("No plugins installed")
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/quality_es_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/quality_es_spec.rb
@@ -40,12 +40,10 @@ RSpec.describe "La biblioteca si misma" 
   it "mantiene la calidad de lenguaje de la documentación" do
     included = /ronn/
     error_messages = []
-    Dir.chdir(root) do
-      `git ls-files -z -- man`.split("\x0").each do |filename|
-        next unless filename =~ included
-        error_messages << check_for_expendable_words(filename)
-        error_messages << check_for_specific_pronouns(filename)
-      end
+    man_tracked_files.each do |filename|
+      next unless filename =~ included
+      error_messages << check_for_expendable_words(filename)
+      error_messages << check_for_specific_pronouns(filename)
     end
     expect(error_messages.compact).to be_well_formed
   end
@@ -53,12 +51,10 @@ RSpec.describe "La biblioteca si misma" 
   it "mantiene la calidad de lenguaje de oraciones usadas en el código fuente" do
     error_messages = []
     exempt = /vendor/
-    Dir.chdir(root) do
-      lib_tracked_files.split("\x0").each do |filename|
-        next if filename =~ exempt
-        error_messages << check_for_expendable_words(filename)
-        error_messages << check_for_specific_pronouns(filename)
-      end
+    lib_tracked_files.each do |filename|
+      next if filename =~ exempt
+      error_messages << check_for_expendable_words(filename)
+      error_messages << check_for_specific_pronouns(filename)
     end
     expect(error_messages.compact).to be_well_formed
   end
--- ruby2.7-2.7.6.orig/spec/bundler/quality_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/quality_spec.rb
@@ -3,25 +3,6 @@
 require "set"
 
 RSpec.describe "The library itself" do
-  def check_for_debugging_mechanisms(filename)
-    debugging_mechanisms_regex = /
-      (binding\.pry)|
-      (debugger)|
-      (sleep\s*\(?\d+)|
-      (fit\s*\(?("|\w))
-    /x
-
-    failing_lines = []
-    each_line(filename) do |line, number|
-      if line =~ debugging_mechanisms_regex && !line.end_with?("# ignore quality_spec\n")
-        failing_lines << number + 1
-      end
-    end
-
-    return if failing_lines.empty?
-    "#{filename} has debugging mechanisms (like binding.pry, sleep, debugger, rspec focusing, etc.) on lines #{failing_lines.join(", ")}"
-  end
-
   def check_for_git_merge_conflicts(filename)
     merge_conflicts_regex = /
       <<<<<<<|
@@ -105,14 +86,12 @@ RSpec.describe "The library itself" do
   end
 
   it "has no malformed whitespace" do
-    exempt = /\.gitmodules|fixtures|vendor|LICENSE|vcr_cassettes|rbreadline\.diff|\.txt$/
+    exempt = /\.gitmodules|fixtures|vendor|LICENSE|vcr_cassettes|rbreadline\.diff|index\.txt$/
     error_messages = []
-    Dir.chdir(root) do
-      tracked_files.split("\x0").each do |filename|
-        next if filename =~ exempt
-        error_messages << check_for_tab_characters(filename)
-        error_messages << check_for_extra_spaces(filename)
-      end
+    tracked_files.each do |filename|
+      next if filename =~ exempt
+      error_messages << check_for_tab_characters(filename)
+      error_messages << check_for_extra_spaces(filename)
     end
     expect(error_messages.compact).to be_well_formed
   end
@@ -120,23 +99,9 @@ RSpec.describe "The library itself" do
   it "has no estraneous quotes" do
     exempt = /vendor|vcr_cassettes|LICENSE|rbreadline\.diff/
     error_messages = []
-    Dir.chdir(root) do
-      tracked_files.split("\x0").each do |filename|
-        next if filename =~ exempt
-        error_messages << check_for_straneous_quotes(filename)
-      end
-    end
-    expect(error_messages.compact).to be_well_formed
-  end
-
-  it "does not include any leftover debugging or development mechanisms" do
-    exempt = %r{quality_spec.rb|support/helpers|vcr_cassettes|\.md|\.ronn|\.txt|\.5|\.1}
-    error_messages = []
-    Dir.chdir(root) do
-      tracked_files.split("\x0").each do |filename|
-        next if filename =~ exempt
-        error_messages << check_for_debugging_mechanisms(filename)
-      end
+    tracked_files.each do |filename|
+      next if filename =~ exempt
+      error_messages << check_for_straneous_quotes(filename)
     end
     expect(error_messages.compact).to be_well_formed
   end
@@ -144,11 +109,9 @@ RSpec.describe "The library itself" do
   it "does not include any unresolved merge conflicts" do
     error_messages = []
     exempt = %r{lock/lockfile_spec|quality_spec|vcr_cassettes|\.ronn|lockfile_parser\.rb}
-    Dir.chdir(root) do
-      tracked_files.split("\x0").each do |filename|
-        next if filename =~ exempt
-        error_messages << check_for_git_merge_conflicts(filename)
-      end
+    tracked_files.each do |filename|
+      next if filename =~ exempt
+      error_messages << check_for_git_merge_conflicts(filename)
     end
     expect(error_messages.compact).to be_well_formed
   end
@@ -156,38 +119,38 @@ RSpec.describe "The library itself" do
   it "maintains language quality of the documentation" do
     included = /ronn/
     error_messages = []
-    Dir.chdir(root) do
-      `git ls-files -z -- man`.split("\x0").each do |filename|
-        next unless filename =~ included
-        error_messages << check_for_expendable_words(filename)
-        error_messages << check_for_specific_pronouns(filename)
-      end
+    man_tracked_files.each do |filename|
+      next unless filename =~ included
+      error_messages << check_for_expendable_words(filename)
+      error_messages << check_for_specific_pronouns(filename)
     end
     expect(error_messages.compact).to be_well_formed
   end
 
   it "maintains language quality of sentences used in source code" do
     error_messages = []
-    exempt = /vendor|vcr_cassettes/
-    Dir.chdir(root) do
-      lib_tracked_files.split("\x0").each do |filename|
-        next if filename =~ exempt
-        error_messages << check_for_expendable_words(filename)
-        error_messages << check_for_specific_pronouns(filename)
-      end
+    exempt = /vendor|vcr_cassettes|CODE_OF_CONDUCT/
+    lib_tracked_files.each do |filename|
+      next if filename =~ exempt
+      error_messages << check_for_expendable_words(filename)
+      error_messages << check_for_specific_pronouns(filename)
     end
     expect(error_messages.compact).to be_well_formed
   end
 
   it "documents all used settings" do
     exemptions = %w[
-      auto_config_jobs
-      deployment_means_frozen
       forget_cli_options
+      gem.changelog
+      gem.ci
       gem.coc
+      gem.linter
       gem.mit
+      gem.rubocop
+      gem.test
+      git.allow_insecure
       inline
-      use_gem_version_promoter_for_major_updates
+      trust-policy
     ]
 
     all_settings = Hash.new {|h, k| h[k] = [] }
@@ -196,16 +159,15 @@ RSpec.describe "The library itself" do
     Bundler::Settings::BOOL_KEYS.each {|k| all_settings[k] << "in Bundler::Settings::BOOL_KEYS" }
     Bundler::Settings::NUMBER_KEYS.each {|k| all_settings[k] << "in Bundler::Settings::NUMBER_KEYS" }
     Bundler::Settings::ARRAY_KEYS.each {|k| all_settings[k] << "in Bundler::Settings::ARRAY_KEYS" }
+    Bundler::Settings::STRING_KEYS.each {|k| all_settings[k] << "in Bundler::Settings::STRING_KEYS" }
 
-    Dir.chdir(root) do
-      key_pattern = /([a-z\._-]+)/i
-      lib_tracked_files.split("\x0").each do |filename|
-        each_line(filename) do |line, number|
-          line.scan(/Bundler\.settings\[:#{key_pattern}\]/).flatten.each {|s| all_settings[s] << "referenced at `#{filename}:#{number.succ}`" }
-        end
+    key_pattern = /([a-z\._-]+)/i
+    lib_tracked_files.each do |filename|
+      each_line(filename) do |line, number|
+        line.scan(/Bundler\.settings\[:#{key_pattern}\]/).flatten.each {|s| all_settings[s] << "referenced at `#{filename}:#{number.succ}`" }
       end
-      documented_settings = File.read("man/bundle-config.ronn")[/LIST OF AVAILABLE KEYS.*/m].scan(/^\* `#{key_pattern}`/).flatten
     end
+    documented_settings = File.read("lib/bundler/man/bundle-config.1.ronn")[/LIST OF AVAILABLE KEYS.*/m].scan(/^\* `#{key_pattern}`/).flatten
 
     documented_settings.each do |s|
       all_settings.delete(s)
@@ -231,57 +193,52 @@ RSpec.describe "The library itself" do
   end
 
   it "ships the correct set of files" do
-    Dir.chdir(root) do
-      git_list = shipped_files.split("\x0")
+    git_list = git_ls_files(ruby_core? ? "lib/bundler lib/bundler.rb libexec/bundle*" : "lib exe CHANGELOG.md LICENSE.md README.md bundler.gemspec")
 
-      gem_list = Gem::Specification.load(gemspec.to_s).files
+    gem_list = loaded_gemspec.files
 
-      expect(git_list.to_set).to eq(gem_list.to_set)
-    end
+    expect(git_list.sort).to eq(gem_list.sort)
   end
 
   it "does not contain any warnings" do
-    Dir.chdir(root) do
-      exclusions = %w[
-        lib/bundler/capistrano.rb
-        lib/bundler/deployment.rb
-        lib/bundler/gem_tasks.rb
-        lib/bundler/vlad.rb
-        lib/bundler/templates/gems.rb
-      ]
-      files_to_require = lib_tracked_files.split("\x0").grep(/\.rb$/) - exclusions
-      files_to_require.reject! {|f| f.start_with?("lib/bundler/vendor") }
-      files_to_require.map! {|f| f.chomp(".rb") }
-      sys_exec!("ruby -w -Ilib") do |input, _, _|
-        files_to_require.each do |f|
-          input.puts "require '#{f.sub(%r{\Alib/}, "")}'"
-        end
+    exclusions = %w[
+      lib/bundler/capistrano.rb
+      lib/bundler/deployment.rb
+      lib/bundler/gem_tasks.rb
+      lib/bundler/vlad.rb
+      lib/bundler/templates/gems.rb
+    ]
+    files_to_require = lib_tracked_files.grep(/\.rb$/) - exclusions
+    files_to_require.reject! {|f| f.start_with?("lib/bundler/vendor") }
+    files_to_require.map! {|f| File.expand_path(f, source_root) }
+    files_to_require.sort!
+    sys_exec("ruby -w") do |input, _, _|
+      files_to_require.each do |f|
+        input.puts "require '#{f}'"
       end
+    end
 
-      warnings = last_command.stdboth.split("\n")
-      # ignore warnings around deprecated Object#=~ method in RubyGems
-      warnings.reject! {|w| w =~ %r{rubygems\/version.rb.*deprecated\ Object#=~} }
+    warnings = last_command.stdboth.split("\n")
+    # ignore warnings around deprecated Object#=~ method in RubyGems
+    warnings.reject! {|w| w =~ %r{rubygems\/version.rb.*deprecated\ Object#=~} }
 
-      expect(warnings).to be_well_formed
-    end
+    expect(warnings).to be_well_formed
   end
 
   it "does not use require internally, but require_relative" do
-    Dir.chdir(root) do
-      exempt = %r{templates/|vendor/}
-      all_bad_requires = []
-      lib_tracked_files.split("\x0").each do |filename|
-        next if filename =~ exempt
-        each_line(filename) do |line, number|
-          line.scan(/^ *require "bundler/).each { all_bad_requires << "#{filename}:#{number.succ}" }
-        end
+    exempt = %r{templates/|\.5|\.1|vendor/}
+    all_bad_requires = []
+    lib_tracked_files.each do |filename|
+      next if filename =~ exempt
+      each_line(filename) do |line, number|
+        line.scan(/^ *require "bundler/).each { all_bad_requires << "#{filename}:#{number.succ}" }
       end
-
-      expect(all_bad_requires).to be_empty, "#{all_bad_requires.size} internal requires that should use `require_relative`: #{all_bad_requires}"
     end
+
+    expect(all_bad_requires).to be_empty, "#{all_bad_requires.size} internal requires that should use `require_relative`: #{all_bad_requires}"
   end
 
-private
+  private
 
   def each_line(filename, &block)
     File.readlines(filename, :encoding => "UTF-8").each_with_index(&block)
--- ruby2.7-2.7.6.orig/spec/bundler/realworld/dependency_api_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/realworld/dependency_api_spec.rb
@@ -24,7 +24,7 @@ RSpec.describe "gemcutter's dependency A
       @t.run
 
       wait_for_server("127.0.0.1", port)
-      bundle! "config set timeout 1"
+      bundle "config set timeout 1"
     end
 
     after do
@@ -34,7 +34,7 @@ RSpec.describe "gemcutter's dependency A
     end
 
     it "times out and falls back on the modern index" do
-      install_gemfile! <<-G, :artifice => nil
+      install_gemfile <<-G, :artifice => nil
         source "#{@server_uri}"
         gem "rack"
       G
--- ruby2.7-2.7.6.orig/spec/bundler/realworld/double_check_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/realworld/double_check_spec.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
 
-RSpec.describe "double checking sources", :realworld => true, :sometimes => true do
+RSpec.describe "double checking sources", :realworld => true do
   it "finds already-installed gems" do
     create_file("rails.gemspec", <<-RUBY)
       Gem::Specification.new do |s|
@@ -25,16 +25,16 @@ RSpec.describe "double checking sources"
     RUBY
 
     cmd = <<-RUBY
-      require "#{lib_dir}/bundler"
+      require "#{entrypoint}"
       require "#{spec_dir}/support/artifice/vcr"
-      require "#{lib_dir}/bundler/inline"
+      require "#{entrypoint}/inline"
       gemfile(true) do
         source "https://rubygems.org"
         gem "rails", path: "."
       end
     RUBY
 
-    ruby! cmd
-    ruby! cmd
+    ruby cmd
+    ruby cmd
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/realworld/edgecases_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/realworld/edgecases_spec.rb
@@ -1,12 +1,12 @@
 # frozen_string_literal: true
 
-RSpec.describe "real world edgecases", :realworld => true, :sometimes => true do
+RSpec.describe "real world edgecases", :realworld => true do
   def rubygems_version(name, requirement)
-    ruby! <<-RUBY
+    ruby <<-RUBY
       require "#{spec_dir}/support/artifice/vcr"
-      require "#{lib_dir}/bundler"
-      require "#{lib_dir}/bundler/source/rubygems/remote"
-      require "#{lib_dir}/bundler/fetcher"
+      require "bundler"
+      require "bundler/source/rubygems/remote"
+      require "bundler/fetcher"
       rubygem = Bundler.ui.silence do
         source = Bundler::Source::Rubygems::Remote.new(Bundler::URI("https://rubygems.org"))
         fetcher = Bundler::Fetcher.new(source)
@@ -29,7 +29,7 @@ RSpec.describe "real world edgecases", :
       gem 'capybara', '~> 2.2.0'
       gem 'rack-cache', '1.2.0' # last version that works on Ruby 1.9
     G
-    bundle! :lock
+    bundle :lock
     expect(lockfile).to include(rubygems_version("rails", "~> 5.0"))
     expect(lockfile).to include("capybara (2.2.1)")
   end
@@ -43,7 +43,7 @@ RSpec.describe "real world edgecases", :
       gem "gxapi_rails", "< 0.1.0" # 0.1.0 was released way after the test was written
       gem 'rack-cache', '1.2.0' # last version that works on Ruby 1.9
     G
-    bundle! :lock
+    bundle :lock
     expect(lockfile).to include("gxapi_rails (0.0.6)")
   end
 
@@ -56,13 +56,15 @@ RSpec.describe "real world edgecases", :
       gem "activerecord", "~> 3.0"
       gem "builder", "~> 2.1.2"
     G
-    bundle! :lock
+    bundle :lock
     expect(lockfile).to include(rubygems_version("i18n", "~> 0.6.0"))
     expect(lockfile).to include(rubygems_version("activesupport", "~> 3.0"))
   end
 
   it "is able to update a top-level dependency when there is a conflict on a shared transitive child" do
-    # from https://github.com/bundler/bundler/issues/5031
+    # from https://github.com/rubygems/bundler/issues/5031
+
+    pristine_system_gems "bundler-1.99.0"
 
     gemfile <<-G
       source "https://rubygems.org"
@@ -152,7 +154,7 @@ RSpec.describe "real world edgecases", :
             activemodel (= 4.2.7.1)
             activerecord (= 4.2.7.1)
             activesupport (= 4.2.7.1)
-            bundler (>= 1.3.0, < 3.0)
+            bundler (>= 1.3.0, < 2.0)
             railties (= 4.2.7.1)
             sprockets-rails
           rails-deprecated_sanitizer (1.0.3)
@@ -189,159 +191,347 @@ RSpec.describe "real world edgecases", :
         rails (~> 4.2.7.1)
     L
 
-    bundle! "lock --update paperclip"
+    bundle "lock --update paperclip", :env => { "BUNDLER_VERSION" => "1.99.0" }
 
     expect(lockfile).to include(rubygems_version("paperclip", "~> 5.1.0"))
   end
 
-  # https://github.com/bundler/bundler/issues/1500
-  it "does not fail install because of gem plugins" do
-    realworld_system_gems("open_gem --version 1.4.2", "rake --version 0.9.2")
-    gemfile <<-G
-      source "https://rubygems.org"
-
-      gem 'rack', '1.0.1'
+  it "outputs a helpful error message when gems have invalid gemspecs", :rubygems => "< 3.3.16" do
+    install_gemfile <<-G, :standalone => true, :raise_on_error => false, :env => { "BUNDLE_FORCE_RUBY_PLATFORM" => "1" }
+      source 'https://rubygems.org'
+      gem "resque-scheduler", "2.2.0"
+      gem "redis-namespace", "1.6.0" # for a consistent resolution including ruby 2.3.0
+      gem "ruby2_keywords", "0.0.5"
     G
+    expect(err).to include("You have one or more invalid gemspecs that need to be fixed.")
+    expect(err).to include("resque-scheduler 2.2.0 has an invalid gemspec")
+  end
 
-    bundle "config set --local path vendor/bundle"
-    bundle! :install
-    expect(err).not_to include("Could not find rake")
-    expect(err).to be_empty
+  it "outputs a helpful warning when gems have a gemspec with invalid `require_paths`", :rubygems => ">= 3.3.16" do
+    install_gemfile <<-G, :standalone => true, :env => { "BUNDLE_FORCE_RUBY_PLATFORM" => "1" }
+      source 'https://rubygems.org'
+      gem "resque-scheduler", "2.2.0"
+      gem "redis-namespace", "1.6.0" # for a consistent resolution including ruby 2.3.0
+      gem "ruby2_keywords", "0.0.5"
+    G
+    expect(err).to include("resque-scheduler 2.2.0 includes a gemspec with `require_paths` set to an array of arrays. Newer versions of this gem might've already fixed this").once
   end
 
-  it "checks out git repos when the lockfile is corrupted" do
-    gemfile <<-G
+  it "doesn't hang on big gemfile" do
+    skip "Only for ruby 2.7.3" if RUBY_VERSION != "2.7.3" || RUBY_PLATFORM =~ /darwin/
+
+    gemfile <<~G
+      # frozen_string_literal: true
+
       source "https://rubygems.org"
-      git_source(:github) {|repo| "https://github.com/\#{repo}.git" }
 
-      gem 'activerecord',  :github => 'carlhuda/rails-bundler-test', :branch => 'master'
-      gem 'activesupport', :github => 'carlhuda/rails-bundler-test', :branch => 'master'
-      gem 'actionpack',    :github => 'carlhuda/rails-bundler-test', :branch => 'master'
-    G
+      ruby "2.7.3"
 
-    lockfile <<-L
-      GIT
-        remote: https://github.com/carlhuda/rails-bundler-test.git
-        revision: 369e28a87419565f1940815219ea9200474589d4
-        branch: master
-        specs:
-          actionpack (3.2.2)
-            activemodel (= 3.2.2)
-            activesupport (= 3.2.2)
-            builder (~> 3.0.0)
-            erubis (~> 2.7.0)
-            journey (~> 1.0.1)
-            rack (~> 1.4.0)
-            rack-cache (~> 1.2)
-            rack-test (~> 0.6.1)
-            sprockets (~> 2.1.2)
-          activemodel (3.2.2)
-            activesupport (= 3.2.2)
-            builder (~> 3.0.0)
-          activerecord (3.2.2)
-            activemodel (= 3.2.2)
-            activesupport (= 3.2.2)
-            arel (~> 3.0.2)
-            tzinfo (~> 0.3.29)
-          activesupport (3.2.2)
-            i18n (~> 0.6)
-            multi_json (~> 1.0)
-
-      GIT
-        remote: https://github.com/carlhuda/rails-bundler-test.git
-        revision: 369e28a87419565f1940815219ea9200474589d4
-        branch: master
-        specs:
-          actionpack (3.2.2)
-            activemodel (= 3.2.2)
-            activesupport (= 3.2.2)
-            builder (~> 3.0.0)
-            erubis (~> 2.7.0)
-            journey (~> 1.0.1)
-            rack (~> 1.4.0)
-            rack-cache (~> 1.2)
-            rack-test (~> 0.6.1)
-            sprockets (~> 2.1.2)
-          activemodel (3.2.2)
-            activesupport (= 3.2.2)
-            builder (~> 3.0.0)
-          activerecord (3.2.2)
-            activemodel (= 3.2.2)
-            activesupport (= 3.2.2)
-            arel (~> 3.0.2)
-            tzinfo (~> 0.3.29)
-          activesupport (3.2.2)
-            i18n (~> 0.6)
-            multi_json (~> 1.0)
-
-      GIT
-        remote: https://github.com/carlhuda/rails-bundler-test.git
-        revision: 369e28a87419565f1940815219ea9200474589d4
-        branch: master
-        specs:
-          actionpack (3.2.2)
-            activemodel (= 3.2.2)
-            activesupport (= 3.2.2)
-            builder (~> 3.0.0)
-            erubis (~> 2.7.0)
-            journey (~> 1.0.1)
-            rack (~> 1.4.0)
-            rack-cache (~> 1.2)
-            rack-test (~> 0.6.1)
-            sprockets (~> 2.1.2)
-          activemodel (3.2.2)
-            activesupport (= 3.2.2)
-            builder (~> 3.0.0)
-          activerecord (3.2.2)
-            activemodel (= 3.2.2)
-            activesupport (= 3.2.2)
-            arel (~> 3.0.2)
-            tzinfo (~> 0.3.29)
-          activesupport (3.2.2)
-            i18n (~> 0.6)
-            multi_json (~> 1.0)
+      gem "rails"
+      gem "pg", ">= 0.18", "< 2.0"
+      gem "goldiloader"
+      gem "awesome_nested_set"
+      gem "circuitbox"
+      gem "passenger"
+      gem "globalid"
+      gem "rack-cors"
+      gem "rails-pg-extras"
+      gem "linear_regression_trend"
+      gem "rack-protection"
+      gem "pundit"
+      gem "remote_ip_proxy_scrubber"
+      gem "bcrypt"
+      gem "searchkick"
+      gem "excon"
+      gem "faraday_middleware-aws-sigv4"
+      gem "typhoeus"
+      gem "sidekiq"
+      gem "sidekiq-undertaker"
+      gem "sidekiq-cron"
+      gem "storext"
+      gem "appsignal"
+      gem "fcm"
+      gem "business_time"
+      gem "tzinfo"
+      gem "holidays"
+      gem "bigdecimal"
+      gem "progress_bar"
+      gem "redis"
+      gem "hiredis"
+      gem "state_machines"
+      gem "state_machines-audit_trail"
+      gem "state_machines-activerecord"
+      gem "interactor"
+      gem "ar_transaction_changes"
+      gem "redis-rails"
+      gem "seed_migration"
+      gem "lograge"
+      gem "graphiql-rails", group: :development
+      gem "graphql"
+      gem "pusher"
+      gem "rbnacl"
+      gem "jwt"
+      gem "json-schema"
+      gem "discard"
+      gem "money"
+      gem "strip_attributes"
+      gem "validates_email_format_of"
+      gem "audited"
+      gem "concurrent-ruby"
+      gem "with_advisory_lock"
+
+      group :test do
+        gem "rspec-sidekiq"
+        gem "simplecov", require: false
+      end
 
-      GEM
-        remote: https://rubygems.org/
-        specs:
-          arel (3.0.2)
-          builder (3.0.0)
-          erubis (2.7.0)
-          hike (1.2.1)
-          i18n (0.6.0)
-          journey (1.0.3)
-          multi_json (1.1.0)
-          rack (1.4.1)
-          rack-cache (1.2)
-            rack (>= 0.4)
-          rack-test (0.6.1)
-            rack (>= 1.0)
-          sprockets (2.1.2)
-            hike (~> 1.2)
-            rack (~> 1.0)
-            tilt (~> 1.1, != 1.3.0)
-          tilt (1.3.3)
-          tzinfo (0.3.32)
+      group :development, :test do
+        gem "byebug", platform: :mri
+        gem "guard"
+        gem "guard-bundler"
+        gem "guard-rspec"
+        gem "rb-fsevent"
+        gem "rspec_junit_formatter"
+        gem "rspec-collection_matchers"
+        gem "rspec-rails"
+        gem "rspec-retry"
+        gem "state_machines-rspec"
+        gem "dotenv-rails"
+        gem "database_cleaner-active_record"
+        gem "database_cleaner-redis"
+        gem "timecop"
+      end
 
-      PLATFORMS
-        ruby
+      gem "factory_bot_rails"
+      gem "faker"
 
-      DEPENDENCIES
-        actionpack!
-        activerecord!
-        activesupport!
-    L
+      group :development do
+        gem "listen"
+        gem "sql_queries_count"
+        gem "rubocop"
+        gem "rubocop-performance"
+        gem "rubocop-rspec"
+        gem "rubocop-rails"
+        gem "brakeman"
+        gem "bundler-audit"
+        gem "solargraph"
+        gem "annotate"
+      end
+    G
 
-    bundle! :lock
-    expect(err).to be_empty
+    if Bundler.feature_flag.bundler_3_mode?
+      # Conflicts on bundler version, so fails earlier
+      bundle :lock, :env => { "DEBUG_RESOLVER" => "1" }, :raise_on_error => false
+      expect(out).to display_total_steps_of(435)
+    else
+      bundle :lock, :env => { "DEBUG_RESOLVER" => "1" }
+      expect(out).to display_total_steps_of(1025)
+    end
   end
 
-  it "outputs a helpful error message when gems have invalid gemspecs" do
-    install_gemfile <<-G, :standalone => true
+  it "doesn't hang on tricky gemfile" do
+    skip "Only for ruby 2.7.3" if RUBY_VERSION != "2.7.3" || RUBY_PLATFORM =~ /darwin/
+
+    gemfile <<~G
       source 'https://rubygems.org'
-      gem "resque-scheduler", "2.2.0"
+
+      group :development do
+        gem "puppet-module-posix-default-r2.7", '~> 0.3'
+        gem "puppet-module-posix-dev-r2.7", '~> 0.3'
+        gem "beaker-rspec"
+        gem "beaker-puppet"
+        gem "beaker-docker"
+        gem "beaker-puppet_install_helper"
+        gem "beaker-module_install_helper"
+      end
     G
-    expect(err).to include("You have one or more invalid gemspecs that need to be fixed.")
-    expect(err).to include("resque-scheduler 2.2.0 has an invalid gemspec")
+
+    bundle :lock, :env => { "DEBUG_RESOLVER" => "1" }
+
+    if Bundler.feature_flag.bundler_3_mode?
+      expect(out).to display_total_steps_of(890)
+    else
+      expect(out).to display_total_steps_of(891)
+    end
+  end
+
+  it "doesn't hang on nix gemfile" do
+    skip "Only for ruby 3.0.1" if RUBY_VERSION != "3.0.1" || RUBY_PLATFORM =~ /darwin/
+
+    gemfile <<~G
+      source "https://rubygems.org" do
+        gem "addressable"
+        gem "atk"
+        gem "awesome_print"
+        gem "bacon"
+        gem "byebug"
+        gem "cairo"
+        gem "cairo-gobject"
+        gem "camping"
+        gem "charlock_holmes"
+        gem "cld3"
+        gem "cocoapods"
+        gem "cocoapods-acknowledgements"
+        gem "cocoapods-art"
+        gem "cocoapods-bin"
+        gem "cocoapods-browser"
+        gem "cocoapods-bugsnag"
+        gem "cocoapods-check"
+        gem "cocoapods-clean"
+        gem "cocoapods-clean_build_phases_scripts"
+        gem "cocoapods-core"
+        gem "cocoapods-coverage"
+        gem "cocoapods-deintegrate"
+        gem "cocoapods-dependencies"
+        gem "cocoapods-deploy"
+        gem "cocoapods-downloader"
+        gem "cocoapods-expert-difficulty"
+        gem "cocoapods-fix-react-native"
+        gem "cocoapods-generate"
+        gem "cocoapods-git_url_rewriter"
+        gem "cocoapods-keys"
+        gem "cocoapods-no-dev-schemes"
+        gem "cocoapods-open"
+        gem "cocoapods-packager"
+        gem "cocoapods-playgrounds"
+        gem "cocoapods-plugins"
+        gem "cocoapods-prune-localizations"
+        gem "cocoapods-rome"
+        gem "cocoapods-search"
+        gem "cocoapods-sorted-search"
+        gem "cocoapods-static-swift-framework"
+        gem "cocoapods-stats"
+        gem "cocoapods-tdfire-binary"
+        gem "cocoapods-testing"
+        gem "cocoapods-trunk"
+        gem "cocoapods-try"
+        gem "cocoapods-try-release-fix"
+        gem "cocoapods-update-if-you-dare"
+        gem "cocoapods-whitelist"
+        gem "cocoapods-wholemodule"
+        gem "coderay"
+        gem "concurrent-ruby"
+        gem "curb"
+        gem "curses"
+        gem "daemons"
+        gem "dep-selector-libgecode"
+        gem "digest-sha3"
+        gem "domain_name"
+        gem "do_sqlite3"
+        gem "ethon"
+        gem "eventmachine"
+        gem "excon"
+        gem "faraday"
+        gem "ffi"
+        gem "ffi-rzmq-core"
+        gem "fog-dnsimple"
+        gem "gdk_pixbuf2"
+        gem "gio2"
+        gem "gitlab-markup"
+        gem "glib2"
+        gem "gpgme"
+        gem "gtk2"
+        gem "hashie"
+        gem "highline"
+        gem "hike"
+        gem "hitimes"
+        gem "hpricot"
+        gem "httpclient"
+        gem "http-cookie"
+        gem "iconv"
+        gem "idn-ruby"
+        gem "jbuilder"
+        gem "jekyll"
+        gem "jmespath"
+        gem "jwt"
+        gem "libv8"
+        gem "libxml-ruby"
+        gem "magic"
+        gem "markaby"
+        gem "method_source"
+        gem "mini_magick"
+        gem "msgpack"
+        gem "mysql2"
+        gem "ncursesw"
+        gem "netrc"
+        gem "net-scp"
+        gem "net-ssh"
+        gem "nokogiri"
+        gem "opus-ruby"
+        gem "ovirt-engine-sdk"
+        gem "pango"
+        gem "patron"
+        gem "pcaprub"
+        gem "pg"
+        gem "pry"
+        gem "pry-byebug"
+        gem "pry-doc"
+        gem "public_suffix"
+        gem "puma"
+        gem "rails"
+        gem "rainbow"
+        gem "rbnacl"
+        gem "rb-readline"
+        gem "re2"
+        gem "redis"
+        gem "redis-rack"
+        gem "rest-client"
+        gem "rmagick"
+        gem "rpam2"
+        gem "rspec"
+        gem "rubocop"
+        gem "rubocop-performance"
+        gem "ruby-libvirt"
+        gem "ruby-lxc"
+        gem "ruby-progressbar"
+        gem "ruby-terminfo"
+        gem "ruby-vips"
+        gem "rubyzip"
+        gem "rugged"
+        gem "sassc"
+        gem "scrypt"
+        gem "semian"
+        gem "sequel"
+        gem "sequel_pg"
+        gem "simplecov"
+        gem "sinatra"
+        gem "slop"
+        gem "snappy"
+        gem "sqlite3"
+        gem "taglib-ruby"
+        gem "thrift"
+        gem "tilt"
+        gem "tiny_tds"
+        gem "treetop"
+        gem "typhoeus"
+        gem "tzinfo"
+        gem "unf_ext"
+        gem "uuid4r"
+        gem "whois"
+        gem "zookeeper"
+      end
+    G
+
+    bundle :lock, :env => { "DEBUG_RESOLVER" => "1" }
+
+    if Bundler.feature_flag.bundler_3_mode?
+      expect(out).to display_total_steps_of(1874)
+    else
+      expect(out).to display_total_steps_of(1922)
+    end
+  end
+
+  private
+
+  RSpec::Matchers.define :display_total_steps_of do |expected_steps|
+    match do |out|
+      out.include?("BUNDLER: Finished resolution (#{expected_steps} steps)")
+    end
+
+    failure_message do |out|
+      actual_steps = out.scan(/BUNDLER: Finished resolution \((\d+) steps\)/).first.first
+
+      "Expected resolution to finish in #{expected_steps} steps, but took #{actual_steps}"
+    end
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/realworld/ffi_spec.rb
@@ -0,0 +1,57 @@
+# frozen_string_literal: true
+
+RSpec.describe "loading dinamically linked library on a bundle exec context", :realworld => true do
+  it "passes ENV right after argv in memory" do
+    create_file "foo.rb", <<~RUBY
+      require 'ffi'
+
+      module FOO
+        extend FFI::Library
+        ffi_lib './libfoo.so'
+
+        attach_function :Hello, [], :void
+      end
+
+      FOO.Hello()
+    RUBY
+
+    create_file "libfoo.c", <<~'C'
+      #include <stdio.h>
+
+      static int foo_init(int argc, char** argv, char** envp) {
+        if (argv[argc+1] == NULL) {
+          printf("FAIL\n");
+        } else {
+          printf("OK\n");
+        }
+
+        return 0;
+      }
+
+      #if defined(__APPLE__) && defined(__MACH__)
+      __attribute__((section("__DATA,__mod_init_func"), used, aligned(sizeof(void*))))
+      #else
+      __attribute__((section(".init_array")))
+      #endif
+      static void *ctr = &foo_init;
+
+      extern char** environ;
+
+      void Hello() {
+        return;
+      }
+    C
+
+    sys_exec "gcc -g -o libfoo.so -shared -fpic libfoo.c"
+
+    install_gemfile <<-G
+      source "https://rubygems.org"
+
+      gem 'ffi'
+    G
+
+    bundle "exec ruby foo.rb"
+
+    expect(out).to eq("OK")
+  end
+end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/realworld/fixtures/warbler/Gemfile
@@ -0,0 +1,7 @@
+# frozen_string_literal: true
+
+source "https://rubygems.org"
+
+gem "demo", :path => "./demo"
+gem "jruby-jars", "~> 9.2"
+gem "warbler", "~> 2.0"
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/realworld/fixtures/warbler/Gemfile.lock
@@ -0,0 +1,30 @@
+PATH
+  remote: demo
+  specs:
+    demo (1.0)
+
+GEM
+  remote: https://rubygems.org/
+  specs:
+    jruby-jars (9.2.16.0)
+    jruby-rack (1.1.21)
+    rake (13.0.1)
+    rubyzip (1.3.0)
+    warbler (2.0.5)
+      jruby-jars (>= 9.0.0.0)
+      jruby-rack (>= 1.1.1, < 1.3)
+      rake (>= 10.1.0)
+      rubyzip (~> 1.0, < 1.4)
+
+PLATFORMS
+  java
+  ruby
+  universal-java-11
+
+DEPENDENCIES
+  demo!
+  jruby-jars (~> 9.2)
+  warbler (~> 2.0)
+
+BUNDLED WITH
+   2.3.0.dev
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/realworld/fixtures/warbler/bin/warbler-example.rb
@@ -0,0 +1,3 @@
+# frozen_string_literal: true
+
+puts require "bundler/setup"
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/realworld/fixtures/warbler/demo/demo.gemspec
@@ -0,0 +1,10 @@
+# frozen_string_literal: true
+
+Gem::Specification.new do |spec|
+  spec.name = "demo"
+  spec.version = "1.0"
+  spec.author = "Somebody"
+  spec.summary = "A demo gem"
+  spec.license = "MIT"
+  spec.homepage = "https://example.org"
+end
--- ruby2.7-2.7.6.orig/spec/bundler/realworld/gemfile_source_header_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/realworld/gemfile_source_header_spec.rb
@@ -30,7 +30,7 @@ RSpec.describe "fetching dependencies wi
     expect(the_bundle).to include_gems "weakling 0.0.3"
   end
 
-private
+  private
 
   def setup_server
     require_rack
--- ruby2.7-2.7.6.orig/spec/bundler/realworld/mirror_probe_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/realworld/mirror_probe_spec.rb
@@ -71,30 +71,15 @@ RSpec.describe "fetching dependencies wi
         gem 'weakling'
       G
 
-      bundle :install, :artifice => nil
+      bundle :install, :artifice => nil, :raise_on_error => false
 
       expect(out).to include("Fetching source index from #{mirror}")
-      expect(err).to include("Retrying fetcher due to error (2/4): Bundler::HTTPError Could not fetch specs from #{mirror}")
-      expect(err).to include("Retrying fetcher due to error (3/4): Bundler::HTTPError Could not fetch specs from #{mirror}")
-      expect(err).to include("Retrying fetcher due to error (4/4): Bundler::HTTPError Could not fetch specs from #{mirror}")
-      expect(err).to include("Could not fetch specs from #{mirror}")
-    end
-
-    it "prints each error and warning on a new line" do
-      gemfile <<-G
-        source "#{original}"
-        gem 'weakling'
-      G
 
-      bundle :install, :artifice => nil
-
-      expect(out).to include "Fetching source index from #{mirror}/"
-      expect(err).to include <<-EOS.strip
-Retrying fetcher due to error (2/4): Bundler::HTTPError Could not fetch specs from #{mirror}/
-Retrying fetcher due to error (3/4): Bundler::HTTPError Could not fetch specs from #{mirror}/
-Retrying fetcher due to error (4/4): Bundler::HTTPError Could not fetch specs from #{mirror}/
-Could not fetch specs from #{mirror}/
-      EOS
+      err_lines = err.split("\n")
+      expect(err_lines).to include(%r{\ARetrying fetcher due to error \(2/4\): Bundler::HTTPError Could not fetch specs from #{mirror}/ due to underlying error <})
+      expect(err_lines).to include(%r{\ARetrying fetcher due to error \(3/4\): Bundler::HTTPError Could not fetch specs from #{mirror}/ due to underlying error <})
+      expect(err_lines).to include(%r{\ARetrying fetcher due to error \(4/4\): Bundler::HTTPError Could not fetch specs from #{mirror}/ due to underlying error <})
+      expect(err_lines).to include(%r{\ACould not fetch specs from #{mirror}/ due to underlying error <})
     end
   end
 
@@ -109,13 +94,15 @@ Could not fetch specs from #{mirror}/
         gem 'weakling'
       G
 
-      bundle :install, :artifice => nil
+      bundle :install, :artifice => nil, :raise_on_error => false
 
       expect(out).to include("Fetching source index from #{mirror}")
-      expect(err).to include("Retrying fetcher due to error (2/4): Bundler::HTTPError Could not fetch specs from #{mirror}")
-      expect(err).to include("Retrying fetcher due to error (3/4): Bundler::HTTPError Could not fetch specs from #{mirror}")
-      expect(err).to include("Retrying fetcher due to error (4/4): Bundler::HTTPError Could not fetch specs from #{mirror}")
-      expect(err).to include("Could not fetch specs from #{mirror}")
+
+      err_lines = err.split("\n")
+      expect(err_lines).to include(%r{\ARetrying fetcher due to error \(2/4\): Bundler::HTTPError Could not fetch specs from #{mirror}/ due to underlying error <})
+      expect(err_lines).to include(%r{\ARetrying fetcher due to error \(3/4\): Bundler::HTTPError Could not fetch specs from #{mirror}/ due to underlying error <})
+      expect(err_lines).to include(%r{\ARetrying fetcher due to error \(4/4\): Bundler::HTTPError Could not fetch specs from #{mirror}/ due to underlying error <})
+      expect(err_lines).to include(%r{\ACould not fetch specs from #{mirror}/ due to underlying error <})
     end
   end
 
@@ -138,7 +125,7 @@ Could not fetch specs from #{mirror}/
   end
 
   def setup_mirror
-    mirror_port = find_unused_port
-    @mirror_uri = "http://#{host}:#{mirror_port}"
+    @mirror_port = find_unused_port
+    @mirror_uri = "http://#{host}:#{@mirror_port}"
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/realworld/parallel_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/realworld/parallel_spec.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
 
-RSpec.describe "parallel", :realworld => true, :sometimes => true do
+RSpec.describe "parallel", :realworld => true do
   it "installs" do
     gemfile <<-G
       source "https://rubygems.org"
@@ -46,14 +46,14 @@ RSpec.describe "parallel", :realworld =>
   end
 
   it "works with --standalone" do
-    gemfile <<-G, :standalone => true
+    gemfile <<-G
       source "https://rubygems.org"
       gem "diff-lcs"
     G
 
     bundle :install, :standalone => true, :jobs => 4
 
-    ruby <<-RUBY, :no_lib => true
+    ruby <<-RUBY
       $:.unshift File.expand_path("bundle")
       require "bundler/setup"
 
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/realworld/slow_perf_spec.rb
@@ -0,0 +1,22 @@
+# frozen_string_literal: true
+
+require "spec_helper"
+
+RSpec.describe "bundle install with complex dependencies", :realworld => true do
+  it "resolves quickly" do
+    gemfile <<-G
+      source 'https://rubygems.org'
+
+      gem "actionmailer"
+      gem "mongoid", ">= 0.10.2"
+    G
+
+    start_time = Time.now
+
+    bundle "lock"
+
+    duration = Time.now - start_time
+
+    expect(duration.to_f).to be < 18 # seconds
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/resolver/basic_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/resolver/basic_spec.rb
@@ -176,7 +176,7 @@ Bundler could not find compatible versio
 
     deps = []
     @deps.each do |d|
-      deps << Bundler::DepProxy.new(d, "ruby")
+      deps << Bundler::DepProxy.get_proxy(d, "ruby")
     end
 
     should_resolve_and_include %w[foo-1.0.0 bar-1.0.0], [[]]
--- ruby2.7-2.7.6.orig/spec/bundler/resolver/platform_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/resolver/platform_spec.rb
@@ -28,10 +28,343 @@ RSpec.describe "Resolving platform crazi
     end
   end
 
+  it "resolves multiplatform gems with redundant platforms correctly" do
+    @index = build_index do
+      gem "zookeeper", "1.4.11"
+      gem "zookeeper", "1.4.11", "java" do
+        dep "slyphon-log4j", "= 1.2.15"
+        dep "slyphon-zookeeper_jar", "= 3.3.5"
+      end
+      gem "slyphon-log4j", "1.2.15"
+      gem "slyphon-zookeeper_jar", "3.3.5", "java"
+    end
+
+    dep "zookeeper"
+    platforms "java", "ruby", "universal-java-11"
+
+    should_resolve_as %w[zookeeper-1.4.11 zookeeper-1.4.11-java slyphon-log4j-1.2.15 slyphon-zookeeper_jar-3.3.5-java]
+  end
+
+  it "takes the latest ruby gem, even if an older platform specific version is available" do
+    @index = build_index do
+      gem "foo", "1.0.0"
+      gem "foo", "1.0.0", "x64-mingw32"
+      gem "foo", "1.1.0"
+    end
+    dep "foo"
+    platforms "x64-mingw32"
+
+    should_resolve_as %w[foo-1.1.0]
+  end
+
+  it "takes the ruby version if the platform version is incompatible" do
+    @index = build_index do
+      gem "bar", "1.0.0"
+      gem "foo", "1.0.0"
+      gem "foo", "1.0.0", "x64-mingw32" do
+        dep "bar", "< 1"
+      end
+    end
+    dep "foo"
+    platforms "x64-mingw32"
+
+    should_resolve_as %w[foo-1.0.0]
+  end
+
+  it "prefers the platform specific gem to the ruby version" do
+    @index = build_index do
+      gem "foo", "1.0.0"
+      gem "foo", "1.0.0", "x64-mingw32"
+    end
+    dep "foo"
+    platforms "x64-mingw32"
+
+    should_resolve_as %w[foo-1.0.0-x64-mingw32]
+  end
+
+  describe "on a linux platform", :rubygems => ">= 3.1.0.pre.1" do
+    # Ruby's platform is *-linux => platform's libc is glibc, so not musl
+    # Ruby's platform is *-linux-musl => platform's libc is musl, so not glibc
+    # Gem's platform is *-linux => gem is glibc + maybe musl compatible
+    # Gem's platform is *-linux-musl => gem is musl compatible but not glibc
+
+    it "favors the platform version-specific gem on a version-specifying linux platform" do
+      @index = build_index do
+        gem "foo", "1.0.0"
+        gem "foo", "1.0.0", "x86_64-linux"
+        gem "foo", "1.0.0", "x86_64-linux-musl"
+      end
+      dep "foo"
+      platforms "x86_64-linux-musl"
+
+      should_resolve_as %w[foo-1.0.0-x86_64-linux-musl]
+    end
+
+    it "favors the version-less gem over the version-specific gem on a gnu linux platform" do
+      @index = build_index do
+        gem "foo", "1.0.0"
+        gem "foo", "1.0.0", "x86_64-linux"
+        gem "foo", "1.0.0", "x86_64-linux-musl"
+      end
+      dep "foo"
+      platforms "x86_64-linux"
+
+      should_resolve_as %w[foo-1.0.0-x86_64-linux]
+    end
+
+    it "ignores the platform version-specific gem on a gnu linux platform" do
+      @index = build_index do
+        gem "foo", "1.0.0", "x86_64-linux-musl"
+      end
+      dep "foo"
+      platforms "x86_64-linux"
+
+      should_not_resolve
+    end
+
+    it "falls back to the platform version-less gem on a linux platform with a version" do
+      @index = build_index do
+        gem "foo", "1.0.0"
+        gem "foo", "1.0.0", "x86_64-linux"
+      end
+      dep "foo"
+      platforms "x86_64-linux-musl"
+
+      should_resolve_as %w[foo-1.0.0-x86_64-linux]
+    end
+
+    it "falls back to the ruby platform gem on a gnu linux platform when only a version-specifying gem is available" do
+      @index = build_index do
+        gem "foo", "1.0.0"
+        gem "foo", "1.0.0", "x86_64-linux-musl"
+      end
+      dep "foo"
+      platforms "x86_64-linux"
+
+      should_resolve_as %w[foo-1.0.0]
+    end
+
+    it "falls back to the platform version-less gem on a version-specifying linux platform and no ruby platform gem is available" do
+      @index = build_index do
+        gem "foo", "1.0.0", "x86_64-linux"
+      end
+      dep "foo"
+      platforms "x86_64-linux-musl"
+
+      should_resolve_as %w[foo-1.0.0-x86_64-linux]
+    end
+  end
+
+  it "takes the latest ruby gem if the platform specific gem doesn't match the required_ruby_version" do
+    @index = build_index do
+      gem "foo", "1.0.0"
+      gem "foo", "1.0.0", "x64-mingw32"
+      gem "foo", "1.1.0"
+      gem "foo", "1.1.0", "x64-mingw32" do |s|
+        s.required_ruby_version = [">= 2.0", "< 2.4"]
+      end
+      gem "Ruby\0", "2.5.1"
+    end
+    dep "foo"
+    dep "Ruby\0", "2.5.1"
+    platforms "x64-mingw32"
+
+    should_resolve_as %w[foo-1.1.0]
+  end
+
+  it "takes the latest ruby gem with required_ruby_version if the platform specific gem doesn't match the required_ruby_version" do
+    @index = build_index do
+      gem "foo", "1.0.0"
+      gem "foo", "1.0.0", "x64-mingw32"
+      gem "foo", "1.1.0" do |s|
+        s.required_ruby_version = [">= 2.0"]
+      end
+      gem "foo", "1.1.0", "x64-mingw32" do |s|
+        s.required_ruby_version = [">= 2.0", "< 2.4"]
+      end
+      gem "Ruby\0", "2.5.1"
+    end
+    dep "foo"
+    dep "Ruby\0", "2.5.1"
+    platforms "x64-mingw32"
+
+    should_resolve_as %w[foo-1.1.0]
+  end
+
+  it "takes the latest ruby gem if the platform specific gem doesn't match the required_ruby_version with multiple platforms" do
+    @index = build_index do
+      gem "foo", "1.0.0"
+      gem "foo", "1.0.0", "x64-mingw32"
+      gem "foo", "1.1.0" do |s|
+        s.required_ruby_version = [">= 2.0"]
+      end
+      gem "foo", "1.1.0", "x64-mingw32" do |s|
+        s.required_ruby_version = [">= 2.0", "< 2.4"]
+      end
+      gem "Ruby\0", "2.5.1"
+    end
+    dep "foo"
+    dep "Ruby\0", "2.5.1"
+    platforms "x86_64-linux", "x64-mingw32"
+
+    should_resolve_as %w[foo-1.1.0]
+  end
+
+  it "doesn't include gems not needed for none of the platforms" do
+    @index = build_index do
+      gem "empyrean", "0.1.0"
+      gem "coderay", "1.1.2"
+      gem "method_source", "0.9.0"
+
+      gem "spoon", "0.0.6" do
+        dep "ffi", ">= 0"
+      end
+
+      gem "pry", "0.11.3", "java" do
+        dep "coderay", "~> 1.1.0"
+        dep "method_source", "~> 0.9.0"
+        dep "spoon", "~> 0.0"
+      end
+
+      gem "pry", "0.11.3" do
+        dep "coderay", "~> 1.1.0"
+        dep "method_source", "~> 0.9.0"
+      end
+
+      gem "ffi", "1.9.23", "java"
+      gem "ffi", "1.9.23"
+    end
+
+    dep "empyrean", "0.1.0"
+    dep "pry"
+
+    platforms "ruby", "java"
+
+    should_resolve_as %w[coderay-1.1.2 empyrean-0.1.0 ffi-1.9.23-java method_source-0.9.0 pry-0.11.3 pry-0.11.3-java spoon-0.0.6]
+  end
+
+  it "includes gems needed for at least one platform" do
+    @index = build_index do
+      gem "empyrean", "0.1.0"
+      gem "coderay", "1.1.2"
+      gem "method_source", "0.9.0"
+
+      gem "spoon", "0.0.6" do
+        dep "ffi", ">= 0"
+      end
+
+      gem "pry", "0.11.3", "java" do
+        dep "coderay", "~> 1.1.0"
+        dep "method_source", "~> 0.9.0"
+        dep "spoon", "~> 0.0"
+      end
+
+      gem "pry", "0.11.3" do
+        dep "coderay", "~> 1.1.0"
+        dep "method_source", "~> 0.9.0"
+      end
+
+      gem "ffi", "1.9.23", "java"
+      gem "ffi", "1.9.23"
+
+      gem "extra", "1.0.0" do
+        dep "ffi", ">= 0"
+      end
+    end
+
+    dep "empyrean", "0.1.0"
+    dep "pry"
+    dep "extra"
+
+    platforms "ruby", "java"
+
+    should_resolve_as %w[coderay-1.1.2 empyrean-0.1.0 extra-1.0.0 ffi-1.9.23 ffi-1.9.23-java method_source-0.9.0 pry-0.11.3 pry-0.11.3-java spoon-0.0.6]
+  end
+
+  it "includes gems needed for at least one platform even when the platform specific requirement is processed earlier than the generic requirement" do
+    @index = build_index do
+      gem "empyrean", "0.1.0"
+      gem "coderay", "1.1.2"
+      gem "method_source", "0.9.0"
+
+      gem "spoon", "0.0.6" do
+        dep "ffi", ">= 0"
+      end
+
+      gem "pry", "0.11.3", "java" do
+        dep "coderay", "~> 1.1.0"
+        dep "method_source", "~> 0.9.0"
+        dep "spoon", "~> 0.0"
+      end
+
+      gem "pry", "0.11.3" do
+        dep "coderay", "~> 1.1.0"
+        dep "method_source", "~> 0.9.0"
+      end
+
+      gem "ffi", "1.9.23", "java"
+      gem "ffi", "1.9.23"
+
+      gem "extra", "1.0.0" do
+        dep "extra2", ">= 0"
+      end
+
+      gem "extra2", "1.0.0" do
+        dep "extra3", ">= 0"
+      end
+
+      gem "extra3", "1.0.0" do
+        dep "ffi", ">= 0"
+      end
+    end
+
+    dep "empyrean", "0.1.0"
+    dep "pry"
+    dep "extra"
+
+    platforms "ruby", "java"
+
+    should_resolve_as %w[coderay-1.1.2 empyrean-0.1.0 extra-1.0.0 extra2-1.0.0 extra3-1.0.0 ffi-1.9.23 ffi-1.9.23-java method_source-0.9.0 pry-0.11.3 pry-0.11.3-java spoon-0.0.6]
+  end
+
+  it "properly adds platforms when platform requirements come from different dependencies" do
+    @index = build_index do
+      gem "ffi", "1.9.14"
+      gem "ffi", "1.9.14", "universal-mingw32"
+
+      gem "gssapi", "0.1"
+      gem "gssapi", "0.2"
+      gem "gssapi", "0.3"
+      gem "gssapi", "1.2.0" do
+        dep "ffi", ">= 1.0.1"
+      end
+
+      gem "mixlib-shellout", "2.2.6"
+      gem "mixlib-shellout", "2.2.6", "universal-mingw32" do
+        dep "win32-process", "~> 0.8.2"
+      end
+
+      # we need all these versions to get the sorting the same as it would be
+      # pulling from rubygems.org
+      %w[0.8.3 0.8.2 0.8.1 0.8.0].each do |v|
+        gem "win32-process", v do
+          dep "ffi", ">= 1.0.0"
+        end
+      end
+    end
+
+    dep "mixlib-shellout"
+    dep "gssapi"
+
+    platforms "universal-mingw32", "ruby"
+
+    should_resolve_as %w[ffi-1.9.14 ffi-1.9.14-universal-mingw32 gssapi-1.2.0 mixlib-shellout-2.2.6 mixlib-shellout-2.2.6-universal-mingw32 win32-process-0.8.3]
+  end
+
   describe "with mingw32" do
     before :each do
       @index = build_index do
-        platforms "mingw32 mswin32 x64-mingw32" do |platform|
+        platforms "mingw32 mswin32 x64-mingw32 x64-mingw-ucrt" do |platform|
           gem "thin", "1.2.7", platform
         end
         gem "win32-api", "1.5.1", "universal-mingw32"
@@ -52,7 +385,7 @@ RSpec.describe "Resolving platform crazi
       should_resolve_as %w[thin-1.2.7-mingw32]
     end
 
-    it "finds x64-mingw gems" do
+    it "finds x64-mingw32 gems" do
       platforms "x64-mingw32"
       dep "thin"
       should_resolve_as %w[thin-1.2.7-x64-mingw32]
@@ -69,6 +402,22 @@ RSpec.describe "Resolving platform crazi
       dep "win32-api"
       should_resolve_as %w[win32-api-1.5.1-universal-mingw32]
     end
+
+    if Gem.rubygems_version >= Gem::Version.new("3.2.28")
+      it "finds x64-mingw-ucrt gems" do
+        platforms "x64-mingw-ucrt"
+        dep "thin"
+        should_resolve_as %w[thin-1.2.7-x64-mingw-ucrt]
+      end
+    end
+
+    if Gem.rubygems_version >= Gem::Version.new("3.3.18")
+      it "finds universal-mingw gems on x64-mingw-ucrt" do
+        platform "x64-mingw-ucrt"
+        dep "win32-api"
+        should_resolve_as %w[win32-api-1.5.1-universal-mingw32]
+      end
+    end
   end
 
   describe "with conflicting cases" do
@@ -90,11 +439,11 @@ RSpec.describe "Resolving platform crazi
       end
     end
 
-    it "reports on the conflict" do
+    it "takes the ruby version as fallback" do
       platforms "ruby", "java"
       dep "foo"
 
-      should_conflict_on "baz"
+      should_resolve_as %w[bar-1.0.0 baz-1.0.0 foo-1.0.0]
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/runtime/executable_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/runtime/executable_spec.rb
@@ -2,14 +2,14 @@
 
 RSpec.describe "Running bin/* commands" do
   before :each do
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
   end
 
   it "runs the bundled command when in the bundle" do
-    bundle! "binstubs rack"
+    bundle "binstubs rack"
 
     build_gem "rack", "2.0", :to_system => true do |s|
       s.executables = "rackup"
@@ -20,7 +20,7 @@ RSpec.describe "Running bin/* commands" 
   end
 
   it "allows the location of the gem stubs to be specified" do
-    bundle! "binstubs rack", :path => "gbin"
+    bundle "binstubs rack", :path => "gbin"
 
     expect(bundled_app("bin")).not_to exist
     expect(bundled_app("gbin/rackup")).to exist
@@ -30,33 +30,31 @@ RSpec.describe "Running bin/* commands" 
   end
 
   it "allows absolute paths as a specification of where to install bin stubs" do
-    bundle! "binstubs rack", :path => tmp("bin")
+    bundle "binstubs rack", :path => tmp("bin")
 
     gembin tmp("bin/rackup")
     expect(out).to eq("1.0.0")
   end
 
   it "uses the default ruby install name when shebang is not specified" do
-    bundle! "binstubs rack"
-    expect(File.open("bin/rackup").gets).to eq("#!/usr/bin/env #{RbConfig::CONFIG["ruby_install_name"]}\n")
+    bundle "binstubs rack"
+    expect(File.readlines(bundled_app("bin/rackup")).first).to eq("#!/usr/bin/env #{RbConfig::CONFIG["ruby_install_name"]}\n")
   end
 
   it "allows the name of the shebang executable to be specified" do
-    bundle! "binstubs rack", :shebang => "ruby-foo"
-    expect(File.open("bin/rackup").gets).to eq("#!/usr/bin/env ruby-foo\n")
+    bundle "binstubs rack", :shebang => "ruby-foo"
+    expect(File.readlines(bundled_app("bin/rackup")).first).to eq("#!/usr/bin/env ruby-foo\n")
   end
 
   it "runs the bundled command when out of the bundle" do
-    bundle! "binstubs rack"
+    bundle "binstubs rack"
 
     build_gem "rack", "2.0", :to_system => true do |s|
       s.executables = "rackup"
     end
 
-    Dir.chdir(tmp) do
-      gembin "rackup"
-      expect(out).to eq("1.0.0")
-    end
+    gembin "rackup", :dir => tmp
+    expect(out).to eq("1.0.0")
   end
 
   it "works with gems in path" do
@@ -65,10 +63,11 @@ RSpec.describe "Running bin/* commands" 
     end
 
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "rack", :path => "#{lib_path("rack")}"
     G
 
-    bundle! "binstubs rack"
+    bundle "binstubs rack"
 
     build_gem "rack", "2.0", :to_system => true do |s|
       s.executables = "rackup"
@@ -79,34 +78,32 @@ RSpec.describe "Running bin/* commands" 
   end
 
   it "creates a bundle binstub" do
-    build_gem "bundler", Bundler::VERSION, :to_system => true do |s|
-      s.executables = "bundle"
-    end
-
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "bundler"
     G
 
-    bundle! "binstubs bundler"
+    bundle "binstubs bundler"
 
     expect(bundled_app("bin/bundle")).to exist
   end
 
   it "does not generate bin stubs if the option was not specified" do
-    bundle! "install"
+    bundle "install"
 
     expect(bundled_app("bin/rackup")).not_to exist
   end
 
   it "allows you to stop installing binstubs", :bundler => "< 3" do
-    bundle! "install --binstubs bin/"
+    skip "delete permission error" if Gem.win_platform?
+
+    bundle "install --binstubs bin/"
     bundled_app("bin/rackup").rmtree
-    bundle! "install --binstubs \"\""
+    bundle "install --binstubs \"\""
 
     expect(bundled_app("bin/rackup")).not_to exist
 
-    bundle! "config bin"
+    bundle "config bin"
     expect(out).to include("You have not configured a value for `bin`")
   end
 
@@ -116,7 +113,7 @@ RSpec.describe "Running bin/* commands" 
       gem "activesupport"
     G
 
-    bundle! :install, :binstubs => "bin"
+    bundle :install, :binstubs => "bin"
 
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
@@ -130,21 +127,21 @@ RSpec.describe "Running bin/* commands" 
   end
 
   it "rewrites bins on binstubs (to maintain backwards compatibility)" do
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
 
     create_file("bin/rackup", "OMG")
 
-    bundle! "binstubs rack"
+    bundle "binstubs rack"
 
     expect(bundled_app("bin/rackup").read).to_not eq("OMG")
   end
 
   it "use BUNDLE_GEMFILE gemfile for binstub" do
     # context with bin/bundler w/ default Gemfile
-    bundle! "binstubs bundler"
+    bundle "binstubs bundler"
 
     # generate other Gemfile with executable gem
     build_repo2 do
@@ -159,7 +156,7 @@ RSpec.describe "Running bin/* commands" 
     # generate binstub for executable from non default Gemfile (other then bin/bundler version)
     ENV["BUNDLE_GEMFILE"] = "OtherGemfile"
     bundle "install"
-    bundle! "binstubs bindir"
+    bundle "binstubs bindir"
 
     # remove user settings
     ENV["BUNDLE_GEMFILE"] = nil
@@ -167,7 +164,6 @@ RSpec.describe "Running bin/* commands" 
     # run binstub for non default Gemfile
     gembin "foo"
 
-    expect(exitstatus).to eq(0) if exitstatus
     expect(out).to eq("1.0")
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/runtime/gem_tasks_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/runtime/gem_tasks_spec.rb
@@ -15,12 +15,11 @@ RSpec.describe "require 'bundler/gem_tas
 
     bundled_app("Rakefile").open("w") do |f|
       f.write <<-RAKEFILE
-        $:.unshift("#{lib_dir}")
         require "bundler/gem_tasks"
       RAKEFILE
     end
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
 
       gem "rake"
@@ -28,8 +27,8 @@ RSpec.describe "require 'bundler/gem_tas
   end
 
   it "includes the relevant tasks" do
-    with_gem_path_as(Spec::Path.base_system_gems.to_s) do
-      sys_exec "#{rake} -T", "RUBYOPT" => "-I#{lib_dir}"
+    with_gem_path_as(base_system_gem_path.to_s) do
+      sys_exec "#{rake} -T", :env => { "GEM_HOME" => system_gem_path.to_s }
     end
 
     expect(err).to be_empty
@@ -42,38 +41,65 @@ RSpec.describe "require 'bundler/gem_tas
     ]
     tasks = out.lines.to_a.map {|s| s.split("#").first.strip }
     expect(tasks & expected_tasks).to eq(expected_tasks)
-    expect(exitstatus).to eq(0) if exitstatus
   end
 
-  it "defines a working `rake install` task" do
-    with_gem_path_as(Spec::Path.base_system_gems.to_s) do
-      sys_exec "#{rake} install", "RUBYOPT" => "-I#{lib_dir}"
+  it "defines a working `rake install` task", :ruby_repo do
+    with_gem_path_as(base_system_gem_path.to_s) do
+      sys_exec "#{rake} install", :env => { "GEM_HOME" => system_gem_path.to_s }
     end
 
     expect(err).to be_empty
 
-    bundle! "exec rake install"
+    bundle "exec rake install"
 
     expect(err).to be_empty
   end
 
-  context "rake build when path has spaces" do
+  context "rake build when path has spaces", :ruby_repo do
     before do
       spaced_bundled_app = tmp.join("bundled app")
-      FileUtils.mv bundled_app, spaced_bundled_app
-      Dir.chdir(spaced_bundled_app)
+      FileUtils.cp_r bundled_app, spaced_bundled_app
+      bundle "exec rake build", :dir => spaced_bundled_app
     end
 
     it "still runs successfully" do
-      bundle! "exec rake build"
+      expect(err).to be_empty
+    end
+  end
+
+  context "rake build when path has brackets", :ruby_repo do
+    before do
+      bracketed_bundled_app = tmp.join("bundled[app")
+      FileUtils.cp_r bundled_app, bracketed_bundled_app
+      bundle "exec rake build", :dir => bracketed_bundled_app
+    end
+
+    it "still runs successfully" do
+      expect(err).to be_empty
+    end
+  end
+
+  context "bundle path configured locally" do
+    before do
+      bundle "config set path vendor/bundle"
+    end
+
+    it "works", :ruby_repo do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+
+        gem "rake"
+      G
+
+      bundle "exec rake -T"
 
       expect(err).to be_empty
     end
   end
 
   it "adds 'pkg' to rake/clean's CLOBBER" do
-    with_gem_path_as(Spec::Path.base_system_gems.to_s) do
-      sys_exec! %(#{rake} -e 'load "Rakefile"; puts CLOBBER.inspect')
+    with_gem_path_as(base_system_gem_path.to_s) do
+      sys_exec %(#{rake} -e 'load "Rakefile"; puts CLOBBER.inspect'), :env => { "GEM_HOME" => system_gem_path.to_s }
     end
     expect(out).to eq '["pkg"]'
   end
--- ruby2.7-2.7.6.orig/spec/bundler/runtime/inline_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/runtime/inline_spec.rb
@@ -2,7 +2,7 @@
 
 RSpec.describe "bundler/inline#gemfile" do
   def script(code, options = {})
-    requires = ["#{lib_dir}/bundler/inline"]
+    requires = ["#{entrypoint}/inline"]
     requires.unshift "#{spec_dir}/support/artifice/" + options.delete(:artifice) if options.key?(:artifice)
     requires = requires.map {|r| "require '#{r}'" }.join("\n")
     ruby("#{requires}\n\n" + code, options)
@@ -48,6 +48,7 @@ RSpec.describe "bundler/inline#gemfile" 
   it "requires the gems" do
     script <<-RUBY
       gemfile do
+        source "#{file_uri_for(gem_repo1)}"
         path "#{lib_path}" do
           gem "two"
         end
@@ -55,10 +56,10 @@ RSpec.describe "bundler/inline#gemfile" 
     RUBY
 
     expect(out).to eq("two")
-    expect(exitstatus).to be_zero if exitstatus
 
-    script <<-RUBY
+    script <<-RUBY, :raise_on_error => false
       gemfile do
+        source "#{file_uri_for(gem_repo1)}"
         path "#{lib_path}" do
           gem "eleven"
         end
@@ -78,7 +79,6 @@ RSpec.describe "bundler/inline#gemfile" 
     RUBY
 
     expect(out).to include("Rack's post install message")
-    expect(exitstatus).to be_zero if exitstatus
 
     script <<-RUBY, :artifice => "endpoint"
       gemfile(true) do
@@ -89,14 +89,13 @@ RSpec.describe "bundler/inline#gemfile" 
 
     expect(out).to include("Installing activesupport")
     err_lines = err.split("\n")
-    err_lines.reject!{|line| line =~ /\.rb:\d+: warning: / } unless RUBY_VERSION < "2.7"
+    err_lines.reject! {|line| line =~ /\.rb:\d+: warning: / } unless RUBY_VERSION < "2.7"
     expect(err_lines).to be_empty
-    expect(exitstatus).to be_zero if exitstatus
   end
 
   it "lets me use my own ui object" do
     script <<-RUBY, :artifice => "endpoint"
-      require '#{lib_dir}/bundler'
+      require '#{entrypoint}'
       class MyBundlerUI < Bundler::UI::Silent
         def confirm(msg, newline = nil)
           puts "CONFIRMED!"
@@ -109,12 +108,11 @@ RSpec.describe "bundler/inline#gemfile" 
     RUBY
 
     expect(out).to eq("CONFIRMED!\nCONFIRMED!")
-    expect(exitstatus).to be_zero if exitstatus
   end
 
   it "has an option for quiet installation" do
     script <<-RUBY, :artifice => "endpoint"
-      require '#{lib_dir}/bundler/inline'
+      require '#{entrypoint}/inline'
 
       gemfile(true, :quiet => true) do
         source "https://notaserver.com"
@@ -126,7 +124,7 @@ RSpec.describe "bundler/inline#gemfile" 
   end
 
   it "raises an exception if passed unknown arguments" do
-    script <<-RUBY
+    script <<-RUBY, :raise_on_error => false
       gemfile(true, :arglebargle => true) do
         path "#{lib_path}"
         gem "two"
@@ -140,9 +138,10 @@ RSpec.describe "bundler/inline#gemfile" 
 
   it "does not mutate the option argument" do
     script <<-RUBY
-      require '#{lib_dir}/bundler'
+      require '#{entrypoint}'
       options = { :ui => Bundler::UI::Shell.new }
       gemfile(false, options) do
+        source "#{file_uri_for(gem_repo1)}"
         path "#{lib_path}" do
           gem "two"
         end
@@ -151,7 +150,6 @@ RSpec.describe "bundler/inline#gemfile" 
     RUBY
 
     expect(out).to match("OKAY")
-    expect(exitstatus).to be_zero if exitstatus
   end
 
   it "installs quietly if necessary when the install option is not set" do
@@ -166,7 +164,6 @@ RSpec.describe "bundler/inline#gemfile" 
 
     expect(out).to eq("1.0.0")
     expect(err).to be_empty
-    expect(exitstatus).to be_zero if exitstatus
   end
 
   it "installs quietly from git if necessary when the install option is not set" do
@@ -174,6 +171,7 @@ RSpec.describe "bundler/inline#gemfile" 
     baz_ref = build_git("baz", "2.0.0").ref_for("HEAD")
     script <<-RUBY
       gemfile do
+        source "#{file_uri_for(gem_repo1)}"
         gem "foo", :git => #{lib_path("foo-1.0.0").to_s.dump}
         gem "baz", :git => #{lib_path("baz-2.0.0").to_s.dump}, :ref => #{baz_ref.dump}
       end
@@ -184,19 +182,20 @@ RSpec.describe "bundler/inline#gemfile" 
 
     expect(out).to eq("1.0.0\n2.0.0")
     expect(err).to be_empty
-    expect(exitstatus).to be_zero if exitstatus
   end
 
   it "allows calling gemfile twice" do
     script <<-RUBY
       gemfile do
         path "#{lib_path}" do
+          source "#{file_uri_for(gem_repo1)}"
           gem "two"
         end
       end
 
       gemfile do
         path "#{lib_path}" do
+          source "#{file_uri_for(gem_repo1)}"
           gem "four"
         end
       end
@@ -204,7 +203,6 @@ RSpec.describe "bundler/inline#gemfile" 
 
     expect(out).to eq("two\nfour")
     expect(err).to be_empty
-    expect(exitstatus).to be_zero if exitstatus
   end
 
   it "installs inline gems when a Gemfile.lock is present" do
@@ -226,22 +224,53 @@ RSpec.describe "bundler/inline#gemfile" 
         rake
 
       BUNDLED WITH
-         1.13.6
+         #{Bundler::VERSION}
     G
 
-    in_app_root do
-      script <<-RUBY
-        gemfile do
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rack"
-        end
+    script <<-RUBY
+      gemfile do
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      end
 
-        puts RACK
-      RUBY
-    end
+      puts RACK
+    RUBY
+
+    expect(err).to be_empty
+  end
+
+  it "does not leak Gemfile.lock versions to the installation output" do
+    gemfile <<-G
+      source "https://notaserver.com"
+      gem "rake"
+    G
+
+    lockfile <<-G
+      GEM
+        remote: https://rubygems.org/
+        specs:
+          rake (11.3.0)
+
+      PLATFORMS
+        ruby
 
+      DEPENDENCIES
+        rake
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    G
+
+    script <<-RUBY
+      gemfile(true) do
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rake", "~> 13.0"
+      end
+    RUBY
+
+    expect(out).to include("Installing rake 13.0")
+    expect(out).not_to include("was 11.3.0")
     expect(err).to be_empty
-    expect(exitstatus).to be_zero if exitstatus
   end
 
   it "installs inline gems when frozen is set" do
@@ -255,25 +284,34 @@ RSpec.describe "bundler/inline#gemfile" 
     RUBY
 
     expect(last_command.stderr).to be_empty
-    expect(exitstatus).to be_zero if exitstatus
+  end
+
+  it "installs inline gems when deployment is set" do
+    script <<-RUBY, :env => { "BUNDLE_DEPLOYMENT" => "true" }
+      gemfile do
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      end
+
+      puts RACK
+    RUBY
+
+    expect(last_command.stderr).to be_empty
   end
 
   it "installs inline gems when BUNDLE_GEMFILE is set to an empty string" do
     ENV["BUNDLE_GEMFILE"] = ""
 
-    in_app_root do
-      script <<-RUBY
-        gemfile do
-          source "#{file_uri_for(gem_repo1)}"
-          gem "rack"
-        end
+    script <<-RUBY
+      gemfile do
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      end
 
-        puts RACK
-      RUBY
-    end
+      puts RACK
+    RUBY
 
     expect(err).to be_empty
-    expect(exitstatus).to be_zero if exitstatus
   end
 
   it "installs inline gems when BUNDLE_BIN is set" do
@@ -295,7 +333,7 @@ RSpec.describe "bundler/inline#gemfile" 
     it "installs inline gems to the system path regardless" do
       script <<-RUBY, :env => { "BUNDLE_PATH" => "./vendor/inline" }
         gemfile(true) do
-          source "file://#{gem_repo1}"
+          source "#{file_uri_for(gem_repo1)}"
           gem "rack"
         end
       RUBY
@@ -305,7 +343,7 @@ RSpec.describe "bundler/inline#gemfile" 
   end
 
   it "skips platform warnings" do
-    simulate_platform "ruby"
+    bundle "config set --local force_ruby_platform true"
 
     script <<-RUBY
       gemfile(true) do
@@ -317,6 +355,20 @@ RSpec.describe "bundler/inline#gemfile" 
     expect(err).to be_empty
   end
 
+  it "still installs if the application has `bundle package` no_install config set" do
+    bundle "config set --local no_install true"
+
+    script <<-RUBY
+      gemfile do
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      end
+    RUBY
+
+    expect(last_command).to be_success
+    expect(system_gem_path("gems/rack-1.0.0")).to exist
+  end
+
   it "preserves previous BUNDLE_GEMFILE value" do
     ENV["BUNDLE_GEMFILE"] = ""
     script <<-RUBY
@@ -350,4 +402,65 @@ RSpec.describe "bundler/inline#gemfile" 
     expect(last_command).to be_success
     expect(out).to include("BUNDLE_GEMFILE is empty")
   end
+
+  it "does not error out if library requires optional dependencies" do
+    Dir.mkdir tmp("path_without_gemfile")
+
+    foo_code = <<~RUBY
+      begin
+        gem "bar"
+      rescue LoadError
+      end
+
+      puts "WIN"
+    RUBY
+
+    build_lib "foo", "1.0.0" do |s|
+      s.write "lib/foo.rb", foo_code
+    end
+
+    script <<-RUBY, :dir => tmp("path_without_gemfile")
+      gemfile do
+        source "#{file_uri_for(gem_repo2)}"
+        path "#{lib_path}" do
+          gem "foo", require: false
+        end
+      end
+
+      require "foo"
+    RUBY
+
+    expect(out).to eq("WIN")
+    expect(err).to be_empty
+  end
+
+  it "when requiring fileutils after does not show redefinition warnings" do
+    dependency_installer_loads_fileutils = ruby "require 'rubygems/dependency_installer'; puts $LOADED_FEATURES.grep(/fileutils/)", :raise_on_error => false
+    skip "does not work if rubygems/dependency_installer loads fileutils, which happens until rubygems 3.2.0" unless dependency_installer_loads_fileutils.empty?
+
+    skip "pathname does not install cleanly on this ruby" if RUBY_VERSION < "2.7.0"
+
+    Dir.mkdir tmp("path_without_gemfile")
+
+    default_fileutils_version = ruby "gem 'fileutils', '< 999999'; require 'fileutils'; puts FileUtils::VERSION", :raise_on_error => false
+    skip "fileutils isn't a default gem" if default_fileutils_version.empty?
+
+    realworld_system_gems "fileutils --version 1.4.1"
+
+    realworld_system_gems "pathname --version 0.2.0"
+
+    realworld_system_gems "timeout uri" # this spec uses net/http which requires these default gems
+
+    script <<-RUBY, :dir => tmp("path_without_gemfile"), :env => { "BUNDLER_GEM_DEFAULT_DIR" => system_gem_path.to_s }
+      require "bundler/inline"
+
+      gemfile(true) do
+        source "#{file_uri_for(gem_repo2)}"
+      end
+
+      require "fileutils"
+    RUBY
+
+    expect(err).to eq("The Gemfile specifies no dependencies")
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/runtime/load_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/runtime/load_spec.rb
@@ -3,10 +3,11 @@
 RSpec.describe "Bundler.load" do
   describe "with a gemfile" do
     before(:each) do
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
+      allow(Bundler::SharedHelpers).to receive(:pwd).and_return(bundled_app)
     end
 
     it "provides a list of the env dependencies" do
@@ -31,7 +32,8 @@ RSpec.describe "Bundler.load" do
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
-      bundle! :install
+      bundle :install
+      allow(Bundler::SharedHelpers).to receive(:pwd).and_return(bundled_app)
     end
 
     it "provides a list of the env dependencies" do
@@ -73,14 +75,14 @@ RSpec.describe "Bundler.load" do
 
   describe "when called twice" do
     it "doesn't try to load the runtime twice" do
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
         gem "activesupport", :group => :test
       G
 
-      ruby! <<-RUBY
-        require "#{lib_dir}/bundler"
+      ruby <<-RUBY
+        require "#{entrypoint}"
         Bundler.setup :default
         Bundler.require :default
         puts RACK
@@ -97,11 +99,11 @@ RSpec.describe "Bundler.load" do
 
   describe "not hurting brittle rubygems" do
     it "does not inject #source into the generated YAML of the gem specs" do
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "activerecord"
       G
-
+      allow(Bundler::SharedHelpers).to receive(:find_gemfile).and_return(bundled_app_gemfile)
       Bundler.load.specs.each do |spec|
         expect(spec.to_yaml).not_to match(/^\s+source:/)
         expect(spec.to_yaml).not_to match(/^\s+groups:/)
--- ruby2.7-2.7.6.orig/spec/bundler/runtime/platform_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/runtime/platform_spec.rb
@@ -22,7 +22,7 @@ RSpec.describe "Bundler.setup with multi
 
     ruby <<-R
       begin
-        require 'bundler'
+        require '#{entrypoint}'
         Bundler.ui.silence { Bundler.setup }
       rescue Bundler::GemNotFound => e
         puts "WIN"
@@ -49,7 +49,7 @@ RSpec.describe "Bundler.setup with multi
     G
 
     simulate_platform "x86-darwin-10"
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "nokogiri"
     G
@@ -57,6 +57,126 @@ RSpec.describe "Bundler.setup with multi
     expect(the_bundle).to include_gems "nokogiri 1.4.2"
   end
 
+  it "will keep both platforms when both ruby and a specific ruby platform are locked and the bundle is unlocked" do
+    build_repo4 do
+      build_gem "nokogiri", "1.11.1" do |s|
+        s.add_dependency "mini_portile2", "~> 2.5.0"
+        s.add_dependency "racc", "~> 1.5.2"
+      end
+
+      build_gem "nokogiri", "1.11.1" do |s|
+        s.platform = Bundler.local_platform
+        s.add_dependency "racc", "~> 1.4"
+      end
+
+      build_gem "mini_portile2", "2.5.0"
+      build_gem "racc", "1.5.2"
+    end
+
+    good_lockfile = <<~L
+      GEM
+        remote: #{file_uri_for(gem_repo4)}/
+        specs:
+          mini_portile2 (2.5.0)
+          nokogiri (1.11.1)
+            mini_portile2 (~> 2.5.0)
+            racc (~> 1.5.2)
+          nokogiri (1.11.1-#{Bundler.local_platform})
+            racc (~> 1.4)
+          racc (1.5.2)
+
+      PLATFORMS
+        #{lockfile_platforms_for(["ruby", specific_local_platform])}
+
+      DEPENDENCIES
+        nokogiri (~> 1.11)
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo4)}"
+      gem "nokogiri", "~> 1.11"
+    G
+
+    lockfile good_lockfile
+
+    bundle "update nokogiri"
+
+    expect(lockfile).to eq(good_lockfile)
+  end
+
+  it "will not try to install platform specific gems when they don't match the current ruby if locked only to ruby" do
+    build_repo4 do
+      build_gem "nokogiri", "1.11.1"
+
+      build_gem "nokogiri", "1.11.1" do |s|
+        s.platform = Bundler.local_platform
+        s.required_ruby_version = "< #{Gem.ruby_version}"
+      end
+    end
+
+    gemfile <<-G
+      source "https://gems.repo4"
+      gem "nokogiri"
+    G
+
+    lockfile <<~L
+      GEM
+        remote: https://gems.repo4/
+        specs:
+          nokogiri (1.11.1)
+
+      PLATFORMS
+        ruby
+
+      DEPENDENCIES
+        nokogiri
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    bundle "install", :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }
+
+    expect(out).to include("Fetching nokogiri 1.11.1")
+    expect(the_bundle).to include_gems "nokogiri 1.11.1"
+    expect(the_bundle).not_to include_gems "nokogiri 1.11.1 #{Bundler.local_platform}"
+  end
+
+  it "will use the java platform if both generic java and generic ruby platforms are locked", :jruby_only do
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "nokogiri"
+    G
+
+    lockfile <<-G
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
+          nokogiri (1.4.2)
+          nokogiri (1.4.2-java)
+            weakling (>= 0.0.3)
+          weakling (0.0.3)
+
+      PLATFORMS
+        java
+        ruby
+
+      DEPENDENCIES
+        nokogiri
+
+      BUNDLED WITH
+        #{Bundler::VERSION}
+    G
+
+    bundle "install"
+
+    expect(out).to include("Fetching nokogiri 1.4.2 (java)")
+    expect(the_bundle).to include_gems "nokogiri 1.4.2 JAVA"
+  end
+
   it "will add the resolve for the current platform" do
     lockfile <<-G
       GEM
@@ -75,7 +195,7 @@ RSpec.describe "Bundler.setup with multi
 
     simulate_platform "x86-darwin-100"
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "nokogiri"
       gem "platform_specific"
@@ -84,40 +204,182 @@ RSpec.describe "Bundler.setup with multi
     expect(the_bundle).to include_gems "nokogiri 1.4.2", "platform_specific 1.0 x86-darwin-100"
   end
 
+  it "allows specifying only-ruby-platform on jruby", :jruby_only do
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "nokogiri"
+      gem "platform_specific"
+    G
+
+    bundle "config set force_ruby_platform true"
+
+    bundle "install"
+
+    expect(the_bundle).to include_gems "nokogiri 1.4.2", "platform_specific 1.0 RUBY"
+  end
+
   it "allows specifying only-ruby-platform" do
-    simulate_platform "java"
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "nokogiri"
+      gem "platform_specific"
+    G
 
-    install_gemfile! <<-G
+    bundle "config set force_ruby_platform true"
+
+    bundle "install"
+
+    expect(the_bundle).to include_gems "nokogiri 1.4.2", "platform_specific 1.0 RUBY"
+  end
+
+  it "allows specifying only-ruby-platform even if the lockfile is locked to a specific compatible platform" do
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "nokogiri"
       gem "platform_specific"
     G
 
-    bundle! "config set force_ruby_platform true"
+    bundle "config set force_ruby_platform true"
 
-    bundle! "install"
+    bundle "install"
 
     expect(the_bundle).to include_gems "nokogiri 1.4.2", "platform_specific 1.0 RUBY"
   end
 
+  it "doesn't pull platform specific gems on truffleruby", :truffleruby_only do
+    install_gemfile <<-G
+     source "#{file_uri_for(gem_repo1)}"
+     gem "platform_specific"
+    G
+
+    expect(the_bundle).to include_gems "platform_specific 1.0 RUBY"
+  end
+
+  it "doesn't pull platform specific gems on truffleruby (except when whitelisted) even if lockfile was generated with an older version that declared RUBY as platform", :truffleruby_only do
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "platform_specific"
+    G
+
+    lockfile <<-L
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
+          platform_specific (1.0)
+
+      PLATFORMS
+        ruby
+
+      DEPENDENCIES
+        platform_specific
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    bundle "install"
+
+    expect(the_bundle).to include_gems "platform_specific 1.0 RUBY"
+
+    simulate_platform "x86_64-linux" do
+      build_repo4 do
+        build_gem "libv8"
+
+        build_gem "libv8" do |s|
+          s.platform = "x86_64-linux"
+        end
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "libv8"
+      G
+
+      lockfile <<-L
+        GEM
+          remote: #{file_uri_for(gem_repo4)}/
+          specs:
+            libv8 (1.0)
+
+        PLATFORMS
+          ruby
+
+        DEPENDENCIES
+          libv8
+
+        BUNDLED WITH
+           #{Bundler::VERSION}
+      L
+
+      bundle "install"
+
+      expect(the_bundle).to include_gems "libv8 1.0 x86_64-linux"
+    end
+  end
+
+  it "doesn't pull platform specific gems on truffleruby, even if lockfile only includes those", :truffleruby_only do
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
+      gem "platform_specific"
+    G
+
+    lockfile <<-L
+      GEM
+        remote: #{file_uri_for(gem_repo1)}/
+        specs:
+          platform_specific (1.0-x86-darwin-100)
+
+      PLATFORMS
+        x86-darwin-100
+
+      DEPENDENCIES
+        platform_specific
+
+      BUNDLED WITH
+         #{Bundler::VERSION}
+    L
+
+    bundle "install"
+
+    expect(the_bundle).to include_gems "platform_specific 1.0 RUBY"
+  end
+
+  it "pulls platform specific gems correctly on musl" do
+    build_repo4 do
+      build_gem "nokogiri", "1.13.8" do |s|
+        s.platform = "aarch64-linux"
+      end
+    end
+
+    simulate_platform "aarch64-linux-musl" do
+      install_gemfile <<-G, :artifice => "compact_index", :env => { "BUNDLER_SPEC_GEM_REPO" => gem_repo4.to_s }, :verbose => true
+        source "https://gems.repo4"
+        gem "nokogiri"
+      G
+    end
+
+    expect(out).to include("Fetching nokogiri 1.13.8 (aarch64-linux)")
+  end
+
   it "allows specifying only-ruby-platform on windows with dependency platforms" do
     simulate_windows do
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "nokogiri", :platforms => [:mingw, :mswin, :x64_mingw, :jruby]
         gem "platform_specific"
       G
 
-      bundle! "config set force_ruby_platform true"
+      bundle "config set force_ruby_platform true"
 
-      bundle! "install"
+      bundle "install"
 
       expect(the_bundle).to include_gems "platform_specific 1.0 RUBY"
+      expect(the_bundle).to not_include_gems "nokogiri"
     end
   end
 
   it "allows specifying only-ruby-platform on windows with gemspec dependency" do
-    build_lib("foo", "1.0", :path => ".") do |s|
+    build_lib("foo", "1.0", :path => bundled_app) do |s|
       s.add_dependency "rack"
     end
 
@@ -125,11 +387,11 @@ RSpec.describe "Bundler.setup with multi
       source "#{file_uri_for(gem_repo1)}"
       gemspec
     G
-    bundle! :lock
+    bundle :lock
 
     simulate_windows do
-      bundle! "config set force_ruby_platform true"
-      bundle! "install"
+      bundle "config set force_ruby_platform true"
+      bundle "install"
 
       expect(the_bundle).to include_gems "rack 1.0"
     end
@@ -141,7 +403,7 @@ RSpec.describe "Bundler.setup with multi
         s.add_dependency "platform_specific"
       end
     end
-    simulate_windows x64_mingw do
+    simulate_windows x64_mingw32 do
       lockfile <<-L
         GEM
           remote: #{file_uri_for(gem_repo2)}/
@@ -158,12 +420,45 @@ RSpec.describe "Bundler.setup with multi
           requires_platform_specific
       L
 
-      install_gemfile! <<-G, :verbose => true
+      install_gemfile <<-G, :verbose => true
         source "#{file_uri_for(gem_repo2)}"
         gem "requires_platform_specific"
       G
 
+      expect(out).to include("lockfile does not have all gems needed for the current platform")
       expect(the_bundle).to include_gem "platform_specific 1.0 x64-mingw32"
     end
   end
+
+  %w[x86-mswin32 x64-mswin64 x86-mingw32 x64-mingw32 x64-mingw-ucrt].each do |arch|
+    it "allows specifying platform windows on #{arch} arch" do
+      platform = send(arch.tr("-", "_"))
+
+      simulate_windows platform do
+        lockfile <<-L
+          GEM
+            remote: #{file_uri_for(gem_repo1)}/
+            specs:
+              platform_specific (1.0-#{platform})
+              requires_platform_specific (1.0)
+                platform_specific
+
+          PLATFORMS
+            #{platform}
+
+          DEPENDENCIES
+            requires_platform_specific
+        L
+
+        install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
+          gem "platform_specific", :platforms => [:windows]
+        G
+
+        bundle "install"
+
+        expect(the_bundle).to include_gems "platform_specific 1.0 #{platform}"
+      end
+    end
+  end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/runtime/require_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/runtime/require_spec.rb
@@ -46,6 +46,7 @@ RSpec.describe "Bundler.require" do
     end
 
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       path "#{lib_path}" do
         gem "one", :group => :bar, :require => %w[baz qux]
         gem "two"
@@ -112,6 +113,7 @@ RSpec.describe "Bundler.require" do
 
   it "raises an exception if a require is specified but the file does not exist" do
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       path "#{lib_path}" do
         gem "two", :require => 'fail'
       end
@@ -130,12 +132,13 @@ RSpec.describe "Bundler.require" do
     end
 
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       path "#{lib_path}" do
         gem "faulty"
       end
     G
 
-    run "Bundler.require"
+    run "Bundler.require", :raise_on_error => false
     expect(err).to match("error while trying to load the gem 'faulty'")
     expect(err).to match("Gem Internal Error Message")
   end
@@ -146,6 +149,7 @@ RSpec.describe "Bundler.require" do
     end
 
     gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       path "#{lib_path}" do
         gem "loadfuuu"
       end
@@ -155,7 +159,7 @@ RSpec.describe "Bundler.require" do
       begin
         Bundler.require
       rescue LoadError => e
-        $stderr.puts "ZOMG LOAD ERROR: \#{e.message}"
+        warn "ZOMG LOAD ERROR: \#{e.message}"
       end
     RUBY
     run(cmd)
@@ -172,6 +176,7 @@ RSpec.describe "Bundler.require" do
 
     it "requires gem names that are namespaced" do
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         path '#{lib_path}' do
           gem 'jquery-rails'
         end
@@ -186,13 +191,15 @@ RSpec.describe "Bundler.require" do
         s.write "lib/brcrypt.rb", "BCrypt = '1.0.0'"
       end
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+
         path "#{lib_path}" do
           gem "bcrypt-ruby"
         end
       G
 
       cmd = <<-RUBY
-        require '#{lib_dir}/bundler'
+        require '#{entrypoint}'
         Bundler.require
       RUBY
       ruby(cmd)
@@ -202,6 +209,7 @@ RSpec.describe "Bundler.require" do
 
     it "does not mangle explicitly given requires" do
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         path "#{lib_path}" do
           gem 'jquery-rails', :require => 'jquery-rails'
         end
@@ -219,6 +227,7 @@ RSpec.describe "Bundler.require" do
       end
 
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         path "#{lib_path}" do
           gem "load-fuuu"
         end
@@ -228,7 +237,7 @@ RSpec.describe "Bundler.require" do
         begin
           Bundler.require
         rescue LoadError => e
-          $stderr.puts "ZOMG LOAD ERROR" if e.message.include?("Could not open library 'libfuuu-1.0'")
+          warn "ZOMG LOAD ERROR" if e.message.include?("Could not open library 'libfuuu-1.0'")
         end
       RUBY
       run(cmd)
@@ -242,6 +251,7 @@ RSpec.describe "Bundler.require" do
       end
 
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         path "#{lib_path}" do
           gem "load-fuuu"
         end
@@ -251,7 +261,7 @@ RSpec.describe "Bundler.require" do
         begin
           Bundler.require
         rescue LoadError => e
-          $stderr.puts "ZOMG LOAD ERROR: \#{e.message}"
+          warn "ZOMG LOAD ERROR: \#{e.message}"
         end
       RUBY
       run(cmd)
@@ -300,6 +310,7 @@ RSpec.describe "Bundler.require" do
 
     it "works when the gems are in the Gemfile in the correct order" do
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         path "#{lib_path}" do
           gem "two"
           gem "one"
@@ -318,6 +329,7 @@ RSpec.describe "Bundler.require" do
         end
 
         install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           gem "multi_gem", :require => "one", :group => :one
           gem "multi_gem", :require => "two", :group => :two
         G
@@ -341,6 +353,7 @@ RSpec.describe "Bundler.require" do
 
     it "fails when the gems are in the Gemfile in the wrong order" do
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         path "#{lib_path}" do
           gem "one"
           gem "two"
@@ -358,6 +371,7 @@ RSpec.describe "Bundler.require" do
         end
 
         install_gemfile <<-G
+          source "#{file_uri_for(gem_repo1)}"
           gem "busted_require"
         G
 
@@ -370,12 +384,12 @@ RSpec.describe "Bundler.require" do
   end
 
   it "does not load rubygems gemspecs that are used" do
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
 
-    run! <<-R
+    run <<-R
       path = File.join(Gem.dir, "specifications", "rack-1.0.0.gemspec")
       contents = File.read(path)
       contents = contents.lines.to_a.insert(-2, "\n  raise 'broken gemspec'\n").join
@@ -384,7 +398,7 @@ RSpec.describe "Bundler.require" do
       end
     R
 
-    run! <<-R
+    run <<-R
       Bundler.require
       puts "WIN"
     R
@@ -395,11 +409,12 @@ RSpec.describe "Bundler.require" do
   it "does not load git gemspecs that are used" do
     build_git "foo"
 
-    install_gemfile! <<-G
+    install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "foo", :git => "#{lib_path("foo-1.0")}"
     G
 
-    run! <<-R
+    run <<-R
       path = Gem.loaded_specs["foo"].loaded_from
       contents = File.read(path)
       contents = contents.lines.to_a.insert(-2, "\n  raise 'broken gemspec'\n").join
@@ -408,7 +423,7 @@ RSpec.describe "Bundler.require" do
       end
     R
 
-    run! <<-R
+    run <<-R
       Bundler.require
       puts "WIN"
     R
@@ -423,7 +438,7 @@ RSpec.describe "Bundler.require with pla
       source "#{file_uri_for(gem_repo1)}"
 
       platforms :#{not_local_tag} do
-        gem "fail", :require => "omgomg"
+        gem "platform_specific", :require => "omgomg"
       end
 
       gem "rack", "1.0.0"
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/runtime/self_management_spec.rb
@@ -0,0 +1,126 @@
+# frozen_string_literal: true
+
+RSpec.describe "Self management", :rubygems => ">= 3.3.0.dev", :realworld => true do
+  describe "auto switching" do
+    let(:previous_minor) do
+      "2.3.0"
+    end
+
+    before do
+      build_repo2
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+
+        gem "rack"
+      G
+    end
+
+    it "installs locked version when using system path and uses it" do
+      lockfile_bundled_with(previous_minor)
+
+      bundle "config set --local path.system true"
+      bundle "install", :artifice => "vcr"
+      expect(out).to include("Bundler #{Bundler::VERSION} is running, but your lockfile was generated with #{previous_minor}. Installing Bundler #{previous_minor} and restarting using that version.")
+
+      # It uninstalls the older system bundler
+      bundle "clean --force"
+      expect(out).to eq("Removing bundler (#{Bundler::VERSION})")
+
+      # App now uses locked version
+      bundle "-v"
+      expect(out).to end_with(previous_minor[0] == "2" ? "Bundler version #{previous_minor}" : previous_minor)
+
+      # Subsequent installs use the locked version without reinstalling
+      bundle "install --verbose"
+      expect(out).to include("Using bundler #{previous_minor}")
+      expect(out).not_to include("Bundler #{Bundler::VERSION} is running, but your lockfile was generated with #{previous_minor}. Installing Bundler #{previous_minor} and restarting using that version.")
+    end
+
+    it "installs locked version when using local path and uses it" do
+      lockfile_bundled_with(previous_minor)
+
+      bundle "config set --local path vendor/bundle"
+      bundle "install", :artifice => "vcr"
+      expect(out).to include("Bundler #{Bundler::VERSION} is running, but your lockfile was generated with #{previous_minor}. Installing Bundler #{previous_minor} and restarting using that version.")
+      expect(vendored_gems("gems/bundler-#{previous_minor}")).to exist
+
+      # It does not uninstall the locked bundler
+      bundle "clean"
+      expect(out).to be_empty
+
+      # App now uses locked version
+      bundle "-v"
+      expect(out).to end_with(previous_minor[0] == "2" ? "Bundler version #{previous_minor}" : previous_minor)
+
+      # Subsequent installs use the locked version without reinstalling
+      bundle "install --verbose"
+      expect(out).to include("Using bundler #{previous_minor}")
+      expect(out).not_to include("Bundler #{Bundler::VERSION} is running, but your lockfile was generated with #{previous_minor}. Installing Bundler #{previous_minor} and restarting using that version.")
+    end
+
+    it "installs locked version when using deployment option and uses it" do
+      lockfile_bundled_with(previous_minor)
+
+      bundle "config set --local deployment true"
+      bundle "install", :artifice => "vcr"
+      expect(out).to include("Bundler #{Bundler::VERSION} is running, but your lockfile was generated with #{previous_minor}. Installing Bundler #{previous_minor} and restarting using that version.")
+      expect(vendored_gems("gems/bundler-#{previous_minor}")).to exist
+
+      # It does not uninstall the locked bundler
+      bundle "clean"
+      expect(out).to be_empty
+
+      # App now uses locked version
+      bundle "-v"
+      expect(out).to end_with(previous_minor[0] == "2" ? "Bundler version #{previous_minor}" : previous_minor)
+
+      # Subsequent installs use the locked version without reinstalling
+      bundle "install --verbose"
+      expect(out).to include("Using bundler #{previous_minor}")
+      expect(out).not_to include("Bundler #{Bundler::VERSION} is running, but your lockfile was generated with #{previous_minor}. Installing Bundler #{previous_minor} and restarting using that version.")
+    end
+
+    it "does not try to install a development version" do
+      lockfile_bundled_with("#{previous_minor}.dev")
+
+      bundle "install --verbose"
+      expect(out).not_to match(/restarting using that version/)
+
+      bundle "-v"
+      expect(out).to eq(Bundler::VERSION[0] == "2" ? "Bundler version #{Bundler::VERSION}" : Bundler::VERSION)
+    end
+
+    it "shows a discreet message if locked bundler does not exist" do
+      missing_minor ="#{Bundler::VERSION[0]}.999.999"
+
+      lockfile_bundled_with(missing_minor)
+
+      bundle "install", :artifice => "vcr"
+      expect(err).to eq("Your lockfile is locked to a version of bundler (#{missing_minor}) that doesn't exist at https://rubygems.org/. Going on using #{Bundler::VERSION}")
+
+      bundle "-v"
+      expect(out).to eq(Bundler::VERSION[0] == "2" ? "Bundler version #{Bundler::VERSION}" : Bundler::VERSION)
+    end
+
+    private
+
+    def lockfile_bundled_with(version)
+      lockfile <<~L
+        GEM
+          remote: #{file_uri_for(gem_repo2)}/
+          specs:
+            rack (1.0.0)
+
+        PLATFORMS
+          #{lockfile_platforms}
+
+        DEPENDENCIES
+          rack
+
+        BUNDLED WITH
+           #{version}
+      L
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/runtime/setup_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/runtime/setup_spec.rb
@@ -1,7 +1,6 @@
 # frozen_string_literal: true
 
 require "tmpdir"
-require "tempfile"
 
 RSpec.describe "Bundler.setup" do
   describe "with no arguments" do
@@ -12,7 +11,7 @@ RSpec.describe "Bundler.setup" do
       G
 
       ruby <<-RUBY
-        require '#{lib_dir}/bundler'
+        require 'bundler'
         Bundler.setup
 
         require 'rack'
@@ -34,7 +33,7 @@ RSpec.describe "Bundler.setup" do
 
     it "doesn't make all groups available" do
       ruby <<-RUBY
-        require '#{lib_dir}/bundler'
+        require 'bundler'
         Bundler.setup(:default)
 
         begin
@@ -49,7 +48,7 @@ RSpec.describe "Bundler.setup" do
 
     it "accepts string for group name" do
       ruby <<-RUBY
-        require '#{lib_dir}/bundler'
+        require 'bundler'
         Bundler.setup(:default, 'test')
 
         require 'rack'
@@ -61,7 +60,7 @@ RSpec.describe "Bundler.setup" do
 
     it "leaves all groups available if they were already" do
       ruby <<-RUBY
-        require '#{lib_dir}/bundler'
+        require 'bundler'
         Bundler.setup
         Bundler.setup(:default)
 
@@ -74,7 +73,7 @@ RSpec.describe "Bundler.setup" do
 
     it "leaves :default available if setup is called twice" do
       ruby <<-RUBY
-        require '#{lib_dir}/bundler'
+        require 'bundler'
         Bundler.setup(:default)
         Bundler.setup(:default, :test)
 
@@ -90,8 +89,8 @@ RSpec.describe "Bundler.setup" do
     end
 
     it "handles multiple non-additive invocations" do
-      ruby <<-RUBY
-        require '#{lib_dir}/bundler'
+      ruby <<-RUBY, :raise_on_error => false
+        require 'bundler'
         Bundler.setup(:default, :test)
         Bundler.setup(:default)
         require 'rack'
@@ -107,9 +106,9 @@ RSpec.describe "Bundler.setup" do
 
   context "load order" do
     def clean_load_path(lp)
-      without_bundler_load_path = ruby!("puts $LOAD_PATH").split("\n")
-      lp -= without_bundler_load_path
-      lp.map! {|p| p.sub(/^#{Regexp.union system_gem_path.to_s, default_bundle_path.to_s, lib_dir.to_s}/i, "") }
+      without_bundler_load_path = ruby("puts $LOAD_PATH").split("\n")
+      lp -= [*without_bundler_load_path, lib_dir.to_s]
+      lp.map! {|p| p.sub(system_gem_path.to_s, "") }
     end
 
     it "puts loaded gems after -I and RUBYLIB", :ruby_repo do
@@ -122,7 +121,7 @@ RSpec.describe "Bundler.setup" do
       ENV["RUBYLIB"] = "rubylib_dir"
 
       ruby <<-RUBY
-        require '#{lib_dir}/bundler'
+        require 'bundler'
         Bundler.setup
         puts $LOAD_PATH
       RUBY
@@ -136,15 +135,15 @@ RSpec.describe "Bundler.setup" do
     end
 
     it "orders the load path correctly when there are dependencies" do
-      system_gems :bundler
+      bundle "config set path.system true"
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rails"
       G
 
-      ruby! <<-RUBY
-        require '#{lib_dir}/bundler'
+      ruby <<-RUBY
+        require 'bundler'
         Bundler.setup
         puts $LOAD_PATH
       RUBY
@@ -153,26 +152,27 @@ RSpec.describe "Bundler.setup" do
 
       expect(load_path).to start_with(
         "/gems/rails-2.3.2/lib",
-        "/gems/bundler-#{Bundler::VERSION}/lib",
         "/gems/activeresource-2.3.2/lib",
         "/gems/activerecord-2.3.2/lib",
         "/gems/actionpack-2.3.2/lib",
         "/gems/actionmailer-2.3.2/lib",
         "/gems/activesupport-2.3.2/lib",
-        "/gems/rake-12.3.2/lib"
+        "/gems/rake-13.0.1/lib"
       )
     end
 
     it "falls back to order the load path alphabetically for backwards compatibility" do
-      install_gemfile! <<-G
+      bundle "config set path.system true"
+
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "weakling"
         gem "duradura"
         gem "terranova"
       G
 
-      ruby! <<-RUBY
-        require '#{lib_dir}/bundler/setup'
+      ruby <<-RUBY
+        require 'bundler/setup'
         puts $LOAD_PATH
       RUBY
 
@@ -193,7 +193,7 @@ RSpec.describe "Bundler.setup" do
     G
 
     ruby <<-R
-      require '#{lib_dir}/bundler'
+      require '#{entrypoint}'
 
       begin
         Bundler.setup
@@ -212,13 +212,13 @@ RSpec.describe "Bundler.setup" do
       gem "rack"
     G
 
-    ruby <<-R
-      require '#{lib_dir}/bundler'
+    ruby <<-R, :raise_on_error => false
+      require 'bundler'
 
       Bundler.setup
     R
 
-    expect(bundled_app("Gemfile.lock")).not_to exist
+    expect(bundled_app_lock).not_to exist
   end
 
   it "doesn't change the Gemfile.lock if the setup fails" do
@@ -227,7 +227,7 @@ RSpec.describe "Bundler.setup" do
       gem "rack"
     G
 
-    lockfile = File.read(bundled_app("Gemfile.lock"))
+    lockfile = File.read(bundled_app_lock)
 
     gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
@@ -235,13 +235,13 @@ RSpec.describe "Bundler.setup" do
       gem "nosuchgem", "10.0"
     G
 
-    ruby <<-R
-      require '#{lib_dir}/bundler'
+    ruby <<-R, :raise_on_error => false
+      require 'bundler'
 
       Bundler.setup
     R
 
-    expect(File.read(bundled_app("Gemfile.lock"))).to eq(lockfile)
+    expect(File.read(bundled_app_lock)).to eq(lockfile)
   end
 
   it "makes a Gemfile.lock if setup succeeds" do
@@ -250,12 +250,12 @@ RSpec.describe "Bundler.setup" do
       gem "rack"
     G
 
-    File.read(bundled_app("Gemfile.lock"))
+    File.read(bundled_app_lock)
 
-    FileUtils.rm(bundled_app("Gemfile.lock"))
+    FileUtils.rm(bundled_app_lock)
 
     run "1"
-    expect(bundled_app("Gemfile.lock")).to exist
+    expect(bundled_app_lock).to exist
   end
 
   describe "$BUNDLE_GEMFILE" do
@@ -279,17 +279,17 @@ RSpec.describe "Bundler.setup" do
     end
 
     context "an absolute path is not provided" do
-      it "uses BUNDLE_GEMFILE to locate the gemfile if present" do
+      it "uses BUNDLE_GEMFILE to locate the gemfile if present and doesn't fail in deployment mode" do
         gemfile <<-G
           source "#{file_uri_for(gem_repo1)}"
         G
 
         bundle "install"
-        bundle "install --deployment"
+        bundle "config set --local deployment true"
 
         ENV["BUNDLE_GEMFILE"] = "Gemfile"
         ruby <<-R
-          require '#{lib_dir}/bundler'
+          require 'bundler'
 
           begin
             Bundler.setup
@@ -429,12 +429,13 @@ RSpec.describe "Bundler.setup" do
       build_git "rack", "1.0.0"
 
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "rack", :git => "#{lib_path("rack-1.0.0")}"
       G
     end
 
     it "provides a useful exception when the git repo is not checked out yet" do
-      run "1"
+      run "1", :raise_on_error => false
       expect(err).to match(/the git source #{lib_path('rack-1.0.0')} is not yet checked out. Please run `bundle install`/i)
     end
 
@@ -444,7 +445,7 @@ RSpec.describe "Bundler.setup" do
       break_git!
 
       ruby <<-R
-        require '#{lib_dir}/bundler'
+        require 'bundler'
 
         begin
           Bundler.setup
@@ -460,12 +461,12 @@ RSpec.describe "Bundler.setup" do
     it "provides a good exception if the lockfile is unavailable" do
       bundle "install"
 
-      FileUtils.rm(bundled_app("Gemfile.lock"))
+      FileUtils.rm(bundled_app_lock)
 
       break_git!
 
       ruby <<-R
-        require "#{lib_dir}/bundler"
+        require "#{entrypoint}"
 
         begin
           Bundler.setup
@@ -475,29 +476,32 @@ RSpec.describe "Bundler.setup" do
         end
       R
 
-      run "puts 'FAIL'"
+      run "puts 'FAIL'", :raise_on_error => false
 
       expect(err).not_to include "This is not the git you are looking for"
     end
 
     it "works even when the cache directory has been deleted" do
-      bundle! :install, forgotten_command_line_options(:path => "vendor/bundle")
+      bundle "config set --local path vendor/bundle"
+      bundle :install
       FileUtils.rm_rf vendored_gems("cache")
       expect(the_bundle).to include_gems "rack 1.0.0"
     end
 
     it "does not randomly change the path when specifying --path and the bundle directory becomes read only" do
-      bundle! :install, forgotten_command_line_options(:path => "vendor/bundle")
+      bundle "config set --local path vendor/bundle"
+      bundle :install
 
-      with_read_only("**/*") do
+      with_read_only("#{bundled_app}/**/*") do
         expect(the_bundle).to include_gems "rack 1.0.0"
       end
     end
 
     it "finds git gem when default bundle path becomes read only" do
+      bundle "config set --local path .bundle"
       bundle "install"
 
-      with_read_only("#{Bundler.bundle_path}/**/*") do
+      with_read_only("#{bundled_app(".bundle")}/**/*") do
         expect(the_bundle).to include_gems "rack 1.0.0"
       end
     end
@@ -511,14 +515,14 @@ RSpec.describe "Bundler.setup" do
 
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
       G
 
       bundle %(config set local.rack #{lib_path("local-rack")})
-      bundle! :install
+      bundle :install
 
       FileUtils.rm_rf(lib_path("local-rack"))
-      run "require 'rack'"
+      run "require 'rack'", :raise_on_error => false
       expect(err).to match(/Cannot use local override for rack-0.8 because #{Regexp.escape(lib_path('local-rack').to_s)} does not exist/)
     end
 
@@ -529,18 +533,18 @@ RSpec.describe "Bundler.setup" do
 
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
       G
 
       bundle %(config set local.rack #{lib_path("local-rack")})
-      bundle! :install
+      bundle :install
 
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack", :git => "#{lib_path("rack-0.8")}"
       G
 
-      run "require 'rack'"
+      run "require 'rack'", :raise_on_error => false
       expect(err).to match(/because :branch is not specified in Gemfile/)
     end
 
@@ -551,19 +555,19 @@ RSpec.describe "Bundler.setup" do
 
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "main"
       G
 
       bundle %(config set local.rack #{lib_path("local-rack")})
-      bundle! :install
+      bundle :install
 
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "changed"
       G
 
-      run "require 'rack'"
-      expect(err).to match(/is using branch master but Gemfile specifies changed/)
+      run "require 'rack'", :raise_on_error => false
+      expect(err).to match(/is using branch main but Gemfile specifies changed/)
     end
 
     it "explodes on refs with different branches on runtime" do
@@ -573,23 +577,24 @@ RSpec.describe "Bundler.setup" do
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :ref => "master", :branch => "master"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :ref => "main", :branch => "main"
       G
 
       gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :ref => "master", :branch => "nonexistant"
+        gem "rack", :git => "#{lib_path("rack-0.8")}", :ref => "main", :branch => "nonexistant"
       G
 
       bundle %(config set local.rack #{lib_path("local-rack")})
-      run "require 'rack'"
-      expect(err).to match(/is using branch master but Gemfile specifies nonexistant/)
+      run "require 'rack'", :raise_on_error => false
+      expect(err).to match(/is using branch main but Gemfile specifies nonexistant/)
     end
   end
 
   describe "when excluding groups" do
     it "doesn't change the resolve if --without is used" do
-      install_gemfile <<-G, forgotten_command_line_options(:without => :rails)
+      bundle "config set --local without rails"
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "activesupport"
 
@@ -598,13 +603,14 @@ RSpec.describe "Bundler.setup" do
         end
       G
 
-      install_gems "activesupport-2.3.5"
+      system_gems "activesupport-2.3.5"
 
       expect(the_bundle).to include_gems "activesupport 2.3.2", :groups => :default
     end
 
     it "remembers --without and does not bail on bare Bundler.setup" do
-      install_gemfile <<-G, forgotten_command_line_options(:without => :rails)
+      bundle "config set --local without rails"
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "activesupport"
 
@@ -613,13 +619,70 @@ RSpec.describe "Bundler.setup" do
         end
       G
 
-      install_gems "activesupport-2.3.5"
+      system_gems "activesupport-2.3.5"
 
       expect(the_bundle).to include_gems "activesupport 2.3.2"
     end
 
+    it "remembers --without and does not bail on bare Bundler.setup, even in the case of path gems no longer available" do
+      bundle "config set --local without development"
+
+      path = bundled_app(File.join("vendor", "foo"))
+      build_lib "foo", :path => path
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "activesupport", "2.3.2"
+        gem 'foo', :path => 'vendor/foo', :group => :development
+      G
+
+      FileUtils.rm_rf(path)
+
+      ruby "require 'bundler'; Bundler.setup", :env => { "DEBUG" => "1" }
+      expect(out).to include("Assuming that source at `vendor/foo` has not changed since fetching its specs errored")
+      expect(out).to include("Found no changes, using resolution from the lockfile")
+      expect(err).to be_empty
+    end
+
+    it "doesn't re-resolve when a pre-release bundler is used and a dependency includes a dependency on bundler" do
+      system_gems "bundler-9.99.9.beta1"
+
+      build_repo4 do
+        build_gem "depends_on_bundler", "1.0" do |s|
+          s.add_dependency "bundler", ">= 1.5.0"
+        end
+      end
+
+      install_gemfile <<~G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "depends_on_bundler"
+      G
+
+      ruby "require '#{system_gem_path("gems/bundler-9.99.9.beta1/lib/bundler.rb")}'; Bundler.setup", :env => { "DEBUG" => "1" }
+      expect(out).to include("Found no changes, using resolution from the lockfile")
+      expect(out).not_to include("lockfile does not have all gems needed for the current platform")
+      expect(err).to be_empty
+    end
+
+    it "doesn't re-resolve when deleting dependencies" do
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+        gem "actionpack"
+      G
+
+      install_gemfile <<-G, :verbose => true
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rack"
+      G
+
+      expect(out).to include("Some dependencies were deleted, using a subset of the resolution from the lockfile")
+      expect(err).to be_empty
+    end
+
     it "remembers --without and does not include groups passed to Bundler.setup" do
-      install_gemfile <<-G, forgotten_command_line_options(:without => :rails)
+      bundle "config set --local without rails"
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "activesupport"
 
@@ -659,12 +722,12 @@ RSpec.describe "Bundler.setup" do
   end
 
   it "does not load all gemspecs" do
-    install_gemfile! <<-G
+    install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
       gem "rack"
     G
 
-    run! <<-R
+    run <<-R
       File.open(File.join(Gem.dir, "specifications", "broken.gemspec"), "w") do |f|
         f.write <<-RUBY
 # -*- encoding: utf-8 -*-
@@ -679,7 +742,7 @@ end
       end
     R
 
-    run! <<-R
+    run <<-R
       puts "WIN"
     R
 
@@ -698,41 +761,68 @@ end
     expect(err).to be_empty
   end
 
-  describe "$MANPATH" do
-    before do
+  context "when the user has `MANPATH` set", :man do
+    before { ENV["MANPATH"] = "/foo#{File::PATH_SEPARATOR}" }
+
+    it "adds the gem's man dir to the MANPATH" do
       build_repo4 do
         build_gem "with_man" do |s|
           s.write("man/man1/page.1", "MANPAGE")
         end
       end
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "with_man"
+      G
+
+      run "puts ENV['MANPATH']"
+      expect(out).to eq("#{default_bundle_path("gems/with_man-1.0/man")}#{File::PATH_SEPARATOR}/foo")
     end
+  end
 
-    context "when the user has one set" do
-      before { ENV["MANPATH"] = "/foo:" }
+  context "when the user does not have `MANPATH` set", :man do
+    before { ENV.delete("MANPATH") }
 
-      it "adds the gem's man dir to the MANPATH" do
-        install_gemfile! <<-G
-          source "#{file_uri_for(gem_repo4)}"
-          gem "with_man"
-        G
+    it "adds the gem's man dir to the MANPATH, leaving : in the end so that system man pages still work" do
+      build_repo4 do
+        build_gem "with_man" do |s|
+          s.write("man/man1/page.1", "MANPAGE")
+        end
 
-        run! "puts ENV['MANPATH']"
-        expect(out).to eq("#{default_bundle_path("gems/with_man-1.0/man")}:/foo")
+        build_gem "with_man_overriding_system_man" do |s|
+          s.write("man/man1/ls.1", "LS MANPAGE")
+        end
       end
-    end
 
-    context "when the user does not have one set" do
-      before { ENV.delete("MANPATH") }
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "with_man"
+      G
 
-      it "adds the gem's man dir to the MANPATH" do
-        install_gemfile! <<-G
-          source "#{file_uri_for(gem_repo4)}"
-          gem "with_man"
-        G
+      run <<~RUBY
+        puts ENV['MANPATH']
+        require "open3"
+        puts Open3.capture2e("man", "ls")[1].success?
+      RUBY
 
-        run! "puts ENV['MANPATH']"
-        expect(out).to eq(default_bundle_path("gems/with_man-1.0/man").to_s)
-      end
+      expect(out).to eq("#{default_bundle_path("gems/with_man-1.0/man")}#{File::PATH_SEPARATOR}\ntrue")
+
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo4)}"
+        gem "with_man_overriding_system_man"
+      G
+
+      run <<~RUBY
+        puts ENV['MANPATH']
+        require "open3"
+        puts Open3.capture2e({ "LC_ALL" => "C" }, "man", "ls")[0]
+      RUBY
+
+      lines = out.split("\n")
+
+      expect(lines).to include("#{default_bundle_path("gems/with_man_overriding_system_man-1.0/man")}#{File::PATH_SEPARATOR}")
+      expect(lines).to include("LS MANPAGE")
     end
   end
 
@@ -754,27 +844,25 @@ end
     expect(out).to eq("yay")
   end
 
-  it "should clean $LOAD_PATH properly", :ruby_repo do
+  it "should clean $LOAD_PATH properly" do
     gem_name = "very_simple_binary"
     full_gem_name = gem_name + "-1.0"
     ext_dir = File.join(tmp("extensions", full_gem_name))
 
-    install_gems full_gem_name
+    system_gems full_gem_name
 
     install_gemfile <<-G
       source "#{file_uri_for(gem_repo1)}"
     G
 
     ruby <<-R
-      if Gem::Specification.method_defined? :extension_dir
-        s = Gem::Specification.find_by_name '#{gem_name}'
-        s.extension_dir = '#{ext_dir}'
+      s = Gem::Specification.find_by_name '#{gem_name}'
+      s.extension_dir = '#{ext_dir}'
 
-        # Don't build extensions.
-        s.class.send(:define_method, :build_extensions) { nil }
-      end
+      # Don't build extensions.
+      s.class.send(:define_method, :build_extensions) { nil }
 
-      require '#{lib_dir}/bundler'
+      require 'bundler'
       gem '#{gem_name}'
 
       puts $LOAD_PATH.count {|path| path =~ /#{gem_name}/} >= 2
@@ -789,17 +877,17 @@ end
 
   context "with bundler is located in symlinked GEM_HOME" do
     let(:gem_home) { Dir.mktmpdir }
-    let(:symlinked_gem_home) { Tempfile.new("gem_home").path }
+    let(:symlinked_gem_home) { tmp("gem_home-symlink").to_s }
     let(:full_name) { "bundler-#{Bundler::VERSION}" }
 
     before do
-      FileUtils.ln_sf(gem_home, symlinked_gem_home)
+      File.symlink(gem_home, symlinked_gem_home)
       gems_dir = File.join(gem_home, "gems")
       specifications_dir = File.join(gem_home, "specifications")
       Dir.mkdir(gems_dir)
       Dir.mkdir(specifications_dir)
 
-      FileUtils.ln_s(root, File.join(gems_dir, full_name))
+      File.symlink(source_root, File.join(gems_dir, full_name))
 
       gemspec_content = File.binread(gemspec).
                 sub("Bundler::VERSION", %("#{Bundler::VERSION}")).
@@ -811,11 +899,11 @@ end
     end
 
     it "should not remove itself from the LOAD_PATH and require a different copy of 'bundler/setup'" do
-      install_gemfile ""
+      install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
 
-      ruby <<-R, :env => { "GEM_PATH" => symlinked_gem_home }, :no_lib => true
+      ruby <<-R, :env => { "GEM_PATH" => symlinked_gem_home }
         TracePoint.trace(:class) do |tp|
-          if tp.path.include?("bundler") && !tp.path.start_with?("#{root}")
+          if tp.path.include?("bundler") && !tp.path.start_with?("#{source_root}")
             puts "OMG. Defining a class from another bundler at \#{tp.path}:\#{tp.lineno}"
           end
         end
@@ -860,14 +948,13 @@ end
       FileUtils.rm(File.join(path, "foo.gemspec"))
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem 'foo', '1.2.3', :path => 'vendor/foo'
       G
 
-      Dir.chdir(bundled_app.parent) do
-        run <<-R, :env => { "BUNDLE_GEMFILE" => bundled_app("Gemfile").to_s }
-          require 'foo'
-        R
-      end
+      run <<-R, :env => { "BUNDLE_GEMFILE" => bundled_app_gemfile.to_s }, :dir => bundled_app.parent
+        require 'foo'
+      R
       expect(err).to be_empty
     end
 
@@ -882,16 +969,15 @@ end
       FileUtils.rm(File.join(absolute_path, "foo.gemspec"))
 
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem 'foo', '1.2.3', :path => '#{relative_path}'
       G
 
       bundle :install
 
-      Dir.chdir(bundled_app.parent) do
-        run <<-R, :env => { "BUNDLE_GEMFILE" => bundled_app("Gemfile").to_s }
-          require 'foo'
-        R
-      end
+      run <<-R, :env => { "BUNDLE_GEMFILE" => bundled_app_gemfile.to_s }, :dir => bundled_app.parent
+        require 'foo'
+      R
 
       expect(err).to be_empty
     end
@@ -902,6 +988,7 @@ end
       build_git "no_gemspec", :gemspec => false
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "no_gemspec", "1.0", :git => "#{lib_path("no_gemspec-1.0")}"
       G
     end
@@ -969,7 +1056,7 @@ end
 
   describe "with system gems in the bundle" do
     before :each do
-      bundle! "config set path.system true"
+      bundle "config set path.system true"
       system_gems "rack-1.0.0"
 
       install_gemfile <<-G
@@ -1004,6 +1091,7 @@ end
       end
 
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "bar", :git => "#{lib_path("bar-1.0")}"
       G
     end
@@ -1015,14 +1103,15 @@ end
     end
 
     it "error intelligently if the gemspec has a LoadError" do
+      skip "whitespace issue?" if Gem.win_platform?
+
       ref = update_git "bar", :gemspec => false do |s|
         s.write "bar.gemspec", "require 'foobarbaz'"
       end.ref_for("HEAD")
-      bundle :install
+      bundle :install, :raise_on_error => false
 
       expect(err.lines.map(&:chomp)).to include(
         a_string_starting_with("[!] There was an error while loading `bar.gemspec`:"),
-        a_string_starting_with("Does it try to require a relative path? That's been removed in Ruby 1.9."),
         " #  from #{default_bundle_path "bundler", "gems", "bar-1.0-#{ref[0, 12]}", "bar.gemspec"}:1",
         " >  require 'foobarbaz'"
       )
@@ -1032,7 +1121,7 @@ end
       bundle "install"
 
       ruby <<-RUBY
-        require '#{lib_dir}/bundler'
+        require 'bundler'
         bundler_module = class << Bundler; self; end
         bundler_module.send(:remove_method, :require)
         def Bundler.require(path)
@@ -1049,6 +1138,7 @@ end
   describe "when Bundler is bundled" do
     it "doesn't blow up" do
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem "bundler", :path => "#{root}"
       G
 
@@ -1059,7 +1149,7 @@ end
 
   describe "when BUNDLED WITH" do
     def lock_with(bundler_version = nil)
-      lock = <<-L
+      lock = <<~L
         GEM
           remote: #{file_uri_for(gem_repo1)}/
           specs:
@@ -1073,13 +1163,15 @@ end
       L
 
       if bundler_version
-        lock += "\n        BUNDLED WITH\n           #{bundler_version}\n"
+        lock += "\nBUNDLED WITH\n   #{bundler_version}\n"
       end
 
       lock
     end
 
     before do
+      bundle "config set --local path.system true"
+
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
@@ -1089,26 +1181,27 @@ end
     context "is not present" do
       it "does not change the lock" do
         lockfile lock_with(nil)
-        ruby "require '#{lib_dir}/bundler/setup'"
-        lockfile_should_be lock_with(nil)
+        ruby "require '#{entrypoint}/setup'"
+        expect(lockfile).to eq lock_with(nil)
       end
     end
 
     context "is newer" do
       it "does not change the lock or warn" do
         lockfile lock_with(Bundler::VERSION.succ)
-        ruby "require '#{lib_dir}/bundler/setup'"
+        ruby "require 'bundler/setup'"
         expect(out).to be_empty
         expect(err).to be_empty
-        lockfile_should_be lock_with(Bundler::VERSION.succ)
+        expect(lockfile).to eq lock_with(Bundler::VERSION.succ)
       end
     end
 
     context "is older" do
       it "does not change the lock" do
+        system_gems "bundler-1.10.1"
         lockfile lock_with("1.10.1")
-        ruby "require '#{lib_dir}/bundler/setup'"
-        lockfile_should_be lock_with("1.10.1")
+        ruby "require '#{entrypoint}/setup'"
+        expect(lockfile).to eq lock_with("1.10.1")
       end
     end
   end
@@ -1117,7 +1210,7 @@ end
     let(:ruby_version) { nil }
 
     def lock_with(ruby_version = nil)
-      lock = <<-L
+      lock = <<~L
         GEM
           remote: #{file_uri_for(gem_repo1)}/
           specs:
@@ -1131,10 +1224,10 @@ end
       L
 
       if ruby_version
-        lock += "\n        RUBY VERSION\n           ruby #{ruby_version}\n"
+        lock += "\nRUBY VERSION\n   ruby #{ruby_version}\n"
       end
 
-      lock += <<-L
+      lock += <<~L
 
         BUNDLED WITH
            #{Bundler::VERSION}
@@ -1154,14 +1247,14 @@ end
 
     context "is not present" do
       it "does not change the lock" do
-        expect { ruby! "require '#{lib_dir}/bundler/setup'" }.not_to change { lockfile }
+        expect { ruby "require 'bundler/setup'" }.not_to change { lockfile }
       end
     end
 
     context "is newer" do
       let(:ruby_version) { "5.5.5" }
       it "does not change the lock or warn" do
-        expect { ruby! "require '#{lib_dir}/bundler/setup'" }.not_to change { lockfile }
+        expect { ruby "require 'bundler/setup'" }.not_to change { lockfile }
         expect(out).to be_empty
         expect(err).to be_empty
       end
@@ -1170,16 +1263,51 @@ end
     context "is older" do
       let(:ruby_version) { "1.0.0" }
       it "does not change the lock" do
-        expect { ruby! "require '#{lib_dir}/bundler/setup'" }.not_to change { lockfile }
+        expect { ruby "require 'bundler/setup'" }.not_to change { lockfile }
       end
     end
   end
 
   describe "with gemified standard libraries" do
+    it "does not load Digest", :ruby_repo do
+      skip "Only for Ruby 3.0+" unless RUBY_VERSION >= "3.0"
+
+      build_git "bar", :gemspec => false do |s|
+        s.write "lib/bar/version.rb", %(BAR_VERSION = '1.0')
+        s.write "bar.gemspec", <<-G
+          require_relative 'lib/bar/version'
+
+          Gem::Specification.new do |s|
+            s.name        = 'bar'
+            s.version     = BAR_VERSION
+            s.summary     = 'Bar'
+            s.files       = Dir["lib/**/*.rb"]
+            s.author      = 'no one'
+
+            s.add_runtime_dependency 'digest'
+          end
+        G
+      end
+
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "bar", :git => "#{lib_path("bar-1.0")}"
+      G
+
+      bundle :install
+
+      ruby <<-RUBY
+        require '#{entrypoint}/setup'
+        puts defined?(::Digest) ? "Digest defined" : "Digest undefined"
+        require 'digest'
+      RUBY
+      expect(out).to eq("Digest undefined")
+    end
+
     it "does not load Psych" do
-      gemfile ""
+      gemfile "source \"#{file_uri_for(gem_repo1)}\""
       ruby <<-RUBY
-        require '#{lib_dir}/bundler/setup'
+        require '#{entrypoint}/setup'
         puts defined?(Psych::VERSION) ? Psych::VERSION : "undefined"
         require 'psych'
         puts Psych::VERSION
@@ -1190,9 +1318,9 @@ end
     end
 
     it "does not load openssl" do
-      install_gemfile! ""
-      ruby! <<-RUBY
-        require "#{lib_dir}/bundler/setup"
+      install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
+      ruby <<-RUBY
+        require "bundler/setup"
         puts defined?(OpenSSL) || "undefined"
         require "openssl"
         puts defined?(OpenSSL) || "undefined"
@@ -1202,11 +1330,18 @@ end
 
     describe "default gem activation" do
       let(:exemptions) do
-        if Gem::Version.new(Gem::VERSION) >= Gem::Version.new("2.7")
+        exempts = if Gem.rubygems_version >= Gem::Version.new("2.7")
           %w[did_you_mean]
         else
           %w[io-console openssl]
         end << "bundler"
+        exempts << "uri" if Gem.ruby_version >= Gem::Version.new("2.7")
+        exempts << "pathname" if Gem.ruby_version >= Gem::Version.new("3.0")
+        exempts << "set" unless Gem.rubygems_version >= Gem::Version.new("3.2.6")
+        exempts << "tsort" unless Gem.rubygems_version >= Gem::Version.new("3.2.31")
+        exempts << "error_highlight" # added in Ruby 3.1 as a default gem
+        exempts << "ruby2_keywords" # added in Ruby 3.1 as a default gem
+        exempts
       end
 
       let(:activation_warning_hack) { strip_whitespace(<<-RUBY) }
@@ -1243,23 +1378,25 @@ end
       RUBY
 
       it "activates no gems with -rbundler/setup" do
-        install_gemfile! ""
-        ruby! code, :env => { "RUBYOPT" => activation_warning_hack_rubyopt + " -r#{lib_dir}/bundler/setup" }
+        install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
+        ruby code, :env => { "RUBYOPT" => activation_warning_hack_rubyopt + " -rbundler/setup" }
         expect(out).to eq("{}")
       end
 
       it "activates no gems with bundle exec" do
-        install_gemfile! ""
+        install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
         create_file("script.rb", code)
-        bundle! "exec ruby ./script.rb", :env => { "RUBYOPT" => activation_warning_hack_rubyopt }
+        bundle "exec ruby ./script.rb", :env => { "RUBYOPT" => activation_warning_hack_rubyopt }
         expect(out).to eq("{}")
       end
 
       it "activates no gems with bundle exec that is loaded" do
-        install_gemfile! ""
+        skip "not executable" if Gem.win_platform?
+
+        install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
         create_file("script.rb", "#!/usr/bin/env ruby\n\n#{code}")
         FileUtils.chmod(0o777, bundled_app("script.rb"))
-        bundle! "exec ./script.rb", :artifice => nil, :env => { "RUBYOPT" => activation_warning_hack_rubyopt }
+        bundle "exec ./script.rb", :artifice => nil, :env => { "RUBYOPT" => activation_warning_hack_rubyopt }
         expect(out).to eq("{}")
       end
 
@@ -1268,31 +1405,31 @@ end
           build_gem "net-http-pipeline", "1.0.1"
         end
 
-        system_gems "net-http-pipeline-1.0.1", :gem_repo => gem_repo4 do
-          gemfile <<-G
-            source "#{file_uri_for(gem_repo4)}"
-            gem "net-http-pipeline", "1.0.1"
-          G
+        system_gems "net-http-pipeline-1.0.1", :gem_repo => gem_repo4
 
-          bundle "config set --local path vendor/bundle"
+        gemfile <<-G
+          source "#{file_uri_for(gem_repo4)}"
+          gem "net-http-pipeline", "1.0.1"
+        G
 
-          bundle! :install
+        bundle "config set --local path vendor/bundle"
 
-          bundle! :check
+        bundle :install
 
-          expect(out).to eq("The Gemfile's dependencies are satisfied")
-        end
+        bundle :check
+
+        expect(out).to eq("The Gemfile's dependencies are satisfied")
       end
 
       Gem::Specification.select(&:default_gem?).map(&:name).each do |g|
-        it "activates newer versions of #{g}" do
+        it "activates newer versions of #{g}", :ruby_repo do
           skip if exemptions.include?(g)
 
           build_repo4 do
             build_gem g, "999999"
           end
 
-          install_gemfile! <<-G
+          install_gemfile <<-G
             source "#{file_uri_for(gem_repo4)}"
             gem "#{g}", "999999"
           G
@@ -1300,14 +1437,14 @@ end
           expect(the_bundle).to include_gem("#{g} 999999", :env => { "RUBYOPT" => activation_warning_hack_rubyopt })
         end
 
-        it "activates older versions of #{g}" do
+        it "activates older versions of #{g}", :ruby_repo do
           skip if exemptions.include?(g)
 
           build_repo4 do
             build_gem g, "0.0.0.a"
           end
 
-          install_gemfile! <<-G
+          install_gemfile <<-G
             source "#{file_uri_for(gem_repo4)}"
             gem "#{g}", "0.0.0.a"
           G
@@ -1325,8 +1462,8 @@ end
         gem "rack"
       G
 
-      ruby! <<-RUBY
-        require "#{lib_dir}/bundler/setup"
+      ruby <<-RUBY
+        require "bundler/setup"
         Object.new.gem "rack"
         puts Gem.loaded_specs["rack"].full_name
       RUBY
@@ -1335,13 +1472,13 @@ end
     end
 
     it "keeps Kernel#gem private", :bundler => "3" do
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
 
-      ruby <<-RUBY
-        require "#{lib_dir}/bundler/setup"
+      ruby <<-RUBY, :raise_on_error => false
+        require "bundler/setup"
         Object.new.gem "rack"
         puts "FAIL"
       RUBY
@@ -1351,13 +1488,13 @@ end
     end
 
     it "keeps Kernel#require private" do
-      install_gemfile! <<-G
+      install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
         gem "rack"
       G
 
-      ruby <<-RUBY
-        require "#{lib_dir}/bundler/setup"
+      ruby <<-RUBY, :raise_on_error => false
+        require "bundler/setup"
         Object.new.require "rack"
         puts "FAIL"
       RUBY
@@ -1367,9 +1504,48 @@ end
     end
 
     it "takes care of requiring rubygems" do
-      sys_exec("#{Gem.ruby} -I#{lib_dir} -e \"puts require('bundler/setup')\"", "RUBYOPT" => "--disable=gems")
+      sys_exec("#{Gem.ruby} -I#{lib_dir} -rbundler/setup -e'puts true'", :env => { "RUBYOPT" => opt_add("--disable=gems", ENV["RUBYOPT"]) })
 
       expect(last_command.stdboth).to eq("true")
     end
+
+    it "memoizes initial set of specs when requiring bundler/setup, so that even if further code mutates dependencies, Bundler.definition.specs is not affected" do
+      install_gemfile <<~G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "yard"
+        gem "rack", :group => :test
+      G
+
+      ruby <<-RUBY, :raise_on_error => false
+        require "bundler/setup"
+        Bundler.require(:test).select! {|d| (d.groups & [:test]).any? }
+        puts Bundler.definition.specs.map(&:name).join(", ")
+      RUBY
+
+      expect(out).to include("rack, yard")
+    end
+
+    it "does not cause double loads when higher versions of default gems are activated before bundler" do
+      build_repo2 do
+        build_gem "json", "999.999.999" do |s|
+          s.write "lib/json.rb", <<~RUBY
+            module JSON
+              VERSION = "999.999.999"
+            end
+          RUBY
+        end
+      end
+
+      system_gems "json-999.999.999", :gem_repo => gem_repo2
+
+      install_gemfile "source \"#{file_uri_for(gem_repo1)}\""
+      ruby <<-RUBY
+        require "json"
+        require "bundler/setup"
+        require "json"
+      RUBY
+
+      expect(err).to be_empty
+    end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/runtime/with_unbundled_env_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/runtime/with_unbundled_env_spec.rb
@@ -1,50 +1,58 @@
 # frozen_string_literal: true
 
 RSpec.describe "Bundler.with_env helpers" do
-  def bundle_exec_ruby!(code, options = {})
+  def bundle_exec_ruby(args, options = {})
     build_bundler_context options
-    bundle! "exec '#{Gem.ruby}' -e #{code}", options
+    bundle "exec '#{Gem.ruby}' #{args}", options
   end
 
   def build_bundler_context(options = {})
     bundle "config set path vendor/bundle"
-    gemfile ""
+    gemfile "source \"#{file_uri_for(gem_repo1)}\""
     bundle "install", options
   end
 
+  def run_bundler_script(env, script)
+    system(env, "ruby", "-I#{lib_dir}", "-rbundler", script.to_s)
+  end
+
   describe "Bundler.original_env" do
     it "should return the PATH present before bundle was activated" do
-      code = "print Bundler.original_env['PATH']"
+      create_file("source.rb", <<-RUBY)
+        print Bundler.original_env["PATH"]
+      RUBY
       path = `getconf PATH`.strip + "#{File::PATH_SEPARATOR}/foo"
       with_path_as(path) do
-        bundle_exec_ruby!(code.dump)
+        bundle_exec_ruby(bundled_app("source.rb").to_s)
         expect(last_command.stdboth).to eq(path)
       end
     end
 
     it "should return the GEM_PATH present before bundle was activated" do
-      code = "print Bundler.original_env['GEM_PATH']"
-      gem_path = ENV["GEM_PATH"] + ":/foo"
+      create_file("source.rb", <<-RUBY)
+        print Bundler.original_env['GEM_PATH']
+      RUBY
+      gem_path = ENV["GEM_PATH"] + "#{File::PATH_SEPARATOR}/foo"
       with_gem_path_as(gem_path) do
-        bundle_exec_ruby!(code.dump)
+        bundle_exec_ruby(bundled_app("source.rb").to_s)
         expect(last_command.stdboth).to eq(gem_path)
       end
     end
 
-    it "works with nested bundle exec invocations" do
-      create_file("exe.rb", <<-'RB')
+    it "works with nested bundle exec invocations", :ruby_repo do
+      create_file("exe.rb", <<-'RUBY')
         count = ARGV.first.to_i
         exit if count < 0
-        STDERR.puts "#{count} #{ENV["PATH"].end_with?(":/foo")}"
+        STDERR.puts "#{count} #{ENV["PATH"].end_with?("#{File::PATH_SEPARATOR}/foo")}"
         if count == 2
-          ENV["PATH"] = "#{ENV["PATH"]}:/foo"
+          ENV["PATH"] = "#{ENV["PATH"]}#{File::PATH_SEPARATOR}/foo"
         end
         exec(Gem.ruby, __FILE__, (count - 1).to_s)
-      RB
+      RUBY
       path = `getconf PATH`.strip + File::PATH_SEPARATOR + File.dirname(Gem.ruby)
       with_path_as(path) do
         build_bundler_context
-        bundle! "exec '#{Gem.ruby}' #{bundled_app("exe.rb")} 2"
+        bundle_exec_ruby("#{bundled_app("exe.rb")} 2")
       end
       expect(err).to eq <<-EOS.strip
 2 false
@@ -57,41 +65,65 @@ RSpec.describe "Bundler.with_env helpers
       # Simulate bundler has not yet been loaded
       ENV.replace(ENV.to_hash.delete_if {|k, _v| k.start_with?(Bundler::EnvironmentPreserver::BUNDLER_PREFIX) })
 
-      original = ruby!('puts ENV.to_a.map {|e| e.join("=") }.sort.join("\n")')
-      code = 'puts Bundler.original_env.to_a.map {|e| e.join("=") }.sort.join("\n")'
-      bundle_exec_ruby! code.dump
+      original = ruby('puts ENV.to_a.map {|e| e.join("=") }.sort.join("\n")')
+      create_file("source.rb", <<-RUBY)
+        puts Bundler.original_env.to_a.map {|e| e.join("=") }.sort.join("\n")
+      RUBY
+      bundle_exec_ruby bundled_app("source.rb")
       expect(out).to eq original
     end
   end
 
   shared_examples_for "an unbundling helper" do
     it "should delete BUNDLE_PATH" do
-      code = "print #{modified_env}.has_key?('BUNDLE_PATH')"
+      create_file("source.rb", <<-RUBY)
+        print #{modified_env}.has_key?('BUNDLE_PATH')
+      RUBY
       ENV["BUNDLE_PATH"] = "./foo"
-      bundle_exec_ruby! code.dump
+      bundle_exec_ruby bundled_app("source.rb")
       expect(last_command.stdboth).to include "false"
     end
 
-    it "should remove '-rbundler/setup' from RUBYOPT" do
-      code = "print #{modified_env}['RUBYOPT']"
-      ENV["RUBYOPT"] = "-W2 -rbundler/setup #{ENV["RUBYOPT"]}"
-      bundle_exec_ruby! code.dump, :env => { "BUNDLER_SPEC_DISABLE_DEFAULT_BUNDLER_GEM" => "true" }
+    it "should remove absolute path to 'bundler/setup' from RUBYOPT even if it was present in original env" do
+      create_file("source.rb", <<-RUBY)
+        print #{modified_env}['RUBYOPT']
+      RUBY
+      setup_require = "-r#{lib_dir}/bundler/setup"
+      ENV["BUNDLER_ORIG_RUBYOPT"] = "-W2 #{setup_require} #{ENV["RUBYOPT"]}"
+      simulate_bundler_version_when_missing_prerelease_default_gem_activation do
+        bundle_exec_ruby bundled_app("source.rb")
+      end
+      expect(last_command.stdboth).not_to include(setup_require)
+    end
+
+    it "should remove relative path to 'bundler/setup' from RUBYOPT even if it was present in original env" do
+      create_file("source.rb", <<-RUBY)
+        print #{modified_env}['RUBYOPT']
+      RUBY
+      ENV["BUNDLER_ORIG_RUBYOPT"] = "-W2 -rbundler/setup #{ENV["RUBYOPT"]}"
+      simulate_bundler_version_when_missing_prerelease_default_gem_activation do
+        bundle_exec_ruby bundled_app("source.rb")
+      end
       expect(last_command.stdboth).not_to include("-rbundler/setup")
     end
 
     it "should restore RUBYLIB", :ruby_repo do
-      code = "print #{modified_env}['RUBYLIB']"
+      create_file("source.rb", <<-RUBY)
+        print #{modified_env}['RUBYLIB']
+      RUBY
       ENV["RUBYLIB"] = lib_dir.to_s + File::PATH_SEPARATOR + "/foo"
       ENV["BUNDLER_ORIG_RUBYLIB"] = lib_dir.to_s + File::PATH_SEPARATOR + "/foo-original"
-      bundle_exec_ruby! code.dump
+      bundle_exec_ruby bundled_app("source.rb")
       expect(last_command.stdboth).to include("/foo-original")
     end
 
     it "should restore the original MANPATH" do
-      code = "print #{modified_env}['MANPATH']"
+      create_file("source.rb", <<-RUBY)
+        print #{modified_env}['MANPATH']
+      RUBY
       ENV["MANPATH"] = "/foo"
       ENV["BUNDLER_ORIG_MANPATH"] = "/foo-original"
-      bundle_exec_ruby! code.dump
+      bundle_exec_ruby bundled_app("source.rb")
       expect(last_command.stdboth).to include("/foo-original")
     end
   end
@@ -111,7 +143,7 @@ RSpec.describe "Bundler.with_env helpers
   describe "Bundler.with_original_env" do
     it "should set ENV to original_env in the block" do
       expected = Bundler.original_env
-      actual = Bundler.with_original_env { ENV.to_hash }
+      actual = Bundler.with_original_env { Bundler::EnvironmentPreserver.env_to_hash(ENV) }
       expect(actual).to eq(expected)
     end
 
@@ -129,7 +161,7 @@ RSpec.describe "Bundler.with_env helpers
       expected = Bundler.unbundled_env
 
       actual = Bundler.ui.silence do
-        Bundler.with_clean_env { ENV.to_hash }
+        Bundler.with_clean_env { Bundler::EnvironmentPreserver.env_to_hash(ENV) }
       end
 
       expect(actual).to eq(expected)
@@ -147,7 +179,7 @@ RSpec.describe "Bundler.with_env helpers
   describe "Bundler.with_unbundled_env" do
     it "should set ENV to unbundled_env in the block" do
       expected = Bundler.unbundled_env
-      actual = Bundler.with_unbundled_env { ENV.to_hash }
+      actual = Bundler.with_unbundled_env { Bundler::EnvironmentPreserver.env_to_hash(ENV) }
       expect(actual).to eq(expected)
     end
 
@@ -161,53 +193,53 @@ RSpec.describe "Bundler.with_env helpers
   end
 
   describe "Bundler.original_system" do
-    let(:code) do
-      <<~RUBY
-        Bundler.original_system(%([ "\$BUNDLE_FOO" = "bar" ] && exit 42))
+    before do
+      create_file("source.rb", <<-'RUBY')
+        Bundler.original_system("ruby", "-e", "exit(42) if ENV['BUNDLE_FOO'] == 'bar'")
 
         exit $?.exitstatus
       RUBY
     end
 
     it "runs system inside with_original_env" do
-      system({ "BUNDLE_FOO" => "bar" }, "ruby -I#{lib_dir} -rbundler -e '#{code}'")
+      run_bundler_script({ "BUNDLE_FOO" => "bar" }, bundled_app("source.rb"))
       expect($?.exitstatus).to eq(42)
     end
   end
 
   describe "Bundler.clean_system", :bundler => 2 do
-    let(:code) do
-      <<~RUBY
-        Bundler.ui.silence { Bundler.clean_system(%([ "\$BUNDLE_FOO" = "bar" ] || exit 42)) }
+    before do
+      create_file("source.rb", <<-'RUBY')
+        Bundler.ui.silence { Bundler.clean_system("ruby", "-e", "exit(42) unless ENV['BUNDLE_FOO'] == 'bar'") }
 
         exit $?.exitstatus
       RUBY
     end
 
     it "runs system inside with_clean_env" do
-      system({ "BUNDLE_FOO" => "bar" }, "ruby -I#{lib_dir} -rbundler -e '#{code}'")
+      run_bundler_script({ "BUNDLE_FOO" => "bar" }, bundled_app("source.rb"))
       expect($?.exitstatus).to eq(42)
     end
   end
 
   describe "Bundler.unbundled_system" do
-    let(:code) do
-      <<~RUBY
-        Bundler.unbundled_system(%([ "\$BUNDLE_FOO" = "bar" ] || exit 42))
+    before do
+      create_file("source.rb", <<-'RUBY')
+        Bundler.unbundled_system("ruby", "-e", "exit(42) unless ENV['BUNDLE_FOO'] == 'bar'")
 
         exit $?.exitstatus
       RUBY
     end
 
     it "runs system inside with_unbundled_env" do
-      system({ "BUNDLE_FOO" => "bar" }, "ruby -I#{lib_dir} -rbundler -e '#{code}'")
+      run_bundler_script({ "BUNDLE_FOO" => "bar" }, bundled_app("source.rb"))
       expect($?.exitstatus).to eq(42)
     end
   end
 
   describe "Bundler.original_exec" do
-    let(:code) do
-      <<~RUBY
+    before do
+      create_file("source.rb", <<-'RUBY')
         Process.fork do
           exit Bundler.original_exec(%(test "\$BUNDLE_FOO" = "bar"))
         end
@@ -221,14 +253,14 @@ RSpec.describe "Bundler.with_env helpers
     it "runs exec inside with_original_env" do
       skip "Fork not implemented" if Gem.win_platform?
 
-      system({ "BUNDLE_FOO" => "bar" }, "ruby -I#{lib_dir} -rbundler -e '#{code}'")
+      run_bundler_script({ "BUNDLE_FOO" => "bar" }, bundled_app("source.rb"))
       expect($?.exitstatus).to eq(0)
     end
   end
 
   describe "Bundler.clean_exec", :bundler => 2 do
-    let(:code) do
-      <<~RUBY
+    before do
+      create_file("source.rb", <<-'RUBY')
         Process.fork do
           exit Bundler.ui.silence { Bundler.clean_exec(%(test "\$BUNDLE_FOO" = "bar")) }
         end
@@ -242,14 +274,14 @@ RSpec.describe "Bundler.with_env helpers
     it "runs exec inside with_clean_env" do
       skip "Fork not implemented" if Gem.win_platform?
 
-      system({ "BUNDLE_FOO" => "bar" }, "ruby -I#{lib_dir} -rbundler -e '#{code}'")
+      run_bundler_script({ "BUNDLE_FOO" => "bar" }, bundled_app("source.rb"))
       expect($?.exitstatus).to eq(1)
     end
   end
 
   describe "Bundler.unbundled_exec" do
-    let(:code) do
-      <<~RUBY
+    before do
+      create_file("source.rb", <<-'RUBY')
         Process.fork do
           exit Bundler.unbundled_exec(%(test "\$BUNDLE_FOO" = "bar"))
         end
@@ -263,7 +295,7 @@ RSpec.describe "Bundler.with_env helpers
     it "runs exec inside with_clean_env" do
       skip "Fork not implemented" if Gem.win_platform?
 
-      system({ "BUNDLE_FOO" => "bar" }, "ruby -I#{lib_dir} -rbundler -e '#{code}'")
+      run_bundler_script({ "BUNDLE_FOO" => "bar" }, bundled_app("source.rb"))
       expect($?.exitstatus).to eq(1)
     end
   end
--- ruby2.7-2.7.6.orig/spec/bundler/spec_helper.rb
+++ ruby2.7-2.7.6/spec/bundler/spec_helper.rb
@@ -1,11 +1,6 @@
 # frozen_string_literal: true
 
-require_relative "support/path"
-
-$:.unshift Spec::Path.spec_dir.to_s
-$:.unshift Spec::Path.lib_dir.to_s
-
-require "bundler/psyched_yaml"
+require "psych"
 require "bundler/vendored_fileutils"
 require "bundler/vendored_uri"
 require "digest"
@@ -15,17 +10,19 @@ if File.expand_path(__FILE__) =~ %r{([^\
 end
 
 require "bundler"
-require "rspec"
+require "rspec/core"
+require "rspec/expectations"
+require "rspec/mocks"
+require "rspec/support/differ"
 
 require_relative "support/builders"
+require_relative "support/build_metadata"
 require_relative "support/filters"
 require_relative "support/helpers"
 require_relative "support/indexes"
 require_relative "support/matchers"
-require_relative "support/parallel"
 require_relative "support/permissions"
 require_relative "support/platforms"
-require_relative "support/sometimes"
 require_relative "support/sudo"
 
 $debug = false
@@ -49,6 +46,8 @@ RSpec.configure do |config|
   # Enable flags like --only-failures and --next-failure
   config.example_status_persistence_file_path = ".rspec_status"
 
+  config.silence_filter_announcements = !ENV["TEST_ENV_NUMBER"].nil?
+
   config.disable_monkey_patching!
 
   # Since failures cause us to keep a bunch of long strings in memory, stop
@@ -59,9 +58,6 @@ RSpec.configure do |config|
 
   config.bisect_runner = :shell
 
-  original_wd  = Dir.pwd
-  original_env = ENV.to_hash
-
   config.expect_with :rspec do |c|
     c.syntax = :expect
   end
@@ -70,61 +66,60 @@ RSpec.configure do |config|
     mocks.allow_message_expectations_on_nil = false
   end
 
-  config.around :each do |example|
-    if ENV["RUBY"]
-      orig_ruby = Gem.ruby
-      Gem.ruby = ENV["RUBY"]
-    end
-    example.run
-    Gem.ruby = orig_ruby if ENV["RUBY"]
-  end
-
   config.before :suite do
+    Gem.ruby = ENV["RUBY"] if ENV["RUBY"]
+
     require_relative "support/rubygems_ext"
-    Spec::Rubygems.setup
-    ENV["RUBYOPT"] = "#{ENV["RUBYOPT"]} -r#{Spec::Path.spec_dir}/support/hax.rb"
-    ENV["BUNDLE_SPEC_RUN"] = "true"
+    Spec::Rubygems.test_setup
+    ENV["BUNDLER_SPEC_RUN"] = "true"
+    ENV["BUNDLER_NO_OLD_RUBYGEMS_WARNING"] = "true"
     ENV["BUNDLE_USER_CONFIG"] = ENV["BUNDLE_USER_CACHE"] = ENV["BUNDLE_USER_PLUGIN"] = nil
+    ENV["BUNDLE_APP_CONFIG"] = nil
+    ENV["BUNDLE_SILENCE_ROOT_WARNING"] = nil
+    ENV["RUBYGEMS_GEMDEPS"] = nil
+    ENV["XDG_CONFIG_HOME"] = nil
     ENV["GEMRC"] = nil
 
     # Don't wrap output in tests
     ENV["THOR_COLUMNS"] = "10000"
 
-    original_env = ENV.to_hash
-
-    if ENV["RUBY"]
-      FileUtils.cp_r Spec::Path.bindir, File.join(Spec::Path.root, "lib", "exe")
-    end
+    extend(Spec::Helpers)
+    system_gems :bundler, :path => pristine_system_gem_path
   end
 
   config.before :all do
+    check_test_gems!
+
     build_repo1
+
+    reset_paths!
   end
 
   config.around :each do |example|
-    ENV.replace(original_env)
-    reset!
-    system_gems []
-    in_app_root
-    @command_executions = []
-
-    Bundler.ui.silence { example.run }
-
-    all_output = @command_executions.map(&:to_s_verbose).join("\n\n")
-    if example.exception && !all_output.empty?
-      warn all_output unless config.formatters.grep(RSpec::Core::Formatters::DocumentationFormatter).empty?
-      message = example.exception.message + "\n\nCommands:\n#{all_output}"
-      (class << example.exception; self; end).send(:define_method, :message) do
-        message
+    begin
+      FileUtils.cp_r pristine_system_gem_path, system_gem_path
+
+      with_gem_path_as(system_gem_path) do
+        Bundler.ui.silence { example.run }
+
+        all_output = all_commands_output
+        if example.exception && !all_output.empty?
+          message = all_output + "\n" + example.exception.message
+          (class << example.exception; self; end).send(:define_method, :message) do
+            message
+          end
+        end
       end
+    ensure
+      reset!
     end
+  end
 
-    Dir.chdir(original_wd)
+  config.before :each, :sudo => true do
+    Spec::Sudo.write_safe_config
   end
 
   config.after :suite do
-    if ENV["RUBY"]
-      FileUtils.rm_rf File.join(Spec::Path.root, "lib", "exe")
-    end
+    FileUtils.rm_r Spec::Path.pristine_system_gem_path
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/support/api_request_limit_hax.rb
@@ -0,0 +1,16 @@
+# frozen_string_literal: true
+
+if ENV["BUNDLER_SPEC_API_REQUEST_LIMIT"]
+  require_relative "path"
+  require "bundler/source"
+  require "bundler/source/rubygems"
+
+  module Bundler
+    class Source
+      class Rubygems < Source
+        remove_const :API_REQUEST_LIMIT
+        API_REQUEST_LIMIT = ENV["BUNDLER_SPEC_API_REQUEST_LIMIT"].to_i
+      end
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/compact_index.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/compact_index.rb
@@ -2,11 +2,13 @@
 
 require_relative "endpoint"
 
-$LOAD_PATH.unshift Dir[base_system_gems.join("gems/compact_index*/lib")].first.to_s
+$LOAD_PATH.unshift Dir[Spec::Path.base_system_gem_path.join("gems/compact_index*/lib")].first.to_s
 require "compact_index"
 
 class CompactIndexAPI < Endpoint
   helpers do
+    include Spec::Path
+
     def load_spec(name, version, platform, gem_repo)
       full_name = "#{name}-#{version}"
       full_name += "-#{platform}" if platform != "ruby"
@@ -60,7 +62,7 @@ class CompactIndexAPI < Endpoint
       body.byteslice(range)
     end
 
-    def gems(gem_repo = GEM_REPO)
+    def gems(gem_repo = default_gem_repo)
       @gems ||= {}
       @gems[gem_repo] ||= begin
         specs = Bundler::Deprecate.skip_during do
@@ -78,12 +80,12 @@ class CompactIndexAPI < Endpoint
               CompactIndex::Dependency.new(d.name, reqs)
             end
             checksum = begin
-                         Digest(:SHA256).file("#{GEM_REPO}/gems/#{spec.original_name}.gem").base64digest
+                         Digest(:SHA256).file("#{gem_repo}/gems/#{spec.original_name}.gem").base64digest
                        rescue StandardError
                          nil
                        end
             CompactIndex::GemVersion.new(spec.version.version, spec.platform.to_s, checksum, nil,
-              deps, spec.required_ruby_version, spec.required_rubygems_version)
+              deps, spec.required_ruby_version.to_s, spec.required_rubygems_version.to_s)
           end
           CompactIndex::Gem.new(name, gem_versions)
         end
@@ -100,7 +102,7 @@ class CompactIndexAPI < Endpoint
   get "/versions" do
     etag_response do
       file = tmp("versions.list")
-      file.delete if file.file?
+      FileUtils.rm_f(file)
       file = CompactIndex::VersionsFile.new(file.to_s)
       file.create(gems)
       file.contents
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/compact_index_api_missing.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/compact_index_api_missing.rb
@@ -6,12 +6,7 @@ Artifice.deactivate
 
 class CompactIndexApiMissing < CompactIndexAPI
   get "/fetch/actual/gem/:id" do
-    warn params[:id]
-    if params[:id] == "rack-1.0.gemspec.rz"
-      halt 404
-    else
-      File.binread("#{gem_repo2}/quick/Marshal.4.8/#{params[:id]}")
-    end
+    halt 404
   end
 end
 
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/compact_index_concurrent_download.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/compact_index_concurrent_download.rb
@@ -10,7 +10,7 @@ class CompactIndexConcurrentDownload < C
       "localgemserver.test.80.dd34752a738ee965a2a4298dc16db6c5", "versions")
 
     # Verify the original (empty) content hasn't been deleted, e.g. on a retry
-    File.read(versions) == "" || raise("Original file should be present and empty")
+    File.binread(versions) == "" || raise("Original file should be present and empty")
 
     # Verify this is only requested once for a partial download
     env["HTTP_RANGE"] || raise("Missing Range header for expected partial download")
@@ -21,7 +21,7 @@ class CompactIndexConcurrentDownload < C
 
     etag_response do
       file = tmp("versions.list")
-      file.delete if file.file?
+      FileUtils.rm_f(file)
       file = CompactIndex::VersionsFile.new(file.to_s)
       file.create(gems)
       file.contents
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/compact_index_creds_diff_host.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/compact_index_creds_diff_host.rb
@@ -31,7 +31,7 @@ class CompactIndexCredsDiffHost < Compac
 
   get "/no/creds/:id" do
     if request.host.include?("diffhost") && !auth.provided?
-      File.read("#{gem_repo1}/gems/#{params[:id]}")
+      File.binread("#{gem_repo1}/gems/#{params[:id]}")
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/compact_index_extra.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/compact_index_extra.rb
@@ -14,11 +14,11 @@ class CompactIndexExtra < CompactIndexAP
   end
 
   get "/extra/specs.4.8.gz" do
-    File.read("#{gem_repo2}/specs.4.8.gz")
+    File.binread("#{gem_repo2}/specs.4.8.gz")
   end
 
   get "/extra/prerelease_specs.4.8.gz" do
-    File.read("#{gem_repo2}/prerelease_specs.4.8.gz")
+    File.binread("#{gem_repo2}/prerelease_specs.4.8.gz")
   end
 
   get "/extra/quick/Marshal.4.8/:id" do
@@ -26,11 +26,11 @@ class CompactIndexExtra < CompactIndexAP
   end
 
   get "/extra/fetch/actual/gem/:id" do
-    File.read("#{gem_repo2}/quick/Marshal.4.8/#{params[:id]}")
+    File.binread("#{gem_repo2}/quick/Marshal.4.8/#{params[:id]}")
   end
 
   get "/extra/gems/:id" do
-    File.read("#{gem_repo2}/gems/#{params[:id]}")
+    File.binread("#{gem_repo2}/gems/#{params[:id]}")
   end
 end
 
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/compact_index_extra_api.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/compact_index_extra_api.rb
@@ -14,7 +14,7 @@ class CompactIndexExtraApi < CompactInde
   get "/extra/versions" do
     etag_response do
       file = tmp("versions.list")
-      file.delete if file.file?
+      FileUtils.rm_f(file)
       file = CompactIndex::VersionsFile.new(file.to_s)
       file.create(gems(gem_repo4))
       file.contents
@@ -29,11 +29,11 @@ class CompactIndexExtraApi < CompactInde
   end
 
   get "/extra/specs.4.8.gz" do
-    File.read("#{gem_repo4}/specs.4.8.gz")
+    File.binread("#{gem_repo4}/specs.4.8.gz")
   end
 
   get "/extra/prerelease_specs.4.8.gz" do
-    File.read("#{gem_repo4}/prerelease_specs.4.8.gz")
+    File.binread("#{gem_repo4}/prerelease_specs.4.8.gz")
   end
 
   get "/extra/quick/Marshal.4.8/:id" do
@@ -41,11 +41,11 @@ class CompactIndexExtraApi < CompactInde
   end
 
   get "/extra/fetch/actual/gem/:id" do
-    File.read("#{gem_repo4}/quick/Marshal.4.8/#{params[:id]}")
+    File.binread("#{gem_repo4}/quick/Marshal.4.8/#{params[:id]}")
   end
 
   get "/extra/gems/:id" do
-    File.read("#{gem_repo4}/gems/#{params[:id]}")
+    File.binread("#{gem_repo4}/gems/#{params[:id]}")
   end
 end
 
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/compact_index_partial_update.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/compact_index_partial_update.rb
@@ -18,19 +18,19 @@ class CompactIndexPartialUpdate < Compac
     )
 
     # Verify a cached copy of the versions file exists
-    unless File.read(cached_versions_path).start_with?("created_at: ")
+    unless File.binread(cached_versions_path).start_with?("created_at: ")
       raise("Cached versions file should be present and have content")
     end
 
     # Verify that a partial request is made, starting from the index of the
     # final byte of the cached file.
-    unless env["HTTP_RANGE"] == "bytes=#{File.read(cached_versions_path).bytesize - 1}-"
+    unless env["HTTP_RANGE"] == "bytes=#{File.binread(cached_versions_path).bytesize - 1}-"
       raise("Range header should be present, and start from the index of the final byte of the cache.")
     end
 
     etag_response do
       # Return the exact contents of the cache.
-      File.read(cached_versions_path)
+      File.binread(cached_versions_path)
     end
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/compact_index_partial_update_no_etag_not_incremental.rb
@@ -0,0 +1,40 @@
+# frozen_string_literal: true
+
+require_relative "compact_index"
+
+Artifice.deactivate
+
+class CompactIndexPartialUpdateNoEtagNotIncremental < CompactIndexAPI
+  def partial_update_no_etag
+    response_body = yield
+    headers "Surrogate-Control" => "max-age=2592000, stale-while-revalidate=60"
+    content_type "text/plain"
+    requested_range_for(response_body)
+  end
+
+  get "/versions" do
+    partial_update_no_etag do
+      file = tmp("versions.list")
+      FileUtils.rm_f(file)
+      file = CompactIndex::VersionsFile.new(file.to_s)
+      file.create(gems)
+      lines = file.contents([], :calculate_info_checksums => true).split("\n")
+      name, versions, checksum = lines.last.split(" ")
+
+      # shuffle versions so new versions are not appended to the end
+      [*lines[0..-2], [name, versions.split(",").reverse.join(","), checksum].join(" ")].join("\n")
+    end
+  end
+
+  get "/info/:name" do
+    partial_update_no_etag do
+      gem = gems.find {|g| g.name == params[:name] }
+      lines = CompactIndex.info(gem ? gem.versions : []).split("\n")
+
+      # shuffle versions so new versions are not appended to the end
+      [lines.first, lines.last, *lines[1..-2]].join("\n")
+    end
+  end
+end
+
+Artifice.activate_with(CompactIndexPartialUpdateNoEtagNotIncremental)
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/compact_index_range_not_satisfiable.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/compact_index_range_not_satisfiable.rb
@@ -11,7 +11,7 @@ class CompactIndexRangeNotSatisfiable < 
     else
       etag_response do
         file = tmp("versions.list")
-        file.delete if file.file?
+        FileUtils.rm_f(file)
         file = CompactIndex::VersionsFile.new(file.to_s)
         file.create(gems)
         file.contents
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/compact_index_rate_limited.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/compact_index_rate_limited.rb
@@ -7,7 +7,7 @@ Artifice.deactivate
 class CompactIndexRateLimited < CompactIndexAPI
   class RequestCounter
     def self.queue
-      @queue ||= Queue.new
+      @queue ||= Thread::Queue.new
     end
 
     def self.size
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/endopint_marshal_fail_basic_authentication.rb
+++ /dev/null
@@ -1,15 +0,0 @@
-# frozen_string_literal: true
-
-require_relative "endpoint_marshal_fail"
-
-Artifice.deactivate
-
-class EndpointMarshalFailBasicAuthentication < EndpointMarshalFail
-  before do
-    unless env["HTTP_AUTHORIZATION"]
-      halt 401, "Authentication info not supplied"
-    end
-  end
-end
-
-Artifice.activate_with(EndpointMarshalFailBasicAuthentication)
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/endpoint.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/endpoint.rb
@@ -1,16 +1,14 @@
 # frozen_string_literal: true
 
 require_relative "../path"
-require Spec::Path.lib_dir.join("bundler/deprecate")
-include Spec::Path
 
-$LOAD_PATH.unshift(*Dir[Spec::Path.base_system_gems.join("gems/{artifice,mustermann,rack,tilt,sinatra}-*/lib")].map(&:to_s))
+$LOAD_PATH.unshift(*Dir[Spec::Path.base_system_gem_path.join("gems/{artifice,mustermann,rack,tilt,sinatra,ruby2_keywords}-*/lib")].map(&:to_s))
 
 require "artifice"
 require "sinatra/base"
 
 ALL_REQUESTS = [] # rubocop:disable Style/MutableConstant
-ALL_REQUESTS_MUTEX = Mutex.new
+ALL_REQUESTS_MUTEX = Thread::Mutex.new
 
 at_exit do
   if expected = ENV["BUNDLER_SPEC_ALL_REQUESTS"]
@@ -28,7 +26,6 @@ class Endpoint < Sinatra::Base
     @all_requests ||= []
   end
 
-  GEM_REPO = Pathname.new(ENV["BUNDLER_SPEC_GEM_REPO"] || Spec::Path.gem_repo1)
   set :raise_errors, true
   set :show_exceptions, false
 
@@ -41,30 +38,48 @@ class Endpoint < Sinatra::Base
   end
 
   helpers do
-    def dependencies_for(gem_names, gem_repo = GEM_REPO)
-      return [] if gem_names.nil? || gem_names.empty?
+    include Spec::Path
 
-      require "#{Spec::Path.lib_dir}/bundler"
-      Bundler::Deprecate.skip_during do
-        all_specs = %w[specs.4.8 prerelease_specs.4.8].map do |filename|
-          Marshal.load(File.open(gem_repo.join(filename)).read)
-        end.inject(:+)
-
-        all_specs.map do |name, version, platform|
-          spec = load_spec(name, version, platform, gem_repo)
-          next unless gem_names.include?(spec.name)
-          {
-            :name         => spec.name,
-            :number       => spec.version.version,
-            :platform     => spec.platform.to_s,
-            :dependencies => spec.dependencies.select {|dep| dep.type == :runtime }.map do |dep|
-              [dep.name, dep.requirement.requirements.map {|a| a.join(" ") }.join(", ")]
-            end,
-          }
-        end.compact
+    def default_gem_repo
+      if ENV["BUNDLER_SPEC_GEM_REPO"]
+        Pathname.new(ENV["BUNDLER_SPEC_GEM_REPO"])
+      else
+        case request.host
+        when "gem.repo1"
+          Spec::Path.gem_repo1
+        when "gem.repo2"
+          Spec::Path.gem_repo2
+        when "gem.repo3"
+          Spec::Path.gem_repo3
+        when "gem.repo4"
+          Spec::Path.gem_repo4
+        else
+          Spec::Path.gem_repo1
+        end
       end
     end
 
+    def dependencies_for(gem_names, gem_repo = default_gem_repo)
+      return [] if gem_names.nil? || gem_names.empty?
+
+      all_specs = %w[specs.4.8 prerelease_specs.4.8].map do |filename|
+        Marshal.load(File.open(gem_repo.join(filename)).read)
+      end.inject(:+)
+
+      all_specs.map do |name, version, platform|
+        spec = load_spec(name, version, platform, gem_repo)
+        next unless gem_names.include?(spec.name)
+        {
+          :name         => spec.name,
+          :number       => spec.version.version,
+          :platform     => spec.platform.to_s,
+          :dependencies => spec.dependencies.select {|dep| dep.type == :runtime }.map do |dep|
+            [dep.name, dep.requirement.requirements.map {|a| a.join(" ") }.join(", ")]
+          end,
+        }
+      end.compact
+    end
+
     def load_spec(name, version, platform, gem_repo)
       full_name = "#{name}-#{version}"
       full_name += "-#{platform}" if platform != "ruby"
@@ -77,11 +92,11 @@ class Endpoint < Sinatra::Base
   end
 
   get "/fetch/actual/gem/:id" do
-    File.read("#{GEM_REPO}/quick/Marshal.4.8/#{params[:id]}")
+    File.binread("#{default_gem_repo}/quick/Marshal.4.8/#{params[:id]}")
   end
 
   get "/gems/:id" do
-    File.read("#{GEM_REPO}/gems/#{params[:id]}")
+    File.binread("#{default_gem_repo}/gems/#{params[:id]}")
   end
 
   get "/api/v1/dependencies" do
@@ -89,11 +104,11 @@ class Endpoint < Sinatra::Base
   end
 
   get "/specs.4.8.gz" do
-    File.read("#{GEM_REPO}/specs.4.8.gz")
+    File.binread("#{default_gem_repo}/specs.4.8.gz")
   end
 
   get "/prerelease_specs.4.8.gz" do
-    File.read("#{GEM_REPO}/prerelease_specs.4.8.gz")
+    File.binread("#{default_gem_repo}/prerelease_specs.4.8.gz")
   end
 end
 
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/endpoint_500.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/endpoint_500.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
 
 require_relative "../path"
-include Spec::Path
 
-$LOAD_PATH.unshift(*Dir[Spec::Path.base_system_gems.join("gems/{artifice,mustermann,rack,tilt,sinatra}-*/lib")].map(&:to_s))
+$LOAD_PATH.unshift(*Dir[Spec::Path.base_system_gem_path.join("gems/{artifice,mustermann,rack,tilt,sinatra,ruby2_keywords}-*/lib")].map(&:to_s))
 
 require "artifice"
 require "sinatra/base"
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/endpoint_api_missing.rb
+++ /dev/null
@@ -1,18 +0,0 @@
-# frozen_string_literal: true
-
-require_relative "endpoint"
-
-Artifice.deactivate
-
-class EndpointApiMissing < Endpoint
-  get "/fetch/actual/gem/:id" do
-    warn params[:id]
-    if params[:id] == "rack-1.0.gemspec.rz"
-      halt 404
-    else
-      File.binread("#{gem_repo2}/quick/Marshal.4.8/#{params[:id]}")
-    end
-  end
-end
-
-Artifice.activate_with(EndpointApiMissing)
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/endpoint_creds_diff_host.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/endpoint_creds_diff_host.rb
@@ -31,7 +31,7 @@ class EndpointCredsDiffHost < Endpoint
 
   get "/no/creds/:id" do
     if request.host.include?("diffhost") && !auth.provided?
-      File.read("#{gem_repo1}/gems/#{params[:id]}")
+      File.binread("#{gem_repo1}/gems/#{params[:id]}")
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/endpoint_extra.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/endpoint_extra.rb
@@ -10,11 +10,11 @@ class EndpointExtra < Endpoint
   end
 
   get "/extra/specs.4.8.gz" do
-    File.read("#{gem_repo2}/specs.4.8.gz")
+    File.binread("#{gem_repo2}/specs.4.8.gz")
   end
 
   get "/extra/prerelease_specs.4.8.gz" do
-    File.read("#{gem_repo2}/prerelease_specs.4.8.gz")
+    File.binread("#{gem_repo2}/prerelease_specs.4.8.gz")
   end
 
   get "/extra/quick/Marshal.4.8/:id" do
@@ -22,11 +22,11 @@ class EndpointExtra < Endpoint
   end
 
   get "/extra/fetch/actual/gem/:id" do
-    File.read("#{gem_repo2}/quick/Marshal.4.8/#{params[:id]}")
+    File.binread("#{gem_repo2}/quick/Marshal.4.8/#{params[:id]}")
   end
 
   get "/extra/gems/:id" do
-    File.read("#{gem_repo2}/gems/#{params[:id]}")
+    File.binread("#{gem_repo2}/gems/#{params[:id]}")
   end
 end
 
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/endpoint_extra_api.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/endpoint_extra_api.rb
@@ -11,11 +11,11 @@ class EndpointExtraApi < Endpoint
   end
 
   get "/extra/specs.4.8.gz" do
-    File.read("#{gem_repo4}/specs.4.8.gz")
+    File.binread("#{gem_repo4}/specs.4.8.gz")
   end
 
   get "/extra/prerelease_specs.4.8.gz" do
-    File.read("#{gem_repo4}/prerelease_specs.4.8.gz")
+    File.binread("#{gem_repo4}/prerelease_specs.4.8.gz")
   end
 
   get "/extra/quick/Marshal.4.8/:id" do
@@ -23,11 +23,11 @@ class EndpointExtraApi < Endpoint
   end
 
   get "/extra/fetch/actual/gem/:id" do
-    File.read("#{gem_repo4}/quick/Marshal.4.8/#{params[:id]}")
+    File.binread("#{gem_repo4}/quick/Marshal.4.8/#{params[:id]}")
   end
 
   get "/extra/gems/:id" do
-    File.read("#{gem_repo4}/gems/#{params[:id]}")
+    File.binread("#{gem_repo4}/gems/#{params[:id]}")
   end
 end
 
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/endpoint_marshal_fail_basic_authentication.rb
@@ -0,0 +1,15 @@
+# frozen_string_literal: true
+
+require_relative "endpoint_marshal_fail"
+
+Artifice.deactivate
+
+class EndpointMarshalFailBasicAuthentication < EndpointMarshalFail
+  before do
+    unless env["HTTP_AUTHORIZATION"]
+      halt 401, "Authentication info not supplied"
+    end
+  end
+end
+
+Artifice.activate_with(EndpointMarshalFailBasicAuthentication)
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/endpoint_mirror_source.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/endpoint_mirror_source.rb
@@ -5,7 +5,7 @@ require_relative "endpoint"
 class EndpointMirrorSource < Endpoint
   get "/gems/:id" do
     if request.env["HTTP_X_GEMFILE_SOURCE"] == "https://server.example.org/"
-      File.read("#{gem_repo1}/gems/#{params[:id]}")
+      File.binread("#{gem_repo1}/gems/#{params[:id]}")
     else
       halt 500
     end
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/fail.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/fail.rb
@@ -1,11 +1,6 @@
 # frozen_string_literal: true
 
 require "net/http"
-begin
-  require "net/https"
-rescue LoadError
-  nil # net/https or openssl
-end
 
 # We can't use artifice here because it uses rack
 
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/vcr.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/vcr.rb
@@ -31,7 +31,6 @@ class BundlerVCRHTTP < Net::HTTP
 
     def recorded_response?
       return true if ENV["BUNDLER_SPEC_PRE_RECORDED"]
-      return false if ENV["BUNDLER_SPEC_FORCE_RECORD"]
       request_pair_paths.all? {|f| File.exist?(f) }
     end
 
@@ -40,7 +39,7 @@ class BundlerVCRHTTP < Net::HTTP
         response_io = ::Net::BufferedIO.new(response_file)
         ::Net::HTTPResponse.read_new(response_io).tap do |response|
           response.decode_content = request.decode_content if request.respond_to?(:decode_content)
-          response.uri = request.uri if request.respond_to?(:uri)
+          response.uri = request.uri
 
           response.reading_body(response_io, request.response_body_permitted?) do
             response_block.call(response) if response_block
@@ -57,6 +56,7 @@ class BundlerVCRHTTP < Net::HTTP
       response = http.request_without_vcr(request, body, &response_block)
       @recording = false
       unless @recording
+        require "fileutils"
         FileUtils.mkdir_p(File.dirname(request_path))
         binwrite(request_path, request_to_string(request))
         binwrite(response_path, response_to_string(response))
@@ -69,7 +69,7 @@ class BundlerVCRHTTP < Net::HTTP
     end
 
     def file_name_for_key(key)
-      key.join("/").gsub(/[\:*?"<>|]/, "-")
+      File.join(*key).gsub(/[\:*?"<>|]/, "-")
     end
 
     def request_pair_paths
@@ -79,7 +79,7 @@ class BundlerVCRHTTP < Net::HTTP
     end
 
     def read_stored_request(path)
-      contents = File.read(path)
+      contents = File.binread(path)
       headers = {}
       method = nil
       path = nil
@@ -133,6 +133,19 @@ class BundlerVCRHTTP < Net::HTTP
     end
   end
 
+  def start_with_vcr
+    if ENV["BUNDLER_SPEC_PRE_RECORDED"]
+      raise IOError, "HTTP session already opened" if @started
+      @socket = nil
+      @started = true
+    else
+      start_without_vcr
+    end
+  end
+
+  alias_method :start_without_vcr, :start
+  alias_method :start, :start_with_vcr
+
   def request_with_vcr(request, *args, &block)
     handler = request.instance_eval do
       remove_instance_variable(:@__vcr_request_handler) if defined?(@__vcr_request_handler)
--- ruby2.7-2.7.6.orig/spec/bundler/support/artifice/windows.rb
+++ ruby2.7-2.7.6/spec/bundler/support/artifice/windows.rb
@@ -1,9 +1,8 @@
 # frozen_string_literal: true
 
 require_relative "../path"
-include Spec::Path
 
-$LOAD_PATH.unshift(*Dir[Spec::Path.base_system_gems.join("gems/{artifice,mustermann,rack,tilt,sinatra}-*/lib")].map(&:to_s))
+$LOAD_PATH.unshift(*Dir[Spec::Path.base_system_gem_path.join("gems/{artifice,mustermann,rack,tilt,sinatra,ruby2_keywords}-*/lib")].map(&:to_s))
 
 require "artifice"
 require "sinatra/base"
@@ -15,7 +14,7 @@ class Windows < Sinatra::Base
   set :show_exceptions, false
 
   helpers do
-    def gem_repo
+    def default_gem_repo
       Pathname.new(ENV["BUNDLER_SPEC_GEM_REPO"] || Spec::Path.gem_repo1)
     end
   end
@@ -27,7 +26,7 @@ class Windows < Sinatra::Base
 
   files.each do |file|
     get "/#{file}" do
-      File.binread gem_repo.join(file)
+      File.binread default_gem_repo.join(file)
     end
   end
 
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/support/build_metadata.rb
@@ -0,0 +1,49 @@
+# frozen_string_literal: true
+
+require_relative "path"
+require_relative "helpers"
+
+module Spec
+  module BuildMetadata
+    include Spec::Path
+    include Spec::Helpers
+
+    def write_build_metadata(dir: source_root)
+      build_metadata = {
+        :git_commit_sha => git_commit_sha,
+        :built_at => loaded_gemspec.date.utc.strftime("%Y-%m-%d"),
+        :release => true,
+      }
+
+      replace_build_metadata(build_metadata, dir: dir) # rubocop:disable Style/HashSyntax
+    end
+
+    def reset_build_metadata(dir: source_root)
+      build_metadata = {
+        :release => false,
+      }
+
+      replace_build_metadata(build_metadata, dir: dir) # rubocop:disable Style/HashSyntax
+    end
+
+    private
+
+    def replace_build_metadata(build_metadata, dir:)
+      build_metadata_file = File.expand_path("lib/bundler/build_metadata.rb", dir)
+
+      ivars = build_metadata.sort.map do |k, v|
+        "    @#{k} = #{loaded_gemspec.send(:ruby_code, v)}"
+      end.join("\n")
+
+      contents = File.read(build_metadata_file)
+      contents.sub!(/^(\s+# begin ivars).+(^\s+# end ivars)/m, "\\1\n#{ivars}\n\\2")
+      File.open(build_metadata_file, "w") {|f| f << contents }
+    end
+
+    def git_commit_sha
+      ruby_core_tarball? ? "unknown" : sys_exec("git rev-parse --short HEAD", :dir => source_root).strip
+    end
+
+    extend self
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/support/builders.rb
+++ ruby2.7-2.7.6/spec/bundler/support/builders.rb
@@ -17,8 +17,29 @@ module Spec
       Gem::Platform.new(platform)
     end
 
+    # Returns a number smaller than the size of the index. Useful for specs that
+    # need the API request limit to be reached for some reason.
+    def low_api_request_limit_for(gem_repo)
+      all_gems = Dir[gem_repo.join("gems/*.gem")]
+
+      all_gem_names = all_gems.map do |file|
+        File.basename(file, ".gem").match(/\A(?<gem_name>[^-]+)-.*\z/)[:gem_name]
+      end.uniq
+
+      (all_gem_names - ["bundler"]).size
+    end
+
     def build_repo1
+      rake_path = Dir["#{Path.base_system_gems}/**/rake*.gem"].first
+
       build_repo gem_repo1 do
+        FileUtils.cp rake_path, "#{gem_repo1}/gems/"
+
+        build_gem "coffee-script-source"
+        build_gem "git"
+        build_gem "puma"
+        build_gem "minitest"
+
         build_gem "rack", %w[0.9.1 1.0.0] do |s|
           s.executables = "rackup"
           s.post_install_message = "Rack's post install message"
@@ -40,7 +61,7 @@ module Spec
 
         build_gem "rails", "2.3.2" do |s|
           s.executables = "rails"
-          s.add_dependency "rake",           "12.3.2"
+          s.add_dependency "rake",           "13.0.1"
           s.add_dependency "actionpack",     "2.3.2"
           s.add_dependency "activerecord",   "2.3.2"
           s.add_dependency "actionmailer",   "2.3.2"
@@ -64,14 +85,6 @@ module Spec
           s.add_dependency "activesupport", ">= 2.0.0"
         end
 
-        build_gem "rails_fail" do |s|
-          s.add_dependency "activesupport", "= 1.2.3"
-        end
-
-        build_gem "missing_dep" do |s|
-          s.add_dependency "not_here"
-        end
-
         build_gem "rspec", "1.2.7", :no_default => true do |s|
           s.write "lib/spec.rb", "SPEC = '1.2.7'"
         end
@@ -81,8 +94,8 @@ module Spec
         end
 
         build_gem "platform_specific" do |s|
-          s.platform = Bundler.local_platform
-          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0.0 #{Bundler.local_platform}'"
+          s.platform = Gem::Platform.local
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0.0 #{Gem::Platform.local}'"
         end
 
         build_gem "platform_specific" do |s|
@@ -97,15 +110,27 @@ module Spec
 
         build_gem "platform_specific" do |s|
           s.platform = "x86-mswin32"
-          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0.0 MSWIN'"
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0 x86-mswin32'"
+        end
+
+        build_gem "platform_specific" do |s|
+          s.platform = "x64-mswin64"
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0 x64-mswin64'"
         end
 
         build_gem "platform_specific" do |s|
           s.platform = "x86-mingw32"
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0 x86-mingw32'"
         end
 
         build_gem "platform_specific" do |s|
           s.platform = "x64-mingw32"
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0 x64-mingw32'"
+        end
+
+        build_gem "platform_specific" do |s|
+          s.platform = "x64-mingw-ucrt"
+          s.write "lib/platform_specific.rb", "PLATFORM_SPECIFIC = '1.0 x64-mingw-ucrt'"
         end
 
         build_gem "platform_specific" do |s|
@@ -146,49 +171,6 @@ module Spec
 
         build_gem "duradura", "7.0"
 
-        build_gem "multiple_versioned_deps" do |s|
-          s.add_dependency "weakling", ">= 0.0.1", "< 0.1"
-        end
-
-        build_gem "not_released", "1.0.pre"
-
-        build_gem "has_prerelease", "1.0"
-        build_gem "has_prerelease", "1.1.pre"
-
-        build_gem "with_development_dependency" do |s|
-          s.add_development_dependency "activesupport", "= 2.3.5"
-        end
-
-        build_gem "with_license" do |s|
-          s.license = "MIT"
-        end
-
-        build_gem "with_implicit_rake_dep" do |s|
-          s.extensions << "Rakefile"
-          s.write "Rakefile", <<-RUBY
-            task :default do
-              path = File.expand_path("../lib", __FILE__)
-              FileUtils.mkdir_p(path)
-              File.open("\#{path}/implicit_rake_dep.rb", "w") do |f|
-                f.puts "IMPLICIT_RAKE_DEP = 'YES'"
-              end
-            end
-          RUBY
-        end
-
-        build_gem "another_implicit_rake_dep" do |s|
-          s.extensions << "Rakefile"
-          s.write "Rakefile", <<-RUBY
-            task :default do
-              path = File.expand_path("../lib", __FILE__)
-              FileUtils.mkdir_p(path)
-              File.open("\#{path}/another_implicit_rake_dep.rb", "w") do |f|
-                f.puts "ANOTHER_IMPLICIT_RAKE_DEP = 'YES'"
-              end
-            end
-          RUBY
-        end
-
         build_gem "very_simple_binary", &:add_c_extension
         build_gem "simple_binary", &:add_c_extension
 
@@ -203,10 +185,6 @@ module Spec
           s.write "lib/rubygems_plugin.rb", "require 'bundler/omg' ; puts 'FAIL'"
         end
 
-        build_gem "bundler_dep" do |s|
-          s.add_dependency "bundler"
-        end
-
         # The yard gem iterates over Gem.source_index looking for plugins
         build_gem "yard" do |s|
           s.write "lib/yard.rb", <<-Y
@@ -216,92 +194,12 @@ module Spec
           Y
         end
 
-        # The rcov gem is platform mswin32, but has no arch
-        build_gem "rcov" do |s|
-          s.platform = Gem::Platform.new([nil, "mswin32", nil])
-          s.write "lib/rcov.rb", "RCOV = '1.0.0'"
-        end
-
         build_gem "net-ssh"
         build_gem "net-sftp", "1.1.1" do |s|
           s.add_dependency "net-ssh", ">= 1.0.0", "< 1.99.0"
         end
 
-        # Test complicated gem dependencies for install
-        build_gem "net_a" do |s|
-          s.add_dependency "net_b"
-          s.add_dependency "net_build_extensions"
-        end
-
-        build_gem "net_b"
-
-        build_gem "net_build_extensions" do |s|
-          s.add_dependency "rake"
-          s.extensions << "Rakefile"
-          s.write "Rakefile", <<-RUBY
-            task :default do
-              path = File.expand_path("../lib", __FILE__)
-              FileUtils.mkdir_p(path)
-              File.open("\#{path}/net_build_extensions.rb", "w") do |f|
-                f.puts "NET_BUILD_EXTENSIONS = 'YES'"
-              end
-            end
-          RUBY
-        end
-
-        build_gem "net_c" do |s|
-          s.add_dependency "net_a"
-          s.add_dependency "net_d"
-        end
-
-        build_gem "net_d"
-
-        build_gem "net_e" do |s|
-          s.add_dependency "net_d"
-        end
-
-        # Capistrano did this (at least until version 2.5.10)
-        # RubyGems 2.2 doesn't allow the specifying of a dependency twice
-        # See https://github.com/rubygems/rubygems/commit/03dbac93a3396a80db258d9bc63500333c25bd2f
-        build_gem "double_deps", "1.0", :skip_validation => true do |s|
-          s.add_dependency "net-ssh", ">= 1.0.0"
-          s.add_dependency "net-ssh"
-        end
-
         build_gem "foo"
-
-        # A minimal fake pry console
-        build_gem "pry" do |s|
-          s.write "lib/pry.rb", <<-RUBY
-            class Pry
-              class << self
-                def toplevel_binding
-                  unless defined?(@toplevel_binding) && @toplevel_binding
-                    TOPLEVEL_BINDING.eval %{
-                      def self.__pry__; binding; end
-                      Pry.instance_variable_set(:@toplevel_binding, __pry__)
-                      class << self; undef __pry__; end
-                    }
-                  end
-                  @toplevel_binding.eval('private')
-                  @toplevel_binding
-                end
-
-                def __pry__
-                  while line = gets
-                    begin
-                      puts eval(line, toplevel_binding).inspect.sub(/^"(.*)"$/, '=> \\1')
-                    rescue Exception => e
-                      puts "\#{e.class}: \#{e.message}"
-                      puts e.backtrace.first
-                    end
-                  end
-                end
-                alias start __pry__
-              end
-            end
-          RUBY
-        end
       end
     end
 
@@ -311,13 +209,6 @@ module Spec
       update_repo2(&blk) if block_given?
     end
 
-    def build_repo3
-      build_repo gem_repo3 do
-        build_gem "rack"
-      end
-      FileUtils.rm_rf Dir[gem_repo3("prerelease*")]
-    end
-
     # A repo that has no pre-installed gems included. (The caller completely
     # determines the contents with the block.)
     def build_repo4(&blk)
@@ -331,9 +222,6 @@ module Spec
 
     def update_repo2
       update_repo gem_repo2 do
-        build_gem "rack", "1.2" do |s|
-          s.executables = "rackup"
-        end
         yield if block_given?
       end
     end
@@ -355,22 +243,24 @@ module Spec
 
     def build_repo(path, &blk)
       return if File.directory?(path)
+
+      FileUtils.mkdir_p("#{path}/gems")
+
+      update_repo(path, &blk)
+    end
+
+    def check_test_gems!
       rake_path = Dir["#{Path.base_system_gems}/**/rake*.gem"].first
 
       if rake_path.nil?
-        Spec::Path.base_system_gems.rmtree
-        Spec::Rubygems.setup
+        FileUtils.rm_rf(Path.base_system_gems)
+        Spec::Rubygems.install_test_deps
         rake_path = Dir["#{Path.base_system_gems}/**/rake*.gem"].first
       end
 
-      if rake_path
-        FileUtils.mkdir_p("#{path}/gems")
-        FileUtils.cp rake_path, "#{path}/gems/"
-      else
+      if rake_path.nil?
         abort "Your test gems are missing! Run `rm -rf #{tmp}` and try again."
       end
-
-      update_repo(path, &blk)
     end
 
     def update_repo(path)
@@ -381,8 +271,8 @@ module Spec
       @_build_path = "#{path}/gems"
       @_build_repo = File.basename(path)
       yield
-      with_gem_path_as Path.base_system_gems do
-        Dir.chdir(path) { gem_command! :generate_index }
+      with_gem_path_as Path.base_system_gem_path do
+        gem_command :generate_index, :dir => path
       end
     ensure
       @_build_path = nil
@@ -424,20 +314,20 @@ module Spec
       opts = args.last.is_a?(Hash) ? args.last : {}
       builder = opts[:bare] ? GitBareBuilder : GitBuilder
       spec = build_with(builder, name, args, &block)
-      GitReader.new(opts[:path] || lib_path(spec.full_name))
+      GitReader.new(self, opts[:path] || lib_path(spec.full_name))
     end
 
     def update_git(name, *args, &block)
       opts = args.last.is_a?(Hash) ? args.last : {}
       spec = build_with(GitUpdater, name, args, &block)
-      GitReader.new(opts[:path] || lib_path(spec.full_name))
+      GitReader.new(self, opts[:path] || lib_path(spec.full_name))
     end
 
     def build_plugin(name, *args, &blk)
       build_with(PluginBuilder, name, args, &blk)
     end
 
-  private
+    private
 
     def build_with(builder, name, args, &blk)
       @_build_path ||= nil
@@ -451,7 +341,6 @@ module Spec
 
       Array(versions).each do |version|
         spec = builder.new(self, name, version)
-        spec.authors = ["no one"] if !spec.authors || spec.authors.empty?
         yield spec if block_given?
         spec._build(options)
       end
@@ -567,8 +456,7 @@ module Spec
         write "ext/extconf.rb", <<-RUBY
           require "mkmf"
 
-
-          # exit 1 unless with_config("simple")
+          $extout = "$(topdir)/" + RbConfig::CONFIG["EXTOUT"] unless RUBY_VERSION < "2.4"
 
           extension_name = "#{name}_c"
           if extra_lib_dir = with_config("ext-lib")
@@ -599,15 +487,6 @@ module Spec
           def @spec.validate(*); end
         end
 
-        case options[:gemspec]
-        when false
-          # do nothing
-        when :yaml
-          @files["#{name}.gemspec"] = @spec.to_yaml
-        else
-          @files["#{name}.gemspec"] = @spec.to_ruby
-        end
-
         unless options[:no_default]
           gem_source = options[:source] || "path@#{path}"
           @files = _default_files.
@@ -616,13 +495,25 @@ module Spec
         end
 
         @spec.authors = ["no one"]
+        @spec.files += @files.keys
+
+        case options[:gemspec]
+        when false
+          # do nothing
+        when :yaml
+          @spec.files << "#{name}.gemspec"
+          @files["#{name}.gemspec"] = @spec.to_yaml
+        else
+          @spec.files << "#{name}.gemspec"
+          @files["#{name}.gemspec"] = @spec.to_ruby
+        end
 
         @files.each do |file, source|
           file = Pathname.new(path).join(file)
           FileUtils.mkdir_p(file.dirname)
           File.open(file, "w") {|f| f.puts source }
+          File.chmod("+x", file) if @spec.executables.map {|exe| "#{@spec.bindir}/#{exe}" }.include?(file)
         end
-        @spec.files = @files.keys
         path
       end
 
@@ -645,17 +536,17 @@ module Spec
 
     class GitBuilder < LibBuilder
       def _build(options)
+        default_branch = options[:default_branch] || "main"
         path = options[:path] || _default_path
         source = options[:source] || "git@#{path}"
         super(options.merge(:path => path, :source => source))
-        Dir.chdir(path) do
-          `git init`
-          `git add *`
-          `git config user.email "lol@wut.com"`
-          `git config user.name "lolwut"`
-          `git config commit.gpgsign false`
-          `git commit -m "OMG INITIAL COMMIT"`
-        end
+        @context.git("config --global init.defaultBranch #{default_branch}", path)
+        @context.git("init", path)
+        @context.git("add *", path)
+        @context.git("config user.email lol@wut.com", path)
+        @context.git("config user.name lolwut", path)
+        @context.git("config commit.gpgsign false", path)
+        @context.git("commit -m OMG_INITIAL_COMMIT", path)
       end
     end
 
@@ -663,91 +554,72 @@ module Spec
       def _build(options)
         path = options[:path] || _default_path
         super(options.merge(:path => path))
-        Dir.chdir(path) do
-          `git init --bare`
-        end
+        @context.git("init --bare", path)
       end
     end
 
     class GitUpdater < LibBuilder
-      def silently(str)
-        `#{str} 2>#{Bundler::NULL}`
-      end
-
       def _build(options)
         libpath = options[:path] || _default_path
         update_gemspec = options[:gemspec] || false
         source = options[:source] || "git@#{libpath}"
 
-        Dir.chdir(libpath) do
-          silently "git checkout master"
-
-          if branch = options[:branch]
-            raise "You can't specify `master` as the branch" if branch == "master"
-            escaped_branch = Shellwords.shellescape(branch)
-
-            if `git branch | grep #{escaped_branch}`.empty?
-              silently("git branch #{escaped_branch}")
-            end
-
-            silently("git checkout #{escaped_branch}")
-          elsif tag = options[:tag]
-            `git tag #{Shellwords.shellescape(tag)}`
-          elsif options[:remote]
-            silently("git remote add origin #{options[:remote]}")
-          elsif options[:push]
-            silently("git push origin #{options[:push]}")
-          end
-
-          current_ref = `git rev-parse HEAD`.strip
-          _default_files.keys.each do |path|
-            _default_files[path] += "\n#{Builders.constantize(name)}_PREV_REF = '#{current_ref}'"
-          end
-          super(options.merge(:path => libpath, :gemspec => update_gemspec, :source => source))
-          `git add *`
-          `git commit -m "BUMP"`
+        if branch = options[:branch]
+          @context.git("checkout -b #{Shellwords.shellescape(branch)}", libpath)
+        elsif tag = options[:tag]
+          @context.git("tag #{Shellwords.shellescape(tag)}", libpath)
+        elsif options[:remote]
+          @context.git("remote add origin #{options[:remote]}", libpath)
+        elsif options[:push]
+          @context.git("push origin #{options[:push]}", libpath)
+        end
+
+        current_ref = @context.git("rev-parse HEAD", libpath).strip
+        _default_files.keys.each do |path|
+          _default_files[path] += "\n#{Builders.constantize(name)}_PREV_REF = '#{current_ref}'"
         end
+        super(options.merge(:path => libpath, :gemspec => update_gemspec, :source => source))
+        @context.git("commit -am BUMP", libpath)
       end
     end
 
     class GitReader
-      attr_reader :path
+      attr_reader :context, :path
 
-      def initialize(path)
+      def initialize(context, path)
+        @context = context
         @path = path
       end
 
       def ref_for(ref, len = nil)
-        ref = git "rev-parse #{ref}"
+        ref = context.git "rev-parse #{ref}", path
         ref = ref[0..len] if len
         ref
       end
-
-    private
-
-      def git(cmd)
-        Bundler::SharedHelpers.with_clean_git_env do
-          Dir.chdir(@path) { `git #{cmd}`.strip }
-        end
-      end
     end
 
     class GemBuilder < LibBuilder
       def _build(opts)
-        lib_path = super(opts.merge(:path => @context.tmp(".tmp/#{@spec.full_name}"), :no_default => opts[:no_default]))
+        lib_path = opts[:lib_path] || @context.tmp(".tmp/#{@spec.full_name}")
+        lib_path = super(opts.merge(:path => lib_path, :no_default => opts[:no_default]))
         destination = opts[:path] || _default_path
-        Dir.chdir(lib_path) do
-          FileUtils.mkdir_p(destination)
-
-          @spec.authors = ["that guy"] if !@spec.authors || @spec.authors.empty?
+        FileUtils.mkdir_p(lib_path.join(destination))
 
-          Bundler.rubygems.build(@spec, opts[:skip_validation])
+        if opts[:gemspec] == :yaml || opts[:gemspec] == false
+          Dir.chdir(lib_path) do
+            Bundler.rubygems.build(@spec, opts[:skip_validation])
+          end
+        elsif opts[:skip_validation]
+          @context.gem_command "build --force #{@spec.name}", :dir => lib_path
+        else
+          @context.gem_command "build #{@spec.name}", :dir => lib_path
         end
+
         gem_path = File.expand_path("#{@spec.full_name}.gem", lib_path)
         if opts[:to_system]
-          @context.system_gems gem_path, :keep_path => true
+          @context.system_gems gem_path, :default => opts[:default]
         elsif opts[:to_bundle]
-          @context.system_gems gem_path, :path => :bundle_path, :keep_path => true
+          @context.system_gems gem_path, :path => @context.default_bundle_path
         else
           FileUtils.mv(gem_path, destination)
         end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/support/bundle.rb
@@ -0,0 +1,8 @@
+# frozen_string_literal: true
+
+require "rubygems"
+require_relative "path"
+bundler_gemspec = Spec::Path.loaded_gemspec
+bundler_gemspec.instance_variable_set(:@full_gem_path, Spec::Path.source_root)
+bundler_gemspec.activate if bundler_gemspec.respond_to?(:activate)
+load File.expand_path("bundle", Spec::Path.bindir)
--- ruby2.7-2.7.6.orig/spec/bundler/support/command_execution.rb
+++ ruby2.7-2.7.6/spec/bundler/support/command_execution.rb
@@ -3,18 +3,7 @@
 module Spec
   CommandExecution = Struct.new(:command, :working_directory, :exitstatus, :stdout, :stderr) do
     def to_s
-      c = Shellwords.shellsplit(command.strip).map {|s| s.include?("\n") ? " \\\n  <<EOS\n#{s.gsub(/^/, "  ").chomp}\nEOS" : Shellwords.shellescape(s) }
-      c = c.reduce("") do |acc, elem|
-        concat = acc + " " + elem
-
-        last_line = concat.match(/.*\z/)[0]
-        if last_line.size >= 100
-          acc + " \\\n  " + elem
-        else
-          concat
-        end
-      end
-      "$ #{c.strip}"
+      "$ #{command}"
     end
     alias_method :inspect, :to_s
 
--- ruby2.7-2.7.6.orig/spec/bundler/support/filters.rb
+++ ruby2.7-2.7.6/spec/bundler/support/filters.rb
@@ -21,25 +21,21 @@ class RequirementChecker < Proc
 end
 
 RSpec.configure do |config|
-  if ENV["BUNDLER_SUDO_TESTS"] && Spec::Sudo.present?
-    config.filter_run :sudo => true
-  else
-    config.filter_run_excluding :sudo => true
-  end
-
-  if ENV["BUNDLER_REALWORLD_TESTS"]
-    config.filter_run :realworld => true
-  else
-    config.filter_run_excluding :realworld => true
-  end
+  config.filter_run_excluding :sudo => true
+  config.filter_run_excluding :realworld => true
 
   git_version = Bundler::Source::Git::GitProxy.new(nil, nil, nil).version
 
-  config.filter_run_excluding :rubygems => RequirementChecker.against(Gem::VERSION)
   config.filter_run_excluding :git => RequirementChecker.against(git_version)
   config.filter_run_excluding :bundler => RequirementChecker.against(Bundler::VERSION.split(".")[0])
+  config.filter_run_excluding :rubygems => RequirementChecker.against(Gem::VERSION)
   config.filter_run_excluding :ruby_repo => !ENV["GEM_COMMAND"].nil?
   config.filter_run_excluding :no_color_tty => Gem.win_platform? || !ENV["GITHUB_ACTION"].nil?
+  config.filter_run_excluding :permissions => Gem.win_platform?
+  config.filter_run_excluding :readline => Gem.win_platform?
+  config.filter_run_excluding :jruby_only => RUBY_ENGINE != "jruby"
+  config.filter_run_excluding :truffleruby_only => RUBY_ENGINE != "truffleruby"
+  config.filter_run_excluding :man => Gem.win_platform?
 
   config.filter_run_when_matching :focus unless ENV["CI"]
 end
--- ruby2.7-2.7.6.orig/spec/bundler/support/hax.rb
+++ ruby2.7-2.7.6/spec/bundler/support/hax.rb
@@ -9,60 +9,30 @@ module Gem
     Gem.ruby = ENV["RUBY"]
   end
 
-  if version = ENV["BUNDLER_SPEC_RUBYGEMS_VERSION"]
-    remove_const(:VERSION) if const_defined?(:VERSION)
-    VERSION = version
+  if ENV["BUNDLER_GEM_DEFAULT_DIR"]
+    @default_dir = ENV["BUNDLER_GEM_DEFAULT_DIR"]
+    @default_specifications_dir = nil
   end
 
-  class Platform
-    @local = new(ENV["BUNDLER_SPEC_PLATFORM"]) if ENV["BUNDLER_SPEC_PLATFORM"]
+  if ENV["BUNDLER_SPEC_WINDOWS"]
+    @@win_platform = true # rubocop:disable Style/ClassVars
   end
-  @platforms = [Gem::Platform::RUBY, Gem::Platform.local]
 
-  # We only need this hack for rubygems versions without the BundlerVersionFinder
-  if Gem::Version.new(Gem::VERSION) < Gem::Version.new("2.7.0") || ENV["BUNDLER_SPEC_DISABLE_DEFAULT_BUNDLER_GEM"]
-    @path_to_default_spec_map.delete_if do |_path, spec|
-      spec.name == "bundler"
+  if ENV["BUNDLER_SPEC_PLATFORM"]
+    class Platform
+      @local = new(ENV["BUNDLER_SPEC_PLATFORM"])
     end
+    @platforms = [Gem::Platform::RUBY, Gem::Platform.local]
   end
-end
 
-if ENV["BUNDLER_SPEC_VERSION"]
-  require_relative "path"
-  require "#{Spec::Path.lib_dir}/bundler/version"
-
-  module Bundler
-    remove_const(:VERSION) if const_defined?(:VERSION)
-    VERSION = ENV["BUNDLER_SPEC_VERSION"].dup
+  if ENV["BUNDLER_SPEC_GEM_SOURCES"]
+    self.sources = [ENV["BUNDLER_SPEC_GEM_SOURCES"]]
   end
-end
 
-if ENV["BUNDLER_SPEC_WINDOWS"] == "true"
-  require_relative "path"
-  require "#{Spec::Path.lib_dir}/bundler/constants"
-
-  module Bundler
-    remove_const :WINDOWS if defined?(WINDOWS)
-    WINDOWS = true
-  end
-end
-
-class Object
-  if ENV["BUNDLER_SPEC_RUBY_ENGINE"]
-    if RUBY_ENGINE != "jruby" && ENV["BUNDLER_SPEC_RUBY_ENGINE"] == "jruby"
-      begin
-        # this has to be done up front because psych will try to load a .jar
-        # if it thinks its on jruby
-        require "psych"
-      rescue LoadError
-        nil
-      end
+  # We only need this hack for rubygems versions without the BundlerVersionFinder
+  if Gem.rubygems_version < Gem::Version.new("2.7.0")
+    @path_to_default_spec_map.delete_if do |_path, spec|
+      spec.name == "bundler"
     end
-
-    remove_const :RUBY_ENGINE
-    RUBY_ENGINE = ENV["BUNDLER_SPEC_RUBY_ENGINE"]
-
-    remove_const :RUBY_ENGINE_VERSION
-    RUBY_ENGINE_VERSION = ENV["BUNDLER_SPEC_RUBY_ENGINE_VERSION"]
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/support/helpers.rb
+++ ruby2.7-2.7.6/spec/bundler/support/helpers.rb
@@ -2,39 +2,37 @@
 
 require_relative "command_execution"
 require_relative "the_bundle"
+require_relative "path"
 
 module Spec
   module Helpers
+    include Spec::Path
+
     def reset!
       Dir.glob("#{tmp}/{gems/*,*}", File::FNM_DOTMATCH).each do |dir|
-        next if %w[base remote1 gems rubygems . ..].include?(File.basename(dir))
-        if ENV["BUNDLER_SUDO_TESTS"]
-          `sudo rm -rf "#{dir}"`
-        else
-          FileUtils.rm_rf(dir)
-        end
+        next if %w[base base_system remote1 rubocop standard gems rubygems . ..].include?(File.basename(dir))
+        FileUtils.rm_rf(dir)
       end
       FileUtils.mkdir_p(home)
       FileUtils.mkdir_p(tmpdir)
-      Bundler.reset!
+      reset_paths!
     end
 
-    def self.bang(method)
-      define_method("#{method}!") do |*args, &blk|
-        send(method, *args, &blk).tap do
-          unless last_command.success?
-            raise "Invoking #{method}!(#{args.map(&:inspect).join(", ")}) failed:\n#{last_command.stdboth}"
-          end
-        end
-      end
+    def reset_paths!
+      Bundler.reset!
+      Gem.clear_paths
     end
 
     def the_bundle(*args)
       TheBundle.new(*args)
     end
 
+    def command_executions
+      @command_executions ||= []
+    end
+
     def last_command
-      @command_executions.last || raise("There is no last command")
+      command_executions.last || raise("There is no last command")
     end
 
     def out
@@ -59,32 +57,19 @@ module Spec
       last_command.exitstatus
     end
 
-    def in_app_root(&blk)
-      Dir.chdir(bundled_app, &blk)
-    end
-
-    def in_app_root2(&blk)
-      Dir.chdir(bundled_app2, &blk)
-    end
-
-    def in_app_root_custom(root, &blk)
-      Dir.chdir(root, &blk)
-    end
-
     def run(cmd, *args)
       opts = args.last.is_a?(Hash) ? args.pop : {}
       groups = args.map(&:inspect).join(", ")
-      setup = "require '#{lib_dir}/bundler' ; Bundler.ui.silence { Bundler.setup(#{groups}) }\n"
-      ruby(setup + cmd, opts)
+      setup = "require '#{entrypoint}' ; Bundler.ui.silence { Bundler.setup(#{groups}) }"
+      ruby([setup, cmd].join(" ; "), opts)
     end
-    bang :run
 
     def load_error_run(ruby, name, *args)
       cmd = <<-RUBY
         begin
           #{ruby}
         rescue LoadError => e
-          $stderr.puts "ZOMG LOAD ERROR" if e.message.include?("-- #{name}")
+          warn "ZOMG LOAD ERROR" if e.message.include?("-- #{name}")
         end
       RUBY
       opts = args.last.is_a?(Hash) ? args.pop : {}
@@ -92,39 +77,34 @@ module Spec
       run(cmd, *args)
     end
 
-    def bundle(cmd, options = {})
+    def bundle(cmd, options = {}, &block)
       with_sudo = options.delete(:sudo)
-      sudo = with_sudo == :preserve_env ? "sudo -E" : "sudo" if with_sudo
+      sudo = with_sudo == :preserve_env ? "sudo -E --preserve-env=RUBYOPT" : "sudo" if with_sudo
 
-      bundle_bin = options.delete("bundle_bin") || bindir.join("bundle")
-
-      if system_bundler = options.delete(:system_bundler)
-        bundle_bin = system_gem_path.join("bin/bundler")
-      end
+      bundle_bin = options.delete(:bundle_bin)
+      bundle_bin ||= installed_bindir.join("bundle")
 
       env = options.delete(:env) || {}
-      env["PATH"].gsub!("#{Path.root}/exe", "") if env["PATH"] && system_bundler
 
       requires = options.delete(:requires) || []
-      requires << "support/hax"
+      realworld = RSpec.current_example.metadata[:realworld]
 
       artifice = options.delete(:artifice) do
-        if RSpec.current_example.metadata[:realworld]
+        if realworld
           "vcr"
         else
           "fail"
         end
       end
       if artifice
-        requires << "support/artifice/#{artifice}"
+        requires << "#{Path.spec_dir}/support/artifice/#{artifice}.rb"
       end
 
-      requires_str = requires.map {|r| "-r#{r}" }.join(" ")
-
       load_path = []
-      load_path << lib_dir unless system_bundler
       load_path << spec_dir
-      load_path_str = "-I#{load_path.join(File::PATH_SEPARATOR)}"
+
+      dir = options.delete(:dir) || bundled_app
+      raise_on_error = options.delete(:raise_on_error)
 
       args = options.map do |k, v|
         case v
@@ -139,74 +119,74 @@ module Spec
         end
       end.join
 
-      cmd = "#{sudo} #{Gem.ruby} #{load_path_str} #{requires_str} #{bundle_bin} #{cmd}#{args}"
-      sys_exec(cmd, env) {|i, o, thr| yield i, o, thr if block_given? }
-    end
-    bang :bundle
-
-    def forgotten_command_line_options(options)
-      remembered = Bundler::VERSION.split(".", 2).first == "2"
-      options = options.map do |k, v|
-        v = '""' if v && v.to_s.empty?
-        [k, v]
-      end
-      return Hash[options] if remembered
-      options.each do |k, v|
-        if v.nil?
-          bundle! "config unset #{k}"
-        else
-          bundle! "config set --local #{k} #{v}"
-        end
-      end
-      {}
+      ruby_cmd = build_ruby_cmd({ :sudo => sudo, :load_path => load_path, :requires => requires })
+      cmd = "#{ruby_cmd} #{bundle_bin} #{cmd}#{args}"
+      sys_exec(cmd, { :env => env, :dir => dir, :raise_on_error => raise_on_error }, &block)
     end
 
     def bundler(cmd, options = {})
-      options["bundle_bin"] = bindir.join("bundler")
+      options[:bundle_bin] = system_gem_path.join("bin/bundler")
       bundle(cmd, options)
     end
 
     def ruby(ruby, options = {})
-      env = options.delete(:env) || {}
-      ruby = ruby.gsub(/["`\$]/) {|m| "\\#{m}" }
-      lib_option = options[:no_lib] ? "" : " -I#{lib_dir}"
-      sys_exec(%(#{Gem.ruby}#{lib_option} -w -e "#{ruby}"), env)
+      ruby_cmd = build_ruby_cmd
+      escaped_ruby = ruby.shellescape
+      sys_exec(%(#{ruby_cmd} -w -e #{escaped_ruby}), options)
     end
-    bang :ruby
 
     def load_error_ruby(ruby, name, opts = {})
       ruby(<<-R)
         begin
           #{ruby}
         rescue LoadError => e
-          $stderr.puts "ZOMG LOAD ERROR"# if e.message.include?("-- #{name}")
+          warn "ZOMG LOAD ERROR" if e.message.include?("-- #{name}")
         end
       R
     end
 
-    def gembin(cmd)
-      old = ENV["RUBYOPT"]
-      ENV["RUBYOPT"] = "#{ENV["RUBYOPT"]} -I#{lib_dir}"
+    def build_ruby_cmd(options = {})
+      sudo = options.delete(:sudo)
+
+      libs = options.delete(:load_path)
+      lib_option = libs ? "-I#{libs.join(File::PATH_SEPARATOR)}" : []
+
+      requires = options.delete(:requires) || []
+      requires << "#{Path.spec_dir}/support/hax.rb"
+      require_option = requires.map {|r| "-r#{r}" }
+
+      [sudo, Gem.ruby, *lib_option, *require_option].compact.join(" ")
+    end
+
+    def gembin(cmd, options = {})
       cmd = bundled_app("bin/#{cmd}") unless cmd.to_s.include?("/")
-      sys_exec(cmd.to_s)
-    ensure
-      ENV["RUBYOPT"] = old
+      sys_exec(cmd.to_s, options)
     end
 
-    def gem_command(command, args = "")
-      sys_exec("#{Path.gem_bin} #{command} #{args}")
+    def gem_command(command, options = {})
+      env = options[:env] || {}
+      env["RUBYOPT"] = opt_add(opt_add("-r#{spec_dir}/support/hax.rb", env["RUBYOPT"]), ENV["RUBYOPT"])
+      options[:env] = env
+      sys_exec("#{Path.gem_bin} #{command}", options)
     end
-    bang :gem_command
 
     def rake
       "#{Gem.ruby} -S #{ENV["GEM_PATH"]}/bin/rake"
     end
 
-    def sys_exec(cmd, env = {})
-      command_execution = CommandExecution.new(cmd.to_s, Dir.pwd)
+    def git(cmd, path, options = {})
+      sys_exec("git #{cmd}", options.merge(:dir => path))
+    end
+
+    def sys_exec(cmd, options = {})
+      env = options[:env] || {}
+      env["RUBYOPT"] = opt_add(opt_add("-r#{spec_dir}/support/switch_rubygems.rb", env["RUBYOPT"]), ENV["RUBYOPT"])
+      dir = options[:dir] || bundled_app
+      command_execution = CommandExecution.new(cmd.to_s, dir)
 
       require "open3"
-      Open3.popen3(env, cmd.to_s) do |stdin, stdout, stderr, wait_thr|
+      require "shellwords"
+      Open3.popen3(env, *cmd.shellsplit, :chdir => dir) do |stdin, stdout, stderr, wait_thr|
         yield stdin, stdout, wait_thr if block_given?
         stdin.close
 
@@ -214,17 +194,38 @@ module Spec
         stderr_read_thread = Thread.new { stderr.read }
         command_execution.stdout = stdout_read_thread.value.strip
         command_execution.stderr = stderr_read_thread.value.strip
-        command_execution.exitstatus = wait_thr && wait_thr.value.exitstatus
+
+        status = wait_thr.value
+        command_execution.exitstatus = if status.exited?
+          status.exitstatus
+        elsif status.signaled?
+          exit_status_for_signal(status.termsig)
+        end
+      end
+
+      unless options[:raise_on_error] == false || command_execution.success?
+        raise <<~ERROR
+
+          Invoking `#{cmd}` failed with output:
+          ----------------------------------------------------------------------
+          #{command_execution.stdboth}
+          ----------------------------------------------------------------------
+        ERROR
       end
 
-      (@command_executions ||= []) << command_execution
+      command_executions << command_execution
 
       command_execution.stdout
     end
-    bang :sys_exec
+
+    def all_commands_output
+      return "" if command_executions.empty?
+
+      "\n\nCommands:\n#{command_executions.map(&:to_s_verbose).join("\n\n")}"
+    end
 
     def config(config = nil, path = bundled_app(".bundle/config"))
-      return YAML.load_file(path) unless config
+      return Psych.load_file(path) unless config
       FileUtils.mkdir_p(File.dirname(path))
       File.open(path, "w") do |f|
         f.puts config.to_yaml
@@ -236,33 +237,31 @@ module Spec
       config(config, home(".bundle/config"))
     end
 
-    def create_file(*args)
-      path = bundled_app(args.shift)
-      path = args.shift if args.first.is_a?(Pathname)
-      str  = args.shift || ""
+    def create_file(path, contents = "")
+      path = Pathname.new(path).expand_path(bundled_app) unless path.is_a?(Pathname)
       path.dirname.mkpath
       File.open(path.to_s, "w") do |f|
-        f.puts strip_whitespace(str)
+        f.puts strip_whitespace(contents)
       end
     end
 
     def gemfile(*args)
-      contents = args.shift
+      contents = args.pop
 
       if contents.nil?
-        File.open("Gemfile", "r", &:read)
+        File.open(bundled_app_gemfile, "r", &:read)
       else
-        create_file("Gemfile", contents, *args)
+        create_file(args.pop || "Gemfile", contents)
       end
     end
 
     def lockfile(*args)
-      contents = args.shift
+      contents = args.pop
 
       if contents.nil?
-        File.open("Gemfile.lock", "r", &:read)
+        File.open(bundled_app_lock, "r", &:read)
       else
-        create_file("Gemfile.lock", contents, *args)
+        create_file(args.pop || "Gemfile.lock", contents)
       end
     end
 
@@ -273,79 +272,116 @@ module Spec
     end
 
     def install_gemfile(*args)
+      opts = args.last.is_a?(Hash) ? args.pop : {}
       gemfile(*args)
-      opts = args.last.is_a?(Hash) ? args.last : {}
-      opts[:retry] ||= 0
       bundle :install, opts
     end
-    bang :install_gemfile
 
     def lock_gemfile(*args)
       gemfile(*args)
       opts = args.last.is_a?(Hash) ? args.last : {}
-      opts[:retry] ||= 0
       bundle :lock, opts
     end
 
-    def install_gems(*gems)
+    def system_gems(*gems)
+      gems = gems.flatten
       options = gems.last.is_a?(Hash) ? gems.pop : {}
-      gem_repo = options.fetch(:gem_repo) { gem_repo1 }
-      gems.each do |g|
-        if g == :bundler
-          with_built_bundler {|gem_path| install_gem(gem_path) }
-        elsif g.to_s =~ %r{\A(?:[A-Z]:)?/.*\.gem\z}
-          install_gem(g)
-        else
-          install_gem("#{gem_repo}/gems/#{g}.gem")
+      path = options.fetch(:path, system_gem_path)
+      default = options.fetch(:default, false)
+      with_gem_path_as(path) do
+        gem_repo = options.fetch(:gem_repo, gem_repo1)
+        gems.each do |g|
+          gem_name = g.to_s
+          if gem_name.start_with?("bundler")
+            version = gem_name.match(/\Abundler-(?<version>.*)\z/)[:version] if gem_name != "bundler"
+            with_built_bundler(version) {|gem_path| install_gem(gem_path, default) }
+          elsif gem_name =~ %r{\A(?:[a-zA-Z]:)?/.*\.gem\z}
+            install_gem(gem_name, default)
+          else
+            install_gem("#{gem_repo}/gems/#{gem_name}.gem", default)
+          end
         end
       end
     end
 
-    def install_gem(path)
+    def install_gem(path, default = false)
       raise "OMG `#{path}` does not exist!" unless File.exist?(path)
 
-      gem_command! :install, "--no-document --ignore-dependencies '#{path}'"
+      args = "--no-document --ignore-dependencies"
+      args += " --default --install-dir #{system_gem_path}" if default
+
+      gem_command "install #{args} '#{path}'"
     end
 
-    def with_built_bundler
-      with_root_gemspec do |gemspec|
-        Dir.chdir(root) { gem_command! :build, gemspec.to_s }
-      end
+    def with_built_bundler(version = nil)
+      version ||= Bundler::VERSION
+      full_name = "bundler-#{version}"
+      build_path = tmp + full_name
+      bundler_path = build_path + "#{full_name}.gem"
 
-      bundler_path = root + "bundler-#{Bundler::VERSION}.gem"
+      Dir.mkdir build_path
 
       begin
+        shipped_files.each do |shipped_file|
+          target_shipped_file = build_path + shipped_file
+          target_shipped_dir = File.dirname(target_shipped_file)
+          FileUtils.mkdir_p target_shipped_dir unless File.directory?(target_shipped_dir)
+          FileUtils.cp shipped_file, target_shipped_file, :preserve => true
+        end
+
+        replace_version_file(version, dir: build_path) # rubocop:disable Style/HashSyntax
+
+        Spec::BuildMetadata.write_build_metadata(dir: build_path) # rubocop:disable Style/HashSyntax
+
+        gem_command "build #{relative_gemspec}", :dir => build_path
+
         yield(bundler_path)
       ensure
-        bundler_path.rmtree
+        build_path.rmtree
       end
     end
 
     def with_gem_path_as(path)
-      backup = ENV.to_hash
-      ENV["GEM_HOME"] = path.to_s
-      ENV["GEM_PATH"] = path.to_s
-      ENV["BUNDLER_ORIG_GEM_PATH"] = nil
-      yield
-    ensure
-      ENV.replace(backup)
+      without_env_side_effects do
+        ENV["GEM_HOME"] = path.to_s
+        ENV["GEM_PATH"] = path.to_s
+        ENV["BUNDLER_ORIG_GEM_HOME"] = nil
+        ENV["BUNDLER_ORIG_GEM_PATH"] = nil
+        yield
+      end
     end
 
     def with_path_as(path)
+      without_env_side_effects do
+        ENV["PATH"] = path.to_s
+        ENV["BUNDLER_ORIG_PATH"] = nil
+        yield
+      end
+    end
+
+    def without_env_side_effects
       backup = ENV.to_hash
-      ENV["PATH"] = path.to_s
-      ENV["BUNDLER_ORIG_PATH"] = nil
       yield
     ensure
       ENV.replace(backup)
     end
 
     def with_path_added(path)
-      with_path_as(path.to_s + ":" + ENV["PATH"]) do
+      with_path_as([path.to_s, ENV["PATH"]].join(File::PATH_SEPARATOR)) do
         yield
       end
     end
 
+    def opt_add(option, options)
+      [option.strip, options].compact.reject(&:empty?).join(" ")
+    end
+
+    def opt_remove(option, options)
+      return unless options
+
+      options.split(" ").reject {|opt| opt.strip == option.strip }.join(" ")
+    end
+
     def break_git!
       FileUtils.mkdir_p(tmp("broken_path"))
       File.open(tmp("broken_path/git"), "w", 0o755) do |f|
@@ -356,6 +392,8 @@ module Spec
     end
 
     def with_fake_man
+      skip "fake_man is not a Windows friendly binstub" if Gem.win_platform?
+
       FileUtils.mkdir_p(tmp("fake_man"))
       File.open(tmp("fake_man/man"), "w", 0o755) do |f|
         f.puts "#!/usr/bin/env ruby\nputs ARGV.inspect\n"
@@ -363,68 +401,21 @@ module Spec
       with_path_added(tmp("fake_man")) { yield }
     end
 
-    def system_gems(*gems)
-      opts = gems.last.is_a?(Hash) ? gems.last : {}
-      path = opts.fetch(:path, system_gem_path)
-      if path == :bundle_path
-        path = ruby!(<<-RUBY)
-          require "bundler"
-          begin
-            puts Bundler.bundle_path
-          rescue Bundler::GemfileNotFound
-            ENV["BUNDLE_GEMFILE"] = "Gemfile"
-            retry
-          end
-
-        RUBY
-      end
-      gems = gems.flatten
-
-      unless opts[:keep_path]
-        FileUtils.rm_rf(path)
-        FileUtils.mkdir_p(path)
-      end
-
-      Gem.clear_paths
-
-      env_backup = ENV.to_hash
-      ENV["GEM_HOME"] = path.to_s
-      ENV["GEM_PATH"] = path.to_s
-      ENV["BUNDLER_ORIG_GEM_PATH"] = nil
+    def pristine_system_gems(*gems)
+      FileUtils.rm_rf(system_gem_path)
 
-      install_gems(*gems)
-      return unless block_given?
-      begin
-        yield
-      ensure
-        ENV.replace(env_backup)
-      end
+      system_gems(*gems)
     end
 
     def realworld_system_gems(*gems)
       gems = gems.flatten
+      opts = gems.last.is_a?(Hash) ? gems.pop : {}
+      path = opts.fetch(:path, system_gem_path)
 
-      FileUtils.rm_rf(system_gem_path)
-      FileUtils.mkdir_p(system_gem_path)
-
-      Gem.clear_paths
-
-      gem_home = ENV["GEM_HOME"]
-      gem_path = ENV["GEM_PATH"]
-      path = ENV["PATH"]
-      ENV["GEM_HOME"] = system_gem_path.to_s
-      ENV["GEM_PATH"] = system_gem_path.to_s
-
-      gems.each do |gem|
-        gem_command! :install, "--no-document #{gem}"
-      end
-      return unless block_given?
-      begin
-        yield
-      ensure
-        ENV["GEM_HOME"] = gem_home
-        ENV["GEM_PATH"] = gem_path
-        ENV["PATH"] = path
+      with_gem_path_as(path) do
+        gems.each do |gem|
+          gem_command "install --no-document #{gem}"
+        end
       end
     end
 
@@ -442,9 +433,8 @@ module Spec
     end
 
     def simulate_new_machine
-      system_gems []
-      FileUtils.rm_rf system_gem_path
       FileUtils.rm_rf bundled_app(".bundle")
+      pristine_system_gems :bundler
     end
 
     def simulate_platform(platform)
@@ -455,56 +445,52 @@ module Spec
       ENV["BUNDLER_SPEC_PLATFORM"] = old if block_given?
     end
 
-    def simulate_ruby_version(version)
-      return if version == RUBY_VERSION
-      old = ENV["BUNDLER_SPEC_RUBY_VERSION"]
-      ENV["BUNDLER_SPEC_RUBY_VERSION"] = version
-      yield if block_given?
+    def simulate_windows(platform = x86_mswin32)
+      old = ENV["BUNDLER_SPEC_WINDOWS"]
+      ENV["BUNDLER_SPEC_WINDOWS"] = "true"
+      simulate_platform platform do
+        simulate_bundler_version_when_missing_prerelease_default_gem_activation do
+          yield
+        end
+      end
     ensure
-      ENV["BUNDLER_SPEC_RUBY_VERSION"] = old if block_given?
+      ENV["BUNDLER_SPEC_WINDOWS"] = old
     end
 
-    def simulate_ruby_engine(engine, version = "1.6.0")
-      return if engine == local_ruby_engine
+    def simulate_bundler_version_when_missing_prerelease_default_gem_activation
+      return yield unless rubygems_version_failing_to_activate_bundler_prereleases
 
-      old = ENV["BUNDLER_SPEC_RUBY_ENGINE"]
-      ENV["BUNDLER_SPEC_RUBY_ENGINE"] = engine
-      old_version = ENV["BUNDLER_SPEC_RUBY_ENGINE_VERSION"]
-      ENV["BUNDLER_SPEC_RUBY_ENGINE_VERSION"] = version
-      yield if block_given?
+      old = ENV["BUNDLER_VERSION"]
+      ENV["BUNDLER_VERSION"] = Bundler::VERSION
+      yield
     ensure
-      ENV["BUNDLER_SPEC_RUBY_ENGINE"] = old if block_given?
-      ENV["BUNDLER_SPEC_RUBY_ENGINE_VERSION"] = old_version if block_given?
+      ENV["BUNDLER_VERSION"] = old
     end
 
-    def simulate_bundler_version(version)
-      old = ENV["BUNDLER_SPEC_VERSION"]
-      ENV["BUNDLER_SPEC_VERSION"] = version.to_s
-      yield if block_given?
-    ensure
-      ENV["BUNDLER_SPEC_VERSION"] = old if block_given?
+    def env_for_missing_prerelease_default_gem_activation
+      if rubygems_version_failing_to_activate_bundler_prereleases
+        { "BUNDLER_VERSION" => Bundler::VERSION }
+      else
+        {}
+      end
     end
 
-    def simulate_rubygems_version(version)
-      old = ENV["BUNDLER_SPEC_RUBYGEMS_VERSION"]
-      ENV["BUNDLER_SPEC_RUBYGEMS_VERSION"] = version.to_s
-      yield if block_given?
-    ensure
-      ENV["BUNDLER_SPEC_RUBYGEMS_VERSION"] = old if block_given?
+    def current_ruby_minor
+      Gem.ruby_version.segments.tap {|s| s.delete_at(2) }.join(".")
     end
 
-    def simulate_windows(platform = mswin)
-      old = ENV["BUNDLER_SPEC_WINDOWS"]
-      ENV["BUNDLER_SPEC_WINDOWS"] = "true"
-      simulate_platform platform do
-        yield
-      end
-    ensure
-      ENV["BUNDLER_SPEC_WINDOWS"] = old
+    def next_ruby_minor
+      Gem.ruby_version.segments[0..1].map.with_index {|s, i| i == 1 ? s + 1 : s }.join(".")
+    end
+
+    # versions providing a bundler version finder but not including
+    # https://github.com/rubygems/rubygems/commit/929e92d752baad3a08f3ac92eaec162cb96aedd1
+    def rubygems_version_failing_to_activate_bundler_prereleases
+      Gem.rubygems_version < Gem::Version.new("3.1.0.pre.1") && Gem.rubygems_version >= Gem::Version.new("2.7.0")
     end
 
     def revision_for(path)
-      Dir.chdir(path) { `git rev-parse HEAD`.strip }
+      sys_exec("git rev-parse HEAD", :dir => path).strip
     end
 
     def with_read_only(pattern)
@@ -526,11 +512,11 @@ module Spec
       process_file(pathname) do |line|
         case line
         when /spec\.metadata\["(?:allowed_push_host|homepage_uri|source_code_uri|changelog_uri)"\]/, /spec\.homepage/
-          line.gsub(/\=.*$/, "= 'http://example.org'")
+          line.gsub(/\=.*$/, '= "http://example.org"')
         when /spec\.summary/
-          line.gsub(/\=.*$/, "= %q{A short summary of my new gem.}")
+          line.gsub(/\=.*$/, '= "A short summary of my new gem."')
         when /spec\.description/
-          line.gsub(/\=.*$/, "= %q{A longer description of my new gem.}")
+          line.gsub(/\=.*$/, '= "A longer description of my new gem."')
         else
           line
         end
@@ -559,7 +545,7 @@ module Spec
     def require_rack
       # need to hack, so we can require rack
       old_gem_home = ENV["GEM_HOME"]
-      ENV["GEM_HOME"] = Spec::Path.base_system_gems.to_s
+      ENV["GEM_HOME"] = Spec::Path.base_system_gem_path.to_s
       require "rack"
       ENV["GEM_HOME"] = old_gem_home
     end
@@ -583,5 +569,16 @@ module Spec
       end
       port
     end
+
+    def exit_status_for_signal(signal_number)
+      # For details see: https://en.wikipedia.org/wiki/Exit_status#Shell_and_scripts
+      128 + signal_number
+    end
+
+    private
+
+    def git_root_dir?
+      root.to_s == `git rev-parse --show-toplevel`.chomp
+    end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/support/indexes.rb
+++ ruby2.7-2.7.6/spec/bundler/support/indexes.rb
@@ -17,16 +17,24 @@ module Spec
     def resolve(args = [])
       @platforms ||= ["ruby"]
       deps = []
-      default_source = instance_double("Bundler::Source::Rubygems", :specs => @index)
+      default_source = instance_double("Bundler::Source::Rubygems", :specs => @index, :to_s => "locally install gems")
       source_requirements = { :default => default_source }
       @deps.each do |d|
+        source_requirements[d.name] = d.source = default_source
         @platforms.each do |p|
-          source_requirements[d.name] = d.source = default_source
-          deps << Bundler::DepProxy.new(d, p)
+          deps << Bundler::DepProxy.get_proxy(d, p)
         end
       end
-      source_requirements ||= {}
-      Bundler::Resolver.resolve(deps, @index, source_requirements, *args)
+      args[0] ||= [] # base
+      args[0].each {|ls| ls.source = default_source }
+      args[1] ||= Bundler::GemVersionPromoter.new # gem_version_promoter
+      args[2] ||= [] # additional_base_requirements
+      args[3] ||= @platforms # platforms
+      Bundler::Resolver.resolve(deps, source_requirements, *args)
+    end
+
+    def should_not_resolve
+      expect { resolve }.to raise_error(Bundler::GemNotFound)
     end
 
     def should_resolve_as(specs)
--- ruby2.7-2.7.6.orig/spec/bundler/support/matchers.rb
+++ ruby2.7-2.7.6/spec/bundler/support/matchers.rb
@@ -75,16 +75,6 @@ module Spec
       end
     end
 
-    RSpec::Matchers.define :have_rubyopts do |*args|
-      args = args.flatten
-      args = args.first.split(/\s+/) if args.size == 1
-
-      match do |actual|
-        actual = actual.split(/\s+/) if actual.is_a?(String)
-        args.all? {|arg| actual.include?(arg) } && actual.uniq.size == actual.size
-      end
-    end
-
     RSpec::Matchers.define :be_sorted do
       diffable
       attr_reader :expected
@@ -124,34 +114,49 @@ module Spec
       match do
         opts = names.last.is_a?(Hash) ? names.pop : {}
         source = opts.delete(:source)
-        groups = Array(opts[:groups])
-        groups << opts
-        @errors = names.map do |name|
-          name, version, platform = name.split(/\s+/)
-          require_path = name == "bundler" ? "#{lib_dir}/bundler" : name.tr("-", "/")
+        groups = Array(opts.delete(:groups)).map(&:inspect).join(", ")
+        opts[:raise_on_error] = false
+        @errors = names.map do |full_name|
+          name, version, platform = full_name.split(/\s+/)
+          require_path = name.tr("-", "/")
           version_const = name == "bundler" ? "Bundler::VERSION" : Spec::Builders.constantize(name)
-          begin
-            run! "require '#{require_path}.rb'; puts #{version_const}", *groups
-          rescue StandardError => e
-            next "#{name} is not installed:\n#{indent(e)}"
-          end
-          actual_version, actual_platform = out.strip.split(/\s+/, 2)
-          unless Gem::Version.new(actual_version) == Gem::Version.new(version)
+          source_const = "#{Spec::Builders.constantize(name)}_SOURCE"
+          ruby <<~R, opts
+            require 'bundler'
+            Bundler.setup(#{groups})
+
+            require '#{require_path}'
+            actual_version, actual_platform = #{version_const}.split(/\s+/, 2)
+            unless Gem::Version.new(actual_version) == Gem::Version.new('#{version}')
+              puts actual_version
+              exit 64
+            end
+            unless actual_platform.to_s == '#{platform}'
+              puts actual_platform
+              exit 65
+            end
+            require '#{require_path}/source'
+            exit 0 if #{source.nil?}
+            actual_source = #{source_const}
+            unless actual_source == '#{source}'
+              puts actual_source
+              exit 66
+            end
+          R
+          next if exitstatus == 0
+          if exitstatus == 64
+            actual_version = out.split("\n").last
             next "#{name} was expected to be at version #{version} but was #{actual_version}"
           end
-          unless actual_platform == platform
+          if exitstatus == 65
+            actual_platform = out.split("\n").last
             next "#{name} was expected to be of platform #{platform} but was #{actual_platform}"
           end
-          next unless source
-          begin
-            source_const = "#{Spec::Builders.constantize(name)}_SOURCE"
-            run! "require '#{require_path}/source'; puts #{source_const}", *groups
-          rescue StandardError
-            next "#{name} does not have a source defined:\n#{indent(e)}"
-          end
-          unless out.strip == source
-            next "Expected #{name} (#{version}) to be installed from `#{source}`, was actually from `#{out}`"
+          if exitstatus == 66
+            actual_source = out.split("\n").last
+            next "Expected #{name} (#{version}) to be installed from `#{source}`, was actually from `#{actual_source}`"
           end
+          next "Command to check for inclusion of gem #{full_name} failed"
         end.compact
 
         @errors.empty?
@@ -159,26 +164,34 @@ module Spec
 
       match_when_negated do
         opts = names.last.is_a?(Hash) ? names.pop : {}
-        groups = Array(opts[:groups]) || []
+        groups = Array(opts.delete(:groups)).map(&:inspect).join(", ")
+        opts[:raise_on_error] = false
         @errors = names.map do |name|
           name, version = name.split(/\s+/, 2)
-          begin
-            run <<-R, *(groups + [opts])
-              begin
-                require '#{name}'
-                puts #{Spec::Builders.constantize(name)}
-              rescue LoadError, NameError
-                puts "WIN"
+          ruby <<-R, opts
+            begin
+              require 'bundler'
+              Bundler.setup(#{groups})
+            rescue Bundler::GemNotFound, Bundler::GitError
+              exit 0
+            end
+
+            begin
+              require '#{name}'
+              name_constant = #{Spec::Builders.constantize(name)}
+              if #{version.nil?} || name_constant == '#{version}'
+                exit 64
+              else
+                exit 0
               end
-            R
-          rescue StandardError => e
-            next "checking for #{name} failed:\n#{e}\n#{e.backtrace.join("\n")}"
-          end
-          next if out == "WIN"
+            rescue LoadError, NameError
+              exit 0
+            end
+          R
+          next if exitstatus == 0
+          next "command to check version of #{name} installed failed" unless exitstatus == 64
           next "expected #{name} to not be installed, but it was" if version.nil?
-          if Gem::Version.new(out) == Gem::Version.new(version)
-            next "expected #{name} (#{version}) not to be installed, but it was"
-          end
+          next "expected #{name} (#{version}) not to be installed, but it was"
         end.compact
 
         @errors.empty?
@@ -195,10 +208,6 @@ module Spec
     RSpec::Matchers.define_negated_matcher :not_include_gems, :include_gems
     RSpec::Matchers.alias_matcher :include_gem, :include_gems
 
-    def have_lockfile(expected)
-      read_as(strip_whitespace(expected))
-    end
-
     def plugin_should_be_installed(*names)
       names.each do |name|
         expect(Bundler::Plugin).to be_installed(name)
@@ -212,13 +221,5 @@ module Spec
         expect(Bundler::Plugin).not_to be_installed(name)
       end
     end
-
-    def lockfile_should_be(expected)
-      expect(bundled_app("Gemfile.lock")).to have_lockfile(expected)
-    end
-
-    def gemfile_should_be(expected)
-      expect(bundled_app("Gemfile")).to read_as(strip_whitespace(expected))
-    end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/support/parallel.rb
+++ /dev/null
@@ -1,5 +0,0 @@
-# frozen_string_literal: true
-
-RSpec.configure do |config|
-  config.silence_filter_announcements = true
-end
--- ruby2.7-2.7.6.orig/spec/bundler/support/path.rb
+++ ruby2.7-2.7.6/spec/bundler/support/path.rb
@@ -5,54 +5,98 @@ require "rbconfig"
 
 module Spec
   module Path
+    def source_root
+      @source_root ||= Pathname.new(ruby_core? ? "../../.." : "../..").expand_path(__dir__)
+    end
+
     def root
-      @root ||= Pathname.new(ruby_core? ? "../../../.." : "../../..").expand_path(__FILE__)
+      @root ||= system_gem_path("gems/bundler-#{Bundler::VERSION}")
     end
 
     def gemspec
-      @gemspec ||= root.join(ruby_core? ? "lib/bundler/bundler.gemspec" : "bundler.gemspec")
+      @gemspec ||= source_root.join(relative_gemspec)
+    end
+
+    def relative_gemspec
+      @relative_gemspec ||= ruby_core? ? "lib/bundler/bundler.gemspec" : "bundler.gemspec"
     end
 
     def gemspec_dir
       @gemspec_dir ||= gemspec.parent
     end
 
+    def loaded_gemspec
+      @loaded_gemspec ||= Gem::Specification.load(gemspec.to_s)
+    end
+
+    def test_gemfile
+      @test_gemfile ||= tool_dir.join("test_gems.rb")
+    end
+
+    def rubocop_gemfile
+      @rubocop_gemfile ||= source_root.join(rubocop_gemfile_basename)
+    end
+
+    def standard_gemfile
+      @standard_gemfile ||= source_root.join(standard_gemfile_basename)
+    end
+
+    def dev_gemfile
+      @dev_gemfile ||= tool_dir.join("dev_gems.rb")
+    end
+
     def bindir
-      @bindir ||= root.join(ruby_core? ? "libexec" : "exe")
+      @bindir ||= source_root.join(ruby_core? ? "libexec" : "exe")
+    end
+
+    def installed_bindir
+      @installed_bindir ||= system_gem_path("bin")
     end
 
     def gem_cmd
-      @gem_cmd ||= ruby_core? ? root.join("bin/gem") : "gem"
+      @gem_cmd ||= ruby_core? ? source_root.join("bin/gem") : "gem"
     end
 
     def gem_bin
       @gem_bin ||= ruby_core? ? ENV["GEM_COMMAND"] : "gem"
     end
 
+    def path
+      env_path = ENV["PATH"]
+      env_path = env_path.split(File::PATH_SEPARATOR).reject {|path| path == bindir.to_s }.join(File::PATH_SEPARATOR) if ruby_core?
+      env_path
+    end
+
     def spec_dir
-      @spec_dir ||= root.join(ruby_core? ? "spec/bundler" : "spec")
+      @spec_dir ||= source_root.join(ruby_core? ? "spec/bundler" : "spec")
     end
 
-    def tracked_files
-      skip "not in git working directory" unless git_root_dir?
+    def api_request_limit_hack_file
+      spec_dir.join("support/api_request_limit_hax.rb")
+    end
 
-      @tracked_files ||= ruby_core? ? `git ls-files -z -- lib/bundler lib/bundler.rb spec/bundler man/bundler*` : `git ls-files -z`
+    def man_dir
+      @man_dir ||= lib_dir.join("bundler/man")
     end
 
-    def shipped_files
-      skip "not in git working directory" unless git_root_dir?
+    def tracked_files
+      @tracked_files ||= git_ls_files(tracked_files_glob)
+    end
 
-      @shipped_files ||= ruby_core? ? `git ls-files -z -- lib/bundler lib/bundler.rb man/bundler* libexec/bundle*` : `git ls-files -z -- lib man exe CHANGELOG.md LICENSE.md README.md bundler.gemspec`
+    def shipped_files
+      @shipped_files ||= loaded_gemspec.files
     end
 
     def lib_tracked_files
-      skip "not in git working directory" unless git_root_dir?
+      @lib_tracked_files ||= git_ls_files(lib_tracked_files_glob)
+    end
 
-      @lib_tracked_files ||= ruby_core? ? `git ls-files -z -- lib/bundler lib/bundler.rb` : `git ls-files -z -- lib`
+    def man_tracked_files
+      @man_tracked_files ||= git_ls_files(man_tracked_files_glob)
     end
 
     def tmp(*path)
-      root.join("tmp", scope, *path)
+      source_root.join("tmp", scope, *path)
     end
 
     def scope
@@ -67,10 +111,10 @@ module Spec
     end
 
     def default_bundle_path(*path)
-      if Bundler::VERSION.split(".").first.to_i < 3
-        system_gem_path(*path)
+      if Bundler.feature_flag.default_install_uses_path?
+        local_gem_path(*path)
       else
-        bundled_app(*[".bundle", ENV.fetch("BUNDLER_SPEC_RUBY_ENGINE", Gem.ruby_engine), RbConfig::CONFIG["ruby_version"], *path].compact)
+        system_gem_path(*path)
       end
     end
 
@@ -80,8 +124,6 @@ module Spec
       root.join(*path)
     end
 
-    alias_method :bundled_app1, :bundled_app
-
     def bundled_app2(*path)
       root = tmp.join("bundled_app2")
       FileUtils.mkdir_p(root)
@@ -89,17 +131,37 @@ module Spec
     end
 
     def vendored_gems(path = nil)
-      bundled_app(*["vendor/bundle", Gem.ruby_engine, RbConfig::CONFIG["ruby_version"], path].compact)
+      scoped_gem_path(bundled_app("vendor/bundle")).join(*[path].compact)
     end
 
     def cached_gem(path)
       bundled_app("vendor/cache/#{path}.gem")
     end
 
+    def bundled_app_gemfile
+      bundled_app("Gemfile")
+    end
+
+    def bundled_app_lock
+      bundled_app("Gemfile.lock")
+    end
+
+    def base_system_gem_path
+      scoped_gem_path(base_system_gems)
+    end
+
     def base_system_gems
       tmp.join("gems/base")
     end
 
+    def rubocop_gems
+      tmp.join("gems/rubocop")
+    end
+
+    def standard_gems
+      tmp.join("gems/standard")
+    end
+
     def file_uri_for(path)
       protocol = "file://"
       root = Gem.win_platform? ? "/" : ""
@@ -135,14 +197,37 @@ module Spec
       tmp("gems/system", *path)
     end
 
+    def pristine_system_gem_path
+      tmp("gems/base_system")
+    end
+
+    def local_gem_path(*path, base: bundled_app)
+      scoped_gem_path(base.join(".bundle")).join(*path)
+    end
+
+    def scoped_gem_path(base)
+      base.join(Gem.ruby_engine, RbConfig::CONFIG["ruby_version"])
+    end
+
     def lib_path(*args)
       tmp("libs", *args)
     end
 
+    def source_lib_dir
+      source_root.join("lib")
+    end
+
     def lib_dir
       root.join("lib")
     end
 
+    # Sometimes rubygems version under test does not include
+    # https://github.com/rubygems/rubygems/pull/2728 and will not always end up
+    # activating the current bundler. In that case, require bundler absolutely.
+    def entrypoint
+      Gem.rubygems_version < Gem::Version.new("3.1.a") ? "#{lib_dir}/bundler" : "bundler"
+    end
+
     def global_plugin_gem(*args)
       home ".bundle", "plugin", "gems", *args
     end
@@ -155,18 +240,11 @@ module Spec
       tmp "tmpdir", *args
     end
 
-    def with_root_gemspec
-      if ruby_core?
-        root_gemspec = root.join("bundler.gemspec")
-        # Dir.chdir(root) for Dir.glob in gemspec
-        spec = Dir.chdir(root) { Gem::Specification.load(gemspec.to_s) }
-        spec.bindir = "libexec"
-        File.open(root_gemspec.to_s, "w") {|f| f.write spec.to_ruby }
-        yield(root_gemspec)
-        FileUtils.rm(root_gemspec)
-      else
-        yield(gemspec)
-      end
+    def replace_version_file(version, dir: source_root)
+      version_file = File.expand_path("lib/bundler/version.rb", dir)
+      contents = File.read(version_file)
+      contents.sub!(/(^\s+VERSION\s*=\s*)"#{Gem::Version::VERSION_PATTERN}"/, %(\\1"#{version}"))
+      File.open(version_file, "w") {|f| f << contents }
     end
 
     def ruby_core?
@@ -180,12 +258,60 @@ module Spec
       end
     end
 
-    extend self
+    def git_root
+      ruby_core? ? source_root : source_root.parent
+    end
+
+    private
+
+    def git_ls_files(glob)
+      skip "Not running on a git context, since running tests from a tarball" if ruby_core_tarball?
+
+      sys_exec("git ls-files -z -- #{glob}", :dir => source_root).split("\x0")
+    end
+
+    def tracked_files_glob
+      ruby_core? ? "lib/bundler lib/bundler.rb spec/bundler man/bundle*" : ""
+    end
+
+    def lib_tracked_files_glob
+      ruby_core? ? "lib/bundler lib/bundler.rb" : "lib"
+    end
+
+    def man_tracked_files_glob
+      ruby_core? ? "man/bundle* man/gemfile*" : "lib/bundler/man/bundle*.1 lib/bundler/man/gemfile*.5"
+    end
+
+    def ruby_core_tarball?
+      !git_root.join(".git").directory?
+    end
 
-  private
+    def rubocop_gemfile_basename
+      filename = if RUBY_VERSION.start_with?("2.3")
+        "rubocop23_gems"
+      elsif RUBY_VERSION.start_with?("2.4")
+        "rubocop24_gems"
+      else
+        "rubocop_gems"
+      end
+      tool_dir.join("#{filename}.rb")
+    end
 
-    def git_root_dir?
-      root.to_s == `git rev-parse --show-toplevel`.chomp
+    def standard_gemfile_basename
+      filename = if RUBY_VERSION.start_with?("2.3")
+        "standard23_gems"
+      elsif RUBY_VERSION.start_with?("2.4")
+        "standard24_gems"
+      else
+        "standard_gems"
+      end
+      tool_dir.join("#{filename}.rb")
     end
+
+    def tool_dir
+      source_root.join("tool/bundler")
+    end
+
+    extend self
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/support/platforms.rb
+++ ruby2.7-2.7.6/spec/bundler/support/platforms.rb
@@ -24,20 +24,32 @@ module Spec
       Gem::Platform.new(["x86", "linux", nil])
     end
 
-    def mswin
+    def x86_mswin32
       Gem::Platform.new(["x86", "mswin32", nil])
     end
 
-    def mingw
+    def x64_mswin64
+      Gem::Platform.new(["x64", "mswin64", nil])
+    end
+
+    def x86_mingw32
       Gem::Platform.new(["x86", "mingw32", nil])
     end
 
-    def x64_mingw
+    def x64_mingw32
       Gem::Platform.new(["x64", "mingw32", nil])
     end
 
+    def x64_mingw_ucrt
+      Gem::Platform.new(["x64", "mingw", "ucrt"])
+    end
+
+    def windows_platforms
+      [x86_mswin32, x64_mswin64, x86_mingw32, x64_mingw32, x64_mingw_ucrt]
+    end
+
     def all_platforms
-      [rb, java, linux, mswin, mingw, x64_mingw]
+      [rb, java, linux, windows_platforms].flatten
     end
 
     def local
@@ -55,28 +67,28 @@ module Spec
     def local_tag
       if RUBY_PLATFORM == "java"
         :jruby
+      elsif ["x64-mingw32", "x64-mingw-ucrt"].include?(RUBY_PLATFORM)
+        :windows
       else
         :ruby
       end
     end
 
     def not_local_tag
-      [:ruby, :jruby].find {|tag| tag != local_tag }
+      [:jruby, :windows, :ruby].find {|tag| tag != local_tag }
     end
 
     def local_ruby_engine
-      ENV["BUNDLER_SPEC_RUBY_ENGINE"] || RUBY_ENGINE
+      RUBY_ENGINE
     end
 
     def local_engine_version
-      return ENV["BUNDLER_SPEC_RUBY_ENGINE_VERSION"] if ENV["BUNDLER_SPEC_RUBY_ENGINE_VERSION"]
-
-      RUBY_ENGINE_VERSION
+      RUBY_ENGINE == "ruby" ? Gem.ruby_version : RUBY_ENGINE_VERSION
     end
 
     def not_local_engine_version
       case not_local_tag
-      when :ruby
+      when :ruby, :windows
         not_local_ruby_version
       when :jruby
         "1.6.1"
@@ -92,15 +104,11 @@ module Spec
     end
 
     def lockfile_platforms
-      local_platforms.map(&:to_s).sort.join("\n  ")
+      lockfile_platforms_for([specific_local_platform])
     end
 
-    def local_platforms
-      if Bundler.feature_flag.specific_platform?
-        [local, specific_local_platform]
-      else
-        [local]
-      end
+    def lockfile_platforms_for(platforms)
+      platforms.map(&:to_s).sort.join("\n  ")
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/support/rubygems_ext.rb
+++ ruby2.7-2.7.6/spec/bundler/support/rubygems_ext.rb
@@ -2,73 +2,37 @@
 
 require_relative "path"
 
+$LOAD_PATH.unshift(Spec::Path.source_lib_dir.to_s)
+
 module Spec
   module Rubygems
-    DEV_DEPS = {
-      "automatiek" => "~> 0.3.0",
-      "parallel_tests" => "~> 2.29",
-      "rake" => "~> 12.0",
-      "ronn" => "~> 0.7.3",
-      "rspec" => "~> 3.8",
-      "rubocop" => "= 0.77.0",
-      "rubocop-performance" => "= 1.5.1",
-    }.freeze
-
-    DEPS = {
-      "rack" => "~> 2.0",
-      "rack-test" => "~> 1.1",
-      "artifice" => "~> 0.6.0",
-      "compact_index" => "~> 0.11.0",
-      "sinatra" => "~> 2.0",
-      # Rake version has to be consistent for tests to pass
-      "rake" => "12.3.2",
-      "builder" => "~> 3.2",
-      # ruby-graphviz is used by the viz tests
-      "ruby-graphviz" => ">= 0.a",
-    }.freeze
-
     extend self
 
     def dev_setup
-      deps = DEV_DEPS
-
-      # JRuby can't build ronn, so we skip that
-      deps.delete("ronn") if RUBY_ENGINE == "jruby"
-
-      install_gems(deps)
+      install_gems(dev_gemfile)
     end
 
     def gem_load(gem_name, bin_container)
-      require_relative "rubygems_version_manager"
-      RubygemsVersionManager.new(ENV["RGV"]).switch
+      require_relative "switch_rubygems"
 
       gem_load_and_activate(gem_name, bin_container)
     end
 
+    def gem_load_and_possibly_install(gem_name, bin_container)
+      require_relative "switch_rubygems"
+
+      gem_load_activate_and_possibly_install(gem_name, bin_container)
+    end
+
     def gem_require(gem_name)
       gem_activate(gem_name)
       require gem_name
     end
 
-    def setup
-      require "fileutils"
+    def test_setup
+      setup_test_paths
 
-      Gem.clear_paths
-
-      ENV["BUNDLE_PATH"] = nil
-      ENV["GEM_HOME"] = ENV["GEM_PATH"] = Path.base_system_gems.to_s
-      ENV["PATH"] = [Path.bindir, Path.system_gem_path.join("bin"), ENV["PATH"]].join(File::PATH_SEPARATOR)
-
-      manifest = DEPS.to_a.sort_by(&:first).map {|k, v| "#{k} => #{v}\n" }
-      manifest_path = Path.base_system_gems.join("manifest.txt")
-      # it's OK if there are extra gems
-      if !manifest_path.file? || !(manifest - manifest_path.readlines).empty?
-        FileUtils.rm_rf(Path.base_system_gems)
-        FileUtils.mkdir_p(Path.base_system_gems)
-        puts "installing gems for the tests to use..."
-        install_gems(DEPS)
-        manifest_path.open("wb") {|f| f << manifest.join }
-      end
+      require "fileutils"
 
       FileUtils.mkdir_p(Path.home)
       FileUtils.mkdir_p(Path.tmpdir)
@@ -80,28 +44,134 @@ module Spec
       Gem::DefaultUserInteraction.ui = Gem::SilentUI.new
     end
 
-  private
+    def install_parallel_test_deps
+      Gem.clear_paths
+
+      require "parallel"
+      require "fileutils"
+
+      install_test_deps
+
+      (2..Parallel.processor_count).each do |n|
+        source = Path.source_root.join("tmp", "1")
+        destination = Path.source_root.join("tmp", n.to_s)
+
+        FileUtils.rm_rf destination
+        FileUtils.cp_r source, destination
+      end
+    end
+
+    def setup_test_paths
+      Gem.clear_paths
+
+      ENV["BUNDLE_PATH"] = nil
+      ENV["GEM_HOME"] = ENV["GEM_PATH"] = Path.base_system_gem_path.to_s
+      ENV["PATH"] = [Path.system_gem_path.join("bin"), ENV["PATH"]].join(File::PATH_SEPARATOR)
+      ENV["PATH"] = [Path.bindir, ENV["PATH"]].join(File::PATH_SEPARATOR) if Path.ruby_core?
+    end
+
+    def install_test_deps
+      install_gems(test_gemfile, Path.base_system_gems.to_s)
+      install_gems(rubocop_gemfile, Path.rubocop_gems.to_s)
+      install_gems(standard_gemfile, Path.standard_gems.to_s)
+    end
+
+    def check_source_control_changes(success_message:, error_message:)
+      require "open3"
+
+      output, status = Open3.capture2e("git status --porcelain")
+
+      if status.success? && output.empty?
+        puts
+        puts success_message
+        puts
+      else
+        system("git status --porcelain")
+
+        puts
+        puts error_message
+        puts
+
+        exit(1)
+      end
+    end
+
+    private
 
     def gem_load_and_activate(gem_name, bin_container)
       gem_activate(gem_name)
       load Gem.bin_path(gem_name, bin_container)
     rescue Gem::LoadError => e
-      abort "We couln't activate #{gem_name} (#{e.requirement}). Run `gem install #{gem_name}:'#{e.requirement}'`"
+      abort "We couldn't activate #{gem_name} (#{e.requirement}). Run `gem install #{gem_name}:'#{e.requirement}'`"
+    end
+
+    def gem_load_activate_and_possibly_install(gem_name, bin_container)
+      gem_activate_and_possibly_install(gem_name)
+      load Gem.bin_path(gem_name, bin_container)
+    end
+
+    def gem_activate_and_possibly_install(gem_name)
+      gem_activate(gem_name)
+    rescue Gem::LoadError => e
+      Gem.install(gem_name, e.requirement)
+      retry
     end
 
     def gem_activate(gem_name)
-      gem_requirement = DEV_DEPS[gem_name]
+      require "bundler"
+      gem_requirement = Bundler::LockfileParser.new(File.read(dev_lockfile)).specs.find {|spec| spec.name == gem_name }.version
       gem gem_name, gem_requirement
     end
 
-    def install_gems(gems)
-      reqs, no_reqs = gems.partition {|_, req| !req.nil? && !req.split(" ").empty? }
-      no_reqs.map!(&:first)
-      reqs.map! {|name, req| "'#{name}:#{req}'" }
-      deps = reqs.concat(no_reqs).join(" ")
-      gem = ENV["GEM_COMMAND"] || "#{Gem.ruby} -S gem --backtrace"
-      cmd = "#{gem} install #{deps} --no-document --conservative"
-      system(cmd) || raise("Installing gems #{deps} for the tests to use failed!")
+    def install_gems(gemfile, path = nil)
+      old_gemfile = ENV["BUNDLE_GEMFILE"]
+      old_orig_gemfile = ENV["BUNDLER_ORIG_BUNDLE_GEMFILE"]
+      ENV["BUNDLE_GEMFILE"] = gemfile.to_s
+      ENV["BUNDLER_ORIG_BUNDLE_GEMFILE"] = nil
+
+      if path
+        old_path = ENV["BUNDLE_PATH"]
+        ENV["BUNDLE_PATH"] = path
+      else
+        old_path__system = ENV["BUNDLE_PATH__SYSTEM"]
+        ENV["BUNDLE_PATH__SYSTEM"] = "true"
+      end
+
+      puts `#{Gem.ruby} #{File.expand_path("support/bundle.rb", Path.spec_dir)} install --verbose`
+      raise unless $?.success?
+    ensure
+      if path
+        ENV["BUNDLE_PATH"] = old_path
+      else
+        ENV["BUNDLE_PATH__SYSTEM"] = old_path__system
+      end
+
+      ENV["BUNDLER_ORIG_BUNDLE_GEMFILE"] = old_orig_gemfile
+      ENV["BUNDLE_GEMFILE"] = old_gemfile
+    end
+
+    def test_gemfile
+      Path.test_gemfile
+    end
+
+    def rubocop_gemfile
+      Path.rubocop_gemfile
+    end
+
+    def standard_gemfile
+      Path.standard_gemfile
+    end
+
+    def dev_gemfile
+      Path.dev_gemfile
+    end
+
+    def dev_lockfile
+      lockfile_for(dev_gemfile)
+    end
+
+    def lockfile_for(gemfile)
+      Pathname.new("#{gemfile.expand_path}.lock")
     end
   end
 end
--- ruby2.7-2.7.6.orig/spec/bundler/support/rubygems_version_manager.rb
+++ ruby2.7-2.7.6/spec/bundler/support/rubygems_version_manager.rb
@@ -15,12 +15,37 @@ class RubygemsVersionManager
   def switch
     return if use_system?
 
+    assert_system_features_not_loaded!
+
     switch_local_copy_if_needed
 
     reexec_if_needed
   end
 
-private
+  def assert_system_features_not_loaded!
+    at_exit do
+      rubylibdir = RbConfig::CONFIG["rubylibdir"]
+
+      rubygems_path = rubylibdir + "/rubygems"
+      rubygems_default_path = rubygems_path + "/defaults"
+
+      bundler_path = rubylibdir + "/bundler"
+      bundler_exemptions = Gem.rubygems_version < Gem::Version.new("3.2.0") ? [bundler_path + "/errors.rb"] : []
+
+      bad_loaded_features = $LOADED_FEATURES.select do |loaded_feature|
+        (loaded_feature.start_with?(rubygems_path) && !loaded_feature.start_with?(rubygems_default_path)) ||
+          (loaded_feature.start_with?(bundler_path) && !bundler_exemptions.any? {|bundler_exemption| loaded_feature.start_with?(bundler_exemption) })
+      end
+
+      errors = if bad_loaded_features.any?
+        all_commands_output + "the following features were incorrectly loaded:\n#{bad_loaded_features.join("\n")}"
+      end
+
+      raise errors if errors
+    end
+  end
+
+  private
 
   def use_system?
     @source.nil?
@@ -31,12 +56,9 @@ private
 
     require "rbconfig"
 
-    ruby = File.join(RbConfig::CONFIG["bindir"], RbConfig::CONFIG["ruby_install_name"])
-    ruby << RbConfig::CONFIG["EXEEXT"]
-
-    cmd = [ruby, $0, *ARGV].compact
+    cmd = [RbConfig.ruby, $0, *ARGV].compact
 
-    ENV["RUBYOPT"] = "-I#{local_copy_path.join("lib")} #{ENV["RUBYOPT"]}"
+    ENV["RUBYOPT"] = opt_add("-I#{local_copy_path.join("lib")}", opt_remove("--disable-gems", ENV["RUBYOPT"]))
 
     exec(ENV, *cmd)
   end
@@ -44,15 +66,13 @@ private
   def switch_local_copy_if_needed
     return unless local_copy_switch_needed?
 
-    Dir.chdir(local_copy_path) do
-      sys_exec!("git remote update")
-      sys_exec!("git checkout #{target_tag} --quiet")
-    end
+    sys_exec("git checkout #{target_tag}", :dir => local_copy_path)
 
     ENV["RGV"] = local_copy_path.to_s
   end
 
   def rubygems_unrequire_needed?
+    require "rubygems"
     !$LOADED_FEATURES.include?(local_copy_path.join("lib/rubygems.rb").to_s)
   end
 
@@ -65,9 +85,7 @@ private
   end
 
   def local_copy_tag
-    Dir.chdir(local_copy_path) do
-      sys_exec!("git rev-parse --abbrev-ref HEAD")
-    end
+    sys_exec("git rev-parse --abbrev-ref HEAD", :dir => local_copy_path)
   end
 
   def local_copy_path
@@ -77,11 +95,10 @@ private
   def resolve_local_copy_path
     return expanded_source if source_is_path?
 
-    rubygems_path = root.join("tmp/rubygems")
+    rubygems_path = source_root.join("tmp/rubygems")
 
     unless rubygems_path.directory?
-      rubygems_path.parent.mkpath
-      sys_exec!("git clone https://github.com/rubygems/rubygems.git #{rubygems_path}")
+      sys_exec("git clone .. #{rubygems_path}", :dir => source_root)
     end
 
     rubygems_path
@@ -92,7 +109,7 @@ private
   end
 
   def expanded_source
-    @expanded_source ||= Pathname.new(@source).expand_path(root)
+    @expanded_source ||= Pathname.new(@source).expand_path(source_root)
   end
 
   def resolve_target_tag
--- ruby2.7-2.7.6.orig/spec/bundler/support/sometimes.rb
+++ /dev/null
@@ -1,57 +0,0 @@
-# frozen_string_literal: true
-
-module Sometimes
-  def run_with_retries(example_to_run, retries)
-    example = RSpec.current_example
-    example.metadata[:retries] ||= retries
-
-    retries.times do |t|
-      example.metadata[:retried] = t + 1
-      example.instance_variable_set(:@exception, nil)
-      example_to_run.run
-      break unless example.exception
-    end
-
-    if e = example.exception
-      new_exception = e.exception(e.message + "[Retried #{retries} times]")
-      new_exception.set_backtrace e.backtrace
-      example.instance_variable_set(:@exception, new_exception)
-    end
-  end
-end
-
-RSpec.configure do |config|
-  config.include Sometimes
-  config.alias_example_to :sometimes, :sometimes => true
-  config.add_setting :sometimes_retry_count, :default => 5
-
-  config.around(:each, :sometimes => true) do |example|
-    retries = example.metadata[:retries] || RSpec.configuration.sometimes_retry_count
-    run_with_retries(example, retries)
-  end
-
-  config.after(:suite) do
-    message = proc do |color, text|
-      colored = RSpec::Core::Formatters::ConsoleCodes.wrap(text, color)
-      notification = RSpec::Core::Notifications::MessageNotification.new(colored)
-      formatter = RSpec.configuration.formatters.first
-      formatter.message(notification) if formatter.respond_to?(:message)
-    end
-
-    retried_examples = RSpec.world.example_groups.map do |g|
-      g.descendants.map do |d|
-        d.filtered_examples.select do |e|
-          e.metadata[:sometimes] && e.metadata.fetch(:retried, 1) > 1
-        end
-      end
-    end.flatten
-
-    message.call(retried_examples.empty? ? :green : :yellow, "\n\nRetried examples: #{retried_examples.count}")
-
-    retried_examples.each do |e|
-      message.call(:cyan, "  #{e.full_description}")
-      path = RSpec::Core::Metadata.relative_path(e.location)
-      message.call(:cyan, "  [#{e.metadata[:retried]}/#{e.metadata[:retries]}] " + path)
-    end
-  end
-end
--- ruby2.7-2.7.6.orig/spec/bundler/support/streams.rb
+++ /dev/null
@@ -1,19 +0,0 @@
-# frozen_string_literal: true
-
-require "stringio"
-
-def capture(*args)
-  opts = args.pop if args.last.is_a?(Hash)
-  opts ||= {}
-
-  args.map!(&:to_s)
-  begin
-    result = StringIO.new
-    result.close if opts[:closed]
-    args.each {|stream| eval "$#{stream} = result" }
-    yield
-  ensure
-    args.each {|stream| eval("$#{stream} = #{stream.upcase}") }
-  end
-  result.string
-end
--- ruby2.7-2.7.6.orig/spec/bundler/support/sudo.rb
+++ ruby2.7-2.7.6/spec/bundler/support/sudo.rb
@@ -6,6 +6,10 @@ module Spec
       @which_sudo ||= Bundler.which("sudo")
     end
 
+    def self.write_safe_config
+      File.write(Spec::Path.tmp("gitconfig"), "[safe]\n\tdirectory = #{Spec::Path.git_root}")
+    end
+
     def sudo(cmd)
       raise "sudo not present" unless Sudo.present?
       sys_exec("sudo #{cmd}")
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/support/switch_rubygems.rb
@@ -0,0 +1,4 @@
+# frozen_string_literal: true
+
+require_relative "rubygems_version_manager"
+RubygemsVersionManager.new(ENV["RGV"]).switch
--- ruby2.7-2.7.6.orig/spec/bundler/update/gemfile_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/update/gemfile_spec.rb
@@ -8,8 +8,8 @@ RSpec.describe "bundle update" do
         gem 'rack'
       G
 
-      bundle! :install, :gemfile => bundled_app("NotGemfile")
-      bundle! :update, :gemfile => bundled_app("NotGemfile"), :all => true
+      bundle :install, :gemfile => bundled_app("NotGemfile")
+      bundle :update, :gemfile => bundled_app("NotGemfile"), :all => true
 
       # Specify BUNDLE_GEMFILE for `the_bundle`
       # to retrieve the proper Gemfile
@@ -26,11 +26,11 @@ RSpec.describe "bundle update" do
       G
 
       bundle "config set --local gemfile #{bundled_app("NotGemfile")}"
-      bundle! :install
+      bundle :install
     end
 
     it "uses the gemfile to update" do
-      bundle! "update", :all => true
+      bundle "update", :all => true
       bundle "list"
 
       expect(out).to include("rack (1.0.0)")
@@ -38,12 +38,10 @@ RSpec.describe "bundle update" do
 
     it "uses the gemfile while in a subdirectory" do
       bundled_app("subdir").mkpath
-      Dir.chdir(bundled_app("subdir")) do
-        bundle! "update", :all => true
-        bundle "list"
+      bundle "update", :all => true, :dir => bundled_app("subdir")
+      bundle "list", :dir => bundled_app("subdir")
 
-        expect(out).to include("rack (1.0.0)")
-      end
+      expect(out).to include("rack (1.0.0)")
     end
   end
 end
--- /dev/null
+++ ruby2.7-2.7.6/spec/bundler/update/gems/fund_spec.rb
@@ -0,0 +1,50 @@
+# frozen_string_literal: true
+
+RSpec.describe "bundle update" do
+  before do
+    build_repo2 do
+      build_gem "has_funding_and_other_metadata" do |s|
+        s.metadata = {
+          "bug_tracker_uri"   => "https://example.com/user/bestgemever/issues",
+          "changelog_uri"     => "https://example.com/user/bestgemever/CHANGELOG.md",
+          "documentation_uri" => "https://www.example.info/gems/bestgemever/0.0.1",
+          "homepage_uri"      => "https://bestgemever.example.io",
+          "mailing_list_uri"  => "https://groups.example.com/bestgemever",
+          "funding_uri"       => "https://example.com/has_funding_and_other_metadata/funding",
+          "source_code_uri"   => "https://example.com/user/bestgemever",
+          "wiki_uri"          => "https://example.com/user/bestgemever/wiki",
+        }
+      end
+
+      build_gem "has_funding", "1.2.3" do |s|
+        s.metadata = {
+          "funding_uri"       => "https://example.com/has_funding/funding",
+        }
+      end
+    end
+
+    gemfile <<-G
+      source "#{file_uri_for(gem_repo2)}"
+      gem 'has_funding_and_other_metadata'
+      gem 'has_funding', '< 2.0'
+    G
+
+    bundle :install
+  end
+
+  context "when listed gems are updated" do
+    before do
+      gemfile <<-G
+        source "#{file_uri_for(gem_repo2)}"
+        gem 'has_funding_and_other_metadata'
+        gem 'has_funding'
+      G
+
+      bundle :update, :all => true
+    end
+
+    it "displays fund message" do
+      expect(out).to include("2 installed gems you directly depend on are looking for funding.")
+    end
+  end
+end
--- ruby2.7-2.7.6.orig/spec/bundler/update/gems/post_install_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/update/gems/post_install_spec.rb
@@ -10,9 +10,9 @@ RSpec.describe "bundle update" do
       gem 'thin'
     G
 
-    bundle! "config set #{config}" if config
+    bundle "config set #{config}" if config
 
-    bundle! :install
+    bundle :install
   end
 
   shared_examples "a config observer" do
@@ -52,7 +52,7 @@ RSpec.describe "bundle update" do
         gem 'thin'
       G
 
-      bundle! :update, :all => true
+      bundle :update, :all => true
     end
 
     it_behaves_like "a post-install message outputter"
@@ -67,7 +67,7 @@ RSpec.describe "bundle update" do
         gem 'thin'
       G
 
-      bundle! :update, :all => true
+      bundle :update, :all => true
     end
 
     it_behaves_like "a post-install message outputter"
--- ruby2.7-2.7.6.orig/spec/bundler/update/git_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/update/git_spec.rb
@@ -7,12 +7,13 @@ RSpec.describe "bundle update" do
       update_git "foo", :branch => "omg"
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{lib_path("foo-1.0")}", :branch => "omg" do
           gem 'foo'
         end
       G
 
-      update_git "foo", :branch => "omg" do |s|
+      update_git "foo" do |s|
         s.write "lib/foo.rb", "FOO = '1.1'"
       end
 
@@ -27,11 +28,12 @@ RSpec.describe "bundle update" do
         s.add_dependency "activesupport", "= 3.0"
       end
 
-      install_gemfile! <<-G
-        gem "rails", :git => "#{lib_path("rails")}"
+      install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rails", :git => "#{file_uri_for(lib_path("rails"))}"
       G
 
-      bundle! "update rails"
+      bundle "update rails"
       expect(the_bundle).to include_gems "rails 3.0", "activesupport 3.0"
     end
 
@@ -40,12 +42,13 @@ RSpec.describe "bundle update" do
       update_git "foo", :branch => "omg", :path => lib_path("foo")
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         git "#{lib_path("foo")}", :branch => "omg" do
           gem 'foo'
         end
       G
 
-      update_git "foo", :branch => "omg", :path => lib_path("foo") do |s|
+      update_git "foo", :path => lib_path("foo") do |s|
         s.write "lib/foo.rb", "FOO = '1.1'"
       end
 
@@ -54,14 +57,15 @@ RSpec.describe "bundle update" do
       expect(the_bundle).to include_gems "foo 1.1"
     end
 
-    it "floats on master when updating all gems that are pinned to the source even if you have child dependencies" do
+    it "floats on main when updating all gems that are pinned to the source even if you have child dependencies" do
       build_git "foo", :path => lib_path("foo")
       build_gem "bar", :to_bundle => true do |s|
         s.add_dependency "foo"
       end
 
       install_gemfile <<-G
-        gem "foo", :git => "#{lib_path("foo")}"
+        source "#{file_uri_for(gem_repo1)}"
+        gem "foo", :git => "#{file_uri_for(lib_path("foo"))}"
         gem "bar"
       G
 
@@ -79,17 +83,19 @@ RSpec.describe "bundle update" do
       build_git "foo", :path => lib_path("foo_two")
 
       install_gemfile <<-G
-        gem "foo", "1.0", :git => "#{lib_path("foo_one")}"
+        source "#{file_uri_for(gem_repo1)}"
+        gem "foo", "1.0", :git => "#{file_uri_for(lib_path("foo_one"))}"
       G
 
       FileUtils.rm_rf lib_path("foo_one")
 
       install_gemfile <<-G
-        gem "foo", "1.0", :git => "#{lib_path("foo_two")}"
+        source "#{file_uri_for(gem_repo1)}"
+        gem "foo", "1.0", :git => "#{file_uri_for(lib_path("foo_two"))}"
       G
 
       expect(err).to be_empty
-      expect(out).to include("Fetching #{lib_path}/foo_two")
+      expect(out).to include("Fetching #{file_uri_for(lib_path)}/foo_two")
       expect(out).to include("Bundle complete!")
     end
 
@@ -97,9 +103,10 @@ RSpec.describe "bundle update" do
       build_git "foo"
       @remote = build_git("bar", :bare => true)
       update_git "foo", :remote => file_uri_for(@remote.path)
-      update_git "foo", :push => "master"
+      update_git "foo", :push => "main"
 
       install_gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem 'foo', :git => "#{@remote.path}"
       G
 
@@ -108,11 +115,11 @@ RSpec.describe "bundle update" do
       update_git "foo", :push => "fubar"
 
       gemfile <<-G
+        source "#{file_uri_for(gem_repo1)}"
         gem 'foo', :git => "#{@remote.path}", :tag => "fubar"
       G
 
       bundle "update", :all => true
-      expect(exitstatus).to eq(0) if exitstatus
     end
 
     describe "with submodules" do
@@ -131,10 +138,8 @@ RSpec.describe "bundle update" do
           s.add_dependency "submodule"
         end
 
-        Dir.chdir(lib_path("has_submodule-1.0")) do
-          sys_exec "git submodule add #{lib_path("submodule-1.0")} submodule-1.0"
-          `git commit -m "submodulator"`
-        end
+        sys_exec "git submodule add #{lib_path("submodule-1.0")} submodule-1.0", :dir => lib_path("has_submodule-1.0")
+        sys_exec "git commit -m \"submodulator\"", :dir => lib_path("has_submodule-1.0")
       end
 
       it "it unlocks the source when submodules are added to a git source" do
@@ -160,24 +165,24 @@ RSpec.describe "bundle update" do
       end
 
       it "unlocks the source when submodules are removed from git source", :git => ">= 2.9.0" do
-        install_gemfile! <<-G
+        install_gemfile <<-G
           source "#{file_uri_for(gem_repo4)}"
           git "#{lib_path("has_submodule-1.0")}", :submodules => true do
             gem "has_submodule"
           end
         G
 
-        run! "require 'submodule'"
+        run "require 'submodule'"
         expect(out).to eq("GIT")
 
-        install_gemfile! <<-G
+        install_gemfile <<-G
           source "#{file_uri_for(gem_repo4)}"
           git "#{lib_path("has_submodule-1.0")}" do
             gem "has_submodule"
           end
         G
 
-        run! "require 'submodule'"
+        run "require 'submodule'"
         expect(out).to eq("GEM")
       end
     end
@@ -186,12 +191,13 @@ RSpec.describe "bundle update" do
       build_git "foo", "1.0"
 
       install_gemfile <<-G
-        gem "foo", :git => "#{lib_path("foo-1.0")}"
+        source "#{file_uri_for(gem_repo1)}"
+        gem "foo", :git => "#{file_uri_for(lib_path("foo-1.0"))}"
       G
 
       lib_path("foo-1.0").join(".git").rmtree
 
-      bundle :update, :all => true
+      bundle :update, :all => true, :raise_on_error => false
       expect(err).to include(lib_path("foo-1.0").to_s).
         and match(/Git error: command `git fetch.+has failed/)
     end
@@ -205,7 +211,7 @@ RSpec.describe "bundle update" do
 
       install_gemfile <<-G
         source "#{file_uri_for(gem_repo1)}"
-        gem "rack", :git => "#{lib_path("rack-0.8")}", :branch => "master"
+        gem "rack", :git => "#{file_uri_for(lib_path("rack-0.8"))}", :branch => "main"
       G
 
       bundle %(config set local.rack #{lib_path("local-rack")})
@@ -214,27 +220,17 @@ RSpec.describe "bundle update" do
     end
 
     it "shows the previous version of the gem" do
-      build_git "rails", "3.0", :path => lib_path("rails")
+      build_git "rails", "2.3.2", :path => lib_path("rails")
 
       install_gemfile <<-G
-        gem "rails", :git => "#{lib_path("rails")}"
+        source "#{file_uri_for(gem_repo1)}"
+        gem "rails", :git => "#{file_uri_for(lib_path("rails"))}"
       G
 
-      lockfile <<-G
-        GIT
-          remote: #{lib_path("rails")}
-          specs:
-            rails (2.3.2)
-
-        PLATFORMS
-          #{generic_local_platform}
-
-        DEPENDENCIES
-          rails!
-      G
+      update_git "rails", "3.0", :path => lib_path("rails"), :gemspec => true
 
       bundle "update", :all => true
-      expect(out).to include("Using rails 3.0 (was 2.3.2) from #{lib_path("rails")} (at master@#{revision_for(lib_path("rails"))[0..6]})")
+      expect(out).to include("Using rails 3.0 (was 2.3.2) from #{file_uri_for(lib_path("rails"))} (at main@#{revision_for(lib_path("rails"))[0..6]})")
     end
   end
 
@@ -259,14 +255,12 @@ RSpec.describe "bundle update" do
 
       bundle "update --source foo"
 
-      in_app_root do
-        run <<-RUBY
-          require 'foo'
-          puts "WIN" if defined?(FOO_PREV_REF)
-        RUBY
+      run <<-RUBY
+        require 'foo'
+        puts "WIN" if defined?(FOO_PREV_REF)
+      RUBY
 
-        expect(out).to eq("WIN")
-      end
+      expect(out).to eq("WIN")
     end
 
     it "unlocks gems that were originally pulled in by the source" do
@@ -299,43 +293,7 @@ RSpec.describe "bundle update" do
       G
     end
 
-    it "the --source flag updates version of gems that were originally pulled in by the source", :bundler => "< 3" do
-      spec_lines = lib_path("bar/foo.gemspec").read.split("\n")
-      spec_lines[5] = "s.version = '2.0'"
-
-      update_git "foo", "2.0", :path => @git.path do |s|
-        s.write "foo.gemspec", spec_lines.join("\n")
-      end
-
-      ref = @git.ref_for "master"
-
-      bundle "update --source bar"
-
-      lockfile_should_be <<-G
-        GIT
-          remote: #{@git.path}
-          revision: #{ref}
-          specs:
-            foo (2.0)
-
-        GEM
-          remote: #{file_uri_for(gem_repo2)}/
-          specs:
-            rack (1.0.0)
-
-        PLATFORMS
-          #{lockfile_platforms}
-
-        DEPENDENCIES
-          foo!
-          rack
-
-        BUNDLED WITH
-           #{Bundler::VERSION}
-      G
-    end
-
-    it "the --source flag updates version of gems that were originally pulled in by the source", :bundler => "3" do
+    it "the --source flag updates version of gems that were originally pulled in by the source" do
       spec_lines = lib_path("bar/foo.gemspec").read.split("\n")
       spec_lines[5] = "s.version = '2.0'"
 
@@ -343,11 +301,11 @@ RSpec.describe "bundle update" do
         s.write "foo.gemspec", spec_lines.join("\n")
       end
 
-      ref = @git.ref_for "master"
+      ref = @git.ref_for "main"
 
       bundle "update --source bar"
 
-      lockfile_should_be <<-G
+      expect(lockfile).to eq <<~G
         GIT
           remote: #{@git.path}
           revision: #{ref}
--- ruby2.7-2.7.6.orig/spec/bundler/update/path_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/update/path_spec.rb
@@ -6,6 +6,7 @@ RSpec.describe "path sources" do
       build_lib "activesupport", "2.3.5", :path => lib_path("rails/activesupport")
 
       install_gemfile <<-G
+      source "#{file_uri_for(gem_repo1)}"
       gem "activesupport", :path => "#{lib_path("rails/activesupport")}"
       G
 
--- ruby2.7-2.7.6.orig/spec/bundler/update/redownload_spec.rb
+++ ruby2.7-2.7.6/spec/bundler/update/redownload_spec.rb
@@ -10,24 +10,24 @@ RSpec.describe "bundle update" do
 
   describe "with --force" do
     it "shows a deprecation when single flag passed", :bundler => 2 do
-      bundle! "update rack --force"
+      bundle "update rack --force"
       expect(err).to include "[DEPRECATED] The `--force` option has been renamed to `--redownload`"
     end
 
     it "shows a deprecation when multiple flags passed", :bundler => 2 do
-      bundle! "update rack --no-color --force"
+      bundle "update rack --no-color --force"
       expect(err).to include "[DEPRECATED] The `--force` option has been renamed to `--redownload`"
     end
   end
 
   describe "with --redownload" do
     it "does not show a deprecation when single flag passed" do
-      bundle! "update rack --redownload"
+      bundle "update rack --redownload"
       expect(err).not_to include "[DEPRECATED] The `--force` option has been renamed to `--redownload`"
     end
 
     it "does not show a deprecation when single multiple flags passed" do
-      bundle! "update rack --no-color --redownload"
+      bundle "update rack --no-color --redownload"
       expect(err).not_to include "[DEPRECATED] The `--force` option has been renamed to `--redownload`"
     end
   end
--- /dev/null
+++ ruby2.7-2.7.6/tool/bundler/rubocop_gems.rb
@@ -0,0 +1,11 @@
+# frozen_string_literal: true
+
+source "https://rubygems.org"
+
+gem "rubocop", "~> 1.7"
+
+gem "minitest"
+gem "rake"
+gem "rake-compiler"
+gem "rspec"
+gem "test-unit"
--- /dev/null
+++ ruby2.7-2.7.6/tool/bundler/rubocop_gems.rb.lock
@@ -0,0 +1,66 @@
+GEM
+  remote: https://rubygems.org/
+  specs:
+    ast (2.4.2)
+    diff-lcs (1.5.0)
+    minitest (5.15.0)
+    parallel (1.21.0)
+    parser (3.1.0.0)
+      ast (~> 2.4.1)
+    power_assert (2.0.1)
+    rainbow (3.1.1)
+    rake (13.0.6)
+    rake-compiler (1.1.7)
+      rake
+    regexp_parser (2.2.0)
+    rexml (3.2.5)
+    rspec (3.10.0)
+      rspec-core (~> 3.10.0)
+      rspec-expectations (~> 3.10.0)
+      rspec-mocks (~> 3.10.0)
+    rspec-core (3.10.1)
+      rspec-support (~> 3.10.0)
+    rspec-expectations (3.10.1)
+      diff-lcs (>= 1.2.0, < 2.0)
+      rspec-support (~> 3.10.0)
+    rspec-mocks (3.10.2)
+      diff-lcs (>= 1.2.0, < 2.0)
+      rspec-support (~> 3.10.0)
+    rspec-support (3.10.3)
+    rubocop (1.24.1)
+      parallel (~> 1.10)
+      parser (>= 3.0.0.0)
+      rainbow (>= 2.2.2, < 4.0)
+      regexp_parser (>= 1.8, < 3.0)
+      rexml
+      rubocop-ast (>= 1.15.1, < 2.0)
+      ruby-progressbar (~> 1.7)
+      unicode-display_width (>= 1.4.0, < 3.0)
+    rubocop-ast (1.15.1)
+      parser (>= 3.0.1.1)
+    ruby-progressbar (1.11.0)
+    test-unit (3.5.3)
+      power_assert
+    unicode-display_width (2.1.0)
+
+PLATFORMS
+  aarch64-linux
+  arm64-darwin-20
+  arm64-darwin-21
+  universal-java-11
+  universal-java-18
+  x64-mingw-ucrt
+  x86_64-darwin-19
+  x86_64-darwin-20
+  x86_64-linux
+
+DEPENDENCIES
+  minitest
+  rake
+  rake-compiler
+  rspec
+  rubocop (~> 1.7)
+  test-unit
+
+BUNDLED WITH
+   2.3.22
--- /dev/null
+++ ruby2.7-2.7.6/tool/bundler/standard_gems.rb
@@ -0,0 +1,11 @@
+# frozen_string_literal: true
+
+source "https://rubygems.org"
+
+gem "standard", "~> 1.0"
+
+gem "minitest"
+gem "rake"
+gem "rake-compiler"
+gem "rspec"
+gem "test-unit"
--- /dev/null
+++ ruby2.7-2.7.6/tool/bundler/standard_gems.rb.lock
@@ -0,0 +1,72 @@
+GEM
+  remote: https://rubygems.org/
+  specs:
+    ast (2.4.2)
+    diff-lcs (1.5.0)
+    minitest (5.15.0)
+    parallel (1.21.0)
+    parser (3.1.0.0)
+      ast (~> 2.4.1)
+    power_assert (2.0.1)
+    rainbow (3.1.1)
+    rake (13.0.6)
+    rake-compiler (1.1.7)
+      rake
+    regexp_parser (2.2.0)
+    rexml (3.2.5)
+    rspec (3.10.0)
+      rspec-core (~> 3.10.0)
+      rspec-expectations (~> 3.10.0)
+      rspec-mocks (~> 3.10.0)
+    rspec-core (3.10.1)
+      rspec-support (~> 3.10.0)
+    rspec-expectations (3.10.1)
+      diff-lcs (>= 1.2.0, < 2.0)
+      rspec-support (~> 3.10.0)
+    rspec-mocks (3.10.2)
+      diff-lcs (>= 1.2.0, < 2.0)
+      rspec-support (~> 3.10.0)
+    rspec-support (3.10.3)
+    rubocop (1.24.1)
+      parallel (~> 1.10)
+      parser (>= 3.0.0.0)
+      rainbow (>= 2.2.2, < 4.0)
+      regexp_parser (>= 1.8, < 3.0)
+      rexml
+      rubocop-ast (>= 1.15.1, < 2.0)
+      ruby-progressbar (~> 1.7)
+      unicode-display_width (>= 1.4.0, < 3.0)
+    rubocop-ast (1.15.1)
+      parser (>= 3.0.1.1)
+    rubocop-performance (1.13.1)
+      rubocop (>= 1.7.0, < 2.0)
+      rubocop-ast (>= 0.4.0)
+    ruby-progressbar (1.11.0)
+    standard (1.6.0)
+      rubocop (= 1.24.1)
+      rubocop-performance (= 1.13.1)
+    test-unit (3.5.3)
+      power_assert
+    unicode-display_width (2.1.0)
+
+PLATFORMS
+  aarch64-linux
+  arm64-darwin-20
+  arm64-darwin-21
+  universal-java-11
+  universal-java-18
+  x64-mingw-ucrt
+  x86_64-darwin-19
+  x86_64-darwin-20
+  x86_64-linux
+
+DEPENDENCIES
+  minitest
+  rake
+  rake-compiler
+  rspec
+  standard (~> 1.0)
+  test-unit
+
+BUNDLED WITH
+   2.3.22
--- /dev/null
+++ ruby2.7-2.7.6/tool/bundler/test_gems.rb
@@ -0,0 +1,12 @@
+# frozen_string_literal: true
+
+source "https://rubygems.org"
+
+gem "rack", "2.0.8"
+gem "webrick", "1.7.0"
+gem "rack-test", "~> 1.1"
+gem "artifice", "~> 0.6.0"
+gem "compact_index", "~> 0.13.0"
+gem "sinatra", "~> 2.0"
+gem "rake", "13.0.1"
+gem "builder", "~> 3.2"
--- /dev/null
+++ ruby2.7-2.7.6/tool/bundler/test_gems.rb.lock
@@ -0,0 +1,46 @@
+GEM
+  remote: https://rubygems.org/
+  specs:
+    artifice (0.6)
+      rack-test
+    builder (3.2.4)
+    compact_index (0.13.0)
+    mustermann (1.1.1)
+      ruby2_keywords (~> 0.0.1)
+    rack (2.0.8)
+    rack-protection (2.0.8.1)
+      rack
+    rack-test (1.1.0)
+      rack (>= 1.0, < 3)
+    rake (13.0.1)
+    ruby2_keywords (0.0.5)
+    sinatra (2.0.8.1)
+      mustermann (~> 1.0)
+      rack (~> 2.0)
+      rack-protection (= 2.0.8.1)
+      tilt (~> 2.0)
+    tilt (2.0.10)
+    webrick (1.7.0)
+
+PLATFORMS
+  java
+  ruby
+  universal-java-11
+  universal-java-18
+  x64-mingw-ucrt
+  x64-mingw32
+  x86_64-darwin-20
+  x86_64-linux
+
+DEPENDENCIES
+  artifice (~> 0.6.0)
+  builder (~> 3.2)
+  compact_index (~> 0.13.0)
+  rack (= 2.0.8)
+  rack-test (~> 1.1)
+  rake (= 13.0.1)
+  sinatra (~> 2.0)
+  webrick (= 1.7.0)
+
+BUNDLED WITH
+   2.3.22
--- ruby2.7-2.7.6.orig/tool/sync_default_gems.rb
+++ ruby2.7-2.7.6/tool/sync_default_gems.rb
@@ -56,7 +56,7 @@ include FileUtils
 
 $repositories = {
   rubygems: 'rubygems/rubygems',
-  bundler: 'bundler/bundler',
+  bundler: 'rubygems/rubygems',
   rdoc: 'ruby/rdoc',
   reline: 'ruby/reline',
   json: 'flori/json',
@@ -117,12 +117,15 @@ def sync_default_gems(gem)
     cp_r(Dir.glob("#{upstream}/lib/rubygems*"), "lib")
     cp_r("#{upstream}/test/rubygems", "test")
   when "bundler"
-    rm_rf(%w[lib/bundler* libexec/bundler libexec/bundle spec/bundler man/bundle* man/gemfile*])
-    cp_r(Dir.glob("#{upstream}/lib/bundler*"), "lib")
-    cp_r(Dir.glob("#{upstream}/exe/bundle*"), "libexec")
-    cp_r("#{upstream}/bundler.gemspec", "lib/bundler")
-    cp_r("#{upstream}/spec", "spec/bundler")
-    cp_r(Dir.glob("#{upstream}/man/*.{1,5,1\.txt,5\.txt,ronn}"), "man")
+    rm_rf(%w[lib/bundler lib/bundler.rb libexec/bundler libexec/bundle spec/bundler tool/bundler/*] + Dir.glob("man/{bundle*,gemfile*}"))
+    cp_r(Dir.glob("#{upstream}/bundler/lib/bundler*"), "lib")
+    cp_r(Dir.glob("#{upstream}/bundler/exe/bundle*"), "libexec")
+    cp_r("#{upstream}/bundler/bundler.gemspec", "lib/bundler")
+    cp_r("#{upstream}/bundler/spec", "spec/bundler")
+    cp_r(Dir.glob("#{upstream}/bundler/tool/bundler/test_gems*"), "tool/bundler")
+    cp_r(Dir.glob("#{upstream}/bundler/tool/bundler/rubocop_gems*"), "tool/bundler")
+    cp_r(Dir.glob("#{upstream}/bundler/tool/bundler/standard_gems*"), "tool/bundler")
+    cp_r(Dir.glob("#{upstream}/bundler/man/*.{1,5,1\.txt,5\.txt,ronn}"), "man")
     rm_rf(%w[spec/bundler/support/artifice/vcr_cassettes])
   when "rdoc"
     rm_rf(%w[lib/rdoc* test/rdoc libexec/rdoc libexec/ri])
